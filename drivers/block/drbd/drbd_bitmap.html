<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › block › drbd › drbd_bitmap.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>drbd_bitmap.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm">   drbd_bitmap.c</span>

<span class="cm">   This file is part of DRBD by Philipp Reisner and Lars Ellenberg.</span>

<span class="cm">   Copyright (C) 2004-2008, LINBIT Information Technologies GmbH.</span>
<span class="cm">   Copyright (C) 2004-2008, Philipp Reisner &lt;philipp.reisner@linbit.com&gt;.</span>
<span class="cm">   Copyright (C) 2004-2008, Lars Ellenberg &lt;lars.ellenberg@linbit.com&gt;.</span>

<span class="cm">   drbd is free software; you can redistribute it and/or modify</span>
<span class="cm">   it under the terms of the GNU General Public License as published by</span>
<span class="cm">   the Free Software Foundation; either version 2, or (at your option)</span>
<span class="cm">   any later version.</span>

<span class="cm">   drbd is distributed in the hope that it will be useful,</span>
<span class="cm">   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm">   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm">   GNU General Public License for more details.</span>

<span class="cm">   You should have received a copy of the GNU General Public License</span>
<span class="cm">   along with drbd; see the file COPYING.  If not, write to</span>
<span class="cm">   the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;linux/vmalloc.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/drbd.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;asm/kmap_types.h&gt;</span>

<span class="cp">#include &quot;drbd_int.h&quot;</span>


<span class="cm">/* OPAQUE outside this file!</span>
<span class="cm"> * interface defined in drbd_int.h</span>

<span class="cm"> * convention:</span>
<span class="cm"> * function name drbd_bm_... =&gt; used elsewhere, &quot;public&quot;.</span>
<span class="cm"> * function name      bm_... =&gt; internal to implementation, &quot;private&quot;.</span>
<span class="cm"> */</span>


<span class="cm">/*</span>
<span class="cm"> * LIMITATIONS:</span>
<span class="cm"> * We want to support &gt;= peta byte of backend storage, while for now still using</span>
<span class="cm"> * a granularity of one bit per 4KiB of storage.</span>
<span class="cm"> * 1 &lt;&lt; 50		bytes backend storage (1 PiB)</span>
<span class="cm"> * 1 &lt;&lt; (50 - 12)	bits needed</span>
<span class="cm"> *	38 --&gt; we need u64 to index and count bits</span>
<span class="cm"> * 1 &lt;&lt; (38 - 3)	bitmap bytes needed</span>
<span class="cm"> *	35 --&gt; we still need u64 to index and count bytes</span>
<span class="cm"> *			(that&#39;s 32 GiB of bitmap for 1 PiB storage)</span>
<span class="cm"> * 1 &lt;&lt; (35 - 2)	32bit longs needed</span>
<span class="cm"> *	33 --&gt; we&#39;d even need u64 to index and count 32bit long words.</span>
<span class="cm"> * 1 &lt;&lt; (35 - 3)	64bit longs needed</span>
<span class="cm"> *	32 --&gt; we could get away with a 32bit unsigned int to index and count</span>
<span class="cm"> *	64bit long words, but I rather stay with unsigned long for now.</span>
<span class="cm"> *	We probably should neither count nor point to bytes or long words</span>
<span class="cm"> *	directly, but either by bitnumber, or by page index and offset.</span>
<span class="cm"> * 1 &lt;&lt; (35 - 12)</span>
<span class="cm"> *	22 --&gt; we need that much 4KiB pages of bitmap.</span>
<span class="cm"> *	1 &lt;&lt; (22 + 3) --&gt; on a 64bit arch,</span>
<span class="cm"> *	we need 32 MiB to store the array of page pointers.</span>
<span class="cm"> *</span>
<span class="cm"> * Because I&#39;m lazy, and because the resulting patch was too large, too ugly</span>
<span class="cm"> * and still incomplete, on 32bit we still &quot;only&quot; support 16 TiB (minus some),</span>
<span class="cm"> * (1 &lt;&lt; 32) bits * 4k storage.</span>
<span class="cm"> *</span>

<span class="cm"> * bitmap storage and IO:</span>
<span class="cm"> *	Bitmap is stored little endian on disk, and is kept little endian in</span>
<span class="cm"> *	core memory. Currently we still hold the full bitmap in core as long</span>
<span class="cm"> *	as we are &quot;attached&quot; to a local disk, which at 32 GiB for 1PiB storage</span>
<span class="cm"> *	seems excessive.</span>
<span class="cm"> *</span>
<span class="cm"> *	We plan to reduce the amount of in-core bitmap pages by paging them in</span>
<span class="cm"> *	and out against their on-disk location as necessary, but need to make</span>
<span class="cm"> *	sure we don&#39;t cause too much meta data IO, and must not deadlock in</span>
<span class="cm"> *	tight memory situations. This needs some more work.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * NOTE</span>
<span class="cm"> *  Access to the *bm_pages is protected by bm_lock.</span>
<span class="cm"> *  It is safe to read the other members within the lock.</span>
<span class="cm"> *</span>
<span class="cm"> *  drbd_bm_set_bits is called from bio_endio callbacks,</span>
<span class="cm"> *  We may be called with irq already disabled,</span>
<span class="cm"> *  so we need spin_lock_irqsave().</span>
<span class="cm"> *  And we need the kmap_atomic.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">drbd_bitmap</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">bm_pages</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">bm_lock</span><span class="p">;</span>

	<span class="cm">/* see LIMITATIONS: above */</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bm_set</span><span class="p">;</span>       <span class="cm">/* nr of set bits; THINK maybe atomic_t? */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bm_bits</span><span class="p">;</span>
	<span class="kt">size_t</span>   <span class="n">bm_words</span><span class="p">;</span>
	<span class="kt">size_t</span>   <span class="n">bm_number_of_pages</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">bm_dev_capacity</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">bm_change</span><span class="p">;</span> <span class="cm">/* serializes resize operations */</span>

	<span class="n">wait_queue_head_t</span> <span class="n">bm_io_wait</span><span class="p">;</span> <span class="cm">/* used to serialize IO of single pages */</span>

	<span class="k">enum</span> <span class="n">bm_flag</span> <span class="n">bm_flags</span><span class="p">;</span>

	<span class="cm">/* debugging aid, in case we are still racy somewhere */</span>
	<span class="kt">char</span>          <span class="o">*</span><span class="n">bm_why</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">bm_task</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define bm_print_lock_info(m) __bm_print_lock_info(m, __func__)</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__bm_print_lock_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">func</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drbd_bitmap</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">mdev</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">__ratelimit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drbd_ratelimit_state</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">dev_err</span><span class="p">(</span><span class="n">DEV</span><span class="p">,</span> <span class="s">&quot;FIXME %s in %s, bitmap locked for &#39;%s&#39; by %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	    <span class="n">current</span> <span class="o">==</span> <span class="n">mdev</span><span class="o">-&gt;</span><span class="n">receiver</span><span class="p">.</span><span class="n">task</span> <span class="o">?</span> <span class="s">&quot;receiver&quot;</span> <span class="o">:</span>
	    <span class="n">current</span> <span class="o">==</span> <span class="n">mdev</span><span class="o">-&gt;</span><span class="n">asender</span><span class="p">.</span><span class="n">task</span>  <span class="o">?</span> <span class="s">&quot;asender&quot;</span>  <span class="o">:</span>
	    <span class="n">current</span> <span class="o">==</span> <span class="n">mdev</span><span class="o">-&gt;</span><span class="n">worker</span><span class="p">.</span><span class="n">task</span>   <span class="o">?</span> <span class="s">&quot;worker&quot;</span>   <span class="o">:</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span>
	    <span class="n">func</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_why</span> <span class="o">?:</span> <span class="s">&quot;?&quot;</span><span class="p">,</span>
	    <span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_task</span> <span class="o">==</span> <span class="n">mdev</span><span class="o">-&gt;</span><span class="n">receiver</span><span class="p">.</span><span class="n">task</span> <span class="o">?</span> <span class="s">&quot;receiver&quot;</span> <span class="o">:</span>
	    <span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_task</span> <span class="o">==</span> <span class="n">mdev</span><span class="o">-&gt;</span><span class="n">asender</span><span class="p">.</span><span class="n">task</span>  <span class="o">?</span> <span class="s">&quot;asender&quot;</span>  <span class="o">:</span>
	    <span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_task</span> <span class="o">==</span> <span class="n">mdev</span><span class="o">-&gt;</span><span class="n">worker</span><span class="p">.</span><span class="n">task</span>   <span class="o">?</span> <span class="s">&quot;worker&quot;</span>   <span class="o">:</span> <span class="s">&quot;?&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">drbd_bm_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">why</span><span class="p">,</span> <span class="k">enum</span> <span class="n">bm_flag</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drbd_bitmap</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">mdev</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">trylock_failed</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">DEV</span><span class="p">,</span> <span class="s">&quot;FIXME no bitmap in drbd_bm_lock!?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">trylock_failed</span> <span class="o">=</span> <span class="o">!</span><span class="n">mutex_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_change</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">trylock_failed</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">DEV</span><span class="p">,</span> <span class="s">&quot;%s going to &#39;%s&#39; but bitmap already locked for &#39;%s&#39; by %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		    <span class="n">current</span> <span class="o">==</span> <span class="n">mdev</span><span class="o">-&gt;</span><span class="n">receiver</span><span class="p">.</span><span class="n">task</span> <span class="o">?</span> <span class="s">&quot;receiver&quot;</span> <span class="o">:</span>
		    <span class="n">current</span> <span class="o">==</span> <span class="n">mdev</span><span class="o">-&gt;</span><span class="n">asender</span><span class="p">.</span><span class="n">task</span>  <span class="o">?</span> <span class="s">&quot;asender&quot;</span>  <span class="o">:</span>
		    <span class="n">current</span> <span class="o">==</span> <span class="n">mdev</span><span class="o">-&gt;</span><span class="n">worker</span><span class="p">.</span><span class="n">task</span>   <span class="o">?</span> <span class="s">&quot;worker&quot;</span>   <span class="o">:</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span>
		    <span class="n">why</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_why</span> <span class="o">?:</span> <span class="s">&quot;?&quot;</span><span class="p">,</span>
		    <span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_task</span> <span class="o">==</span> <span class="n">mdev</span><span class="o">-&gt;</span><span class="n">receiver</span><span class="p">.</span><span class="n">task</span> <span class="o">?</span> <span class="s">&quot;receiver&quot;</span> <span class="o">:</span>
		    <span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_task</span> <span class="o">==</span> <span class="n">mdev</span><span class="o">-&gt;</span><span class="n">asender</span><span class="p">.</span><span class="n">task</span>  <span class="o">?</span> <span class="s">&quot;asender&quot;</span>  <span class="o">:</span>
		    <span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_task</span> <span class="o">==</span> <span class="n">mdev</span><span class="o">-&gt;</span><span class="n">worker</span><span class="p">.</span><span class="n">task</span>   <span class="o">?</span> <span class="s">&quot;worker&quot;</span>   <span class="o">:</span> <span class="s">&quot;?&quot;</span><span class="p">);</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_change</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">BM_LOCKED_MASK</span> <span class="o">&amp;</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_flags</span><span class="p">)</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">DEV</span><span class="p">,</span> <span class="s">&quot;FIXME bitmap already locked in bm_lock</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_flags</span> <span class="o">|=</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BM_LOCKED_MASK</span><span class="p">;</span>

	<span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_why</span>  <span class="o">=</span> <span class="n">why</span><span class="p">;</span>
	<span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_task</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">drbd_bm_unlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drbd_bitmap</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">mdev</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">DEV</span><span class="p">,</span> <span class="s">&quot;FIXME no bitmap in drbd_bm_unlock!?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">BM_LOCKED_MASK</span> <span class="o">&amp;</span> <span class="n">mdev</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="o">-&gt;</span><span class="n">bm_flags</span><span class="p">))</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">DEV</span><span class="p">,</span> <span class="s">&quot;FIXME bitmap not locked in bm_unlock</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">BM_LOCKED_MASK</span><span class="p">;</span>
	<span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_why</span>  <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_task</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_change</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* we store some &quot;meta&quot; info about our pages in page-&gt;private */</span>
<span class="cm">/* at a granularity of 4k storage per bitmap bit:</span>
<span class="cm"> * one peta byte storage: 1&lt;&lt;50 byte, 1&lt;&lt;38 * 4k storage blocks</span>
<span class="cm"> *  1&lt;&lt;38 bits,</span>
<span class="cm"> *  1&lt;&lt;23 4k bitmap pages.</span>
<span class="cm"> * Use 24 bits as page index, covers 2 peta byte storage</span>
<span class="cm"> * at a granularity of 4k per bit.</span>
<span class="cm"> * Used to report the failed page idx on io error from the endio handlers.</span>
<span class="cm"> */</span>
<span class="cp">#define BM_PAGE_IDX_MASK	((1UL&lt;&lt;24)-1)</span>
<span class="cm">/* this page is currently read in, or written back */</span>
<span class="cp">#define BM_PAGE_IO_LOCK		31</span>
<span class="cm">/* if there has been an IO error for this page */</span>
<span class="cp">#define BM_PAGE_IO_ERROR	30</span>
<span class="cm">/* this is to be able to intelligently skip disk IO,</span>
<span class="cm"> * set if bits have been set since last IO. */</span>
<span class="cp">#define BM_PAGE_NEED_WRITEOUT	29</span>
<span class="cm">/* to mark for lazy writeout once syncer cleared all clearable bits,</span>
<span class="cm"> * we if bits have been cleared since last IO. */</span>
<span class="cp">#define BM_PAGE_LAZY_WRITEOUT	28</span>

<span class="cm">/* store_page_idx uses non-atomic assignment. It is only used directly after</span>
<span class="cm"> * allocating the page.  All other bm_set_page_* and bm_clear_page_* need to</span>
<span class="cm"> * use atomic bit manipulation, as set_out_of_sync (and therefore bitmap</span>
<span class="cm"> * changes) may happen from various contexts, and wait_on_bit/wake_up_bit</span>
<span class="cm"> * requires it all to be atomic as well. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">bm_store_page_idx</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="mi">0</span> <span class="o">!=</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">BM_PAGE_IDX_MASK</span><span class="p">));</span>
	<span class="n">set_page_private</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">bm_page_to_idx</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">page_private</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">BM_PAGE_IDX_MASK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* As is very unlikely that the same page is under IO from more than one</span>
<span class="cm"> * context, we can get away with a bit per page and one wait queue per bitmap.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">bm_page_lock_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">page_nr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drbd_bitmap</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">mdev</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">page_private</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_pages</span><span class="p">[</span><span class="n">page_nr</span><span class="p">]);</span>
	<span class="n">wait_event</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_io_wait</span><span class="p">,</span> <span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">BM_PAGE_IO_LOCK</span><span class="p">,</span> <span class="n">addr</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bm_page_unlock_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">page_nr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drbd_bitmap</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">mdev</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">page_private</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_pages</span><span class="p">[</span><span class="n">page_nr</span><span class="p">]);</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">BM_PAGE_IO_LOCK</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="n">smp_mb__after_clear_bit</span><span class="p">();</span>
	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdev</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="o">-&gt;</span><span class="n">bm_io_wait</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* set _before_ submit_io, so it may be reset due to being changed</span>
<span class="cm"> * while this page is in flight... will get submitted later again */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">bm_set_page_unchanged</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* use cmpxchg? */</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">BM_PAGE_NEED_WRITEOUT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page_private</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">BM_PAGE_LAZY_WRITEOUT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page_private</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bm_set_page_need_writeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">BM_PAGE_NEED_WRITEOUT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page_private</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">bm_test_page_unchanged</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">volatile</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">page_private</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">addr</span> <span class="o">&amp;</span> <span class="p">((</span><span class="mi">1UL</span><span class="o">&lt;&lt;</span><span class="n">BM_PAGE_NEED_WRITEOUT</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="mi">1UL</span><span class="o">&lt;&lt;</span><span class="n">BM_PAGE_LAZY_WRITEOUT</span><span class="p">)))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bm_set_page_io_err</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">BM_PAGE_IO_ERROR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page_private</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bm_clear_page_io_err</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">BM_PAGE_IO_ERROR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page_private</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bm_set_page_lazy_writeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">BM_PAGE_LAZY_WRITEOUT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page_private</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">bm_test_page_lazy_writeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">BM_PAGE_LAZY_WRITEOUT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page_private</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* on a 32bit box, this would allow for exactly (2&lt;&lt;38) bits. */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">bm_word_to_page_idx</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_bitmap</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">long_nr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* page_nr = (word*sizeof(long)) &gt;&gt; PAGE_SHIFT; */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">page_nr</span> <span class="o">=</span> <span class="n">long_nr</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">PAGE_SHIFT</span> <span class="o">-</span> <span class="n">LN2_BPL</span> <span class="o">+</span> <span class="mi">3</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">page_nr</span> <span class="o">&gt;=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_number_of_pages</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">page_nr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">bm_bit_to_page_idx</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_bitmap</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="n">u64</span> <span class="n">bitnr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* page_nr = (bitnr/8) &gt;&gt; PAGE_SHIFT; */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">page_nr</span> <span class="o">=</span> <span class="n">bitnr</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">PAGE_SHIFT</span> <span class="o">+</span> <span class="mi">3</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">page_nr</span> <span class="o">&gt;=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_number_of_pages</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">page_nr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="nf">__bm_map_pidx</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_bitmap</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_pages</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="nf">bm_map_pidx</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_bitmap</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__bm_map_pidx</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__bm_unmap</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">p_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">p_addr</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bm_unmap</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">p_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__bm_unmap</span><span class="p">(</span><span class="n">p_addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* long word offset of _bitmap_ sector */</span>
<span class="cp">#define S2W(s)	((s)&lt;&lt;(BM_EXT_SHIFT-BM_BLOCK_SHIFT-LN2_BPL))</span>
<span class="cm">/* word offset from start of bitmap to word number _in_page_</span>
<span class="cm"> * modulo longs per page</span>
<span class="cm">#define MLPP(X) ((X) % (PAGE_SIZE/sizeof(long))</span>
<span class="cm"> hm, well, Philipp thinks gcc might not optimize the % into &amp; (... - 1)</span>
<span class="cm"> so do it explicitly:</span>
<span class="cm"> */</span>
<span class="cp">#define MLPP(X) ((X) &amp; ((PAGE_SIZE/sizeof(long))-1))</span>

<span class="cm">/* Long words per page */</span>
<span class="cp">#define LWPP (PAGE_SIZE/sizeof(long))</span>

<span class="cm">/*</span>
<span class="cm"> * actually most functions herein should take a struct drbd_bitmap*, not a</span>
<span class="cm"> * struct drbd_conf*, but for the debug macros I like to have the mdev around</span>
<span class="cm"> * to be able to report device specific.</span>
<span class="cm"> */</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">bm_free_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">number</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pages</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">number</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ALERT</span> <span class="s">&quot;drbd: bm_free_pages tried to free &quot;</span>
					  <span class="s">&quot;a NULL pointer; i=%lu n=%lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					  <span class="n">i</span><span class="p">,</span> <span class="n">number</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">__free_page</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bm_vk_free</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">v</span><span class="p">)</span>
		<span class="n">vfree</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * &quot;have&quot; and &quot;want&quot; are NUMBER OF PAGES.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="nf">bm_realloc_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_bitmap</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">want</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">old_pages</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_pages</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">new_pages</span><span class="p">,</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">bytes</span><span class="p">,</span> <span class="n">vmalloced</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">have</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_number_of_pages</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">have</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">old_pages</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">have</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">old_pages</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">have</span> <span class="o">==</span> <span class="n">want</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">old_pages</span><span class="p">;</span>

	<span class="cm">/* Trying kmalloc first, falling back to vmalloc.</span>
<span class="cm">	 * GFP_KERNEL is ok, as this is done when a lower level disk is</span>
<span class="cm">	 * &quot;attached&quot; to the drbd.  Context is receiver thread or cqueue</span>
<span class="cm">	 * thread.  As we have no disk yet, we are not in the IO path,</span>
<span class="cm">	 * not even the IO path of the peer. */</span>
	<span class="n">bytes</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">)</span><span class="o">*</span><span class="n">want</span><span class="p">;</span>
	<span class="n">new_pages</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">bytes</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_pages</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">new_pages</span> <span class="o">=</span> <span class="n">vzalloc</span><span class="p">(</span><span class="n">bytes</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_pages</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">vmalloced</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">want</span> <span class="o">&gt;=</span> <span class="n">have</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">have</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">new_pages</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">old_pages</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">for</span> <span class="p">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">want</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">page</span> <span class="o">=</span> <span class="n">alloc_page</span><span class="p">(</span><span class="n">GFP_HIGHUSER</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">bm_free_pages</span><span class="p">(</span><span class="n">new_pages</span> <span class="o">+</span> <span class="n">have</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="n">have</span><span class="p">);</span>
				<span class="n">bm_vk_free</span><span class="p">(</span><span class="n">new_pages</span><span class="p">,</span> <span class="n">vmalloced</span><span class="p">);</span>
				<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* we want to know which page it is</span>
<span class="cm">			 * from the endio handlers */</span>
			<span class="n">bm_store_page_idx</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">new_pages</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">want</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">new_pages</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">old_pages</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="cm">/* NOT HERE, we are outside the spinlock!</span>
<span class="cm">		bm_free_pages(old_pages + want, have - want);</span>
<span class="cm">		*/</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vmalloced</span><span class="p">)</span>
		<span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_flags</span> <span class="o">|=</span> <span class="n">BM_P_VMALLOCED</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">BM_P_VMALLOCED</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">new_pages</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * called on driver init only. TODO call when a device is created.</span>
<span class="cm"> * allocates the drbd_bitmap, and stores it in mdev-&gt;bitmap.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">drbd_bm_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drbd_bitmap</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">mdev</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">;</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">b</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">b</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_bitmap</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">b</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_lock</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_change</span><span class="p">);</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_io_wait</span><span class="p">);</span>

	<span class="n">mdev</span><span class="o">-&gt;</span><span class="n">bitmap</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">sector_t</span> <span class="nf">drbd_bm_capacity</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ERR_IF</span><span class="p">(</span><span class="o">!</span><span class="n">mdev</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">mdev</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="o">-&gt;</span><span class="n">bm_dev_capacity</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* called on driver unload. TODO: call when a device is destroyed.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">drbd_bm_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ERR_IF</span> <span class="p">(</span><span class="o">!</span><span class="n">mdev</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
	<span class="n">bm_free_pages</span><span class="p">(</span><span class="n">mdev</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="o">-&gt;</span><span class="n">bm_pages</span><span class="p">,</span> <span class="n">mdev</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="o">-&gt;</span><span class="n">bm_number_of_pages</span><span class="p">);</span>
	<span class="n">bm_vk_free</span><span class="p">(</span><span class="n">mdev</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="o">-&gt;</span><span class="n">bm_pages</span><span class="p">,</span> <span class="p">(</span><span class="n">BM_P_VMALLOCED</span> <span class="o">&amp;</span> <span class="n">mdev</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="o">-&gt;</span><span class="n">bm_flags</span><span class="p">));</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">mdev</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">);</span>
	<span class="n">mdev</span><span class="o">-&gt;</span><span class="n">bitmap</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * since (b-&gt;bm_bits % BITS_PER_LONG) != 0,</span>
<span class="cm"> * this masks out the remaining bits.</span>
<span class="cm"> * Returns the number of bits cleared.</span>
<span class="cm"> */</span>
<span class="cp">#define BITS_PER_PAGE		(1UL &lt;&lt; (PAGE_SHIFT + 3))</span>
<span class="cp">#define BITS_PER_PAGE_MASK	(BITS_PER_PAGE - 1)</span>
<span class="cp">#define BITS_PER_LONG_MASK	(BITS_PER_LONG - 1)</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">bm_clear_surplus</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_bitmap</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mask</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">p_addr</span><span class="p">,</span> <span class="o">*</span><span class="n">bm</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cleared</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* number of bits modulo bits per page */</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_bits</span> <span class="o">&amp;</span> <span class="n">BITS_PER_PAGE_MASK</span><span class="p">);</span>
	<span class="cm">/* mask the used bits of the word containing the last bit */</span>
	<span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="n">BITS_PER_LONG_MASK</span><span class="p">))</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="cm">/* bitmap is always stored little endian,</span>
<span class="cm">	 * on disk and in core memory alike */</span>
	<span class="n">mask</span> <span class="o">=</span> <span class="n">cpu_to_lel</span><span class="p">(</span><span class="n">mask</span><span class="p">);</span>

	<span class="n">p_addr</span> <span class="o">=</span> <span class="n">bm_map_pidx</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_number_of_pages</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">bm</span> <span class="o">=</span> <span class="n">p_addr</span> <span class="o">+</span> <span class="p">(</span><span class="n">tmp</span><span class="o">/</span><span class="n">BITS_PER_LONG</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mask</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* If mask != 0, we are not exactly aligned, so bm now points</span>
<span class="cm">		 * to the long containing the last bit.</span>
<span class="cm">		 * If mask == 0, bm already points to the word immediately</span>
<span class="cm">		 * after the last (long word aligned) bit. */</span>
		<span class="n">cleared</span> <span class="o">=</span> <span class="n">hweight_long</span><span class="p">(</span><span class="o">*</span><span class="n">bm</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">mask</span><span class="p">);</span>
		<span class="o">*</span><span class="n">bm</span> <span class="o">&amp;=</span> <span class="n">mask</span><span class="p">;</span>
		<span class="n">bm</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">BITS_PER_LONG</span> <span class="o">==</span> <span class="mi">32</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">bm</span> <span class="o">-</span> <span class="n">p_addr</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* on a 32bit arch, we may need to zero out</span>
<span class="cm">		 * a padding long to align with a 64bit remote */</span>
		<span class="n">cleared</span> <span class="o">+=</span> <span class="n">hweight_long</span><span class="p">(</span><span class="o">*</span><span class="n">bm</span><span class="p">);</span>
		<span class="o">*</span><span class="n">bm</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">bm_unmap</span><span class="p">(</span><span class="n">p_addr</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">cleared</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bm_set_surplus</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_bitmap</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mask</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">p_addr</span><span class="p">,</span> <span class="o">*</span><span class="n">bm</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="cm">/* number of bits modulo bits per page */</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_bits</span> <span class="o">&amp;</span> <span class="n">BITS_PER_PAGE_MASK</span><span class="p">);</span>
	<span class="cm">/* mask the used bits of the word containing the last bit */</span>
	<span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="n">BITS_PER_LONG_MASK</span><span class="p">))</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="cm">/* bitmap is always stored little endian,</span>
<span class="cm">	 * on disk and in core memory alike */</span>
	<span class="n">mask</span> <span class="o">=</span> <span class="n">cpu_to_lel</span><span class="p">(</span><span class="n">mask</span><span class="p">);</span>

	<span class="n">p_addr</span> <span class="o">=</span> <span class="n">bm_map_pidx</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_number_of_pages</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">bm</span> <span class="o">=</span> <span class="n">p_addr</span> <span class="o">+</span> <span class="p">(</span><span class="n">tmp</span><span class="o">/</span><span class="n">BITS_PER_LONG</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mask</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* If mask != 0, we are not exactly aligned, so bm now points</span>
<span class="cm">		 * to the long containing the last bit.</span>
<span class="cm">		 * If mask == 0, bm already points to the word immediately</span>
<span class="cm">		 * after the last (long word aligned) bit. */</span>
		<span class="o">*</span><span class="n">bm</span> <span class="o">|=</span> <span class="o">~</span><span class="n">mask</span><span class="p">;</span>
		<span class="n">bm</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">BITS_PER_LONG</span> <span class="o">==</span> <span class="mi">32</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">bm</span> <span class="o">-</span> <span class="n">p_addr</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* on a 32bit arch, we may need to zero out</span>
<span class="cm">		 * a padding long to align with a 64bit remote */</span>
		<span class="o">*</span><span class="n">bm</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0UL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">bm_unmap</span><span class="p">(</span><span class="n">p_addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* you better not modify the bitmap while this is running,</span>
<span class="cm"> * or its results will be stale */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">bm_count_bits</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_bitmap</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">p_addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_bits</span> <span class="o">&amp;</span> <span class="n">BITS_PER_LONG_MASK</span><span class="p">))</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">last_word</span><span class="p">;</span>

	<span class="cm">/* all but last page */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_number_of_pages</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">idx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">p_addr</span> <span class="o">=</span> <span class="n">__bm_map_pidx</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">LWPP</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">bits</span> <span class="o">+=</span> <span class="n">hweight_long</span><span class="p">(</span><span class="n">p_addr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">__bm_unmap</span><span class="p">(</span><span class="n">p_addr</span><span class="p">);</span>
		<span class="n">cond_resched</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="cm">/* last (or only) page */</span>
	<span class="n">last_word</span> <span class="o">=</span> <span class="p">((</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_bits</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">BITS_PER_PAGE_MASK</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">LN2_BPL</span><span class="p">;</span>
	<span class="n">p_addr</span> <span class="o">=</span> <span class="n">__bm_map_pidx</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">last_word</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">bits</span> <span class="o">+=</span> <span class="n">hweight_long</span><span class="p">(</span><span class="n">p_addr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="n">p_addr</span><span class="p">[</span><span class="n">last_word</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="n">cpu_to_lel</span><span class="p">(</span><span class="n">mask</span><span class="p">);</span>
	<span class="n">bits</span> <span class="o">+=</span> <span class="n">hweight_long</span><span class="p">(</span><span class="n">p_addr</span><span class="p">[</span><span class="n">last_word</span><span class="p">]);</span>
	<span class="cm">/* 32bit arch, may have an unused padding long */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">BITS_PER_LONG</span> <span class="o">==</span> <span class="mi">32</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">last_word</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">p_addr</span><span class="p">[</span><span class="n">last_word</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">__bm_unmap</span><span class="p">(</span><span class="n">p_addr</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">bits</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* offset and len in long words.*/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">bm_memset</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_bitmap</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">p_addr</span><span class="p">,</span> <span class="o">*</span><span class="n">bm</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">do_now</span><span class="p">,</span> <span class="n">end</span><span class="p">;</span>

	<span class="n">end</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&gt;</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_words</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ALERT</span> <span class="s">&quot;drbd: bm_memset end &gt; bm_words</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">do_now</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">LWPP</span><span class="p">),</span> <span class="n">end</span><span class="p">)</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>
		<span class="n">idx</span> <span class="o">=</span> <span class="n">bm_word_to_page_idx</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
		<span class="n">p_addr</span> <span class="o">=</span> <span class="n">bm_map_pidx</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
		<span class="n">bm</span> <span class="o">=</span> <span class="n">p_addr</span> <span class="o">+</span> <span class="n">MLPP</span><span class="p">(</span><span class="n">offset</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bm</span><span class="o">+</span><span class="n">do_now</span> <span class="o">&gt;</span> <span class="n">p_addr</span> <span class="o">+</span> <span class="n">LWPP</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ALERT</span> <span class="s">&quot;drbd: BUG BUG BUG! p_addr:%p bm:%p do_now:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">p_addr</span><span class="p">,</span> <span class="n">bm</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">do_now</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">memset</span><span class="p">(</span><span class="n">bm</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">do_now</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">));</span>
		<span class="n">bm_unmap</span><span class="p">(</span><span class="n">p_addr</span><span class="p">);</span>
		<span class="n">bm_set_page_need_writeout</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_pages</span><span class="p">[</span><span class="n">idx</span><span class="p">]);</span>
		<span class="n">offset</span> <span class="o">+=</span> <span class="n">do_now</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * make sure the bitmap has enough room for the attached storage,</span>
<span class="cm"> * if necessary, resize.</span>
<span class="cm"> * called whenever we may have changed the device size.</span>
<span class="cm"> * returns -ENOMEM if we could not allocate enough memory, 0 on success.</span>
<span class="cm"> * In case this is actually a resize, we copy the old bitmap into the new one.</span>
<span class="cm"> * Otherwise, the bitmap is initialized to all bits set.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">drbd_bm_resize</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">capacity</span><span class="p">,</span> <span class="kt">int</span> <span class="n">set_new_bits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drbd_bitmap</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">mdev</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bits</span><span class="p">,</span> <span class="n">words</span><span class="p">,</span> <span class="n">owords</span><span class="p">,</span> <span class="n">obits</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">want</span><span class="p">,</span> <span class="n">have</span><span class="p">,</span> <span class="n">onpages</span><span class="p">;</span> <span class="cm">/* number of pages */</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">npages</span><span class="p">,</span> <span class="o">**</span><span class="n">opages</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">growing</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">opages_vmalloced</span><span class="p">;</span>

	<span class="n">ERR_IF</span><span class="p">(</span><span class="o">!</span><span class="n">b</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">drbd_bm_lock</span><span class="p">(</span><span class="n">mdev</span><span class="p">,</span> <span class="s">&quot;resize&quot;</span><span class="p">,</span> <span class="n">BM_LOCKED_MASK</span><span class="p">);</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="n">DEV</span><span class="p">,</span> <span class="s">&quot;drbd_bm_resize called with capacity == %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">capacity</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">capacity</span> <span class="o">==</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_dev_capacity</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">opages_vmalloced</span> <span class="o">=</span> <span class="p">(</span><span class="n">BM_P_VMALLOCED</span> <span class="o">&amp;</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">capacity</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_lock</span><span class="p">);</span>
		<span class="n">opages</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_pages</span><span class="p">;</span>
		<span class="n">onpages</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_number_of_pages</span><span class="p">;</span>
		<span class="n">owords</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_words</span><span class="p">;</span>
		<span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_pages</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_number_of_pages</span> <span class="o">=</span>
		<span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_set</span>   <span class="o">=</span>
		<span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_bits</span>  <span class="o">=</span>
		<span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_words</span> <span class="o">=</span>
		<span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_dev_capacity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_lock</span><span class="p">);</span>
		<span class="n">bm_free_pages</span><span class="p">(</span><span class="n">opages</span><span class="p">,</span> <span class="n">onpages</span><span class="p">);</span>
		<span class="n">bm_vk_free</span><span class="p">(</span><span class="n">opages</span><span class="p">,</span> <span class="n">opages_vmalloced</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">bits</span>  <span class="o">=</span> <span class="n">BM_SECT_TO_BIT</span><span class="p">(</span><span class="n">ALIGN</span><span class="p">(</span><span class="n">capacity</span><span class="p">,</span> <span class="n">BM_SECT_PER_BIT</span><span class="p">));</span>

	<span class="cm">/* if we would use</span>
<span class="cm">	   words = ALIGN(bits,BITS_PER_LONG) &gt;&gt; LN2_BPL;</span>
<span class="cm">	   a 32bit host could present the wrong number of words</span>
<span class="cm">	   to a 64bit host.</span>
<span class="cm">	*/</span>
	<span class="n">words</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">bits</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">LN2_BPL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">get_ldev</span><span class="p">(</span><span class="n">mdev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">bits_on_disk</span> <span class="o">=</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">mdev</span><span class="o">-&gt;</span><span class="n">ldev</span><span class="o">-&gt;</span><span class="n">md</span><span class="p">.</span><span class="n">md_size_sect</span><span class="o">-</span><span class="n">MD_BM_OFFSET</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">;</span>
		<span class="n">put_ldev</span><span class="p">(</span><span class="n">mdev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bits</span> <span class="o">&gt;</span> <span class="n">bits_on_disk</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_info</span><span class="p">(</span><span class="n">DEV</span><span class="p">,</span> <span class="s">&quot;bits = %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bits</span><span class="p">);</span>
			<span class="n">dev_info</span><span class="p">(</span><span class="n">DEV</span><span class="p">,</span> <span class="s">&quot;bits_on_disk = %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bits_on_disk</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">want</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">words</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">),</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="n">have</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_number_of_pages</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">want</span> <span class="o">==</span> <span class="n">have</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">D_ASSERT</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_pages</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">npages</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_pages</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">drbd_insert_fault</span><span class="p">(</span><span class="n">mdev</span><span class="p">,</span> <span class="n">DRBD_FAULT_BM_ALLOC</span><span class="p">))</span>
			<span class="n">npages</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">npages</span> <span class="o">=</span> <span class="n">bm_realloc_pages</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">want</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">npages</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_lock</span><span class="p">);</span>
	<span class="n">opages</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_pages</span><span class="p">;</span>
	<span class="n">owords</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_words</span><span class="p">;</span>
	<span class="n">obits</span>  <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_bits</span><span class="p">;</span>

	<span class="n">growing</span> <span class="o">=</span> <span class="n">bits</span> <span class="o">&gt;</span> <span class="n">obits</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">opages</span> <span class="o">&amp;&amp;</span> <span class="n">growing</span> <span class="o">&amp;&amp;</span> <span class="n">set_new_bits</span><span class="p">)</span>
		<span class="n">bm_set_surplus</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>

	<span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_pages</span> <span class="o">=</span> <span class="n">npages</span><span class="p">;</span>
	<span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_number_of_pages</span> <span class="o">=</span> <span class="n">want</span><span class="p">;</span>
	<span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_bits</span>  <span class="o">=</span> <span class="n">bits</span><span class="p">;</span>
	<span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_words</span> <span class="o">=</span> <span class="n">words</span><span class="p">;</span>
	<span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_dev_capacity</span> <span class="o">=</span> <span class="n">capacity</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">growing</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">set_new_bits</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">bm_memset</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">owords</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="n">words</span><span class="o">-</span><span class="n">owords</span><span class="p">);</span>
			<span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_set</span> <span class="o">+=</span> <span class="n">bits</span> <span class="o">-</span> <span class="n">obits</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">bm_memset</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">owords</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="n">words</span><span class="o">-</span><span class="n">owords</span><span class="p">);</span>

	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">want</span> <span class="o">&lt;</span> <span class="n">have</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* implicit: (opages != NULL) &amp;&amp; (opages != npages) */</span>
		<span class="n">bm_free_pages</span><span class="p">(</span><span class="n">opages</span> <span class="o">+</span> <span class="n">want</span><span class="p">,</span> <span class="n">have</span> <span class="o">-</span> <span class="n">want</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">bm_clear_surplus</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>

	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">opages</span> <span class="o">!=</span> <span class="n">npages</span><span class="p">)</span>
		<span class="n">bm_vk_free</span><span class="p">(</span><span class="n">opages</span><span class="p">,</span> <span class="n">opages_vmalloced</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">growing</span><span class="p">)</span>
		<span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_set</span> <span class="o">=</span> <span class="n">bm_count_bits</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="n">DEV</span><span class="p">,</span> <span class="s">&quot;resync bitmap: bits=%lu words=%lu pages=%lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bits</span><span class="p">,</span> <span class="n">words</span><span class="p">,</span> <span class="n">want</span><span class="p">);</span>

 <span class="nl">out:</span>
	<span class="n">drbd_bm_unlock</span><span class="p">(</span><span class="n">mdev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* inherently racy:</span>
<span class="cm"> * if not protected by other means, return value may be out of date when</span>
<span class="cm"> * leaving this function...</span>
<span class="cm"> * we still need to lock it, since it is important that this returns</span>
<span class="cm"> * bm_set == 0 precisely.</span>
<span class="cm"> *</span>
<span class="cm"> * maybe bm_set should be atomic_t ?</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">_drbd_bm_total_weight</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drbd_bitmap</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">mdev</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">s</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">ERR_IF</span><span class="p">(</span><span class="o">!</span><span class="n">b</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ERR_IF</span><span class="p">(</span><span class="o">!</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_pages</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">s</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_set</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">drbd_bm_total_weight</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">s</span><span class="p">;</span>
	<span class="cm">/* if I don&#39;t have a disk, I don&#39;t know about out-of-sync status */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">get_ldev_if_state</span><span class="p">(</span><span class="n">mdev</span><span class="p">,</span> <span class="n">D_NEGOTIATING</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">s</span> <span class="o">=</span> <span class="n">_drbd_bm_total_weight</span><span class="p">(</span><span class="n">mdev</span><span class="p">);</span>
	<span class="n">put_ldev</span><span class="p">(</span><span class="n">mdev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">size_t</span> <span class="nf">drbd_bm_words</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drbd_bitmap</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">mdev</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">;</span>
	<span class="n">ERR_IF</span><span class="p">(</span><span class="o">!</span><span class="n">b</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ERR_IF</span><span class="p">(</span><span class="o">!</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_pages</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_words</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">drbd_bm_bits</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drbd_bitmap</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">mdev</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">;</span>
	<span class="n">ERR_IF</span><span class="p">(</span><span class="o">!</span><span class="n">b</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_bits</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* merge number words from buffer into the bitmap starting at offset.</span>
<span class="cm"> * buffer[i] is expected to be little endian unsigned long.</span>
<span class="cm"> * bitmap must be locked by drbd_bm_lock.</span>
<span class="cm"> * currently only used from receive_bitmap.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">drbd_bm_merge_lel</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">number</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drbd_bitmap</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">mdev</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">p_addr</span><span class="p">,</span> <span class="o">*</span><span class="n">bm</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">word</span><span class="p">,</span> <span class="n">bits</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">end</span><span class="p">,</span> <span class="n">do_now</span><span class="p">;</span>

	<span class="n">end</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">number</span><span class="p">;</span>

	<span class="n">ERR_IF</span><span class="p">(</span><span class="o">!</span><span class="n">b</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
	<span class="n">ERR_IF</span><span class="p">(</span><span class="o">!</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_pages</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">number</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_words</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">end</span>    <span class="o">&gt;</span>  <span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_words</span><span class="p">);</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_lock</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">do_now</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">offset</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">LWPP</span><span class="p">),</span> <span class="n">end</span><span class="p">)</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>
		<span class="n">idx</span> <span class="o">=</span> <span class="n">bm_word_to_page_idx</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
		<span class="n">p_addr</span> <span class="o">=</span> <span class="n">bm_map_pidx</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
		<span class="n">bm</span> <span class="o">=</span> <span class="n">p_addr</span> <span class="o">+</span> <span class="n">MLPP</span><span class="p">(</span><span class="n">offset</span><span class="p">);</span>
		<span class="n">offset</span> <span class="o">+=</span> <span class="n">do_now</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">do_now</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">bits</span> <span class="o">=</span> <span class="n">hweight_long</span><span class="p">(</span><span class="o">*</span><span class="n">bm</span><span class="p">);</span>
			<span class="n">word</span> <span class="o">=</span> <span class="o">*</span><span class="n">bm</span> <span class="o">|</span> <span class="o">*</span><span class="n">buffer</span><span class="o">++</span><span class="p">;</span>
			<span class="o">*</span><span class="n">bm</span><span class="o">++</span> <span class="o">=</span> <span class="n">word</span><span class="p">;</span>
			<span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_set</span> <span class="o">+=</span> <span class="n">hweight_long</span><span class="p">(</span><span class="n">word</span><span class="p">)</span> <span class="o">-</span> <span class="n">bits</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">bm_unmap</span><span class="p">(</span><span class="n">p_addr</span><span class="p">);</span>
		<span class="n">bm_set_page_need_writeout</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_pages</span><span class="p">[</span><span class="n">idx</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="cm">/* with 32bit &lt;-&gt; 64bit cross-platform connect</span>
<span class="cm">	 * this is only correct for current usage,</span>
<span class="cm">	 * where we _know_ that we are 64 bit aligned,</span>
<span class="cm">	 * and know that this function is used in this way, too...</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">==</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_words</span><span class="p">)</span>
		<span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_set</span> <span class="o">-=</span> <span class="n">bm_clear_surplus</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* copy number words from the bitmap starting at offset into the buffer.</span>
<span class="cm"> * buffer[i] will be little endian unsigned long.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">drbd_bm_get_lel</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">number</span><span class="p">,</span>
		     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drbd_bitmap</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">mdev</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">p_addr</span><span class="p">,</span> <span class="o">*</span><span class="n">bm</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">end</span><span class="p">,</span> <span class="n">do_now</span><span class="p">;</span>

	<span class="n">end</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">number</span><span class="p">;</span>

	<span class="n">ERR_IF</span><span class="p">(</span><span class="o">!</span><span class="n">b</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
	<span class="n">ERR_IF</span><span class="p">(</span><span class="o">!</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_pages</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_words</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">end</span>    <span class="o">&gt;</span>  <span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_words</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">number</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">DEV</span><span class="p">,</span> <span class="s">&quot;offset=%lu number=%lu bm_words=%lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span>	<span class="n">offset</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span>	<span class="n">number</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_words</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">do_now</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">offset</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">LWPP</span><span class="p">),</span> <span class="n">end</span><span class="p">)</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>
			<span class="n">p_addr</span> <span class="o">=</span> <span class="n">bm_map_pidx</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">bm_word_to_page_idx</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">offset</span><span class="p">));</span>
			<span class="n">bm</span> <span class="o">=</span> <span class="n">p_addr</span> <span class="o">+</span> <span class="n">MLPP</span><span class="p">(</span><span class="n">offset</span><span class="p">);</span>
			<span class="n">offset</span> <span class="o">+=</span> <span class="n">do_now</span><span class="p">;</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">do_now</span><span class="o">--</span><span class="p">)</span>
				<span class="o">*</span><span class="n">buffer</span><span class="o">++</span> <span class="o">=</span> <span class="o">*</span><span class="n">bm</span><span class="o">++</span><span class="p">;</span>
			<span class="n">bm_unmap</span><span class="p">(</span><span class="n">p_addr</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* set all bits in the bitmap */</span>
<span class="kt">void</span> <span class="nf">drbd_bm_set_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drbd_bitmap</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">mdev</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">;</span>
	<span class="n">ERR_IF</span><span class="p">(</span><span class="o">!</span><span class="n">b</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
	<span class="n">ERR_IF</span><span class="p">(</span><span class="o">!</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_pages</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_lock</span><span class="p">);</span>
	<span class="n">bm_memset</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_words</span><span class="p">);</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">bm_clear_surplus</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
	<span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_set</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_bits</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* clear all bits in the bitmap */</span>
<span class="kt">void</span> <span class="nf">drbd_bm_clear_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drbd_bitmap</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">mdev</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">;</span>
	<span class="n">ERR_IF</span><span class="p">(</span><span class="o">!</span><span class="n">b</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
	<span class="n">ERR_IF</span><span class="p">(</span><span class="o">!</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_pages</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_lock</span><span class="p">);</span>
	<span class="n">bm_memset</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_words</span><span class="p">);</span>
	<span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_set</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">bm_aio_ctx</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">in_flight</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">done</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">flags</span><span class="p">;</span>
<span class="cp">#define BM_AIO_COPY_PAGES	1</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kref</span> <span class="n">kref</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bm_aio_ctx_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">kref</span> <span class="o">*</span><span class="n">kref</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bm_aio_ctx</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">kref</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bm_aio_ctx</span><span class="p">,</span> <span class="n">kref</span><span class="p">);</span>

	<span class="n">put_ldev</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mdev</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* bv_page may be a copy, or may be the original */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">bm_async_io_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span> <span class="kt">int</span> <span class="n">error</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bm_aio_ctx</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drbd_bitmap</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">mdev</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">bm_page_to_idx</span><span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_io_vec</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">bv_page</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">uptodate</span> <span class="o">=</span> <span class="n">bio_flagged</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="n">BIO_UPTODATE</span><span class="p">);</span>


	<span class="cm">/* strange behavior of some lower level drivers...</span>
<span class="cm">	 * fail the request by clearing the uptodate flag,</span>
<span class="cm">	 * but do not return any error?!</span>
<span class="cm">	 * do we want to WARN() on this? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">uptodate</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BM_AIO_COPY_PAGES</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">bm_test_page_unchanged</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_pages</span><span class="p">[</span><span class="n">idx</span><span class="p">]))</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">DEV</span><span class="p">,</span> <span class="s">&quot;bitmap page idx %u changed during IO!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* ctx error will hold the completed-last non-zero error code,</span>
<span class="cm">		 * in case error codes differ. */</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="n">error</span><span class="p">;</span>
		<span class="n">bm_set_page_io_err</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_pages</span><span class="p">[</span><span class="n">idx</span><span class="p">]);</span>
		<span class="cm">/* Not identical to on disk version of it.</span>
<span class="cm">		 * Is BM_PAGE_IO_ERROR enough? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">__ratelimit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drbd_ratelimit_state</span><span class="p">))</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">DEV</span><span class="p">,</span> <span class="s">&quot;IO ERROR %d on bitmap page idx %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">error</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">bm_clear_page_io_err</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_pages</span><span class="p">[</span><span class="n">idx</span><span class="p">]);</span>
		<span class="n">dynamic_dev_dbg</span><span class="p">(</span><span class="n">DEV</span><span class="p">,</span> <span class="s">&quot;bitmap page idx %u completed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">bm_page_unlock_io</span><span class="p">(</span><span class="n">mdev</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BM_AIO_COPY_PAGES</span><span class="p">)</span>
		<span class="n">mempool_free</span><span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_io_vec</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">bv_page</span><span class="p">,</span> <span class="n">drbd_md_io_page_pool</span><span class="p">);</span>

	<span class="n">bio_put</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">in_flight</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdev</span><span class="o">-&gt;</span><span class="n">misc_wait</span><span class="p">);</span>
		<span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bm_aio_ctx_destroy</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bm_page_io_async</span><span class="p">(</span><span class="k">struct</span> <span class="n">bm_aio_ctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">page_nr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rw</span><span class="p">)</span> <span class="n">__must_hold</span><span class="p">(</span><span class="n">local</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span> <span class="o">=</span> <span class="n">bio_alloc_drbd</span><span class="p">(</span><span class="n">GFP_NOIO</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drbd_bitmap</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">mdev</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>

	<span class="n">sector_t</span> <span class="n">on_disk_sector</span> <span class="o">=</span>
		<span class="n">mdev</span><span class="o">-&gt;</span><span class="n">ldev</span><span class="o">-&gt;</span><span class="n">md</span><span class="p">.</span><span class="n">md_offset</span> <span class="o">+</span> <span class="n">mdev</span><span class="o">-&gt;</span><span class="n">ldev</span><span class="o">-&gt;</span><span class="n">md</span><span class="p">.</span><span class="n">bm_offset</span><span class="p">;</span>
	<span class="n">on_disk_sector</span> <span class="o">+=</span> <span class="p">((</span><span class="n">sector_t</span><span class="p">)</span><span class="n">page_nr</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">PAGE_SHIFT</span><span class="o">-</span><span class="mi">9</span><span class="p">);</span>

	<span class="cm">/* this might happen with very small</span>
<span class="cm">	 * flexible external meta data device,</span>
<span class="cm">	 * or with PAGE_SIZE &gt; 4k */</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span>
		<span class="p">(</span><span class="n">drbd_md_last_sector</span><span class="p">(</span><span class="n">mdev</span><span class="o">-&gt;</span><span class="n">ldev</span><span class="p">)</span> <span class="o">-</span> <span class="n">on_disk_sector</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">9</span><span class="p">);</span>

	<span class="cm">/* serialize IO on this page */</span>
	<span class="n">bm_page_lock_io</span><span class="p">(</span><span class="n">mdev</span><span class="p">,</span> <span class="n">page_nr</span><span class="p">);</span>
	<span class="cm">/* before memcpy and submit,</span>
<span class="cm">	 * so it can be redirtied any time */</span>
	<span class="n">bm_set_page_unchanged</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_pages</span><span class="p">[</span><span class="n">page_nr</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BM_AIO_COPY_PAGES</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="o">*</span><span class="n">dest</span><span class="p">;</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">drbd_md_io_page_pool</span><span class="p">,</span> <span class="n">__GFP_HIGHMEM</span><span class="o">|</span><span class="n">__GFP_WAIT</span><span class="p">);</span>
		<span class="n">dest</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">src</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_pages</span><span class="p">[</span><span class="n">page_nr</span><span class="p">]);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
		<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">src</span><span class="p">);</span>
		<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">dest</span><span class="p">);</span>
		<span class="n">bm_store_page_idx</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">page_nr</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_pages</span><span class="p">[</span><span class="n">page_nr</span><span class="p">];</span>

	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_bdev</span> <span class="o">=</span> <span class="n">mdev</span><span class="o">-&gt;</span><span class="n">ldev</span><span class="o">-&gt;</span><span class="n">md_bdev</span><span class="p">;</span>
	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_sector</span> <span class="o">=</span> <span class="n">on_disk_sector</span><span class="p">;</span>
	<span class="cm">/* bio_add_page of a single page to an empty bio will always succeed,</span>
<span class="cm">	 * according to api.  Do we want to assert that? */</span>
	<span class="n">bio_add_page</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_private</span> <span class="o">=</span> <span class="n">ctx</span><span class="p">;</span>
	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_end_io</span> <span class="o">=</span> <span class="n">bm_async_io_complete</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">drbd_insert_fault</span><span class="p">(</span><span class="n">mdev</span><span class="p">,</span> <span class="p">(</span><span class="n">rw</span> <span class="o">&amp;</span> <span class="n">WRITE</span><span class="p">)</span> <span class="o">?</span> <span class="n">DRBD_FAULT_MD_WR</span> <span class="o">:</span> <span class="n">DRBD_FAULT_MD_RD</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_rw</span> <span class="o">|=</span> <span class="n">rw</span><span class="p">;</span>
		<span class="n">bio_endio</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="o">-</span><span class="n">EIO</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">submit_bio</span><span class="p">(</span><span class="n">rw</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
		<span class="cm">/* this should not count as user activity and cause the</span>
<span class="cm">		 * resync to throttle -- see drbd_rs_should_slow_down(). */</span>
		<span class="n">atomic_add</span><span class="p">(</span><span class="n">len</span> <span class="o">&gt;&gt;</span> <span class="mi">9</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mdev</span><span class="o">-&gt;</span><span class="n">rs_sect_ev</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * bm_rw: read/write the whole bitmap from/to its on disk location.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">bm_rw</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rw</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">lazy_writeout_upper_idx</span><span class="p">)</span> <span class="n">__must_hold</span><span class="p">(</span><span class="n">local</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bm_aio_ctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drbd_bitmap</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">mdev</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_pages</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">now</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">ppb</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We are protected against bitmap disappearing/resizing by holding an</span>
<span class="cm">	 * ldev reference (caller must have called get_ldev()).</span>
<span class="cm">	 * For read/write, we are protected against changes to the bitmap by</span>
<span class="cm">	 * the bitmap lock (see drbd_bitmap_io).</span>
<span class="cm">	 * For lazy writeout, we don&#39;t care for ongoing changes to the bitmap,</span>
<span class="cm">	 * as we submit copies of pages anyways.</span>
<span class="cm">	 */</span>

	<span class="n">ctx</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">bm_aio_ctx</span><span class="p">),</span> <span class="n">GFP_NOIO</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ctx</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">bm_aio_ctx</span><span class="p">)</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">mdev</span> <span class="o">=</span> <span class="n">mdev</span><span class="p">,</span>
		<span class="p">.</span><span class="n">in_flight</span> <span class="o">=</span> <span class="n">ATOMIC_INIT</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
		<span class="p">.</span><span class="n">done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
		<span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">,</span>
		<span class="p">.</span><span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
		<span class="p">.</span><span class="n">kref</span> <span class="o">=</span> <span class="p">{</span> <span class="n">ATOMIC_INIT</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">};</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">get_ldev_if_state</span><span class="p">(</span><span class="n">mdev</span><span class="p">,</span> <span class="n">D_ATTACHING</span><span class="p">))</span> <span class="p">{</span>  <span class="cm">/* put is in bm_aio_ctx_destroy() */</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">DEV</span><span class="p">,</span> <span class="s">&quot;ASSERT FAILED: get_ldev_if_state() == 1 in bm_rw()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">BM_LOCKED_MASK</span> <span class="o">&amp;</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_flags</span><span class="p">));</span>

	<span class="n">num_pages</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_number_of_pages</span><span class="p">;</span>

	<span class="n">now</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>

	<span class="cm">/* let the layers below us try to merge these bios... */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_pages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* ignore completely unchanged pages */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lazy_writeout_upper_idx</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">==</span> <span class="n">lazy_writeout_upper_idx</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rw</span> <span class="o">&amp;</span> <span class="n">WRITE</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bm_test_page_unchanged</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_pages</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="p">{</span>
				<span class="n">dynamic_dev_dbg</span><span class="p">(</span><span class="n">DEV</span><span class="p">,</span> <span class="s">&quot;skipped bm write for idx %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* during lazy writeout,</span>
<span class="cm">			 * ignore those pages not marked for lazy writeout. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lazy_writeout_upper_idx</span> <span class="o">&amp;&amp;</span>
			    <span class="o">!</span><span class="n">bm_test_page_lazy_writeout</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_pages</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="p">{</span>
				<span class="n">dynamic_dev_dbg</span><span class="p">(</span><span class="n">DEV</span><span class="p">,</span> <span class="s">&quot;skipped bm lazy write for idx %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">in_flight</span><span class="p">);</span>
		<span class="n">bm_page_io_async</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">rw</span><span class="p">);</span>
		<span class="o">++</span><span class="n">count</span><span class="p">;</span>
		<span class="n">cond_resched</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We initialize ctx-&gt;in_flight to one to make sure bm_async_io_complete</span>
<span class="cm">	 * will not set ctx-&gt;done early, and decrement / test it here.  If there</span>
<span class="cm">	 * are still some bios in flight, we need to wait for them here.</span>
<span class="cm">	 * If all IO is done already (or nothing had been submitted), there is</span>
<span class="cm">	 * no need to wait.  Still, we need to put the kref associated with the</span>
<span class="cm">	 * &quot;in_flight reached zero, all done&quot; event.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">in_flight</span><span class="p">))</span>
		<span class="n">wait_until_done_or_disk_failure</span><span class="p">(</span><span class="n">mdev</span><span class="p">,</span> <span class="n">mdev</span><span class="o">-&gt;</span><span class="n">ldev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bm_aio_ctx_destroy</span><span class="p">);</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="n">DEV</span><span class="p">,</span> <span class="s">&quot;bitmap %s of %u pages took %lu jiffies</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">rw</span> <span class="o">==</span> <span class="n">WRITE</span> <span class="o">?</span> <span class="s">&quot;WRITE&quot;</span> <span class="o">:</span> <span class="s">&quot;READ&quot;</span><span class="p">,</span>
			<span class="n">count</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">-</span> <span class="n">now</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_alert</span><span class="p">(</span><span class="n">DEV</span><span class="p">,</span> <span class="s">&quot;we had at least one MD IO ERROR during bitmap IO</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">drbd_chk_io_error</span><span class="p">(</span><span class="n">mdev</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span> <span class="cm">/* ctx-&gt;error ? */</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">in_flight</span><span class="p">))</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span> <span class="cm">/* Disk failed during IO... */</span>

	<span class="n">now</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rw</span> <span class="o">==</span> <span class="n">WRITE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">drbd_md_flush</span><span class="p">(</span><span class="n">mdev</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="cm">/* rw == READ */</span> <span class="p">{</span>
		<span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_set</span> <span class="o">=</span> <span class="n">bm_count_bits</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="n">DEV</span><span class="p">,</span> <span class="s">&quot;recounting of set bits took additional %lu jiffies</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">jiffies</span> <span class="o">-</span> <span class="n">now</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">now</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_set</span><span class="p">;</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="n">DEV</span><span class="p">,</span> <span class="s">&quot;%s (%lu bits) marked out-of-sync by on disk bit-map.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	     <span class="n">ppsize</span><span class="p">(</span><span class="n">ppb</span><span class="p">,</span> <span class="n">now</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">BM_BLOCK_SHIFT</span><span class="o">-</span><span class="mi">10</span><span class="p">)),</span> <span class="n">now</span><span class="p">);</span>

	<span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bm_aio_ctx_destroy</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * drbd_bm_read() - Read the whole bitmap from its on disk location.</span>
<span class="cm"> * @mdev:	DRBD device.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">drbd_bm_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">)</span> <span class="n">__must_hold</span><span class="p">(</span><span class="n">local</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bm_rw</span><span class="p">(</span><span class="n">mdev</span><span class="p">,</span> <span class="n">READ</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * drbd_bm_write() - Write the whole bitmap to its on disk location.</span>
<span class="cm"> * @mdev:	DRBD device.</span>
<span class="cm"> *</span>
<span class="cm"> * Will only write pages that have changed since last IO.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">drbd_bm_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">)</span> <span class="n">__must_hold</span><span class="p">(</span><span class="n">local</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bm_rw</span><span class="p">(</span><span class="n">mdev</span><span class="p">,</span> <span class="n">WRITE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * drbd_bm_lazy_write_out() - Write bitmap pages 0 to @upper_idx-1, if they have changed.</span>
<span class="cm"> * @mdev:	DRBD device.</span>
<span class="cm"> * @upper_idx:	0: write all changed pages; +ve: page index to stop scanning for changed pages</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">drbd_bm_write_lazy</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">upper_idx</span><span class="p">)</span> <span class="n">__must_hold</span><span class="p">(</span><span class="n">local</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bm_rw</span><span class="p">(</span><span class="n">mdev</span><span class="p">,</span> <span class="n">WRITE</span><span class="p">,</span> <span class="n">BM_AIO_COPY_PAGES</span><span class="p">,</span> <span class="n">upper_idx</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * drbd_bm_write_copy_pages() - Write the whole bitmap to its on disk location.</span>
<span class="cm"> * @mdev:	DRBD device.</span>
<span class="cm"> *</span>
<span class="cm"> * Will only write pages that have changed since last IO.</span>
<span class="cm"> * In contrast to drbd_bm_write(), this will copy the bitmap pages</span>
<span class="cm"> * to temporary writeout pages. It is intended to trigger a full write-out</span>
<span class="cm"> * while still allowing the bitmap to change, for example if a resync or online</span>
<span class="cm"> * verify is aborted due to a failed peer disk, while local IO continues, or</span>
<span class="cm"> * pending resync acks are still being processed.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">drbd_bm_write_copy_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">)</span> <span class="n">__must_hold</span><span class="p">(</span><span class="n">local</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bm_rw</span><span class="p">(</span><span class="n">mdev</span><span class="p">,</span> <span class="n">WRITE</span><span class="p">,</span> <span class="n">BM_AIO_COPY_PAGES</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * drbd_bm_write_page: Writes a PAGE_SIZE aligned piece of bitmap</span>
<span class="cm"> * @mdev:	DRBD device.</span>
<span class="cm"> * @idx:	bitmap page index</span>
<span class="cm"> *</span>
<span class="cm"> * We don&#39;t want to special case on logical_block_size of the backend device,</span>
<span class="cm"> * so we submit PAGE_SIZE aligned pieces.</span>
<span class="cm"> * Note that on &quot;most&quot; systems, PAGE_SIZE is 4k.</span>
<span class="cm"> *</span>
<span class="cm"> * In case this becomes an issue on systems with larger PAGE_SIZE,</span>
<span class="cm"> * we may want to change this again to write 4k aligned 4k pieces.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">drbd_bm_write_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">)</span> <span class="n">__must_hold</span><span class="p">(</span><span class="n">local</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bm_aio_ctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bm_test_page_unchanged</span><span class="p">(</span><span class="n">mdev</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="o">-&gt;</span><span class="n">bm_pages</span><span class="p">[</span><span class="n">idx</span><span class="p">]))</span> <span class="p">{</span>
		<span class="n">dynamic_dev_dbg</span><span class="p">(</span><span class="n">DEV</span><span class="p">,</span> <span class="s">&quot;skipped bm page write for idx %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ctx</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">bm_aio_ctx</span><span class="p">),</span> <span class="n">GFP_NOIO</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ctx</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">bm_aio_ctx</span><span class="p">)</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">mdev</span> <span class="o">=</span> <span class="n">mdev</span><span class="p">,</span>
		<span class="p">.</span><span class="n">in_flight</span> <span class="o">=</span> <span class="n">ATOMIC_INIT</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
		<span class="p">.</span><span class="n">done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
		<span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">BM_AIO_COPY_PAGES</span><span class="p">,</span>
		<span class="p">.</span><span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
		<span class="p">.</span><span class="n">kref</span> <span class="o">=</span> <span class="p">{</span> <span class="n">ATOMIC_INIT</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">};</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">get_ldev_if_state</span><span class="p">(</span><span class="n">mdev</span><span class="p">,</span> <span class="n">D_ATTACHING</span><span class="p">))</span> <span class="p">{</span>  <span class="cm">/* put is in bm_aio_ctx_destroy() */</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">DEV</span><span class="p">,</span> <span class="s">&quot;ASSERT FAILED: get_ldev_if_state() == 1 in drbd_bm_write_page()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">bm_page_io_async</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">WRITE_SYNC</span><span class="p">);</span>
	<span class="n">wait_until_done_or_disk_failure</span><span class="p">(</span><span class="n">mdev</span><span class="p">,</span> <span class="n">mdev</span><span class="o">-&gt;</span><span class="n">ldev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">error</span><span class="p">)</span>
		<span class="n">drbd_chk_io_error</span><span class="p">(</span><span class="n">mdev</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
		<span class="cm">/* that should force detach, so the in memory bitmap will be</span>
<span class="cm">		 * gone in a moment as well. */</span>

	<span class="n">mdev</span><span class="o">-&gt;</span><span class="n">bm_writ_cnt</span><span class="o">++</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">in_flight</span><span class="p">)</span> <span class="o">?</span> <span class="o">-</span><span class="n">EIO</span> <span class="o">:</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">error</span><span class="p">;</span>
	<span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bm_aio_ctx_destroy</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* NOTE</span>
<span class="cm"> * find_first_bit returns int, we return unsigned long.</span>
<span class="cm"> * For this to work on 32bit arch with bitnumbers &gt; (1&lt;&lt;32),</span>
<span class="cm"> * we&#39;d need to return u64, and get a whole lot of other places</span>
<span class="cm"> * fixed where we still use unsigned long.</span>
<span class="cm"> *</span>
<span class="cm"> * this returns a bit number, NOT a sector!</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">__bm_find_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bm_fo</span><span class="p">,</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">find_zero_bit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drbd_bitmap</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">mdev</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">p_addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bit_offset</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">;</span>


	<span class="k">if</span> <span class="p">(</span><span class="n">bm_fo</span> <span class="o">&gt;</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_bits</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">DEV</span><span class="p">,</span> <span class="s">&quot;bm_fo=%lu bm_bits=%lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bm_fo</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_bits</span><span class="p">);</span>
		<span class="n">bm_fo</span> <span class="o">=</span> <span class="n">DRBD_END_OF_BITMAP</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">bm_fo</span> <span class="o">&lt;</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_bits</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* bit offset of the first bit in the page */</span>
			<span class="n">bit_offset</span> <span class="o">=</span> <span class="n">bm_fo</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">BITS_PER_PAGE_MASK</span><span class="p">;</span>
			<span class="n">p_addr</span> <span class="o">=</span> <span class="n">__bm_map_pidx</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">bm_bit_to_page_idx</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">bm_fo</span><span class="p">));</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">find_zero_bit</span><span class="p">)</span>
				<span class="n">i</span> <span class="o">=</span> <span class="n">find_next_zero_bit_le</span><span class="p">(</span><span class="n">p_addr</span><span class="p">,</span>
						<span class="n">PAGE_SIZE</span><span class="o">*</span><span class="mi">8</span><span class="p">,</span> <span class="n">bm_fo</span> <span class="o">&amp;</span> <span class="n">BITS_PER_PAGE_MASK</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">i</span> <span class="o">=</span> <span class="n">find_next_bit_le</span><span class="p">(</span><span class="n">p_addr</span><span class="p">,</span>
						<span class="n">PAGE_SIZE</span><span class="o">*</span><span class="mi">8</span><span class="p">,</span> <span class="n">bm_fo</span> <span class="o">&amp;</span> <span class="n">BITS_PER_PAGE_MASK</span><span class="p">);</span>

			<span class="n">__bm_unmap</span><span class="p">(</span><span class="n">p_addr</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">PAGE_SIZE</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">bm_fo</span> <span class="o">=</span> <span class="n">bit_offset</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">bm_fo</span> <span class="o">&gt;=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_bits</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">bm_fo</span> <span class="o">=</span> <span class="n">bit_offset</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span><span class="o">*</span><span class="mi">8</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">bm_fo</span> <span class="o">=</span> <span class="n">DRBD_END_OF_BITMAP</span><span class="p">;</span>
	<span class="p">}</span>
 <span class="nl">found:</span>
	<span class="k">return</span> <span class="n">bm_fo</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">bm_find_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bm_fo</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">find_zero_bit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drbd_bitmap</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">mdev</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span> <span class="o">=</span> <span class="n">DRBD_END_OF_BITMAP</span><span class="p">;</span>

	<span class="n">ERR_IF</span><span class="p">(</span><span class="o">!</span><span class="n">b</span><span class="p">)</span> <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">ERR_IF</span><span class="p">(</span><span class="o">!</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_pages</span><span class="p">)</span> <span class="k">return</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">BM_DONT_TEST</span> <span class="o">&amp;</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_flags</span><span class="p">)</span>
		<span class="n">bm_print_lock_info</span><span class="p">(</span><span class="n">mdev</span><span class="p">);</span>

	<span class="n">i</span> <span class="o">=</span> <span class="n">__bm_find_next</span><span class="p">(</span><span class="n">mdev</span><span class="p">,</span> <span class="n">bm_fo</span><span class="p">,</span> <span class="n">find_zero_bit</span><span class="p">);</span>

	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">drbd_bm_find_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bm_fo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bm_find_next</span><span class="p">(</span><span class="n">mdev</span><span class="p">,</span> <span class="n">bm_fo</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">/* not yet needed for anything. */</span>
<span class="c">unsigned long drbd_bm_find_next_zero(struct drbd_conf *mdev, unsigned long bm_fo)</span>
<span class="c">{</span>
<span class="c">	return bm_find_next(mdev, bm_fo, 1);</span>
<span class="c">}</span>
<span class="cp">#endif</span>

<span class="cm">/* does not spin_lock_irqsave.</span>
<span class="cm"> * you must take drbd_bm_lock() first */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">_drbd_bm_find_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bm_fo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* WARN_ON(!(BM_DONT_SET &amp; mdev-&gt;b-&gt;bm_flags)); */</span>
	<span class="k">return</span> <span class="n">__bm_find_next</span><span class="p">(</span><span class="n">mdev</span><span class="p">,</span> <span class="n">bm_fo</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">_drbd_bm_find_next_zero</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bm_fo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* WARN_ON(!(BM_DONT_SET &amp; mdev-&gt;b-&gt;bm_flags)); */</span>
	<span class="k">return</span> <span class="n">__bm_find_next</span><span class="p">(</span><span class="n">mdev</span><span class="p">,</span> <span class="n">bm_fo</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* returns number of bits actually changed.</span>
<span class="cm"> * for val != 0, we change 0 -&gt; 1, return code positive</span>
<span class="cm"> * for val == 0, we change 1 -&gt; 0, return code negative</span>
<span class="cm"> * wants bitnr, not sector.</span>
<span class="cm"> * expected to be called for only a few bits (e - s about BITS_PER_LONG).</span>
<span class="cm"> * Must hold bitmap lock already. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__bm_change_bits_to</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">s</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">e</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drbd_bitmap</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">mdev</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">p_addr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bitnr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">last_page_nr</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1U</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">changed_total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">e</span> <span class="o">&gt;=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_bits</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">DEV</span><span class="p">,</span> <span class="s">&quot;ASSERT FAILED: bit_s=%lu bit_e=%lu bm_bits=%lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">s</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_bits</span><span class="p">);</span>
		<span class="n">e</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_bits</span> <span class="o">?</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_bits</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">bitnr</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span> <span class="n">bitnr</span> <span class="o">&lt;=</span> <span class="n">e</span><span class="p">;</span> <span class="n">bitnr</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">page_nr</span> <span class="o">=</span> <span class="n">bm_bit_to_page_idx</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">bitnr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page_nr</span> <span class="o">!=</span> <span class="n">last_page_nr</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">p_addr</span><span class="p">)</span>
				<span class="n">__bm_unmap</span><span class="p">(</span><span class="n">p_addr</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">bm_set_page_lazy_writeout</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_pages</span><span class="p">[</span><span class="n">last_page_nr</span><span class="p">]);</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">bm_set_page_need_writeout</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_pages</span><span class="p">[</span><span class="n">last_page_nr</span><span class="p">]);</span>
			<span class="n">changed_total</span> <span class="o">+=</span> <span class="n">c</span><span class="p">;</span>
			<span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">p_addr</span> <span class="o">=</span> <span class="n">__bm_map_pidx</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">page_nr</span><span class="p">);</span>
			<span class="n">last_page_nr</span> <span class="o">=</span> <span class="n">page_nr</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">val</span><span class="p">)</span>
			<span class="n">c</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">__test_and_set_bit_le</span><span class="p">(</span><span class="n">bitnr</span> <span class="o">&amp;</span> <span class="n">BITS_PER_PAGE_MASK</span><span class="p">,</span> <span class="n">p_addr</span><span class="p">));</span>
		<span class="k">else</span>
			<span class="n">c</span> <span class="o">-=</span> <span class="p">(</span><span class="mi">0</span> <span class="o">!=</span> <span class="n">__test_and_clear_bit_le</span><span class="p">(</span><span class="n">bitnr</span> <span class="o">&amp;</span> <span class="n">BITS_PER_PAGE_MASK</span><span class="p">,</span> <span class="n">p_addr</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p_addr</span><span class="p">)</span>
		<span class="n">__bm_unmap</span><span class="p">(</span><span class="n">p_addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">bm_set_page_lazy_writeout</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_pages</span><span class="p">[</span><span class="n">last_page_nr</span><span class="p">]);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">bm_set_page_need_writeout</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_pages</span><span class="p">[</span><span class="n">last_page_nr</span><span class="p">]);</span>
	<span class="n">changed_total</span> <span class="o">+=</span> <span class="n">c</span><span class="p">;</span>
	<span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_set</span> <span class="o">+=</span> <span class="n">changed_total</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">changed_total</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* returns number of bits actually changed.</span>
<span class="cm"> * for val != 0, we change 0 -&gt; 1, return code positive</span>
<span class="cm"> * for val == 0, we change 1 -&gt; 0, return code negative</span>
<span class="cm"> * wants bitnr, not sector */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">bm_change_bits_to</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">s</span><span class="p">,</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">e</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drbd_bitmap</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">mdev</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ERR_IF</span><span class="p">(</span><span class="o">!</span><span class="n">b</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ERR_IF</span><span class="p">(</span><span class="o">!</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_pages</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">val</span> <span class="o">?</span> <span class="n">BM_DONT_SET</span> <span class="o">:</span> <span class="n">BM_DONT_CLEAR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_flags</span><span class="p">)</span>
		<span class="n">bm_print_lock_info</span><span class="p">(</span><span class="n">mdev</span><span class="p">);</span>

	<span class="n">c</span> <span class="o">=</span> <span class="n">__bm_change_bits_to</span><span class="p">(</span><span class="n">mdev</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">c</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* returns number of bits changed 0 -&gt; 1 */</span>
<span class="kt">int</span> <span class="nf">drbd_bm_set_bits</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">s</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bm_change_bits_to</span><span class="p">(</span><span class="n">mdev</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* returns number of bits changed 1 -&gt; 0 */</span>
<span class="kt">int</span> <span class="nf">drbd_bm_clear_bits</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">s</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">bm_change_bits_to</span><span class="p">(</span><span class="n">mdev</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* sets all bits in full words,</span>
<span class="cm"> * from first_word up to, but not including, last_word */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">bm_set_full_words_within_one_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_bitmap</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">page_nr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">first_word</span><span class="p">,</span> <span class="kt">int</span> <span class="n">last_word</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bits</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">paddr</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_pages</span><span class="p">[</span><span class="n">page_nr</span><span class="p">]);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">first_word</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">last_word</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bits</span> <span class="o">=</span> <span class="n">hweight_long</span><span class="p">(</span><span class="n">paddr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">paddr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0UL</span><span class="p">;</span>
		<span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_set</span> <span class="o">+=</span> <span class="n">BITS_PER_LONG</span> <span class="o">-</span> <span class="n">bits</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">paddr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Same thing as drbd_bm_set_bits,</span>
<span class="cm"> * but more efficient for a large bit range.</span>
<span class="cm"> * You must first drbd_bm_lock().</span>
<span class="cm"> * Can be called to set the whole bitmap in one go.</span>
<span class="cm"> * Sets bits from s to e _inclusive_. */</span>
<span class="kt">void</span> <span class="nf">_drbd_bm_set_bits</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">s</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* First set_bit from the first bit (s)</span>
<span class="cm">	 * up to the next long boundary (sl),</span>
<span class="cm">	 * then assign full words up to the last long boundary (el),</span>
<span class="cm">	 * then set_bit up to and including the last bit (e).</span>
<span class="cm">	 *</span>
<span class="cm">	 * Do not use memset, because we must account for changes,</span>
<span class="cm">	 * so we need to loop over the words with hweight() anyways.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">drbd_bitmap</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">mdev</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sl</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">BITS_PER_LONG</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">el</span> <span class="o">=</span> <span class="p">(</span><span class="n">e</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">BITS_PER_LONG</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">first_page</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">last_page</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">page_nr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">first_word</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">last_word</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">e</span> <span class="o">-</span> <span class="n">s</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="o">*</span><span class="n">BITS_PER_LONG</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* don&#39;t bother; el and sl may even be wrong. */</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_lock</span><span class="p">);</span>
		<span class="n">__bm_change_bits_to</span><span class="p">(</span><span class="n">mdev</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_lock</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* difference is large enough that we can trust sl and el */</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_lock</span><span class="p">);</span>

	<span class="cm">/* bits filling the current long */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sl</span><span class="p">)</span>
		<span class="n">__bm_change_bits_to</span><span class="p">(</span><span class="n">mdev</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">sl</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">first_page</span> <span class="o">=</span> <span class="n">sl</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">3</span> <span class="o">+</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
	<span class="n">last_page</span> <span class="o">=</span> <span class="n">el</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">3</span> <span class="o">+</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>

	<span class="cm">/* MLPP: modulo longs per page */</span>
	<span class="cm">/* LWPP: long words per page */</span>
	<span class="n">first_word</span> <span class="o">=</span> <span class="n">MLPP</span><span class="p">(</span><span class="n">sl</span> <span class="o">&gt;&gt;</span> <span class="n">LN2_BPL</span><span class="p">);</span>
	<span class="n">last_word</span> <span class="o">=</span> <span class="n">LWPP</span><span class="p">;</span>

	<span class="cm">/* first and full pages, unless first page == last page */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">page_nr</span> <span class="o">=</span> <span class="n">first_page</span><span class="p">;</span> <span class="n">page_nr</span> <span class="o">&lt;</span> <span class="n">last_page</span><span class="p">;</span> <span class="n">page_nr</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bm_set_full_words_within_one_page</span><span class="p">(</span><span class="n">mdev</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">,</span> <span class="n">page_nr</span><span class="p">,</span> <span class="n">first_word</span><span class="p">,</span> <span class="n">last_word</span><span class="p">);</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_lock</span><span class="p">);</span>
		<span class="n">cond_resched</span><span class="p">();</span>
		<span class="n">first_word</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* last page (respectively only page, for first page == last page) */</span>
	<span class="n">last_word</span> <span class="o">=</span> <span class="n">MLPP</span><span class="p">(</span><span class="n">el</span> <span class="o">&gt;&gt;</span> <span class="n">LN2_BPL</span><span class="p">);</span>

	<span class="cm">/* consider bitmap-&gt;bm_bits = 32768, bitmap-&gt;bm_number_of_pages = 1. (or multiples).</span>
<span class="cm">	 * ==&gt; e = 32767, el = 32768, last_page = 2,</span>
<span class="cm">	 * and now last_word = 0.</span>
<span class="cm">	 * We do not want to touch last_page in this case,</span>
<span class="cm">	 * as we did not allocate it, it is not present in bitmap-&gt;bm_pages.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">last_word</span><span class="p">)</span>
		<span class="n">bm_set_full_words_within_one_page</span><span class="p">(</span><span class="n">mdev</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">,</span> <span class="n">last_page</span><span class="p">,</span> <span class="n">first_word</span><span class="p">,</span> <span class="n">last_word</span><span class="p">);</span>

	<span class="cm">/* possibly trailing bits.</span>
<span class="cm">	 * example: (e &amp; 63) == 63, el will be e+1.</span>
<span class="cm">	 * if that even was the very last bit,</span>
<span class="cm">	 * it would trigger an assert in __bm_change_bits_to()</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">el</span> <span class="o">&lt;=</span> <span class="n">e</span><span class="p">)</span>
		<span class="n">__bm_change_bits_to</span><span class="p">(</span><span class="n">mdev</span><span class="p">,</span> <span class="n">el</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* returns bit state</span>
<span class="cm"> * wants bitnr, NOT sector.</span>
<span class="cm"> * inherently racy... area needs to be locked by means of {al,rs}_lru</span>
<span class="cm"> *  1 ... bit set</span>
<span class="cm"> *  0 ... bit not set</span>
<span class="cm"> * -1 ... first out of bounds access, stop testing for bits!</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">drbd_bm_test_bit</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bitnr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drbd_bitmap</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">mdev</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">p_addr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">ERR_IF</span><span class="p">(</span><span class="o">!</span><span class="n">b</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ERR_IF</span><span class="p">(</span><span class="o">!</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_pages</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">BM_DONT_TEST</span> <span class="o">&amp;</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_flags</span><span class="p">)</span>
		<span class="n">bm_print_lock_info</span><span class="p">(</span><span class="n">mdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bitnr</span> <span class="o">&lt;</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_bits</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">p_addr</span> <span class="o">=</span> <span class="n">bm_map_pidx</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">bm_bit_to_page_idx</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">bitnr</span><span class="p">));</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">test_bit_le</span><span class="p">(</span><span class="n">bitnr</span> <span class="o">&amp;</span> <span class="n">BITS_PER_PAGE_MASK</span><span class="p">,</span> <span class="n">p_addr</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">bm_unmap</span><span class="p">(</span><span class="n">p_addr</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bitnr</span> <span class="o">==</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_bits</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="cm">/* (bitnr &gt; b-&gt;bm_bits) */</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">DEV</span><span class="p">,</span> <span class="s">&quot;bitnr=%lu &gt; bm_bits=%lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bitnr</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_bits</span><span class="p">);</span>
		<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* returns number of bits set in the range [s, e] */</span>
<span class="kt">int</span> <span class="nf">drbd_bm_count_bits</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">s</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drbd_bitmap</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">mdev</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">p_addr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bitnr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">page_nr</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1U</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* If this is called without a bitmap, that is a bug.  But just to be</span>
<span class="cm">	 * robust in case we screwed up elsewhere, in that case pretend there</span>
<span class="cm">	 * was one dirty bit in the requested area, so we won&#39;t try to do a</span>
<span class="cm">	 * local read there (no bitmap probably implies no disk) */</span>
	<span class="n">ERR_IF</span><span class="p">(</span><span class="o">!</span><span class="n">b</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ERR_IF</span><span class="p">(</span><span class="o">!</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_pages</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">BM_DONT_TEST</span> <span class="o">&amp;</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_flags</span><span class="p">)</span>
		<span class="n">bm_print_lock_info</span><span class="p">(</span><span class="n">mdev</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">bitnr</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span> <span class="n">bitnr</span> <span class="o">&lt;=</span> <span class="n">e</span><span class="p">;</span> <span class="n">bitnr</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">bm_bit_to_page_idx</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">bitnr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page_nr</span> <span class="o">!=</span> <span class="n">idx</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">page_nr</span> <span class="o">=</span> <span class="n">idx</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">p_addr</span><span class="p">)</span>
				<span class="n">bm_unmap</span><span class="p">(</span><span class="n">p_addr</span><span class="p">);</span>
			<span class="n">p_addr</span> <span class="o">=</span> <span class="n">bm_map_pidx</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">ERR_IF</span> <span class="p">(</span><span class="n">bitnr</span> <span class="o">&gt;=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_bits</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">DEV</span><span class="p">,</span> <span class="s">&quot;bitnr=%lu bm_bits=%lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bitnr</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_bits</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">c</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">0</span> <span class="o">!=</span> <span class="n">test_bit_le</span><span class="p">(</span><span class="n">bitnr</span> <span class="o">-</span> <span class="p">(</span><span class="n">page_nr</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">PAGE_SHIFT</span><span class="o">+</span><span class="mi">3</span><span class="p">)),</span> <span class="n">p_addr</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p_addr</span><span class="p">)</span>
		<span class="n">bm_unmap</span><span class="p">(</span><span class="n">p_addr</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">c</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* inherently racy...</span>
<span class="cm"> * return value may be already out-of-date when this function returns.</span>
<span class="cm"> * but the general usage is that this is only use during a cstate when bits are</span>
<span class="cm"> * only cleared, not set, and typically only care for the case when the return</span>
<span class="cm"> * value is zero, or we already &quot;locked&quot; this &quot;bitmap extent&quot; by other means.</span>
<span class="cm"> *</span>
<span class="cm"> * enr is bm-extent number, since we chose to name one sector (512 bytes)</span>
<span class="cm"> * worth of the bitmap a &quot;bitmap extent&quot;.</span>
<span class="cm"> *</span>
<span class="cm"> * TODO</span>
<span class="cm"> * I think since we use it like a reference count, we should use the real</span>
<span class="cm"> * reference count of some bitmap extent element from some lru instead...</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">drbd_bm_e_weight</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">enr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drbd_bitmap</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">mdev</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">e</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">p_addr</span><span class="p">,</span> <span class="o">*</span><span class="n">bm</span><span class="p">;</span>

	<span class="n">ERR_IF</span><span class="p">(</span><span class="o">!</span><span class="n">b</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ERR_IF</span><span class="p">(</span><span class="o">!</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_pages</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">BM_DONT_TEST</span> <span class="o">&amp;</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_flags</span><span class="p">)</span>
		<span class="n">bm_print_lock_info</span><span class="p">(</span><span class="n">mdev</span><span class="p">);</span>

	<span class="n">s</span> <span class="o">=</span> <span class="n">S2W</span><span class="p">(</span><span class="n">enr</span><span class="p">);</span>
	<span class="n">e</span> <span class="o">=</span> <span class="n">min</span><span class="p">((</span><span class="kt">size_t</span><span class="p">)</span><span class="n">S2W</span><span class="p">(</span><span class="n">enr</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_words</span><span class="p">);</span>
	<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">&lt;</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_words</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">e</span><span class="o">-</span><span class="n">s</span><span class="p">;</span>
		<span class="n">p_addr</span> <span class="o">=</span> <span class="n">bm_map_pidx</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">bm_word_to_page_idx</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">s</span><span class="p">));</span>
		<span class="n">bm</span> <span class="o">=</span> <span class="n">p_addr</span> <span class="o">+</span> <span class="n">MLPP</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">n</span><span class="o">--</span><span class="p">)</span>
			<span class="n">count</span> <span class="o">+=</span> <span class="n">hweight_long</span><span class="p">(</span><span class="o">*</span><span class="n">bm</span><span class="o">++</span><span class="p">);</span>
		<span class="n">bm_unmap</span><span class="p">(</span><span class="n">p_addr</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">DEV</span><span class="p">,</span> <span class="s">&quot;start offset (%d) too large in drbd_bm_e_weight</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Set all bits covered by the AL-extent al_enr.</span>
<span class="cm"> * Returns number of bits changed. */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">drbd_bm_ALe_set_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">drbd_conf</span> <span class="o">*</span><span class="n">mdev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">al_enr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drbd_bitmap</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">mdev</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">p_addr</span><span class="p">,</span> <span class="o">*</span><span class="n">bm</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">weight</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">s</span><span class="p">,</span> <span class="n">e</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">do_now</span><span class="p">;</span>
	<span class="n">ERR_IF</span><span class="p">(</span><span class="o">!</span><span class="n">b</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ERR_IF</span><span class="p">(</span><span class="o">!</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_pages</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">BM_DONT_SET</span> <span class="o">&amp;</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_flags</span><span class="p">)</span>
		<span class="n">bm_print_lock_info</span><span class="p">(</span><span class="n">mdev</span><span class="p">);</span>
	<span class="n">weight</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_set</span><span class="p">;</span>

	<span class="n">s</span> <span class="o">=</span> <span class="n">al_enr</span> <span class="o">*</span> <span class="n">BM_WORDS_PER_AL_EXT</span><span class="p">;</span>
	<span class="n">e</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">s</span> <span class="o">+</span> <span class="n">BM_WORDS_PER_AL_EXT</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_words</span><span class="p">);</span>
	<span class="cm">/* assert that s and e are on the same page */</span>
	<span class="n">D_ASSERT</span><span class="p">((</span><span class="n">e</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">PAGE_SHIFT</span> <span class="o">-</span> <span class="n">LN2_BPL</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span>
	      <span class="o">==</span>  <span class="n">s</span>    <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">PAGE_SHIFT</span> <span class="o">-</span> <span class="n">LN2_BPL</span> <span class="o">+</span> <span class="mi">3</span><span class="p">));</span>
	<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">&lt;</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_words</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">do_now</span> <span class="o">=</span> <span class="n">e</span><span class="o">-</span><span class="n">s</span><span class="p">;</span>
		<span class="n">p_addr</span> <span class="o">=</span> <span class="n">bm_map_pidx</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">bm_word_to_page_idx</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">s</span><span class="p">));</span>
		<span class="n">bm</span> <span class="o">=</span> <span class="n">p_addr</span> <span class="o">+</span> <span class="n">MLPP</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">count</span> <span class="o">+=</span> <span class="n">hweight_long</span><span class="p">(</span><span class="o">*</span><span class="n">bm</span><span class="p">);</span>
			<span class="o">*</span><span class="n">bm</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1UL</span><span class="p">;</span>
			<span class="n">bm</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">bm_unmap</span><span class="p">(</span><span class="n">p_addr</span><span class="p">);</span>
		<span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_set</span> <span class="o">+=</span> <span class="n">do_now</span><span class="o">*</span><span class="n">BITS_PER_LONG</span> <span class="o">-</span> <span class="n">count</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">e</span> <span class="o">==</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_words</span><span class="p">)</span>
			<span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_set</span> <span class="o">-=</span> <span class="n">bm_clear_surplus</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">DEV</span><span class="p">,</span> <span class="s">&quot;start offset (%lu) too large in drbd_bm_ALe_set_all</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">weight</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_set</span> <span class="o">-</span> <span class="n">weight</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bm_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">weight</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
