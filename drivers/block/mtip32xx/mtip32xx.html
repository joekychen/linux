<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › block › mtip32xx › mtip32xx.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>mtip32xx.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Driver for the Micron P320 SSD</span>
<span class="cm"> *   Copyright (C) 2011 Micron Technology, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * Portions of this code were derived from works subjected to the</span>
<span class="cm"> * following copyright:</span>
<span class="cm"> *    Copyright (C) 2009 Integrated Device Technology, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/ata.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/hdreg.h&gt;</span>
<span class="cp">#include &lt;linux/uaccess.h&gt;</span>
<span class="cp">#include &lt;linux/random.h&gt;</span>
<span class="cp">#include &lt;linux/smp.h&gt;</span>
<span class="cp">#include &lt;linux/compat.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/genhd.h&gt;</span>
<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;linux/bio.h&gt;</span>
<span class="cp">#include &lt;linux/dma-mapping.h&gt;</span>
<span class="cp">#include &lt;linux/idr.h&gt;</span>
<span class="cp">#include &lt;linux/kthread.h&gt;</span>
<span class="cp">#include &lt;../drivers/ata/ahci.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/debugfs.h&gt;</span>
<span class="cp">#include &quot;mtip32xx.h&quot;</span>

<span class="cp">#define HW_CMD_SLOT_SZ		(MTIP_MAX_COMMAND_SLOTS * 32)</span>
<span class="cp">#define HW_CMD_TBL_SZ		(AHCI_CMD_TBL_HDR_SZ + (MTIP_MAX_SG * 16))</span>
<span class="cp">#define HW_CMD_TBL_AR_SZ	(HW_CMD_TBL_SZ * MTIP_MAX_COMMAND_SLOTS)</span>
<span class="cp">#define HW_PORT_PRIV_DMA_SZ \</span>
<span class="cp">		(HW_CMD_SLOT_SZ + HW_CMD_TBL_AR_SZ + AHCI_RX_FIS_SZ)</span>

<span class="cp">#define HOST_CAP_NZDMA		(1 &lt;&lt; 19)</span>
<span class="cp">#define HOST_HSORG		0xFC</span>
<span class="cp">#define HSORG_DISABLE_SLOTGRP_INTR (1&lt;&lt;24)</span>
<span class="cp">#define HSORG_DISABLE_SLOTGRP_PXIS (1&lt;&lt;16)</span>
<span class="cp">#define HSORG_HWREV		0xFF00</span>
<span class="cp">#define HSORG_STYLE		0x8</span>
<span class="cp">#define HSORG_SLOTGROUPS	0x7</span>

<span class="cp">#define PORT_COMMAND_ISSUE	0x38</span>
<span class="cp">#define PORT_SDBV		0x7C</span>

<span class="cp">#define PORT_OFFSET		0x100</span>
<span class="cp">#define PORT_MEM_SIZE		0x80</span>

<span class="cp">#define PORT_IRQ_ERR \</span>
<span class="cp">	(PORT_IRQ_HBUS_ERR | PORT_IRQ_IF_ERR | PORT_IRQ_CONNECT | \</span>
<span class="cp">	 PORT_IRQ_PHYRDY | PORT_IRQ_UNK_FIS | PORT_IRQ_BAD_PMP | \</span>
<span class="cp">	 PORT_IRQ_TF_ERR | PORT_IRQ_HBUS_DATA_ERR | PORT_IRQ_IF_NONFATAL | \</span>
<span class="cp">	 PORT_IRQ_OVERFLOW)</span>
<span class="cp">#define PORT_IRQ_LEGACY \</span>
<span class="cp">	(PORT_IRQ_PIOS_FIS | PORT_IRQ_D2H_REG_FIS)</span>
<span class="cp">#define PORT_IRQ_HANDLED \</span>
<span class="cp">	(PORT_IRQ_SDB_FIS | PORT_IRQ_LEGACY | \</span>
<span class="cp">	 PORT_IRQ_TF_ERR | PORT_IRQ_IF_ERR | \</span>
<span class="cp">	 PORT_IRQ_CONNECT | PORT_IRQ_PHYRDY)</span>
<span class="cp">#define DEF_PORT_IRQ \</span>
<span class="cp">	(PORT_IRQ_ERR | PORT_IRQ_LEGACY | PORT_IRQ_SDB_FIS)</span>

<span class="cm">/* product numbers */</span>
<span class="cp">#define MTIP_PRODUCT_UNKNOWN	0x00</span>
<span class="cp">#define MTIP_PRODUCT_ASICFPGA	0x11</span>

<span class="cm">/* Device instance number, incremented each time a device is probed. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">instance</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Global variable used to hold the major block device number</span>
<span class="cm"> * allocated in mtip_init().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">mtip_major</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dfs_parent</span><span class="p">;</span>

<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">rssd_index_lock</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_IDA</span><span class="p">(</span><span class="n">rssd_index_ida</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">mtip_block_initialize</span><span class="p">(</span><span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">dd</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_COMPAT</span>
<span class="k">struct</span> <span class="n">mtip_compat_ide_task_request_s</span> <span class="p">{</span>
	<span class="n">__u8</span>		<span class="n">io_ports</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="n">__u8</span>		<span class="n">hob_ports</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="n">ide_reg_valid_t</span>	<span class="n">out_flags</span><span class="p">;</span>
	<span class="n">ide_reg_valid_t</span>	<span class="n">in_flags</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">data_phase</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">req_cmd</span><span class="p">;</span>
	<span class="n">compat_ulong_t</span>	<span class="n">out_size</span><span class="p">;</span>
	<span class="n">compat_ulong_t</span>	<span class="n">in_size</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * This function check_for_surprise_removal is called</span>
<span class="cm"> * while card is removed from the system and it will</span>
<span class="cm"> * read the vendor id from the configration space</span>
<span class="cm"> *</span>
<span class="cm"> * @pdev Pointer to the pci_dev structure.</span>
<span class="cm"> *</span>
<span class="cm"> * return value</span>
<span class="cm"> *	 true if device removed, else false</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">mtip_check_surprise_removal</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">vendor_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

       <span class="cm">/* Read the vendorID from the configuration space */</span>
	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vendor_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vendor_id</span> <span class="o">==</span> <span class="mh">0xFFFF</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="cm">/* device removed */</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="cm">/* device present */</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This function is called for clean the pending command in the</span>
<span class="cm"> * command slot during the surprise removal of device and return</span>
<span class="cm"> * error to the upper layer.</span>
<span class="cm"> *</span>
<span class="cm"> * @dd Pointer to the DRIVER_DATA structure.</span>
<span class="cm"> *</span>
<span class="cm"> * return value</span>
<span class="cm"> *	None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mtip_command_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">dd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">group</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">commandslot</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">commandindex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mtip_cmd</span> <span class="o">*</span><span class="n">command</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mtip_port</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">;</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">in_progress</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">in_progress</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">in_progress</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">group</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">group</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">group</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">commandslot</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">commandslot</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">;</span> <span class="n">commandslot</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">allocated</span><span class="p">[</span><span class="n">group</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">commandslot</span><span class="p">)))</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="n">commandindex</span> <span class="o">=</span> <span class="n">group</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span> <span class="o">|</span> <span class="n">commandslot</span><span class="p">;</span>
			<span class="n">command</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">commands</span><span class="p">[</span><span class="n">commandindex</span><span class="p">];</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">command</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">)</span>
			    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">command</span><span class="o">-&gt;</span><span class="n">async_callback</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">command</span><span class="o">-&gt;</span><span class="n">async_callback</span><span class="p">(</span><span class="n">command</span><span class="o">-&gt;</span><span class="n">async_data</span><span class="p">,</span>
					<span class="o">-</span><span class="n">ENODEV</span><span class="p">);</span>
				<span class="n">command</span><span class="o">-&gt;</span><span class="n">async_callback</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="n">command</span><span class="o">-&gt;</span><span class="n">async_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">dma_unmap_sg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="n">command</span><span class="o">-&gt;</span><span class="n">sg</span><span class="p">,</span>
				<span class="n">command</span><span class="o">-&gt;</span><span class="n">scatter_ents</span><span class="p">,</span>
				<span class="n">command</span><span class="o">-&gt;</span><span class="n">direction</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">cmd_slot</span><span class="p">);</span>

	<span class="n">set_bit</span><span class="p">(</span><span class="n">MTIP_DDF_CLEANUP_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">dd_flag</span><span class="p">);</span>
	<span class="n">in_progress</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Obtain an empty command slot.</span>
<span class="cm"> *</span>
<span class="cm"> * This function needs to be reentrant since it could be called</span>
<span class="cm"> * at the same time on multiple CPUs. The allocation of the</span>
<span class="cm"> * command slot must be atomic.</span>
<span class="cm"> *</span>
<span class="cm"> * @port Pointer to the port data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * return value</span>
<span class="cm"> *	&gt;= 0	Index of command slot obtained.</span>
<span class="cm"> *	-1	No command slots available.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_slot</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtip_port</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">slot</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_command_slots</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">slot_groups</span> <span class="o">*</span> <span class="mi">32</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Try 10 times, because there is a small race here.</span>
<span class="cm">	 *  that&#39;s ok, because it&#39;s still cheaper than a lock.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Race: Since this section is not protected by lock, same bit</span>
<span class="cm">	 * could be chosen by different process contexts running in</span>
<span class="cm">	 * different processor. So instead of costly lock, we are going</span>
<span class="cm">	 * with loop.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">slot</span> <span class="o">=</span> <span class="n">find_next_zero_bit</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">allocated</span><span class="p">,</span>
					 <span class="n">num_command_slots</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">slot</span> <span class="o">&lt;</span> <span class="n">num_command_slots</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">slot</span><span class="p">,</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">allocated</span><span class="p">)))</span>
			<span class="k">return</span> <span class="n">slot</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Failed to get a tag.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mtip_check_surprise_removal</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Device not present, clean outstanding commands */</span>
		<span class="n">mtip_command_cleanup</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">dd</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Release a command slot.</span>
<span class="cm"> *</span>
<span class="cm"> * @port Pointer to the port data structure.</span>
<span class="cm"> * @tag  Tag of command to release</span>
<span class="cm"> *</span>
<span class="cm"> * return value</span>
<span class="cm"> *	None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">release_slot</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtip_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">smp_mb__before_clear_bit</span><span class="p">();</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">allocated</span><span class="p">);</span>
	<span class="n">smp_mb__after_clear_bit</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Reset the HBA (without sleeping)</span>
<span class="cm"> *</span>
<span class="cm"> * Just like hba_reset, except does not call sleep, so can be</span>
<span class="cm"> * run from interrupt/tasklet context.</span>
<span class="cm"> *</span>
<span class="cm"> * @dd Pointer to the driver data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * return value</span>
<span class="cm"> *	0	The reset was successful.</span>
<span class="cm"> *	-1	The HBA Reset bit did not clear.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hba_reset_nosleep</span><span class="p">(</span><span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">dd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">;</span>

	<span class="cm">/* Chip quirk: quiesce any chip function */</span>
	<span class="n">mdelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

	<span class="cm">/* Set the reset bit */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">HOST_RESET</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">HOST_CTL</span><span class="p">);</span>

	<span class="cm">/* Flush */</span>
	<span class="n">readl</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">HOST_CTL</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Wait 10ms then spin for up to 1 second</span>
<span class="cm">	 * waiting for reset acknowledgement</span>
<span class="cm">	 */</span>
	<span class="n">timeout</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
	<span class="n">mdelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">readl</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">HOST_CTL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">HOST_RESET</span><span class="p">)</span>
		 <span class="o">&amp;&amp;</span> <span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">timeout</span><span class="p">))</span>
		<span class="n">mdelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">MTIP_DDF_REMOVE_PENDING_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">dd_flag</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">HOST_CTL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">HOST_RESET</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Issue a command to the hardware.</span>
<span class="cm"> *</span>
<span class="cm"> * Set the appropriate bit in the s_active and Command Issue hardware</span>
<span class="cm"> * registers, causing hardware command processing to begin.</span>
<span class="cm"> *</span>
<span class="cm"> * @port Pointer to the port structure.</span>
<span class="cm"> * @tag  The tag of the command to be issued.</span>
<span class="cm"> *</span>
<span class="cm"> * return value</span>
<span class="cm"> *      None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">mtip_issue_ncq_command</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtip_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">commands</span><span class="p">[</span><span class="n">tag</span><span class="p">].</span><span class="n">active</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">cmd_issue_lock</span><span class="p">);</span>

	<span class="n">writel</span><span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">MTIP_TAG_BIT</span><span class="p">(</span><span class="n">tag</span><span class="p">)),</span>
			<span class="n">port</span><span class="o">-&gt;</span><span class="n">s_active</span><span class="p">[</span><span class="n">MTIP_TAG_INDEX</span><span class="p">(</span><span class="n">tag</span><span class="p">)]);</span>
	<span class="n">writel</span><span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">MTIP_TAG_BIT</span><span class="p">(</span><span class="n">tag</span><span class="p">)),</span>
			<span class="n">port</span><span class="o">-&gt;</span><span class="n">cmd_issue</span><span class="p">[</span><span class="n">MTIP_TAG_INDEX</span><span class="p">(</span><span class="n">tag</span><span class="p">)]);</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">cmd_issue_lock</span><span class="p">);</span>

	<span class="cm">/* Set the command&#39;s timeout value.*/</span>
	<span class="n">port</span><span class="o">-&gt;</span><span class="n">commands</span><span class="p">[</span><span class="n">tag</span><span class="p">].</span><span class="n">comp_time</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span>
					<span class="n">MTIP_NCQ_COMMAND_TIMEOUT_MS</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Enable/disable the reception of FIS</span>
<span class="cm"> *</span>
<span class="cm"> * @port   Pointer to the port data structure</span>
<span class="cm"> * @enable 1 to enable, 0 to disable</span>
<span class="cm"> *</span>
<span class="cm"> * return value</span>
<span class="cm"> *	Previous state: 1 enabled, 0 disabled</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mtip_enable_fis</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtip_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="kt">int</span> <span class="n">enable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="cm">/* enable FIS reception */</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">PORT_CMD</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">enable</span><span class="p">)</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">tmp</span> <span class="o">|</span> <span class="n">PORT_CMD_FIS_RX</span><span class="p">,</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">PORT_CMD</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PORT_CMD_FIS_RX</span><span class="p">,</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">PORT_CMD</span><span class="p">);</span>

	<span class="cm">/* Flush */</span>
	<span class="n">readl</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">PORT_CMD</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(((</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="n">PORT_CMD_FIS_RX</span><span class="p">)</span> <span class="o">==</span> <span class="n">PORT_CMD_FIS_RX</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Enable/disable the DMA engine</span>
<span class="cm"> *</span>
<span class="cm"> * @port   Pointer to the port data structure</span>
<span class="cm"> * @enable 1 to enable, 0 to disable</span>
<span class="cm"> *</span>
<span class="cm"> * return value</span>
<span class="cm"> *	Previous state: 1 enabled, 0 disabled.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mtip_enable_engine</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtip_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="kt">int</span> <span class="n">enable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="cm">/* enable FIS reception */</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">PORT_CMD</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">enable</span><span class="p">)</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">tmp</span> <span class="o">|</span> <span class="n">PORT_CMD_START</span><span class="p">,</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">PORT_CMD</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PORT_CMD_START</span><span class="p">,</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">PORT_CMD</span><span class="p">);</span>

	<span class="n">readl</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">PORT_CMD</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(((</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="n">PORT_CMD_START</span><span class="p">)</span> <span class="o">==</span> <span class="n">PORT_CMD_START</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Enables the port DMA engine and FIS reception.</span>
<span class="cm"> *</span>
<span class="cm"> * return value</span>
<span class="cm"> *	None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">mtip_start_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtip_port</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Enable FIS reception */</span>
	<span class="n">mtip_enable_fis</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* Enable the DMA engine */</span>
	<span class="n">mtip_enable_engine</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Deinitialize a port by disabling port interrupts, the DMA engine,</span>
<span class="cm"> * and FIS reception.</span>
<span class="cm"> *</span>
<span class="cm"> * @port Pointer to the port structure</span>
<span class="cm"> *</span>
<span class="cm"> * return value</span>
<span class="cm"> *	None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">mtip_deinit_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtip_port</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Disable interrupts on this port */</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">PORT_IRQ_MASK</span><span class="p">);</span>

	<span class="cm">/* Disable the DMA engine */</span>
	<span class="n">mtip_enable_engine</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Disable FIS reception */</span>
	<span class="n">mtip_enable_fis</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Initialize a port.</span>
<span class="cm"> *</span>
<span class="cm"> * This function deinitializes the port by calling mtip_deinit_port() and</span>
<span class="cm"> * then initializes it by setting the command header and RX FIS addresses,</span>
<span class="cm"> * clearing the SError register and any pending port interrupts before</span>
<span class="cm"> * re-enabling the default set of port interrupts.</span>
<span class="cm"> *</span>
<span class="cm"> * @port Pointer to the port structure.</span>
<span class="cm"> *</span>
<span class="cm"> * return value</span>
<span class="cm"> *	None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mtip_init_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtip_port</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">mtip_deinit_port</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>

	<span class="cm">/* Program the command list base and FIS base addresses */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">HOST_CAP</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">HOST_CAP_64</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">writel</span><span class="p">((</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">command_list_dma</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">,</span>
			 <span class="n">port</span><span class="o">-&gt;</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">PORT_LST_ADDR_HI</span><span class="p">);</span>
		<span class="n">writel</span><span class="p">((</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">rxfis_dma</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">,</span>
			 <span class="n">port</span><span class="o">-&gt;</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">PORT_FIS_ADDR_HI</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">writel</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">command_list_dma</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFFFF</span><span class="p">,</span>
			<span class="n">port</span><span class="o">-&gt;</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">PORT_LST_ADDR</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">rxfis_dma</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFFFF</span><span class="p">,</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">PORT_FIS_ADDR</span><span class="p">);</span>

	<span class="cm">/* Clear SError */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">PORT_SCR_ERR</span><span class="p">),</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">PORT_SCR_ERR</span><span class="p">);</span>

	<span class="cm">/* reset the completed registers.*/</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">slot_groups</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">writel</span><span class="p">(</span><span class="mh">0xFFFFFFFF</span><span class="p">,</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">completed</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="cm">/* Clear any pending interrupts for this port */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">PORT_IRQ_STAT</span><span class="p">),</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">PORT_IRQ_STAT</span><span class="p">);</span>

	<span class="cm">/* Clear any pending interrupts on the HBA. */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">HOST_IRQ_STAT</span><span class="p">),</span>
					<span class="n">port</span><span class="o">-&gt;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">HOST_IRQ_STAT</span><span class="p">);</span>

	<span class="cm">/* Enable port interrupts */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">DEF_PORT_IRQ</span><span class="p">,</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">PORT_IRQ_MASK</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Restart a port</span>
<span class="cm"> *</span>
<span class="cm"> * @port Pointer to the port data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * return value</span>
<span class="cm"> *	None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mtip_restart_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtip_port</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">;</span>

	<span class="cm">/* Disable the DMA engine */</span>
	<span class="n">mtip_enable_engine</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Chip quirk: wait up to 500ms for PxCMD.CR == 0 */</span>
	<span class="n">timeout</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="mi">500</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">readl</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">PORT_CMD</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PORT_CMD_LIST_ON</span><span class="p">)</span>
		 <span class="o">&amp;&amp;</span> <span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">timeout</span><span class="p">))</span>
		<span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">MTIP_DDF_REMOVE_PENDING_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">dd_flag</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Chip quirk: escalate to hba reset if</span>
<span class="cm">	 * PxCMD.CR not clear after 500 ms</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">PORT_CMD</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PORT_CMD_LIST_ON</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;PxCMD.CR not clear, escalating reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">hba_reset_nosleep</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">dd</span><span class="p">))</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;HBA reset escalation failed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="cm">/* 30 ms delay before com reset to quiesce chip */</span>
		<span class="n">mdelay</span><span class="p">(</span><span class="mi">30</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Issuing COM reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Set PxSCTL.DET */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">PORT_SCR_CTL</span><span class="p">)</span> <span class="o">|</span>
			 <span class="mi">1</span><span class="p">,</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">PORT_SCR_CTL</span><span class="p">);</span>
	<span class="n">readl</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">PORT_SCR_CTL</span><span class="p">);</span>

	<span class="cm">/* Wait 1 ms to quiesce chip function */</span>
	<span class="n">timeout</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">timeout</span><span class="p">))</span>
		<span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">MTIP_DDF_REMOVE_PENDING_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">dd_flag</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Clear PxSCTL.DET */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">PORT_SCR_CTL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">1</span><span class="p">,</span>
			 <span class="n">port</span><span class="o">-&gt;</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">PORT_SCR_CTL</span><span class="p">);</span>
	<span class="n">readl</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">PORT_SCR_CTL</span><span class="p">);</span>

	<span class="cm">/* Wait 500 ms for bit 0 of PORT_SCR_STS to be set */</span>
	<span class="n">timeout</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="mi">500</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(((</span><span class="n">readl</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">PORT_SCR_STAT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			 <span class="o">&amp;&amp;</span> <span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">timeout</span><span class="p">))</span>
		<span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">MTIP_DDF_REMOVE_PENDING_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">dd_flag</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">readl</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">PORT_SCR_STAT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;COM reset failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">mtip_init_port</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>
	<span class="n">mtip_start_port</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Helper function for tag logging</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">print_tags</span><span class="p">(</span><span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span>
			<span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">tagbits</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">cnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">tagmap</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">group</span><span class="p">,</span> <span class="n">tagmap_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">tagmap</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tagmap</span><span class="p">));</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">group</span> <span class="o">=</span> <span class="n">SLOTBITS_IN_LONGS</span><span class="p">;</span> <span class="n">group</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">group</span><span class="o">--</span><span class="p">)</span>
		<span class="n">tagmap_len</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">tagmap</span> <span class="o">+</span> <span class="n">tagmap_len</span><span class="p">,</span> <span class="s">&quot;%016lX &quot;</span><span class="p">,</span>
						<span class="n">tagbits</span><span class="p">[</span><span class="n">group</span><span class="o">-</span><span class="mi">1</span><span class="p">]);</span>
	<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;%d command(s) %s: tagmap [%s]&quot;</span><span class="p">,</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">tagmap</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called periodically to see if any read/write commands are</span>
<span class="cm"> * taking too long to complete.</span>
<span class="cm"> *</span>
<span class="cm"> * @data Pointer to the PORT data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * return value</span>
<span class="cm"> *	None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mtip_timeout_function</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">int</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mtip_port</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">mtip_port</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">host_to_dev_fis</span> <span class="o">*</span><span class="n">fis</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mtip_cmd</span> <span class="o">*</span><span class="n">command</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tag</span><span class="p">,</span> <span class="n">cmdto_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bit</span><span class="p">,</span> <span class="n">group</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_command_slots</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">slot_groups</span> <span class="o">*</span> <span class="mi">32</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">to</span><span class="p">,</span> <span class="n">tagaccum</span><span class="p">[</span><span class="n">SLOTBITS_IN_LONGS</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">port</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">MTIP_DDF_RESUME_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">dd_flag</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">cmd_timer</span><span class="p">,</span>
			<span class="n">jiffies</span> <span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="mi">30000</span><span class="p">));</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* clear the tag accumulator */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">tagaccum</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SLOTBITS_IN_LONGS</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">));</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">tag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">tag</span> <span class="o">&lt;</span> <span class="n">num_command_slots</span><span class="p">;</span> <span class="n">tag</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Skip internal command slot as it has</span>
<span class="cm">		 * its own timeout mechanism</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tag</span> <span class="o">==</span> <span class="n">MTIP_TAG_INTERNAL</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">commands</span><span class="p">[</span><span class="n">tag</span><span class="p">].</span><span class="n">active</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		   <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">commands</span><span class="p">[</span><span class="n">tag</span><span class="p">].</span><span class="n">comp_time</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">group</span> <span class="o">=</span> <span class="n">tag</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span><span class="p">;</span>
			<span class="n">bit</span> <span class="o">=</span> <span class="n">tag</span> <span class="o">&amp;</span> <span class="mh">0x1F</span><span class="p">;</span>

			<span class="n">command</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">commands</span><span class="p">[</span><span class="n">tag</span><span class="p">];</span>
			<span class="n">fis</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">host_to_dev_fis</span> <span class="o">*</span><span class="p">)</span> <span class="n">command</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">;</span>

			<span class="n">set_bit</span><span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="n">tagaccum</span><span class="p">);</span>
			<span class="n">cmdto_cnt</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cmdto_cnt</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
				<span class="n">set_bit</span><span class="p">(</span><span class="n">MTIP_PF_EH_ACTIVE_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * Clear the completed bit. This should prevent</span>
<span class="cm">			 *  any interrupt handlers from trying to retire</span>
<span class="cm">			 *  the command.</span>
<span class="cm">			 */</span>
			<span class="n">writel</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">bit</span><span class="p">,</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">completed</span><span class="p">[</span><span class="n">group</span><span class="p">]);</span>

			<span class="cm">/* Call the async completion callback. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">command</span><span class="o">-&gt;</span><span class="n">async_callback</span><span class="p">))</span>
				<span class="n">command</span><span class="o">-&gt;</span><span class="n">async_callback</span><span class="p">(</span><span class="n">command</span><span class="o">-&gt;</span><span class="n">async_data</span><span class="p">,</span>
							 <span class="o">-</span><span class="n">EIO</span><span class="p">);</span>
			<span class="n">command</span><span class="o">-&gt;</span><span class="n">async_callback</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">command</span><span class="o">-&gt;</span><span class="n">comp_func</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

			<span class="cm">/* Unmap the DMA scatter list entries */</span>
			<span class="n">dma_unmap_sg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="n">command</span><span class="o">-&gt;</span><span class="n">sg</span><span class="p">,</span>
					<span class="n">command</span><span class="o">-&gt;</span><span class="n">scatter_ents</span><span class="p">,</span>
					<span class="n">command</span><span class="o">-&gt;</span><span class="n">direction</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * Clear the allocated bit and active tag for the</span>
<span class="cm">			 * command.</span>
<span class="cm">			 */</span>
			<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">commands</span><span class="p">[</span><span class="n">tag</span><span class="p">].</span><span class="n">active</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">release_slot</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">tag</span><span class="p">);</span>

			<span class="n">up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">cmd_slot</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmdto_cnt</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">MTIP_PF_IC_ACTIVE_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">print_tags</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">dd</span><span class="p">,</span> <span class="s">&quot;timed out&quot;</span><span class="p">,</span> <span class="n">tagaccum</span><span class="p">,</span> <span class="n">cmdto_cnt</span><span class="p">);</span>

		<span class="n">mtip_restart_port</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">MTIP_PF_EH_ACTIVE_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">svc_wait</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ic_pause_timer</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">to</span>  <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">ic_pause_timer</span> <span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">to</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">MTIP_PF_IC_ACTIVE_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">port</span><span class="o">-&gt;</span><span class="n">ic_pause_timer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">clear_bit</span><span class="p">(</span><span class="n">MTIP_PF_SE_ACTIVE_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
				<span class="n">clear_bit</span><span class="p">(</span><span class="n">MTIP_PF_DM_ACTIVE_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
				<span class="n">clear_bit</span><span class="p">(</span><span class="n">MTIP_PF_IC_ACTIVE_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
				<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">svc_wait</span><span class="p">);</span>
			<span class="p">}</span>


		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Restart the timer */</span>
	<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">cmd_timer</span><span class="p">,</span>
		<span class="n">jiffies</span> <span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">MTIP_TIMEOUT_CHECK_PERIOD</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * IO completion function.</span>
<span class="cm"> *</span>
<span class="cm"> * This completion function is called by the driver ISR when a</span>
<span class="cm"> * command that was issued by the kernel completes. It first calls the</span>
<span class="cm"> * asynchronous completion function which normally calls back into the block</span>
<span class="cm"> * layer passing the asynchronous callback data, then unmaps the</span>
<span class="cm"> * scatter list associated with the completed command, and finally</span>
<span class="cm"> * clears the allocated bit associated with the completed command.</span>
<span class="cm"> *</span>
<span class="cm"> * @port   Pointer to the port data structure.</span>
<span class="cm"> * @tag    Tag of the command.</span>
<span class="cm"> * @data   Pointer to driver_data.</span>
<span class="cm"> * @status Completion status.</span>
<span class="cm"> *</span>
<span class="cm"> * return value</span>
<span class="cm"> *	None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mtip_async_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtip_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">tag</span><span class="p">,</span>
				<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mtip_cmd</span> <span class="o">*</span><span class="n">command</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">dd</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cb_status</span> <span class="o">=</span> <span class="n">status</span> <span class="o">?</span> <span class="o">-</span><span class="n">EIO</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">dd</span><span class="p">)</span> <span class="o">||</span> <span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">port</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">command</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">commands</span><span class="p">[</span><span class="n">tag</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">PORT_IRQ_TF_ERR</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;Command tag %d failed due to TFE</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">tag</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Upper layer callback */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">command</span><span class="o">-&gt;</span><span class="n">async_callback</span><span class="p">))</span>
		<span class="n">command</span><span class="o">-&gt;</span><span class="n">async_callback</span><span class="p">(</span><span class="n">command</span><span class="o">-&gt;</span><span class="n">async_data</span><span class="p">,</span> <span class="n">cb_status</span><span class="p">);</span>

	<span class="n">command</span><span class="o">-&gt;</span><span class="n">async_callback</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">command</span><span class="o">-&gt;</span><span class="n">comp_func</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Unmap the DMA scatter list entries */</span>
	<span class="n">dma_unmap_sg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="n">command</span><span class="o">-&gt;</span><span class="n">sg</span><span class="p">,</span>
		<span class="n">command</span><span class="o">-&gt;</span><span class="n">scatter_ents</span><span class="p">,</span>
		<span class="n">command</span><span class="o">-&gt;</span><span class="n">direction</span><span class="p">);</span>

	<span class="cm">/* Clear the allocated and active bits for the command */</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">commands</span><span class="p">[</span><span class="n">tag</span><span class="p">].</span><span class="n">active</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">release_slot</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">tag</span><span class="p">);</span>

	<span class="n">up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">cmd_slot</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Internal command completion callback function.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is normally called by the driver ISR when an internal</span>
<span class="cm"> * command completed. This function signals the command completion by</span>
<span class="cm"> * calling complete().</span>
<span class="cm"> *</span>
<span class="cm"> * @port   Pointer to the port data structure.</span>
<span class="cm"> * @tag    Tag of the command that has completed.</span>
<span class="cm"> * @data   Pointer to a completion structure.</span>
<span class="cm"> * @status Completion status.</span>
<span class="cm"> *</span>
<span class="cm"> * return value</span>
<span class="cm"> *	None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mtip_completion</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtip_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">tag</span><span class="p">,</span>
			    <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mtip_cmd</span> <span class="o">*</span><span class="n">command</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">commands</span><span class="p">[</span><span class="n">tag</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">completion</span> <span class="o">*</span><span class="n">waiting</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">PORT_IRQ_TF_ERR</span><span class="p">))</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;Internal command %d completed with TFE</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">tag</span><span class="p">);</span>

	<span class="n">command</span><span class="o">-&gt;</span><span class="n">async_callback</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">command</span><span class="o">-&gt;</span><span class="n">comp_func</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">complete</span><span class="p">(</span><span class="n">waiting</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mtip_null_completion</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtip_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">tag</span><span class="p">,</span>
			    <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">mtip_read_log_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtip_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="n">u8</span> <span class="n">page</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
				<span class="n">dma_addr_t</span> <span class="n">buffer_dma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sectors</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">mtip_get_smart_attr</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtip_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">id</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">smart_attr</span> <span class="o">*</span><span class="n">attrib</span><span class="p">);</span>
<span class="cm">/*</span>
<span class="cm"> * Handle an error.</span>
<span class="cm"> *</span>
<span class="cm"> * @dd Pointer to the DRIVER_DATA structure.</span>
<span class="cm"> *</span>
<span class="cm"> * return value</span>
<span class="cm"> *	None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mtip_handle_tfe</span><span class="p">(</span><span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">dd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">group</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="n">bit</span><span class="p">,</span> <span class="n">reissue</span><span class="p">,</span> <span class="n">rv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mtip_port</span> <span class="o">*</span><span class="n">port</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mtip_cmd</span>  <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">completed</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">host_to_dev_fis</span> <span class="o">*</span><span class="n">fis</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tagaccum</span><span class="p">[</span><span class="n">SLOTBITS_IN_LONGS</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">fail_reason</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fail_all_ncq_write</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">fail_all_ncq_cmds</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Taskfile error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">port</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">;</span>

	<span class="cm">/* Stop the timer to prevent command timeouts. */</span>
	<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">cmd_timer</span><span class="p">);</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">MTIP_PF_EH_ACTIVE_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">MTIP_PF_IC_ACTIVE_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="n">test_bit</span><span class="p">(</span><span class="n">MTIP_TAG_INTERNAL</span><span class="p">,</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">allocated</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">commands</span><span class="p">[</span><span class="n">MTIP_TAG_INTERNAL</span><span class="p">];</span>
		<span class="n">dbg_printk</span><span class="p">(</span><span class="n">MTIP_DRV_NAME</span> <span class="s">&quot; TFE for the internal command</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">);</span> <span class="cm">/* active &gt; 1 indicates error */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">comp_data</span> <span class="o">&amp;&amp;</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">comp_func</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">comp_func</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">MTIP_TAG_INTERNAL</span><span class="p">,</span>
					<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">comp_data</span><span class="p">,</span> <span class="n">PORT_IRQ_TF_ERR</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">goto</span> <span class="n">handle_tfe_exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* clear the tag accumulator */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">tagaccum</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SLOTBITS_IN_LONGS</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">));</span>

	<span class="cm">/* Loop through all the groups */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">group</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">group</span> <span class="o">&lt;</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">slot_groups</span><span class="p">;</span> <span class="n">group</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">completed</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">completed</span><span class="p">[</span><span class="n">group</span><span class="p">]);</span>

		<span class="cm">/* clear completed status register in the hardware.*/</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">completed</span><span class="p">,</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">completed</span><span class="p">[</span><span class="n">group</span><span class="p">]);</span>

		<span class="cm">/* Process successfully completed commands */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">bit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">bit</span> <span class="o">&lt;</span> <span class="mi">32</span> <span class="o">&amp;&amp;</span> <span class="n">completed</span><span class="p">;</span> <span class="n">bit</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">completed</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">bit</span><span class="p">)))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">tag</span> <span class="o">=</span> <span class="p">(</span><span class="n">group</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">+</span> <span class="n">bit</span><span class="p">;</span>

			<span class="cm">/* Skip the internal command slot */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tag</span> <span class="o">==</span> <span class="n">MTIP_TAG_INTERNAL</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="n">cmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">commands</span><span class="p">[</span><span class="n">tag</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">comp_func</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">set_bit</span><span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="n">tagaccum</span><span class="p">);</span>
				<span class="n">cmd_cnt</span><span class="o">++</span><span class="p">;</span>
				<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
				<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">comp_func</span><span class="p">(</span><span class="n">port</span><span class="p">,</span>
					 <span class="n">tag</span><span class="p">,</span>
					 <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">comp_data</span><span class="p">,</span>
					 <span class="mi">0</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="s">&quot;Missing completion func for tag %d&quot;</span><span class="p">,</span>
					<span class="n">tag</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">mtip_check_surprise_removal</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">mtip_command_cleanup</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>
					<span class="cm">/* don&#39;t proceed further */</span>
					<span class="k">return</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">print_tags</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="s">&quot;completed (TFE)&quot;</span><span class="p">,</span> <span class="n">tagaccum</span><span class="p">,</span> <span class="n">cmd_cnt</span><span class="p">);</span>

	<span class="cm">/* Restart the port */</span>
	<span class="n">mdelay</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
	<span class="n">mtip_restart_port</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>

	<span class="cm">/* Trying to determine the cause of the error */</span>
	<span class="n">rv</span> <span class="o">=</span> <span class="n">mtip_read_log_page</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">,</span> <span class="n">ATA_LOG_SATA_NCQ</span><span class="p">,</span>
				<span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">log_buf</span><span class="p">,</span>
				<span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">log_buf_dma</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rv</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;Error in READ LOG EXT (10h) command</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="cm">/* non-critical error, don&#39;t fail the load */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">buf</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">log_buf</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">259</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;Write protect bit is set.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">MTIP_DDF_WRITE_PROTECT_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">dd_flag</span><span class="p">);</span>
			<span class="n">fail_all_ncq_write</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">fail_reason</span> <span class="o">=</span> <span class="s">&quot;write protect&quot;</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">288</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0xF7</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;Exceeded Tmax, drive in thermal shutdown.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">MTIP_DDF_OVER_TEMP_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">dd_flag</span><span class="p">);</span>
			<span class="n">fail_all_ncq_cmds</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">fail_reason</span> <span class="o">=</span> <span class="s">&quot;thermal shutdown&quot;</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">288</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0xBF</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;Drive indicates rebuild has failed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">fail_all_ncq_cmds</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">fail_reason</span> <span class="o">=</span> <span class="s">&quot;rebuild failed&quot;</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* clear the tag accumulator */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">tagaccum</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SLOTBITS_IN_LONGS</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">));</span>

	<span class="cm">/* Loop through all the groups */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">group</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">group</span> <span class="o">&lt;</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">slot_groups</span><span class="p">;</span> <span class="n">group</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">bit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">bit</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">;</span> <span class="n">bit</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">reissue</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">tag</span> <span class="o">=</span> <span class="p">(</span><span class="n">group</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">+</span> <span class="n">bit</span><span class="p">;</span>
			<span class="n">cmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">commands</span><span class="p">[</span><span class="n">tag</span><span class="p">];</span>

			<span class="cm">/* If the active bit is set re-issue the command */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="n">fis</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">host_to_dev_fis</span> <span class="o">*</span><span class="p">)</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">;</span>

			<span class="cm">/* Should re-issue? */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tag</span> <span class="o">==</span> <span class="n">MTIP_TAG_INTERNAL</span> <span class="o">||</span>
			    <span class="n">fis</span><span class="o">-&gt;</span><span class="n">command</span> <span class="o">==</span> <span class="n">ATA_CMD_SET_FEATURES</span><span class="p">)</span>
				<span class="n">reissue</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">fail_all_ncq_cmds</span> <span class="o">||</span>
					<span class="p">(</span><span class="n">fail_all_ncq_write</span> <span class="o">&amp;&amp;</span>
					<span class="n">fis</span><span class="o">-&gt;</span><span class="n">command</span> <span class="o">==</span> <span class="n">ATA_CMD_FPDMA_WRITE</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="s">&quot;  Fail: %s w/tag %d [%s].</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">fis</span><span class="o">-&gt;</span><span class="n">command</span> <span class="o">==</span> <span class="n">ATA_CMD_FPDMA_WRITE</span> <span class="o">?</span>
						<span class="s">&quot;write&quot;</span> <span class="o">:</span> <span class="s">&quot;read&quot;</span><span class="p">,</span>
					<span class="n">tag</span><span class="p">,</span>
					<span class="n">fail_reason</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">?</span>
						<span class="n">fail_reason</span> <span class="o">:</span> <span class="s">&quot;unknown&quot;</span><span class="p">);</span>
					<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">comp_func</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">comp_func</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span>
							<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">comp_data</span><span class="p">,</span>
							<span class="o">-</span><span class="n">ENODATA</span><span class="p">);</span>
					<span class="p">}</span>
					<span class="k">continue</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * First check if this command has</span>
<span class="cm">			 *  exceeded its retries.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">reissue</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">retries</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>

				<span class="n">set_bit</span><span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="n">tagaccum</span><span class="p">);</span>

				<span class="cm">/* Re-issue the command. */</span>
				<span class="n">mtip_issue_ncq_command</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">tag</span><span class="p">);</span>

				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* Retire a command that will not be reissued */</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;retiring tag %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">tag</span><span class="p">);</span>
			<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">comp_func</span><span class="p">)</span>
				<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">comp_func</span><span class="p">(</span>
					<span class="n">port</span><span class="p">,</span>
					<span class="n">tag</span><span class="p">,</span>
					<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">comp_data</span><span class="p">,</span>
					<span class="n">PORT_IRQ_TF_ERR</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="s">&quot;Bad completion for tag %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">tag</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">print_tags</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="s">&quot;reissued (TFE)&quot;</span><span class="p">,</span> <span class="n">tagaccum</span><span class="p">,</span> <span class="n">cmd_cnt</span><span class="p">);</span>

<span class="nl">handle_tfe_exit:</span>
	<span class="cm">/* clear eh_active */</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">MTIP_PF_EH_ACTIVE_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">svc_wait</span><span class="p">);</span>

	<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">cmd_timer</span><span class="p">,</span>
		 <span class="n">jiffies</span> <span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">MTIP_TIMEOUT_CHECK_PERIOD</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Handle a set device bits interrupt</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">mtip_process_sdbf</span><span class="p">(</span><span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">dd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mtip_port</span>  <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">group</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="n">bit</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">completed</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mtip_cmd</span> <span class="o">*</span><span class="n">command</span><span class="p">;</span>

	<span class="cm">/* walk all bits in all slot groups */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">group</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">group</span> <span class="o">&lt;</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">slot_groups</span><span class="p">;</span> <span class="n">group</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">completed</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">completed</span><span class="p">[</span><span class="n">group</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">completed</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* clear completed status register in the hardware.*/</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">completed</span><span class="p">,</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">completed</span><span class="p">[</span><span class="n">group</span><span class="p">]);</span>

		<span class="cm">/* Process completed commands. */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">bit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		     <span class="p">(</span><span class="n">bit</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">completed</span><span class="p">;</span>
		     <span class="n">bit</span><span class="o">++</span><span class="p">,</span> <span class="n">completed</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">completed</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">tag</span> <span class="o">=</span> <span class="p">(</span><span class="n">group</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">|</span> <span class="n">bit</span><span class="p">;</span>

				<span class="cm">/* skip internal command slot. */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">tag</span> <span class="o">==</span> <span class="n">MTIP_TAG_INTERNAL</span><span class="p">))</span>
					<span class="k">continue</span><span class="p">;</span>

				<span class="n">command</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">commands</span><span class="p">[</span><span class="n">tag</span><span class="p">];</span>
				<span class="cm">/* make internal callback */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">command</span><span class="o">-&gt;</span><span class="n">comp_func</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">command</span><span class="o">-&gt;</span><span class="n">comp_func</span><span class="p">(</span>
						<span class="n">port</span><span class="p">,</span>
						<span class="n">tag</span><span class="p">,</span>
						<span class="n">command</span><span class="o">-&gt;</span><span class="n">comp_data</span><span class="p">,</span>
						<span class="mi">0</span><span class="p">);</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
						<span class="s">&quot;Null completion &quot;</span>
						<span class="s">&quot;for tag %d&quot;</span><span class="p">,</span>
						<span class="n">tag</span><span class="p">);</span>

					<span class="k">if</span> <span class="p">(</span><span class="n">mtip_check_surprise_removal</span><span class="p">(</span>
						<span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">))</span> <span class="p">{</span>
						<span class="n">mtip_command_cleanup</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>
						<span class="k">return</span><span class="p">;</span>
					<span class="p">}</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Process legacy pio and d2h interrupts</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">mtip_process_legacy</span><span class="p">(</span><span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="n">u32</span> <span class="n">port_stat</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mtip_port</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mtip_cmd</span> <span class="o">*</span><span class="n">cmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">commands</span><span class="p">[</span><span class="n">MTIP_TAG_INTERNAL</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">MTIP_PF_IC_ACTIVE_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">cmd</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">cmd_issue</span><span class="p">[</span><span class="n">MTIP_TAG_INTERNAL</span><span class="p">])</span>
		<span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">MTIP_TAG_INTERNAL</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">comp_func</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">comp_func</span><span class="p">(</span><span class="n">port</span><span class="p">,</span>
				<span class="n">MTIP_TAG_INTERNAL</span><span class="p">,</span>
				<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">comp_data</span><span class="p">,</span>
				<span class="mi">0</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Demux and handle errors</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">mtip_process_errors</span><span class="p">(</span><span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="n">u32</span> <span class="n">port_stat</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">port_stat</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PORT_IRQ_TF_ERR</span> <span class="o">|</span> <span class="n">PORT_IRQ_IF_ERR</span><span class="p">)))</span>
		<span class="n">mtip_handle_tfe</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">port_stat</span> <span class="o">&amp;</span> <span class="n">PORT_IRQ_CONNECT</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;Clearing PxSERR.DIAG.x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">writel</span><span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">26</span><span class="p">),</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">PORT_SCR_ERR</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">port_stat</span> <span class="o">&amp;</span> <span class="n">PORT_IRQ_PHYRDY</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;Clearing PxSERR.DIAG.n</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">writel</span><span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">),</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">PORT_SCR_ERR</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">port_stat</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PORT_IRQ_HANDLED</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;Port stat errors %x unhandled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="n">port_stat</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PORT_IRQ_HANDLED</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">irqreturn_t</span> <span class="nf">mtip_handle_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">dd</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mtip_port</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">hba_stat</span><span class="p">,</span> <span class="n">port_stat</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rv</span> <span class="o">=</span> <span class="n">IRQ_NONE</span><span class="p">;</span>

	<span class="n">hba_stat</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">HOST_IRQ_STAT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hba_stat</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rv</span> <span class="o">=</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>

		<span class="cm">/* Acknowledge the interrupt status on the port.*/</span>
		<span class="n">port_stat</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">PORT_IRQ_STAT</span><span class="p">);</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">port_stat</span><span class="p">,</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">PORT_IRQ_STAT</span><span class="p">);</span>

		<span class="cm">/* Demux port status */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">port_stat</span> <span class="o">&amp;</span> <span class="n">PORT_IRQ_SDB_FIS</span><span class="p">))</span>
			<span class="n">mtip_process_sdbf</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">port_stat</span> <span class="o">&amp;</span> <span class="n">PORT_IRQ_ERR</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">mtip_check_surprise_removal</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">mtip_command_cleanup</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>
				<span class="cm">/* don&#39;t proceed further */</span>
				<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">MTIP_DDF_REMOVE_PENDING_BIT</span><span class="p">,</span>
							<span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">dd_flag</span><span class="p">))</span>
				<span class="k">return</span> <span class="n">rv</span><span class="p">;</span>

			<span class="n">mtip_process_errors</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">port_stat</span> <span class="o">&amp;</span> <span class="n">PORT_IRQ_ERR</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">port_stat</span> <span class="o">&amp;</span> <span class="n">PORT_IRQ_LEGACY</span><span class="p">))</span>
			<span class="n">mtip_process_legacy</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">port_stat</span> <span class="o">&amp;</span> <span class="n">PORT_IRQ_LEGACY</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* acknowledge interrupt */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">hba_stat</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">HOST_IRQ_STAT</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rv</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Wrapper for mtip_handle_irq</span>
<span class="cm"> * (ignores return code)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mtip_tasklet</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mtip_handle_irq</span><span class="p">((</span><span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * HBA interrupt subroutine.</span>
<span class="cm"> *</span>
<span class="cm"> * @irq		IRQ number.</span>
<span class="cm"> * @instance	Pointer to the driver data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * return value</span>
<span class="cm"> *	IRQ_HANDLED	A HBA interrupt was pending and handled.</span>
<span class="cm"> *	IRQ_NONE	This interrupt was not for the HBA.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">mtip_irq_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">instance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">dd</span> <span class="o">=</span> <span class="n">instance</span><span class="p">;</span>
	<span class="n">tasklet_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">tasklet</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mtip_issue_non_ncq_command</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtip_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">commands</span><span class="p">[</span><span class="n">tag</span><span class="p">].</span><span class="n">active</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">MTIP_TAG_BIT</span><span class="p">(</span><span class="n">tag</span><span class="p">),</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">cmd_issue</span><span class="p">[</span><span class="n">MTIP_TAG_INDEX</span><span class="p">(</span><span class="n">tag</span><span class="p">)]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">mtip_pause_ncq</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtip_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">host_to_dev_fis</span> <span class="o">*</span><span class="n">fis</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">host_to_dev_fis</span> <span class="o">*</span><span class="n">reply</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">task_file_data</span><span class="p">;</span>

	<span class="n">reply</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">rxfis</span> <span class="o">+</span> <span class="n">RX_FIS_D2H_REG</span><span class="p">;</span>
	<span class="n">task_file_data</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">mmio</span><span class="o">+</span><span class="n">PORT_TFDATA</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">task_file_data</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">fis</span><span class="o">-&gt;</span><span class="n">command</span> <span class="o">==</span> <span class="n">ATA_CMD_SEC_ERASE_UNIT</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fis</span><span class="o">-&gt;</span><span class="n">command</span> <span class="o">==</span> <span class="n">ATA_CMD_SEC_ERASE_PREP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">MTIP_PF_SE_ACTIVE_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">ic_pause_timer</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">fis</span><span class="o">-&gt;</span><span class="n">command</span> <span class="o">==</span> <span class="n">ATA_CMD_DOWNLOAD_MICRO</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
					<span class="p">(</span><span class="n">fis</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">==</span> <span class="mh">0x03</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">MTIP_PF_DM_ACTIVE_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">ic_pause_timer</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">fis</span><span class="o">-&gt;</span><span class="n">command</span> <span class="o">==</span> <span class="n">ATA_CMD_SEC_ERASE_UNIT</span><span class="p">)</span> <span class="o">||</span>
		<span class="p">((</span><span class="n">fis</span><span class="o">-&gt;</span><span class="n">command</span> <span class="o">==</span> <span class="mh">0xFC</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">fis</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">==</span> <span class="mh">0x27</span> <span class="o">||</span> <span class="n">fis</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">==</span> <span class="mh">0x72</span> <span class="o">||</span>
			 <span class="n">fis</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">==</span> <span class="mh">0x62</span> <span class="o">||</span> <span class="n">fis</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">==</span> <span class="mh">0x26</span><span class="p">)))</span> <span class="p">{</span>
		<span class="cm">/* Com reset after secure erase or lowlevel format */</span>
		<span class="n">mtip_restart_port</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Wait for port to quiesce</span>
<span class="cm"> *</span>
<span class="cm"> * @port    Pointer to port data structure</span>
<span class="cm"> * @timeout Max duration to wait (ms)</span>
<span class="cm"> *</span>
<span class="cm"> * return value</span>
<span class="cm"> *	0	Success</span>
<span class="cm"> *	-EBUSY  Commands still active</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mtip_quiesce_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtip_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">to</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">active</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">to</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">timeout</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">MTIP_PF_SVC_THD_ACTIVE_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="n">test_bit</span><span class="p">(</span><span class="n">MTIP_PF_ISSUE_CMDS_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">msleep</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span> <span class="cm">/* svc thd is actively issuing commands */</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">MTIP_DDF_REMOVE_PENDING_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">dd_flag</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Ignore s_active bit 0 of array element 0.</span>
<span class="cm">		 * This bit will always be set</span>
<span class="cm">		 */</span>
		<span class="n">active</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">s_active</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFFFE</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">slot_groups</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span>
			<span class="n">active</span> <span class="o">|=</span> <span class="n">readl</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">s_active</span><span class="p">[</span><span class="n">n</span><span class="p">]);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">active</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">msleep</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">to</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">active</span> <span class="o">?</span> <span class="o">-</span><span class="n">EBUSY</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Execute an internal command and wait for the completion.</span>
<span class="cm"> *</span>
<span class="cm"> * @port    Pointer to the port data structure.</span>
<span class="cm"> * @fis     Pointer to the FIS that describes the command.</span>
<span class="cm"> * @fis_len  Length in WORDS of the FIS.</span>
<span class="cm"> * @buffer  DMA accessible for command data.</span>
<span class="cm"> * @buf_len  Length, in bytes, of the data buffer.</span>
<span class="cm"> * @opts    Command header options, excluding the FIS length</span>
<span class="cm"> *             and the number of PRD entries.</span>
<span class="cm"> * @timeout Time in ms to wait for the command to complete.</span>
<span class="cm"> *</span>
<span class="cm"> * return value</span>
<span class="cm"> *	0	 Command completed successfully.</span>
<span class="cm"> *	-EFAULT  The buffer address is not correctly aligned.</span>
<span class="cm"> *	-EBUSY   Internal command or other IO in progress.</span>
<span class="cm"> *	-EAGAIN  Time out waiting for command to complete.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mtip_exec_internal_command</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtip_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">host_to_dev_fis</span> <span class="o">*</span><span class="n">fis</span><span class="p">,</span>
					<span class="kt">int</span> <span class="n">fis_len</span><span class="p">,</span>
					<span class="n">dma_addr_t</span> <span class="n">buffer</span><span class="p">,</span>
					<span class="kt">int</span> <span class="n">buf_len</span><span class="p">,</span>
					<span class="n">u32</span> <span class="n">opts</span><span class="p">,</span>
					<span class="n">gfp_t</span> <span class="n">atomic</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mtip_cmd_sg</span> <span class="o">*</span><span class="n">command_sg</span><span class="p">;</span>
	<span class="n">DECLARE_COMPLETION_ONSTACK</span><span class="p">(</span><span class="n">wait</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">rv</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ready2go</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mtip_cmd</span> <span class="o">*</span><span class="n">int_cmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">commands</span><span class="p">[</span><span class="n">MTIP_TAG_INTERNAL</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">to</span><span class="p">;</span>

	<span class="cm">/* Make sure the buffer is 8 byte aligned. This is asic specific. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buffer</span> <span class="o">&amp;</span> <span class="mh">0x00000007</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;SG buffer is not 8 byte aligned</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">to</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">timeout</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">ready2go</span> <span class="o">=</span> <span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">MTIP_TAG_INTERNAL</span><span class="p">,</span>
						<span class="n">port</span><span class="o">-&gt;</span><span class="n">allocated</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ready2go</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">mdelay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">to</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ready2go</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;Internal cmd active. new cmd [%02X]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fis</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">MTIP_PF_IC_ACTIVE_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">port</span><span class="o">-&gt;</span><span class="n">ic_pause_timer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fis</span><span class="o">-&gt;</span><span class="n">command</span> <span class="o">==</span> <span class="n">ATA_CMD_SEC_ERASE_UNIT</span><span class="p">)</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">MTIP_PF_SE_ACTIVE_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">fis</span><span class="o">-&gt;</span><span class="n">command</span> <span class="o">==</span> <span class="n">ATA_CMD_DOWNLOAD_MICRO</span><span class="p">)</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">MTIP_PF_DM_ACTIVE_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic</span> <span class="o">==</span> <span class="n">GFP_KERNEL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fis</span><span class="o">-&gt;</span><span class="n">command</span> <span class="o">!=</span> <span class="n">ATA_CMD_STANDBYNOW1</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* wait for io to complete if non atomic */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mtip_quiesce_io</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="mi">5000</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="s">&quot;Failed to quiesce IO</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">release_slot</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">MTIP_TAG_INTERNAL</span><span class="p">);</span>
				<span class="n">clear_bit</span><span class="p">(</span><span class="n">MTIP_PF_IC_ACTIVE_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
				<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">svc_wait</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* Set the completion function and data for the command. */</span>
		<span class="n">int_cmd</span><span class="o">-&gt;</span><span class="n">comp_data</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">;</span>
		<span class="n">int_cmd</span><span class="o">-&gt;</span><span class="n">comp_func</span> <span class="o">=</span> <span class="n">mtip_completion</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Clear completion - we&#39;re going to poll */</span>
		<span class="n">int_cmd</span><span class="o">-&gt;</span><span class="n">comp_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">int_cmd</span><span class="o">-&gt;</span><span class="n">comp_func</span> <span class="o">=</span> <span class="n">mtip_null_completion</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Copy the command to the command table */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">int_cmd</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">,</span> <span class="n">fis</span><span class="p">,</span> <span class="n">fis_len</span><span class="o">*</span><span class="mi">4</span><span class="p">);</span>

	<span class="cm">/* Populate the SG list */</span>
	<span class="n">int_cmd</span><span class="o">-&gt;</span><span class="n">command_header</span><span class="o">-&gt;</span><span class="n">opts</span> <span class="o">=</span>
		 <span class="n">__force_bit2int</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">opts</span> <span class="o">|</span> <span class="n">fis_len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buf_len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">command_sg</span> <span class="o">=</span> <span class="n">int_cmd</span><span class="o">-&gt;</span><span class="n">command</span> <span class="o">+</span> <span class="n">AHCI_CMD_TBL_HDR_SZ</span><span class="p">;</span>

		<span class="n">command_sg</span><span class="o">-&gt;</span><span class="n">info</span> <span class="o">=</span>
			<span class="n">__force_bit2int</span> <span class="n">cpu_to_le32</span><span class="p">((</span><span class="n">buf_len</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3FFFFF</span><span class="p">);</span>
		<span class="n">command_sg</span><span class="o">-&gt;</span><span class="n">dba</span>	<span class="o">=</span>
			<span class="n">__force_bit2int</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">buffer</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFFFF</span><span class="p">);</span>
		<span class="n">command_sg</span><span class="o">-&gt;</span><span class="n">dba_upper</span> <span class="o">=</span>
			<span class="n">__force_bit2int</span> <span class="n">cpu_to_le32</span><span class="p">((</span><span class="n">buffer</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">);</span>

		<span class="n">int_cmd</span><span class="o">-&gt;</span><span class="n">command_header</span><span class="o">-&gt;</span><span class="n">opts</span> <span class="o">|=</span>
			<span class="n">__force_bit2int</span> <span class="n">cpu_to_le32</span><span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="cm">/* Populate the command header */</span>
	<span class="n">int_cmd</span><span class="o">-&gt;</span><span class="n">command_header</span><span class="o">-&gt;</span><span class="n">byte_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Issue the command to the hardware */</span>
	<span class="n">mtip_issue_non_ncq_command</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">MTIP_TAG_INTERNAL</span><span class="p">);</span>

	<span class="cm">/* Poll if atomic, wait_for_completion otherwise */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic</span> <span class="o">==</span> <span class="n">GFP_KERNEL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Wait for the command to complete or timeout. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wait_for_completion_timeout</span><span class="p">(</span>
				<span class="o">&amp;</span><span class="n">wait</span><span class="p">,</span>
				<span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">timeout</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;Internal command did not complete [%d] &quot;</span>
				<span class="s">&quot;within timeout of  %lu ms</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">atomic</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mtip_check_surprise_removal</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">)</span> <span class="o">||</span>
				<span class="n">test_bit</span><span class="p">(</span><span class="n">MTIP_DDF_REMOVE_PENDING_BIT</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">dd_flag</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">rv</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">exec_ic_exit</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">rv</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Spin for &lt;timeout&gt; checking if command still outstanding */</span>
		<span class="n">timeout</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">timeout</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">((</span><span class="n">readl</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">cmd_issue</span><span class="p">[</span><span class="n">MTIP_TAG_INTERNAL</span><span class="p">])</span>
				<span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">MTIP_TAG_INTERNAL</span><span class="p">))</span>
				<span class="o">&amp;&amp;</span> <span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">timeout</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mtip_check_surprise_removal</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">rv</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">exec_ic_exit</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">fis</span><span class="o">-&gt;</span><span class="n">command</span> <span class="o">!=</span> <span class="n">ATA_CMD_STANDBYNOW1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				<span class="n">test_bit</span><span class="p">(</span><span class="n">MTIP_DDF_REMOVE_PENDING_BIT</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">dd_flag</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">rv</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">exec_ic_exit</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">PORT_IRQ_STAT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PORT_IRQ_ERR</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">int_cmd</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">);</span> <span class="cm">/* error */</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">int_cmd</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;Internal command [%02X] failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fis</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">);</span>
		<span class="n">rv</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">cmd_issue</span><span class="p">[</span><span class="n">MTIP_TAG_INTERNAL</span><span class="p">])</span>
			<span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">MTIP_TAG_INTERNAL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rv</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">MTIP_DDF_REMOVE_PENDING_BIT</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">dd_flag</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">mtip_restart_port</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>
			<span class="n">rv</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">exec_ic_exit:</span>
	<span class="cm">/* Clear the allocated and active bits for the internal command. */</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">int_cmd</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">release_slot</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">MTIP_TAG_INTERNAL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rv</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">mtip_pause_ncq</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">fis</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* NCQ paused */</span>
		<span class="k">return</span> <span class="n">rv</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">MTIP_PF_IC_ACTIVE_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">svc_wait</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rv</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Byte-swap ATA ID strings.</span>
<span class="cm"> *</span>
<span class="cm"> * ATA identify data contains strings in byte-swapped 16-bit words.</span>
<span class="cm"> * They must be swapped (on all architectures) to be usable as C strings.</span>
<span class="cm"> * This function swaps bytes in-place.</span>
<span class="cm"> *</span>
<span class="cm"> * @buf The buffer location of the string</span>
<span class="cm"> * @len The number of bytes to swap</span>
<span class="cm"> *</span>
<span class="cm"> * return value</span>
<span class="cm"> *	None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ata_swap_string</span><span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">len</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">be16_to_cpus</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Request the device identity information.</span>
<span class="cm"> *</span>
<span class="cm"> * If a user space buffer is not specified, i.e. is NULL, the</span>
<span class="cm"> * identify information is still read from the drive and placed</span>
<span class="cm"> * into the identify data buffer (@e port-&gt;identify) in the</span>
<span class="cm"> * port data structure.</span>
<span class="cm"> * When the identify buffer contains valid identify information @e</span>
<span class="cm"> * port-&gt;identify_valid is non-zero.</span>
<span class="cm"> *</span>
<span class="cm"> * @port	 Pointer to the port structure.</span>
<span class="cm"> * @user_buffer  A user space buffer where the identify data should be</span>
<span class="cm"> *                    copied.</span>
<span class="cm"> *</span>
<span class="cm"> * return value</span>
<span class="cm"> *	0	Command completed successfully.</span>
<span class="cm"> *	-EFAULT An error occurred while coping data to the user buffer.</span>
<span class="cm"> *	-1	Command failed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mtip_get_identify</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtip_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">user_buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rv</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">host_to_dev_fis</span> <span class="n">fis</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">MTIP_DDF_REMOVE_PENDING_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">dd_flag</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="cm">/* Build the FIS. */</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fis</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">host_to_dev_fis</span><span class="p">));</span>
	<span class="n">fis</span><span class="p">.</span><span class="n">type</span>	<span class="o">=</span> <span class="mh">0x27</span><span class="p">;</span>
	<span class="n">fis</span><span class="p">.</span><span class="n">opts</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">;</span>
	<span class="n">fis</span><span class="p">.</span><span class="n">command</span>	<span class="o">=</span> <span class="n">ATA_CMD_ID_ATA</span><span class="p">;</span>

	<span class="cm">/* Set the identify information as invalid. */</span>
	<span class="n">port</span><span class="o">-&gt;</span><span class="n">identify_valid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Clear the identify information. */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">identify</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u16</span><span class="p">)</span> <span class="o">*</span> <span class="n">ATA_ID_WORDS</span><span class="p">);</span>

	<span class="cm">/* Execute the command. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mtip_exec_internal_command</span><span class="p">(</span><span class="n">port</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">fis</span><span class="p">,</span>
				<span class="mi">5</span><span class="p">,</span>
				<span class="n">port</span><span class="o">-&gt;</span><span class="n">identify_dma</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="n">u16</span><span class="p">)</span> <span class="o">*</span> <span class="n">ATA_ID_WORDS</span><span class="p">,</span>
				<span class="mi">0</span><span class="p">,</span>
				<span class="n">GFP_KERNEL</span><span class="p">,</span>
				<span class="n">MTIP_INTERNAL_COMMAND_TIMEOUT_MS</span><span class="p">)</span>
				<span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rv</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Perform any necessary byte-swapping.  Yes, the kernel does in fact</span>
<span class="cm">	 * perform field-sensitive swapping on the string fields.</span>
<span class="cm">	 * See the kernel use of ata_id_string() for proof of this.</span>
<span class="cm">	 */</span>
<span class="cp">#ifdef __LITTLE_ENDIAN</span>
	<span class="n">ata_swap_string</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">identify</span> <span class="o">+</span> <span class="mi">27</span><span class="p">,</span> <span class="mi">40</span><span class="p">);</span>  <span class="cm">/* model string*/</span>
	<span class="n">ata_swap_string</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">identify</span> <span class="o">+</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>   <span class="cm">/* firmware string*/</span>
	<span class="n">ata_swap_string</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">identify</span> <span class="o">+</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>  <span class="cm">/* serial# string*/</span>
<span class="cp">#else</span>
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ATA_ID_WORDS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">port</span><span class="o">-&gt;</span><span class="n">identify</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">identify</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="cm">/* Set the identify buffer as valid. */</span>
	<span class="n">port</span><span class="o">-&gt;</span><span class="n">identify_valid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">user_buffer</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span>
			<span class="n">user_buffer</span><span class="p">,</span>
			<span class="n">port</span><span class="o">-&gt;</span><span class="n">identify</span><span class="p">,</span>
			<span class="n">ATA_ID_WORDS</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u16</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">rv</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">rv</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Issue a standby immediate command to the device.</span>
<span class="cm"> *</span>
<span class="cm"> * @port Pointer to the port structure.</span>
<span class="cm"> *</span>
<span class="cm"> * return value</span>
<span class="cm"> *	0	Command was executed successfully.</span>
<span class="cm"> *	-1	An error occurred while executing the command.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mtip_standby_immediate</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtip_port</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">host_to_dev_fis</span>	<span class="n">fis</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">;</span>

	<span class="cm">/* Build the FIS. */</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fis</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">host_to_dev_fis</span><span class="p">));</span>
	<span class="n">fis</span><span class="p">.</span><span class="n">type</span>	<span class="o">=</span> <span class="mh">0x27</span><span class="p">;</span>
	<span class="n">fis</span><span class="p">.</span><span class="n">opts</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">;</span>
	<span class="n">fis</span><span class="p">.</span><span class="n">command</span>	<span class="o">=</span> <span class="n">ATA_CMD_STANDBYNOW1</span><span class="p">;</span>

	<span class="n">start</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">rv</span> <span class="o">=</span> <span class="n">mtip_exec_internal_command</span><span class="p">(</span><span class="n">port</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">fis</span><span class="p">,</span>
					<span class="mi">5</span><span class="p">,</span>
					<span class="mi">0</span><span class="p">,</span>
					<span class="mi">0</span><span class="p">,</span>
					<span class="mi">0</span><span class="p">,</span>
					<span class="n">GFP_ATOMIC</span><span class="p">,</span>
					<span class="mi">15000</span><span class="p">);</span>
	<span class="n">dbg_printk</span><span class="p">(</span><span class="n">MTIP_DRV_NAME</span> <span class="s">&quot;Time taken to complete standby cmd: %d ms</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">jiffies_to_msecs</span><span class="p">(</span><span class="n">jiffies</span> <span class="o">-</span> <span class="n">start</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rv</span><span class="p">)</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;STANDBY IMMEDIATE command failed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rv</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Issue a READ LOG EXT command to the device.</span>
<span class="cm"> *</span>
<span class="cm"> * @port	pointer to the port structure.</span>
<span class="cm"> * @page	page number to fetch</span>
<span class="cm"> * @buffer	pointer to buffer</span>
<span class="cm"> * @buffer_dma	dma address corresponding to @buffer</span>
<span class="cm"> * @sectors	page length to fetch, in sectors</span>
<span class="cm"> *</span>
<span class="cm"> * return value</span>
<span class="cm"> *	@rv	return value from mtip_exec_internal_command()</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mtip_read_log_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtip_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="n">u8</span> <span class="n">page</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
				<span class="n">dma_addr_t</span> <span class="n">buffer_dma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sectors</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">host_to_dev_fis</span> <span class="n">fis</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fis</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">host_to_dev_fis</span><span class="p">));</span>
	<span class="n">fis</span><span class="p">.</span><span class="n">type</span>	<span class="o">=</span> <span class="mh">0x27</span><span class="p">;</span>
	<span class="n">fis</span><span class="p">.</span><span class="n">opts</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">;</span>
	<span class="n">fis</span><span class="p">.</span><span class="n">command</span>	<span class="o">=</span> <span class="n">ATA_CMD_READ_LOG_EXT</span><span class="p">;</span>
	<span class="n">fis</span><span class="p">.</span><span class="n">sect_count</span>	<span class="o">=</span> <span class="n">sectors</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>
	<span class="n">fis</span><span class="p">.</span><span class="n">sect_cnt_ex</span>	<span class="o">=</span> <span class="p">(</span><span class="n">sectors</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>
	<span class="n">fis</span><span class="p">.</span><span class="n">lba_low</span>	<span class="o">=</span> <span class="n">page</span><span class="p">;</span>
	<span class="n">fis</span><span class="p">.</span><span class="n">lba_mid</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">fis</span><span class="p">.</span><span class="n">device</span>	<span class="o">=</span> <span class="n">ATA_DEVICE_OBS</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sectors</span> <span class="o">*</span> <span class="n">ATA_SECT_SIZE</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">mtip_exec_internal_command</span><span class="p">(</span><span class="n">port</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">fis</span><span class="p">,</span>
					<span class="mi">5</span><span class="p">,</span>
					<span class="n">buffer_dma</span><span class="p">,</span>
					<span class="n">sectors</span> <span class="o">*</span> <span class="n">ATA_SECT_SIZE</span><span class="p">,</span>
					<span class="mi">0</span><span class="p">,</span>
					<span class="n">GFP_ATOMIC</span><span class="p">,</span>
					<span class="n">MTIP_INTERNAL_COMMAND_TIMEOUT_MS</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Issue a SMART READ DATA command to the device.</span>
<span class="cm"> *</span>
<span class="cm"> * @port	pointer to the port structure.</span>
<span class="cm"> * @buffer	pointer to buffer</span>
<span class="cm"> * @buffer_dma	dma address corresponding to @buffer</span>
<span class="cm"> *</span>
<span class="cm"> * return value</span>
<span class="cm"> *	@rv	return value from mtip_exec_internal_command()</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mtip_get_smart_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtip_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
					<span class="n">dma_addr_t</span> <span class="n">buffer_dma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">host_to_dev_fis</span> <span class="n">fis</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fis</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">host_to_dev_fis</span><span class="p">));</span>
	<span class="n">fis</span><span class="p">.</span><span class="n">type</span>	<span class="o">=</span> <span class="mh">0x27</span><span class="p">;</span>
	<span class="n">fis</span><span class="p">.</span><span class="n">opts</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">;</span>
	<span class="n">fis</span><span class="p">.</span><span class="n">command</span>	<span class="o">=</span> <span class="n">ATA_CMD_SMART</span><span class="p">;</span>
	<span class="n">fis</span><span class="p">.</span><span class="n">features</span>	<span class="o">=</span> <span class="mh">0xD0</span><span class="p">;</span>
	<span class="n">fis</span><span class="p">.</span><span class="n">sect_count</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">fis</span><span class="p">.</span><span class="n">lba_mid</span>	<span class="o">=</span> <span class="mh">0x4F</span><span class="p">;</span>
	<span class="n">fis</span><span class="p">.</span><span class="n">lba_hi</span>	<span class="o">=</span> <span class="mh">0xC2</span><span class="p">;</span>
	<span class="n">fis</span><span class="p">.</span><span class="n">device</span>	<span class="o">=</span> <span class="n">ATA_DEVICE_OBS</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">mtip_exec_internal_command</span><span class="p">(</span><span class="n">port</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">fis</span><span class="p">,</span>
					<span class="mi">5</span><span class="p">,</span>
					<span class="n">buffer_dma</span><span class="p">,</span>
					<span class="n">ATA_SECT_SIZE</span><span class="p">,</span>
					<span class="mi">0</span><span class="p">,</span>
					<span class="n">GFP_ATOMIC</span><span class="p">,</span>
					<span class="mi">15000</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Get the value of a smart attribute</span>
<span class="cm"> *</span>
<span class="cm"> * @port	pointer to the port structure</span>
<span class="cm"> * @id		attribute number</span>
<span class="cm"> * @attrib	pointer to return attrib information corresponding to @id</span>
<span class="cm"> *</span>
<span class="cm"> * return value</span>
<span class="cm"> *	-EINVAL	NULL buffer passed or unsupported attribute @id.</span>
<span class="cm"> *	-EPERM	Identify data not valid, SMART not supported or not enabled</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mtip_get_smart_attr</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtip_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">id</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">smart_attr</span> <span class="o">*</span><span class="n">attrib</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rv</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">smart_attr</span> <span class="o">*</span><span class="n">pattr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">attrib</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">identify_valid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;IDENTIFY DATA not valid</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">identify</span><span class="p">[</span><span class="mi">82</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;SMART not supported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">identify</span><span class="p">[</span><span class="mi">85</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;SMART not enabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">smart_buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ATA_SECT_SIZE</span><span class="p">);</span>
	<span class="n">rv</span> <span class="o">=</span> <span class="n">mtip_get_smart_data</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">smart_buf</span><span class="p">,</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">smart_buf_dma</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rv</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Failed to ge SMART data</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rv</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pattr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">smart_attr</span> <span class="o">*</span><span class="p">)(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">smart_buf</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">29</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">pattr</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pattr</span><span class="o">-&gt;</span><span class="n">attr_id</span> <span class="o">==</span> <span class="n">id</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">attrib</span><span class="p">,</span> <span class="n">pattr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">smart_attr</span><span class="p">));</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">29</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;Query for invalid SMART attribute ID</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">rv</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">rv</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Get the drive capacity.</span>
<span class="cm"> *</span>
<span class="cm"> * @dd      Pointer to the device data structure.</span>
<span class="cm"> * @sectors Pointer to the variable that will receive the sector count.</span>
<span class="cm"> *</span>
<span class="cm"> * return value</span>
<span class="cm"> *	1 Capacity was returned successfully.</span>
<span class="cm"> *	0 The identify information is invalid.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">mtip_hw_get_capacity</span><span class="p">(</span><span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="n">sector_t</span> <span class="o">*</span><span class="n">sectors</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mtip_port</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">total</span><span class="p">,</span> <span class="n">raw0</span><span class="p">,</span> <span class="n">raw1</span><span class="p">,</span> <span class="n">raw2</span><span class="p">,</span> <span class="n">raw3</span><span class="p">;</span>
	<span class="n">raw0</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">identify</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
	<span class="n">raw1</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">identify</span><span class="p">[</span><span class="mi">101</span><span class="p">];</span>
	<span class="n">raw2</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">identify</span><span class="p">[</span><span class="mi">102</span><span class="p">];</span>
	<span class="n">raw3</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">identify</span><span class="p">[</span><span class="mi">103</span><span class="p">];</span>
	<span class="n">total</span> <span class="o">=</span> <span class="n">raw0</span> <span class="o">|</span> <span class="n">raw1</span><span class="o">&lt;&lt;</span><span class="mi">16</span> <span class="o">|</span> <span class="n">raw2</span><span class="o">&lt;&lt;</span><span class="mi">32</span> <span class="o">|</span> <span class="n">raw3</span><span class="o">&lt;&lt;</span><span class="mi">48</span><span class="p">;</span>
	<span class="o">*</span><span class="n">sectors</span> <span class="o">=</span> <span class="n">total</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">bool</span><span class="p">)</span> <span class="o">!!</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">identify_valid</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Reset the HBA.</span>
<span class="cm"> *</span>
<span class="cm"> * Resets the HBA by setting the HBA Reset bit in the Global</span>
<span class="cm"> * HBA Control register. After setting the HBA Reset bit the</span>
<span class="cm"> * function waits for 1 second before reading the HBA Reset</span>
<span class="cm"> * bit to make sure it has cleared. If HBA Reset is not clear</span>
<span class="cm"> * an error is returned. Cannot be used in non-blockable</span>
<span class="cm"> * context.</span>
<span class="cm"> *</span>
<span class="cm"> * @dd Pointer to the driver data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * return value</span>
<span class="cm"> *	0  The reset was successful.</span>
<span class="cm"> *	-1 The HBA Reset bit did not clear.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mtip_hba_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">dd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mtip_deinit_port</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">);</span>

	<span class="cm">/* Set the reset bit */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">HOST_RESET</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">HOST_CTL</span><span class="p">);</span>

	<span class="cm">/* Flush */</span>
	<span class="n">readl</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">HOST_CTL</span><span class="p">);</span>

	<span class="cm">/* Wait for reset to clear */</span>
	<span class="n">ssleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* Check the bit has cleared */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">HOST_CTL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">HOST_RESET</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;Reset bit did not clear.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Display the identify command data.</span>
<span class="cm"> *</span>
<span class="cm"> * @port Pointer to the port data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * return value</span>
<span class="cm"> *	None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mtip_dump_identify</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtip_port</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sector_t</span> <span class="n">sectors</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">revid</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">cbuf</span><span class="p">[</span><span class="mi">42</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">identify_valid</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">strlcpy</span><span class="p">(</span><span class="n">cbuf</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">identify</span><span class="o">+</span><span class="mi">10</span><span class="p">),</span> <span class="mi">21</span><span class="p">);</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;Serial No.: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cbuf</span><span class="p">);</span>

	<span class="n">strlcpy</span><span class="p">(</span><span class="n">cbuf</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">identify</span><span class="o">+</span><span class="mi">23</span><span class="p">),</span> <span class="mi">9</span><span class="p">);</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;Firmware Ver.: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cbuf</span><span class="p">);</span>

	<span class="n">strlcpy</span><span class="p">(</span><span class="n">cbuf</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">identify</span><span class="o">+</span><span class="mi">27</span><span class="p">),</span> <span class="mi">41</span><span class="p">);</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Model: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cbuf</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mtip_hw_get_capacity</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">dd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sectors</span><span class="p">))</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;Capacity: %llu sectors (%llu MB)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">sectors</span><span class="p">,</span>
			 <span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">sectors</span><span class="p">)</span> <span class="o">*</span> <span class="n">ATA_SECT_SIZE</span> <span class="o">&gt;&gt;</span> <span class="mi">20</span><span class="p">);</span>

	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_REVISION_ID</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">revid</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">revid</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mh">0x1</span>:
		<span class="n">strlcpy</span><span class="p">(</span><span class="n">cbuf</span><span class="p">,</span> <span class="s">&quot;A0&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x3</span>:
		<span class="n">strlcpy</span><span class="p">(</span><span class="n">cbuf</span><span class="p">,</span> <span class="s">&quot;A2&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">strlcpy</span><span class="p">(</span><span class="n">cbuf</span><span class="p">,</span> <span class="s">&quot;?&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;Card Type: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cbuf</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Map the commands scatter list into the command table.</span>
<span class="cm"> *</span>
<span class="cm"> * @command Pointer to the command.</span>
<span class="cm"> * @nents Number of scatter list entries.</span>
<span class="cm"> *</span>
<span class="cm"> * return value</span>
<span class="cm"> *	None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">fill_command_sg</span><span class="p">(</span><span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">mtip_cmd</span> <span class="o">*</span><span class="n">command</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">nents</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dma_len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mtip_cmd_sg</span> <span class="o">*</span><span class="n">command_sg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span> <span class="o">=</span> <span class="n">command</span><span class="o">-&gt;</span><span class="n">sg</span><span class="p">;</span>

	<span class="n">command_sg</span> <span class="o">=</span> <span class="n">command</span><span class="o">-&gt;</span><span class="n">command</span> <span class="o">+</span> <span class="n">AHCI_CMD_TBL_HDR_SZ</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">nents</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dma_len</span> <span class="o">=</span> <span class="n">sg_dma_len</span><span class="p">(</span><span class="n">sg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dma_len</span> <span class="o">&gt;</span> <span class="mh">0x400000</span><span class="p">)</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;DMA segment length truncated</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">command_sg</span><span class="o">-&gt;</span><span class="n">info</span> <span class="o">=</span> <span class="n">__force_bit2int</span>
			<span class="n">cpu_to_le32</span><span class="p">((</span><span class="n">dma_len</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3FFFFF</span><span class="p">);</span>
		<span class="n">command_sg</span><span class="o">-&gt;</span><span class="n">dba</span>	<span class="o">=</span> <span class="n">__force_bit2int</span>
			<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">sg_dma_address</span><span class="p">(</span><span class="n">sg</span><span class="p">));</span>
		<span class="n">command_sg</span><span class="o">-&gt;</span><span class="n">dba_upper</span> <span class="o">=</span> <span class="n">__force_bit2int</span>
			<span class="n">cpu_to_le32</span><span class="p">((</span><span class="n">sg_dma_address</span><span class="p">(</span><span class="n">sg</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">);</span>
		<span class="n">command_sg</span><span class="o">++</span><span class="p">;</span>
		<span class="n">sg</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * @brief Execute a drive command.</span>
<span class="cm"> *</span>
<span class="cm"> * return value 0 The command completed successfully.</span>
<span class="cm"> * return value -1 An error occurred while executing the command.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">exec_drive_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtip_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">command</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">host_to_dev_fis</span>	<span class="n">fis</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">host_to_dev_fis</span> <span class="o">*</span><span class="n">reply</span> <span class="o">=</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">rxfis</span> <span class="o">+</span> <span class="n">RX_FIS_D2H_REG</span><span class="p">);</span>

	<span class="cm">/* Build the FIS. */</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fis</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">host_to_dev_fis</span><span class="p">));</span>
	<span class="n">fis</span><span class="p">.</span><span class="n">type</span>	<span class="o">=</span> <span class="mh">0x27</span><span class="p">;</span>
	<span class="n">fis</span><span class="p">.</span><span class="n">opts</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">;</span>
	<span class="n">fis</span><span class="p">.</span><span class="n">command</span>	<span class="o">=</span> <span class="n">command</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">fis</span><span class="p">.</span><span class="n">features</span>	<span class="o">=</span> <span class="n">command</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">fis</span><span class="p">.</span><span class="n">sect_count</span>	<span class="o">=</span> <span class="n">command</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="n">fis</span><span class="p">.</span><span class="n">sector</span>	<span class="o">=</span> <span class="n">command</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="n">fis</span><span class="p">.</span><span class="n">cyl_low</span>	<span class="o">=</span> <span class="n">command</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="n">fis</span><span class="p">.</span><span class="n">cyl_hi</span>	<span class="o">=</span> <span class="n">command</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
	<span class="n">fis</span><span class="p">.</span><span class="n">device</span>	<span class="o">=</span> <span class="n">command</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x10</span><span class="p">;</span> <span class="cm">/* Clear the dev bit*/</span>

	<span class="n">dbg_printk</span><span class="p">(</span><span class="n">MTIP_DRV_NAME</span> <span class="s">&quot; %s: User Command: cmd %x, feat %x, nsect %x, sect %x, lcyl %x, hcyl %x, sel %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span>
		<span class="n">command</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
		<span class="n">command</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
		<span class="n">command</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
		<span class="n">command</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
		<span class="n">command</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
		<span class="n">command</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span>
		<span class="n">command</span><span class="p">[</span><span class="mi">6</span><span class="p">]);</span>

	<span class="cm">/* Execute the command. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mtip_exec_internal_command</span><span class="p">(</span><span class="n">port</span><span class="p">,</span>
				 <span class="o">&amp;</span><span class="n">fis</span><span class="p">,</span>
				 <span class="mi">5</span><span class="p">,</span>
				 <span class="mi">0</span><span class="p">,</span>
				 <span class="mi">0</span><span class="p">,</span>
				 <span class="mi">0</span><span class="p">,</span>
				 <span class="n">GFP_KERNEL</span><span class="p">,</span>
				 <span class="n">MTIP_IOCTL_COMMAND_TIMEOUT_MS</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">command</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">reply</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">;</span> <span class="cm">/* Status*/</span>
	<span class="n">command</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">reply</span><span class="o">-&gt;</span><span class="n">features</span><span class="p">;</span> <span class="cm">/* Error*/</span>
	<span class="n">command</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">reply</span><span class="o">-&gt;</span><span class="n">cyl_low</span><span class="p">;</span>
	<span class="n">command</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">reply</span><span class="o">-&gt;</span><span class="n">cyl_hi</span><span class="p">;</span>

	<span class="n">dbg_printk</span><span class="p">(</span><span class="n">MTIP_DRV_NAME</span> <span class="s">&quot; %s: Completion Status: stat %x, err %x , cyl_lo %x cyl_hi %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span>
		<span class="n">command</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
		<span class="n">command</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
		<span class="n">command</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
		<span class="n">command</span><span class="p">[</span><span class="mi">5</span><span class="p">]);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * @brief Execute a drive command.</span>
<span class="cm"> *</span>
<span class="cm"> * @param port Pointer to the port data structure.</span>
<span class="cm"> * @param command Pointer to the user specified command parameters.</span>
<span class="cm"> * @param user_buffer Pointer to the user space buffer where read sector</span>
<span class="cm"> *                   data should be copied.</span>
<span class="cm"> *</span>
<span class="cm"> * return value 0 The command completed successfully.</span>
<span class="cm"> * return value -EFAULT An error occurred while copying the completion</span>
<span class="cm"> *                 data to the user space buffer.</span>
<span class="cm"> * return value -1 An error occurred while executing the command.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">exec_drive_command</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtip_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">command</span><span class="p">,</span>
				<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">user_buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">host_to_dev_fis</span>	<span class="n">fis</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">host_to_dev_fis</span> <span class="o">*</span><span class="n">reply</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">dma_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rv</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">xfer_sz</span> <span class="o">=</span> <span class="n">command</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">xfer_sz</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">user_buffer</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

		<span class="n">buf</span> <span class="o">=</span> <span class="n">dmam_alloc_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="n">ATA_SECT_SIZE</span> <span class="o">*</span> <span class="n">xfer_sz</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">dma_addr</span><span class="p">,</span>
				<span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;Memory allocation failed (%d bytes)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">ATA_SECT_SIZE</span> <span class="o">*</span> <span class="n">xfer_sz</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ATA_SECT_SIZE</span> <span class="o">*</span> <span class="n">xfer_sz</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Build the FIS. */</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fis</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">host_to_dev_fis</span><span class="p">));</span>
	<span class="n">fis</span><span class="p">.</span><span class="n">type</span>	<span class="o">=</span> <span class="mh">0x27</span><span class="p">;</span>
	<span class="n">fis</span><span class="p">.</span><span class="n">opts</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">;</span>
	<span class="n">fis</span><span class="p">.</span><span class="n">command</span>	<span class="o">=</span> <span class="n">command</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">fis</span><span class="p">.</span><span class="n">features</span>	<span class="o">=</span> <span class="n">command</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="n">fis</span><span class="p">.</span><span class="n">sect_count</span>	<span class="o">=</span> <span class="n">command</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fis</span><span class="p">.</span><span class="n">command</span> <span class="o">==</span> <span class="n">ATA_CMD_SMART</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fis</span><span class="p">.</span><span class="n">sector</span>	<span class="o">=</span> <span class="n">command</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
		<span class="n">fis</span><span class="p">.</span><span class="n">cyl_low</span>	<span class="o">=</span> <span class="mh">0x4F</span><span class="p">;</span>
		<span class="n">fis</span><span class="p">.</span><span class="n">cyl_hi</span>	<span class="o">=</span> <span class="mh">0xC2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">xfer_sz</span><span class="p">)</span>
		<span class="n">reply</span> <span class="o">=</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">rxfis</span> <span class="o">+</span> <span class="n">RX_FIS_PIO_SETUP</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">reply</span> <span class="o">=</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">rxfis</span> <span class="o">+</span> <span class="n">RX_FIS_D2H_REG</span><span class="p">);</span>

	<span class="n">dbg_printk</span><span class="p">(</span><span class="n">MTIP_DRV_NAME</span>
		<span class="s">&quot; %s: User Command: cmd %x, sect %x, &quot;</span>
		<span class="s">&quot;feat %x, sectcnt %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span>
		<span class="n">command</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
		<span class="n">command</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
		<span class="n">command</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
		<span class="n">command</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>

	<span class="cm">/* Execute the command. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mtip_exec_internal_command</span><span class="p">(</span><span class="n">port</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">fis</span><span class="p">,</span>
				 <span class="mi">5</span><span class="p">,</span>
				 <span class="p">(</span><span class="n">xfer_sz</span> <span class="o">?</span> <span class="n">dma_addr</span> <span class="o">:</span> <span class="mi">0</span><span class="p">),</span>
				 <span class="p">(</span><span class="n">xfer_sz</span> <span class="o">?</span> <span class="n">ATA_SECT_SIZE</span> <span class="o">*</span> <span class="n">xfer_sz</span> <span class="o">:</span> <span class="mi">0</span><span class="p">),</span>
				 <span class="mi">0</span><span class="p">,</span>
				 <span class="n">GFP_KERNEL</span><span class="p">,</span>
				 <span class="n">MTIP_IOCTL_COMMAND_TIMEOUT_MS</span><span class="p">)</span>
				 <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rv</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">exit_drive_command</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Collect the completion status. */</span>
	<span class="n">command</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">reply</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">;</span> <span class="cm">/* Status*/</span>
	<span class="n">command</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">reply</span><span class="o">-&gt;</span><span class="n">features</span><span class="p">;</span> <span class="cm">/* Error*/</span>
	<span class="n">command</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">reply</span><span class="o">-&gt;</span><span class="n">sect_count</span><span class="p">;</span>

	<span class="n">dbg_printk</span><span class="p">(</span><span class="n">MTIP_DRV_NAME</span>
		<span class="s">&quot; %s: Completion Status: stat %x, &quot;</span>
		<span class="s">&quot;err %x, nsect %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span>
		<span class="n">command</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
		<span class="n">command</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
		<span class="n">command</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">xfer_sz</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">user_buffer</span><span class="p">,</span>
				 <span class="n">buf</span><span class="p">,</span>
				 <span class="n">ATA_SECT_SIZE</span> <span class="o">*</span> <span class="n">command</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span> <span class="p">{</span>
			<span class="n">rv</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">exit_drive_command</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">exit_drive_command:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">)</span>
		<span class="n">dmam_free_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="n">ATA_SECT_SIZE</span> <span class="o">*</span> <span class="n">xfer_sz</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">dma_addr</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rv</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Indicates whether a command has a single sector payload.</span>
<span class="cm"> *</span>
<span class="cm"> *  @command passed to the device to perform the certain event.</span>
<span class="cm"> *  @features passed to the device to perform the certain event.</span>
<span class="cm"> *</span>
<span class="cm"> *  return value</span>
<span class="cm"> *	1	command is one that always has a single sector payload,</span>
<span class="cm"> *		regardless of the value in the Sector Count field.</span>
<span class="cm"> *      0       otherwise</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">implicit_sector</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">command</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">features</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rv</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* list of commands that have an implicit sector count of 1 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">command</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ATA_CMD_SEC_SET_PASS</span>:
	<span class="k">case</span> <span class="n">ATA_CMD_SEC_UNLOCK</span>:
	<span class="k">case</span> <span class="n">ATA_CMD_SEC_ERASE_PREP</span>:
	<span class="k">case</span> <span class="n">ATA_CMD_SEC_ERASE_UNIT</span>:
	<span class="k">case</span> <span class="n">ATA_CMD_SEC_FREEZE_LOCK</span>:
	<span class="k">case</span> <span class="n">ATA_CMD_SEC_DISABLE_PASS</span>:
	<span class="k">case</span> <span class="n">ATA_CMD_PMP_READ</span>:
	<span class="k">case</span> <span class="n">ATA_CMD_PMP_WRITE</span>:
		<span class="n">rv</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ATA_CMD_SET_MAX</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">features</span> <span class="o">==</span> <span class="n">ATA_SET_MAX_UNLOCK</span><span class="p">)</span>
			<span class="n">rv</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ATA_CMD_SMART</span>:
		<span class="k">if</span> <span class="p">((</span><span class="n">features</span> <span class="o">==</span> <span class="n">ATA_SMART_READ_VALUES</span><span class="p">)</span> <span class="o">||</span>
				<span class="p">(</span><span class="n">features</span> <span class="o">==</span> <span class="n">ATA_SMART_READ_THRESHOLDS</span><span class="p">))</span>
			<span class="n">rv</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ATA_CMD_CONF_OVERLAY</span>:
		<span class="k">if</span> <span class="p">((</span><span class="n">features</span> <span class="o">==</span> <span class="n">ATA_DCO_IDENTIFY</span><span class="p">)</span> <span class="o">||</span>
				<span class="p">(</span><span class="n">features</span> <span class="o">==</span> <span class="n">ATA_DCO_SET</span><span class="p">))</span>
			<span class="n">rv</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rv</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mtip_set_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">host_to_dev_fis</span> <span class="o">*</span><span class="n">fis</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">fis</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ATA_CMD_DOWNLOAD_MICRO</span>:
		<span class="o">*</span><span class="n">timeout</span> <span class="o">=</span> <span class="mi">120000</span><span class="p">;</span> <span class="cm">/* 2 minutes */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ATA_CMD_SEC_ERASE_UNIT</span>:
	<span class="k">case</span> <span class="mh">0xFC</span>:
		<span class="o">*</span><span class="n">timeout</span> <span class="o">=</span> <span class="mi">240000</span><span class="p">;</span> <span class="cm">/* 4 minutes */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ATA_CMD_STANDBYNOW1</span>:
		<span class="o">*</span><span class="n">timeout</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">;</span>  <span class="cm">/* 10 seconds */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0xF7</span>:
	<span class="k">case</span> <span class="mh">0xFA</span>:
		<span class="o">*</span><span class="n">timeout</span> <span class="o">=</span> <span class="mi">60000</span><span class="p">;</span>  <span class="cm">/* 60 seconds */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ATA_CMD_SMART</span>:
		<span class="o">*</span><span class="n">timeout</span> <span class="o">=</span> <span class="mi">15000</span><span class="p">;</span>  <span class="cm">/* 15 seconds */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="o">*</span><span class="n">timeout</span> <span class="o">=</span> <span class="n">MTIP_IOCTL_COMMAND_TIMEOUT_MS</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Executes a taskfile</span>
<span class="cm"> * See ide_taskfile_ioctl() for derivation</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">exec_drive_taskfile</span><span class="p">(</span><span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span>
			       <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			       <span class="n">ide_task_request_t</span> <span class="o">*</span><span class="n">req_task</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="n">outtotal</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">host_to_dev_fis</span>	<span class="n">fis</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">host_to_dev_fis</span> <span class="o">*</span><span class="n">reply</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">outbuf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">inbuf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">outbuf_dma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">inbuf_dma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">dma_buffer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">taskin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">taskout</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">nsect</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">force_single_sector</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">transfer_size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">task_file_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">intotal</span> <span class="o">=</span> <span class="n">outtotal</span> <span class="o">+</span> <span class="n">req_task</span><span class="o">-&gt;</span><span class="n">out_size</span><span class="p">;</span>

	<span class="n">taskout</span> <span class="o">=</span> <span class="n">req_task</span><span class="o">-&gt;</span><span class="n">out_size</span><span class="p">;</span>
	<span class="n">taskin</span> <span class="o">=</span> <span class="n">req_task</span><span class="o">-&gt;</span><span class="n">in_size</span><span class="p">;</span>
	<span class="cm">/* 130560 = 512 * 0xFF*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">taskin</span> <span class="o">&gt;</span> <span class="mi">130560</span> <span class="o">||</span> <span class="n">taskout</span> <span class="o">&gt;</span> <span class="mi">130560</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">abort</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">taskout</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">outbuf</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">taskout</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">outbuf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">abort</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">outbuf</span><span class="p">,</span> <span class="n">buf</span> <span class="o">+</span> <span class="n">outtotal</span><span class="p">,</span> <span class="n">taskout</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">abort</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">outbuf_dma</span> <span class="o">=</span> <span class="n">pci_map_single</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
					 <span class="n">outbuf</span><span class="p">,</span>
					 <span class="n">taskout</span><span class="p">,</span>
					 <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">outbuf_dma</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">abort</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">dma_buffer</span> <span class="o">=</span> <span class="n">outbuf_dma</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">taskin</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">inbuf</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">taskin</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inbuf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">abort</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">inbuf</span><span class="p">,</span> <span class="n">buf</span> <span class="o">+</span> <span class="n">intotal</span><span class="p">,</span> <span class="n">taskin</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">abort</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">inbuf_dma</span> <span class="o">=</span> <span class="n">pci_map_single</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
					 <span class="n">inbuf</span><span class="p">,</span>
					 <span class="n">taskin</span><span class="p">,</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inbuf_dma</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">abort</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">dma_buffer</span> <span class="o">=</span> <span class="n">inbuf_dma</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* only supports PIO and non-data commands from this ioctl. */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">req_task</span><span class="o">-&gt;</span><span class="n">data_phase</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">TASKFILE_OUT</span>:
		<span class="n">nsect</span> <span class="o">=</span> <span class="n">taskout</span> <span class="o">/</span> <span class="n">ATA_SECT_SIZE</span><span class="p">;</span>
		<span class="n">reply</span> <span class="o">=</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">rxfis</span> <span class="o">+</span> <span class="n">RX_FIS_PIO_SETUP</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TASKFILE_IN</span>:
		<span class="n">reply</span> <span class="o">=</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">rxfis</span> <span class="o">+</span> <span class="n">RX_FIS_PIO_SETUP</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TASKFILE_NO_DATA</span>:
		<span class="n">reply</span> <span class="o">=</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">rxfis</span> <span class="o">+</span> <span class="n">RX_FIS_D2H_REG</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">abort</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Build the FIS. */</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fis</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">host_to_dev_fis</span><span class="p">));</span>

	<span class="n">fis</span><span class="p">.</span><span class="n">type</span>	<span class="o">=</span> <span class="mh">0x27</span><span class="p">;</span>
	<span class="n">fis</span><span class="p">.</span><span class="n">opts</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">;</span>
	<span class="n">fis</span><span class="p">.</span><span class="n">command</span>	<span class="o">=</span> <span class="n">req_task</span><span class="o">-&gt;</span><span class="n">io_ports</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span>
	<span class="n">fis</span><span class="p">.</span><span class="n">features</span>	<span class="o">=</span> <span class="n">req_task</span><span class="o">-&gt;</span><span class="n">io_ports</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">fis</span><span class="p">.</span><span class="n">sect_count</span>	<span class="o">=</span> <span class="n">req_task</span><span class="o">-&gt;</span><span class="n">io_ports</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="n">fis</span><span class="p">.</span><span class="n">lba_low</span>	<span class="o">=</span> <span class="n">req_task</span><span class="o">-&gt;</span><span class="n">io_ports</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="n">fis</span><span class="p">.</span><span class="n">lba_mid</span>	<span class="o">=</span> <span class="n">req_task</span><span class="o">-&gt;</span><span class="n">io_ports</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="n">fis</span><span class="p">.</span><span class="n">lba_hi</span>	<span class="o">=</span> <span class="n">req_task</span><span class="o">-&gt;</span><span class="n">io_ports</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
	 <span class="cm">/* Clear the dev bit*/</span>
	<span class="n">fis</span><span class="p">.</span><span class="n">device</span>	<span class="o">=</span> <span class="n">req_task</span><span class="o">-&gt;</span><span class="n">io_ports</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x10</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">req_task</span><span class="o">-&gt;</span><span class="n">in_flags</span><span class="p">.</span><span class="n">all</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">req_task</span><span class="o">-&gt;</span><span class="n">out_flags</span><span class="p">.</span><span class="n">all</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">req_task</span><span class="o">-&gt;</span><span class="n">in_flags</span><span class="p">.</span><span class="n">all</span>	<span class="o">=</span>
			<span class="n">IDE_TASKFILE_STD_IN_FLAGS</span> <span class="o">|</span>
			<span class="p">(</span><span class="n">IDE_HOB_STD_IN_FLAGS</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>
		<span class="n">fis</span><span class="p">.</span><span class="n">lba_low_ex</span>		<span class="o">=</span> <span class="n">req_task</span><span class="o">-&gt;</span><span class="n">hob_ports</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
		<span class="n">fis</span><span class="p">.</span><span class="n">lba_mid_ex</span>		<span class="o">=</span> <span class="n">req_task</span><span class="o">-&gt;</span><span class="n">hob_ports</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
		<span class="n">fis</span><span class="p">.</span><span class="n">lba_hi_ex</span>		<span class="o">=</span> <span class="n">req_task</span><span class="o">-&gt;</span><span class="n">hob_ports</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
		<span class="n">fis</span><span class="p">.</span><span class="n">features_ex</span>		<span class="o">=</span> <span class="n">req_task</span><span class="o">-&gt;</span><span class="n">hob_ports</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
		<span class="n">fis</span><span class="p">.</span><span class="n">sect_cnt_ex</span>		<span class="o">=</span> <span class="n">req_task</span><span class="o">-&gt;</span><span class="n">hob_ports</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">req_task</span><span class="o">-&gt;</span><span class="n">in_flags</span><span class="p">.</span><span class="n">all</span> <span class="o">=</span> <span class="n">IDE_TASKFILE_STD_IN_FLAGS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">force_single_sector</span> <span class="o">=</span> <span class="n">implicit_sector</span><span class="p">(</span><span class="n">fis</span><span class="p">.</span><span class="n">command</span><span class="p">,</span> <span class="n">fis</span><span class="p">.</span><span class="n">features</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">taskin</span> <span class="o">||</span> <span class="n">taskout</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">fis</span><span class="p">.</span><span class="n">sect_count</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nsect</span><span class="p">)</span>
			<span class="n">fis</span><span class="p">.</span><span class="n">sect_count</span> <span class="o">=</span> <span class="n">nsect</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">force_single_sector</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="s">&quot;data movement but &quot;</span>
					<span class="s">&quot;sect_count is 0</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
					<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
					<span class="k">goto</span> <span class="n">abort</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">dbg_printk</span><span class="p">(</span><span class="n">MTIP_DRV_NAME</span>
		<span class="s">&quot; %s: cmd %x, feat %x, nsect %x,&quot;</span>
		<span class="s">&quot; sect/lbal %x, lcyl/lbam %x, hcyl/lbah %x,&quot;</span>
		<span class="s">&quot; head/dev %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span>
		<span class="n">fis</span><span class="p">.</span><span class="n">command</span><span class="p">,</span>
		<span class="n">fis</span><span class="p">.</span><span class="n">features</span><span class="p">,</span>
		<span class="n">fis</span><span class="p">.</span><span class="n">sect_count</span><span class="p">,</span>
		<span class="n">fis</span><span class="p">.</span><span class="n">lba_low</span><span class="p">,</span>
		<span class="n">fis</span><span class="p">.</span><span class="n">lba_mid</span><span class="p">,</span>
		<span class="n">fis</span><span class="p">.</span><span class="n">lba_hi</span><span class="p">,</span>
		<span class="n">fis</span><span class="p">.</span><span class="n">device</span><span class="p">);</span>

	<span class="n">mtip_set_timeout</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fis</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">timeout</span><span class="p">);</span>

	<span class="cm">/* Determine the correct transfer size.*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">force_single_sector</span><span class="p">)</span>
		<span class="n">transfer_size</span> <span class="o">=</span> <span class="n">ATA_SECT_SIZE</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">transfer_size</span> <span class="o">=</span> <span class="n">ATA_SECT_SIZE</span> <span class="o">*</span> <span class="n">fis</span><span class="p">.</span><span class="n">sect_count</span><span class="p">;</span>

	<span class="cm">/* Execute the command.*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mtip_exec_internal_command</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">,</span>
				 <span class="o">&amp;</span><span class="n">fis</span><span class="p">,</span>
				 <span class="mi">5</span><span class="p">,</span>
				 <span class="n">dma_buffer</span><span class="p">,</span>
				 <span class="n">transfer_size</span><span class="p">,</span>
				 <span class="mi">0</span><span class="p">,</span>
				 <span class="n">GFP_KERNEL</span><span class="p">,</span>
				 <span class="n">timeout</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">abort</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">task_file_data</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">mmio</span><span class="o">+</span><span class="n">PORT_TFDATA</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">req_task</span><span class="o">-&gt;</span><span class="n">data_phase</span> <span class="o">==</span> <span class="n">TASKFILE_IN</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">task_file_data</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">reply</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">rxfis</span> <span class="o">+</span> <span class="n">RX_FIS_PIO_SETUP</span><span class="p">;</span>
		<span class="n">req_task</span><span class="o">-&gt;</span><span class="n">io_ports</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="n">reply</span><span class="o">-&gt;</span><span class="n">control</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">reply</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">rxfis</span> <span class="o">+</span> <span class="n">RX_FIS_D2H_REG</span><span class="p">;</span>
		<span class="n">req_task</span><span class="o">-&gt;</span><span class="n">io_ports</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="n">reply</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* reclaim the DMA buffers.*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inbuf_dma</span><span class="p">)</span>
		<span class="n">pci_unmap_single</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">inbuf_dma</span><span class="p">,</span>
			<span class="n">taskin</span><span class="p">,</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">outbuf_dma</span><span class="p">)</span>
		<span class="n">pci_unmap_single</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">outbuf_dma</span><span class="p">,</span>
			<span class="n">taskout</span><span class="p">,</span> <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
	<span class="n">inbuf_dma</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">outbuf_dma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* return the ATA registers to the caller.*/</span>
	<span class="n">req_task</span><span class="o">-&gt;</span><span class="n">io_ports</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">reply</span><span class="o">-&gt;</span><span class="n">features</span><span class="p">;</span>
	<span class="n">req_task</span><span class="o">-&gt;</span><span class="n">io_ports</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">reply</span><span class="o">-&gt;</span><span class="n">sect_count</span><span class="p">;</span>
	<span class="n">req_task</span><span class="o">-&gt;</span><span class="n">io_ports</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">reply</span><span class="o">-&gt;</span><span class="n">lba_low</span><span class="p">;</span>
	<span class="n">req_task</span><span class="o">-&gt;</span><span class="n">io_ports</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">reply</span><span class="o">-&gt;</span><span class="n">lba_mid</span><span class="p">;</span>
	<span class="n">req_task</span><span class="o">-&gt;</span><span class="n">io_ports</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">reply</span><span class="o">-&gt;</span><span class="n">lba_hi</span><span class="p">;</span>
	<span class="n">req_task</span><span class="o">-&gt;</span><span class="n">io_ports</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">reply</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">req_task</span><span class="o">-&gt;</span><span class="n">out_flags</span><span class="p">.</span><span class="n">all</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>  <span class="p">{</span>

		<span class="n">req_task</span><span class="o">-&gt;</span><span class="n">hob_ports</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">reply</span><span class="o">-&gt;</span><span class="n">lba_low_ex</span><span class="p">;</span>
		<span class="n">req_task</span><span class="o">-&gt;</span><span class="n">hob_ports</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">reply</span><span class="o">-&gt;</span><span class="n">lba_mid_ex</span><span class="p">;</span>
		<span class="n">req_task</span><span class="o">-&gt;</span><span class="n">hob_ports</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">reply</span><span class="o">-&gt;</span><span class="n">lba_hi_ex</span><span class="p">;</span>
		<span class="n">req_task</span><span class="o">-&gt;</span><span class="n">hob_ports</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">reply</span><span class="o">-&gt;</span><span class="n">features_ex</span><span class="p">;</span>
		<span class="n">req_task</span><span class="o">-&gt;</span><span class="n">hob_ports</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">reply</span><span class="o">-&gt;</span><span class="n">sect_cnt_ex</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dbg_printk</span><span class="p">(</span><span class="n">MTIP_DRV_NAME</span>
		<span class="s">&quot; %s: Completion: stat %x,&quot;</span>
		<span class="s">&quot;err %x, sect_cnt %x, lbalo %x,&quot;</span>
		<span class="s">&quot;lbamid %x, lbahi %x, dev %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span>
		<span class="n">req_task</span><span class="o">-&gt;</span><span class="n">io_ports</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span>
		<span class="n">req_task</span><span class="o">-&gt;</span><span class="n">io_ports</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
		<span class="n">req_task</span><span class="o">-&gt;</span><span class="n">io_ports</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
		<span class="n">req_task</span><span class="o">-&gt;</span><span class="n">io_ports</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
		<span class="n">req_task</span><span class="o">-&gt;</span><span class="n">io_ports</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
		<span class="n">req_task</span><span class="o">-&gt;</span><span class="n">io_ports</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span>
		<span class="n">req_task</span><span class="o">-&gt;</span><span class="n">io_ports</span><span class="p">[</span><span class="mi">6</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">taskout</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">outtotal</span><span class="p">,</span> <span class="n">outbuf</span><span class="p">,</span> <span class="n">taskout</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">abort</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">taskin</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">intotal</span><span class="p">,</span> <span class="n">inbuf</span><span class="p">,</span> <span class="n">taskin</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">abort</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">abort:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inbuf_dma</span><span class="p">)</span>
		<span class="n">pci_unmap_single</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">inbuf_dma</span><span class="p">,</span>
					<span class="n">taskin</span><span class="p">,</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">outbuf_dma</span><span class="p">)</span>
		<span class="n">pci_unmap_single</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">outbuf_dma</span><span class="p">,</span>
					<span class="n">taskout</span><span class="p">,</span> <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">outbuf</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">inbuf</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Handle IOCTL calls from the Block Layer.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called by the Block Layer when it receives an IOCTL</span>
<span class="cm"> * command that it does not understand. If the IOCTL command is not supported</span>
<span class="cm"> * this function returns -ENOTTY.</span>
<span class="cm"> *</span>
<span class="cm"> * @dd  Pointer to the driver data structure.</span>
<span class="cm"> * @cmd IOCTL command passed from the Block Layer.</span>
<span class="cm"> * @arg IOCTL argument passed from the Block Layer.</span>
<span class="cm"> *</span>
<span class="cm"> * return value</span>
<span class="cm"> *	0	The IOCTL completed successfully.</span>
<span class="cm"> *	-ENOTTY The specified command is not supported.</span>
<span class="cm"> *	-EFAULT An error occurred copying data to a user space buffer.</span>
<span class="cm"> *	-EIO	An error occurred while executing the command.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mtip_hw_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span>
			 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">HDIO_GET_IDENTITY</span>:
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">((</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">identify</span><span class="p">,</span>
						<span class="k">sizeof</span><span class="p">(</span><span class="n">u16</span><span class="p">)</span> <span class="o">*</span> <span class="n">ATA_ID_WORDS</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">HDIO_DRIVE_CMD</span>:
	<span class="p">{</span>
		<span class="n">u8</span> <span class="n">drive_command</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>

		<span class="cm">/* Copy the user command info to our buffer. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">drive_command</span><span class="p">,</span>
					 <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">,</span>
					 <span class="k">sizeof</span><span class="p">(</span><span class="n">drive_command</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

		<span class="cm">/* Execute the drive command. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">exec_drive_command</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">,</span>
					 <span class="n">drive_command</span><span class="p">,</span>
					 <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">arg</span><span class="o">+</span><span class="mi">4</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

		<span class="cm">/* Copy the status back to the users buffer. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">((</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">,</span>
					 <span class="n">drive_command</span><span class="p">,</span>
					 <span class="k">sizeof</span><span class="p">(</span><span class="n">drive_command</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">HDIO_DRIVE_TASK</span>:
	<span class="p">{</span>
		<span class="n">u8</span> <span class="n">drive_command</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span>

		<span class="cm">/* Copy the user command info to our buffer. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">drive_command</span><span class="p">,</span>
					 <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">,</span>
					 <span class="k">sizeof</span><span class="p">(</span><span class="n">drive_command</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

		<span class="cm">/* Execute the drive command. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">exec_drive_task</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">,</span> <span class="n">drive_command</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

		<span class="cm">/* Copy the status back to the users buffer. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">((</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">,</span>
					 <span class="n">drive_command</span><span class="p">,</span>
					 <span class="k">sizeof</span><span class="p">(</span><span class="n">drive_command</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">HDIO_DRIVE_TASKFILE</span>: <span class="p">{</span>
		<span class="n">ide_task_request_t</span> <span class="n">req_task</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">outtotal</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req_task</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">,</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="n">req_task</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

		<span class="n">outtotal</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">req_task</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">exec_drive_taskfile</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">req_task</span><span class="p">,</span> <span class="n">outtotal</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">((</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req_task</span><span class="p">,</span>
							<span class="k">sizeof</span><span class="p">(</span><span class="n">req_task</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Submit an IO to the hw</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called by the block layer to issue an io</span>
<span class="cm"> * to the device. Upon completion, the callback function will</span>
<span class="cm"> * be called with the data parameter passed as the callback data.</span>
<span class="cm"> *</span>
<span class="cm"> * @dd       Pointer to the driver data structure.</span>
<span class="cm"> * @start    First sector to read.</span>
<span class="cm"> * @nsect    Number of sectors to read.</span>
<span class="cm"> * @nents    Number of entries in scatter list for the read command.</span>
<span class="cm"> * @tag      The tag of this read command.</span>
<span class="cm"> * @callback Pointer to the function that should be called</span>
<span class="cm"> *	     when the read completes.</span>
<span class="cm"> * @data     Callback data passed to the callback function</span>
<span class="cm"> *	     when the read completes.</span>
<span class="cm"> * @dir      Direction (read or write)</span>
<span class="cm"> *</span>
<span class="cm"> * return value</span>
<span class="cm"> *	None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mtip_hw_submit_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">start</span><span class="p">,</span>
			      <span class="kt">int</span> <span class="n">nsect</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nents</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tag</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">callback</span><span class="p">,</span>
			      <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">host_to_dev_fis</span>	<span class="o">*</span><span class="n">fis</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mtip_port</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mtip_cmd</span> <span class="o">*</span><span class="n">command</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">commands</span><span class="p">[</span><span class="n">tag</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">dma_dir</span> <span class="o">=</span> <span class="p">(</span><span class="n">dir</span> <span class="o">==</span> <span class="n">READ</span><span class="p">)</span> <span class="o">?</span> <span class="n">DMA_FROM_DEVICE</span> <span class="o">:</span> <span class="n">DMA_TO_DEVICE</span><span class="p">;</span>

	<span class="cm">/* Map the scatter list for DMA access */</span>
	<span class="n">nents</span> <span class="o">=</span> <span class="n">dma_map_sg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">command</span><span class="o">-&gt;</span><span class="n">sg</span><span class="p">,</span> <span class="n">nents</span><span class="p">,</span> <span class="n">dma_dir</span><span class="p">);</span>

	<span class="n">command</span><span class="o">-&gt;</span><span class="n">scatter_ents</span> <span class="o">=</span> <span class="n">nents</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The number of retries for this command before it is</span>
<span class="cm">	 * reported as a failure to the upper layers.</span>
<span class="cm">	 */</span>
	<span class="n">command</span><span class="o">-&gt;</span><span class="n">retries</span> <span class="o">=</span> <span class="n">MTIP_MAX_RETRIES</span><span class="p">;</span>

	<span class="cm">/* Fill out fis */</span>
	<span class="n">fis</span> <span class="o">=</span> <span class="n">command</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">;</span>
	<span class="n">fis</span><span class="o">-&gt;</span><span class="n">type</span>        <span class="o">=</span> <span class="mh">0x27</span><span class="p">;</span>
	<span class="n">fis</span><span class="o">-&gt;</span><span class="n">opts</span>        <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">;</span>
	<span class="n">fis</span><span class="o">-&gt;</span><span class="n">command</span>     <span class="o">=</span>
		<span class="p">(</span><span class="n">dir</span> <span class="o">==</span> <span class="n">READ</span> <span class="o">?</span> <span class="n">ATA_CMD_FPDMA_READ</span> <span class="o">:</span> <span class="n">ATA_CMD_FPDMA_WRITE</span><span class="p">);</span>
	<span class="o">*</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">fis</span><span class="o">-&gt;</span><span class="n">lba_low</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">start</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFF</span><span class="p">);</span>
	<span class="o">*</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">fis</span><span class="o">-&gt;</span><span class="n">lba_low_ex</span><span class="p">)</span> <span class="o">=</span> <span class="p">((</span><span class="n">start</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFF</span><span class="p">);</span>
	<span class="n">fis</span><span class="o">-&gt;</span><span class="n">device</span>	 <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">;</span>
	<span class="n">fis</span><span class="o">-&gt;</span><span class="n">features</span>    <span class="o">=</span> <span class="n">nsect</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>
	<span class="n">fis</span><span class="o">-&gt;</span><span class="n">features_ex</span> <span class="o">=</span> <span class="p">(</span><span class="n">nsect</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>
	<span class="n">fis</span><span class="o">-&gt;</span><span class="n">sect_count</span>  <span class="o">=</span> <span class="p">((</span><span class="n">tag</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">tag</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span><span class="p">));</span>
	<span class="n">fis</span><span class="o">-&gt;</span><span class="n">sect_cnt_ex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">fis</span><span class="o">-&gt;</span><span class="n">control</span>     <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">fis</span><span class="o">-&gt;</span><span class="n">res2</span>        <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">fis</span><span class="o">-&gt;</span><span class="n">res3</span>        <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">fill_command_sg</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">command</span><span class="p">,</span> <span class="n">nents</span><span class="p">);</span>

	<span class="cm">/* Populate the command header */</span>
	<span class="n">command</span><span class="o">-&gt;</span><span class="n">command_header</span><span class="o">-&gt;</span><span class="n">opts</span> <span class="o">=</span>
			<span class="n">__force_bit2int</span> <span class="n">cpu_to_le32</span><span class="p">(</span>
				<span class="p">(</span><span class="n">nents</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="mi">5</span> <span class="o">|</span> <span class="n">AHCI_CMD_PREFETCH</span><span class="p">);</span>
	<span class="n">command</span><span class="o">-&gt;</span><span class="n">command_header</span><span class="o">-&gt;</span><span class="n">byte_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set the completion function and data for the command</span>
<span class="cm">	 * within this layer.</span>
<span class="cm">	 */</span>
	<span class="n">command</span><span class="o">-&gt;</span><span class="n">comp_data</span> <span class="o">=</span> <span class="n">dd</span><span class="p">;</span>
	<span class="n">command</span><span class="o">-&gt;</span><span class="n">comp_func</span> <span class="o">=</span> <span class="n">mtip_async_complete</span><span class="p">;</span>
	<span class="n">command</span><span class="o">-&gt;</span><span class="n">direction</span> <span class="o">=</span> <span class="n">dma_dir</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set the completion function and data for the command passed</span>
<span class="cm">	 * from the upper layer.</span>
<span class="cm">	 */</span>
	<span class="n">command</span><span class="o">-&gt;</span><span class="n">async_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">command</span><span class="o">-&gt;</span><span class="n">async_callback</span> <span class="o">=</span> <span class="n">callback</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * To prevent this command from being issued</span>
<span class="cm">	 * if an internal command is in progress or error handling is active.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MTIP_PF_PAUSE_IO</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">cmds_to_issue</span><span class="p">);</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">MTIP_PF_ISSUE_CMDS_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Issue the command to the hardware */</span>
	<span class="n">mtip_issue_ncq_command</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">tag</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Release a command slot.</span>
<span class="cm"> *</span>
<span class="cm"> * @dd  Pointer to the driver data structure.</span>
<span class="cm"> * @tag Slot tag</span>
<span class="cm"> *</span>
<span class="cm"> * return value</span>
<span class="cm"> *      None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mtip_hw_release_scatterlist</span><span class="p">(</span><span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">release_slot</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">,</span> <span class="n">tag</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Obtain a command slot and return its associated scatter list.</span>
<span class="cm"> *</span>
<span class="cm"> * @dd  Pointer to the driver data structure.</span>
<span class="cm"> * @tag Pointer to an int that will receive the allocated command</span>
<span class="cm"> *            slot tag.</span>
<span class="cm"> *</span>
<span class="cm"> * return value</span>
<span class="cm"> *	Pointer to the scatter list for the allocated command slot</span>
<span class="cm"> *	or NULL if no command slots are available.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="nf">mtip_hw_get_scatterlist</span><span class="p">(</span><span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span>
						   <span class="kt">int</span> <span class="o">*</span><span class="n">tag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * It is possible that, even with this semaphore, a thread</span>
<span class="cm">	 * may think that no command slots are available. Therefore, we</span>
<span class="cm">	 * need to make an attempt to get_slot().</span>
<span class="cm">	 */</span>
	<span class="n">down</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">cmd_slot</span><span class="p">);</span>
	<span class="o">*</span><span class="n">tag</span> <span class="o">=</span> <span class="n">get_slot</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">MTIP_DDF_REMOVE_PENDING_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">dd_flag</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">cmd_slot</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">*</span><span class="n">tag</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">cmd_slot</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">commands</span><span class="p">[</span><span class="o">*</span><span class="n">tag</span><span class="p">].</span><span class="n">sg</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Sysfs status dump.</span>
<span class="cm"> *</span>
<span class="cm"> * @dev  Pointer to the device structure, passed by the kernrel.</span>
<span class="cm"> * @attr Pointer to the device_attribute structure passed by the kernel.</span>
<span class="cm"> * @buf  Pointer to the char buffer that will receive the stats info.</span>
<span class="cm"> *</span>
<span class="cm"> * return value</span>
<span class="cm"> *	The size, in bytes, of the data copied into buf.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">mtip_hw_show_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">dd</span> <span class="o">=</span> <span class="n">dev_to_disk</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">MTIP_DDF_OVER_TEMP_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">dd_flag</span><span class="p">))</span>
		<span class="n">size</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="s">&quot;thermal_shutdown</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">MTIP_DDF_WRITE_PROTECT_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">dd_flag</span><span class="p">))</span>
		<span class="n">size</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="s">&quot;write_protect</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">size</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="s">&quot;online</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">mtip_hw_show_status</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">mtip_hw_read_registers</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ubuf</span><span class="p">,</span>
				  <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">dd</span> <span class="o">=</span>  <span class="p">(</span><span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="p">)</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">MTIP_DFS_MAX_BUF_SIZE</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">group_allocated</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="o">*</span><span class="n">offset</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">len</span> <span class="o">||</span> <span class="n">size</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="n">size</span><span class="p">],</span> <span class="s">&quot;H/ S ACTive      : [ 0x&quot;</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">slot_groups</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span><span class="o">--</span><span class="p">)</span>
		<span class="n">size</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="n">size</span><span class="p">],</span> <span class="s">&quot;%08X &quot;</span><span class="p">,</span>
					 <span class="n">readl</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">s_active</span><span class="p">[</span><span class="n">n</span><span class="p">]));</span>

	<span class="n">size</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="n">size</span><span class="p">],</span> <span class="s">&quot;]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">size</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="n">size</span><span class="p">],</span> <span class="s">&quot;H/ Command Issue : [ 0x&quot;</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">slot_groups</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span><span class="o">--</span><span class="p">)</span>
		<span class="n">size</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="n">size</span><span class="p">],</span> <span class="s">&quot;%08X &quot;</span><span class="p">,</span>
					<span class="n">readl</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">cmd_issue</span><span class="p">[</span><span class="n">n</span><span class="p">]));</span>

	<span class="n">size</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="n">size</span><span class="p">],</span> <span class="s">&quot;]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">size</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="n">size</span><span class="p">],</span> <span class="s">&quot;H/ Completed     : [ 0x&quot;</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">slot_groups</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span><span class="o">--</span><span class="p">)</span>
		<span class="n">size</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="n">size</span><span class="p">],</span> <span class="s">&quot;%08X &quot;</span><span class="p">,</span>
				<span class="n">readl</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">completed</span><span class="p">[</span><span class="n">n</span><span class="p">]));</span>

	<span class="n">size</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="n">size</span><span class="p">],</span> <span class="s">&quot;]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">size</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="n">size</span><span class="p">],</span> <span class="s">&quot;H/ PORT IRQ STAT : [ 0x%08X ]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">readl</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">PORT_IRQ_STAT</span><span class="p">));</span>
	<span class="n">size</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="n">size</span><span class="p">],</span> <span class="s">&quot;H/ HOST IRQ STAT : [ 0x%08X ]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">readl</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">HOST_IRQ_STAT</span><span class="p">));</span>
	<span class="n">size</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="n">size</span><span class="p">],</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">size</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="n">size</span><span class="p">],</span> <span class="s">&quot;L/ Allocated     : [ 0x&quot;</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">slot_groups</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">))</span>
			<span class="n">group_allocated</span> <span class="o">=</span>
				<span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">allocated</span><span class="p">[</span><span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">32</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">));</span>
		<span class="k">else</span>
			<span class="n">group_allocated</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">allocated</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
		<span class="n">size</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="n">size</span><span class="p">],</span> <span class="s">&quot;%08X &quot;</span><span class="p">,</span> <span class="n">group_allocated</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">size</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="n">size</span><span class="p">],</span> <span class="s">&quot;]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">size</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="n">size</span><span class="p">],</span> <span class="s">&quot;L/ Commands in Q : [ 0x&quot;</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">slot_groups</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">))</span>
			<span class="n">group_allocated</span> <span class="o">=</span>
				<span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">cmds_to_issue</span><span class="p">[</span><span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">32</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">));</span>
		<span class="k">else</span>
			<span class="n">group_allocated</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">cmds_to_issue</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
		<span class="n">size</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="n">size</span><span class="p">],</span> <span class="s">&quot;%08X &quot;</span><span class="p">,</span> <span class="n">group_allocated</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">size</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="n">size</span><span class="p">],</span> <span class="s">&quot;]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="o">*</span><span class="n">offset</span> <span class="o">=</span> <span class="n">size</span> <span class="o">&lt;=</span> <span class="n">len</span> <span class="o">?</span> <span class="n">size</span> <span class="o">:</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">ubuf</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="o">*</span><span class="n">offset</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">return</span> <span class="o">*</span><span class="n">offset</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">mtip_hw_read_flags</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ubuf</span><span class="p">,</span>
				  <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">dd</span> <span class="o">=</span>  <span class="p">(</span><span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="p">)</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">MTIP_DFS_MAX_BUF_SIZE</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="o">*</span><span class="n">offset</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">len</span> <span class="o">||</span> <span class="n">size</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="n">size</span><span class="p">],</span> <span class="s">&quot;Flag-port : [ %08lX ]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
							<span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">size</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="n">size</span><span class="p">],</span> <span class="s">&quot;Flag-dd   : [ %08lX ]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
							<span class="n">dd</span><span class="o">-&gt;</span><span class="n">dd_flag</span><span class="p">);</span>

	<span class="o">*</span><span class="n">offset</span> <span class="o">=</span> <span class="n">size</span> <span class="o">&lt;=</span> <span class="n">len</span> <span class="o">?</span> <span class="n">size</span> <span class="o">:</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">ubuf</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="o">*</span><span class="n">offset</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">return</span> <span class="o">*</span><span class="n">offset</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">mtip_regs_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>  <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span>   <span class="o">=</span> <span class="n">simple_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>   <span class="o">=</span> <span class="n">mtip_hw_read_registers</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span> <span class="n">no_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">mtip_flags_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>  <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span>   <span class="o">=</span> <span class="n">simple_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>   <span class="o">=</span> <span class="n">mtip_hw_read_flags</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span> <span class="n">no_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Create the sysfs related attributes.</span>
<span class="cm"> *</span>
<span class="cm"> * @dd   Pointer to the driver data structure.</span>
<span class="cm"> * @kobj Pointer to the kobj for the block device.</span>
<span class="cm"> *</span>
<span class="cm"> * return value</span>
<span class="cm"> *	0	Operation completed successfully.</span>
<span class="cm"> *	-EINVAL Invalid parameter.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mtip_hw_sysfs_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kobj</span> <span class="o">||</span> <span class="o">!</span><span class="n">dd</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sysfs_create_file</span><span class="p">(</span><span class="n">kobj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_attr_status</span><span class="p">.</span><span class="n">attr</span><span class="p">))</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;Error creating &#39;status&#39; sysfs entry</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Remove the sysfs related attributes.</span>
<span class="cm"> *</span>
<span class="cm"> * @dd   Pointer to the driver data structure.</span>
<span class="cm"> * @kobj Pointer to the kobj for the block device.</span>
<span class="cm"> *</span>
<span class="cm"> * return value</span>
<span class="cm"> *	0	Operation completed successfully.</span>
<span class="cm"> *	-EINVAL Invalid parameter.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mtip_hw_sysfs_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kobj</span> <span class="o">||</span> <span class="o">!</span><span class="n">dd</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">sysfs_remove_file</span><span class="p">(</span><span class="n">kobj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_attr_status</span><span class="p">.</span><span class="n">attr</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mtip_hw_debugfs_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">dd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dfs_parent</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">dfs_node</span> <span class="o">=</span> <span class="n">debugfs_create_dir</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">disk_name</span><span class="p">,</span> <span class="n">dfs_parent</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR_OR_NULL</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">dfs_node</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;Error creating node %s under debugfs</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">dd</span><span class="o">-&gt;</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">disk_name</span><span class="p">);</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">dfs_node</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">debugfs_create_file</span><span class="p">(</span><span class="s">&quot;flags&quot;</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">dfs_node</span><span class="p">,</span> <span class="n">dd</span><span class="p">,</span>
							<span class="o">&amp;</span><span class="n">mtip_flags_fops</span><span class="p">);</span>
	<span class="n">debugfs_create_file</span><span class="p">(</span><span class="s">&quot;registers&quot;</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">dfs_node</span><span class="p">,</span> <span class="n">dd</span><span class="p">,</span>
							<span class="o">&amp;</span><span class="n">mtip_regs_fops</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mtip_hw_debugfs_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">dd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">debugfs_remove_recursive</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">dfs_node</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Perform any init/resume time hardware setup</span>
<span class="cm"> *</span>
<span class="cm"> * @dd Pointer to the driver data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * return value</span>
<span class="cm"> *	None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hba_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">dd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">hwdata</span><span class="p">;</span>
	<span class="n">hwdata</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">HOST_HSORG</span><span class="p">);</span>

	<span class="cm">/* interrupt bug workaround: use only 1 IS bit.*/</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">hwdata</span> <span class="o">|</span>
		<span class="n">HSORG_DISABLE_SLOTGRP_INTR</span> <span class="o">|</span>
		<span class="n">HSORG_DISABLE_SLOTGRP_PXIS</span><span class="p">,</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">HOST_HSORG</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Detect the details of the product, and store anything needed</span>
<span class="cm"> * into the driver data structure.  This includes product type and</span>
<span class="cm"> * version and number of slot groups.</span>
<span class="cm"> *</span>
<span class="cm"> * @dd Pointer to the driver data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * return value</span>
<span class="cm"> *	None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mtip_detect_product</span><span class="p">(</span><span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">dd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">hwdata</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rev</span><span class="p">,</span> <span class="n">slotgroups</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * HBA base + 0xFC [15:0] - vendor-specific hardware interface</span>
<span class="cm">	 * info register:</span>
<span class="cm">	 * [15:8] hardware/software interface rev#</span>
<span class="cm">	 * [   3] asic-style interface</span>
<span class="cm">	 * [ 2:0] number of slot groups, minus 1 (only valid for asic-style).</span>
<span class="cm">	 */</span>
	<span class="n">hwdata</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">HOST_HSORG</span><span class="p">);</span>

	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">product_type</span> <span class="o">=</span> <span class="n">MTIP_PRODUCT_UNKNOWN</span><span class="p">;</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">slot_groups</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hwdata</span> <span class="o">&amp;</span> <span class="mh">0x8</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">product_type</span> <span class="o">=</span> <span class="n">MTIP_PRODUCT_ASICFPGA</span><span class="p">;</span>
		<span class="n">rev</span> <span class="o">=</span> <span class="p">(</span><span class="n">hwdata</span> <span class="o">&amp;</span> <span class="n">HSORG_HWREV</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">slotgroups</span> <span class="o">=</span> <span class="p">(</span><span class="n">hwdata</span> <span class="o">&amp;</span> <span class="n">HSORG_SLOTGROUPS</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;ASIC-FPGA design, HS rev 0x%x, &quot;</span>
			<span class="s">&quot;%i slot groups [%i slots]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">rev</span><span class="p">,</span>
			 <span class="n">slotgroups</span><span class="p">,</span>
			 <span class="n">slotgroups</span> <span class="o">*</span> <span class="mi">32</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">slotgroups</span> <span class="o">&gt;</span> <span class="n">MTIP_MAX_SLOT_GROUPS</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;Warning: driver only supports &quot;</span>
				<span class="s">&quot;%i slot groups.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">MTIP_MAX_SLOT_GROUPS</span><span class="p">);</span>
			<span class="n">slotgroups</span> <span class="o">=</span> <span class="n">MTIP_MAX_SLOT_GROUPS</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">slot_groups</span> <span class="o">=</span> <span class="n">slotgroups</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Unrecognized product id</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Blocking wait for FTL rebuild to complete</span>
<span class="cm"> *</span>
<span class="cm"> * @dd Pointer to the DRIVER_DATA structure.</span>
<span class="cm"> *</span>
<span class="cm"> * return value</span>
<span class="cm"> *	0	FTL rebuild completed successfully</span>
<span class="cm"> *	-EFAULT FTL rebuild error/timeout/interruption</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mtip_ftl_rebuild_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">dd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">,</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">start</span><span class="p">;</span>

	<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;FTL rebuild in progress. Polling for completion.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">start</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">timeout</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">MTIP_FTL_REBUILD_TIMEOUT_MS</span><span class="p">);</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">MTIP_DDF_REMOVE_PENDING_BIT</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">dd_flag</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mtip_check_surprise_removal</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">mtip_get_identify</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">identify</span> <span class="o">+</span> <span class="n">MTIP_FTL_REBUILD_OFFSET</span><span class="p">)</span> <span class="o">==</span>
			<span class="n">MTIP_FTL_REBUILD_MAGIC</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ssleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
			<span class="cm">/* Print message every 3 minutes */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cnt</span><span class="o">++</span> <span class="o">&gt;=</span> <span class="mi">180</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;FTL rebuild in progress (%d secs).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">jiffies_to_msecs</span><span class="p">(</span><span class="n">jiffies</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">);</span>
				<span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;FTL rebuild complete (%d secs).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">jiffies_to_msecs</span><span class="p">(</span><span class="n">jiffies</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">);</span>
			<span class="n">mtip_block_initialize</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ssleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">timeout</span><span class="p">));</span>

	<span class="cm">/* Check for timeout */</span>
	<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;Timed out waiting for FTL rebuild to complete (%d secs).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">jiffies_to_msecs</span><span class="p">(</span><span class="n">jiffies</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * service thread to issue queued commands</span>
<span class="cm"> *</span>
<span class="cm"> * @data Pointer to the driver data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * return value</span>
<span class="cm"> *	0</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mtip_service_thread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">dd</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">slot</span><span class="p">,</span> <span class="n">slot_start</span><span class="p">,</span> <span class="n">slot_wrap</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_cmd_slots</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">slot_groups</span> <span class="o">*</span> <span class="mi">32</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mtip_port</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * the condition is to check neither an internal command is</span>
<span class="cm">		 * is in progress nor error handling is active</span>
<span class="cm">		 */</span>
		<span class="n">wait_event_interruptible</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">svc_wait</span><span class="p">,</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="o">!</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MTIP_PF_PAUSE_IO</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">kthread_should_stop</span><span class="p">())</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">MTIP_DDF_REMOVE_PENDING_BIT</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">dd_flag</span><span class="p">)))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">set_bit</span><span class="p">(</span><span class="n">MTIP_PF_SVC_THD_ACTIVE_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">MTIP_PF_ISSUE_CMDS_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">slot</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="cm">/* used to restrict the loop to one iteration */</span>
			<span class="n">slot_start</span> <span class="o">=</span> <span class="n">num_cmd_slots</span><span class="p">;</span>
			<span class="n">slot_wrap</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">slot</span> <span class="o">=</span> <span class="n">find_next_bit</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">cmds_to_issue</span><span class="p">,</span>
						<span class="n">num_cmd_slots</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">slot_wrap</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">((</span><span class="n">slot_start</span> <span class="o">&gt;=</span> <span class="n">slot</span><span class="p">)</span> <span class="o">||</span>
						<span class="p">(</span><span class="n">slot</span> <span class="o">&gt;=</span> <span class="n">num_cmd_slots</span><span class="p">))</span>
						<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">slot_start</span> <span class="o">==</span> <span class="n">num_cmd_slots</span><span class="p">))</span>
					<span class="n">slot_start</span> <span class="o">=</span> <span class="n">slot</span><span class="p">;</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">slot</span> <span class="o">==</span> <span class="n">num_cmd_slots</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">slot</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
					<span class="n">slot_wrap</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
					<span class="k">continue</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="cm">/* Issue the command to the hardware */</span>
				<span class="n">mtip_issue_ncq_command</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>

				<span class="n">clear_bit</span><span class="p">(</span><span class="n">slot</span><span class="p">,</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">cmds_to_issue</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="n">clear_bit</span><span class="p">(</span><span class="n">MTIP_PF_ISSUE_CMDS_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">MTIP_PF_REBUILD_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mtip_ftl_rebuild_poll</span><span class="p">(</span><span class="n">dd</span><span class="p">))</span>
				<span class="n">set_bit</span><span class="p">(</span><span class="n">MTIP_DDF_REBUILD_FAILED_BIT</span><span class="p">,</span>
							<span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">dd_flag</span><span class="p">);</span>
			<span class="n">clear_bit</span><span class="p">(</span><span class="n">MTIP_PF_REBUILD_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">MTIP_PF_SVC_THD_ACTIVE_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">MTIP_PF_SVC_THD_STOP_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called once for each card.</span>
<span class="cm"> *</span>
<span class="cm"> * @dd Pointer to the driver data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * return value</span>
<span class="cm"> *	0 on success, else an error code.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mtip_hw_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">dd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rv</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_command_slots</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">,</span> <span class="n">timetaken</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">smart_attr</span> <span class="n">attr242</span><span class="p">;</span>

	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">mmio</span> <span class="o">=</span> <span class="n">pcim_iomap_table</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">)[</span><span class="n">MTIP_ABAR</span><span class="p">];</span>

	<span class="n">mtip_detect_product</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">product_type</span> <span class="o">==</span> <span class="n">MTIP_PRODUCT_UNKNOWN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rv</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">num_command_slots</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">slot_groups</span> <span class="o">*</span> <span class="mi">32</span><span class="p">;</span>

	<span class="n">hba_setup</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>

	<span class="n">tasklet_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">tasklet</span><span class="p">,</span> <span class="n">mtip_tasklet</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">dd</span><span class="p">);</span>

	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtip_port</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;Memory allocation: port structure</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Counting semaphore to track command slot usage */</span>
	<span class="n">sema_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">cmd_slot</span><span class="p">,</span> <span class="n">num_command_slots</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* Spinlock to prevent concurrent issue */</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">cmd_issue_lock</span><span class="p">);</span>

	<span class="cm">/* Set the port mmio base address. */</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">mmio</span>	<span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">PORT_OFFSET</span><span class="p">;</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">dd</span>	<span class="o">=</span> <span class="n">dd</span><span class="p">;</span>

	<span class="cm">/* Allocate memory for the command list. */</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">command_list</span> <span class="o">=</span>
		<span class="n">dmam_alloc_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="n">HW_PORT_PRIV_DMA_SZ</span> <span class="o">+</span> <span class="p">(</span><span class="n">ATA_SECT_SIZE</span> <span class="o">*</span> <span class="mi">4</span><span class="p">),</span>
			<span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">command_list_dma</span><span class="p">,</span>
			<span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">command_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;Memory allocation: command list</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">rv</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Clear the memory we have allocated. */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">command_list</span><span class="p">,</span>
		<span class="mi">0</span><span class="p">,</span>
		<span class="n">HW_PORT_PRIV_DMA_SZ</span> <span class="o">+</span> <span class="p">(</span><span class="n">ATA_SECT_SIZE</span> <span class="o">*</span> <span class="mi">4</span><span class="p">));</span>

	<span class="cm">/* Setup the addresse of the RX FIS. */</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">rxfis</span>	    <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">command_list</span> <span class="o">+</span> <span class="n">HW_CMD_SLOT_SZ</span><span class="p">;</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">rxfis_dma</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">command_list_dma</span> <span class="o">+</span> <span class="n">HW_CMD_SLOT_SZ</span><span class="p">;</span>

	<span class="cm">/* Setup the address of the command tables. */</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">command_table</span>	  <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">rxfis</span> <span class="o">+</span> <span class="n">AHCI_RX_FIS_SZ</span><span class="p">;</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">command_tbl_dma</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">rxfis_dma</span> <span class="o">+</span> <span class="n">AHCI_RX_FIS_SZ</span><span class="p">;</span>

	<span class="cm">/* Setup the address of the identify data. */</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">identify</span>     <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">command_table</span> <span class="o">+</span>
					<span class="n">HW_CMD_TBL_AR_SZ</span><span class="p">;</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">identify_dma</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">command_tbl_dma</span> <span class="o">+</span>
					<span class="n">HW_CMD_TBL_AR_SZ</span><span class="p">;</span>

	<span class="cm">/* Setup the address of the sector buffer - for some non-ncq cmds */</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">sector_buffer</span>	<span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">identify</span> <span class="o">+</span> <span class="n">ATA_SECT_SIZE</span><span class="p">;</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">sector_buffer_dma</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">identify_dma</span> <span class="o">+</span> <span class="n">ATA_SECT_SIZE</span><span class="p">;</span>

	<span class="cm">/* Setup the address of the log buf - for read log command */</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">log_buf</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">sector_buffer</span>  <span class="o">+</span> <span class="n">ATA_SECT_SIZE</span><span class="p">;</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">log_buf_dma</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">sector_buffer_dma</span> <span class="o">+</span> <span class="n">ATA_SECT_SIZE</span><span class="p">;</span>

	<span class="cm">/* Setup the address of the smart buf - for smart read data command */</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">smart_buf</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">log_buf</span>  <span class="o">+</span> <span class="n">ATA_SECT_SIZE</span><span class="p">;</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">smart_buf_dma</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">log_buf_dma</span> <span class="o">+</span> <span class="n">ATA_SECT_SIZE</span><span class="p">;</span>


	<span class="cm">/* Point the command headers at the command tables. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_command_slots</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">commands</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">command_header</span> <span class="o">=</span>
					<span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">command_list</span> <span class="o">+</span>
					<span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtip_cmd_hdr</span><span class="p">)</span> <span class="o">*</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">commands</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">command_header_dma</span> <span class="o">=</span>
					<span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">command_list_dma</span> <span class="o">+</span>
					<span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtip_cmd_hdr</span><span class="p">)</span> <span class="o">*</span> <span class="n">i</span><span class="p">);</span>

		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">commands</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">command</span> <span class="o">=</span>
			<span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">command_table</span> <span class="o">+</span> <span class="p">(</span><span class="n">HW_CMD_TBL_SZ</span> <span class="o">*</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">commands</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">command_dma</span> <span class="o">=</span>
			<span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">command_tbl_dma</span> <span class="o">+</span> <span class="p">(</span><span class="n">HW_CMD_TBL_SZ</span> <span class="o">*</span> <span class="n">i</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">HOST_CAP</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">HOST_CAP_64</span><span class="p">)</span>
			<span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">commands</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">command_header</span><span class="o">-&gt;</span><span class="n">ctbau</span> <span class="o">=</span>
			<span class="n">__force_bit2int</span> <span class="n">cpu_to_le32</span><span class="p">(</span>
			<span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">commands</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">command_dma</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">);</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">commands</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">command_header</span><span class="o">-&gt;</span><span class="n">ctba</span> <span class="o">=</span>
			<span class="n">__force_bit2int</span> <span class="n">cpu_to_le32</span><span class="p">(</span>
			<span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">commands</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">command_dma</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFFFF</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * If this is not done, a bug is reported by the stock</span>
<span class="cm">		 * FC11 i386. Due to the fact that it has lots of kernel</span>
<span class="cm">		 * debugging enabled.</span>
<span class="cm">		 */</span>
		<span class="n">sg_init_table</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">commands</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sg</span><span class="p">,</span> <span class="n">MTIP_MAX_SG</span><span class="p">);</span>

		<span class="cm">/* Mark all commands as currently inactive.*/</span>
		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">commands</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">active</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Setup the pointers to the extended s_active and CI registers. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">slot_groups</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">s_active</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>
			<span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="mh">0x80</span> <span class="o">+</span> <span class="n">PORT_SCR_ACT</span><span class="p">;</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">cmd_issue</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>
			<span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="mh">0x80</span> <span class="o">+</span> <span class="n">PORT_COMMAND_ISSUE</span><span class="p">;</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">completed</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>
			<span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="mh">0x80</span> <span class="o">+</span> <span class="n">PORT_SDBV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">timetaken</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">timeout</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="mi">30000</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(((</span><span class="n">readl</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">PORT_SCR_STAT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0F</span><span class="p">)</span> <span class="o">!=</span> <span class="mh">0x03</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		 <span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">timeout</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mdelay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">mtip_check_surprise_removal</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">timetaken</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">-</span> <span class="n">timetaken</span><span class="p">;</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;Surprise removal detected at %u ms</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">jiffies_to_msecs</span><span class="p">(</span><span class="n">timetaken</span><span class="p">));</span>
		<span class="n">rv</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out2</span> <span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">MTIP_DDF_REMOVE_PENDING_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">dd_flag</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">timetaken</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">-</span> <span class="n">timetaken</span><span class="p">;</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;Removal detected at %u ms</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">jiffies_to_msecs</span><span class="p">(</span><span class="n">timetaken</span><span class="p">));</span>
		<span class="n">rv</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Conditionally reset the HBA. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">HOST_CAP</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">HOST_CAP_NZDMA</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mtip_hba_reset</span><span class="p">(</span><span class="n">dd</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;Card did not reset within timeout</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">rv</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out2</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Clear any pending interrupts on the HBA */</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">HOST_IRQ_STAT</span><span class="p">),</span>
			<span class="n">dd</span><span class="o">-&gt;</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">HOST_IRQ_STAT</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">mtip_init_port</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">);</span>
	<span class="n">mtip_start_port</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">);</span>

	<span class="cm">/* Setup the ISR and enable interrupts. */</span>
	<span class="n">rv</span> <span class="o">=</span> <span class="n">devm_request_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span>
				<span class="n">mtip_irq_handler</span><span class="p">,</span>
				<span class="n">IRQF_SHARED</span><span class="p">,</span>
				<span class="n">dev_driver_string</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">),</span>
				<span class="n">dd</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rv</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;Unable to allocate IRQ %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Enable interrupts on the HBA. */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">HOST_CTL</span><span class="p">)</span> <span class="o">|</span> <span class="n">HOST_IRQ_EN</span><span class="p">,</span>
					<span class="n">dd</span><span class="o">-&gt;</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">HOST_CTL</span><span class="p">);</span>

	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">cmd_timer</span><span class="p">);</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">svc_wait</span><span class="p">);</span>

	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">cmd_timer</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">int</span><span class="p">)</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">;</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">cmd_timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">mtip_timeout_function</span><span class="p">;</span>
	<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">cmd_timer</span><span class="p">,</span>
		<span class="n">jiffies</span> <span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">MTIP_TIMEOUT_CHECK_PERIOD</span><span class="p">));</span>


	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">MTIP_DDF_REMOVE_PENDING_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">dd_flag</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rv</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out3</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mtip_get_identify</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rv</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out3</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">identify</span> <span class="o">+</span> <span class="n">MTIP_FTL_REBUILD_OFFSET</span><span class="p">)</span> <span class="o">==</span>
		<span class="n">MTIP_FTL_REBUILD_MAGIC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">MTIP_PF_REBUILD_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">MTIP_FTL_REBUILD_MAGIC</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mtip_dump_identify</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">);</span>

	<span class="cm">/* check write protect, over temp and rebuild statuses */</span>
	<span class="n">rv</span> <span class="o">=</span> <span class="n">mtip_read_log_page</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">,</span> <span class="n">ATA_LOG_SATA_NCQ</span><span class="p">,</span>
				<span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">log_buf</span><span class="p">,</span>
				<span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">log_buf_dma</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rv</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;Error in READ LOG EXT (10h) command</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="cm">/* non-critical error, don&#39;t fail the load */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">buf</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">log_buf</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">259</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;Write protect bit is set.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">MTIP_DDF_WRITE_PROTECT_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">dd_flag</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">288</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0xF7</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;Exceeded Tmax, drive in thermal shutdown.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">MTIP_DDF_OVER_TEMP_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">dd_flag</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">288</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0xBF</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;Drive indicates rebuild has failed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="cm">/* TODO */</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* get write protect progess */</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr242</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">smart_attr</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mtip_get_smart_attr</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">,</span> <span class="mi">242</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attr242</span><span class="p">))</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;Unable to check write protect progress</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;Write protect progress: %d%% (%d blocks)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">attr242</span><span class="p">.</span><span class="n">cur</span><span class="p">,</span> <span class="n">attr242</span><span class="p">.</span><span class="n">data</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rv</span><span class="p">;</span>

<span class="nl">out3:</span>
	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">cmd_timer</span><span class="p">);</span>

	<span class="cm">/* Disable interrupts on the HBA. */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">HOST_CTL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">HOST_IRQ_EN</span><span class="p">,</span>
			<span class="n">dd</span><span class="o">-&gt;</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">HOST_CTL</span><span class="p">);</span>

	<span class="cm">/*Release the IRQ. */</span>
	<span class="n">devm_free_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">dd</span><span class="p">);</span>

<span class="nl">out2:</span>
	<span class="n">mtip_deinit_port</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">);</span>

	<span class="cm">/* Free the command/command header memory. */</span>
	<span class="n">dmam_free_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="n">HW_PORT_PRIV_DMA_SZ</span> <span class="o">+</span> <span class="p">(</span><span class="n">ATA_SECT_SIZE</span> <span class="o">*</span> <span class="mi">4</span><span class="p">),</span>
				<span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">command_list</span><span class="p">,</span>
				<span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">command_list_dma</span><span class="p">);</span>
<span class="nl">out1:</span>
	<span class="cm">/* Free the memory allocated for the for structure. */</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rv</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called to deinitialize an interface.</span>
<span class="cm"> *</span>
<span class="cm"> * @dd Pointer to the driver data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * return value</span>
<span class="cm"> *	0</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mtip_hw_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">dd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Send standby immediate (E0h) to the drive so that it</span>
<span class="cm">	 * saves its state.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">MTIP_DDF_CLEANUP_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">dd_flag</span><span class="p">))</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">MTIP_PF_REBUILD_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mtip_standby_immediate</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">))</span>
				<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="s">&quot;STANDBY IMMEDIATE failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="cm">/* de-initialize the port. */</span>
		<span class="n">mtip_deinit_port</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">);</span>

		<span class="cm">/* Disable interrupts on the HBA. */</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">HOST_CTL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">HOST_IRQ_EN</span><span class="p">,</span>
				<span class="n">dd</span><span class="o">-&gt;</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">HOST_CTL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">cmd_timer</span><span class="p">);</span>

	<span class="cm">/* Release the IRQ. */</span>
	<span class="n">devm_free_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">dd</span><span class="p">);</span>

	<span class="cm">/* Stop the bottom half tasklet. */</span>
	<span class="n">tasklet_kill</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">tasklet</span><span class="p">);</span>

	<span class="cm">/* Free the command/command header memory. */</span>
	<span class="n">dmam_free_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="n">HW_PORT_PRIV_DMA_SZ</span> <span class="o">+</span> <span class="p">(</span><span class="n">ATA_SECT_SIZE</span> <span class="o">*</span> <span class="mi">4</span><span class="p">),</span>
			<span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">command_list</span><span class="p">,</span>
			<span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">command_list_dma</span><span class="p">);</span>
	<span class="cm">/* Free the memory allocated for the for structure. */</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Issue a Standby Immediate command to the device.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called by the Block Layer just before the</span>
<span class="cm"> * system powers off during a shutdown.</span>
<span class="cm"> *</span>
<span class="cm"> * @dd Pointer to the driver data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * return value</span>
<span class="cm"> *	0</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mtip_hw_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">dd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Send standby immediate (E0h) to the drive so that it</span>
<span class="cm">	 * saves its state.</span>
<span class="cm">	 */</span>
	<span class="n">mtip_standby_immediate</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Suspend function</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called by the Block Layer just before the</span>
<span class="cm"> * system hibernates.</span>
<span class="cm"> *</span>
<span class="cm"> * @dd Pointer to the driver data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * return value</span>
<span class="cm"> *	0	Suspend was successful</span>
<span class="cm"> *	-EFAULT Suspend was not successful</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mtip_hw_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">dd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Send standby immediate (E0h) to the drive</span>
<span class="cm">	 * so that it saves its state.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mtip_standby_immediate</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;Failed standby-immediate command</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Disable interrupts on the HBA.*/</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">HOST_CTL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">HOST_IRQ_EN</span><span class="p">,</span>
			<span class="n">dd</span><span class="o">-&gt;</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">HOST_CTL</span><span class="p">);</span>
	<span class="n">mtip_deinit_port</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Resume function</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called by the Block Layer as the</span>
<span class="cm"> * system resumes.</span>
<span class="cm"> *</span>
<span class="cm"> * @dd Pointer to the driver data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * return value</span>
<span class="cm"> *	0	Resume was successful</span>
<span class="cm"> *      -EFAULT Resume was not successful</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mtip_hw_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">dd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Perform any needed hardware setup steps */</span>
	<span class="n">hba_setup</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>

	<span class="cm">/* Reset the HBA */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mtip_hba_reset</span><span class="p">(</span><span class="n">dd</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;Unable to reset the HBA</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Enable the port, DMA engine, and FIS reception specific</span>
<span class="cm">	 * h/w in controller.</span>
<span class="cm">	 */</span>
	<span class="n">mtip_init_port</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">);</span>
	<span class="n">mtip_start_port</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">);</span>

	<span class="cm">/* Enable interrupts on the HBA.*/</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">HOST_CTL</span><span class="p">)</span> <span class="o">|</span> <span class="n">HOST_IRQ_EN</span><span class="p">,</span>
			<span class="n">dd</span><span class="o">-&gt;</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">HOST_CTL</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Helper function for reusing disk name</span>
<span class="cm"> * upon hot insertion.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">rssd_disk_name_format</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">prefix</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="n">index</span><span class="p">,</span>
				 <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="n">buflen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">base</span> <span class="o">=</span> <span class="sc">&#39;z&#39;</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">begin</span> <span class="o">=</span> <span class="n">buf</span> <span class="o">+</span> <span class="n">strlen</span><span class="p">(</span><span class="n">prefix</span><span class="p">);</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">end</span> <span class="o">=</span> <span class="n">buf</span> <span class="o">+</span> <span class="n">buflen</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">unit</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
	<span class="n">unit</span> <span class="o">=</span> <span class="n">base</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">begin</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="o">*--</span><span class="n">p</span> <span class="o">=</span> <span class="sc">&#39;a&#39;</span> <span class="o">+</span> <span class="p">(</span><span class="n">index</span> <span class="o">%</span> <span class="n">unit</span><span class="p">);</span>
		<span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="n">index</span> <span class="o">/</span> <span class="n">unit</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">memmove</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">p</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">prefix</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">prefix</span><span class="p">));</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Block layer IOCTL handler.</span>
<span class="cm"> *</span>
<span class="cm"> * @dev Pointer to the block_device structure.</span>
<span class="cm"> * @mode ignored</span>
<span class="cm"> * @cmd IOCTL command passed from the user application.</span>
<span class="cm"> * @arg Argument passed from the user application.</span>
<span class="cm"> *</span>
<span class="cm"> * return value</span>
<span class="cm"> *	0        IOCTL completed successfully.</span>
<span class="cm"> *	-ENOTTY  IOCTL not supported or invalid driver data</span>
<span class="cm"> *                 structure pointer.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mtip_block_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			    <span class="n">fmode_t</span> <span class="n">mode</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="n">cmd</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">dd</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">bd_disk</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dd</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">MTIP_DDF_REMOVE_PENDING_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">dd_flag</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">BLKFLSBUF</span>:
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="n">mtip_hw_ioctl</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_COMPAT</span>
<span class="cm">/*</span>
<span class="cm"> * Block layer compat IOCTL handler.</span>
<span class="cm"> *</span>
<span class="cm"> * @dev Pointer to the block_device structure.</span>
<span class="cm"> * @mode ignored</span>
<span class="cm"> * @cmd IOCTL command passed from the user application.</span>
<span class="cm"> * @arg Argument passed from the user application.</span>
<span class="cm"> *</span>
<span class="cm"> * return value</span>
<span class="cm"> *	0        IOCTL completed successfully.</span>
<span class="cm"> *	-ENOTTY  IOCTL not supported or invalid driver data</span>
<span class="cm"> *                 structure pointer.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mtip_block_compat_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			    <span class="n">fmode_t</span> <span class="n">mode</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="n">cmd</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">dd</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">bd_disk</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dd</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">MTIP_DDF_REMOVE_PENDING_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">dd_flag</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">BLKFLSBUF</span>:
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HDIO_DRIVE_TASKFILE</span>: <span class="p">{</span>
		<span class="k">struct</span> <span class="n">mtip_compat_ide_task_request_s</span> <span class="n">__user</span> <span class="o">*</span><span class="n">compat_req_task</span><span class="p">;</span>
		<span class="n">ide_task_request_t</span> <span class="n">req_task</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">compat_tasksize</span><span class="p">,</span> <span class="n">outtotal</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>

		<span class="n">compat_tasksize</span> <span class="o">=</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtip_compat_ide_task_request_s</span><span class="p">);</span>

		<span class="n">compat_req_task</span> <span class="o">=</span>
			<span class="p">(</span><span class="k">struct</span> <span class="n">mtip_compat_ide_task_request_s</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req_task</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">,</span>
			<span class="n">compat_tasksize</span> <span class="o">-</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">compat_long_t</span><span class="p">))))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">req_task</span><span class="p">.</span><span class="n">out_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">compat_req_task</span><span class="o">-&gt;</span><span class="n">out_size</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">req_task</span><span class="p">.</span><span class="n">in_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">compat_req_task</span><span class="o">-&gt;</span><span class="n">in_size</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

		<span class="n">outtotal</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtip_compat_ide_task_request_s</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">exec_drive_taskfile</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">req_task</span><span class="p">,</span> <span class="n">outtotal</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">((</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req_task</span><span class="p">,</span>
				<span class="n">compat_tasksize</span> <span class="o">-</span>
				<span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">compat_long_t</span><span class="p">))))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="n">req_task</span><span class="p">.</span><span class="n">out_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">compat_req_task</span><span class="o">-&gt;</span><span class="n">out_size</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="n">req_task</span><span class="p">.</span><span class="n">in_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">compat_req_task</span><span class="o">-&gt;</span><span class="n">in_size</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="n">mtip_hw_ioctl</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Obtain the geometry of the device.</span>
<span class="cm"> *</span>
<span class="cm"> * You may think that this function is obsolete, but some applications,</span>
<span class="cm"> * fdisk for example still used CHS values. This function describes the</span>
<span class="cm"> * device as having 224 heads and 56 sectors per cylinder. These values are</span>
<span class="cm"> * chosen so that each cylinder is aligned on a 4KB boundary. Since a</span>
<span class="cm"> * partition is described in terms of a start and end cylinder this means</span>
<span class="cm"> * that each partition is also 4KB aligned. Non-aligned partitions adversely</span>
<span class="cm"> * affects performance.</span>
<span class="cm"> *</span>
<span class="cm"> * @dev Pointer to the block_device strucutre.</span>
<span class="cm"> * @geo Pointer to a hd_geometry structure.</span>
<span class="cm"> *</span>
<span class="cm"> * return value</span>
<span class="cm"> *	0       Operation completed successfully.</span>
<span class="cm"> *	-ENOTTY An error occurred while reading the drive capacity.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mtip_block_getgeo</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">hd_geometry</span> <span class="o">*</span><span class="n">geo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">dd</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">bd_disk</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">capacity</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dd</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">mtip_hw_get_capacity</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">capacity</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;Could not get drive capacity.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">geo</span><span class="o">-&gt;</span><span class="n">heads</span> <span class="o">=</span> <span class="mi">224</span><span class="p">;</span>
	<span class="n">geo</span><span class="o">-&gt;</span><span class="n">sectors</span> <span class="o">=</span> <span class="mi">56</span><span class="p">;</span>
	<span class="n">sector_div</span><span class="p">(</span><span class="n">capacity</span><span class="p">,</span> <span class="p">(</span><span class="n">geo</span><span class="o">-&gt;</span><span class="n">heads</span> <span class="o">*</span> <span class="n">geo</span><span class="o">-&gt;</span><span class="n">sectors</span><span class="p">));</span>
	<span class="n">geo</span><span class="o">-&gt;</span><span class="n">cylinders</span> <span class="o">=</span> <span class="n">capacity</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Block device operation function.</span>
<span class="cm"> *</span>
<span class="cm"> * This structure contains pointers to the functions required by the block</span>
<span class="cm"> * layer.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">block_device_operations</span> <span class="n">mtip_block_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">ioctl</span>		<span class="o">=</span> <span class="n">mtip_block_ioctl</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_COMPAT</span>
	<span class="p">.</span><span class="n">compat_ioctl</span>	<span class="o">=</span> <span class="n">mtip_block_compat_ioctl</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="p">.</span><span class="n">getgeo</span>		<span class="o">=</span> <span class="n">mtip_block_getgeo</span><span class="p">,</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Block layer make request function.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called by the kernel to process a BIO for</span>
<span class="cm"> * the P320 device.</span>
<span class="cm"> *</span>
<span class="cm"> * @queue Pointer to the request queue. Unused other than to obtain</span>
<span class="cm"> *              the driver data structure.</span>
<span class="cm"> * @bio   Pointer to the BIO.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mtip_make_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">queue</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">dd</span> <span class="o">=</span> <span class="n">queue</span><span class="o">-&gt;</span><span class="n">queuedata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio_vec</span> <span class="o">*</span><span class="n">bvec</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nents</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">dd_flag</span> <span class="o">&amp;</span> <span class="n">MTIP_DDF_STOP_IO</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">MTIP_DDF_REMOVE_PENDING_BIT</span><span class="p">,</span>
							<span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">dd_flag</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">bio_endio</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">MTIP_DDF_OVER_TEMP_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">dd_flag</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">bio_endio</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="o">-</span><span class="n">ENODATA</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">MTIP_DDF_WRITE_PROTECT_BIT</span><span class="p">,</span>
							<span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">dd_flag</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				<span class="n">bio_data_dir</span><span class="p">(</span><span class="n">bio</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">bio_endio</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="o">-</span><span class="n">ENODATA</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">bio_has_data</span><span class="p">(</span><span class="n">bio</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">blk_queue_flush</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">bio_endio</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sg</span> <span class="o">=</span> <span class="n">mtip_hw_get_scatterlist</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tag</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">sg</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">blk_queue_bounce</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bio</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">((</span><span class="n">bio</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bi_vcnt</span> <span class="o">&gt;</span> <span class="n">MTIP_MAX_SG</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;Maximum number of SGL entries exceeded</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">bio_io_error</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>
			<span class="n">mtip_hw_release_scatterlist</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">tag</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Create the scatter list for this bio. */</span>
		<span class="n">bio_for_each_segment</span><span class="p">(</span><span class="n">bvec</span><span class="p">,</span> <span class="n">bio</span><span class="p">,</span> <span class="n">nents</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sg_set_page</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sg</span><span class="p">[</span><span class="n">nents</span><span class="p">],</span>
					<span class="n">bvec</span><span class="o">-&gt;</span><span class="n">bv_page</span><span class="p">,</span>
					<span class="n">bvec</span><span class="o">-&gt;</span><span class="n">bv_len</span><span class="p">,</span>
					<span class="n">bvec</span><span class="o">-&gt;</span><span class="n">bv_offset</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* Issue the read/write. */</span>
		<span class="n">mtip_hw_submit_io</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span>
				<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_sector</span><span class="p">,</span>
				<span class="n">bio_sectors</span><span class="p">(</span><span class="n">bio</span><span class="p">),</span>
				<span class="n">nents</span><span class="p">,</span>
				<span class="n">tag</span><span class="p">,</span>
				<span class="n">bio_endio</span><span class="p">,</span>
				<span class="n">bio</span><span class="p">,</span>
				<span class="n">bio_data_dir</span><span class="p">(</span><span class="n">bio</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">bio_io_error</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Block layer initialization function.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called once by the PCI layer for each P320</span>
<span class="cm"> * device that is connected to the system.</span>
<span class="cm"> *</span>
<span class="cm"> * @dd Pointer to the driver data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * return value</span>
<span class="cm"> *	0 on success else an error code.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mtip_block_initialize</span><span class="p">(</span><span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">dd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rv</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">wait_for_rebuild</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">capacity</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">thd_name</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">disk</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">skip_create_disk</span><span class="p">;</span> <span class="cm">/* hw init done, before rebuild */</span>

	<span class="cm">/* Initialize the protocol layer. */</span>
	<span class="n">wait_for_rebuild</span> <span class="o">=</span> <span class="n">mtip_hw_init</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wait_for_rebuild</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;Protocol layer initialization failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">rv</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">protocol_init_error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">disk</span> <span class="o">=</span> <span class="n">alloc_disk</span><span class="p">(</span><span class="n">MTIP_MAX_MINORS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">disk</span>  <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;Unable to allocate gendisk structure</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">rv</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">alloc_disk_error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Generate the disk name, implemented same as in sd.c */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ida_pre_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rssd_index_ida</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">ida_get_error</span><span class="p">;</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rssd_index_lock</span><span class="p">);</span>
		<span class="n">rv</span> <span class="o">=</span> <span class="n">ida_get_new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rssd_index_ida</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">index</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rssd_index_lock</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">rv</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rv</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">ida_get_error</span><span class="p">;</span>

	<span class="n">rv</span> <span class="o">=</span> <span class="n">rssd_disk_name_format</span><span class="p">(</span><span class="s">&quot;rssd&quot;</span><span class="p">,</span>
				<span class="n">index</span><span class="p">,</span>
				<span class="n">dd</span><span class="o">-&gt;</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">disk_name</span><span class="p">,</span>
				<span class="n">DISK_NAME_LEN</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rv</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">disk_index_error</span><span class="p">;</span>

	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">driverfs_dev</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">major</span>		<span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">major</span><span class="p">;</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">first_minor</span>	<span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">instance</span> <span class="o">*</span> <span class="n">MTIP_MAX_MINORS</span><span class="p">;</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">fops</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">mtip_block_ops</span><span class="p">;</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">private_data</span>	<span class="o">=</span> <span class="n">dd</span><span class="p">;</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">index</span>		<span class="o">=</span> <span class="n">index</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * if rebuild pending, start the service thread, and delay the block</span>
<span class="cm">	 * queue creation and add_disk()</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wait_for_rebuild</span> <span class="o">==</span> <span class="n">MTIP_FTL_REBUILD_MAGIC</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">start_service_thread</span><span class="p">;</span>

<span class="nl">skip_create_disk:</span>
	<span class="cm">/* Allocate the request queue. */</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">queue</span> <span class="o">=</span> <span class="n">blk_alloc_queue</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">queue</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;Unable to allocate request queue</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">rv</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">block_queue_alloc_init_error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Attach our request function to the request queue. */</span>
	<span class="n">blk_queue_make_request</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="n">mtip_make_request</span><span class="p">);</span>

	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">queue</span>		<span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">;</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">queuedata</span>	<span class="o">=</span> <span class="n">dd</span><span class="p">;</span>

	<span class="cm">/* Set device limits. */</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">QUEUE_FLAG_NONROT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">queue_flags</span><span class="p">);</span>
	<span class="n">blk_queue_max_segments</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="n">MTIP_MAX_SG</span><span class="p">);</span>
	<span class="n">blk_queue_physical_block_size</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="mi">4096</span><span class="p">);</span>
	<span class="n">blk_queue_max_hw_sectors</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="mh">0xffff</span><span class="p">);</span>
	<span class="n">blk_queue_max_segment_size</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="mh">0x400000</span><span class="p">);</span>
	<span class="n">blk_queue_io_min</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="mi">4096</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * write back cache is not supported in the device. FUA depends on</span>
<span class="cm">	 * write back cache support, hence setting flush support to zero.</span>
<span class="cm">	 */</span>
	<span class="n">blk_queue_flush</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Set the capacity of the device in 512 byte sectors. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">mtip_hw_get_capacity</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">capacity</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;Could not read drive capacity</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">rv</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">read_capacity_error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">set_capacity</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">disk</span><span class="p">,</span> <span class="n">capacity</span><span class="p">);</span>

	<span class="cm">/* Enable the block device and add it to /dev */</span>
	<span class="n">add_disk</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">disk</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now that the disk is active, initialize any sysfs attributes</span>
<span class="cm">	 * managed by the protocol layer.</span>
<span class="cm">	 */</span>
	<span class="n">kobj</span> <span class="o">=</span> <span class="n">kobject_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">disk_to_dev</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">disk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kobj</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mtip_hw_sysfs_init</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">kobj</span><span class="p">);</span>
		<span class="n">kobject_put</span><span class="p">(</span><span class="n">kobj</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mtip_hw_debugfs_init</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">mtip_svc_handler</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">MTIP_DDF_INIT_DONE_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">dd_flag</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rv</span><span class="p">;</span> <span class="cm">/* service thread created for handling rebuild */</span>
	<span class="p">}</span>

<span class="nl">start_service_thread:</span>
	<span class="n">sprintf</span><span class="p">(</span><span class="n">thd_name</span><span class="p">,</span> <span class="s">&quot;mtip_svc_thd_%02d&quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>

	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">mtip_svc_handler</span> <span class="o">=</span> <span class="n">kthread_run</span><span class="p">(</span><span class="n">mtip_service_thread</span><span class="p">,</span>
						<span class="n">dd</span><span class="p">,</span> <span class="n">thd_name</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">mtip_svc_handler</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;service thread failed to start</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">mtip_svc_handler</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">rv</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">kthread_run_error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wait_for_rebuild</span> <span class="o">==</span> <span class="n">MTIP_FTL_REBUILD_MAGIC</span><span class="p">)</span>
		<span class="n">rv</span> <span class="o">=</span> <span class="n">wait_for_rebuild</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">rv</span><span class="p">;</span>

<span class="nl">kthread_run_error:</span>
	<span class="n">mtip_hw_debugfs_exit</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>

	<span class="cm">/* Delete our gendisk. This also removes the device from /dev */</span>
	<span class="n">del_gendisk</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">disk</span><span class="p">);</span>

<span class="nl">read_capacity_error:</span>
	<span class="n">blk_cleanup_queue</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>

<span class="nl">block_queue_alloc_init_error:</span>
<span class="nl">disk_index_error:</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rssd_index_lock</span><span class="p">);</span>
	<span class="n">ida_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rssd_index_ida</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rssd_index_lock</span><span class="p">);</span>

<span class="nl">ida_get_error:</span>
	<span class="n">put_disk</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">disk</span><span class="p">);</span>

<span class="nl">alloc_disk_error:</span>
	<span class="n">mtip_hw_exit</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span> <span class="cm">/* De-initialize the protocol layer. */</span>

<span class="nl">protocol_init_error:</span>
	<span class="k">return</span> <span class="n">rv</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Block layer deinitialization function.</span>
<span class="cm"> *</span>
<span class="cm"> * Called by the PCI layer as each P320 device is removed.</span>
<span class="cm"> *</span>
<span class="cm"> * @dd Pointer to the driver data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * return value</span>
<span class="cm"> *	0</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mtip_block_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">dd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">mtip_svc_handler</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">MTIP_PF_SVC_THD_STOP_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">svc_wait</span><span class="p">);</span>
		<span class="n">kthread_stop</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">mtip_svc_handler</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Clean up the sysfs attributes, if created */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">MTIP_DDF_INIT_DONE_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">dd_flag</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">kobj</span> <span class="o">=</span> <span class="n">kobject_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">disk_to_dev</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">disk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kobj</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mtip_hw_sysfs_exit</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">kobj</span><span class="p">);</span>
			<span class="n">kobject_put</span><span class="p">(</span><span class="n">kobj</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">mtip_hw_debugfs_exit</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Delete our gendisk structure. This also removes the device</span>
<span class="cm">	 * from /dev</span>
<span class="cm">	 */</span>
	<span class="n">del_gendisk</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">disk</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rssd_index_lock</span><span class="p">);</span>
	<span class="n">ida_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rssd_index_ida</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rssd_index_lock</span><span class="p">);</span>

	<span class="n">blk_cleanup_queue</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">disk</span>  <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">queue</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* De-initialize the protocol layer. */</span>
	<span class="n">mtip_hw_exit</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function called by the PCI layer when just before the</span>
<span class="cm"> * machine shuts down.</span>
<span class="cm"> *</span>
<span class="cm"> * If a protocol layer shutdown function is present it will be called</span>
<span class="cm"> * by this function.</span>
<span class="cm"> *</span>
<span class="cm"> * @dd Pointer to the driver data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * return value</span>
<span class="cm"> *	0</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mtip_block_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">dd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;Shutting down %s ...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">disk_name</span><span class="p">);</span>

	<span class="cm">/* Delete our gendisk structure, and cleanup the blk queue. */</span>
	<span class="n">del_gendisk</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">disk</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rssd_index_lock</span><span class="p">);</span>
	<span class="n">ida_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rssd_index_ida</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rssd_index_lock</span><span class="p">);</span>

	<span class="n">blk_cleanup_queue</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">disk</span>  <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">queue</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">mtip_hw_shutdown</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mtip_block_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">dd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;Suspending %s ...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">disk_name</span><span class="p">);</span>
	<span class="n">mtip_hw_suspend</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mtip_block_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">dd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Resuming %s ...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">disk_name</span><span class="p">);</span>
	<span class="n">mtip_hw_resume</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called for each supported PCI device detected.</span>
<span class="cm"> *</span>
<span class="cm"> * This function allocates the private data structure, enables the</span>
<span class="cm"> * PCI device and then calls the block layer initialization function.</span>
<span class="cm"> *</span>
<span class="cm"> * return value</span>
<span class="cm"> *	0 on success else an error code.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mtip_pci_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">ent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rv</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">dd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Allocate memory for this devices private data. */</span>
	<span class="n">dd</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">driver_data</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dd</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;Unable to allocate memory for driver data</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Attach the private data to this PCI device.  */</span>
	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">dd</span><span class="p">);</span>

	<span class="n">rv</span> <span class="o">=</span> <span class="n">pcim_enable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rv</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Unable to enable device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">iomap_err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Map BAR5 to memory. */</span>
	<span class="n">rv</span> <span class="o">=</span> <span class="n">pcim_iomap_regions</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">MTIP_ABAR</span><span class="p">,</span> <span class="n">MTIP_DRV_NAME</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rv</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Unable to map regions</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">iomap_err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pci_set_dma_mask</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">64</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">rv</span> <span class="o">=</span> <span class="n">pci_set_consistent_dma_mask</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">64</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rv</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rv</span> <span class="o">=</span> <span class="n">pci_set_consistent_dma_mask</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span>
						<span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">32</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rv</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="s">&quot;64-bit DMA enable failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">setmask_err</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">pci_set_master</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pci_enable_msi</span><span class="p">(</span><span class="n">pdev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;Unable to enable MSI interrupt.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">block_initialize_err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Copy the info we may need later into the private data structure. */</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">major</span>	<span class="o">=</span> <span class="n">mtip_major</span><span class="p">;</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">instance</span>	<span class="o">=</span> <span class="n">instance</span><span class="p">;</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">pdev</span>	<span class="o">=</span> <span class="n">pdev</span><span class="p">;</span>

	<span class="cm">/* Initialize the block layer. */</span>
	<span class="n">rv</span> <span class="o">=</span> <span class="n">mtip_block_initialize</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rv</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;Unable to initialize block layer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">block_initialize_err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Increment the instance count so that each device has a unique</span>
<span class="cm">	 * instance number.</span>
<span class="cm">	 */</span>
	<span class="n">instance</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rv</span> <span class="o">!=</span> <span class="n">MTIP_FTL_REBUILD_MAGIC</span><span class="p">)</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">MTIP_DDF_INIT_DONE_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">dd_flag</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

<span class="nl">block_initialize_err:</span>
	<span class="n">pci_disable_msi</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

<span class="nl">setmask_err:</span>
	<span class="n">pcim_iounmap_regions</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">MTIP_ABAR</span><span class="p">);</span>

<span class="nl">iomap_err:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>
	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rv</span><span class="p">;</span>
<span class="nl">done:</span>
	<span class="k">return</span> <span class="n">rv</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called for each probed device when the device is removed or the</span>
<span class="cm"> * driver is unloaded.</span>
<span class="cm"> *</span>
<span class="cm"> * return value</span>
<span class="cm"> *	None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mtip_pci_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">dd</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">set_bit</span><span class="p">(</span><span class="n">MTIP_DDF_REMOVE_PENDING_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">dd_flag</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mtip_check_surprise_removal</span><span class="p">(</span><span class="n">pdev</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">MTIP_DDF_CLEANUP_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">dd_flag</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">counter</span><span class="o">++</span><span class="p">;</span>
			<span class="n">msleep</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">counter</span> <span class="o">==</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Cleanup the outstanding commands */</span>
				<span class="n">mtip_command_cleanup</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Clean up the block layer. */</span>
	<span class="n">mtip_block_remove</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>

	<span class="n">pci_disable_msi</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>
	<span class="n">pcim_iounmap_regions</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">MTIP_ABAR</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called for each probed device when the device is suspended.</span>
<span class="cm"> *</span>
<span class="cm"> * return value</span>
<span class="cm"> *	0  Success</span>
<span class="cm"> *	&lt;0 Error</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mtip_pci_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">mesg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rv</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">dd</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;Driver private datastructure is NULL</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">set_bit</span><span class="p">(</span><span class="n">MTIP_DDF_RESUME_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">dd_flag</span><span class="p">);</span>

	<span class="cm">/* Disable ports &amp; interrupts then send standby immediate */</span>
	<span class="n">rv</span> <span class="o">=</span> <span class="n">mtip_block_suspend</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rv</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;Failed to suspend controller</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rv</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Save the pci config space to pdev structure &amp;</span>
<span class="cm">	 * disable the device</span>
<span class="cm">	 */</span>
	<span class="n">pci_save_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="cm">/* Move to Low power state*/</span>
	<span class="n">pci_set_power_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_D3hot</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rv</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called for each probed device when the device is resumed.</span>
<span class="cm"> *</span>
<span class="cm"> * return value</span>
<span class="cm"> *      0  Success</span>
<span class="cm"> *      &lt;0 Error</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mtip_pci_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rv</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">dd</span><span class="p">;</span>

	<span class="n">dd</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;Driver private datastructure is NULL</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Move the device to active State */</span>
	<span class="n">pci_set_power_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_D0</span><span class="p">);</span>

	<span class="cm">/* Restore PCI configuration space */</span>
	<span class="n">pci_restore_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="cm">/* Enable the PCI device*/</span>
	<span class="n">rv</span> <span class="o">=</span> <span class="n">pcim_enable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rv</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;Failed to enable card during resume</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pci_set_master</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Calls hbaReset, initPort, &amp; startPort function</span>
<span class="cm">	 * then enables interrupts</span>
<span class="cm">	 */</span>
	<span class="n">rv</span> <span class="o">=</span> <span class="n">mtip_block_resume</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rv</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Unable to resume</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="nl">err:</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">MTIP_DDF_RESUME_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">dd_flag</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rv</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Shutdown routine</span>
<span class="cm"> *</span>
<span class="cm"> * return value</span>
<span class="cm"> *      None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mtip_pci_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">dd</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="p">)</span>
		<span class="n">mtip_block_shutdown</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Table of device ids supported by this driver. */</span>
<span class="k">static</span> <span class="n">DEFINE_PCI_DEVICE_TABLE</span><span class="p">(</span><span class="n">mtip_pci_tbl</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span>  <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_MICRON</span><span class="p">,</span> <span class="n">P320_DEVICE_ID</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="mi">0</span> <span class="p">}</span>
<span class="p">};</span>

<span class="cm">/* Structure that describes the PCI driver functions. */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_driver</span> <span class="n">mtip_pci_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>			<span class="o">=</span> <span class="n">MTIP_DRV_NAME</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_table</span>		<span class="o">=</span> <span class="n">mtip_pci_tbl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span>			<span class="o">=</span> <span class="n">mtip_pci_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span>			<span class="o">=</span> <span class="n">mtip_pci_remove</span><span class="p">,</span>
	<span class="p">.</span><span class="n">suspend</span>		<span class="o">=</span> <span class="n">mtip_pci_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span>			<span class="o">=</span> <span class="n">mtip_pci_resume</span><span class="p">,</span>
	<span class="p">.</span><span class="n">shutdown</span>		<span class="o">=</span> <span class="n">mtip_pci_shutdown</span><span class="p">,</span>
<span class="p">};</span>

<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">mtip_pci_tbl</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Module initialization function.</span>
<span class="cm"> *</span>
<span class="cm"> * Called once when the module is loaded. This function allocates a major</span>
<span class="cm"> * block device number to the Cyclone devices and registers the PCI layer</span>
<span class="cm"> * of the driver.</span>
<span class="cm"> *</span>
<span class="cm"> * Return value</span>
<span class="cm"> *      0 on success else error code.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">mtip_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="n">MTIP_DRV_NAME</span> <span class="s">&quot; Version &quot;</span> <span class="n">MTIP_DRV_VERSION</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Allocate a major block device number to use with this driver. */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">register_blkdev</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">MTIP_DRV_NAME</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Unable to register block device (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">error</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mtip_major</span> <span class="o">=</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dfs_parent</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dfs_parent</span> <span class="o">=</span> <span class="n">debugfs_create_dir</span><span class="p">(</span><span class="s">&quot;rssd&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR_OR_NULL</span><span class="p">(</span><span class="n">dfs_parent</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;Error creating debugfs parent</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">dfs_parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Register our PCI operations. */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">pci_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mtip_pci_driver</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">debugfs_remove</span><span class="p">(</span><span class="n">dfs_parent</span><span class="p">);</span>
		<span class="n">unregister_blkdev</span><span class="p">(</span><span class="n">mtip_major</span><span class="p">,</span> <span class="n">MTIP_DRV_NAME</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Module de-initialization function.</span>
<span class="cm"> *</span>
<span class="cm"> * Called once when the module is unloaded. This function deallocates</span>
<span class="cm"> * the major block device number allocated by mtip_init() and</span>
<span class="cm"> * unregisters the PCI layer of the driver.</span>
<span class="cm"> *</span>
<span class="cm"> * Return value</span>
<span class="cm"> *      none</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">mtip_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">debugfs_remove_recursive</span><span class="p">(</span><span class="n">dfs_parent</span><span class="p">);</span>

	<span class="cm">/* Release the allocated major block device number. */</span>
	<span class="n">unregister_blkdev</span><span class="p">(</span><span class="n">mtip_major</span><span class="p">,</span> <span class="n">MTIP_DRV_NAME</span><span class="p">);</span>

	<span class="cm">/* Unregister the PCI driver. */</span>
	<span class="n">pci_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mtip_pci_driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Micron Technology, Inc&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Micron RealSSD PCIe Block Driver&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_VERSION</span><span class="p">(</span><span class="n">MTIP_DRV_VERSION</span><span class="p">);</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">mtip_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">mtip_exit</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
