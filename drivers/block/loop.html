<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › block › loop.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>loop.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  linux/drivers/block/loop.c</span>
<span class="cm"> *</span>
<span class="cm"> *  Written by Theodore Ts&#39;o, 3/29/93</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright 1993 by Theodore Ts&#39;o.  Redistribution of this file is</span>
<span class="cm"> * permitted under the GNU General Public License.</span>
<span class="cm"> *</span>
<span class="cm"> * DES encryption plus some minor changes by Werner Almesberger, 30-MAY-1993</span>
<span class="cm"> * more DES encryption plus IDEA encryption by Nicholas J. Leon, June 20, 1996</span>
<span class="cm"> *</span>
<span class="cm"> * Modularized and updated for 1.1.16 kernel - Mitch Dsouza 28th May 1994</span>
<span class="cm"> * Adapted for 1.3.59 kernel - Andries Brouwer, 1 Feb 1996</span>
<span class="cm"> *</span>
<span class="cm"> * Fixed do_loop_request() re-entrancy - Vincent.Renardias@waw.com Mar 20, 1997</span>
<span class="cm"> *</span>
<span class="cm"> * Added devfs support - Richard Gooch &lt;rgooch@atnf.csiro.au&gt; 16-Jan-1998</span>
<span class="cm"> *</span>
<span class="cm"> * Handle sparse backing files correctly - Kenn Humborg, Jun 28, 1998</span>
<span class="cm"> *</span>
<span class="cm"> * Loadable modules and other fixes by AK, 1998</span>
<span class="cm"> *</span>
<span class="cm"> * Make real block number available to downstream transfer functions, enables</span>
<span class="cm"> * CBC (and relatives) mode encryption requiring unique IVs per data block.</span>
<span class="cm"> * Reed H. Petty, rhp@draper.net</span>
<span class="cm"> *</span>
<span class="cm"> * Maximum number of loop devices now dynamic via max_loop module parameter.</span>
<span class="cm"> * Russell Kroll &lt;rkroll@exploits.org&gt; 19990701</span>
<span class="cm"> *</span>
<span class="cm"> * Maximum number of loop devices when compiled-in now selectable by passing</span>
<span class="cm"> * max_loop=&lt;1-255&gt; to the kernel on boot.</span>
<span class="cm"> * Erik I. Bolsø, &lt;eriki@himolde.no&gt;, Oct 31, 1999</span>
<span class="cm"> *</span>
<span class="cm"> * Completely rewrite request handling to be make_request_fn style and</span>
<span class="cm"> * non blocking, pushing work to a helper thread. Lots of fixes from</span>
<span class="cm"> * Al Viro too.</span>
<span class="cm"> * Jens Axboe &lt;axboe@suse.de&gt;, Nov 2000</span>
<span class="cm"> *</span>
<span class="cm"> * Support up to 256 loop devices</span>
<span class="cm"> * Heinz Mauelshagen &lt;mge@sistina.com&gt;, Feb 2002</span>
<span class="cm"> *</span>
<span class="cm"> * Support for falling back on the write file operation when the address space</span>
<span class="cm"> * operations write_begin is not available on the backing filesystem.</span>
<span class="cm"> * Anton Altaparmakov, 16 Feb 2005</span>
<span class="cm"> *</span>
<span class="cm"> * Still To Fix:</span>
<span class="cm"> * - Advisory locking is ignored here.</span>
<span class="cm"> * - Should use an own CAP_* category instead of CAP_SYS_ADMIN</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/moduleparam.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/file.h&gt;</span>
<span class="cp">#include &lt;linux/stat.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/major.h&gt;</span>
<span class="cp">#include &lt;linux/wait.h&gt;</span>
<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;linux/blkpg.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/swap.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/loop.h&gt;</span>
<span class="cp">#include &lt;linux/compat.h&gt;</span>
<span class="cp">#include &lt;linux/suspend.h&gt;</span>
<span class="cp">#include &lt;linux/freezer.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/writeback.h&gt;</span>
<span class="cp">#include &lt;linux/completion.h&gt;</span>
<span class="cp">#include &lt;linux/highmem.h&gt;</span>
<span class="cp">#include &lt;linux/kthread.h&gt;</span>
<span class="cp">#include &lt;linux/splice.h&gt;</span>
<span class="cp">#include &lt;linux/sysfs.h&gt;</span>
<span class="cp">#include &lt;linux/miscdevice.h&gt;</span>
<span class="cp">#include &lt;linux/falloc.h&gt;</span>

<span class="cp">#include &lt;asm/uaccess.h&gt;</span>

<span class="k">static</span> <span class="n">DEFINE_IDR</span><span class="p">(</span><span class="n">loop_index_idr</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">loop_index_mutex</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">max_part</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">part_shift</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Transfer functions</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">transfer_none</span><span class="p">(</span><span class="k">struct</span> <span class="n">loop_device</span> <span class="o">*</span><span class="n">lo</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">raw_page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">raw_off</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">loop_page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">loop_off</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">real_block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">raw_buf</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">raw_page</span><span class="p">)</span> <span class="o">+</span> <span class="n">raw_off</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">loop_buf</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">loop_page</span><span class="p">)</span> <span class="o">+</span> <span class="n">loop_off</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">READ</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">loop_buf</span><span class="p">,</span> <span class="n">raw_buf</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">raw_buf</span><span class="p">,</span> <span class="n">loop_buf</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

	<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">loop_buf</span><span class="p">);</span>
	<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">raw_buf</span><span class="p">);</span>
	<span class="n">cond_resched</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">transfer_xor</span><span class="p">(</span><span class="k">struct</span> <span class="n">loop_device</span> <span class="o">*</span><span class="n">lo</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">raw_page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">raw_off</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">loop_page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">loop_off</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">real_block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">raw_buf</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">raw_page</span><span class="p">)</span> <span class="o">+</span> <span class="n">raw_off</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">loop_buf</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">loop_page</span><span class="p">)</span> <span class="o">+</span> <span class="n">loop_off</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span> <span class="o">*</span><span class="n">key</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">keysize</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">READ</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">in</span> <span class="o">=</span> <span class="n">raw_buf</span><span class="p">;</span>
		<span class="n">out</span> <span class="o">=</span> <span class="n">loop_buf</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">in</span> <span class="o">=</span> <span class="n">loop_buf</span><span class="p">;</span>
		<span class="n">out</span> <span class="o">=</span> <span class="n">raw_buf</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">key</span> <span class="o">=</span> <span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_encrypt_key</span><span class="p">;</span>
	<span class="n">keysize</span> <span class="o">=</span> <span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_encrypt_key_size</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="o">*</span><span class="n">out</span><span class="o">++</span> <span class="o">=</span> <span class="o">*</span><span class="n">in</span><span class="o">++</span> <span class="o">^</span> <span class="n">key</span><span class="p">[(</span><span class="n">i</span> <span class="o">&amp;</span> <span class="mi">511</span><span class="p">)</span> <span class="o">%</span> <span class="n">keysize</span><span class="p">];</span>

	<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">loop_buf</span><span class="p">);</span>
	<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">raw_buf</span><span class="p">);</span>
	<span class="n">cond_resched</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">xor_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">loop_device</span> <span class="o">*</span><span class="n">lo</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">loop_info64</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">lo_encrypt_key_size</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">loop_func_table</span> <span class="n">none_funcs</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">number</span> <span class="o">=</span> <span class="n">LO_CRYPT_NONE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">transfer</span> <span class="o">=</span> <span class="n">transfer_none</span><span class="p">,</span>
<span class="p">};</span> 	

<span class="k">static</span> <span class="k">struct</span> <span class="n">loop_func_table</span> <span class="n">xor_funcs</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">number</span> <span class="o">=</span> <span class="n">LO_CRYPT_XOR</span><span class="p">,</span>
	<span class="p">.</span><span class="n">transfer</span> <span class="o">=</span> <span class="n">transfer_xor</span><span class="p">,</span>
	<span class="p">.</span><span class="n">init</span> <span class="o">=</span> <span class="n">xor_init</span>
<span class="p">};</span> 	

<span class="cm">/* xfer_funcs[0] is special - its release function is never called */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">loop_func_table</span> <span class="o">*</span><span class="n">xfer_funcs</span><span class="p">[</span><span class="n">MAX_LO_CRYPT</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="o">&amp;</span><span class="n">none_funcs</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">xor_funcs</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">loff_t</span> <span class="nf">get_size</span><span class="p">(</span><span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">sizelimit</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">loff_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">loopsize</span><span class="p">;</span>

	<span class="cm">/* Compute loopsize in bytes */</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>
	<span class="n">loopsize</span> <span class="o">=</span> <span class="n">size</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>
	<span class="cm">/* offset is beyond i_size, wierd but possible */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">loopsize</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sizelimit</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">sizelimit</span> <span class="o">&lt;</span> <span class="n">loopsize</span><span class="p">)</span>
		<span class="n">loopsize</span> <span class="o">=</span> <span class="n">sizelimit</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Unfortunately, if we want to do I/O on the device,</span>
<span class="cm">	 * the number of 512-byte sectors has to fit into a sector_t.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">loopsize</span> <span class="o">&gt;&gt;</span> <span class="mi">9</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">loff_t</span> <span class="nf">get_loop_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">loop_device</span> <span class="o">*</span><span class="n">lo</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">get_size</span><span class="p">(</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_offset</span><span class="p">,</span> <span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_sizelimit</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">figure_loop_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">loop_device</span> <span class="o">*</span><span class="n">lo</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">sizelimit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">loff_t</span> <span class="n">size</span> <span class="o">=</span> <span class="n">get_size</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">sizelimit</span><span class="p">,</span> <span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_backing_file</span><span class="p">);</span>
	<span class="n">sector_t</span> <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">sector_t</span><span class="p">)</span><span class="n">size</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">((</span><span class="n">loff_t</span><span class="p">)</span><span class="n">x</span> <span class="o">!=</span> <span class="n">size</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFBIG</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_offset</span> <span class="o">!=</span> <span class="n">offset</span><span class="p">)</span>
		<span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_offset</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_sizelimit</span> <span class="o">!=</span> <span class="n">sizelimit</span><span class="p">)</span>
		<span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_sizelimit</span> <span class="o">=</span> <span class="n">sizelimit</span><span class="p">;</span>
	<span class="n">set_capacity</span><span class="p">(</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_disk</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">lo_do_transfer</span><span class="p">(</span><span class="k">struct</span> <span class="n">loop_device</span> <span class="o">*</span><span class="n">lo</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span>
	       <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">rpage</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">roffs</span><span class="p">,</span>
	       <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">lpage</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">loffs</span><span class="p">,</span>
	       <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">rblock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">transfer</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">lo</span><span class="o">-&gt;</span><span class="n">transfer</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">rpage</span><span class="p">,</span> <span class="n">roffs</span><span class="p">,</span> <span class="n">lpage</span><span class="p">,</span> <span class="n">loffs</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">rblock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __do_lo_send_write - helper for writing data to a loop device</span>
<span class="cm"> *</span>
<span class="cm"> * This helper just factors out common code between do_lo_send_direct_write()</span>
<span class="cm"> * and do_lo_send_write().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__do_lo_send_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
		<span class="n">u8</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">ssize_t</span> <span class="n">bw</span><span class="p">;</span>
	<span class="n">mm_segment_t</span> <span class="n">old_fs</span> <span class="o">=</span> <span class="n">get_fs</span><span class="p">();</span>

	<span class="n">set_fs</span><span class="p">(</span><span class="n">get_ds</span><span class="p">());</span>
	<span class="n">bw</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pos</span><span class="p">);</span>
	<span class="n">set_fs</span><span class="p">(</span><span class="n">old_fs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">bw</span> <span class="o">==</span> <span class="n">len</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;loop: Write error at byte offset %llu, length %i.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">pos</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bw</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">bw</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">bw</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * do_lo_send_direct_write - helper for writing data to a loop device</span>
<span class="cm"> *</span>
<span class="cm"> * This is the fast, non-transforming version that does not need double</span>
<span class="cm"> * buffering.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_lo_send_direct_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">loop_device</span> <span class="o">*</span><span class="n">lo</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">bio_vec</span> <span class="o">*</span><span class="n">bvec</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">pos</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">ssize_t</span> <span class="n">bw</span> <span class="o">=</span> <span class="n">__do_lo_send_write</span><span class="p">(</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_backing_file</span><span class="p">,</span>
			<span class="n">kmap</span><span class="p">(</span><span class="n">bvec</span><span class="o">-&gt;</span><span class="n">bv_page</span><span class="p">)</span> <span class="o">+</span> <span class="n">bvec</span><span class="o">-&gt;</span><span class="n">bv_offset</span><span class="p">,</span>
			<span class="n">bvec</span><span class="o">-&gt;</span><span class="n">bv_len</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
	<span class="n">kunmap</span><span class="p">(</span><span class="n">bvec</span><span class="o">-&gt;</span><span class="n">bv_page</span><span class="p">);</span>
	<span class="n">cond_resched</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">bw</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * do_lo_send_write - helper for writing data to a loop device</span>
<span class="cm"> *</span>
<span class="cm"> * This is the slow, transforming version that needs to double buffer the</span>
<span class="cm"> * data as it cannot do the transformations in place without having direct</span>
<span class="cm"> * access to the destination pages of the backing file.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_lo_send_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">loop_device</span> <span class="o">*</span><span class="n">lo</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio_vec</span> <span class="o">*</span><span class="n">bvec</span><span class="p">,</span>
		<span class="n">loff_t</span> <span class="n">pos</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">lo_do_transfer</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">WRITE</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bvec</span><span class="o">-&gt;</span><span class="n">bv_page</span><span class="p">,</span>
			<span class="n">bvec</span><span class="o">-&gt;</span><span class="n">bv_offset</span><span class="p">,</span> <span class="n">bvec</span><span class="o">-&gt;</span><span class="n">bv_len</span><span class="p">,</span> <span class="n">pos</span> <span class="o">&gt;&gt;</span> <span class="mi">9</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">__do_lo_send_write</span><span class="p">(</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_backing_file</span><span class="p">,</span>
				<span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">),</span> <span class="n">bvec</span><span class="o">-&gt;</span><span class="n">bv_len</span><span class="p">,</span>
				<span class="n">pos</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;loop: Transfer error at byte offset %llu, &quot;</span>
			<span class="s">&quot;length %i.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">pos</span><span class="p">,</span> <span class="n">bvec</span><span class="o">-&gt;</span><span class="n">bv_len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">lo_send</span><span class="p">(</span><span class="k">struct</span> <span class="n">loop_device</span> <span class="o">*</span><span class="n">lo</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">do_lo_send</span><span class="p">)(</span><span class="k">struct</span> <span class="n">loop_device</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio_vec</span> <span class="o">*</span><span class="p">,</span> <span class="n">loff_t</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">bio_vec</span> <span class="o">*</span><span class="n">bvec</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">transfer</span> <span class="o">!=</span> <span class="n">transfer_none</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">alloc_page</span><span class="p">(</span><span class="n">GFP_NOIO</span> <span class="o">|</span> <span class="n">__GFP_HIGHMEM</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
		<span class="n">kmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">do_lo_send</span> <span class="o">=</span> <span class="n">do_lo_send_write</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">do_lo_send</span> <span class="o">=</span> <span class="n">do_lo_send_direct_write</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">bio_for_each_segment</span><span class="p">(</span><span class="n">bvec</span><span class="p">,</span> <span class="n">bio</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">do_lo_send</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">bvec</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">pos</span> <span class="o">+=</span> <span class="n">bvec</span><span class="o">-&gt;</span><span class="n">bv_len</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kunmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">__free_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="nl">fail:</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;loop: Failed to allocate temporary page for write.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">lo_read_data</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">loop_device</span> <span class="o">*</span><span class="n">lo</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">offset</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bsize</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lo_splice_actor</span><span class="p">(</span><span class="k">struct</span> <span class="n">pipe_inode_info</span> <span class="o">*</span><span class="n">pipe</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pipe_buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">splice_desc</span> <span class="o">*</span><span class="n">sd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lo_read_data</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">loop_device</span> <span class="o">*</span><span class="n">lo</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">lo</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">IV</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">IV</span> <span class="o">=</span> <span class="p">((</span><span class="n">sector_t</span><span class="p">)</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SHIFT</span> <span class="o">-</span> <span class="mi">9</span><span class="p">))</span> <span class="o">+</span>
							<span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">&gt;&gt;</span> <span class="mi">9</span><span class="p">);</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">bsize</span><span class="p">)</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">bsize</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lo_do_transfer</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">READ</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">IV</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;loop: transfer error block %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>
		<span class="n">size</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">flush_dcache_page</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lo_direct_splice_actor</span><span class="p">(</span><span class="k">struct</span> <span class="n">pipe_inode_info</span> <span class="o">*</span><span class="n">pipe</span><span class="p">,</span> <span class="k">struct</span> <span class="n">splice_desc</span> <span class="o">*</span><span class="n">sd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__splice_from_pipe</span><span class="p">(</span><span class="n">pipe</span><span class="p">,</span> <span class="n">sd</span><span class="p">,</span> <span class="n">lo_splice_actor</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">do_lo_receive</span><span class="p">(</span><span class="k">struct</span> <span class="n">loop_device</span> <span class="o">*</span><span class="n">lo</span><span class="p">,</span>
	      <span class="k">struct</span> <span class="n">bio_vec</span> <span class="o">*</span><span class="n">bvec</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bsize</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lo_read_data</span> <span class="n">cookie</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">splice_desc</span> <span class="n">sd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">cookie</span><span class="p">.</span><span class="n">lo</span> <span class="o">=</span> <span class="n">lo</span><span class="p">;</span>
	<span class="n">cookie</span><span class="p">.</span><span class="n">page</span> <span class="o">=</span> <span class="n">bvec</span><span class="o">-&gt;</span><span class="n">bv_page</span><span class="p">;</span>
	<span class="n">cookie</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">bvec</span><span class="o">-&gt;</span><span class="n">bv_offset</span><span class="p">;</span>
	<span class="n">cookie</span><span class="p">.</span><span class="n">bsize</span> <span class="o">=</span> <span class="n">bsize</span><span class="p">;</span>

	<span class="n">sd</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sd</span><span class="p">.</span><span class="n">total_len</span> <span class="o">=</span> <span class="n">bvec</span><span class="o">-&gt;</span><span class="n">bv_len</span><span class="p">;</span>
	<span class="n">sd</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sd</span><span class="p">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">pos</span><span class="p">;</span>
	<span class="n">sd</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cookie</span><span class="p">;</span>

	<span class="n">file</span> <span class="o">=</span> <span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_backing_file</span><span class="p">;</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">splice_direct_to_actor</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sd</span><span class="p">,</span> <span class="n">lo_direct_splice_actor</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lo_receive</span><span class="p">(</span><span class="k">struct</span> <span class="n">loop_device</span> <span class="o">*</span><span class="n">lo</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bsize</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bio_vec</span> <span class="o">*</span><span class="n">bvec</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">s</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">bio_for_each_segment</span><span class="p">(</span><span class="n">bvec</span><span class="p">,</span> <span class="n">bio</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">s</span> <span class="o">=</span> <span class="n">do_lo_receive</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">bvec</span><span class="p">,</span> <span class="n">bsize</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">s</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">!=</span> <span class="n">bvec</span><span class="o">-&gt;</span><span class="n">bv_len</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">zero_fill_bio</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">pos</span> <span class="o">+=</span> <span class="n">bvec</span><span class="o">-&gt;</span><span class="n">bv_len</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_bio_filebacked</span><span class="p">(</span><span class="k">struct</span> <span class="n">loop_device</span> <span class="o">*</span><span class="n">lo</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">loff_t</span> <span class="n">pos</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">pos</span> <span class="o">=</span> <span class="p">((</span><span class="n">loff_t</span><span class="p">)</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_sector</span> <span class="o">&lt;&lt;</span> <span class="mi">9</span><span class="p">)</span> <span class="o">+</span> <span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_offset</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bio_rw</span><span class="p">(</span><span class="n">bio</span><span class="p">)</span> <span class="o">==</span> <span class="n">WRITE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span> <span class="o">=</span> <span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_backing_file</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_rw</span> <span class="o">&amp;</span> <span class="n">REQ_FLUSH</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">vfs_fsync</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * We use punch hole to reclaim the free space used by the</span>
<span class="cm">		 * image a.k.a. discard. However we do not support discard if</span>
<span class="cm">		 * encryption is enabled, because it may give an attacker</span>
<span class="cm">		 * useful information.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_rw</span> <span class="o">&amp;</span> <span class="n">REQ_DISCARD</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span> <span class="o">=</span> <span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_backing_file</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">mode</span> <span class="o">=</span> <span class="n">FALLOC_FL_PUNCH_HOLE</span> <span class="o">|</span> <span class="n">FALLOC_FL_KEEP_SIZE</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">fallocate</span><span class="p">)</span> <span class="o">||</span>
			    <span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_encrypt_key_size</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">fallocate</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span>
						    <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_size</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EINVAL</span> <span class="o">&amp;&amp;</span>
				     <span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">))</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">lo_send</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">bio</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_rw</span> <span class="o">&amp;</span> <span class="n">REQ_FUA</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">vfs_fsync</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">))</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">lo_receive</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">bio</span><span class="p">,</span> <span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_blocksize</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Add bio to back of pending list</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">loop_add_bio</span><span class="p">(</span><span class="k">struct</span> <span class="n">loop_device</span> <span class="o">*</span><span class="n">lo</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bio_list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_bio_list</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Grab first pending buffer</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="nf">loop_get_bio</span><span class="p">(</span><span class="k">struct</span> <span class="n">loop_device</span> <span class="o">*</span><span class="n">lo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bio_list_pop</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_bio_list</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">loop_make_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">old_bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">loop_device</span> <span class="o">*</span><span class="n">lo</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">queuedata</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rw</span> <span class="o">=</span> <span class="n">bio_rw</span><span class="p">(</span><span class="n">old_bio</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rw</span> <span class="o">==</span> <span class="n">READA</span><span class="p">)</span>
		<span class="n">rw</span> <span class="o">=</span> <span class="n">READ</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">lo</span> <span class="o">||</span> <span class="p">(</span><span class="n">rw</span> <span class="o">!=</span> <span class="n">READ</span> <span class="o">&amp;&amp;</span> <span class="n">rw</span> <span class="o">!=</span> <span class="n">WRITE</span><span class="p">));</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_state</span> <span class="o">!=</span> <span class="n">Lo_bound</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rw</span> <span class="o">==</span> <span class="n">WRITE</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_flags</span> <span class="o">&amp;</span> <span class="n">LO_FLAGS_READ_ONLY</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">loop_add_bio</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">old_bio</span><span class="p">);</span>
	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_event</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_lock</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_lock</span><span class="p">);</span>
	<span class="n">bio_io_error</span><span class="p">(</span><span class="n">old_bio</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">switch_request</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">completion</span> <span class="n">wait</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">do_loop_switch</span><span class="p">(</span><span class="k">struct</span> <span class="n">loop_device</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">switch_request</span> <span class="o">*</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">loop_handle_bio</span><span class="p">(</span><span class="k">struct</span> <span class="n">loop_device</span> <span class="o">*</span><span class="n">lo</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_bdev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">do_loop_switch</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_private</span><span class="p">);</span>
		<span class="n">bio_put</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">do_bio_filebacked</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
		<span class="n">bio_endio</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * worker thread that handles reads/writes to file backed loop devices,</span>
<span class="cm"> * to avoid blocking in our make_request_fn. it also does loop decrypting</span>
<span class="cm"> * on reads for block backed loop, as that is too heavy to do from</span>
<span class="cm"> * b_end_io context where irqs may be disabled.</span>
<span class="cm"> *</span>
<span class="cm"> * Loop explanation:  loop_clr_fd() sets lo_state to Lo_rundown before</span>
<span class="cm"> * calling kthread_stop().  Therefore once kthread_should_stop() is</span>
<span class="cm"> * true, make_request will not place any more requests.  Therefore</span>
<span class="cm"> * once kthread_should_stop() is true and lo_bio is NULL, we are</span>
<span class="cm"> * done with the loop.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">loop_thread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">loop_device</span> <span class="o">*</span><span class="n">lo</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">;</span>

	<span class="n">set_user_nice</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="o">-</span><span class="mi">20</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">kthread_should_stop</span><span class="p">()</span> <span class="o">||</span> <span class="o">!</span><span class="n">bio_list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_bio_list</span><span class="p">))</span> <span class="p">{</span>

		<span class="n">wait_event_interruptible</span><span class="p">(</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_event</span><span class="p">,</span>
				<span class="o">!</span><span class="n">bio_list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_bio_list</span><span class="p">)</span> <span class="o">||</span>
				<span class="n">kthread_should_stop</span><span class="p">());</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">bio_list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_bio_list</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_lock</span><span class="p">);</span>
		<span class="n">bio</span> <span class="o">=</span> <span class="n">loop_get_bio</span><span class="p">(</span><span class="n">lo</span><span class="p">);</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_lock</span><span class="p">);</span>

		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">bio</span><span class="p">);</span>
		<span class="n">loop_handle_bio</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * loop_switch performs the hard work of switching a backing store.</span>
<span class="cm"> * First it needs to flush existing IO, it does this by sending a magic</span>
<span class="cm"> * BIO down the pipe. The completion of this BIO does the actual switch.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">loop_switch</span><span class="p">(</span><span class="k">struct</span> <span class="n">loop_device</span> <span class="o">*</span><span class="n">lo</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">switch_request</span> <span class="n">w</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span> <span class="o">=</span> <span class="n">bio_alloc</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bio</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">w</span><span class="p">.</span><span class="n">wait</span><span class="p">);</span>
	<span class="n">w</span><span class="p">.</span><span class="n">file</span> <span class="o">=</span> <span class="n">file</span><span class="p">;</span>
	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_private</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">w</span><span class="p">;</span>
	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_bdev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">loop_make_request</span><span class="p">(</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_queue</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
	<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">w</span><span class="p">.</span><span class="n">wait</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Helper to flush the IOs in loop, but keeping loop thread running</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">loop_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">loop_device</span> <span class="o">*</span><span class="n">lo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* loop not yet configured, no running thread, nothing to flush */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_thread</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">loop_switch</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Do the actual switch; called from the BIO completion routine</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">do_loop_switch</span><span class="p">(</span><span class="k">struct</span> <span class="n">loop_device</span> <span class="o">*</span><span class="n">lo</span><span class="p">,</span> <span class="k">struct</span> <span class="n">switch_request</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">old_file</span> <span class="o">=</span> <span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_backing_file</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">;</span>

	<span class="cm">/* if no new file, only flush of queued bios requested */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">file</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">mapping</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="p">;</span>
	<span class="n">mapping_set_gfp_mask</span><span class="p">(</span><span class="n">old_file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="p">,</span> <span class="n">lo</span><span class="o">-&gt;</span><span class="n">old_gfp_mask</span><span class="p">);</span>
	<span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_backing_file</span> <span class="o">=</span> <span class="n">file</span><span class="p">;</span>
	<span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_blocksize</span> <span class="o">=</span> <span class="n">S_ISBLK</span><span class="p">(</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">?</span>
		<span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">i_bdev</span><span class="o">-&gt;</span><span class="n">bd_block_size</span> <span class="o">:</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
	<span class="n">lo</span><span class="o">-&gt;</span><span class="n">old_gfp_mask</span> <span class="o">=</span> <span class="n">mapping_gfp_mask</span><span class="p">(</span><span class="n">mapping</span><span class="p">);</span>
	<span class="n">mapping_set_gfp_mask</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">lo</span><span class="o">-&gt;</span><span class="n">old_gfp_mask</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">__GFP_IO</span><span class="o">|</span><span class="n">__GFP_FS</span><span class="p">));</span>
<span class="nl">out:</span>
	<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * loop_change_fd switched the backing store of a loopback device to</span>
<span class="cm"> * a new file. This is useful for operating system installers to free up</span>
<span class="cm"> * the original file and in High Availability environments to switch to</span>
<span class="cm"> * an alternative location for the content in case of server meltdown.</span>
<span class="cm"> * This can only work if the loop device is used read-only, and if the</span>
<span class="cm"> * new backing store is the same size and type as the old backing store.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">loop_change_fd</span><span class="p">(</span><span class="k">struct</span> <span class="n">loop_device</span> <span class="o">*</span><span class="n">lo</span><span class="p">,</span> <span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span>	<span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="o">*</span><span class="n">old_file</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span>	<span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_state</span> <span class="o">!=</span> <span class="n">Lo_bound</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* the loop device has to be read-only */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_flags</span> <span class="o">&amp;</span> <span class="n">LO_FLAGS_READ_ONLY</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>
	<span class="n">file</span> <span class="o">=</span> <span class="n">fget</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">file</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="n">old_file</span> <span class="o">=</span> <span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_backing_file</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">S_ISBLK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_putf</span><span class="p">;</span>

	<span class="cm">/* size of the new backing store needs to be the same */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">get_loop_size</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">file</span><span class="p">)</span> <span class="o">!=</span> <span class="n">get_loop_size</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">old_file</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_putf</span><span class="p">;</span>

	<span class="cm">/* and ... switch */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">loop_switch</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_putf</span><span class="p">;</span>

	<span class="n">fput</span><span class="p">(</span><span class="n">old_file</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_flags</span> <span class="o">&amp;</span> <span class="n">LO_FLAGS_PARTSCAN</span><span class="p">)</span>
		<span class="n">ioctl_by_bdev</span><span class="p">(</span><span class="n">bdev</span><span class="p">,</span> <span class="n">BLKRRPART</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">out_putf:</span>
	<span class="n">fput</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
 <span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_loop_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">i</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">i</span> <span class="o">&amp;&amp;</span> <span class="n">S_ISBLK</span><span class="p">(</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">MAJOR</span><span class="p">(</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">i_rdev</span><span class="p">)</span> <span class="o">==</span> <span class="n">LOOP_MAJOR</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* loop sysfs attributes */</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">loop_attr_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
			      <span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">callback</span><span class="p">)(</span><span class="k">struct</span> <span class="n">loop_device</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span> <span class="o">=</span> <span class="n">dev_to_disk</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">loop_device</span> <span class="o">*</span><span class="n">lo</span> <span class="o">=</span> <span class="n">disk</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">callback</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define LOOP_ATTR_RO(_name)						\</span>
<span class="cp">static ssize_t loop_attr_##_name##_show(struct loop_device *, char *);	\</span>
<span class="cp">static ssize_t loop_attr_do_show_##_name(struct device *d,		\</span>
<span class="cp">				struct device_attribute *attr, char *b)	\</span>
<span class="cp">{									\</span>
<span class="cp">	return loop_attr_show(d, b, loop_attr_##_name##_show);		\</span>
<span class="cp">}									\</span>
<span class="cp">static struct device_attribute loop_attr_##_name =			\</span>
<span class="cp">	__ATTR(_name, S_IRUGO, loop_attr_do_show_##_name, NULL);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">loop_attr_backing_file_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">loop_device</span> <span class="o">*</span><span class="n">lo</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">ssize_t</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_backing_file</span><span class="p">)</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">d_path</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_backing_file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR_OR_NULL</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="n">memmove</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="n">buf</span><span class="p">[</span><span class="n">ret</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
		<span class="n">buf</span><span class="p">[</span><span class="n">ret</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">loop_attr_offset_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">loop_device</span> <span class="o">*</span><span class="n">lo</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_offset</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">loop_attr_sizelimit_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">loop_device</span> <span class="o">*</span><span class="n">lo</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_sizelimit</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">loop_attr_autoclear_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">loop_device</span> <span class="o">*</span><span class="n">lo</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">autoclear</span> <span class="o">=</span> <span class="p">(</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_flags</span> <span class="o">&amp;</span> <span class="n">LO_FLAGS_AUTOCLEAR</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">autoclear</span> <span class="o">?</span> <span class="s">&quot;1&quot;</span> <span class="o">:</span> <span class="s">&quot;0&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">loop_attr_partscan_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">loop_device</span> <span class="o">*</span><span class="n">lo</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">partscan</span> <span class="o">=</span> <span class="p">(</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_flags</span> <span class="o">&amp;</span> <span class="n">LO_FLAGS_PARTSCAN</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">partscan</span> <span class="o">?</span> <span class="s">&quot;1&quot;</span> <span class="o">:</span> <span class="s">&quot;0&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">LOOP_ATTR_RO</span><span class="p">(</span><span class="n">backing_file</span><span class="p">);</span>
<span class="n">LOOP_ATTR_RO</span><span class="p">(</span><span class="n">offset</span><span class="p">);</span>
<span class="n">LOOP_ATTR_RO</span><span class="p">(</span><span class="n">sizelimit</span><span class="p">);</span>
<span class="n">LOOP_ATTR_RO</span><span class="p">(</span><span class="n">autoclear</span><span class="p">);</span>
<span class="n">LOOP_ATTR_RO</span><span class="p">(</span><span class="n">partscan</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="n">loop_attrs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="o">&amp;</span><span class="n">loop_attr_backing_file</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">loop_attr_offset</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">loop_attr_sizelimit</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">loop_attr_autoclear</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">loop_attr_partscan</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="nb">NULL</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">attribute_group</span> <span class="n">loop_attribute_group</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;loop&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">attrs</span><span class="o">=</span> <span class="n">loop_attrs</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">loop_sysfs_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">loop_device</span> <span class="o">*</span><span class="n">lo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sysfs_create_group</span><span class="p">(</span><span class="o">&amp;</span><span class="n">disk_to_dev</span><span class="p">(</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_disk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span>
				  <span class="o">&amp;</span><span class="n">loop_attribute_group</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">loop_sysfs_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">loop_device</span> <span class="o">*</span><span class="n">lo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sysfs_remove_group</span><span class="p">(</span><span class="o">&amp;</span><span class="n">disk_to_dev</span><span class="p">(</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_disk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span>
			   <span class="o">&amp;</span><span class="n">loop_attribute_group</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">loop_config_discard</span><span class="p">(</span><span class="k">struct</span> <span class="n">loop_device</span> <span class="o">*</span><span class="n">lo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span> <span class="o">=</span> <span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_backing_file</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_queue</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We use punch hole to reclaim the free space used by the</span>
<span class="cm">	 * image a.k.a. discard. However we do support discard if</span>
<span class="cm">	 * encryption is enabled, because it may give an attacker</span>
<span class="cm">	 * useful information.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">fallocate</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_encrypt_key_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">limits</span><span class="p">.</span><span class="n">discard_granularity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">limits</span><span class="p">.</span><span class="n">discard_alignment</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">limits</span><span class="p">.</span><span class="n">max_discard_sectors</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">limits</span><span class="p">.</span><span class="n">discard_zeroes_data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">queue_flag_clear_unlocked</span><span class="p">(</span><span class="n">QUEUE_FLAG_DISCARD</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">q</span><span class="o">-&gt;</span><span class="n">limits</span><span class="p">.</span><span class="n">discard_granularity</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">;</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">limits</span><span class="p">.</span><span class="n">discard_alignment</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">limits</span><span class="p">.</span><span class="n">max_discard_sectors</span> <span class="o">=</span> <span class="n">UINT_MAX</span> <span class="o">&gt;&gt;</span> <span class="mi">9</span><span class="p">;</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">limits</span><span class="p">.</span><span class="n">discard_zeroes_data</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">queue_flag_set_unlocked</span><span class="p">(</span><span class="n">QUEUE_FLAG_DISCARD</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">loop_set_fd</span><span class="p">(</span><span class="k">struct</span> <span class="n">loop_device</span> <span class="o">*</span><span class="n">lo</span><span class="p">,</span> <span class="n">fmode_t</span> <span class="n">mode</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span>	<span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="o">*</span><span class="n">f</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span>	<span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">lo_blocksize</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">lo_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>
	<span class="n">loff_t</span>		<span class="n">size</span><span class="p">;</span>

	<span class="cm">/* This is safe, since we have a reference from open(). */</span>
	<span class="n">__module_get</span><span class="p">(</span><span class="n">THIS_MODULE</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>
	<span class="n">file</span> <span class="o">=</span> <span class="n">fget</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">file</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_state</span> <span class="o">!=</span> <span class="n">Lo_unbound</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_putf</span><span class="p">;</span>

	<span class="cm">/* Avoid recursion */</span>
	<span class="n">f</span> <span class="o">=</span> <span class="n">file</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">is_loop_device</span><span class="p">(</span><span class="n">f</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">loop_device</span> <span class="o">*</span><span class="n">l</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">i_bdev</span> <span class="o">==</span> <span class="n">bdev</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_putf</span><span class="p">;</span>

		<span class="n">l</span> <span class="o">=</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">i_bdev</span><span class="o">-&gt;</span><span class="n">bd_disk</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">lo_state</span> <span class="o">==</span> <span class="n">Lo_unbound</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_putf</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">f</span> <span class="o">=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">lo_backing_file</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mapping</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="p">;</span>
	<span class="n">inode</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">S_ISBLK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_putf</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_WRITE</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">FMODE_WRITE</span><span class="p">)</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">)</span>
		<span class="n">lo_flags</span> <span class="o">|=</span> <span class="n">LO_FLAGS_READ_ONLY</span><span class="p">;</span>

	<span class="n">lo_blocksize</span> <span class="o">=</span> <span class="n">S_ISBLK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">?</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_bdev</span><span class="o">-&gt;</span><span class="n">bd_block_size</span> <span class="o">:</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFBIG</span><span class="p">;</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">get_loop_size</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">loff_t</span><span class="p">)(</span><span class="n">sector_t</span><span class="p">)</span><span class="n">size</span> <span class="o">!=</span> <span class="n">size</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_putf</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">set_device_ro</span><span class="p">(</span><span class="n">bdev</span><span class="p">,</span> <span class="p">(</span><span class="n">lo_flags</span> <span class="o">&amp;</span> <span class="n">LO_FLAGS_READ_ONLY</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_blocksize</span> <span class="o">=</span> <span class="n">lo_blocksize</span><span class="p">;</span>
	<span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_device</span> <span class="o">=</span> <span class="n">bdev</span><span class="p">;</span>
	<span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_flags</span> <span class="o">=</span> <span class="n">lo_flags</span><span class="p">;</span>
	<span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_backing_file</span> <span class="o">=</span> <span class="n">file</span><span class="p">;</span>
	<span class="n">lo</span><span class="o">-&gt;</span><span class="n">transfer</span> <span class="o">=</span> <span class="n">transfer_none</span><span class="p">;</span>
	<span class="n">lo</span><span class="o">-&gt;</span><span class="n">ioctl</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_sizelimit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">lo</span><span class="o">-&gt;</span><span class="n">old_gfp_mask</span> <span class="o">=</span> <span class="n">mapping_gfp_mask</span><span class="p">(</span><span class="n">mapping</span><span class="p">);</span>
	<span class="n">mapping_set_gfp_mask</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">lo</span><span class="o">-&gt;</span><span class="n">old_gfp_mask</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">__GFP_IO</span><span class="o">|</span><span class="n">__GFP_FS</span><span class="p">));</span>

	<span class="n">bio_list_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_bio_list</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * set queue make_request_fn, and add limits based on lower level</span>
<span class="cm">	 * device</span>
<span class="cm">	 */</span>
	<span class="n">blk_queue_make_request</span><span class="p">(</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_queue</span><span class="p">,</span> <span class="n">loop_make_request</span><span class="p">);</span>
	<span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_queue</span><span class="o">-&gt;</span><span class="n">queuedata</span> <span class="o">=</span> <span class="n">lo</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">lo_flags</span> <span class="o">&amp;</span> <span class="n">LO_FLAGS_READ_ONLY</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">fsync</span><span class="p">)</span>
		<span class="n">blk_queue_flush</span><span class="p">(</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_queue</span><span class="p">,</span> <span class="n">REQ_FLUSH</span><span class="p">);</span>

	<span class="n">set_capacity</span><span class="p">(</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_disk</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">bd_set_size</span><span class="p">(</span><span class="n">bdev</span><span class="p">,</span> <span class="n">size</span> <span class="o">&lt;&lt;</span> <span class="mi">9</span><span class="p">);</span>
	<span class="n">loop_sysfs_init</span><span class="p">(</span><span class="n">lo</span><span class="p">);</span>
	<span class="cm">/* let user-space know about the new size */</span>
	<span class="n">kobject_uevent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">disk_to_dev</span><span class="p">(</span><span class="n">bdev</span><span class="o">-&gt;</span><span class="n">bd_disk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="n">KOBJ_CHANGE</span><span class="p">);</span>

	<span class="n">set_blocksize</span><span class="p">(</span><span class="n">bdev</span><span class="p">,</span> <span class="n">lo_blocksize</span><span class="p">);</span>

	<span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_thread</span> <span class="o">=</span> <span class="n">kthread_create</span><span class="p">(</span><span class="n">loop_thread</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="s">&quot;loop%d&quot;</span><span class="p">,</span>
						<span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_number</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_thread</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_thread</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_clr</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_state</span> <span class="o">=</span> <span class="n">Lo_bound</span><span class="p">;</span>
	<span class="n">wake_up_process</span><span class="p">(</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_thread</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">part_shift</span><span class="p">)</span>
		<span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_flags</span> <span class="o">|=</span> <span class="n">LO_FLAGS_PARTSCAN</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_flags</span> <span class="o">&amp;</span> <span class="n">LO_FLAGS_PARTSCAN</span><span class="p">)</span>
		<span class="n">ioctl_by_bdev</span><span class="p">(</span><span class="n">bdev</span><span class="p">,</span> <span class="n">BLKRRPART</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_clr:</span>
	<span class="n">loop_sysfs_exit</span><span class="p">(</span><span class="n">lo</span><span class="p">);</span>
	<span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_thread</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_device</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_backing_file</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">set_capacity</span><span class="p">(</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_disk</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">invalidate_bdev</span><span class="p">(</span><span class="n">bdev</span><span class="p">);</span>
	<span class="n">bd_set_size</span><span class="p">(</span><span class="n">bdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">kobject_uevent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">disk_to_dev</span><span class="p">(</span><span class="n">bdev</span><span class="o">-&gt;</span><span class="n">bd_disk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="n">KOBJ_CHANGE</span><span class="p">);</span>
	<span class="n">mapping_set_gfp_mask</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">lo</span><span class="o">-&gt;</span><span class="n">old_gfp_mask</span><span class="p">);</span>
	<span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_state</span> <span class="o">=</span> <span class="n">Lo_unbound</span><span class="p">;</span>
 <span class="nl">out_putf:</span>
	<span class="n">fput</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
 <span class="nl">out:</span>
	<span class="cm">/* This is safe: open() is still holding a reference. */</span>
	<span class="n">module_put</span><span class="p">(</span><span class="n">THIS_MODULE</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">loop_release_xfer</span><span class="p">(</span><span class="k">struct</span> <span class="n">loop_device</span> <span class="o">*</span><span class="n">lo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">loop_func_table</span> <span class="o">*</span><span class="n">xfer</span> <span class="o">=</span> <span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_encryption</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">xfer</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">release</span><span class="p">)</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">release</span><span class="p">(</span><span class="n">lo</span><span class="p">);</span>
		<span class="n">lo</span><span class="o">-&gt;</span><span class="n">transfer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_encryption</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">module_put</span><span class="p">(</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">loop_init_xfer</span><span class="p">(</span><span class="k">struct</span> <span class="n">loop_device</span> <span class="o">*</span><span class="n">lo</span><span class="p">,</span> <span class="k">struct</span> <span class="n">loop_func_table</span> <span class="o">*</span><span class="n">xfer</span><span class="p">,</span>
	       <span class="k">const</span> <span class="k">struct</span> <span class="n">loop_info64</span> <span class="o">*</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">xfer</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">owner</span> <span class="o">=</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">try_module_get</span><span class="p">(</span><span class="n">owner</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">)</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="n">module_put</span><span class="p">(</span><span class="n">owner</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_encryption</span> <span class="o">=</span> <span class="n">xfer</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">loop_clr_fd</span><span class="p">(</span><span class="k">struct</span> <span class="n">loop_device</span> <span class="o">*</span><span class="n">lo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span> <span class="o">=</span> <span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_backing_file</span><span class="p">;</span>
	<span class="n">gfp_t</span> <span class="n">gfp</span> <span class="o">=</span> <span class="n">lo</span><span class="o">-&gt;</span><span class="n">old_gfp_mask</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span> <span class="o">=</span> <span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_device</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_state</span> <span class="o">!=</span> <span class="n">Lo_bound</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_refcnt</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>	<span class="cm">/* we needed one fd for the ioctl */</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">filp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_lock</span><span class="p">);</span>
	<span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_state</span> <span class="o">=</span> <span class="n">Lo_rundown</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_lock</span><span class="p">);</span>

	<span class="n">kthread_stop</span><span class="p">(</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_thread</span><span class="p">);</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_lock</span><span class="p">);</span>
	<span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_backing_file</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_lock</span><span class="p">);</span>

	<span class="n">loop_release_xfer</span><span class="p">(</span><span class="n">lo</span><span class="p">);</span>
	<span class="n">lo</span><span class="o">-&gt;</span><span class="n">transfer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">lo</span><span class="o">-&gt;</span><span class="n">ioctl</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_device</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_encryption</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_sizelimit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_encrypt_key_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_thread</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_encrypt_key</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">LO_KEY_SIZE</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_crypt_name</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">LO_NAME_SIZE</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_file_name</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">LO_NAME_SIZE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bdev</span><span class="p">)</span>
		<span class="n">invalidate_bdev</span><span class="p">(</span><span class="n">bdev</span><span class="p">);</span>
	<span class="n">set_capacity</span><span class="p">(</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_disk</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">loop_sysfs_exit</span><span class="p">(</span><span class="n">lo</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bdev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bd_set_size</span><span class="p">(</span><span class="n">bdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="cm">/* let user-space know about this change */</span>
		<span class="n">kobject_uevent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">disk_to_dev</span><span class="p">(</span><span class="n">bdev</span><span class="o">-&gt;</span><span class="n">bd_disk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="n">KOBJ_CHANGE</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mapping_set_gfp_mask</span><span class="p">(</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>
	<span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_state</span> <span class="o">=</span> <span class="n">Lo_unbound</span><span class="p">;</span>
	<span class="cm">/* This is safe: open() is still holding a reference. */</span>
	<span class="n">module_put</span><span class="p">(</span><span class="n">THIS_MODULE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_flags</span> <span class="o">&amp;</span> <span class="n">LO_FLAGS_PARTSCAN</span> <span class="o">&amp;&amp;</span> <span class="n">bdev</span><span class="p">)</span>
		<span class="n">ioctl_by_bdev</span><span class="p">(</span><span class="n">bdev</span><span class="p">,</span> <span class="n">BLKRRPART</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">part_shift</span><span class="p">)</span>
		<span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_disk</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">GENHD_FL_NO_PART_SCAN</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_ctl_mutex</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Need not hold lo_ctl_mutex to fput backing file.</span>
<span class="cm">	 * Calling fput holding lo_ctl_mutex triggers a circular</span>
<span class="cm">	 * lock dependency possibility warning as fput can take</span>
<span class="cm">	 * bd_mutex which is usually taken before lo_ctl_mutex.</span>
<span class="cm">	 */</span>
	<span class="n">fput</span><span class="p">(</span><span class="n">filp</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">loop_set_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">loop_device</span> <span class="o">*</span><span class="n">lo</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">loop_info64</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">loop_func_table</span> <span class="o">*</span><span class="n">xfer</span><span class="p">;</span>
	<span class="n">uid_t</span> <span class="n">uid</span> <span class="o">=</span> <span class="n">current_uid</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_encrypt_key_size</span> <span class="o">&amp;&amp;</span>
	    <span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_key_owner</span> <span class="o">!=</span> <span class="n">uid</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_state</span> <span class="o">!=</span> <span class="n">Lo_bound</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">lo_encrypt_key_size</span> <span class="o">&gt;</span> <span class="n">LO_KEY_SIZE</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">loop_release_xfer</span><span class="p">(</span><span class="n">lo</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">lo_encrypt_type</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">type</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">lo_encrypt_type</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&gt;=</span> <span class="n">MAX_LO_CRYPT</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">xfer</span> <span class="o">=</span> <span class="n">xfer_funcs</span><span class="p">[</span><span class="n">type</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xfer</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">xfer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">loop_init_xfer</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">xfer</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_offset</span> <span class="o">!=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">lo_offset</span> <span class="o">||</span>
	    <span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_sizelimit</span> <span class="o">!=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">lo_sizelimit</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">figure_loop_size</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">lo_offset</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">lo_sizelimit</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFBIG</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">loop_config_discard</span><span class="p">(</span><span class="n">lo</span><span class="p">);</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_file_name</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">lo_file_name</span><span class="p">,</span> <span class="n">LO_NAME_SIZE</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_crypt_name</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">lo_crypt_name</span><span class="p">,</span> <span class="n">LO_NAME_SIZE</span><span class="p">);</span>
	<span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_file_name</span><span class="p">[</span><span class="n">LO_NAME_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_crypt_name</span><span class="p">[</span><span class="n">LO_NAME_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xfer</span><span class="p">)</span>
		<span class="n">xfer</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">none_funcs</span><span class="p">;</span>
	<span class="n">lo</span><span class="o">-&gt;</span><span class="n">transfer</span> <span class="o">=</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">transfer</span><span class="p">;</span>
	<span class="n">lo</span><span class="o">-&gt;</span><span class="n">ioctl</span> <span class="o">=</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">ioctl</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_flags</span> <span class="o">&amp;</span> <span class="n">LO_FLAGS_AUTOCLEAR</span><span class="p">)</span> <span class="o">!=</span>
	     <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">lo_flags</span> <span class="o">&amp;</span> <span class="n">LO_FLAGS_AUTOCLEAR</span><span class="p">))</span>
		<span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_flags</span> <span class="o">^=</span> <span class="n">LO_FLAGS_AUTOCLEAR</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">lo_flags</span> <span class="o">&amp;</span> <span class="n">LO_FLAGS_PARTSCAN</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	     <span class="o">!</span><span class="p">(</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_flags</span> <span class="o">&amp;</span> <span class="n">LO_FLAGS_PARTSCAN</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_flags</span> <span class="o">|=</span> <span class="n">LO_FLAGS_PARTSCAN</span><span class="p">;</span>
		<span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_disk</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">GENHD_FL_NO_PART_SCAN</span><span class="p">;</span>
		<span class="n">ioctl_by_bdev</span><span class="p">(</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_device</span><span class="p">,</span> <span class="n">BLKRRPART</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_encrypt_key_size</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">lo_encrypt_key_size</span><span class="p">;</span>
	<span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_init</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">lo_init</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_init</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">lo_init</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">lo_encrypt_key_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_encrypt_key</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">lo_encrypt_key</span><span class="p">,</span>
		       <span class="n">info</span><span class="o">-&gt;</span><span class="n">lo_encrypt_key_size</span><span class="p">);</span>
		<span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_key_owner</span> <span class="o">=</span> <span class="n">uid</span><span class="p">;</span>
	<span class="p">}</span>	

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">loop_get_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">loop_device</span> <span class="o">*</span><span class="n">lo</span><span class="p">,</span> <span class="k">struct</span> <span class="n">loop_info64</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span> <span class="o">=</span> <span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_backing_file</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kstat</span> <span class="n">stat</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_state</span> <span class="o">!=</span> <span class="n">Lo_bound</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">vfs_getattr</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">mnt</span><span class="p">,</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stat</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">info</span><span class="p">));</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">lo_number</span> <span class="o">=</span> <span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_number</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">lo_device</span> <span class="o">=</span> <span class="n">huge_encode_dev</span><span class="p">(</span><span class="n">stat</span><span class="p">.</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">lo_inode</span> <span class="o">=</span> <span class="n">stat</span><span class="p">.</span><span class="n">ino</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">lo_rdevice</span> <span class="o">=</span> <span class="n">huge_encode_dev</span><span class="p">(</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_device</span> <span class="o">?</span> <span class="n">stat</span><span class="p">.</span><span class="n">rdev</span> <span class="o">:</span> <span class="n">stat</span><span class="p">.</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">lo_offset</span> <span class="o">=</span> <span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_offset</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">lo_sizelimit</span> <span class="o">=</span> <span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_sizelimit</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">lo_flags</span> <span class="o">=</span> <span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_flags</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">lo_file_name</span><span class="p">,</span> <span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_file_name</span><span class="p">,</span> <span class="n">LO_NAME_SIZE</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">lo_crypt_name</span><span class="p">,</span> <span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_crypt_name</span><span class="p">,</span> <span class="n">LO_NAME_SIZE</span><span class="p">);</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">lo_encrypt_type</span> <span class="o">=</span>
		<span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_encryption</span> <span class="o">?</span> <span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_encryption</span><span class="o">-&gt;</span><span class="n">number</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_encrypt_key_size</span> <span class="o">&amp;&amp;</span> <span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">lo_encrypt_key_size</span> <span class="o">=</span> <span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_encrypt_key_size</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">lo_encrypt_key</span><span class="p">,</span> <span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_encrypt_key</span><span class="p">,</span>
		       <span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_encrypt_key_size</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">loop_info64_from_old</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">loop_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="k">struct</span> <span class="n">loop_info64</span> <span class="o">*</span><span class="n">info64</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">info64</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">info64</span><span class="p">));</span>
	<span class="n">info64</span><span class="o">-&gt;</span><span class="n">lo_number</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">lo_number</span><span class="p">;</span>
	<span class="n">info64</span><span class="o">-&gt;</span><span class="n">lo_device</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">lo_device</span><span class="p">;</span>
	<span class="n">info64</span><span class="o">-&gt;</span><span class="n">lo_inode</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">lo_inode</span><span class="p">;</span>
	<span class="n">info64</span><span class="o">-&gt;</span><span class="n">lo_rdevice</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">lo_rdevice</span><span class="p">;</span>
	<span class="n">info64</span><span class="o">-&gt;</span><span class="n">lo_offset</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">lo_offset</span><span class="p">;</span>
	<span class="n">info64</span><span class="o">-&gt;</span><span class="n">lo_sizelimit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">info64</span><span class="o">-&gt;</span><span class="n">lo_encrypt_type</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">lo_encrypt_type</span><span class="p">;</span>
	<span class="n">info64</span><span class="o">-&gt;</span><span class="n">lo_encrypt_key_size</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">lo_encrypt_key_size</span><span class="p">;</span>
	<span class="n">info64</span><span class="o">-&gt;</span><span class="n">lo_flags</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">lo_flags</span><span class="p">;</span>
	<span class="n">info64</span><span class="o">-&gt;</span><span class="n">lo_init</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">lo_init</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">info64</span><span class="o">-&gt;</span><span class="n">lo_init</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">lo_init</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">lo_encrypt_type</span> <span class="o">==</span> <span class="n">LO_CRYPT_CRYPTOAPI</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">info64</span><span class="o">-&gt;</span><span class="n">lo_crypt_name</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">lo_name</span><span class="p">,</span> <span class="n">LO_NAME_SIZE</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">info64</span><span class="o">-&gt;</span><span class="n">lo_file_name</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">lo_name</span><span class="p">,</span> <span class="n">LO_NAME_SIZE</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">info64</span><span class="o">-&gt;</span><span class="n">lo_encrypt_key</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">lo_encrypt_key</span><span class="p">,</span> <span class="n">LO_KEY_SIZE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">loop_info64_to_old</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">loop_info64</span> <span class="o">*</span><span class="n">info64</span><span class="p">,</span> <span class="k">struct</span> <span class="n">loop_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">info</span><span class="p">));</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">lo_number</span> <span class="o">=</span> <span class="n">info64</span><span class="o">-&gt;</span><span class="n">lo_number</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">lo_device</span> <span class="o">=</span> <span class="n">info64</span><span class="o">-&gt;</span><span class="n">lo_device</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">lo_inode</span> <span class="o">=</span> <span class="n">info64</span><span class="o">-&gt;</span><span class="n">lo_inode</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">lo_rdevice</span> <span class="o">=</span> <span class="n">info64</span><span class="o">-&gt;</span><span class="n">lo_rdevice</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">lo_offset</span> <span class="o">=</span> <span class="n">info64</span><span class="o">-&gt;</span><span class="n">lo_offset</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">lo_encrypt_type</span> <span class="o">=</span> <span class="n">info64</span><span class="o">-&gt;</span><span class="n">lo_encrypt_type</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">lo_encrypt_key_size</span> <span class="o">=</span> <span class="n">info64</span><span class="o">-&gt;</span><span class="n">lo_encrypt_key_size</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">lo_flags</span> <span class="o">=</span> <span class="n">info64</span><span class="o">-&gt;</span><span class="n">lo_flags</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">lo_init</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">info64</span><span class="o">-&gt;</span><span class="n">lo_init</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">lo_init</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">info64</span><span class="o">-&gt;</span><span class="n">lo_init</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">lo_encrypt_type</span> <span class="o">==</span> <span class="n">LO_CRYPT_CRYPTOAPI</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">lo_name</span><span class="p">,</span> <span class="n">info64</span><span class="o">-&gt;</span><span class="n">lo_crypt_name</span><span class="p">,</span> <span class="n">LO_NAME_SIZE</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">lo_name</span><span class="p">,</span> <span class="n">info64</span><span class="o">-&gt;</span><span class="n">lo_file_name</span><span class="p">,</span> <span class="n">LO_NAME_SIZE</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">lo_encrypt_key</span><span class="p">,</span> <span class="n">info64</span><span class="o">-&gt;</span><span class="n">lo_encrypt_key</span><span class="p">,</span> <span class="n">LO_KEY_SIZE</span><span class="p">);</span>

	<span class="cm">/* error in case values were truncated */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">lo_device</span> <span class="o">!=</span> <span class="n">info64</span><span class="o">-&gt;</span><span class="n">lo_device</span> <span class="o">||</span>
	    <span class="n">info</span><span class="o">-&gt;</span><span class="n">lo_rdevice</span> <span class="o">!=</span> <span class="n">info64</span><span class="o">-&gt;</span><span class="n">lo_rdevice</span> <span class="o">||</span>
	    <span class="n">info</span><span class="o">-&gt;</span><span class="n">lo_inode</span> <span class="o">!=</span> <span class="n">info64</span><span class="o">-&gt;</span><span class="n">lo_inode</span> <span class="o">||</span>
	    <span class="n">info</span><span class="o">-&gt;</span><span class="n">lo_offset</span> <span class="o">!=</span> <span class="n">info64</span><span class="o">-&gt;</span><span class="n">lo_offset</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOVERFLOW</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">loop_set_status_old</span><span class="p">(</span><span class="k">struct</span> <span class="n">loop_device</span> <span class="o">*</span><span class="n">lo</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">loop_info</span> <span class="n">__user</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">loop_info</span> <span class="n">info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">loop_info64</span> <span class="n">info64</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">loop_info</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="n">loop_info64_from_old</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info64</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">loop_set_status</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info64</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">loop_set_status64</span><span class="p">(</span><span class="k">struct</span> <span class="n">loop_device</span> <span class="o">*</span><span class="n">lo</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">loop_info64</span> <span class="n">__user</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">loop_info64</span> <span class="n">info64</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info64</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">loop_info64</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">loop_set_status</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info64</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">loop_get_status_old</span><span class="p">(</span><span class="k">struct</span> <span class="n">loop_device</span> <span class="o">*</span><span class="n">lo</span><span class="p">,</span> <span class="k">struct</span> <span class="n">loop_info</span> <span class="n">__user</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">loop_info</span> <span class="n">info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">loop_info64</span> <span class="n">info64</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">arg</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">loop_get_status</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info64</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">loop_info64_to_old</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info64</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span> <span class="o">&amp;&amp;</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">info</span><span class="p">)))</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">loop_get_status64</span><span class="p">(</span><span class="k">struct</span> <span class="n">loop_device</span> <span class="o">*</span><span class="n">lo</span><span class="p">,</span> <span class="k">struct</span> <span class="n">loop_info64</span> <span class="n">__user</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">loop_info64</span> <span class="n">info64</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">arg</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">loop_get_status</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info64</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span> <span class="o">&amp;&amp;</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info64</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">info64</span><span class="p">)))</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">loop_set_capacity</span><span class="p">(</span><span class="k">struct</span> <span class="n">loop_device</span> <span class="o">*</span><span class="n">lo</span><span class="p">,</span> <span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">sec</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">sz</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_state</span> <span class="o">!=</span> <span class="n">Lo_bound</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">figure_loop_size</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_offset</span><span class="p">,</span> <span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_sizelimit</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">sec</span> <span class="o">=</span> <span class="n">get_capacity</span><span class="p">(</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_disk</span><span class="p">);</span>
	<span class="cm">/* the width of sector_t may be narrow for bit-shift */</span>
	<span class="n">sz</span> <span class="o">=</span> <span class="n">sec</span><span class="p">;</span>
	<span class="n">sz</span> <span class="o">&lt;&lt;=</span> <span class="mi">9</span><span class="p">;</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdev</span><span class="o">-&gt;</span><span class="n">bd_mutex</span><span class="p">);</span>
	<span class="n">bd_set_size</span><span class="p">(</span><span class="n">bdev</span><span class="p">,</span> <span class="n">sz</span><span class="p">);</span>
	<span class="cm">/* let user-space know about the new size */</span>
	<span class="n">kobject_uevent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">disk_to_dev</span><span class="p">(</span><span class="n">bdev</span><span class="o">-&gt;</span><span class="n">bd_disk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="n">KOBJ_CHANGE</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdev</span><span class="o">-&gt;</span><span class="n">bd_mutex</span><span class="p">);</span>

 <span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">lo_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span> <span class="n">fmode_t</span> <span class="n">mode</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">loop_device</span> <span class="o">*</span><span class="n">lo</span> <span class="o">=</span> <span class="n">bdev</span><span class="o">-&gt;</span><span class="n">bd_disk</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">mutex_lock_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_ctl_mutex</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">LOOP_SET_FD</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">loop_set_fd</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">bdev</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LOOP_CHANGE_FD</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">loop_change_fd</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">bdev</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LOOP_CLR_FD</span>:
		<span class="cm">/* loop_clr_fd would have unlocked lo_ctl_mutex on success */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">loop_clr_fd</span><span class="p">(</span><span class="n">lo</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_unlocked</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LOOP_SET_STATUS</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">FMODE_WRITE</span><span class="p">)</span> <span class="o">||</span> <span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">loop_set_status_old</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span>
					<span class="p">(</span><span class="k">struct</span> <span class="n">loop_info</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LOOP_GET_STATUS</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">loop_get_status_old</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">loop_info</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LOOP_SET_STATUS64</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">FMODE_WRITE</span><span class="p">)</span> <span class="o">||</span> <span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">loop_set_status64</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span>
					<span class="p">(</span><span class="k">struct</span> <span class="n">loop_info64</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LOOP_GET_STATUS64</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">loop_get_status64</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">loop_info64</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LOOP_SET_CAPACITY</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">FMODE_WRITE</span><span class="p">)</span> <span class="o">||</span> <span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">loop_set_capacity</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">bdev</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">lo</span><span class="o">-&gt;</span><span class="n">ioctl</span> <span class="o">?</span> <span class="n">lo</span><span class="o">-&gt;</span><span class="n">ioctl</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span> <span class="o">:</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_ctl_mutex</span><span class="p">);</span>

<span class="nl">out_unlocked:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_COMPAT</span>
<span class="k">struct</span> <span class="n">compat_loop_info</span> <span class="p">{</span>
	<span class="n">compat_int_t</span>	<span class="n">lo_number</span><span class="p">;</span>      <span class="cm">/* ioctl r/o */</span>
	<span class="n">compat_dev_t</span>	<span class="n">lo_device</span><span class="p">;</span>      <span class="cm">/* ioctl r/o */</span>
	<span class="n">compat_ulong_t</span>	<span class="n">lo_inode</span><span class="p">;</span>       <span class="cm">/* ioctl r/o */</span>
	<span class="n">compat_dev_t</span>	<span class="n">lo_rdevice</span><span class="p">;</span>     <span class="cm">/* ioctl r/o */</span>
	<span class="n">compat_int_t</span>	<span class="n">lo_offset</span><span class="p">;</span>
	<span class="n">compat_int_t</span>	<span class="n">lo_encrypt_type</span><span class="p">;</span>
	<span class="n">compat_int_t</span>	<span class="n">lo_encrypt_key_size</span><span class="p">;</span>    <span class="cm">/* ioctl w/o */</span>
	<span class="n">compat_int_t</span>	<span class="n">lo_flags</span><span class="p">;</span>       <span class="cm">/* ioctl r/o */</span>
	<span class="kt">char</span>		<span class="n">lo_name</span><span class="p">[</span><span class="n">LO_NAME_SIZE</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">lo_encrypt_key</span><span class="p">[</span><span class="n">LO_KEY_SIZE</span><span class="p">];</span> <span class="cm">/* ioctl w/o */</span>
	<span class="n">compat_ulong_t</span>	<span class="n">lo_init</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="kt">char</span>		<span class="n">reserved</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Transfer 32-bit compatibility structure in userspace to 64-bit loop info</span>
<span class="cm"> * - noinlined to reduce stack space usage in main part of driver</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span>
<span class="nf">loop_info64_from_compat</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">compat_loop_info</span> <span class="n">__user</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">loop_info64</span> <span class="o">*</span><span class="n">info64</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">compat_loop_info</span> <span class="n">info</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">info</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">info64</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">info64</span><span class="p">));</span>
	<span class="n">info64</span><span class="o">-&gt;</span><span class="n">lo_number</span> <span class="o">=</span> <span class="n">info</span><span class="p">.</span><span class="n">lo_number</span><span class="p">;</span>
	<span class="n">info64</span><span class="o">-&gt;</span><span class="n">lo_device</span> <span class="o">=</span> <span class="n">info</span><span class="p">.</span><span class="n">lo_device</span><span class="p">;</span>
	<span class="n">info64</span><span class="o">-&gt;</span><span class="n">lo_inode</span> <span class="o">=</span> <span class="n">info</span><span class="p">.</span><span class="n">lo_inode</span><span class="p">;</span>
	<span class="n">info64</span><span class="o">-&gt;</span><span class="n">lo_rdevice</span> <span class="o">=</span> <span class="n">info</span><span class="p">.</span><span class="n">lo_rdevice</span><span class="p">;</span>
	<span class="n">info64</span><span class="o">-&gt;</span><span class="n">lo_offset</span> <span class="o">=</span> <span class="n">info</span><span class="p">.</span><span class="n">lo_offset</span><span class="p">;</span>
	<span class="n">info64</span><span class="o">-&gt;</span><span class="n">lo_sizelimit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">info64</span><span class="o">-&gt;</span><span class="n">lo_encrypt_type</span> <span class="o">=</span> <span class="n">info</span><span class="p">.</span><span class="n">lo_encrypt_type</span><span class="p">;</span>
	<span class="n">info64</span><span class="o">-&gt;</span><span class="n">lo_encrypt_key_size</span> <span class="o">=</span> <span class="n">info</span><span class="p">.</span><span class="n">lo_encrypt_key_size</span><span class="p">;</span>
	<span class="n">info64</span><span class="o">-&gt;</span><span class="n">lo_flags</span> <span class="o">=</span> <span class="n">info</span><span class="p">.</span><span class="n">lo_flags</span><span class="p">;</span>
	<span class="n">info64</span><span class="o">-&gt;</span><span class="n">lo_init</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">info</span><span class="p">.</span><span class="n">lo_init</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">info64</span><span class="o">-&gt;</span><span class="n">lo_init</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">info</span><span class="p">.</span><span class="n">lo_init</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">lo_encrypt_type</span> <span class="o">==</span> <span class="n">LO_CRYPT_CRYPTOAPI</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">info64</span><span class="o">-&gt;</span><span class="n">lo_crypt_name</span><span class="p">,</span> <span class="n">info</span><span class="p">.</span><span class="n">lo_name</span><span class="p">,</span> <span class="n">LO_NAME_SIZE</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">info64</span><span class="o">-&gt;</span><span class="n">lo_file_name</span><span class="p">,</span> <span class="n">info</span><span class="p">.</span><span class="n">lo_name</span><span class="p">,</span> <span class="n">LO_NAME_SIZE</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">info64</span><span class="o">-&gt;</span><span class="n">lo_encrypt_key</span><span class="p">,</span> <span class="n">info</span><span class="p">.</span><span class="n">lo_encrypt_key</span><span class="p">,</span> <span class="n">LO_KEY_SIZE</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Transfer 64-bit loop info to 32-bit compatibility structure in userspace</span>
<span class="cm"> * - noinlined to reduce stack space usage in main part of driver</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span>
<span class="nf">loop_info64_to_compat</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">loop_info64</span> <span class="o">*</span><span class="n">info64</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">compat_loop_info</span> <span class="n">__user</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">compat_loop_info</span> <span class="n">info</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">info</span><span class="p">));</span>
	<span class="n">info</span><span class="p">.</span><span class="n">lo_number</span> <span class="o">=</span> <span class="n">info64</span><span class="o">-&gt;</span><span class="n">lo_number</span><span class="p">;</span>
	<span class="n">info</span><span class="p">.</span><span class="n">lo_device</span> <span class="o">=</span> <span class="n">info64</span><span class="o">-&gt;</span><span class="n">lo_device</span><span class="p">;</span>
	<span class="n">info</span><span class="p">.</span><span class="n">lo_inode</span> <span class="o">=</span> <span class="n">info64</span><span class="o">-&gt;</span><span class="n">lo_inode</span><span class="p">;</span>
	<span class="n">info</span><span class="p">.</span><span class="n">lo_rdevice</span> <span class="o">=</span> <span class="n">info64</span><span class="o">-&gt;</span><span class="n">lo_rdevice</span><span class="p">;</span>
	<span class="n">info</span><span class="p">.</span><span class="n">lo_offset</span> <span class="o">=</span> <span class="n">info64</span><span class="o">-&gt;</span><span class="n">lo_offset</span><span class="p">;</span>
	<span class="n">info</span><span class="p">.</span><span class="n">lo_encrypt_type</span> <span class="o">=</span> <span class="n">info64</span><span class="o">-&gt;</span><span class="n">lo_encrypt_type</span><span class="p">;</span>
	<span class="n">info</span><span class="p">.</span><span class="n">lo_encrypt_key_size</span> <span class="o">=</span> <span class="n">info64</span><span class="o">-&gt;</span><span class="n">lo_encrypt_key_size</span><span class="p">;</span>
	<span class="n">info</span><span class="p">.</span><span class="n">lo_flags</span> <span class="o">=</span> <span class="n">info64</span><span class="o">-&gt;</span><span class="n">lo_flags</span><span class="p">;</span>
	<span class="n">info</span><span class="p">.</span><span class="n">lo_init</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">info64</span><span class="o">-&gt;</span><span class="n">lo_init</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">info</span><span class="p">.</span><span class="n">lo_init</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">info64</span><span class="o">-&gt;</span><span class="n">lo_init</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">lo_encrypt_type</span> <span class="o">==</span> <span class="n">LO_CRYPT_CRYPTOAPI</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">lo_name</span><span class="p">,</span> <span class="n">info64</span><span class="o">-&gt;</span><span class="n">lo_crypt_name</span><span class="p">,</span> <span class="n">LO_NAME_SIZE</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">lo_name</span><span class="p">,</span> <span class="n">info64</span><span class="o">-&gt;</span><span class="n">lo_file_name</span><span class="p">,</span> <span class="n">LO_NAME_SIZE</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">lo_encrypt_key</span><span class="p">,</span> <span class="n">info64</span><span class="o">-&gt;</span><span class="n">lo_encrypt_key</span><span class="p">,</span> <span class="n">LO_KEY_SIZE</span><span class="p">);</span>

	<span class="cm">/* error in case values were truncated */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">lo_device</span> <span class="o">!=</span> <span class="n">info64</span><span class="o">-&gt;</span><span class="n">lo_device</span> <span class="o">||</span>
	    <span class="n">info</span><span class="p">.</span><span class="n">lo_rdevice</span> <span class="o">!=</span> <span class="n">info64</span><span class="o">-&gt;</span><span class="n">lo_rdevice</span> <span class="o">||</span>
	    <span class="n">info</span><span class="p">.</span><span class="n">lo_inode</span> <span class="o">!=</span> <span class="n">info64</span><span class="o">-&gt;</span><span class="n">lo_inode</span> <span class="o">||</span>
	    <span class="n">info</span><span class="p">.</span><span class="n">lo_offset</span> <span class="o">!=</span> <span class="n">info64</span><span class="o">-&gt;</span><span class="n">lo_offset</span> <span class="o">||</span>
	    <span class="n">info</span><span class="p">.</span><span class="n">lo_init</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">info64</span><span class="o">-&gt;</span><span class="n">lo_init</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">||</span>
	    <span class="n">info</span><span class="p">.</span><span class="n">lo_init</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">info64</span><span class="o">-&gt;</span><span class="n">lo_init</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOVERFLOW</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">info</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">loop_set_status_compat</span><span class="p">(</span><span class="k">struct</span> <span class="n">loop_device</span> <span class="o">*</span><span class="n">lo</span><span class="p">,</span>
		       <span class="k">const</span> <span class="k">struct</span> <span class="n">compat_loop_info</span> <span class="n">__user</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">loop_info64</span> <span class="n">info64</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">loop_info64_from_compat</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info64</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">loop_set_status</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info64</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">loop_get_status_compat</span><span class="p">(</span><span class="k">struct</span> <span class="n">loop_device</span> <span class="o">*</span><span class="n">lo</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">compat_loop_info</span> <span class="n">__user</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">loop_info64</span> <span class="n">info64</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">arg</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">loop_get_status</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info64</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">loop_info64_to_compat</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info64</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">lo_compat_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span> <span class="n">fmode_t</span> <span class="n">mode</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">loop_device</span> <span class="o">*</span><span class="n">lo</span> <span class="o">=</span> <span class="n">bdev</span><span class="o">-&gt;</span><span class="n">bd_disk</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">switch</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">LOOP_SET_STATUS</span>:
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_ctl_mutex</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">loop_set_status_compat</span><span class="p">(</span>
			<span class="n">lo</span><span class="p">,</span> <span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">compat_loop_info</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_ctl_mutex</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LOOP_GET_STATUS</span>:
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_ctl_mutex</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">loop_get_status_compat</span><span class="p">(</span>
			<span class="n">lo</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">compat_loop_info</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_ctl_mutex</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LOOP_SET_CAPACITY</span>:
	<span class="k">case</span> <span class="n">LOOP_CLR_FD</span>:
	<span class="k">case</span> <span class="n">LOOP_GET_STATUS64</span>:
	<span class="k">case</span> <span class="n">LOOP_SET_STATUS64</span>:
		<span class="n">arg</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">compat_ptr</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">LOOP_SET_FD</span>:
	<span class="k">case</span> <span class="n">LOOP_CHANGE_FD</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">lo_ioctl</span><span class="p">(</span><span class="n">bdev</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOIOCTLCMD</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">lo_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span> <span class="n">fmode_t</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">loop_device</span> <span class="o">*</span><span class="n">lo</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">loop_index_mutex</span><span class="p">);</span>
	<span class="n">lo</span> <span class="o">=</span> <span class="n">bdev</span><span class="o">-&gt;</span><span class="n">bd_disk</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lo</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_ctl_mutex</span><span class="p">);</span>
	<span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_refcnt</span><span class="o">++</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_ctl_mutex</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">loop_index_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">lo_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">,</span> <span class="n">fmode_t</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">loop_device</span> <span class="o">*</span><span class="n">lo</span> <span class="o">=</span> <span class="n">disk</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_ctl_mutex</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_refcnt</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_flags</span> <span class="o">&amp;</span> <span class="n">LO_FLAGS_AUTOCLEAR</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * In autoclear mode, stop the loop thread</span>
<span class="cm">		 * and remove configuration after last close.</span>
<span class="cm">		 */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">loop_clr_fd</span><span class="p">(</span><span class="n">lo</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_unlocked</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Otherwise keep thread (if running) and config,</span>
<span class="cm">		 * but flush possible ongoing bios in thread.</span>
<span class="cm">		 */</span>
		<span class="n">loop_flush</span><span class="p">(</span><span class="n">lo</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_ctl_mutex</span><span class="p">);</span>
<span class="nl">out_unlocked:</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">block_device_operations</span> <span class="n">lo_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span> <span class="o">=</span>	<span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span>		<span class="n">lo_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span>	<span class="n">lo_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ioctl</span> <span class="o">=</span>	<span class="n">lo_ioctl</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_COMPAT</span>
	<span class="p">.</span><span class="n">compat_ioctl</span> <span class="o">=</span>	<span class="n">lo_compat_ioctl</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * And now the modules code and kernel interface.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">max_loop</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">max_loop</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">max_loop</span><span class="p">,</span> <span class="s">&quot;Maximum number of loop devices&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">max_part</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">max_part</span><span class="p">,</span> <span class="s">&quot;Maximum number of partitions per loop device&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_ALIAS_BLOCKDEV_MAJOR</span><span class="p">(</span><span class="n">LOOP_MAJOR</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">loop_register_transfer</span><span class="p">(</span><span class="k">struct</span> <span class="n">loop_func_table</span> <span class="o">*</span><span class="n">funcs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">funcs</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="n">MAX_LO_CRYPT</span> <span class="o">||</span> <span class="n">xfer_funcs</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">xfer_funcs</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">funcs</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">unregister_transfer_cb</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">loop_device</span> <span class="o">*</span><span class="n">lo</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">loop_func_table</span> <span class="o">*</span><span class="n">xfer</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_ctl_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_encryption</span> <span class="o">==</span> <span class="n">xfer</span><span class="p">)</span>
		<span class="n">loop_release_xfer</span><span class="p">(</span><span class="n">lo</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_ctl_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">loop_unregister_transfer</span><span class="p">(</span><span class="kt">int</span> <span class="n">number</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">number</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">loop_func_table</span> <span class="o">*</span><span class="n">xfer</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="n">MAX_LO_CRYPT</span> <span class="o">||</span> <span class="p">(</span><span class="n">xfer</span> <span class="o">=</span> <span class="n">xfer_funcs</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">xfer_funcs</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">idr_for_each</span><span class="p">(</span><span class="o">&amp;</span><span class="n">loop_index_idr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">unregister_transfer_cb</span><span class="p">,</span> <span class="n">xfer</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">loop_register_transfer</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">loop_unregister_transfer</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">loop_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">loop_device</span> <span class="o">**</span><span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">loop_device</span> <span class="o">*</span><span class="n">lo</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">lo</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">lo</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lo</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">idr_pre_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">loop_index_idr</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free_dev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">m</span><span class="p">;</span>

		<span class="cm">/* create specific i in the index */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">idr_get_new_above</span><span class="p">(</span><span class="o">&amp;</span><span class="n">loop_index_idr</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">idr_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">loop_index_idr</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">m</span><span class="p">;</span>

		<span class="cm">/* get next free nr */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">idr_get_new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">loop_index_idr</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">i</span> <span class="o">=</span> <span class="n">m</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free_dev</span><span class="p">;</span>

	<span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_queue</span> <span class="o">=</span> <span class="n">blk_alloc_queue</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_queue</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free_dev</span><span class="p">;</span>

	<span class="n">disk</span> <span class="o">=</span> <span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_disk</span> <span class="o">=</span> <span class="n">alloc_disk</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">part_shift</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">disk</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free_queue</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Disable partition scanning by default. The in-kernel partition</span>
<span class="cm">	 * scanning can be requested individually per-device during its</span>
<span class="cm">	 * setup. Userspace can always add and remove partitions from all</span>
<span class="cm">	 * devices. The needed partition minors are allocated from the</span>
<span class="cm">	 * extended minor space, the main loop device numbers will continue</span>
<span class="cm">	 * to match the loop minors, regardless of the number of partitions</span>
<span class="cm">	 * used.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If max_part is given, partition scanning is globally enabled for</span>
<span class="cm">	 * all loop devices. The minors for the main loop devices will be</span>
<span class="cm">	 * multiples of max_part.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note: Global-for-all-devices, set-only-at-init, read-only module</span>
<span class="cm">	 * parameteters like &#39;max_loop&#39; and &#39;max_part&#39; make things needlessly</span>
<span class="cm">	 * complicated, are too static, inflexible and may surprise</span>
<span class="cm">	 * userspace tools. Parameters like this in general should be avoided.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">part_shift</span><span class="p">)</span>
		<span class="n">disk</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">GENHD_FL_NO_PART_SCAN</span><span class="p">;</span>
	<span class="n">disk</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">GENHD_FL_EXT_DEVT</span><span class="p">;</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_ctl_mutex</span><span class="p">);</span>
	<span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_number</span>		<span class="o">=</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_thread</span>		<span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_event</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_lock</span><span class="p">);</span>
	<span class="n">disk</span><span class="o">-&gt;</span><span class="n">major</span>		<span class="o">=</span> <span class="n">LOOP_MAJOR</span><span class="p">;</span>
	<span class="n">disk</span><span class="o">-&gt;</span><span class="n">first_minor</span>	<span class="o">=</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">part_shift</span><span class="p">;</span>
	<span class="n">disk</span><span class="o">-&gt;</span><span class="n">fops</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">lo_fops</span><span class="p">;</span>
	<span class="n">disk</span><span class="o">-&gt;</span><span class="n">private_data</span>	<span class="o">=</span> <span class="n">lo</span><span class="p">;</span>
	<span class="n">disk</span><span class="o">-&gt;</span><span class="n">queue</span>		<span class="o">=</span> <span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_queue</span><span class="p">;</span>
	<span class="n">sprintf</span><span class="p">(</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">disk_name</span><span class="p">,</span> <span class="s">&quot;loop%d&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="n">add_disk</span><span class="p">(</span><span class="n">disk</span><span class="p">);</span>
	<span class="o">*</span><span class="n">l</span> <span class="o">=</span> <span class="n">lo</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_number</span><span class="p">;</span>

<span class="nl">out_free_queue:</span>
	<span class="n">blk_cleanup_queue</span><span class="p">(</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_queue</span><span class="p">);</span>
<span class="nl">out_free_dev:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">lo</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">loop_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">loop_device</span> <span class="o">*</span><span class="n">lo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">del_gendisk</span><span class="p">(</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_disk</span><span class="p">);</span>
	<span class="n">blk_cleanup_queue</span><span class="p">(</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_queue</span><span class="p">);</span>
	<span class="n">put_disk</span><span class="p">(</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_disk</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">lo</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">find_free_cb</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">loop_device</span> <span class="o">*</span><span class="n">lo</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">loop_device</span> <span class="o">**</span><span class="n">l</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_state</span> <span class="o">==</span> <span class="n">Lo_unbound</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">l</span> <span class="o">=</span> <span class="n">lo</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">loop_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">loop_device</span> <span class="o">**</span><span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">loop_device</span> <span class="o">*</span><span class="n">lo</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">idr_for_each</span><span class="p">(</span><span class="o">&amp;</span><span class="n">loop_index_idr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">find_free_cb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lo</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">l</span> <span class="o">=</span> <span class="n">lo</span><span class="p">;</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_number</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* lookup and return a specific i */</span>
	<span class="n">lo</span> <span class="o">=</span> <span class="n">idr_find</span><span class="p">(</span><span class="o">&amp;</span><span class="n">loop_index_idr</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lo</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">l</span> <span class="o">=</span> <span class="n">lo</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_number</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="nf">loop_probe</span><span class="p">(</span><span class="n">dev_t</span> <span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">part</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">loop_device</span> <span class="o">*</span><span class="n">lo</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">loop_index_mutex</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">loop_lookup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo</span><span class="p">,</span> <span class="n">MINOR</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">part_shift</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">loop_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo</span><span class="p">,</span> <span class="n">MINOR</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">part_shift</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">kobj</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">kobj</span> <span class="o">=</span> <span class="n">get_disk</span><span class="p">(</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_disk</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">loop_index_mutex</span><span class="p">);</span>

	<span class="o">*</span><span class="n">part</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">kobj</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">long</span> <span class="nf">loop_control_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">parm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">loop_device</span> <span class="o">*</span><span class="n">lo</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">loop_index_mutex</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">LOOP_CTL_ADD</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">loop_lookup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo</span><span class="p">,</span> <span class="n">parm</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">loop_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo</span><span class="p">,</span> <span class="n">parm</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LOOP_CTL_REMOVE</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">loop_lookup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo</span><span class="p">,</span> <span class="n">parm</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_ctl_mutex</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_state</span> <span class="o">!=</span> <span class="n">Lo_unbound</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_ctl_mutex</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_refcnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_ctl_mutex</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_disk</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_ctl_mutex</span><span class="p">);</span>
		<span class="n">idr_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">loop_index_idr</span><span class="p">,</span> <span class="n">lo</span><span class="o">-&gt;</span><span class="n">lo_number</span><span class="p">);</span>
		<span class="n">loop_remove</span><span class="p">(</span><span class="n">lo</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LOOP_CTL_GET_FREE</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">loop_lookup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">loop_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">loop_index_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">loop_ctl_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">nonseekable_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unlocked_ioctl</span>	<span class="o">=</span> <span class="n">loop_control_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">compat_ioctl</span>	<span class="o">=</span> <span class="n">loop_control_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">noop_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">miscdevice</span> <span class="n">loop_misc</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">minor</span>		<span class="o">=</span> <span class="n">LOOP_CTRL_MINOR</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;loop-control&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fops</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">loop_ctl_fops</span><span class="p">,</span>
<span class="p">};</span>

<span class="n">MODULE_ALIAS_MISCDEV</span><span class="p">(</span><span class="n">LOOP_CTRL_MINOR</span><span class="p">);</span>
<span class="n">MODULE_ALIAS</span><span class="p">(</span><span class="s">&quot;devname:loop-control&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">loop_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">nr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">range</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">loop_device</span> <span class="o">*</span><span class="n">lo</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">misc_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">loop_misc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">part_shift</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">max_part</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">part_shift</span> <span class="o">=</span> <span class="n">fls</span><span class="p">(</span><span class="n">max_part</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Adjust max_part according to part_shift as it is exported</span>
<span class="cm">		 * to user space so that user can decide correct minor number</span>
<span class="cm">		 * if [s]he want to create more devices.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Note that -1 is required because partition 0 is reserved</span>
<span class="cm">		 * for the whole disk.</span>
<span class="cm">		 */</span>
		<span class="n">max_part</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">part_shift</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">part_shift</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">DISK_MAX_PARTS</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">max_loop</span> <span class="o">&gt;</span> <span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">MINORBITS</span> <span class="o">-</span> <span class="n">part_shift</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If max_loop is specified, create that many devices upfront.</span>
<span class="cm">	 * This also becomes a hard limit. If max_loop is not specified,</span>
<span class="cm">	 * create CONFIG_BLK_DEV_LOOP_MIN_COUNT loop devices at module</span>
<span class="cm">	 * init time. Loop devices can be requested on-demand with the</span>
<span class="cm">	 * /dev/loop-control interface, or be instantiated by accessing</span>
<span class="cm">	 * a &#39;dead&#39; device node.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">max_loop</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nr</span> <span class="o">=</span> <span class="n">max_loop</span><span class="p">;</span>
		<span class="n">range</span> <span class="o">=</span> <span class="n">max_loop</span> <span class="o">&lt;&lt;</span> <span class="n">part_shift</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">nr</span> <span class="o">=</span> <span class="n">CONFIG_BLK_DEV_LOOP_MIN_COUNT</span><span class="p">;</span>
		<span class="n">range</span> <span class="o">=</span> <span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">MINORBITS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">register_blkdev</span><span class="p">(</span><span class="n">LOOP_MAJOR</span><span class="p">,</span> <span class="s">&quot;loop&quot;</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="n">blk_register_region</span><span class="p">(</span><span class="n">MKDEV</span><span class="p">(</span><span class="n">LOOP_MAJOR</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">range</span><span class="p">,</span>
				  <span class="n">THIS_MODULE</span><span class="p">,</span> <span class="n">loop_probe</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="cm">/* pre-create number of devices given by config or max_loop */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">loop_index_mutex</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">loop_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">loop_index_mutex</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;loop: module loaded</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">loop_exit_cb</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">loop_device</span> <span class="o">*</span><span class="n">lo</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>

	<span class="n">loop_remove</span><span class="p">(</span><span class="n">lo</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">loop_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">range</span><span class="p">;</span>

	<span class="n">range</span> <span class="o">=</span> <span class="n">max_loop</span> <span class="o">?</span> <span class="n">max_loop</span> <span class="o">&lt;&lt;</span> <span class="n">part_shift</span> <span class="o">:</span> <span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">MINORBITS</span><span class="p">;</span>

	<span class="n">idr_for_each</span><span class="p">(</span><span class="o">&amp;</span><span class="n">loop_index_idr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">loop_exit_cb</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">idr_remove_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">loop_index_idr</span><span class="p">);</span>
	<span class="n">idr_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">loop_index_idr</span><span class="p">);</span>

	<span class="n">blk_unregister_region</span><span class="p">(</span><span class="n">MKDEV</span><span class="p">(</span><span class="n">LOOP_MAJOR</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">range</span><span class="p">);</span>
	<span class="n">unregister_blkdev</span><span class="p">(</span><span class="n">LOOP_MAJOR</span><span class="p">,</span> <span class="s">&quot;loop&quot;</span><span class="p">);</span>

	<span class="n">misc_deregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">loop_misc</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">loop_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">loop_exit</span><span class="p">);</span>

<span class="cp">#ifndef MODULE</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">max_loop_setup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">max_loop</span> <span class="o">=</span> <span class="n">simple_strtol</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;max_loop=&quot;</span><span class="p">,</span> <span class="n">max_loop_setup</span><span class="p">);</span>
<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
