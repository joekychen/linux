<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › block › ataflop.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>ataflop.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  drivers/block/ataflop.c</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 1993  Greg Harp</span>
<span class="cm"> *  Atari Support by Bjoern Brauel, Roman Hodek</span>
<span class="cm"> *</span>
<span class="cm"> *  Big cleanup Sep 11..14 1994 Roman Hodek:</span>
<span class="cm"> *   - Driver now works interrupt driven</span>
<span class="cm"> *   - Support for two drives; should work, but I cannot test that :-(</span>
<span class="cm"> *   - Reading is done in whole tracks and buffered to speed up things</span>
<span class="cm"> *   - Disk change detection and drive deselecting after motor-off</span>
<span class="cm"> *     similar to TOS</span>
<span class="cm"> *   - Autodetection of disk format (DD/HD); untested yet, because I</span>
<span class="cm"> *     don&#39;t have an HD drive :-(</span>
<span class="cm"> *</span>
<span class="cm"> *  Fixes Nov 13 1994 Martin Schaller:</span>
<span class="cm"> *   - Autodetection works now</span>
<span class="cm"> *   - Support for 5 1/4&#39;&#39; disks</span>
<span class="cm"> *   - Removed drive type (unknown on atari)</span>
<span class="cm"> *   - Do seeks with 8 Mhz</span>
<span class="cm"> *</span>
<span class="cm"> *  Changes by Andreas Schwab:</span>
<span class="cm"> *   - After errors in multiple read mode try again reading single sectors</span>
<span class="cm"> *  (Feb 1995):</span>
<span class="cm"> *   - Clean up error handling</span>
<span class="cm"> *   - Set blk_size for proper size checking</span>
<span class="cm"> *   - Initialize track register when testing presence of floppy</span>
<span class="cm"> *   - Implement some ioctl&#39;s</span>
<span class="cm"> *</span>
<span class="cm"> *  Changes by Torsten Lang:</span>
<span class="cm"> *   - When probing the floppies we should add the FDCCMDADD_H flag since</span>
<span class="cm"> *     the FDC will otherwise wait forever when no disk is inserted...</span>
<span class="cm"> *</span>
<span class="cm"> * ++ Freddi Aschwanden (fa) 20.9.95 fixes for medusa:</span>
<span class="cm"> *  - MFPDELAY() after each FDC access -&gt; atari </span>
<span class="cm"> *  - more/other disk formats</span>
<span class="cm"> *  - DMA to the block buffer directly if we have a 32bit DMA</span>
<span class="cm"> *  - for medusa, the step rate is always 3ms</span>
<span class="cm"> *  - on medusa, use only cache_push()</span>
<span class="cm"> * Roman:</span>
<span class="cm"> *  - Make disk format numbering independent from minors</span>
<span class="cm"> *  - Let user set max. supported drive type (speeds up format</span>
<span class="cm"> *    detection, saves buffer space)</span>
<span class="cm"> *</span>
<span class="cm"> * Roman 10/15/95:</span>
<span class="cm"> *  - implement some more ioctls</span>
<span class="cm"> *  - disk formatting</span>
<span class="cm"> *  </span>
<span class="cm"> * Andreas 95/12/12:</span>
<span class="cm"> *  - increase gap size at start of track for HD/ED disks</span>
<span class="cm"> *</span>
<span class="cm"> * Michael (MSch) 11/07/96:</span>
<span class="cm"> *  - implemented FDSETPRM and FDDEFPRM ioctl</span>
<span class="cm"> *</span>
<span class="cm"> * Andreas (97/03/19):</span>
<span class="cm"> *  - implemented missing BLK* ioctls</span>
<span class="cm"> *</span>
<span class="cm"> *  Things left to do:</span>
<span class="cm"> *   - Formatting</span>
<span class="cm"> *   - Maybe a better strategy for disk change detection (does anyone</span>
<span class="cm"> *     know one?)</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>

<span class="cp">#include &lt;linux/fd.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>

<span class="cp">#include &lt;asm/atafd.h&gt;</span>
<span class="cp">#include &lt;asm/atafdreg.h&gt;</span>
<span class="cp">#include &lt;asm/atariints.h&gt;</span>
<span class="cp">#include &lt;asm/atari_stdma.h&gt;</span>
<span class="cp">#include &lt;asm/atari_stram.h&gt;</span>

<span class="cp">#define	FD_MAX_UNITS 2</span>

<span class="cp">#undef DEBUG</span>

<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">ataflop_mutex</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">fd_request</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">fdc_queue</span><span class="p">;</span>

<span class="cm">/* Disk types: DD, HD, ED */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">atari_disk_type</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span>	<span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">unsigned</span>	<span class="n">spt</span><span class="p">;</span>		<span class="cm">/* sectors per track */</span>
	<span class="kt">unsigned</span>	<span class="n">blocks</span><span class="p">;</span>		<span class="cm">/* total number of blocks */</span>
	<span class="kt">unsigned</span>	<span class="n">fdc_speed</span><span class="p">;</span>	<span class="cm">/* fdc_speed setting */</span>
	<span class="kt">unsigned</span> 	<span class="n">stretch</span><span class="p">;</span>	<span class="cm">/* track doubling ? */</span>
<span class="p">}</span> <span class="n">atari_disk_type</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="s">&quot;d360&quot;</span><span class="p">,</span>  <span class="mi">9</span><span class="p">,</span> <span class="mi">720</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>	<span class="cm">/*  0: 360kB diskette */</span>
	<span class="p">{</span> <span class="s">&quot;D360&quot;</span><span class="p">,</span>  <span class="mi">9</span><span class="p">,</span> <span class="mi">720</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span>	<span class="cm">/*  1: 360kb in 720k or 1.2MB drive */</span>
	<span class="p">{</span> <span class="s">&quot;D720&quot;</span><span class="p">,</span>  <span class="mi">9</span><span class="p">,</span><span class="mi">1440</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>	<span class="cm">/*  2: 720kb in 720k or 1.2MB drive */</span>
	<span class="p">{</span> <span class="s">&quot;D820&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span><span class="mi">1640</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>	<span class="cm">/*  3: DD disk with 82 tracks/10 sectors */</span>
<span class="cm">/* formats above are probed for type DD */</span>
<span class="cp">#define	MAX_TYPE_DD 3</span>
	<span class="p">{</span> <span class="s">&quot;h1200&quot;</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">2400</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>	<span class="cm">/*  4: 1.2MB diskette */</span>
	<span class="p">{</span> <span class="s">&quot;H1440&quot;</span><span class="p">,</span><span class="mi">18</span><span class="p">,</span><span class="mi">2880</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>	<span class="cm">/*  5: 1.4 MB diskette (HD) */</span>
	<span class="p">{</span> <span class="s">&quot;H1640&quot;</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">3280</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>	<span class="cm">/*  6: 1.64MB diskette (fat HD) 82 tr 20 sec */</span>
<span class="cm">/* formats above are probed for types DD and HD */</span>
<span class="cp">#define	MAX_TYPE_HD 6</span>
	<span class="p">{</span> <span class="s">&quot;E2880&quot;</span><span class="p">,</span><span class="mi">36</span><span class="p">,</span><span class="mi">5760</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>	<span class="cm">/*  7: 2.8 MB diskette (ED) */</span>
	<span class="p">{</span> <span class="s">&quot;E3280&quot;</span><span class="p">,</span><span class="mi">40</span><span class="p">,</span><span class="mi">6560</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>	<span class="cm">/*  8: 3.2 MB diskette (fat ED) 82 tr 40 sec */</span>
<span class="cm">/* formats above are probed for types DD, HD and ED */</span>
<span class="cp">#define	MAX_TYPE_ED 8</span>
<span class="cm">/* types below are never autoprobed */</span>
	<span class="p">{</span> <span class="s">&quot;H1680&quot;</span><span class="p">,</span><span class="mi">21</span><span class="p">,</span><span class="mi">3360</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>	<span class="cm">/*  9: 1.68MB diskette (fat HD) 80 tr 21 sec */</span>
	<span class="p">{</span> <span class="s">&quot;h410&quot;</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">820</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span>		<span class="cm">/* 10: 410k diskette 41 tr 10 sec, stretch */</span>
	<span class="p">{</span> <span class="s">&quot;h1476&quot;</span><span class="p">,</span><span class="mi">18</span><span class="p">,</span><span class="mi">2952</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>	<span class="cm">/* 11: 1.48MB diskette 82 tr 18 sec */</span>
	<span class="p">{</span> <span class="s">&quot;H1722&quot;</span><span class="p">,</span><span class="mi">21</span><span class="p">,</span><span class="mi">3444</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>	<span class="cm">/* 12: 1.72MB diskette 82 tr 21 sec */</span>
	<span class="p">{</span> <span class="s">&quot;h420&quot;</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">840</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span>		<span class="cm">/* 13: 420k diskette 42 tr 10 sec, stretch */</span>
	<span class="p">{</span> <span class="s">&quot;H830&quot;</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">1660</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>	<span class="cm">/* 14: 820k diskette 83 tr 10 sec */</span>
	<span class="p">{</span> <span class="s">&quot;h1494&quot;</span><span class="p">,</span><span class="mi">18</span><span class="p">,</span><span class="mi">2952</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>	<span class="cm">/* 15: 1.49MB diskette 83 tr 18 sec */</span>
	<span class="p">{</span> <span class="s">&quot;H1743&quot;</span><span class="p">,</span><span class="mi">21</span><span class="p">,</span><span class="mi">3486</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>	<span class="cm">/* 16: 1.74MB diskette 83 tr 21 sec */</span>
	<span class="p">{</span> <span class="s">&quot;h880&quot;</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">1760</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>	<span class="cm">/* 17: 880k diskette 80 tr 11 sec */</span>
	<span class="p">{</span> <span class="s">&quot;D1040&quot;</span><span class="p">,</span><span class="mi">13</span><span class="p">,</span><span class="mi">2080</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>	<span class="cm">/* 18: 1.04MB diskette 80 tr 13 sec */</span>
	<span class="p">{</span> <span class="s">&quot;D1120&quot;</span><span class="p">,</span><span class="mi">14</span><span class="p">,</span><span class="mi">2240</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>	<span class="cm">/* 19: 1.12MB diskette 80 tr 14 sec */</span>
	<span class="p">{</span> <span class="s">&quot;h1600&quot;</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">3200</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>	<span class="cm">/* 20: 1.60MB diskette 80 tr 20 sec */</span>
	<span class="p">{</span> <span class="s">&quot;H1760&quot;</span><span class="p">,</span><span class="mi">22</span><span class="p">,</span><span class="mi">3520</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>	<span class="cm">/* 21: 1.76MB diskette 80 tr 22 sec */</span>
	<span class="p">{</span> <span class="s">&quot;H1920&quot;</span><span class="p">,</span><span class="mi">24</span><span class="p">,</span><span class="mi">3840</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>	<span class="cm">/* 22: 1.92MB diskette 80 tr 24 sec */</span>
	<span class="p">{</span> <span class="s">&quot;E3200&quot;</span><span class="p">,</span><span class="mi">40</span><span class="p">,</span><span class="mi">6400</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>	<span class="cm">/* 23: 3.2MB diskette 80 tr 40 sec */</span>
	<span class="p">{</span> <span class="s">&quot;E3520&quot;</span><span class="p">,</span><span class="mi">44</span><span class="p">,</span><span class="mi">7040</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>	<span class="cm">/* 24: 3.52MB diskette 80 tr 44 sec */</span>
	<span class="p">{</span> <span class="s">&quot;E3840&quot;</span><span class="p">,</span><span class="mi">48</span><span class="p">,</span><span class="mi">7680</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>	<span class="cm">/* 25: 3.84MB diskette 80 tr 48 sec */</span>
	<span class="p">{</span> <span class="s">&quot;H1840&quot;</span><span class="p">,</span><span class="mi">23</span><span class="p">,</span><span class="mi">3680</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>	<span class="cm">/* 26: 1.84MB diskette 80 tr 23 sec */</span>
	<span class="p">{</span> <span class="s">&quot;D800&quot;</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">1600</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>	<span class="cm">/* 27: 800k diskette 80 tr 10 sec */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">StartDiskType</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">MAX_TYPE_DD</span><span class="p">,</span>
	<span class="n">MAX_TYPE_HD</span><span class="p">,</span>
	<span class="n">MAX_TYPE_ED</span>
<span class="p">};</span>

<span class="cp">#define	TYPE_DD		0</span>
<span class="cp">#define	TYPE_HD		1</span>
<span class="cp">#define	TYPE_ED		2</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">DriveType</span> <span class="o">=</span> <span class="n">TYPE_HD</span><span class="p">;</span>

<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">ataflop_lock</span><span class="p">);</span>

<span class="cm">/* Array for translating minors into disk formats */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">int</span> 	 <span class="n">index</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">drive_types</span><span class="p">;</span>
<span class="p">}</span> <span class="n">minor2disktype</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span>  <span class="mi">0</span><span class="p">,</span> <span class="n">TYPE_DD</span> <span class="p">},</span>	<span class="cm">/*  1: d360 */</span>
	<span class="p">{</span>  <span class="mi">4</span><span class="p">,</span> <span class="n">TYPE_HD</span> <span class="p">},</span>	<span class="cm">/*  2: h1200 */</span>
	<span class="p">{</span>  <span class="mi">1</span><span class="p">,</span> <span class="n">TYPE_DD</span> <span class="p">},</span>	<span class="cm">/*  3: D360 */</span>
	<span class="p">{</span>  <span class="mi">2</span><span class="p">,</span> <span class="n">TYPE_DD</span> <span class="p">},</span>	<span class="cm">/*  4: D720 */</span>
	<span class="p">{</span>  <span class="mi">1</span><span class="p">,</span> <span class="n">TYPE_DD</span> <span class="p">},</span>	<span class="cm">/*  5: h360 = D360 */</span>
	<span class="p">{</span>  <span class="mi">2</span><span class="p">,</span> <span class="n">TYPE_DD</span> <span class="p">},</span>	<span class="cm">/*  6: h720 = D720 */</span>
	<span class="p">{</span>  <span class="mi">5</span><span class="p">,</span> <span class="n">TYPE_HD</span> <span class="p">},</span>	<span class="cm">/*  7: H1440 */</span>
	<span class="p">{</span>  <span class="mi">7</span><span class="p">,</span> <span class="n">TYPE_ED</span> <span class="p">},</span>	<span class="cm">/*  8: E2880 */</span>
<span class="cm">/* some PC formats :-) */</span>
	<span class="p">{</span>  <span class="mi">8</span><span class="p">,</span> <span class="n">TYPE_ED</span> <span class="p">},</span>	<span class="cm">/*  9: E3280    &lt;- was &quot;CompaQ&quot; == E2880 for PC */</span>
	<span class="p">{</span>  <span class="mi">5</span><span class="p">,</span> <span class="n">TYPE_HD</span> <span class="p">},</span>	<span class="cm">/* 10: h1440 = H1440 */</span>
	<span class="p">{</span>  <span class="mi">9</span><span class="p">,</span> <span class="n">TYPE_HD</span> <span class="p">},</span>	<span class="cm">/* 11: H1680 */</span>
	<span class="p">{</span> <span class="mi">10</span><span class="p">,</span> <span class="n">TYPE_DD</span> <span class="p">},</span>	<span class="cm">/* 12: h410  */</span>
	<span class="p">{</span>  <span class="mi">3</span><span class="p">,</span> <span class="n">TYPE_DD</span> <span class="p">},</span>	<span class="cm">/* 13: H820     &lt;- == D820, 82x10 */</span>
	<span class="p">{</span> <span class="mi">11</span><span class="p">,</span> <span class="n">TYPE_HD</span> <span class="p">},</span>	<span class="cm">/* 14: h1476 */</span>
	<span class="p">{</span> <span class="mi">12</span><span class="p">,</span> <span class="n">TYPE_HD</span> <span class="p">},</span>	<span class="cm">/* 15: H1722 */</span>
	<span class="p">{</span> <span class="mi">13</span><span class="p">,</span> <span class="n">TYPE_DD</span> <span class="p">},</span>	<span class="cm">/* 16: h420  */</span>
	<span class="p">{</span> <span class="mi">14</span><span class="p">,</span> <span class="n">TYPE_DD</span> <span class="p">},</span>	<span class="cm">/* 17: H830  */</span>
	<span class="p">{</span> <span class="mi">15</span><span class="p">,</span> <span class="n">TYPE_HD</span> <span class="p">},</span>	<span class="cm">/* 18: h1494 */</span>
	<span class="p">{</span> <span class="mi">16</span><span class="p">,</span> <span class="n">TYPE_HD</span> <span class="p">},</span>	<span class="cm">/* 19: H1743 */</span>
	<span class="p">{</span> <span class="mi">17</span><span class="p">,</span> <span class="n">TYPE_DD</span> <span class="p">},</span>	<span class="cm">/* 20: h880  */</span>
	<span class="p">{</span> <span class="mi">18</span><span class="p">,</span> <span class="n">TYPE_DD</span> <span class="p">},</span>	<span class="cm">/* 21: D1040 */</span>
	<span class="p">{</span> <span class="mi">19</span><span class="p">,</span> <span class="n">TYPE_DD</span> <span class="p">},</span>	<span class="cm">/* 22: D1120 */</span>
	<span class="p">{</span> <span class="mi">20</span><span class="p">,</span> <span class="n">TYPE_HD</span> <span class="p">},</span>	<span class="cm">/* 23: h1600 */</span>
	<span class="p">{</span> <span class="mi">21</span><span class="p">,</span> <span class="n">TYPE_HD</span> <span class="p">},</span>	<span class="cm">/* 24: H1760 */</span>
	<span class="p">{</span> <span class="mi">22</span><span class="p">,</span> <span class="n">TYPE_HD</span> <span class="p">},</span>	<span class="cm">/* 25: H1920 */</span>
	<span class="p">{</span> <span class="mi">23</span><span class="p">,</span> <span class="n">TYPE_ED</span> <span class="p">},</span>	<span class="cm">/* 26: E3200 */</span>
	<span class="p">{</span> <span class="mi">24</span><span class="p">,</span> <span class="n">TYPE_ED</span> <span class="p">},</span>	<span class="cm">/* 27: E3520 */</span>
	<span class="p">{</span> <span class="mi">25</span><span class="p">,</span> <span class="n">TYPE_ED</span> <span class="p">},</span>	<span class="cm">/* 28: E3840 */</span>
	<span class="p">{</span> <span class="mi">26</span><span class="p">,</span> <span class="n">TYPE_HD</span> <span class="p">},</span>	<span class="cm">/* 29: H1840 */</span>
	<span class="p">{</span> <span class="mi">27</span><span class="p">,</span> <span class="n">TYPE_DD</span> <span class="p">},</span>	<span class="cm">/* 30: D800  */</span>
	<span class="p">{</span>  <span class="mi">6</span><span class="p">,</span> <span class="n">TYPE_HD</span> <span class="p">},</span>	<span class="cm">/* 31: H1640    &lt;- was H1600 == h1600 for PC */</span>
<span class="p">};</span>

<span class="cp">#define NUM_DISK_MINORS ARRAY_SIZE(minor2disktype)</span>

<span class="cm">/*</span>
<span class="cm"> * Maximum disk size (in kilobytes). This default is used whenever the</span>
<span class="cm"> * current disk size is unknown.</span>
<span class="cm"> */</span>
<span class="cp">#define MAX_DISK_SIZE 3280</span>

<span class="cm">/*</span>
<span class="cm"> * MSch: User-provided type information. &#39;drive&#39; points to</span>
<span class="cm"> * the respective entry of this array. Set by FDSETPRM ioctls.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">atari_disk_type</span> <span class="n">user_params</span><span class="p">[</span><span class="n">FD_MAX_UNITS</span><span class="p">];</span>

<span class="cm">/*</span>
<span class="cm"> * User-provided permanent type information. &#39;drive&#39; points to</span>
<span class="cm"> * the respective entry of this array.  Set by FDDEFPRM ioctls, </span>
<span class="cm"> * restored upon disk change by floppy_revalidate() if valid (as seen by</span>
<span class="cm"> * default_params[].blocks &gt; 0 - a bit in unit[].flags might be used for this?)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">atari_disk_type</span> <span class="n">default_params</span><span class="p">[</span><span class="n">FD_MAX_UNITS</span><span class="p">];</span>

<span class="cm">/* current info on each unit */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">atari_floppy_struct</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">connected</span><span class="p">;</span>				<span class="cm">/* !=0 : drive is connected */</span>
	<span class="kt">int</span> <span class="n">autoprobe</span><span class="p">;</span>				<span class="cm">/* !=0 : do autoprobe	    */</span>

	<span class="k">struct</span> <span class="n">atari_disk_type</span>	<span class="o">*</span><span class="n">disktype</span><span class="p">;</span>	<span class="cm">/* current type of disk */</span>

	<span class="kt">int</span> <span class="n">track</span><span class="p">;</span>		<span class="cm">/* current head position or -1 if</span>
<span class="cm">				   unknown */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">steprate</span><span class="p">;</span>	<span class="cm">/* steprate setting */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">wpstat</span><span class="p">;</span>	<span class="cm">/* current state of WP signal (for</span>
<span class="cm">				   disk change detection) */</span>
	<span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>		<span class="cm">/* flags */</span>
	<span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ref</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">type</span><span class="p">;</span>
<span class="p">}</span> <span class="n">unit</span><span class="p">[</span><span class="n">FD_MAX_UNITS</span><span class="p">];</span>

<span class="cp">#define	UD	unit[drive]</span>
<span class="cp">#define	UDT	unit[drive].disktype</span>
<span class="cp">#define	SUD	unit[SelectedDrive]</span>
<span class="cp">#define	SUDT	unit[SelectedDrive].disktype</span>


<span class="cp">#define FDC_READ(reg) ({			\</span>
<span class="cp">    </span><span class="cm">/* unsigned long __flags; */</span><span class="cp">		\</span>
<span class="cp">    unsigned short __val;			\</span>
<span class="cp">    </span><span class="cm">/* local_irq_save(__flags); */</span><span class="cp">		\</span>
<span class="cp">    dma_wd.dma_mode_status = 0x80 | (reg);	\</span>
<span class="cp">    udelay(25);					\</span>
<span class="cp">    __val = dma_wd.fdc_acces_seccount;		\</span>
<span class="cp">    MFPDELAY();					\</span>
<span class="cp">    </span><span class="cm">/* local_irq_restore(__flags); */</span><span class="cp">		\</span>
<span class="cp">    __val &amp; 0xff;				\</span>
<span class="cp">})</span>

<span class="cp">#define FDC_WRITE(reg,val)			\</span>
<span class="cp">    do {					\</span>
<span class="cp">	</span><span class="cm">/* unsigned long __flags; */</span><span class="cp">		\</span>
<span class="cp">	</span><span class="cm">/* local_irq_save(__flags); */</span><span class="cp">		\</span>
<span class="cp">	dma_wd.dma_mode_status = 0x80 | (reg);	\</span>
<span class="cp">	udelay(25);				\</span>
<span class="cp">	dma_wd.fdc_acces_seccount = (val);	\</span>
<span class="cp">	MFPDELAY();				\</span>
<span class="cp">        </span><span class="cm">/* local_irq_restore(__flags); */</span><span class="cp">	\</span>
<span class="cp">    } while(0)</span>


<span class="cm">/* Buffering variables:</span>
<span class="cm"> * First, there is a DMA buffer in ST-RAM that is used for floppy DMA</span>
<span class="cm"> * operations. Second, a track buffer is used to cache a whole track</span>
<span class="cm"> * of the disk to save read operations. These are two separate buffers</span>
<span class="cm"> * because that allows write operations without clearing the track buffer.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">MaxSectors</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="mi">11</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">44</span>
<span class="p">};</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">BufferSize</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="mi">15</span><span class="o">*</span><span class="mi">512</span><span class="p">,</span> <span class="mi">30</span><span class="o">*</span><span class="mi">512</span><span class="p">,</span> <span class="mi">60</span><span class="o">*</span><span class="mi">512</span>
<span class="p">};</span>

<span class="cp">#define	BUFFER_SIZE	(BufferSize[DriveType])</span>

<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">DMABuffer</span><span class="p">;</span>			  <span class="cm">/* buffer for writes */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">PhysDMABuffer</span><span class="p">;</span>   <span class="cm">/* physical address */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">UseTrackbuffer</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>		  <span class="cm">/* Do track buffering? */</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">UseTrackbuffer</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">TrackBuffer</span><span class="p">;</span>			  <span class="cm">/* buffer for reads */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">PhysTrackBuffer</span><span class="p">;</span> <span class="cm">/* physical address */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">BufferDrive</span><span class="p">,</span> <span class="n">BufferSide</span><span class="p">,</span> <span class="n">BufferTrack</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">read_track</span><span class="p">;</span>		<span class="cm">/* non-zero if we are reading whole tracks */</span>

<span class="cp">#define	SECTOR_BUFFER(sec)	(TrackBuffer + ((sec)-1)*512)</span>
<span class="cp">#define	IS_BUFFERED(drive,side,track) \</span>
<span class="cp">    (BufferDrive == (drive) &amp;&amp; BufferSide == (side) &amp;&amp; BufferTrack == (track))</span>

<span class="cm">/*</span>
<span class="cm"> * These are global variables, as that&#39;s the easiest way to give</span>
<span class="cm"> * information to interrupts. They are the data used for the current</span>
<span class="cm"> * request.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">SelectedDrive</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">ReqCmd</span><span class="p">,</span> <span class="n">ReqBlock</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">ReqSide</span><span class="p">,</span> <span class="n">ReqTrack</span><span class="p">,</span> <span class="n">ReqSector</span><span class="p">,</span> <span class="n">ReqCnt</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">HeadSettleFlag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ReqData</span><span class="p">,</span> <span class="o">*</span><span class="n">ReqBuffer</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">MotorOn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MotorOffTrys</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">IsFormatting</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">FormatError</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">UserSteprate</span><span class="p">[</span><span class="n">FD_MAX_UNITS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="p">};</span>
<span class="n">module_param_array</span><span class="p">(</span><span class="n">UserSteprate</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="cm">/* Synchronization of FDC access. */</span>
<span class="k">static</span> <span class="k">volatile</span> <span class="kt">int</span> <span class="n">fdc_busy</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">static</span> <span class="n">DECLARE_WAIT_QUEUE_HEAD</span><span class="p">(</span><span class="n">fdc_wait</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DECLARE_WAIT_QUEUE_HEAD</span><span class="p">(</span><span class="n">format_wait</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">changed_floppies</span> <span class="o">=</span> <span class="mh">0xff</span><span class="p">,</span> <span class="n">fake_change</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#define	CHECK_CHANGE_DELAY	HZ/2</span>

<span class="cp">#define	FD_MOTOR_OFF_DELAY	(3*HZ)</span>
<span class="cp">#define	FD_MOTOR_OFF_MAXTRY	(10*20)</span>

<span class="cp">#define FLOPPY_TIMEOUT		(6*HZ)</span>
<span class="cp">#define RECALIBRATE_ERRORS	4	</span><span class="cm">/* After this many errors the drive</span>
<span class="cm">					 * will be recalibrated. */</span><span class="cp"></span>
<span class="cp">#define MAX_ERRORS		8	</span><span class="cm">/* After this many errors the driver</span>
<span class="cm">					 * will give up. */</span><span class="cp"></span>


<span class="cm">/*</span>
<span class="cm"> * The driver is trying to determine the correct media format</span>
<span class="cm"> * while Probing is set. fd_rwsec_done() clears it after a</span>
<span class="cm"> * successful access.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">Probing</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cm">/* This flag is set when a dummy seek is necessary to make the WP</span>
<span class="cm"> * status bit accessible.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">NeedSeek</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>


<span class="cp">#ifdef DEBUG</span>
<span class="cp">#define DPRINT(a)	printk a</span>
<span class="cp">#else</span>
<span class="cp">#define DPRINT(a)</span>
<span class="cp">#endif</span>

<span class="cm">/***************************** Prototypes *****************************/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">fd_select_side</span><span class="p">(</span> <span class="kt">int</span> <span class="n">side</span> <span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">fd_select_drive</span><span class="p">(</span> <span class="kt">int</span> <span class="n">drive</span> <span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">fd_deselect</span><span class="p">(</span> <span class="kt">void</span> <span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">fd_motor_off_timer</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dummy</span> <span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">check_change</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dummy</span> <span class="p">);</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="n">floppy_irq</span> <span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dummy</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">fd_error</span><span class="p">(</span> <span class="kt">void</span> <span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">do_format</span><span class="p">(</span><span class="kt">int</span> <span class="n">drive</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="k">struct</span> <span class="n">atari_format_descr</span> <span class="o">*</span><span class="n">desc</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">do_fd_action</span><span class="p">(</span> <span class="kt">int</span> <span class="n">drive</span> <span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">fd_calibrate</span><span class="p">(</span> <span class="kt">void</span> <span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">fd_calibrate_done</span><span class="p">(</span> <span class="kt">int</span> <span class="n">status</span> <span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">fd_seek</span><span class="p">(</span> <span class="kt">void</span> <span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">fd_seek_done</span><span class="p">(</span> <span class="kt">int</span> <span class="n">status</span> <span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">fd_rwsec</span><span class="p">(</span> <span class="kt">void</span> <span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">fd_readtrack_check</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dummy</span> <span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">fd_rwsec_done</span><span class="p">(</span> <span class="kt">int</span> <span class="n">status</span> <span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">fd_rwsec_done1</span><span class="p">(</span><span class="kt">int</span> <span class="n">status</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">fd_writetrack</span><span class="p">(</span> <span class="kt">void</span> <span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">fd_writetrack_done</span><span class="p">(</span> <span class="kt">int</span> <span class="n">status</span> <span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">fd_times_out</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dummy</span> <span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">finish_fdc</span><span class="p">(</span> <span class="kt">void</span> <span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">finish_fdc_done</span><span class="p">(</span> <span class="kt">int</span> <span class="n">dummy</span> <span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">setup_req_params</span><span class="p">(</span> <span class="kt">int</span> <span class="n">drive</span> <span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">redo_fd_request</span><span class="p">(</span> <span class="kt">void</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">fd_locked_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span> <span class="n">fmode_t</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span>
                     <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">param</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">fd_probe</span><span class="p">(</span> <span class="kt">int</span> <span class="n">drive</span> <span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">fd_test_drive_present</span><span class="p">(</span> <span class="kt">int</span> <span class="n">drive</span> <span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">config_types</span><span class="p">(</span> <span class="kt">void</span> <span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">floppy_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span> <span class="n">fmode_t</span> <span class="n">mode</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">floppy_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">,</span> <span class="n">fmode_t</span> <span class="n">mode</span><span class="p">);</span>

<span class="cm">/************************* End of Prototypes **************************/</span>

<span class="k">static</span> <span class="n">DEFINE_TIMER</span><span class="p">(</span><span class="n">motor_off_timer</span><span class="p">,</span> <span class="n">fd_motor_off_timer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_TIMER</span><span class="p">(</span><span class="n">readtrack_timer</span><span class="p">,</span> <span class="n">fd_readtrack_check</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_TIMER</span><span class="p">(</span><span class="n">timeout_timer</span><span class="p">,</span> <span class="n">fd_times_out</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_TIMER</span><span class="p">(</span><span class="n">fd_timer</span><span class="p">,</span> <span class="n">check_change</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fd_end_request_cur</span><span class="p">(</span><span class="kt">int</span> <span class="n">err</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">__blk_end_request_cur</span><span class="p">(</span><span class="n">fd_request</span><span class="p">,</span> <span class="n">err</span><span class="p">))</span>
		<span class="n">fd_request</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">start_motor_off_timer</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">motor_off_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">FD_MOTOR_OFF_DELAY</span><span class="p">);</span>
	<span class="n">MotorOffTrys</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">start_check_change_timer</span><span class="p">(</span> <span class="kt">void</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fd_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">CHECK_CHANGE_DELAY</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">start_timeout</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timeout_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">FLOPPY_TIMEOUT</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">stop_timeout</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timeout_timer</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Select the side to use. */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fd_select_side</span><span class="p">(</span> <span class="kt">int</span> <span class="n">side</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* protect against various other ints mucking around with the PSG */</span>
	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
  
	<span class="n">sound_ym</span><span class="p">.</span><span class="n">rd_data_reg_sel</span> <span class="o">=</span> <span class="mi">14</span><span class="p">;</span> <span class="cm">/* Select PSG Port A */</span>
	<span class="n">sound_ym</span><span class="p">.</span><span class="n">wd_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">side</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="n">sound_ym</span><span class="p">.</span><span class="n">rd_data_reg_sel</span> <span class="o">|</span> <span class="mh">0x01</span> <span class="o">:</span>
	                                 <span class="n">sound_ym</span><span class="p">.</span><span class="n">rd_data_reg_sel</span> <span class="o">&amp;</span> <span class="mh">0xfe</span><span class="p">;</span>

	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/* Select a drive, update the FDC&#39;s track register and set the correct</span>
<span class="cm"> * clock speed for this disk&#39;s type.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fd_select_drive</span><span class="p">(</span> <span class="kt">int</span> <span class="n">drive</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">tmp</span><span class="p">;</span>
  
	<span class="k">if</span> <span class="p">(</span><span class="n">drive</span> <span class="o">==</span> <span class="n">SelectedDrive</span><span class="p">)</span>
	  <span class="k">return</span><span class="p">;</span>

	<span class="cm">/* protect against various other ints mucking around with the PSG */</span>
	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">sound_ym</span><span class="p">.</span><span class="n">rd_data_reg_sel</span> <span class="o">=</span> <span class="mi">14</span><span class="p">;</span> <span class="cm">/* Select PSG Port A */</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">sound_ym</span><span class="p">.</span><span class="n">rd_data_reg_sel</span><span class="p">;</span>
	<span class="n">sound_ym</span><span class="p">.</span><span class="n">wd_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">|</span> <span class="n">DSKDRVNONE</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">drive</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">DSKDRV0</span> <span class="o">:</span> <span class="n">DSKDRV1</span><span class="p">);</span>
	<span class="n">atari_dont_touch_floppy_select</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* restore track register to saved value */</span>
	<span class="n">FDC_WRITE</span><span class="p">(</span> <span class="n">FDCREG_TRACK</span><span class="p">,</span> <span class="n">UD</span><span class="p">.</span><span class="n">track</span> <span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">25</span><span class="p">);</span>

	<span class="cm">/* select 8/16 MHz */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">UDT</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ATARIHW_PRESENT</span><span class="p">(</span><span class="n">FDCSPEED</span><span class="p">))</span>
			<span class="n">dma_wd</span><span class="p">.</span><span class="n">fdc_speed</span> <span class="o">=</span> <span class="n">UDT</span><span class="o">-&gt;</span><span class="n">fdc_speed</span><span class="p">;</span>
	
	<span class="n">SelectedDrive</span> <span class="o">=</span> <span class="n">drive</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* Deselect both drives. */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fd_deselect</span><span class="p">(</span> <span class="kt">void</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* protect against various other ints mucking around with the PSG */</span>
	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">atari_dont_touch_floppy_select</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sound_ym</span><span class="p">.</span><span class="n">rd_data_reg_sel</span><span class="o">=</span><span class="mi">14</span><span class="p">;</span>	<span class="cm">/* Select PSG Port A */</span>
	<span class="n">sound_ym</span><span class="p">.</span><span class="n">wd_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">sound_ym</span><span class="p">.</span><span class="n">rd_data_reg_sel</span> <span class="o">|</span>
			    <span class="p">(</span><span class="n">MACH_IS_FALCON</span> <span class="o">?</span> <span class="mi">3</span> <span class="o">:</span> <span class="mi">7</span><span class="p">));</span> <span class="cm">/* no drives selected */</span>
	<span class="cm">/* On Falcon, the drive B select line is used on the printer port, so</span>
<span class="cm">	 * leave it alone... */</span>
	<span class="n">SelectedDrive</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/* This timer function deselects the drives when the FDC switched the</span>
<span class="cm"> * motor off. The deselection cannot happen earlier because the FDC</span>
<span class="cm"> * counts the index signals, which arrive only if one drive is selected.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fd_motor_off_timer</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dummy</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">status</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">SelectedDrive</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="cm">/* no drive selected, needn&#39;t deselect anyone */</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">stdma_islocked</span><span class="p">())</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">FDC_READ</span><span class="p">(</span> <span class="n">FDCREG_STATUS</span> <span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* motor already turned off by FDC -&gt; deselect drives */</span>
		<span class="n">MotorOn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">fd_deselect</span><span class="p">();</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* not yet off, try again */</span>

  <span class="nl">retry:</span>
	<span class="cm">/* Test again later; if tested too often, it seems there is no disk</span>
<span class="cm">	 * in the drive and the FDC will leave the motor on forever (or,</span>
<span class="cm">	 * at least until a disk is inserted). So we&#39;ll test only twice</span>
<span class="cm">	 * per second from then on...</span>
<span class="cm">	 */</span>
	<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">motor_off_timer</span><span class="p">,</span>
		  <span class="n">jiffies</span> <span class="o">+</span> <span class="p">(</span><span class="n">MotorOffTrys</span><span class="o">++</span> <span class="o">&lt;</span> <span class="n">FD_MOTOR_OFF_MAXTRY</span> <span class="o">?</span> <span class="n">HZ</span><span class="o">/</span><span class="mi">20</span> <span class="o">:</span> <span class="n">HZ</span><span class="o">/</span><span class="mi">2</span><span class="p">));</span>
<span class="p">}</span>


<span class="cm">/* This function is repeatedly called to detect disk changes (as good</span>
<span class="cm"> * as possible) and keep track of the current state of the write protection.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">check_change</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dummy</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">int</span>    <span class="n">drive</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">old_porta</span><span class="p">;</span>
	<span class="kt">int</span>			  <span class="n">stat</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">drive</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="o">!</span><span class="n">UD</span><span class="p">.</span><span class="n">connected</span><span class="p">)</span>
		<span class="n">drive</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* protect against various other ints mucking around with the PSG */</span>
	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">stdma_islocked</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">sound_ym</span><span class="p">.</span><span class="n">rd_data_reg_sel</span> <span class="o">=</span> <span class="mi">14</span><span class="p">;</span>
		<span class="n">old_porta</span> <span class="o">=</span> <span class="n">sound_ym</span><span class="p">.</span><span class="n">rd_data_reg_sel</span><span class="p">;</span>
		<span class="n">sound_ym</span><span class="p">.</span><span class="n">wd_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">old_porta</span> <span class="o">|</span> <span class="n">DSKDRVNONE</span><span class="p">)</span> <span class="o">&amp;</span>
			               <span class="o">~</span><span class="p">(</span><span class="n">drive</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">DSKDRV0</span> <span class="o">:</span> <span class="n">DSKDRV1</span><span class="p">);</span>
		<span class="n">stat</span> <span class="o">=</span> <span class="o">!!</span><span class="p">(</span><span class="n">FDC_READ</span><span class="p">(</span> <span class="n">FDCREG_STATUS</span> <span class="p">)</span> <span class="o">&amp;</span> <span class="n">FDCSTAT_WPROT</span><span class="p">);</span>
		<span class="n">sound_ym</span><span class="p">.</span><span class="n">wd_data</span> <span class="o">=</span> <span class="n">old_porta</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">stat</span> <span class="o">!=</span> <span class="n">UD</span><span class="p">.</span><span class="n">wpstat</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DPRINT</span><span class="p">((</span> <span class="s">&quot;wpstat[%d] = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">drive</span><span class="p">,</span> <span class="n">stat</span> <span class="p">));</span>
			<span class="n">UD</span><span class="p">.</span><span class="n">wpstat</span> <span class="o">=</span> <span class="n">stat</span><span class="p">;</span>
			<span class="n">set_bit</span> <span class="p">(</span><span class="n">drive</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">changed_floppies</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">start_check_change_timer</span><span class="p">();</span>
<span class="p">}</span>

 
<span class="cm">/* Handling of the Head Settling Flag: This flag should be set after each</span>
<span class="cm"> * seek operation, because we don&#39;t use seeks with verify.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_head_settle_flag</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">HeadSettleFlag</span> <span class="o">=</span> <span class="n">FDCCMDADD_E</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">get_head_settle_flag</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>	<span class="n">tmp</span> <span class="o">=</span> <span class="n">HeadSettleFlag</span><span class="p">;</span>
	<span class="n">HeadSettleFlag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span><span class="p">(</span> <span class="n">tmp</span> <span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">copy_buffer</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">to</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ulong</span> <span class="o">*</span><span class="n">p1</span> <span class="o">=</span> <span class="p">(</span><span class="n">ulong</span> <span class="o">*</span><span class="p">)</span><span class="n">from</span><span class="p">,</span> <span class="o">*</span><span class="n">p2</span> <span class="o">=</span> <span class="p">(</span><span class="n">ulong</span> <span class="o">*</span><span class="p">)</span><span class="n">to</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cnt</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">512</span><span class="o">/</span><span class="mi">4</span><span class="p">;</span> <span class="n">cnt</span><span class="p">;</span> <span class="n">cnt</span><span class="o">--</span><span class="p">)</span>
		<span class="o">*</span><span class="n">p2</span><span class="o">++</span> <span class="o">=</span> <span class="o">*</span><span class="n">p1</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

  
  

<span class="cm">/* General Interrupt Handling */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">FloppyIRQHandler</span><span class="p">)(</span> <span class="kt">int</span> <span class="n">status</span> <span class="p">)</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">floppy_irq</span> <span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dummy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">handler</span><span class="p">)(</span> <span class="kt">int</span> <span class="p">);</span>

	<span class="n">handler</span> <span class="o">=</span> <span class="n">xchg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">FloppyIRQHandler</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">handler</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nop</span><span class="p">();</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">FDC_READ</span><span class="p">(</span> <span class="n">FDCREG_STATUS</span> <span class="p">);</span>
		<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;FDC irq, status = %02x handler = %08lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">status</span><span class="p">,(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">handler</span><span class="p">));</span>
		<span class="n">handler</span><span class="p">(</span> <span class="n">status</span> <span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;FDC irq, no handler</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* Error handling: If some error happened, retry some times, then</span>
<span class="cm"> * recalibrate, then try again, and fail after MAX_ERRORS.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fd_error</span><span class="p">(</span> <span class="kt">void</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IsFormatting</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IsFormatting</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">FormatError</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">wake_up</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">format_wait</span> <span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fd_request</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">fd_request</span><span class="o">-&gt;</span><span class="n">errors</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fd_request</span><span class="o">-&gt;</span><span class="n">errors</span> <span class="o">&gt;=</span> <span class="n">MAX_ERRORS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;fd%d: too many errors.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">SelectedDrive</span> <span class="p">);</span>
		<span class="n">fd_end_request_cur</span><span class="p">(</span><span class="o">-</span><span class="n">EIO</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">fd_request</span><span class="o">-&gt;</span><span class="n">errors</span> <span class="o">==</span> <span class="n">RECALIBRATE_ERRORS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;fd%d: recalibrating</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">SelectedDrive</span> <span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">SelectedDrive</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="n">SUD</span><span class="p">.</span><span class="n">track</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">redo_fd_request</span><span class="p">();</span>
<span class="p">}</span>



<span class="cp">#define	SET_IRQ_HANDLER(proc) do { FloppyIRQHandler = (proc); } while(0)</span>


<span class="cm">/* ---------- Formatting ---------- */</span>

<span class="cp">#define FILL(n,val)		\</span>
<span class="cp">    do {			\</span>
<span class="cp">	memset( p, val, n );	\</span>
<span class="cp">	p += n;			\</span>
<span class="cp">    } while(0)</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_format</span><span class="p">(</span><span class="kt">int</span> <span class="n">drive</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="k">struct</span> <span class="n">atari_format_descr</span> <span class="o">*</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sect</span><span class="p">,</span> <span class="n">nsect</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">flags</span><span class="p">;</span>

	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;do_format( dr=%d tr=%d he=%d offs=%d )</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">drive</span><span class="p">,</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">track</span><span class="p">,</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">,</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">sect_offset</span> <span class="p">));</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">while</span><span class="p">(</span> <span class="n">fdc_busy</span> <span class="p">)</span> <span class="n">sleep_on</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">fdc_wait</span> <span class="p">);</span>
	<span class="n">fdc_busy</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">stdma_lock</span><span class="p">(</span><span class="n">floppy_irq</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">atari_turnon_irq</span><span class="p">(</span> <span class="n">IRQ_MFP_FDC</span> <span class="p">);</span> <span class="cm">/* should be already, just to be sure */</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">type</span> <span class="o">&gt;=</span> <span class="n">NUM_DISK_MINORS</span> <span class="o">||</span>
		    <span class="n">minor2disktype</span><span class="p">[</span><span class="n">type</span><span class="p">].</span><span class="n">drive_types</span> <span class="o">&gt;</span> <span class="n">DriveType</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">redo_fd_request</span><span class="p">();</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">type</span> <span class="o">=</span> <span class="n">minor2disktype</span><span class="p">[</span><span class="n">type</span><span class="p">].</span><span class="n">index</span><span class="p">;</span>
		<span class="n">UDT</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">atari_disk_type</span><span class="p">[</span><span class="n">type</span><span class="p">];</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">UDT</span> <span class="o">||</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">track</span> <span class="o">&gt;=</span> <span class="n">UDT</span><span class="o">-&gt;</span><span class="n">blocks</span><span class="o">/</span><span class="n">UDT</span><span class="o">-&gt;</span><span class="n">spt</span><span class="o">/</span><span class="mi">2</span> <span class="o">||</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">redo_fd_request</span><span class="p">();</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">nsect</span> <span class="o">=</span> <span class="n">UDT</span><span class="o">-&gt;</span><span class="n">spt</span><span class="p">;</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">TrackBuffer</span><span class="p">;</span>
	<span class="cm">/* The track buffer is used for the raw track data, so its</span>
<span class="cm">	   contents become invalid! */</span>
	<span class="n">BufferDrive</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="cm">/* stop deselect timer */</span>
	<span class="n">del_timer</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">motor_off_timer</span> <span class="p">);</span>

	<span class="n">FILL</span><span class="p">(</span> <span class="mi">60</span> <span class="o">*</span> <span class="p">(</span><span class="n">nsect</span> <span class="o">/</span> <span class="mi">9</span><span class="p">),</span> <span class="mh">0x4e</span> <span class="p">);</span>
	<span class="k">for</span><span class="p">(</span> <span class="n">sect</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">sect</span> <span class="o">&lt;</span> <span class="n">nsect</span><span class="p">;</span> <span class="o">++</span><span class="n">sect</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">FILL</span><span class="p">(</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
		<span class="n">FILL</span><span class="p">(</span> <span class="mi">3</span><span class="p">,</span> <span class="mh">0xf5</span> <span class="p">);</span>
		<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="mh">0xfe</span><span class="p">;</span>
		<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">track</span><span class="p">;</span>
		<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>
		<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="n">nsect</span> <span class="o">+</span> <span class="n">sect</span> <span class="o">-</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">sect_offset</span><span class="p">)</span> <span class="o">%</span> <span class="n">nsect</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="mh">0xf7</span><span class="p">;</span>
		<span class="n">FILL</span><span class="p">(</span> <span class="mi">22</span><span class="p">,</span> <span class="mh">0x4e</span> <span class="p">);</span>
		<span class="n">FILL</span><span class="p">(</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
		<span class="n">FILL</span><span class="p">(</span> <span class="mi">3</span><span class="p">,</span> <span class="mh">0xf5</span> <span class="p">);</span>
		<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="mh">0xfb</span><span class="p">;</span>
		<span class="n">FILL</span><span class="p">(</span> <span class="mi">512</span><span class="p">,</span> <span class="mh">0xe5</span> <span class="p">);</span>
		<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="mh">0xf7</span><span class="p">;</span>
		<span class="n">FILL</span><span class="p">(</span> <span class="mi">40</span><span class="p">,</span> <span class="mh">0x4e</span> <span class="p">);</span>
	<span class="p">}</span>
	<span class="n">FILL</span><span class="p">(</span> <span class="n">TrackBuffer</span><span class="o">+</span><span class="n">BUFFER_SIZE</span><span class="o">-</span><span class="n">p</span><span class="p">,</span> <span class="mh">0x4e</span> <span class="p">);</span>

	<span class="n">IsFormatting</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">FormatError</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ReqTrack</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">track</span><span class="p">;</span>
	<span class="n">ReqSide</span>  <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>
	<span class="n">do_fd_action</span><span class="p">(</span> <span class="n">drive</span> <span class="p">);</span>

	<span class="n">sleep_on</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">format_wait</span> <span class="p">);</span>

	<span class="n">redo_fd_request</span><span class="p">();</span>
	<span class="k">return</span><span class="p">(</span> <span class="n">FormatError</span> <span class="o">?</span> <span class="o">-</span><span class="n">EIO</span> <span class="o">:</span> <span class="mi">0</span> <span class="p">);</span>	
<span class="p">}</span>


<span class="cm">/* do_fd_action() is the general procedure for a fd request: All</span>
<span class="cm"> * required parameter settings (drive select, side select, track</span>
<span class="cm"> * position) are checked and set if needed. For each of these</span>
<span class="cm"> * parameters and the actual reading or writing exist two functions:</span>
<span class="cm"> * one that starts the setting (or skips it if possible) and one</span>
<span class="cm"> * callback for the &quot;done&quot; interrupt. Each done func calls the next</span>
<span class="cm"> * set function to propagate the request down to fd_rwsec_done().</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">do_fd_action</span><span class="p">(</span> <span class="kt">int</span> <span class="n">drive</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;do_fd_action</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="n">UseTrackbuffer</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">IsFormatting</span><span class="p">)</span> <span class="p">{</span>
	<span class="nl">repeat:</span>
	    <span class="k">if</span> <span class="p">(</span><span class="n">IS_BUFFERED</span><span class="p">(</span> <span class="n">drive</span><span class="p">,</span> <span class="n">ReqSide</span><span class="p">,</span> <span class="n">ReqTrack</span> <span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ReqCmd</span> <span class="o">==</span> <span class="n">READ</span><span class="p">)</span> <span class="p">{</span>
		    <span class="n">copy_buffer</span><span class="p">(</span> <span class="n">SECTOR_BUFFER</span><span class="p">(</span><span class="n">ReqSector</span><span class="p">),</span> <span class="n">ReqData</span> <span class="p">);</span>
		    <span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">ReqCnt</span> <span class="o">&lt;</span> <span class="n">blk_rq_cur_sectors</span><span class="p">(</span><span class="n">fd_request</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* read next sector */</span>
			<span class="n">setup_req_params</span><span class="p">(</span> <span class="n">drive</span> <span class="p">);</span>
			<span class="k">goto</span> <span class="n">repeat</span><span class="p">;</span>
		    <span class="p">}</span>
		    <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* all sectors finished */</span>
			<span class="n">fd_end_request_cur</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
			<span class="n">redo_fd_request</span><span class="p">();</span>
			<span class="k">return</span><span class="p">;</span>
		    <span class="p">}</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
		    <span class="cm">/* cmd == WRITE, pay attention to track buffer</span>
<span class="cm">		     * consistency! */</span>
		    <span class="n">copy_buffer</span><span class="p">(</span> <span class="n">ReqData</span><span class="p">,</span> <span class="n">SECTOR_BUFFER</span><span class="p">(</span><span class="n">ReqSector</span><span class="p">)</span> <span class="p">);</span>
		<span class="p">}</span>
	    <span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">SelectedDrive</span> <span class="o">!=</span> <span class="n">drive</span><span class="p">)</span>
		<span class="n">fd_select_drive</span><span class="p">(</span> <span class="n">drive</span> <span class="p">);</span>
    
	<span class="k">if</span> <span class="p">(</span><span class="n">UD</span><span class="p">.</span><span class="n">track</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">fd_calibrate</span><span class="p">();</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">UD</span><span class="p">.</span><span class="n">track</span> <span class="o">!=</span> <span class="n">ReqTrack</span> <span class="o">&lt;&lt;</span> <span class="n">UDT</span><span class="o">-&gt;</span><span class="n">stretch</span><span class="p">)</span>
		<span class="n">fd_seek</span><span class="p">();</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">IsFormatting</span><span class="p">)</span>
		<span class="n">fd_writetrack</span><span class="p">();</span>
	<span class="k">else</span>
		<span class="n">fd_rwsec</span><span class="p">();</span>
<span class="p">}</span>


<span class="cm">/* Seek to track 0 if the current track is unknown */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fd_calibrate</span><span class="p">(</span> <span class="kt">void</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">SUD</span><span class="p">.</span><span class="n">track</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fd_calibrate_done</span><span class="p">(</span> <span class="mi">0</span> <span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ATARIHW_PRESENT</span><span class="p">(</span><span class="n">FDCSPEED</span><span class="p">))</span>
		<span class="n">dma_wd</span><span class="p">.</span><span class="n">fdc_speed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 	<span class="cm">/* always seek with 8 Mhz */</span><span class="p">;</span>
	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;fd_calibrate</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
	<span class="n">SET_IRQ_HANDLER</span><span class="p">(</span> <span class="n">fd_calibrate_done</span> <span class="p">);</span>
	<span class="cm">/* we can&#39;t verify, since the speed may be incorrect */</span>
	<span class="n">FDC_WRITE</span><span class="p">(</span> <span class="n">FDCREG_CMD</span><span class="p">,</span> <span class="n">FDCCMD_RESTORE</span> <span class="o">|</span> <span class="n">SUD</span><span class="p">.</span><span class="n">steprate</span> <span class="p">);</span>

	<span class="n">NeedSeek</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">MotorOn</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">start_timeout</span><span class="p">();</span>
	<span class="cm">/* wait for IRQ */</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">fd_calibrate_done</span><span class="p">(</span> <span class="kt">int</span> <span class="n">status</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;fd_calibrate_done()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
	<span class="n">stop_timeout</span><span class="p">();</span>
    
	<span class="cm">/* set the correct speed now */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ATARIHW_PRESENT</span><span class="p">(</span><span class="n">FDCSPEED</span><span class="p">))</span>
		<span class="n">dma_wd</span><span class="p">.</span><span class="n">fdc_speed</span> <span class="o">=</span> <span class="n">SUDT</span><span class="o">-&gt;</span><span class="n">fdc_speed</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">FDCSTAT_RECNF</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;fd%d: restore failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">SelectedDrive</span> <span class="p">);</span>
		<span class="n">fd_error</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">SUD</span><span class="p">.</span><span class="n">track</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">fd_seek</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>
  
  
<span class="cm">/* Seek the drive to the requested track. The drive must have been</span>
<span class="cm"> * calibrated at some point before this.</span>
<span class="cm"> */</span>
  
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fd_seek</span><span class="p">(</span> <span class="kt">void</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">SUD</span><span class="p">.</span><span class="n">track</span> <span class="o">==</span> <span class="n">ReqTrack</span> <span class="o">&lt;&lt;</span> <span class="n">SUDT</span><span class="o">-&gt;</span><span class="n">stretch</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fd_seek_done</span><span class="p">(</span> <span class="mi">0</span> <span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ATARIHW_PRESENT</span><span class="p">(</span><span class="n">FDCSPEED</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dma_wd</span><span class="p">.</span><span class="n">fdc_speed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* always seek witch 8 Mhz */</span>
		<span class="n">MFPDELAY</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;fd_seek() to track %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">ReqTrack</span><span class="p">));</span>
	<span class="n">FDC_WRITE</span><span class="p">(</span> <span class="n">FDCREG_DATA</span><span class="p">,</span> <span class="n">ReqTrack</span> <span class="o">&lt;&lt;</span> <span class="n">SUDT</span><span class="o">-&gt;</span><span class="n">stretch</span><span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">25</span><span class="p">);</span>
	<span class="n">SET_IRQ_HANDLER</span><span class="p">(</span> <span class="n">fd_seek_done</span> <span class="p">);</span>
	<span class="n">FDC_WRITE</span><span class="p">(</span> <span class="n">FDCREG_CMD</span><span class="p">,</span> <span class="n">FDCCMD_SEEK</span> <span class="o">|</span> <span class="n">SUD</span><span class="p">.</span><span class="n">steprate</span> <span class="p">);</span>

	<span class="n">MotorOn</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">set_head_settle_flag</span><span class="p">();</span>
	<span class="n">start_timeout</span><span class="p">();</span>
	<span class="cm">/* wait for IRQ */</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">fd_seek_done</span><span class="p">(</span> <span class="kt">int</span> <span class="n">status</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;fd_seek_done()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
	<span class="n">stop_timeout</span><span class="p">();</span>
	
	<span class="cm">/* set the correct speed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ATARIHW_PRESENT</span><span class="p">(</span><span class="n">FDCSPEED</span><span class="p">))</span>
		<span class="n">dma_wd</span><span class="p">.</span><span class="n">fdc_speed</span> <span class="o">=</span> <span class="n">SUDT</span><span class="o">-&gt;</span><span class="n">fdc_speed</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">FDCSTAT_RECNF</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;fd%d: seek error (to track %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">SelectedDrive</span><span class="p">,</span> <span class="n">ReqTrack</span> <span class="p">);</span>
		<span class="cm">/* we don&#39;t know exactly which track we are on now! */</span>
		<span class="n">SUD</span><span class="p">.</span><span class="n">track</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">fd_error</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">SUD</span><span class="p">.</span><span class="n">track</span> <span class="o">=</span> <span class="n">ReqTrack</span> <span class="o">&lt;&lt;</span> <span class="n">SUDT</span><span class="o">-&gt;</span><span class="n">stretch</span><span class="p">;</span>
		<span class="n">NeedSeek</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IsFormatting</span><span class="p">)</span>
			<span class="n">fd_writetrack</span><span class="p">();</span>
		<span class="k">else</span>
			<span class="n">fd_rwsec</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="cm">/* This does the actual reading/writing after positioning the head</span>
<span class="cm"> * over the correct track.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">MultReadInProgress</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">fd_rwsec</span><span class="p">(</span> <span class="kt">void</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">paddr</span><span class="p">,</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>  <span class="n">rwflag</span><span class="p">,</span> <span class="n">old_motoron</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">track</span><span class="p">;</span>
	
	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;fd_rwsec(), Sec=%d, Access=%c</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">ReqSector</span><span class="p">,</span> <span class="n">ReqCmd</span> <span class="o">==</span> <span class="n">WRITE</span> <span class="o">?</span> <span class="sc">&#39;w&#39;</span> <span class="o">:</span> <span class="sc">&#39;r&#39;</span> <span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ReqCmd</span> <span class="o">==</span> <span class="n">WRITE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ATARIHW_PRESENT</span><span class="p">(</span><span class="n">EXTD_DMA</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">paddr</span> <span class="o">=</span> <span class="n">virt_to_phys</span><span class="p">(</span><span class="n">ReqData</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">copy_buffer</span><span class="p">(</span> <span class="n">ReqData</span><span class="p">,</span> <span class="n">DMABuffer</span> <span class="p">);</span>
			<span class="n">paddr</span> <span class="o">=</span> <span class="n">PhysDMABuffer</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">dma_cache_maintenance</span><span class="p">(</span> <span class="n">paddr</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="mi">1</span> <span class="p">);</span>
		<span class="n">rwflag</span> <span class="o">=</span> <span class="mh">0x100</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">read_track</span><span class="p">)</span>
			<span class="n">paddr</span> <span class="o">=</span> <span class="n">PhysTrackBuffer</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">paddr</span> <span class="o">=</span> <span class="n">ATARIHW_PRESENT</span><span class="p">(</span><span class="n">EXTD_DMA</span><span class="p">)</span> <span class="o">?</span> 
				<span class="n">virt_to_phys</span><span class="p">(</span><span class="n">ReqData</span><span class="p">)</span> <span class="o">:</span> <span class="n">PhysDMABuffer</span><span class="p">;</span>
		<span class="n">rwflag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">fd_select_side</span><span class="p">(</span> <span class="n">ReqSide</span> <span class="p">);</span>
  
	<span class="cm">/* Start sector of this operation */</span>
	<span class="n">FDC_WRITE</span><span class="p">(</span> <span class="n">FDCREG_SECTOR</span><span class="p">,</span> <span class="n">read_track</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">ReqSector</span> <span class="p">);</span>
	<span class="n">MFPDELAY</span><span class="p">();</span>
	<span class="cm">/* Cheat for track if stretch != 0 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">SUDT</span><span class="o">-&gt;</span><span class="n">stretch</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">track</span> <span class="o">=</span> <span class="n">FDC_READ</span><span class="p">(</span> <span class="n">FDCREG_TRACK</span><span class="p">);</span>
		<span class="n">MFPDELAY</span><span class="p">();</span>
		<span class="n">FDC_WRITE</span><span class="p">(</span> <span class="n">FDCREG_TRACK</span><span class="p">,</span> <span class="n">track</span> <span class="o">&gt;&gt;</span> <span class="n">SUDT</span><span class="o">-&gt;</span><span class="n">stretch</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">25</span><span class="p">);</span>
  
	<span class="cm">/* Setup DMA */</span>
	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">dma_wd</span><span class="p">.</span><span class="n">dma_lo</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span><span class="n">paddr</span><span class="p">;</span>
	<span class="n">MFPDELAY</span><span class="p">();</span>
	<span class="n">paddr</span> <span class="o">&gt;&gt;=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">dma_wd</span><span class="p">.</span><span class="n">dma_md</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span><span class="n">paddr</span><span class="p">;</span>
	<span class="n">MFPDELAY</span><span class="p">();</span>
	<span class="n">paddr</span> <span class="o">&gt;&gt;=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ATARIHW_PRESENT</span><span class="p">(</span><span class="n">EXTD_DMA</span><span class="p">))</span>
		<span class="n">st_dma_ext_dmahi</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span><span class="p">)</span><span class="n">paddr</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">dma_wd</span><span class="p">.</span><span class="n">dma_hi</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span><span class="n">paddr</span><span class="p">;</span>
	<span class="n">MFPDELAY</span><span class="p">();</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
  
	<span class="cm">/* Clear FIFO and switch DMA to correct mode */</span>  
	<span class="n">dma_wd</span><span class="p">.</span><span class="n">dma_mode_status</span> <span class="o">=</span> <span class="mh">0x90</span> <span class="o">|</span> <span class="n">rwflag</span><span class="p">;</span>  
	<span class="n">MFPDELAY</span><span class="p">();</span>
	<span class="n">dma_wd</span><span class="p">.</span><span class="n">dma_mode_status</span> <span class="o">=</span> <span class="mh">0x90</span> <span class="o">|</span> <span class="p">(</span><span class="n">rwflag</span> <span class="o">^</span> <span class="mh">0x100</span><span class="p">);</span>  
	<span class="n">MFPDELAY</span><span class="p">();</span>
	<span class="n">dma_wd</span><span class="p">.</span><span class="n">dma_mode_status</span> <span class="o">=</span> <span class="mh">0x90</span> <span class="o">|</span> <span class="n">rwflag</span><span class="p">;</span>
	<span class="n">MFPDELAY</span><span class="p">();</span>
  
	<span class="cm">/* How many sectors for DMA */</span>
	<span class="n">dma_wd</span><span class="p">.</span><span class="n">fdc_acces_seccount</span> <span class="o">=</span> <span class="n">read_track</span> <span class="o">?</span> <span class="n">SUDT</span><span class="o">-&gt;</span><span class="n">spt</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
  
	<span class="n">udelay</span><span class="p">(</span><span class="mi">25</span><span class="p">);</span>  
  
	<span class="cm">/* Start operation */</span>
	<span class="n">dma_wd</span><span class="p">.</span><span class="n">dma_mode_status</span> <span class="o">=</span> <span class="n">FDCSELREG_STP</span> <span class="o">|</span> <span class="n">rwflag</span><span class="p">;</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">25</span><span class="p">);</span>
	<span class="n">SET_IRQ_HANDLER</span><span class="p">(</span> <span class="n">fd_rwsec_done</span> <span class="p">);</span>
	<span class="n">dma_wd</span><span class="p">.</span><span class="n">fdc_acces_seccount</span> <span class="o">=</span>
	  <span class="p">(</span><span class="n">get_head_settle_flag</span><span class="p">()</span> <span class="o">|</span>
	   <span class="p">(</span><span class="n">rwflag</span> <span class="o">?</span> <span class="n">FDCCMD_WRSEC</span> <span class="o">:</span> <span class="p">(</span><span class="n">FDCCMD_RDSEC</span> <span class="o">|</span> <span class="p">(</span><span class="n">read_track</span> <span class="o">?</span> <span class="n">FDCCMDADD_M</span> <span class="o">:</span> <span class="mi">0</span><span class="p">))));</span>

	<span class="n">old_motoron</span> <span class="o">=</span> <span class="n">MotorOn</span><span class="p">;</span>
	<span class="n">MotorOn</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">NeedSeek</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/* wait for interrupt */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">read_track</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* If reading a whole track, wait about one disk rotation and</span>
<span class="cm">		 * then check if all sectors are read. The FDC will even</span>
<span class="cm">		 * search for the first non-existent sector and need 1 sec to</span>
<span class="cm">		 * recognise that it isn&#39;t present :-(</span>
<span class="cm">		 */</span>
		<span class="n">MultReadInProgress</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">readtrack_timer</span><span class="p">,</span>
			  <span class="cm">/* 1 rot. + 5 rot.s if motor was off  */</span>
			  <span class="n">jiffies</span> <span class="o">+</span> <span class="n">HZ</span><span class="o">/</span><span class="mi">5</span> <span class="o">+</span> <span class="p">(</span><span class="n">old_motoron</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">HZ</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">start_timeout</span><span class="p">();</span>
<span class="p">}</span>

    
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fd_readtrack_check</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dummy</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">addr2</span><span class="p">;</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">MultReadInProgress</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* This prevents a race condition that could arise if the</span>
<span class="cm">		 * interrupt is triggered while the calling of this timer</span>
<span class="cm">		 * callback function takes place. The IRQ function then has</span>
<span class="cm">		 * already cleared &#39;MultReadInProgress&#39;  when flow of control</span>
<span class="cm">		 * gets here.</span>
<span class="cm">		 */</span>
		<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* get the current DMA address */</span>
	<span class="cm">/* ++ f.a. read twice to avoid being fooled by switcher */</span>
	<span class="n">addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">addr2</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="n">dma_wd</span><span class="p">.</span><span class="n">dma_lo</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="n">MFPDELAY</span><span class="p">();</span>
		<span class="n">addr</span> <span class="o">|=</span> <span class="p">(</span><span class="n">dma_wd</span><span class="p">.</span><span class="n">dma_md</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">MFPDELAY</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ATARIHW_PRESENT</span><span class="p">(</span> <span class="n">EXTD_DMA</span> <span class="p">))</span>
			<span class="n">addr</span> <span class="o">|=</span> <span class="p">(</span><span class="n">st_dma_ext_dmahi</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">addr</span> <span class="o">|=</span> <span class="p">(</span><span class="n">dma_wd</span><span class="p">.</span><span class="n">dma_hi</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="n">MFPDELAY</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="n">addr</span> <span class="o">!=</span> <span class="n">addr2</span><span class="p">);</span>
  
	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&gt;=</span> <span class="n">PhysTrackBuffer</span> <span class="o">+</span> <span class="n">SUDT</span><span class="o">-&gt;</span><span class="n">spt</span><span class="o">*</span><span class="mi">512</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* already read enough data, force an FDC interrupt to stop</span>
<span class="cm">		 * the read operation</span>
<span class="cm">		 */</span>
		<span class="n">SET_IRQ_HANDLER</span><span class="p">(</span> <span class="nb">NULL</span> <span class="p">);</span>
		<span class="n">MultReadInProgress</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;fd_readtrack_check(): done</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
		<span class="n">FDC_WRITE</span><span class="p">(</span> <span class="n">FDCREG_CMD</span><span class="p">,</span> <span class="n">FDCCMD_FORCI</span> <span class="p">);</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">25</span><span class="p">);</span>

		<span class="cm">/* No error until now -- the FDC would have interrupted</span>
<span class="cm">		 * otherwise!</span>
<span class="cm">		 */</span>
		<span class="n">fd_rwsec_done1</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* not yet finished, wait another tenth rotation */</span>
		<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;fd_readtrack_check(): not yet finished</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
		<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">readtrack_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">HZ</span><span class="o">/</span><span class="mi">5</span><span class="o">/</span><span class="mi">10</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">fd_rwsec_done</span><span class="p">(</span> <span class="kt">int</span> <span class="n">status</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;fd_rwsec_done()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">read_track</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">readtrack_timer</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">MultReadInProgress</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="n">MultReadInProgress</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">fd_rwsec_done1</span><span class="p">(</span><span class="n">status</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fd_rwsec_done1</span><span class="p">(</span><span class="kt">int</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">track</span><span class="p">;</span>

	<span class="n">stop_timeout</span><span class="p">();</span>
	
	<span class="cm">/* Correct the track if stretch != 0 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">SUDT</span><span class="o">-&gt;</span><span class="n">stretch</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">track</span> <span class="o">=</span> <span class="n">FDC_READ</span><span class="p">(</span> <span class="n">FDCREG_TRACK</span><span class="p">);</span>
		<span class="n">MFPDELAY</span><span class="p">();</span>
		<span class="n">FDC_WRITE</span><span class="p">(</span> <span class="n">FDCREG_TRACK</span><span class="p">,</span> <span class="n">track</span> <span class="o">&lt;&lt;</span> <span class="n">SUDT</span><span class="o">-&gt;</span><span class="n">stretch</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">UseTrackbuffer</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dma_wd</span><span class="p">.</span><span class="n">dma_mode_status</span> <span class="o">=</span> <span class="mh">0x90</span><span class="p">;</span>
		<span class="n">MFPDELAY</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">dma_wd</span><span class="p">.</span><span class="n">dma_mode_status</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;fd%d: DMA error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">SelectedDrive</span> <span class="p">);</span>
			<span class="k">goto</span> <span class="n">err_end</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">MFPDELAY</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ReqCmd</span> <span class="o">==</span> <span class="n">WRITE</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">FDCSTAT_WPROT</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;fd%d: is write protected</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">SelectedDrive</span> <span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_end</span><span class="p">;</span>
	<span class="p">}</span>	
	<span class="k">if</span> <span class="p">((</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">FDCSTAT_RECNF</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="cm">/* RECNF is no error after a multiple read when the FDC</span>
<span class="cm">	       searched for a non-existent sector! */</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">read_track</span> <span class="o">&amp;&amp;</span> <span class="n">FDC_READ</span><span class="p">(</span><span class="n">FDCREG_SECTOR</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">SUDT</span><span class="o">-&gt;</span><span class="n">spt</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">Probing</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">SUDT</span> <span class="o">&gt;</span> <span class="n">atari_disk_type</span><span class="p">)</span> <span class="p">{</span>
			    <span class="k">if</span> <span class="p">(</span><span class="n">SUDT</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">blocks</span> <span class="o">&gt;</span> <span class="n">ReqBlock</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* try another disk type */</span>
				<span class="n">SUDT</span><span class="o">--</span><span class="p">;</span>
				<span class="n">set_capacity</span><span class="p">(</span><span class="n">unit</span><span class="p">[</span><span class="n">SelectedDrive</span><span class="p">].</span><span class="n">disk</span><span class="p">,</span>
							<span class="n">SUDT</span><span class="o">-&gt;</span><span class="n">blocks</span><span class="p">);</span>
			    <span class="p">}</span> <span class="k">else</span>
				<span class="n">Probing</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">SUD</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FTD_MSG</span><span class="p">)</span>
					<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;fd%d: Auto-detected floppy type %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					       <span class="n">SelectedDrive</span><span class="p">,</span> <span class="n">SUDT</span><span class="o">-&gt;</span><span class="n">name</span> <span class="p">);</span>
				<span class="n">Probing</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>	
<span class="cm">/* record not found, but not probing. Maybe stretch wrong ? Restart probing */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">SUD</span><span class="p">.</span><span class="n">autoprobe</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">SUDT</span> <span class="o">=</span> <span class="n">atari_disk_type</span> <span class="o">+</span> <span class="n">StartDiskType</span><span class="p">[</span><span class="n">DriveType</span><span class="p">];</span>
				<span class="n">set_capacity</span><span class="p">(</span><span class="n">unit</span><span class="p">[</span><span class="n">SelectedDrive</span><span class="p">].</span><span class="n">disk</span><span class="p">,</span>
							<span class="n">SUDT</span><span class="o">-&gt;</span><span class="n">blocks</span><span class="p">);</span>
				<span class="n">Probing</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">Probing</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ATARIHW_PRESENT</span><span class="p">(</span><span class="n">FDCSPEED</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">dma_wd</span><span class="p">.</span><span class="n">fdc_speed</span> <span class="o">=</span> <span class="n">SUDT</span><span class="o">-&gt;</span><span class="n">fdc_speed</span><span class="p">;</span>
				<span class="n">MFPDELAY</span><span class="p">();</span>
			<span class="p">}</span>
			<span class="n">setup_req_params</span><span class="p">(</span> <span class="n">SelectedDrive</span> <span class="p">);</span>
			<span class="n">BufferDrive</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="n">do_fd_action</span><span class="p">(</span> <span class="n">SelectedDrive</span> <span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;fd%d: sector %d not found (side %d, track %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">SelectedDrive</span><span class="p">,</span> <span class="n">FDC_READ</span> <span class="p">(</span><span class="n">FDCREG_SECTOR</span><span class="p">),</span> <span class="n">ReqSide</span><span class="p">,</span> <span class="n">ReqTrack</span> <span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_end</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">FDCSTAT_CRC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;fd%d: CRC error (side %d, track %d, sector %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">SelectedDrive</span><span class="p">,</span> <span class="n">ReqSide</span><span class="p">,</span> <span class="n">ReqTrack</span><span class="p">,</span> <span class="n">FDC_READ</span> <span class="p">(</span><span class="n">FDCREG_SECTOR</span><span class="p">)</span> <span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_end</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">FDCSTAT_LOST</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;fd%d: lost data (side %d, track %d, sector %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">SelectedDrive</span><span class="p">,</span> <span class="n">ReqSide</span><span class="p">,</span> <span class="n">ReqTrack</span><span class="p">,</span> <span class="n">FDC_READ</span> <span class="p">(</span><span class="n">FDCREG_SECTOR</span><span class="p">)</span> <span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_end</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">Probing</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="n">ReqCmd</span> <span class="o">==</span> <span class="n">READ</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">read_track</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
			<span class="n">addr</span> <span class="o">=</span> <span class="n">ATARIHW_PRESENT</span><span class="p">(</span> <span class="n">EXTD_DMA</span> <span class="p">)</span> <span class="o">?</span> <span class="n">ReqData</span> <span class="o">:</span> <span class="n">DMABuffer</span><span class="p">;</span>
			<span class="n">dma_cache_maintenance</span><span class="p">(</span> <span class="n">virt_to_phys</span><span class="p">(</span><span class="n">addr</span><span class="p">),</span> <span class="mi">512</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ATARIHW_PRESENT</span><span class="p">(</span> <span class="n">EXTD_DMA</span> <span class="p">))</span>
				<span class="n">copy_buffer</span> <span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">ReqData</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">dma_cache_maintenance</span><span class="p">(</span> <span class="n">PhysTrackBuffer</span><span class="p">,</span> <span class="n">MaxSectors</span><span class="p">[</span><span class="n">DriveType</span><span class="p">]</span> <span class="o">*</span> <span class="mi">512</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
			<span class="n">BufferDrive</span> <span class="o">=</span> <span class="n">SelectedDrive</span><span class="p">;</span>
			<span class="n">BufferSide</span>  <span class="o">=</span> <span class="n">ReqSide</span><span class="p">;</span>
			<span class="n">BufferTrack</span> <span class="o">=</span> <span class="n">ReqTrack</span><span class="p">;</span>
			<span class="n">copy_buffer</span> <span class="p">(</span><span class="n">SECTOR_BUFFER</span> <span class="p">(</span><span class="n">ReqSector</span><span class="p">),</span> <span class="n">ReqData</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
  
	<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">ReqCnt</span> <span class="o">&lt;</span> <span class="n">blk_rq_cur_sectors</span><span class="p">(</span><span class="n">fd_request</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* read next sector */</span>
		<span class="n">setup_req_params</span><span class="p">(</span> <span class="n">SelectedDrive</span> <span class="p">);</span>
		<span class="n">do_fd_action</span><span class="p">(</span> <span class="n">SelectedDrive</span> <span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* all sectors finished */</span>
		<span class="n">fd_end_request_cur</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="n">redo_fd_request</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">return</span><span class="p">;</span>
  
  <span class="nl">err_end:</span>
	<span class="n">BufferDrive</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">fd_error</span><span class="p">();</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">fd_writetrack</span><span class="p">(</span> <span class="kt">void</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">paddr</span><span class="p">,</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">track</span><span class="p">;</span>
	
	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;fd_writetrack() Tr=%d Si=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ReqTrack</span><span class="p">,</span> <span class="n">ReqSide</span> <span class="p">));</span>

	<span class="n">paddr</span> <span class="o">=</span> <span class="n">PhysTrackBuffer</span><span class="p">;</span>
	<span class="n">dma_cache_maintenance</span><span class="p">(</span> <span class="n">paddr</span><span class="p">,</span> <span class="n">BUFFER_SIZE</span><span class="p">,</span> <span class="mi">1</span> <span class="p">);</span>

	<span class="n">fd_select_side</span><span class="p">(</span> <span class="n">ReqSide</span> <span class="p">);</span>
  
	<span class="cm">/* Cheat for track if stretch != 0 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">SUDT</span><span class="o">-&gt;</span><span class="n">stretch</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">track</span> <span class="o">=</span> <span class="n">FDC_READ</span><span class="p">(</span> <span class="n">FDCREG_TRACK</span><span class="p">);</span>
		<span class="n">MFPDELAY</span><span class="p">();</span>
		<span class="n">FDC_WRITE</span><span class="p">(</span><span class="n">FDCREG_TRACK</span><span class="p">,</span><span class="n">track</span> <span class="o">&gt;&gt;</span> <span class="n">SUDT</span><span class="o">-&gt;</span><span class="n">stretch</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">40</span><span class="p">);</span>
  
	<span class="cm">/* Setup DMA */</span>
	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">dma_wd</span><span class="p">.</span><span class="n">dma_lo</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span><span class="n">paddr</span><span class="p">;</span>
	<span class="n">MFPDELAY</span><span class="p">();</span>
	<span class="n">paddr</span> <span class="o">&gt;&gt;=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">dma_wd</span><span class="p">.</span><span class="n">dma_md</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span><span class="n">paddr</span><span class="p">;</span>
	<span class="n">MFPDELAY</span><span class="p">();</span>
	<span class="n">paddr</span> <span class="o">&gt;&gt;=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ATARIHW_PRESENT</span><span class="p">(</span> <span class="n">EXTD_DMA</span> <span class="p">))</span>
		<span class="n">st_dma_ext_dmahi</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span><span class="p">)</span><span class="n">paddr</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">dma_wd</span><span class="p">.</span><span class="n">dma_hi</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span><span class="n">paddr</span><span class="p">;</span>
	<span class="n">MFPDELAY</span><span class="p">();</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
  
	<span class="cm">/* Clear FIFO and switch DMA to correct mode */</span>  
	<span class="n">dma_wd</span><span class="p">.</span><span class="n">dma_mode_status</span> <span class="o">=</span> <span class="mh">0x190</span><span class="p">;</span>  
	<span class="n">MFPDELAY</span><span class="p">();</span>
	<span class="n">dma_wd</span><span class="p">.</span><span class="n">dma_mode_status</span> <span class="o">=</span> <span class="mh">0x90</span><span class="p">;</span>  
	<span class="n">MFPDELAY</span><span class="p">();</span>
	<span class="n">dma_wd</span><span class="p">.</span><span class="n">dma_mode_status</span> <span class="o">=</span> <span class="mh">0x190</span><span class="p">;</span>
	<span class="n">MFPDELAY</span><span class="p">();</span>
  
	<span class="cm">/* How many sectors for DMA */</span>
	<span class="n">dma_wd</span><span class="p">.</span><span class="n">fdc_acces_seccount</span> <span class="o">=</span> <span class="n">BUFFER_SIZE</span><span class="o">/</span><span class="mi">512</span><span class="p">;</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">40</span><span class="p">);</span>  
  
	<span class="cm">/* Start operation */</span>
	<span class="n">dma_wd</span><span class="p">.</span><span class="n">dma_mode_status</span> <span class="o">=</span> <span class="n">FDCSELREG_STP</span> <span class="o">|</span> <span class="mh">0x100</span><span class="p">;</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">40</span><span class="p">);</span>
	<span class="n">SET_IRQ_HANDLER</span><span class="p">(</span> <span class="n">fd_writetrack_done</span> <span class="p">);</span>
	<span class="n">dma_wd</span><span class="p">.</span><span class="n">fdc_acces_seccount</span> <span class="o">=</span> <span class="n">FDCCMD_WRTRA</span> <span class="o">|</span> <span class="n">get_head_settle_flag</span><span class="p">();</span> 

	<span class="n">MotorOn</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">start_timeout</span><span class="p">();</span>
	<span class="cm">/* wait for interrupt */</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">fd_writetrack_done</span><span class="p">(</span> <span class="kt">int</span> <span class="n">status</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;fd_writetrack_done()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>

	<span class="n">stop_timeout</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">FDCSTAT_WPROT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;fd%d: is write protected</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">SelectedDrive</span> <span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_end</span><span class="p">;</span>
	<span class="p">}</span>	
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">FDCSTAT_LOST</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;fd%d: lost data (side %d, track %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">SelectedDrive</span><span class="p">,</span> <span class="n">ReqSide</span><span class="p">,</span> <span class="n">ReqTrack</span> <span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_end</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">wake_up</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">format_wait</span> <span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>

  <span class="nl">err_end:</span>
	<span class="n">fd_error</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fd_times_out</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dummy</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="n">atari_disable_irq</span><span class="p">(</span> <span class="n">IRQ_MFP_FDC</span> <span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">FloppyIRQHandler</span><span class="p">)</span> <span class="k">goto</span> <span class="n">end</span><span class="p">;</span> <span class="cm">/* int occurred after timer was fired, but</span>
<span class="cm">					  * before we came here... */</span>

	<span class="n">SET_IRQ_HANDLER</span><span class="p">(</span> <span class="nb">NULL</span> <span class="p">);</span>
	<span class="cm">/* If the timeout occurred while the readtrack_check timer was</span>
<span class="cm">	 * active, we need to cancel it, else bad things will happen */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">UseTrackbuffer</span><span class="p">)</span>
		<span class="n">del_timer</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">readtrack_timer</span> <span class="p">);</span>
	<span class="n">FDC_WRITE</span><span class="p">(</span> <span class="n">FDCREG_CMD</span><span class="p">,</span> <span class="n">FDCCMD_FORCI</span> <span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span> <span class="mi">25</span> <span class="p">);</span>
	
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;floppy timeout</span><span class="se">\n</span><span class="s">&quot;</span> <span class="p">);</span>
	<span class="n">fd_error</span><span class="p">();</span>
  <span class="nl">end:</span>
	<span class="n">atari_enable_irq</span><span class="p">(</span> <span class="n">IRQ_MFP_FDC</span> <span class="p">);</span>
<span class="p">}</span>


<span class="cm">/* The (noop) seek operation here is needed to make the WP bit in the</span>
<span class="cm"> * FDC status register accessible for check_change. If the last disk</span>
<span class="cm"> * operation would have been a RDSEC, this bit would always read as 0</span>
<span class="cm"> * no matter what :-( To save time, the seek goes to the track we&#39;re</span>
<span class="cm"> * already on.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">finish_fdc</span><span class="p">(</span> <span class="kt">void</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">NeedSeek</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">finish_fdc_done</span><span class="p">(</span> <span class="mi">0</span> <span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;finish_fdc: dummy seek started</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
		<span class="n">FDC_WRITE</span> <span class="p">(</span><span class="n">FDCREG_DATA</span><span class="p">,</span> <span class="n">SUD</span><span class="p">.</span><span class="n">track</span><span class="p">);</span>
		<span class="n">SET_IRQ_HANDLER</span><span class="p">(</span> <span class="n">finish_fdc_done</span> <span class="p">);</span>
		<span class="n">FDC_WRITE</span> <span class="p">(</span><span class="n">FDCREG_CMD</span><span class="p">,</span> <span class="n">FDCCMD_SEEK</span><span class="p">);</span>
		<span class="n">MotorOn</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">start_timeout</span><span class="p">();</span>
		<span class="cm">/* we must wait for the IRQ here, because the ST-DMA</span>
<span class="cm">		   is released immediately afterwards and the interrupt</span>
<span class="cm">		   may be delivered to the wrong driver. */</span>
	  <span class="p">}</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">finish_fdc_done</span><span class="p">(</span> <span class="kt">int</span> <span class="n">dummy</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;finish_fdc_done entered</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
	<span class="n">stop_timeout</span><span class="p">();</span>
	<span class="n">NeedSeek</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">timer_pending</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fd_timer</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">time_before</span><span class="p">(</span><span class="n">fd_timer</span><span class="p">.</span><span class="n">expires</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="mi">5</span><span class="p">))</span>
		<span class="cm">/* If the check for a disk change is done too early after this</span>
<span class="cm">		 * last seek command, the WP bit still reads wrong :-((</span>
<span class="cm">		 */</span>
		<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fd_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="mi">5</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">start_check_change_timer</span><span class="p">();</span>
	<span class="n">start_motor_off_timer</span><span class="p">();</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">stdma_release</span><span class="p">();</span>
	<span class="n">fdc_busy</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">wake_up</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">fdc_wait</span> <span class="p">);</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;finish_fdc() finished</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* The detection of disk changes is a dark chapter in Atari history :-(</span>
<span class="cm"> * Because the &quot;Drive ready&quot; signal isn&#39;t present in the Atari</span>
<span class="cm"> * hardware, one has to rely on the &quot;Write Protect&quot;. This works fine,</span>
<span class="cm"> * as long as no write protected disks are used. TOS solves this</span>
<span class="cm"> * problem by introducing tri-state logic (&quot;maybe changed&quot;) and</span>
<span class="cm"> * looking at the serial number in block 0. This isn&#39;t possible for</span>
<span class="cm"> * Linux, since the floppy driver can&#39;t make assumptions about the</span>
<span class="cm"> * filesystem used on the disk and thus the contents of block 0. I&#39;ve</span>
<span class="cm"> * chosen the method to always say &quot;The disk was changed&quot; if it is</span>
<span class="cm"> * unsure whether it was. This implies that every open or mount</span>
<span class="cm"> * invalidates the disk buffers if you work with write protected</span>
<span class="cm"> * disks. But at least this is better than working with incorrect data</span>
<span class="cm"> * due to unrecognised disk changes.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">floppy_check_events</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">clearing</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">atari_floppy_struct</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">disk</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">drive</span> <span class="o">=</span> <span class="n">p</span> <span class="o">-</span> <span class="n">unit</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span> <span class="p">(</span><span class="n">drive</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fake_change</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* simulated change (e.g. after formatting) */</span>
		<span class="k">return</span> <span class="n">DISK_EVENT_MEDIA_CHANGE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span> <span class="p">(</span><span class="n">drive</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">changed_floppies</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* surely changed (the WP signal changed at least once) */</span>
		<span class="k">return</span> <span class="n">DISK_EVENT_MEDIA_CHANGE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">UD</span><span class="p">.</span><span class="n">wpstat</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* WP is on -&gt; could be changed: to be sure, buffers should be</span>
<span class="cm">		 * invalidated...</span>
<span class="cm">		 */</span>
		<span class="k">return</span> <span class="n">DISK_EVENT_MEDIA_CHANGE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">floppy_revalidate</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">atari_floppy_struct</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">disk</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">drive</span> <span class="o">=</span> <span class="n">p</span> <span class="o">-</span> <span class="n">unit</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">drive</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">changed_floppies</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">test_bit</span><span class="p">(</span><span class="n">drive</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fake_change</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">p</span><span class="o">-&gt;</span><span class="n">disktype</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">UD</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FTD_MSG</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;floppy: clear format %p!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">UDT</span><span class="p">);</span>
		<span class="n">BufferDrive</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">drive</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fake_change</span><span class="p">);</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">drive</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">changed_floppies</span><span class="p">);</span>
		<span class="cm">/* MSch: clearing geometry makes sense only for autoprobe</span>
<span class="cm">		   formats, for &#39;permanent user-defined&#39; parameter:</span>
<span class="cm">		   restore default_params[] here if flagged valid! */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">default_params</span><span class="p">[</span><span class="n">drive</span><span class="p">].</span><span class="n">blocks</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">UDT</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">UDT</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">default_params</span><span class="p">[</span><span class="n">drive</span><span class="p">];</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* This sets up the global variables describing the current request. */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">setup_req_params</span><span class="p">(</span> <span class="kt">int</span> <span class="n">drive</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">block</span> <span class="o">=</span> <span class="n">ReqBlock</span> <span class="o">+</span> <span class="n">ReqCnt</span><span class="p">;</span>

	<span class="n">ReqTrack</span> <span class="o">=</span> <span class="n">block</span> <span class="o">/</span> <span class="n">UDT</span><span class="o">-&gt;</span><span class="n">spt</span><span class="p">;</span>
	<span class="n">ReqSector</span> <span class="o">=</span> <span class="n">block</span> <span class="o">-</span> <span class="n">ReqTrack</span> <span class="o">*</span> <span class="n">UDT</span><span class="o">-&gt;</span><span class="n">spt</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ReqSide</span> <span class="o">=</span> <span class="n">ReqTrack</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ReqTrack</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ReqData</span> <span class="o">=</span> <span class="n">ReqBuffer</span> <span class="o">+</span> <span class="mi">512</span> <span class="o">*</span> <span class="n">ReqCnt</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">UseTrackbuffer</span><span class="p">)</span>
		<span class="n">read_track</span> <span class="o">=</span> <span class="p">(</span><span class="n">ReqCmd</span> <span class="o">==</span> <span class="n">READ</span> <span class="o">&amp;&amp;</span> <span class="n">fd_request</span><span class="o">-&gt;</span><span class="n">errors</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">read_track</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;Request params: Si=%d Tr=%d Se=%d Data=%08lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">ReqSide</span><span class="p">,</span>
			<span class="n">ReqTrack</span><span class="p">,</span> <span class="n">ReqSector</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ReqData</span> <span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Round-robin between our available drives, doing one request from each</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="nf">set_next_request</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">old_pos</span> <span class="o">=</span> <span class="n">fdc_queue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">q</span> <span class="o">=</span> <span class="n">unit</span><span class="p">[</span><span class="n">fdc_queue</span><span class="p">].</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">fdc_queue</span> <span class="o">==</span> <span class="n">FD_MAX_UNITS</span><span class="p">)</span>
			<span class="n">fdc_queue</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rq</span> <span class="o">=</span> <span class="n">blk_fetch_request</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">fdc_queue</span> <span class="o">!=</span> <span class="n">old_pos</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rq</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">redo_fd_request</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">drive</span><span class="p">,</span> <span class="n">type</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">atari_floppy_struct</span> <span class="o">*</span><span class="n">floppy</span><span class="p">;</span>

	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;redo_fd_request: fd_request=%p dev=%s fd_request-&gt;sector=%ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">fd_request</span><span class="p">,</span> <span class="n">fd_request</span> <span class="o">?</span> <span class="n">fd_request</span><span class="o">-&gt;</span><span class="n">rq_disk</span><span class="o">-&gt;</span><span class="n">disk_name</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
		<span class="n">fd_request</span> <span class="o">?</span> <span class="n">blk_rq_pos</span><span class="p">(</span><span class="n">fd_request</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span> <span class="p">));</span>

	<span class="n">IsFormatting</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">repeat:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fd_request</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fd_request</span> <span class="o">=</span> <span class="n">set_next_request</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fd_request</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">the_end</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">floppy</span> <span class="o">=</span> <span class="n">fd_request</span><span class="o">-&gt;</span><span class="n">rq_disk</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="n">drive</span> <span class="o">=</span> <span class="n">floppy</span> <span class="o">-</span> <span class="n">unit</span><span class="p">;</span>
	<span class="n">type</span> <span class="o">=</span> <span class="n">floppy</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">UD</span><span class="p">.</span><span class="n">connected</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* drive not connected */</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Unknown Device: fd%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">drive</span> <span class="p">);</span>
		<span class="n">fd_end_request_cur</span><span class="p">(</span><span class="o">-</span><span class="n">EIO</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">repeat</span><span class="p">;</span>
	<span class="p">}</span>
		
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">UDT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">Probing</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">UDT</span> <span class="o">=</span> <span class="n">atari_disk_type</span> <span class="o">+</span> <span class="n">StartDiskType</span><span class="p">[</span><span class="n">DriveType</span><span class="p">];</span>
			<span class="n">set_capacity</span><span class="p">(</span><span class="n">floppy</span><span class="o">-&gt;</span><span class="n">disk</span><span class="p">,</span> <span class="n">UDT</span><span class="o">-&gt;</span><span class="n">blocks</span><span class="p">);</span>
			<span class="n">UD</span><span class="p">.</span><span class="n">autoprobe</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> 
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* user supplied disk type */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">type</span> <span class="o">&gt;=</span> <span class="n">NUM_DISK_MINORS</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;fd%d: invalid disk format&quot;</span><span class="p">,</span> <span class="n">drive</span> <span class="p">);</span>
			<span class="n">fd_end_request_cur</span><span class="p">(</span><span class="o">-</span><span class="n">EIO</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">repeat</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">minor2disktype</span><span class="p">[</span><span class="n">type</span><span class="p">].</span><span class="n">drive_types</span> <span class="o">&gt;</span> <span class="n">DriveType</span><span class="p">)</span>  <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;fd%d: unsupported disk format&quot;</span><span class="p">,</span> <span class="n">drive</span> <span class="p">);</span>
			<span class="n">fd_end_request_cur</span><span class="p">(</span><span class="o">-</span><span class="n">EIO</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">repeat</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">type</span> <span class="o">=</span> <span class="n">minor2disktype</span><span class="p">[</span><span class="n">type</span><span class="p">].</span><span class="n">index</span><span class="p">;</span>
		<span class="n">UDT</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">atari_disk_type</span><span class="p">[</span><span class="n">type</span><span class="p">];</span>
		<span class="n">set_capacity</span><span class="p">(</span><span class="n">floppy</span><span class="o">-&gt;</span><span class="n">disk</span><span class="p">,</span> <span class="n">UDT</span><span class="o">-&gt;</span><span class="n">blocks</span><span class="p">);</span>
		<span class="n">UD</span><span class="p">.</span><span class="n">autoprobe</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="n">blk_rq_pos</span><span class="p">(</span><span class="n">fd_request</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="n">UDT</span><span class="o">-&gt;</span><span class="n">blocks</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fd_end_request_cur</span><span class="p">(</span><span class="o">-</span><span class="n">EIO</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">repeat</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* stop deselect timer */</span>
	<span class="n">del_timer</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">motor_off_timer</span> <span class="p">);</span>
		
	<span class="n">ReqCnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ReqCmd</span> <span class="o">=</span> <span class="n">rq_data_dir</span><span class="p">(</span><span class="n">fd_request</span><span class="p">);</span>
	<span class="n">ReqBlock</span> <span class="o">=</span> <span class="n">blk_rq_pos</span><span class="p">(</span><span class="n">fd_request</span><span class="p">);</span>
	<span class="n">ReqBuffer</span> <span class="o">=</span> <span class="n">fd_request</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">;</span>
	<span class="n">setup_req_params</span><span class="p">(</span> <span class="n">drive</span> <span class="p">);</span>
	<span class="n">do_fd_action</span><span class="p">(</span> <span class="n">drive</span> <span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>

  <span class="nl">the_end:</span>
	<span class="n">finish_fdc</span><span class="p">();</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="nf">do_fd_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span> <span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;do_fd_request for pid %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">));</span>
	<span class="k">while</span><span class="p">(</span> <span class="n">fdc_busy</span> <span class="p">)</span> <span class="n">sleep_on</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">fdc_wait</span> <span class="p">);</span>
	<span class="n">fdc_busy</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">stdma_lock</span><span class="p">(</span><span class="n">floppy_irq</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">atari_disable_irq</span><span class="p">(</span> <span class="n">IRQ_MFP_FDC</span> <span class="p">);</span>
	<span class="n">redo_fd_request</span><span class="p">();</span>
	<span class="n">atari_enable_irq</span><span class="p">(</span> <span class="n">IRQ_MFP_FDC</span> <span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fd_locked_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span> <span class="n">fmode_t</span> <span class="n">mode</span><span class="p">,</span>
		    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">param</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span> <span class="o">=</span> <span class="n">bdev</span><span class="o">-&gt;</span><span class="n">bd_disk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">atari_floppy_struct</span> <span class="o">*</span><span class="n">floppy</span> <span class="o">=</span> <span class="n">disk</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">drive</span> <span class="o">=</span> <span class="n">floppy</span> <span class="o">-</span> <span class="n">unit</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">type</span> <span class="o">=</span> <span class="n">floppy</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">atari_format_descr</span> <span class="n">fmt_desc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">atari_disk_type</span> <span class="o">*</span><span class="n">dtp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">floppy_struct</span> <span class="n">getprm</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">settype</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">floppy_struct</span> <span class="n">setprm</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">argp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">param</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">FDGETPRM</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">type</span> <span class="o">&gt;=</span> <span class="n">NUM_DISK_MINORS</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">minor2disktype</span><span class="p">[</span><span class="n">type</span><span class="p">].</span><span class="n">drive_types</span> <span class="o">&gt;</span> <span class="n">DriveType</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
			<span class="n">type</span> <span class="o">=</span> <span class="n">minor2disktype</span><span class="p">[</span><span class="n">type</span><span class="p">].</span><span class="n">index</span><span class="p">;</span>
			<span class="n">dtp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">atari_disk_type</span><span class="p">[</span><span class="n">type</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">UD</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FTD_MSG</span><span class="p">)</span>
			    <span class="n">printk</span> <span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;floppy%d: found dtp %p name %s!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			        <span class="n">drive</span><span class="p">,</span> <span class="n">dtp</span><span class="p">,</span> <span class="n">dtp</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">UDT</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">dtp</span> <span class="o">=</span> <span class="n">UDT</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">memset</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">getprm</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">getprm</span><span class="p">));</span>
		<span class="n">getprm</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">dtp</span><span class="o">-&gt;</span><span class="n">blocks</span><span class="p">;</span>
		<span class="n">getprm</span><span class="p">.</span><span class="n">sect</span> <span class="o">=</span> <span class="n">dtp</span><span class="o">-&gt;</span><span class="n">spt</span><span class="p">;</span>
		<span class="n">getprm</span><span class="p">.</span><span class="n">head</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">getprm</span><span class="p">.</span><span class="n">track</span> <span class="o">=</span> <span class="n">dtp</span><span class="o">-&gt;</span><span class="n">blocks</span><span class="o">/</span><span class="n">dtp</span><span class="o">-&gt;</span><span class="n">spt</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
		<span class="n">getprm</span><span class="p">.</span><span class="n">stretch</span> <span class="o">=</span> <span class="n">dtp</span><span class="o">-&gt;</span><span class="n">stretch</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">argp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">getprm</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">getprm</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">FDSETPRM</span>:
	<span class="k">case</span> <span class="n">FDDEFPRM</span>:
	        <span class="cm">/* </span>
<span class="cm">		 * MSch 7/96: simple &#39;set geometry&#39; case: just set the</span>
<span class="cm">		 * &#39;default&#39; device params (minor == 0).</span>
<span class="cm">		 * Currently, the drive geometry is cleared after each</span>
<span class="cm">		 * disk change and subsequent revalidate()! simple</span>
<span class="cm">		 * implementation of FDDEFPRM: save geometry from a</span>
<span class="cm">		 * FDDEFPRM call and restore it in floppy_revalidate() !</span>
<span class="cm">		 */</span>

		<span class="cm">/* get the parameters from user space */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">floppy</span><span class="o">-&gt;</span><span class="n">ref</span> <span class="o">!=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">floppy</span><span class="o">-&gt;</span><span class="n">ref</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">setprm</span><span class="p">,</span> <span class="n">argp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">setprm</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="cm">/* </span>
<span class="cm">		 * first of all: check for floppy change and revalidate, </span>
<span class="cm">		 * or the next access will revalidate - and clear UDT :-(</span>
<span class="cm">		 */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">floppy_check_events</span><span class="p">(</span><span class="n">disk</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
		        <span class="n">floppy_revalidate</span><span class="p">(</span><span class="n">disk</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">UD</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FTD_MSG</span><span class="p">)</span>
		    <span class="n">printk</span> <span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;floppy%d: setting size %d spt %d str %d!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">drive</span><span class="p">,</span> <span class="n">setprm</span><span class="p">.</span><span class="n">size</span><span class="p">,</span> <span class="n">setprm</span><span class="p">.</span><span class="n">sect</span><span class="p">,</span> <span class="n">setprm</span><span class="p">.</span><span class="n">stretch</span><span class="p">);</span>

		<span class="cm">/* what if type &gt; 0 here? Overwrite specified entry ? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
		        <span class="cm">/* refuse to re-set a predefined type for now */</span>
			<span class="n">redo_fd_request</span><span class="p">();</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* </span>
<span class="cm">		 * type == 0: first look for a matching entry in the type list,</span>
<span class="cm">		 * and set the UD.disktype field to use the perdefined entry.</span>
<span class="cm">		 * TODO: add user-defined format to head of autoprobe list ? </span>
<span class="cm">		 * Useful to include the user-type for future autodetection!</span>
<span class="cm">		 */</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">settype</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">settype</span> <span class="o">&lt;</span> <span class="n">NUM_DISK_MINORS</span><span class="p">;</span> <span class="n">settype</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">setidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">minor2disktype</span><span class="p">[</span><span class="n">settype</span><span class="p">].</span><span class="n">drive_types</span> <span class="o">&gt;</span> <span class="n">DriveType</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* skip this one, invalid for drive ... */</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">setidx</span> <span class="o">=</span> <span class="n">minor2disktype</span><span class="p">[</span><span class="n">settype</span><span class="p">].</span><span class="n">index</span><span class="p">;</span>
			<span class="n">dtp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">atari_disk_type</span><span class="p">[</span><span class="n">setidx</span><span class="p">];</span>

			<span class="cm">/* found matching entry ?? */</span>
			<span class="k">if</span> <span class="p">(</span>   <span class="n">dtp</span><span class="o">-&gt;</span><span class="n">blocks</span>  <span class="o">==</span> <span class="n">setprm</span><span class="p">.</span><span class="n">size</span> 
			    <span class="o">&amp;&amp;</span> <span class="n">dtp</span><span class="o">-&gt;</span><span class="n">spt</span>     <span class="o">==</span> <span class="n">setprm</span><span class="p">.</span><span class="n">sect</span>
			    <span class="o">&amp;&amp;</span> <span class="n">dtp</span><span class="o">-&gt;</span><span class="n">stretch</span> <span class="o">==</span> <span class="n">setprm</span><span class="p">.</span><span class="n">stretch</span> <span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">UD</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FTD_MSG</span><span class="p">)</span>
				    <span class="n">printk</span> <span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;floppy%d: setting %s %p!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				        <span class="n">drive</span><span class="p">,</span> <span class="n">dtp</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">dtp</span><span class="p">);</span>
				<span class="n">UDT</span> <span class="o">=</span> <span class="n">dtp</span><span class="p">;</span>
				<span class="n">set_capacity</span><span class="p">(</span><span class="n">floppy</span><span class="o">-&gt;</span><span class="n">disk</span><span class="p">,</span> <span class="n">UDT</span><span class="o">-&gt;</span><span class="n">blocks</span><span class="p">);</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">FDDEFPRM</span><span class="p">)</span> <span class="p">{</span>
				  <span class="cm">/* save settings as permanent default type */</span>
				  <span class="n">default_params</span><span class="p">[</span><span class="n">drive</span><span class="p">].</span><span class="n">name</span>    <span class="o">=</span> <span class="n">dtp</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
				  <span class="n">default_params</span><span class="p">[</span><span class="n">drive</span><span class="p">].</span><span class="n">spt</span>     <span class="o">=</span> <span class="n">dtp</span><span class="o">-&gt;</span><span class="n">spt</span><span class="p">;</span>
				  <span class="n">default_params</span><span class="p">[</span><span class="n">drive</span><span class="p">].</span><span class="n">blocks</span>  <span class="o">=</span> <span class="n">dtp</span><span class="o">-&gt;</span><span class="n">blocks</span><span class="p">;</span>
				  <span class="n">default_params</span><span class="p">[</span><span class="n">drive</span><span class="p">].</span><span class="n">fdc_speed</span> <span class="o">=</span> <span class="n">dtp</span><span class="o">-&gt;</span><span class="n">fdc_speed</span><span class="p">;</span>
				  <span class="n">default_params</span><span class="p">[</span><span class="n">drive</span><span class="p">].</span><span class="n">stretch</span> <span class="o">=</span> <span class="n">dtp</span><span class="o">-&gt;</span><span class="n">stretch</span><span class="p">;</span>
				<span class="p">}</span>
				
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>

		<span class="p">}</span>

		<span class="cm">/* no matching disk type found above - setting user_params */</span>

	       	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">FDDEFPRM</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* set permanent type */</span>
			<span class="n">dtp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">default_params</span><span class="p">[</span><span class="n">drive</span><span class="p">];</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="cm">/* set user type (reset by disk change!) */</span>
			<span class="n">dtp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">user_params</span><span class="p">[</span><span class="n">drive</span><span class="p">];</span>

		<span class="n">dtp</span><span class="o">-&gt;</span><span class="n">name</span>   <span class="o">=</span> <span class="s">&quot;user format&quot;</span><span class="p">;</span>
		<span class="n">dtp</span><span class="o">-&gt;</span><span class="n">blocks</span> <span class="o">=</span> <span class="n">setprm</span><span class="p">.</span><span class="n">size</span><span class="p">;</span>
		<span class="n">dtp</span><span class="o">-&gt;</span><span class="n">spt</span>    <span class="o">=</span> <span class="n">setprm</span><span class="p">.</span><span class="n">sect</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">setprm</span><span class="p">.</span><span class="n">sect</span> <span class="o">&gt;</span> <span class="mi">14</span><span class="p">)</span> 
			<span class="n">dtp</span><span class="o">-&gt;</span><span class="n">fdc_speed</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">dtp</span><span class="o">-&gt;</span><span class="n">fdc_speed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">dtp</span><span class="o">-&gt;</span><span class="n">stretch</span> <span class="o">=</span> <span class="n">setprm</span><span class="p">.</span><span class="n">stretch</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">UD</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FTD_MSG</span><span class="p">)</span>
			<span class="n">printk</span> <span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;floppy%d: blk %d spt %d str %d!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">drive</span><span class="p">,</span> <span class="n">dtp</span><span class="o">-&gt;</span><span class="n">blocks</span><span class="p">,</span> <span class="n">dtp</span><span class="o">-&gt;</span><span class="n">spt</span><span class="p">,</span> <span class="n">dtp</span><span class="o">-&gt;</span><span class="n">stretch</span><span class="p">);</span>

		<span class="cm">/* sanity check */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">setprm</span><span class="p">.</span><span class="n">track</span> <span class="o">!=</span> <span class="n">dtp</span><span class="o">-&gt;</span><span class="n">blocks</span><span class="o">/</span><span class="n">dtp</span><span class="o">-&gt;</span><span class="n">spt</span><span class="o">/</span><span class="mi">2</span> <span class="o">||</span>
		    <span class="n">setprm</span><span class="p">.</span><span class="n">head</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">redo_fd_request</span><span class="p">();</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">UDT</span> <span class="o">=</span> <span class="n">dtp</span><span class="p">;</span>
		<span class="n">set_capacity</span><span class="p">(</span><span class="n">floppy</span><span class="o">-&gt;</span><span class="n">disk</span><span class="p">,</span> <span class="n">UDT</span><span class="o">-&gt;</span><span class="n">blocks</span><span class="p">);</span>

		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">FDMSGON</span>:
		<span class="n">UD</span><span class="p">.</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">FTD_MSG</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">FDMSGOFF</span>:
		<span class="n">UD</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FTD_MSG</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">FDSETEMSGTRESH</span>:
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">FDFMTBEG</span>:
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">FDFMTTRK</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">floppy</span><span class="o">-&gt;</span><span class="n">ref</span> <span class="o">!=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">floppy</span><span class="o">-&gt;</span><span class="n">ref</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fmt_desc</span><span class="p">,</span> <span class="n">argp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">fmt_desc</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">do_format</span><span class="p">(</span><span class="n">drive</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fmt_desc</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">FDCLRPRM</span>:
		<span class="n">UDT</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="cm">/* MSch: invalidate default_params */</span>
		<span class="n">default_params</span><span class="p">[</span><span class="n">drive</span><span class="p">].</span><span class="n">blocks</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">set_capacity</span><span class="p">(</span><span class="n">floppy</span><span class="o">-&gt;</span><span class="n">disk</span><span class="p">,</span> <span class="n">MAX_DISK_SIZE</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">FDFMTEND</span>:
	<span class="k">case</span> <span class="n">FDFLUSH</span>:
		<span class="cm">/* invalidate the buffer track to force a reread */</span>
		<span class="n">BufferDrive</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">drive</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fake_change</span><span class="p">);</span>
		<span class="n">check_disk_change</span><span class="p">(</span><span class="n">bdev</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fd_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span> <span class="n">fmode_t</span> <span class="n">mode</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ataflop_mutex</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">fd_locked_ioctl</span><span class="p">(</span><span class="n">bdev</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ataflop_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Initialize the &#39;unit&#39; variable for drive &#39;drive&#39; */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">fd_probe</span><span class="p">(</span> <span class="kt">int</span> <span class="n">drive</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="n">UD</span><span class="p">.</span><span class="n">connected</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">UDT</span>  <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fd_test_drive_present</span><span class="p">(</span> <span class="n">drive</span> <span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">UD</span><span class="p">.</span><span class="n">connected</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">UD</span><span class="p">.</span><span class="n">track</span>     <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">switch</span><span class="p">(</span> <span class="n">UserSteprate</span><span class="p">[</span><span class="n">drive</span><span class="p">]</span> <span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">2</span>:
		<span class="n">UD</span><span class="p">.</span><span class="n">steprate</span> <span class="o">=</span> <span class="n">FDCSTEP_2</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">3</span>:
		<span class="n">UD</span><span class="p">.</span><span class="n">steprate</span> <span class="o">=</span> <span class="n">FDCSTEP_3</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">6</span>:
		<span class="n">UD</span><span class="p">.</span><span class="n">steprate</span> <span class="o">=</span> <span class="n">FDCSTEP_6</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">12</span>:
		<span class="n">UD</span><span class="p">.</span><span class="n">steprate</span> <span class="o">=</span> <span class="n">FDCSTEP_12</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span> <span class="cm">/* should be -1 for &quot;not set by user&quot; */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ATARIHW_PRESENT</span><span class="p">(</span> <span class="n">FDCSPEED</span> <span class="p">)</span> <span class="o">||</span> <span class="n">MACH_IS_MEDUSA</span><span class="p">)</span>
			<span class="n">UD</span><span class="p">.</span><span class="n">steprate</span> <span class="o">=</span> <span class="n">FDCSTEP_3</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">UD</span><span class="p">.</span><span class="n">steprate</span> <span class="o">=</span> <span class="n">FDCSTEP_6</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">MotorOn</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* from probe restore operation! */</span>
<span class="p">}</span>


<span class="cm">/* This function tests the physical presence of a floppy drive (not</span>
<span class="cm"> * whether a disk is inserted). This is done by issuing a restore</span>
<span class="cm"> * command, waiting max. 2 seconds (that should be enough to move the</span>
<span class="cm"> * head across the whole disk) and looking at the state of the &quot;TR00&quot;</span>
<span class="cm"> * signal. This should now be raised if there is a drive connected</span>
<span class="cm"> * (and there is no hardware failure :-) Otherwise, the drive is</span>
<span class="cm"> * declared absent.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">fd_test_drive_present</span><span class="p">(</span> <span class="kt">int</span> <span class="n">drive</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ok</span><span class="p">;</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="n">drive</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">MACH_IS_FALCON</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">2</span><span class="p">))</span> <span class="k">return</span><span class="p">(</span> <span class="mi">0</span> <span class="p">);</span>
	<span class="n">fd_select_drive</span><span class="p">(</span> <span class="n">drive</span> <span class="p">);</span>

	<span class="cm">/* disable interrupt temporarily */</span>
	<span class="n">atari_turnoff_irq</span><span class="p">(</span> <span class="n">IRQ_MFP_FDC</span> <span class="p">);</span>
	<span class="n">FDC_WRITE</span> <span class="p">(</span><span class="n">FDCREG_TRACK</span><span class="p">,</span> <span class="mh">0xff00</span><span class="p">);</span>
	<span class="n">FDC_WRITE</span><span class="p">(</span> <span class="n">FDCREG_CMD</span><span class="p">,</span> <span class="n">FDCCMD_RESTORE</span> <span class="o">|</span> <span class="n">FDCCMDADD_H</span> <span class="o">|</span> <span class="n">FDCSTEP_6</span> <span class="p">);</span>

	<span class="n">timeout</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">HZ</span><span class="o">+</span><span class="n">HZ</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">timeout</span><span class="p">))</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">st_mfp</span><span class="p">.</span><span class="n">par_dt_reg</span> <span class="o">&amp;</span> <span class="mh">0x20</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">FDC_READ</span><span class="p">(</span> <span class="n">FDCREG_STATUS</span> <span class="p">);</span>
	<span class="n">ok</span> <span class="o">=</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">FDCSTAT_TR00</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* force interrupt to abort restore operation (FDC would try</span>
<span class="cm">	 * about 50 seconds!) */</span>
	<span class="n">FDC_WRITE</span><span class="p">(</span> <span class="n">FDCREG_CMD</span><span class="p">,</span> <span class="n">FDCCMD_FORCI</span> <span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">500</span><span class="p">);</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">FDC_READ</span><span class="p">(</span> <span class="n">FDCREG_STATUS</span> <span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ok</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* dummy seek command to make WP bit accessible */</span>
		<span class="n">FDC_WRITE</span><span class="p">(</span> <span class="n">FDCREG_DATA</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
		<span class="n">FDC_WRITE</span><span class="p">(</span> <span class="n">FDCREG_CMD</span><span class="p">,</span> <span class="n">FDCCMD_SEEK</span> <span class="p">);</span>
		<span class="k">while</span><span class="p">(</span> <span class="n">st_mfp</span><span class="p">.</span><span class="n">par_dt_reg</span> <span class="o">&amp;</span> <span class="mh">0x20</span> <span class="p">)</span>
			<span class="p">;</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">FDC_READ</span><span class="p">(</span> <span class="n">FDCREG_STATUS</span> <span class="p">);</span>
	<span class="p">}</span>

	<span class="n">atari_turnon_irq</span><span class="p">(</span> <span class="n">IRQ_MFP_FDC</span> <span class="p">);</span>
	<span class="k">return</span><span class="p">(</span> <span class="n">ok</span> <span class="p">);</span>
<span class="p">}</span>


<span class="cm">/* Look how many and which kind of drives are connected. If there are</span>
<span class="cm"> * floppies, additionally start the disk-change and motor-off timers.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">config_types</span><span class="p">(</span> <span class="kt">void</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">drive</span><span class="p">,</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* for probing drives, set the FDC speed to 8 MHz */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ATARIHW_PRESENT</span><span class="p">(</span><span class="n">FDCSPEED</span><span class="p">))</span>
		<span class="n">dma_wd</span><span class="p">.</span><span class="n">fdc_speed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Probing floppy drive(s):</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">for</span><span class="p">(</span> <span class="n">drive</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">drive</span> <span class="o">&lt;</span> <span class="n">FD_MAX_UNITS</span><span class="p">;</span> <span class="n">drive</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">fd_probe</span><span class="p">(</span> <span class="n">drive</span> <span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">UD</span><span class="p">.</span><span class="n">connected</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;fd%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">drive</span><span class="p">);</span>
			<span class="o">++</span><span class="n">cnt</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">FDC_READ</span><span class="p">(</span> <span class="n">FDCREG_STATUS</span> <span class="p">)</span> <span class="o">&amp;</span> <span class="n">FDCSTAT_BUSY</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* If FDC is still busy from probing, give it another FORCI</span>
<span class="cm">		 * command to abort the operation. If this isn&#39;t done, the FDC</span>
<span class="cm">		 * will interrupt later and its IRQ line stays low, because</span>
<span class="cm">		 * the status register isn&#39;t read. And this will block any</span>
<span class="cm">		 * interrupts on this IRQ line :-(</span>
<span class="cm">		 */</span>
		<span class="n">FDC_WRITE</span><span class="p">(</span> <span class="n">FDCREG_CMD</span><span class="p">,</span> <span class="n">FDCCMD_FORCI</span> <span class="p">);</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">500</span><span class="p">);</span>
		<span class="n">FDC_READ</span><span class="p">(</span> <span class="n">FDCREG_STATUS</span> <span class="p">);</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
	<span class="p">}</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">start_motor_off_timer</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="n">fd_select_drive</span><span class="p">(</span> <span class="mi">0</span> <span class="p">);</span>
		<span class="n">start_check_change_timer</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * floppy_open check for aliasing (/dev/fd0 can be the same as</span>
<span class="cm"> * /dev/PS0 etc), and disallows simultaneous access to the same</span>
<span class="cm"> * drive with different device numbers.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">floppy_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span> <span class="n">fmode_t</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">atari_floppy_struct</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">bdev</span><span class="o">-&gt;</span><span class="n">bd_disk</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">type</span>  <span class="o">=</span> <span class="n">MINOR</span><span class="p">(</span><span class="n">bdev</span><span class="o">-&gt;</span><span class="n">bd_dev</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">;</span>

	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;fd_open: type=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">type</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ref</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">type</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ref</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ref</span> <span class="o">&amp;&amp;</span> <span class="n">mode</span> <span class="o">&amp;</span> <span class="n">FMODE_EXCL</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">FMODE_EXCL</span><span class="p">)</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">ref</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">ref</span><span class="o">++</span><span class="p">;</span>

	<span class="n">p</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">FMODE_NDELAY</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">FMODE_READ</span><span class="o">|</span><span class="n">FMODE_WRITE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">check_disk_change</span><span class="p">(</span><span class="n">bdev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">FMODE_WRITE</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">wpstat</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ref</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
					<span class="n">p</span><span class="o">-&gt;</span><span class="n">ref</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="n">p</span><span class="o">-&gt;</span><span class="n">ref</span><span class="o">--</span><span class="p">;</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">floppy_unlocked_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span> <span class="n">fmode_t</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ataflop_mutex</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">floppy_open</span><span class="p">(</span><span class="n">bdev</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ataflop_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">floppy_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">,</span> <span class="n">fmode_t</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">atari_floppy_struct</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">disk</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ataflop_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ref</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">ref</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ref</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;floppy_release with fd_ref == 0&quot;</span><span class="p">);</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">ref</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ataflop_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">block_device_operations</span> <span class="n">floppy_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">floppy_unlocked_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">floppy_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ioctl</span>		<span class="o">=</span> <span class="n">fd_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">check_events</span>	<span class="o">=</span> <span class="n">floppy_check_events</span><span class="p">,</span>
	<span class="p">.</span><span class="n">revalidate_disk</span><span class="o">=</span> <span class="n">floppy_revalidate</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="nf">floppy_find</span><span class="p">(</span><span class="n">dev_t</span> <span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">part</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">drive</span> <span class="o">=</span> <span class="o">*</span><span class="n">part</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">type</span>  <span class="o">=</span> <span class="o">*</span><span class="n">part</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">drive</span> <span class="o">&gt;=</span> <span class="n">FD_MAX_UNITS</span> <span class="o">||</span> <span class="n">type</span> <span class="o">&gt;</span> <span class="n">NUM_DISK_MINORS</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="o">*</span><span class="n">part</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">get_disk</span><span class="p">(</span><span class="n">unit</span><span class="p">[</span><span class="n">drive</span><span class="p">].</span><span class="n">disk</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">atari_floppy_init</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">MACH_IS_ATARI</span><span class="p">)</span>
		<span class="cm">/* Amiga, Mac, ... don&#39;t have Atari-compatible floppy :-) */</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">register_blkdev</span><span class="p">(</span><span class="n">FLOPPY_MAJOR</span><span class="p">,</span><span class="s">&quot;fd&quot;</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">FD_MAX_UNITS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">unit</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">disk</span> <span class="o">=</span> <span class="n">alloc_disk</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">unit</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">disk</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">Enomem</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">UseTrackbuffer</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="cm">/* not set by user -&gt; use default: for now, we turn</span>
<span class="cm">		   track buffering off for all Medusas, though it</span>
<span class="cm">		   could be used with ones that have a counter</span>
<span class="cm">		   card. But the test is too hard :-( */</span>
		<span class="n">UseTrackbuffer</span> <span class="o">=</span> <span class="o">!</span><span class="n">MACH_IS_MEDUSA</span><span class="p">;</span>

	<span class="cm">/* initialize variables */</span>
	<span class="n">SelectedDrive</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">BufferDrive</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">DMABuffer</span> <span class="o">=</span> <span class="n">atari_stram_alloc</span><span class="p">(</span><span class="n">BUFFER_SIZE</span><span class="o">+</span><span class="mi">512</span><span class="p">,</span> <span class="s">&quot;ataflop&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">DMABuffer</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;atari_floppy_init: cannot get dma buffer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">Enomem</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">TrackBuffer</span> <span class="o">=</span> <span class="n">DMABuffer</span> <span class="o">+</span> <span class="mi">512</span><span class="p">;</span>
	<span class="n">PhysDMABuffer</span> <span class="o">=</span> <span class="n">virt_to_phys</span><span class="p">(</span><span class="n">DMABuffer</span><span class="p">);</span>
	<span class="n">PhysTrackBuffer</span> <span class="o">=</span> <span class="n">virt_to_phys</span><span class="p">(</span><span class="n">TrackBuffer</span><span class="p">);</span>
	<span class="n">BufferDrive</span> <span class="o">=</span> <span class="n">BufferSide</span> <span class="o">=</span> <span class="n">BufferTrack</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">FD_MAX_UNITS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">unit</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">track</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">unit</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">unit</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">major</span> <span class="o">=</span> <span class="n">FLOPPY_MAJOR</span><span class="p">;</span>
		<span class="n">unit</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">first_minor</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">unit</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">disk_name</span><span class="p">,</span> <span class="s">&quot;fd%d&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">unit</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">fops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">floppy_fops</span><span class="p">;</span>
		<span class="n">unit</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">unit</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">unit</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">queue</span> <span class="o">=</span> <span class="n">blk_init_queue</span><span class="p">(</span><span class="n">do_fd_request</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">ataflop_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">unit</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">Enomem</span><span class="p">;</span>
		<span class="n">set_capacity</span><span class="p">(</span><span class="n">unit</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">disk</span><span class="p">,</span> <span class="n">MAX_DISK_SIZE</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
		<span class="n">add_disk</span><span class="p">(</span><span class="n">unit</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">disk</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">blk_register_region</span><span class="p">(</span><span class="n">MKDEV</span><span class="p">(</span><span class="n">FLOPPY_MAJOR</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">256</span><span class="p">,</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
				<span class="n">floppy_find</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Atari floppy driver: max. %cD, %strack buffering</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">DriveType</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="sc">&#39;D&#39;</span> <span class="o">:</span> <span class="n">DriveType</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">?</span> <span class="sc">&#39;H&#39;</span> <span class="o">:</span> <span class="sc">&#39;E&#39;</span><span class="p">,</span>
	       <span class="n">UseTrackbuffer</span> <span class="o">?</span> <span class="s">&quot;&quot;</span> <span class="o">:</span> <span class="s">&quot;no &quot;</span><span class="p">);</span>
	<span class="n">config_types</span><span class="p">();</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">Enomem:</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">unit</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">;</span>

		<span class="n">put_disk</span><span class="p">(</span><span class="n">unit</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">disk</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="p">)</span>
			<span class="n">blk_cleanup_queue</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">unregister_blkdev</span><span class="p">(</span><span class="n">FLOPPY_MAJOR</span><span class="p">,</span> <span class="s">&quot;fd&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifndef MODULE</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">atari_floppy_setup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ints</span><span class="p">[</span><span class="mi">3</span> <span class="o">+</span> <span class="n">FD_MAX_UNITS</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">MACH_IS_ATARI</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">str</span> <span class="o">=</span> <span class="n">get_options</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="mi">3</span> <span class="o">+</span> <span class="n">FD_MAX_UNITS</span><span class="p">,</span> <span class="n">ints</span><span class="p">);</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="n">ints</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;ataflop_setup: no arguments!</span><span class="se">\n</span><span class="s">&quot;</span> <span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ints</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="o">+</span><span class="n">FD_MAX_UNITS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;ataflop_setup: too many arguments</span><span class="se">\n</span><span class="s">&quot;</span> <span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ints</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">ints</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;ataflop_setup: bad drive type</span><span class="se">\n</span><span class="s">&quot;</span> <span class="p">);</span>
	<span class="k">else</span>
		<span class="n">DriveType</span> <span class="o">=</span> <span class="n">ints</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ints</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">UseTrackbuffer</span> <span class="o">=</span> <span class="p">(</span><span class="n">ints</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">for</span><span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">ints</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">i</span><span class="o">-</span><span class="mi">3</span> <span class="o">&lt;</span> <span class="n">FD_MAX_UNITS</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ints</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="n">ints</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">3</span> <span class="o">&amp;&amp;</span> <span class="n">ints</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">6</span> <span class="o">&amp;&amp;</span> <span class="n">ints</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">12</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;ataflop_setup: bad steprate</span><span class="se">\n</span><span class="s">&quot;</span> <span class="p">);</span>
		<span class="k">else</span>
			<span class="n">UserSteprate</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">ints</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;floppy=&quot;</span><span class="p">,</span> <span class="n">atari_floppy_setup</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">atari_floppy_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">blk_unregister_region</span><span class="p">(</span><span class="n">MKDEV</span><span class="p">(</span><span class="n">FLOPPY_MAJOR</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">256</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">FD_MAX_UNITS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">unit</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">;</span>

		<span class="n">del_gendisk</span><span class="p">(</span><span class="n">unit</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">disk</span><span class="p">);</span>
		<span class="n">put_disk</span><span class="p">(</span><span class="n">unit</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">disk</span><span class="p">);</span>
		<span class="n">blk_cleanup_queue</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">unregister_blkdev</span><span class="p">(</span><span class="n">FLOPPY_MAJOR</span><span class="p">,</span> <span class="s">&quot;fd&quot;</span><span class="p">);</span>

	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fd_timer</span><span class="p">);</span>
	<span class="n">atari_stram_free</span><span class="p">(</span> <span class="n">DMABuffer</span> <span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">atari_floppy_init</span><span class="p">)</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">atari_floppy_exit</span><span class="p">)</span>

<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
