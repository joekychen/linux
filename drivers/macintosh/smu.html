<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › macintosh › smu.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>smu.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * PowerMac G5 SMU driver</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright 2004 J. Mayer &lt;l_indien@magic.fr&gt;</span>
<span class="cm"> * Copyright 2005 Benjamin Herrenschmidt, IBM Corp.</span>
<span class="cm"> *</span>
<span class="cm"> * Released under the term of the GNU GPL v2.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * TODO:</span>
<span class="cm"> *  - maybe add timeout to commands ?</span>
<span class="cm"> *  - blocking version of time functions</span>
<span class="cm"> *  - polling version of i2c commands (including timer that works with</span>
<span class="cm"> *    interrupts off)</span>
<span class="cm"> *  - maybe avoid some data copies with i2c by directly using the smu cmd</span>
<span class="cm"> *    buffer and a lower level internal interface</span>
<span class="cm"> *  - understand SMU -&gt; CPU events and implement reception of them via</span>
<span class="cm"> *    the userland interface</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/dmapool.h&gt;</span>
<span class="cp">#include &lt;linux/bootmem.h&gt;</span>
<span class="cp">#include &lt;linux/vmalloc.h&gt;</span>
<span class="cp">#include &lt;linux/highmem.h&gt;</span>
<span class="cp">#include &lt;linux/jiffies.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/rtc.h&gt;</span>
<span class="cp">#include &lt;linux/completion.h&gt;</span>
<span class="cp">#include &lt;linux/miscdevice.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/poll.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/of_device.h&gt;</span>
<span class="cp">#include &lt;linux/of_platform.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>

<span class="cp">#include &lt;asm/byteorder.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/prom.h&gt;</span>
<span class="cp">#include &lt;asm/machdep.h&gt;</span>
<span class="cp">#include &lt;asm/pmac_feature.h&gt;</span>
<span class="cp">#include &lt;asm/smu.h&gt;</span>
<span class="cp">#include &lt;asm/sections.h&gt;</span>
<span class="cp">#include &lt;asm/abs_addr.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>

<span class="cp">#define VERSION &quot;0.7&quot;</span>
<span class="cp">#define AUTHOR  &quot;(c) 2005 Benjamin Herrenschmidt, IBM Corp.&quot;</span>

<span class="cp">#undef DEBUG_SMU</span>

<span class="cp">#ifdef DEBUG_SMU</span>
<span class="cp">#define DPRINTK(fmt, args...) do { printk(KERN_DEBUG fmt , ##args); } while (0)</span>
<span class="cp">#else</span>
<span class="cp">#define DPRINTK(fmt, args...) do { } while (0)</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * This is the command buffer passed to the SMU hardware</span>
<span class="cm"> */</span>
<span class="cp">#define SMU_MAX_DATA	254</span>

<span class="k">struct</span> <span class="n">smu_cmd_buf</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">cmd</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">length</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">data</span><span class="p">[</span><span class="n">SMU_MAX_DATA</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">smu_device</span> <span class="p">{</span>
	<span class="n">spinlock_t</span>		<span class="n">lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device_node</span>	<span class="o">*</span><span class="n">of_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">platform_device</span>	<span class="o">*</span><span class="n">of_dev</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">doorbell</span><span class="p">;</span>	<span class="cm">/* doorbell gpio */</span>
	<span class="n">u32</span> <span class="n">__iomem</span>		<span class="o">*</span><span class="n">db_buf</span><span class="p">;</span>	<span class="cm">/* doorbell buffer */</span>
	<span class="k">struct</span> <span class="n">device_node</span>	<span class="o">*</span><span class="n">db_node</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">db_irq</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">msg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device_node</span>	<span class="o">*</span><span class="n">msg_node</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">msg_irq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">smu_cmd_buf</span>	<span class="o">*</span><span class="n">cmd_buf</span><span class="p">;</span>	<span class="cm">/* command buffer virtual */</span>
	<span class="n">u32</span>			<span class="n">cmd_buf_abs</span><span class="p">;</span>	<span class="cm">/* command buffer absolute */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">cmd_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">smu_cmd</span>		<span class="o">*</span><span class="n">cmd_cur</span><span class="p">;</span>	<span class="cm">/* pending command */</span>
	<span class="kt">int</span>			<span class="n">broken_nap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">cmd_i2c_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">smu_i2c_cmd</span>	<span class="o">*</span><span class="n">cmd_i2c_cur</span><span class="p">;</span>	<span class="cm">/* pending i2c command */</span>
	<span class="k">struct</span> <span class="n">timer_list</span>	<span class="n">i2c_timer</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * I don&#39;t think there will ever be more than one SMU, so</span>
<span class="cm"> * for now, just hard code that</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">smu_mutex</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">smu_device</span>	<span class="o">*</span><span class="n">smu</span><span class="p">;</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">smu_part_access</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">smu_irq_inited</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">smu_i2c_retry</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * SMU driver low level stuff</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">smu_start_cmd</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">faddr</span><span class="p">,</span> <span class="n">fend</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">smu_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smu</span><span class="o">-&gt;</span><span class="n">cmd_list</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Fetch first command in queue */</span>
	<span class="n">cmd</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">smu</span><span class="o">-&gt;</span><span class="n">cmd_list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">smu_cmd</span><span class="p">,</span> <span class="n">link</span><span class="p">);</span>
	<span class="n">smu</span><span class="o">-&gt;</span><span class="n">cmd_cur</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">;</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">);</span>

	<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;SMU: starting cmd %x, %d bytes data</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">,</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">);</span>
	<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;SMU: data buffer: %02x %02x %02x %02x %02x %02x %02x %02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="p">((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">data_buf</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span> <span class="p">((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">data_buf</span><span class="p">)[</span><span class="mi">1</span><span class="p">],</span>
		<span class="p">((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">data_buf</span><span class="p">)[</span><span class="mi">2</span><span class="p">],</span> <span class="p">((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">data_buf</span><span class="p">)[</span><span class="mi">3</span><span class="p">],</span>
		<span class="p">((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">data_buf</span><span class="p">)[</span><span class="mi">4</span><span class="p">],</span> <span class="p">((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">data_buf</span><span class="p">)[</span><span class="mi">5</span><span class="p">],</span>
		<span class="p">((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">data_buf</span><span class="p">)[</span><span class="mi">6</span><span class="p">],</span> <span class="p">((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">data_buf</span><span class="p">)[</span><span class="mi">7</span><span class="p">]);</span>

	<span class="cm">/* Fill the SMU command buffer */</span>
	<span class="n">smu</span><span class="o">-&gt;</span><span class="n">cmd_buf</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">;</span>
	<span class="n">smu</span><span class="o">-&gt;</span><span class="n">cmd_buf</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">smu</span><span class="o">-&gt;</span><span class="n">cmd_buf</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">data_buf</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">);</span>

	<span class="cm">/* Flush command and data to RAM */</span>
	<span class="n">faddr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">smu</span><span class="o">-&gt;</span><span class="n">cmd_buf</span><span class="p">;</span>
	<span class="n">fend</span> <span class="o">=</span> <span class="n">faddr</span> <span class="o">+</span> <span class="n">smu</span><span class="o">-&gt;</span><span class="n">cmd_buf</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">flush_inval_dcache_range</span><span class="p">(</span><span class="n">faddr</span><span class="p">,</span> <span class="n">fend</span><span class="p">);</span>


	<span class="cm">/* We also disable NAP mode for the duration of the command</span>
<span class="cm">	 * on U3 based machines.</span>
<span class="cm">	 * This is slightly racy as it can be written back to 1 by a sysctl</span>
<span class="cm">	 * but that never happens in practice. There seem to be an issue with</span>
<span class="cm">	 * U3 based machines such as the iMac G5 where napping for the</span>
<span class="cm">	 * whole duration of the command prevents the SMU from fetching it</span>
<span class="cm">	 * from memory. This might be related to the strange i2c based</span>
<span class="cm">	 * mechanism the SMU uses to access memory.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">smu</span><span class="o">-&gt;</span><span class="n">broken_nap</span><span class="p">)</span>
		<span class="n">powersave_nap</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* This isn&#39;t exactly a DMA mapping here, I suspect</span>
<span class="cm">	 * the SMU is actually communicating with us via i2c to the</span>
<span class="cm">	 * northbridge or the CPU to access RAM.</span>
<span class="cm">	 */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">smu</span><span class="o">-&gt;</span><span class="n">cmd_buf_abs</span><span class="p">,</span> <span class="n">smu</span><span class="o">-&gt;</span><span class="n">db_buf</span><span class="p">);</span>

	<span class="cm">/* Ring the SMU doorbell */</span>
	<span class="n">pmac_do_feature_call</span><span class="p">(</span><span class="n">PMAC_FTR_WRITE_GPIO</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">smu</span><span class="o">-&gt;</span><span class="n">doorbell</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">smu_db_intr</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">smu_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">done</span><span class="p">)(</span><span class="k">struct</span> <span class="n">smu_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">misc</span><span class="p">)</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">misc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">gpio</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* SMU completed the command, well, we hope, let&#39;s make sure</span>
<span class="cm">	 * of it</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">gpio</span> <span class="o">=</span> <span class="n">pmac_do_feature_call</span><span class="p">(</span><span class="n">PMAC_FTR_READ_GPIO</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">smu</span><span class="o">-&gt;</span><span class="n">doorbell</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">gpio</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">7</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cmd</span> <span class="o">=</span> <span class="n">smu</span><span class="o">-&gt;</span><span class="n">cmd_cur</span><span class="p">;</span>
	<span class="n">smu</span><span class="o">-&gt;</span><span class="n">cmd_cur</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">faddr</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">reply_len</span><span class="p">;</span>
		<span class="n">u8</span> <span class="n">ack</span><span class="p">;</span>

		<span class="cm">/* CPU might have brought back the cache line, so we need</span>
<span class="cm">		 * to flush again before peeking at the SMU response. We</span>
<span class="cm">		 * flush the entire buffer for now as we haven&#39;t read the</span>
<span class="cm">		 * reply length (it&#39;s only 2 cache lines anyway)</span>
<span class="cm">		 */</span>
		<span class="n">faddr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">smu</span><span class="o">-&gt;</span><span class="n">cmd_buf</span><span class="p">;</span>
		<span class="n">flush_inval_dcache_range</span><span class="p">(</span><span class="n">faddr</span><span class="p">,</span> <span class="n">faddr</span> <span class="o">+</span> <span class="mi">256</span><span class="p">);</span>

		<span class="cm">/* Now check ack */</span>
		<span class="n">ack</span> <span class="o">=</span> <span class="p">(</span><span class="o">~</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ack</span> <span class="o">!=</span> <span class="n">smu</span><span class="o">-&gt;</span><span class="n">cmd_buf</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;SMU: incorrect ack, want %x got %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">ack</span><span class="p">,</span> <span class="n">smu</span><span class="o">-&gt;</span><span class="n">cmd_buf</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">);</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">reply_len</span> <span class="o">=</span> <span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">smu</span><span class="o">-&gt;</span><span class="n">cmd_buf</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;SMU: reply len: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">reply_len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reply_len</span> <span class="o">&gt;</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">reply_len</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;SMU: reply buffer too small,&quot;</span>
			       <span class="s">&quot;got %d bytes for a %d bytes buffer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">reply_len</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">reply_len</span><span class="p">);</span>
			<span class="n">reply_len</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">reply_len</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">reply_len</span> <span class="o">=</span> <span class="n">reply_len</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">reply_buf</span> <span class="o">&amp;&amp;</span> <span class="n">reply_len</span><span class="p">)</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">reply_buf</span><span class="p">,</span> <span class="n">smu</span><span class="o">-&gt;</span><span class="n">cmd_buf</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">reply_len</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Now complete the command. Write status last in order as we lost</span>
<span class="cm">	 * ownership of the command structure as soon as it&#39;s no longer -1</span>
<span class="cm">	 */</span>
	<span class="n">done</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">;</span>
	<span class="n">misc</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">misc</span><span class="p">;</span>
	<span class="n">mb</span><span class="p">();</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* Re-enable NAP mode */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">smu</span><span class="o">-&gt;</span><span class="n">broken_nap</span><span class="p">)</span>
		<span class="n">powersave_nap</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
 <span class="nl">bail:</span>
	<span class="cm">/* Start next command if any */</span>
	<span class="n">smu_start_cmd</span><span class="p">();</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Call command completion handler if any */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">done</span><span class="p">)</span>
		<span class="n">done</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">misc</span><span class="p">);</span>

	<span class="cm">/* It&#39;s an edge interrupt, nothing to do */</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">smu_msg_intr</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* I don&#39;t quite know what to do with this one, we seem to never</span>
<span class="cm">	 * receive it, so I suspect we have to arm it someway in the SMU</span>
<span class="cm">	 * to start getting events that way.</span>
<span class="cm">	 */</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;SMU: message interrupt !</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* It&#39;s an edge interrupt, nothing to do */</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Queued command management.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">smu_queue_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">smu_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">smu</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">&gt;</span> <span class="n">SMU_MAX_DATA</span> <span class="o">||</span>
	    <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">reply_len</span> <span class="o">&gt;</span> <span class="n">SMU_MAX_DATA</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">smu</span><span class="o">-&gt;</span><span class="n">cmd_list</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">smu</span><span class="o">-&gt;</span><span class="n">cmd_cur</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">smu_start_cmd</span><span class="p">();</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Workaround for early calls when irq isn&#39;t available */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">smu_irq_inited</span> <span class="o">||</span> <span class="n">smu</span><span class="o">-&gt;</span><span class="n">db_irq</span> <span class="o">==</span> <span class="n">NO_IRQ</span><span class="p">)</span>
		<span class="n">smu_spinwait_cmd</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">smu_queue_cmd</span><span class="p">);</span>


<span class="kt">int</span> <span class="nf">smu_queue_simple</span><span class="p">(</span><span class="k">struct</span> <span class="n">smu_simple_cmd</span> <span class="o">*</span><span class="n">scmd</span><span class="p">,</span> <span class="n">u8</span> <span class="n">command</span><span class="p">,</span>
		     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">data_len</span><span class="p">,</span>
		     <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">done</span><span class="p">)(</span><span class="k">struct</span> <span class="n">smu_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">misc</span><span class="p">),</span>
		     <span class="kt">void</span> <span class="o">*</span><span class="n">misc</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smu_cmd</span> <span class="o">*</span><span class="n">cmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">scmd</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">;</span>
	<span class="kt">va_list</span> <span class="n">list</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">data_len</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">scmd</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">scmd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">scmd</span><span class="p">));</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">command</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">=</span> <span class="n">data_len</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">data_buf</span> <span class="o">=</span> <span class="n">scmd</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">reply_len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">scmd</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">);</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">reply_buf</span> <span class="o">=</span> <span class="n">scmd</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">done</span> <span class="o">=</span> <span class="n">done</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">misc</span> <span class="o">=</span> <span class="n">misc</span><span class="p">;</span>

	<span class="n">va_start</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">misc</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">data_len</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">scmd</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)</span><span class="n">va_arg</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
	<span class="n">va_end</span><span class="p">(</span><span class="n">list</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">smu_queue_cmd</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">smu_queue_simple</span><span class="p">);</span>


<span class="kt">void</span> <span class="nf">smu_poll</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">gpio</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">smu</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">gpio</span> <span class="o">=</span> <span class="n">pmac_do_feature_call</span><span class="p">(</span><span class="n">PMAC_FTR_READ_GPIO</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">smu</span><span class="o">-&gt;</span><span class="n">doorbell</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">gpio</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">==</span> <span class="mi">7</span><span class="p">)</span>
		<span class="n">smu_db_intr</span><span class="p">(</span><span class="n">smu</span><span class="o">-&gt;</span><span class="n">db_irq</span><span class="p">,</span> <span class="n">smu</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">smu_poll</span><span class="p">);</span>


<span class="kt">void</span> <span class="nf">smu_done_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">smu_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">misc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">completion</span> <span class="o">*</span><span class="n">comp</span> <span class="o">=</span> <span class="n">misc</span><span class="p">;</span>

	<span class="n">complete</span><span class="p">(</span><span class="n">comp</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">smu_done_complete</span><span class="p">);</span>


<span class="kt">void</span> <span class="nf">smu_spinwait_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">smu_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">smu_poll</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">smu_spinwait_cmd</span><span class="p">);</span>


<span class="cm">/* RTC low level commands */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">bcd2hex</span> <span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(((</span><span class="n">n</span> <span class="o">&amp;</span> <span class="mh">0xf0</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">*</span> <span class="mi">10</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">n</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">hex2bcd</span> <span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">((</span><span class="n">n</span> <span class="o">/</span> <span class="mi">10</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">10</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">smu_fill_set_rtc_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">smu_cmd_buf</span> <span class="o">*</span><span class="n">cmd_buf</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">rtc_time</span> <span class="o">*</span><span class="n">time</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cmd_buf</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">=</span> <span class="mh">0x8e</span><span class="p">;</span>
	<span class="n">cmd_buf</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">cmd_buf</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x80</span><span class="p">;</span>
	<span class="n">cmd_buf</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">hex2bcd</span><span class="p">(</span><span class="n">time</span><span class="o">-&gt;</span><span class="n">tm_sec</span><span class="p">);</span>
	<span class="n">cmd_buf</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">hex2bcd</span><span class="p">(</span><span class="n">time</span><span class="o">-&gt;</span><span class="n">tm_min</span><span class="p">);</span>
	<span class="n">cmd_buf</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">hex2bcd</span><span class="p">(</span><span class="n">time</span><span class="o">-&gt;</span><span class="n">tm_hour</span><span class="p">);</span>
	<span class="n">cmd_buf</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span><span class="o">-&gt;</span><span class="n">tm_wday</span><span class="p">;</span>
	<span class="n">cmd_buf</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">hex2bcd</span><span class="p">(</span><span class="n">time</span><span class="o">-&gt;</span><span class="n">tm_mday</span><span class="p">);</span>
	<span class="n">cmd_buf</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">hex2bcd</span><span class="p">(</span><span class="n">time</span><span class="o">-&gt;</span><span class="n">tm_mon</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">cmd_buf</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="n">hex2bcd</span><span class="p">(</span><span class="n">time</span><span class="o">-&gt;</span><span class="n">tm_year</span> <span class="o">-</span> <span class="mi">100</span><span class="p">);</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">smu_get_rtc_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">rtc_time</span> <span class="o">*</span><span class="n">time</span><span class="p">,</span> <span class="kt">int</span> <span class="n">spinwait</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smu_simple_cmd</span> <span class="n">cmd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">smu</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">rtc_time</span><span class="p">));</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">smu_queue_simple</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span> <span class="n">SMU_CMD_RTC_COMMAND</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
			      <span class="n">SMU_CMD_RTC_GET_DATETIME</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">smu_spinwait_simple</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="p">);</span>

	<span class="n">time</span><span class="o">-&gt;</span><span class="n">tm_sec</span> <span class="o">=</span> <span class="n">bcd2hex</span><span class="p">(</span><span class="n">cmd</span><span class="p">.</span><span class="n">buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">time</span><span class="o">-&gt;</span><span class="n">tm_min</span> <span class="o">=</span> <span class="n">bcd2hex</span><span class="p">(</span><span class="n">cmd</span><span class="p">.</span><span class="n">buffer</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
	<span class="n">time</span><span class="o">-&gt;</span><span class="n">tm_hour</span> <span class="o">=</span> <span class="n">bcd2hex</span><span class="p">(</span><span class="n">cmd</span><span class="p">.</span><span class="n">buffer</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
	<span class="n">time</span><span class="o">-&gt;</span><span class="n">tm_wday</span> <span class="o">=</span> <span class="n">bcd2hex</span><span class="p">(</span><span class="n">cmd</span><span class="p">.</span><span class="n">buffer</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
	<span class="n">time</span><span class="o">-&gt;</span><span class="n">tm_mday</span> <span class="o">=</span> <span class="n">bcd2hex</span><span class="p">(</span><span class="n">cmd</span><span class="p">.</span><span class="n">buffer</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span>
	<span class="n">time</span><span class="o">-&gt;</span><span class="n">tm_mon</span> <span class="o">=</span> <span class="n">bcd2hex</span><span class="p">(</span><span class="n">cmd</span><span class="p">.</span><span class="n">buffer</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">time</span><span class="o">-&gt;</span><span class="n">tm_year</span> <span class="o">=</span> <span class="n">bcd2hex</span><span class="p">(</span><span class="n">cmd</span><span class="p">.</span><span class="n">buffer</span><span class="p">[</span><span class="mi">6</span><span class="p">])</span> <span class="o">+</span> <span class="mi">100</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">smu_set_rtc_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">rtc_time</span> <span class="o">*</span><span class="n">time</span><span class="p">,</span> <span class="kt">int</span> <span class="n">spinwait</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smu_simple_cmd</span> <span class="n">cmd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">smu</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">smu_queue_simple</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span> <span class="n">SMU_CMD_RTC_COMMAND</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
			      <span class="n">SMU_CMD_RTC_SET_DATETIME</span><span class="p">,</span>
			      <span class="n">hex2bcd</span><span class="p">(</span><span class="n">time</span><span class="o">-&gt;</span><span class="n">tm_sec</span><span class="p">),</span>
			      <span class="n">hex2bcd</span><span class="p">(</span><span class="n">time</span><span class="o">-&gt;</span><span class="n">tm_min</span><span class="p">),</span>
			      <span class="n">hex2bcd</span><span class="p">(</span><span class="n">time</span><span class="o">-&gt;</span><span class="n">tm_hour</span><span class="p">),</span>
			      <span class="n">time</span><span class="o">-&gt;</span><span class="n">tm_wday</span><span class="p">,</span>
			      <span class="n">hex2bcd</span><span class="p">(</span><span class="n">time</span><span class="o">-&gt;</span><span class="n">tm_mday</span><span class="p">),</span>
			      <span class="n">hex2bcd</span><span class="p">(</span><span class="n">time</span><span class="o">-&gt;</span><span class="n">tm_mon</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
			      <span class="n">hex2bcd</span><span class="p">(</span><span class="n">time</span><span class="o">-&gt;</span><span class="n">tm_year</span> <span class="o">-</span> <span class="mi">100</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">smu_spinwait_simple</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="nf">smu_shutdown</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smu_simple_cmd</span> <span class="n">cmd</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">smu</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">smu_queue_simple</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span> <span class="n">SMU_CMD_POWER_COMMAND</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
			     <span class="sc">&#39;S&#39;</span><span class="p">,</span> <span class="sc">&#39;H&#39;</span><span class="p">,</span> <span class="sc">&#39;U&#39;</span><span class="p">,</span> <span class="sc">&#39;T&#39;</span><span class="p">,</span> <span class="sc">&#39;D&#39;</span><span class="p">,</span> <span class="sc">&#39;O&#39;</span><span class="p">,</span> <span class="sc">&#39;W&#39;</span><span class="p">,</span> <span class="sc">&#39;N&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">smu_spinwait_simple</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(;;)</span>
		<span class="p">;</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="nf">smu_restart</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smu_simple_cmd</span> <span class="n">cmd</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">smu</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">smu_queue_simple</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span> <span class="n">SMU_CMD_POWER_COMMAND</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
			     <span class="sc">&#39;R&#39;</span><span class="p">,</span> <span class="sc">&#39;E&#39;</span><span class="p">,</span> <span class="sc">&#39;S&#39;</span><span class="p">,</span> <span class="sc">&#39;T&#39;</span><span class="p">,</span> <span class="sc">&#39;A&#39;</span><span class="p">,</span> <span class="sc">&#39;R&#39;</span><span class="p">,</span> <span class="sc">&#39;T&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">smu_spinwait_simple</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(;;)</span>
		<span class="p">;</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">smu_present</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">smu</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">smu_present</span><span class="p">);</span>


<span class="kt">int</span> <span class="n">__init</span> <span class="nf">smu_init</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u32</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="n">np</span> <span class="o">=</span> <span class="n">of_find_node_by_type</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;smu&quot;</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">np</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;SMU: Driver %s %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">VERSION</span><span class="p">,</span> <span class="n">AUTHOR</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">smu_cmdbuf_abs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;SMU: Command buffer not allocated !</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail_np</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">smu</span> <span class="o">=</span> <span class="n">alloc_bootmem</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">smu_device</span><span class="p">));</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smu</span><span class="o">-&gt;</span><span class="n">cmd_list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smu</span><span class="o">-&gt;</span><span class="n">cmd_i2c_list</span><span class="p">);</span>
	<span class="n">smu</span><span class="o">-&gt;</span><span class="n">of_node</span> <span class="o">=</span> <span class="n">np</span><span class="p">;</span>
	<span class="n">smu</span><span class="o">-&gt;</span><span class="n">db_irq</span> <span class="o">=</span> <span class="n">NO_IRQ</span><span class="p">;</span>
	<span class="n">smu</span><span class="o">-&gt;</span><span class="n">msg_irq</span> <span class="o">=</span> <span class="n">NO_IRQ</span><span class="p">;</span>

	<span class="cm">/* smu_cmdbuf_abs is in the low 2G of RAM, can be converted to a</span>
<span class="cm">	 * 32 bits value safely</span>
<span class="cm">	 */</span>
	<span class="n">smu</span><span class="o">-&gt;</span><span class="n">cmd_buf_abs</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">smu_cmdbuf_abs</span><span class="p">;</span>
	<span class="n">smu</span><span class="o">-&gt;</span><span class="n">cmd_buf</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">smu_cmd_buf</span> <span class="o">*</span><span class="p">)</span><span class="n">abs_to_virt</span><span class="p">(</span><span class="n">smu_cmdbuf_abs</span><span class="p">);</span>

	<span class="n">smu</span><span class="o">-&gt;</span><span class="n">db_node</span> <span class="o">=</span> <span class="n">of_find_node_by_name</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;smu-doorbell&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">smu</span><span class="o">-&gt;</span><span class="n">db_node</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;SMU: Can&#39;t find doorbell GPIO !</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail_bootmem</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">data</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">smu</span><span class="o">-&gt;</span><span class="n">db_node</span><span class="p">,</span> <span class="s">&quot;reg&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;SMU: Can&#39;t find doorbell GPIO address !</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail_db_node</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Current setup has one doorbell GPIO that does both doorbell</span>
<span class="cm">	 * and ack. GPIOs are at 0x50, best would be to find that out</span>
<span class="cm">	 * in the device-tree though.</span>
<span class="cm">	 */</span>
	<span class="n">smu</span><span class="o">-&gt;</span><span class="n">doorbell</span> <span class="o">=</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">smu</span><span class="o">-&gt;</span><span class="n">doorbell</span> <span class="o">&lt;</span> <span class="mh">0x50</span><span class="p">)</span>
		<span class="n">smu</span><span class="o">-&gt;</span><span class="n">doorbell</span> <span class="o">+=</span> <span class="mh">0x50</span><span class="p">;</span>

	<span class="cm">/* Now look for the smu-interrupt GPIO */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">smu</span><span class="o">-&gt;</span><span class="n">msg_node</span> <span class="o">=</span> <span class="n">of_find_node_by_name</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;smu-interrupt&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">smu</span><span class="o">-&gt;</span><span class="n">msg_node</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">data</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">smu</span><span class="o">-&gt;</span><span class="n">msg_node</span><span class="p">,</span> <span class="s">&quot;reg&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">of_node_put</span><span class="p">(</span><span class="n">smu</span><span class="o">-&gt;</span><span class="n">msg_node</span><span class="p">);</span>
			<span class="n">smu</span><span class="o">-&gt;</span><span class="n">msg_node</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">smu</span><span class="o">-&gt;</span><span class="n">msg</span> <span class="o">=</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">smu</span><span class="o">-&gt;</span><span class="n">msg</span> <span class="o">&lt;</span> <span class="mh">0x50</span><span class="p">)</span>
			<span class="n">smu</span><span class="o">-&gt;</span><span class="n">msg</span> <span class="o">+=</span> <span class="mh">0x50</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Doorbell buffer is currently hard-coded, I didn&#39;t find a proper</span>
<span class="cm">	 * device-tree entry giving the address. Best would probably to use</span>
<span class="cm">	 * an offset for K2 base though, but let&#39;s do it that way for now.</span>
<span class="cm">	 */</span>
	<span class="n">smu</span><span class="o">-&gt;</span><span class="n">db_buf</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="mh">0x8000860c</span><span class="p">,</span> <span class="mh">0x1000</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">smu</span><span class="o">-&gt;</span><span class="n">db_buf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;SMU: Can&#39;t map doorbell buffer pointer !</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail_msg_node</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* U3 has an issue with NAP mode when issuing SMU commands */</span>
	<span class="n">smu</span><span class="o">-&gt;</span><span class="n">broken_nap</span> <span class="o">=</span> <span class="n">pmac_get_uninorth_variant</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">smu</span><span class="o">-&gt;</span><span class="n">broken_nap</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;SMU: using NAP mode workaround</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">sys_ctrler</span> <span class="o">=</span> <span class="n">SYS_CTRLER_SMU</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fail_msg_node:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">smu</span><span class="o">-&gt;</span><span class="n">msg_node</span><span class="p">)</span>
		<span class="n">of_node_put</span><span class="p">(</span><span class="n">smu</span><span class="o">-&gt;</span><span class="n">msg_node</span><span class="p">);</span>
<span class="nl">fail_db_node:</span>
	<span class="n">of_node_put</span><span class="p">(</span><span class="n">smu</span><span class="o">-&gt;</span><span class="n">db_node</span><span class="p">);</span>
<span class="nl">fail_bootmem:</span>
	<span class="n">free_bootmem</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">smu</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">smu_device</span><span class="p">));</span>
	<span class="n">smu</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="nl">fail_np:</span>
	<span class="n">of_node_put</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">smu_late_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">smu</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smu</span><span class="o">-&gt;</span><span class="n">i2c_timer</span><span class="p">);</span>
	<span class="n">smu</span><span class="o">-&gt;</span><span class="n">i2c_timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">smu_i2c_retry</span><span class="p">;</span>
	<span class="n">smu</span><span class="o">-&gt;</span><span class="n">i2c_timer</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">smu</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">smu</span><span class="o">-&gt;</span><span class="n">db_node</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">smu</span><span class="o">-&gt;</span><span class="n">db_irq</span> <span class="o">=</span> <span class="n">irq_of_parse_and_map</span><span class="p">(</span><span class="n">smu</span><span class="o">-&gt;</span><span class="n">db_node</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">smu</span><span class="o">-&gt;</span><span class="n">db_irq</span> <span class="o">==</span> <span class="n">NO_IRQ</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;smu: failed to map irq for node %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">smu</span><span class="o">-&gt;</span><span class="n">db_node</span><span class="o">-&gt;</span><span class="n">full_name</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">smu</span><span class="o">-&gt;</span><span class="n">msg_node</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">smu</span><span class="o">-&gt;</span><span class="n">msg_irq</span> <span class="o">=</span> <span class="n">irq_of_parse_and_map</span><span class="p">(</span><span class="n">smu</span><span class="o">-&gt;</span><span class="n">msg_node</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">smu</span><span class="o">-&gt;</span><span class="n">msg_irq</span> <span class="o">==</span> <span class="n">NO_IRQ</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;smu: failed to map irq for node %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">smu</span><span class="o">-&gt;</span><span class="n">msg_node</span><span class="o">-&gt;</span><span class="n">full_name</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Try to request the interrupts</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">smu</span><span class="o">-&gt;</span><span class="n">db_irq</span> <span class="o">!=</span> <span class="n">NO_IRQ</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">request_irq</span><span class="p">(</span><span class="n">smu</span><span class="o">-&gt;</span><span class="n">db_irq</span><span class="p">,</span> <span class="n">smu_db_intr</span><span class="p">,</span>
				<span class="n">IRQF_SHARED</span><span class="p">,</span> <span class="s">&quot;SMU doorbell&quot;</span><span class="p">,</span> <span class="n">smu</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;SMU: can&#39;t &quot;</span>
			       <span class="s">&quot;request interrupt %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">smu</span><span class="o">-&gt;</span><span class="n">db_irq</span><span class="p">);</span>
			<span class="n">smu</span><span class="o">-&gt;</span><span class="n">db_irq</span> <span class="o">=</span> <span class="n">NO_IRQ</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">smu</span><span class="o">-&gt;</span><span class="n">msg_irq</span> <span class="o">!=</span> <span class="n">NO_IRQ</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">request_irq</span><span class="p">(</span><span class="n">smu</span><span class="o">-&gt;</span><span class="n">msg_irq</span><span class="p">,</span> <span class="n">smu_msg_intr</span><span class="p">,</span>
				<span class="n">IRQF_SHARED</span><span class="p">,</span> <span class="s">&quot;SMU message&quot;</span><span class="p">,</span> <span class="n">smu</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;SMU: can&#39;t &quot;</span>
			       <span class="s">&quot;request interrupt %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">smu</span><span class="o">-&gt;</span><span class="n">msg_irq</span><span class="p">);</span>
			<span class="n">smu</span><span class="o">-&gt;</span><span class="n">msg_irq</span> <span class="o">=</span> <span class="n">NO_IRQ</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">smu_irq_inited</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/* This has to be before arch_initcall as the low i2c stuff relies on the</span>
<span class="cm"> * above having been done before we reach arch_initcalls</span>
<span class="cm"> */</span>
<span class="n">core_initcall</span><span class="p">(</span><span class="n">smu_late_init</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * sysfs visibility</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">smu_expose_childs</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">unused</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">np</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="p">(</span><span class="n">np</span> <span class="o">=</span> <span class="n">of_get_next_child</span><span class="p">(</span><span class="n">smu</span><span class="o">-&gt;</span><span class="n">of_node</span><span class="p">,</span> <span class="n">np</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">of_device_is_compatible</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s">&quot;smu-sensors&quot;</span><span class="p">))</span>
			<span class="n">of_platform_device_create</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s">&quot;smu-sensors&quot;</span><span class="p">,</span>
						  <span class="o">&amp;</span><span class="n">smu</span><span class="o">-&gt;</span><span class="n">of_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DECLARE_WORK</span><span class="p">(</span><span class="n">smu_expose_childs_work</span><span class="p">,</span> <span class="n">smu_expose_childs</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">smu_platform_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span><span class="o">*</span> <span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">smu</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="n">smu</span><span class="o">-&gt;</span><span class="n">of_dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Ok, we are matched, now expose all i2c busses. We have to defer</span>
<span class="cm">	 * that unfortunately or it would deadlock inside the device model</span>
<span class="cm">	 */</span>
	<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smu_expose_childs_work</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">of_device_id</span> <span class="n">smu_platform_match</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">type</span>		<span class="o">=</span> <span class="s">&quot;smu&quot;</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{},</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">platform_driver</span> <span class="n">smu_of_platform_driver</span> <span class="o">=</span>
<span class="p">{</span>
	<span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;smu&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">of_match_table</span> <span class="o">=</span> <span class="n">smu_platform_match</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">.</span><span class="n">probe</span>		<span class="o">=</span> <span class="n">smu_platform_probe</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">smu_init_sysfs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * For now, we don&#39;t power manage machines with an SMU chip,</span>
<span class="cm">	 * I&#39;m a bit too far from figuring out how that works with those</span>
<span class="cm">	 * new chipsets, but that will come back and bite us</span>
<span class="cm">	 */</span>
	<span class="n">platform_driver_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smu_of_platform_driver</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">device_initcall</span><span class="p">(</span><span class="n">smu_init_sysfs</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="nf">smu_get_ofdev</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">smu</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">smu</span><span class="o">-&gt;</span><span class="n">of_dev</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">smu_get_ofdev</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * i2c interface</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">smu_i2c_complete_command</span><span class="p">(</span><span class="k">struct</span> <span class="n">smu_i2c_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fail</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">done</span><span class="p">)(</span><span class="k">struct</span> <span class="n">smu_i2c_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">misc</span><span class="p">)</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">misc</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">misc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* Check for read case */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fail</span> <span class="o">&amp;&amp;</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">fail</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
			       <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">datalen</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;SMU: completing, success: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">!</span><span class="n">fail</span><span class="p">);</span>

	<span class="cm">/* Update status and mark no pending i2c command with lock</span>
<span class="cm">	 * held so nobody comes in while we dequeue an eventual</span>
<span class="cm">	 * pending next i2c command</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">smu</span><span class="o">-&gt;</span><span class="n">cmd_i2c_cur</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">wmb</span><span class="p">();</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">fail</span> <span class="o">?</span> <span class="o">-</span><span class="n">EIO</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Is there another i2c command waiting ? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smu</span><span class="o">-&gt;</span><span class="n">cmd_i2c_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">smu_i2c_cmd</span> <span class="o">*</span><span class="n">newcmd</span><span class="p">;</span>

		<span class="cm">/* Fetch it, new current, remove from list */</span>
		<span class="n">newcmd</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">smu</span><span class="o">-&gt;</span><span class="n">cmd_i2c_list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">smu_i2c_cmd</span><span class="p">,</span> <span class="n">link</span><span class="p">);</span>
		<span class="n">smu</span><span class="o">-&gt;</span><span class="n">cmd_i2c_cur</span> <span class="o">=</span> <span class="n">newcmd</span><span class="p">;</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">);</span>

		<span class="cm">/* Queue with low level smu */</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scmd</span><span class="p">.</span><span class="n">link</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">smu</span><span class="o">-&gt;</span><span class="n">cmd_list</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">smu</span><span class="o">-&gt;</span><span class="n">cmd_cur</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">smu_start_cmd</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Call command completion handler if any */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">done</span><span class="p">)</span>
		<span class="n">done</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">misc</span><span class="p">);</span>

<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">smu_i2c_retry</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smu_i2c_cmd</span>	<span class="o">*</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">smu</span><span class="o">-&gt;</span><span class="n">cmd_i2c_cur</span><span class="p">;</span>

	<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;SMU: i2c failure, requeuing...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* requeue command simply by resetting reply_len */</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scmd</span><span class="p">.</span><span class="n">reply_len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="p">);</span>
	<span class="n">smu_queue_cmd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scmd</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">smu_i2c_low_completion</span><span class="p">(</span><span class="k">struct</span> <span class="n">smu_cmd</span> <span class="o">*</span><span class="n">scmd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">misc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smu_i2c_cmd</span>	<span class="o">*</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">misc</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">fail</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;SMU: i2c compl. stage=%d status=%x pdata[0]=%x rlen: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">stage</span><span class="p">,</span> <span class="n">scmd</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">scmd</span><span class="o">-&gt;</span><span class="n">reply_len</span><span class="p">);</span>

	<span class="cm">/* Check for possible status */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">scmd</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">fail</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">stage</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">fail</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">fail</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mh">0x80</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">fail</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Handle failures by requeuing command, after 5ms interval</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fail</span> <span class="o">&amp;&amp;</span> <span class="o">--</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">retries</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;SMU: i2c failure, starting timer...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">cmd</span> <span class="o">!=</span> <span class="n">smu</span><span class="o">-&gt;</span><span class="n">cmd_i2c_cur</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">smu_irq_inited</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mdelay</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
			<span class="n">smu_i2c_retry</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smu</span><span class="o">-&gt;</span><span class="n">i2c_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="mi">5</span><span class="p">));</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If failure or stage 1, command is complete */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fail</span> <span class="o">||</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">stage</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">smu_i2c_complete_command</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">fail</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;SMU: going to stage 1</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Ok, initial command complete, now poll status */</span>
	<span class="n">scmd</span><span class="o">-&gt;</span><span class="n">reply_buf</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="p">;</span>
	<span class="n">scmd</span><span class="o">-&gt;</span><span class="n">reply_len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="p">);</span>
	<span class="n">scmd</span><span class="o">-&gt;</span><span class="n">data_buf</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="p">;</span>
	<span class="n">scmd</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">stage</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">retries</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
	<span class="n">smu_queue_cmd</span><span class="p">(</span><span class="n">scmd</span><span class="p">);</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">smu_queue_i2c</span><span class="p">(</span><span class="k">struct</span> <span class="n">smu_i2c_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">smu</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="cm">/* Fill most fields of scmd */</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scmd</span><span class="p">.</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">SMU_CMD_I2C_COMMAND</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scmd</span><span class="p">.</span><span class="n">done</span> <span class="o">=</span> <span class="n">smu_i2c_low_completion</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scmd</span><span class="p">.</span><span class="n">misc</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scmd</span><span class="p">.</span><span class="n">reply_buf</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scmd</span><span class="p">.</span><span class="n">reply_len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="p">);</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scmd</span><span class="p">.</span><span class="n">data_buf</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scmd</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">stage</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">retries</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Check transfer type, sanitize some &quot;info&quot; fields</span>
<span class="cm">	 * based on transfer type and do more checking</span>
<span class="cm">	 */</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">caddr</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">devaddr</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">read</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">devaddr</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">;</span>
	<span class="k">switch</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SMU_I2C_TRANSFER_SIMPLE</span>:
		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">sublen</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SMU_I2C_TRANSFER_COMBINED</span>:
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">devaddr</span> <span class="o">&amp;=</span> <span class="mh">0xfe</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SMU_I2C_TRANSFER_STDSUB</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">sublen</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Finish setting up command based on transfer direction</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">datalen</span> <span class="o">&gt;</span> <span class="n">SMU_I2C_READ_MAX</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">datalen</span><span class="p">);</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scmd</span><span class="p">.</span><span class="n">data_len</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">datalen</span> <span class="o">&gt;</span> <span class="n">SMU_I2C_WRITE_MAX</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scmd</span><span class="p">.</span><span class="n">data_len</span> <span class="o">=</span> <span class="mi">9</span> <span class="o">+</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">datalen</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;SMU: i2c enqueuing command</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;SMU:   %s, len=%d bus=%x addr=%x sub0=%x type=%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">read</span> <span class="o">?</span> <span class="s">&quot;read&quot;</span> <span class="o">:</span> <span class="s">&quot;write&quot;</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">datalen</span><span class="p">,</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">bus</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">caddr</span><span class="p">,</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">subaddr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">type</span><span class="p">);</span>


	<span class="cm">/* Enqueue command in i2c list, and if empty, enqueue also in</span>
<span class="cm">	 * main command list</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">smu</span><span class="o">-&gt;</span><span class="n">cmd_i2c_cur</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">smu</span><span class="o">-&gt;</span><span class="n">cmd_i2c_cur</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">;</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scmd</span><span class="p">.</span><span class="n">link</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">smu</span><span class="o">-&gt;</span><span class="n">cmd_list</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">smu</span><span class="o">-&gt;</span><span class="n">cmd_cur</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">smu_start_cmd</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">smu</span><span class="o">-&gt;</span><span class="n">cmd_i2c_list</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Handling of &quot;partitions&quot;</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">smu_read_datablock</span><span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="n">dest</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DECLARE_COMPLETION_ONSTACK</span><span class="p">(</span><span class="n">comp</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">chunk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">smu_cmd</span> <span class="n">cmd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">params</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>

	<span class="cm">/* We currently use a chunk size of 0xe. We could check the</span>
<span class="cm">	 * SMU firmware version and use bigger sizes though</span>
<span class="cm">	 */</span>
	<span class="n">chunk</span> <span class="o">=</span> <span class="mh">0xe</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">clen</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">chunk</span><span class="p">);</span>

		<span class="n">cmd</span><span class="p">.</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">SMU_CMD_MISC_ee_COMMAND</span><span class="p">;</span>
		<span class="n">cmd</span><span class="p">.</span><span class="n">data_len</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
		<span class="n">cmd</span><span class="p">.</span><span class="n">data_buf</span> <span class="o">=</span> <span class="n">params</span><span class="p">;</span>
		<span class="n">cmd</span><span class="p">.</span><span class="n">reply_len</span> <span class="o">=</span> <span class="n">chunk</span><span class="p">;</span>
		<span class="n">cmd</span><span class="p">.</span><span class="n">reply_buf</span> <span class="o">=</span> <span class="n">dest</span><span class="p">;</span>
		<span class="n">cmd</span><span class="p">.</span><span class="n">done</span> <span class="o">=</span> <span class="n">smu_done_complete</span><span class="p">;</span>
		<span class="n">cmd</span><span class="p">.</span><span class="n">misc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">comp</span><span class="p">;</span>
		<span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">SMU_CMD_MISC_ee_GET_DATABLOCK_REC</span><span class="p">;</span>
		<span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x4</span><span class="p">;</span>
		<span class="o">*</span><span class="p">((</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
		<span class="n">params</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">clen</span><span class="p">;</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="n">smu_queue_cmd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
		<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">comp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="p">.</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="p">.</span><span class="n">reply_len</span> <span class="o">!=</span> <span class="n">clen</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;SMU: short read in &quot;</span>
			       <span class="s">&quot;smu_read_datablock, got: %d, want: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">cmd</span><span class="p">.</span><span class="n">reply_len</span><span class="p">,</span> <span class="n">clen</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">len</span> <span class="o">-=</span> <span class="n">clen</span><span class="p">;</span>
		<span class="n">addr</span> <span class="o">+=</span> <span class="n">clen</span><span class="p">;</span>
		<span class="n">dest</span> <span class="o">+=</span> <span class="n">clen</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">smu_sdbp_header</span> <span class="o">*</span><span class="nf">smu_create_sdb_partition</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DECLARE_COMPLETION_ONSTACK</span><span class="p">(</span><span class="n">comp</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">smu_simple_cmd</span> <span class="n">cmd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">addr</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">tlen</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">smu_sdbp_header</span> <span class="o">*</span><span class="n">hdr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">property</span> <span class="o">*</span><span class="n">prop</span><span class="p">;</span>

	<span class="cm">/* First query the partition info */</span>
	<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;SMU: Query partition infos ... (irq=%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">smu</span><span class="o">-&gt;</span><span class="n">db_irq</span><span class="p">);</span>
	<span class="n">smu_queue_simple</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span> <span class="n">SMU_CMD_PARTITION_COMMAND</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>
			 <span class="n">smu_done_complete</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">comp</span><span class="p">,</span>
			 <span class="n">SMU_CMD_PARTITION_LATEST</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
	<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">comp</span><span class="p">);</span>
	<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;SMU: done, status: %d, reply_len: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">cmd</span><span class="p">.</span><span class="n">cmd</span><span class="p">.</span><span class="n">status</span><span class="p">,</span> <span class="n">cmd</span><span class="p">.</span><span class="n">cmd</span><span class="p">.</span><span class="n">reply_len</span><span class="p">);</span>

	<span class="cm">/* Partition doesn&#39;t exist (or other error) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="p">.</span><span class="n">cmd</span><span class="p">.</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">cmd</span><span class="p">.</span><span class="n">cmd</span><span class="p">.</span><span class="n">reply_len</span> <span class="o">!=</span> <span class="mi">6</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Fetch address and length from reply */</span>
	<span class="n">addr</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span><span class="n">cmd</span><span class="p">.</span><span class="n">buffer</span><span class="p">);</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">.</span><span class="n">buffer</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">;</span>
	<span class="cm">/* Calucluate total length to allocate, including the 17 bytes</span>
<span class="cm">	 * for &quot;sdb-partition-XX&quot; that we append at the end of the buffer</span>
<span class="cm">	 */</span>
	<span class="n">tlen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">property</span><span class="p">)</span> <span class="o">+</span> <span class="n">len</span> <span class="o">+</span> <span class="mi">18</span><span class="p">;</span>

	<span class="n">prop</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">tlen</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">prop</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">hdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">smu_sdbp_header</span> <span class="o">*</span><span class="p">)(</span><span class="n">prop</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">prop</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">prop</span><span class="p">)</span> <span class="o">+</span> <span class="n">tlen</span> <span class="o">-</span> <span class="mi">18</span><span class="p">;</span>
	<span class="n">sprintf</span><span class="p">(</span><span class="n">prop</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;sdb-partition-%02x&quot;</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
	<span class="n">prop</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">prop</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="n">hdr</span><span class="p">;</span>
	<span class="n">prop</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Read the datablock */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">smu_read_datablock</span><span class="p">((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">hdr</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;SMU: datablock read failed while reading &quot;</span>
		       <span class="s">&quot;partition %02x !</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">failure</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Got it, check a few things and create the property */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">!=</span> <span class="n">id</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;SMU: Reading partition %02x and got &quot;</span>
		       <span class="s">&quot;%02x !</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">failure</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">prom_add_property</span><span class="p">(</span><span class="n">smu</span><span class="o">-&gt;</span><span class="n">of_node</span><span class="p">,</span> <span class="n">prop</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;SMU: Failed creating sdb-partition-%02x &quot;</span>
		       <span class="s">&quot;property !</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">failure</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">hdr</span><span class="p">;</span>
 <span class="nl">failure:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">prop</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Note: Only allowed to return error code in pointers (using ERR_PTR)</span>
<span class="cm"> * when interruptible is 1</span>
<span class="cm"> */</span>
<span class="k">const</span> <span class="k">struct</span> <span class="n">smu_sdbp_header</span> <span class="o">*</span><span class="nf">__smu_get_sdb_partition</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">interruptible</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">pname</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">smu_sdbp_header</span> <span class="o">*</span><span class="n">part</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">smu</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">sprintf</span><span class="p">(</span><span class="n">pname</span><span class="p">,</span> <span class="s">&quot;sdb-partition-%02x&quot;</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>

	<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;smu_get_sdb_partition(%02x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">interruptible</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">mutex_lock_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smu_part_access</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">rc</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smu_part_access</span><span class="p">);</span>

	<span class="n">part</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">smu</span><span class="o">-&gt;</span><span class="n">of_node</span><span class="p">,</span> <span class="n">pname</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">part</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;trying to extract from SMU ...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">part</span> <span class="o">=</span> <span class="n">smu_create_sdb_partition</span><span class="p">(</span><span class="n">id</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">part</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">size</span><span class="p">)</span>
			<span class="o">*</span><span class="n">size</span> <span class="o">=</span> <span class="n">part</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smu_part_access</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">part</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">smu_sdbp_header</span> <span class="o">*</span><span class="nf">smu_get_sdb_partition</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__smu_get_sdb_partition</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">smu_get_sdb_partition</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> * Userland driver interface</span>
<span class="cm"> */</span>


<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">smu_clist</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">smu_clist_lock</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">smu_file_mode</span> <span class="p">{</span>
	<span class="n">smu_file_commands</span><span class="p">,</span>
	<span class="n">smu_file_events</span><span class="p">,</span>
	<span class="n">smu_file_closing</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">smu_private</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">list</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">smu_file_mode</span>	<span class="n">mode</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">busy</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">smu_cmd</span>		<span class="n">cmd</span><span class="p">;</span>
	<span class="n">spinlock_t</span>		<span class="n">lock</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span>	<span class="n">wait</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">buffer</span><span class="p">[</span><span class="n">SMU_MAX_DATA</span><span class="p">];</span>
<span class="p">};</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">smu_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smu_private</span> <span class="o">*</span><span class="n">pp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">pp</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">smu_private</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pp</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">pp</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">smu_file_commands</span><span class="p">;</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smu_mutex</span><span class="p">);</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smu_clist_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">smu_clist</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smu_clist_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">pp</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smu_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">smu_user_cmd_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">smu_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">misc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smu_private</span> <span class="o">*</span><span class="n">pp</span> <span class="o">=</span> <span class="n">misc</span><span class="p">;</span>

	<span class="n">wake_up_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">smu_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			 <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smu_private</span> <span class="o">*</span><span class="n">pp</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">smu_user_cmd_hdr</span> <span class="n">hdr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">busy</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hdr</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">hdr</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">hdr</span><span class="p">.</span><span class="n">cmdtype</span> <span class="o">==</span> <span class="n">SMU_CMDTYPE_WANTS_EVENTS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pp</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">smu_file_events</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">hdr</span><span class="p">.</span><span class="n">cmdtype</span> <span class="o">==</span> <span class="n">SMU_CMDTYPE_GET_PARTITION</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">smu_sdbp_header</span> <span class="o">*</span><span class="n">part</span><span class="p">;</span>
		<span class="n">part</span> <span class="o">=</span> <span class="n">__smu_get_sdb_partition</span><span class="p">(</span><span class="n">hdr</span><span class="p">.</span><span class="n">cmd</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">part</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">part</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">part</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">hdr</span><span class="p">.</span><span class="n">cmdtype</span> <span class="o">!=</span> <span class="n">SMU_CMDTYPE_SMU</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">!=</span> <span class="n">smu_file_commands</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBADFD</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">hdr</span><span class="p">.</span><span class="n">data_len</span> <span class="o">&gt;</span> <span class="n">SMU_MAX_DATA</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">busy</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pp</span><span class="o">-&gt;</span><span class="n">busy</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">pp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="n">buf</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">hdr</span><span class="p">),</span> <span class="n">hdr</span><span class="p">.</span><span class="n">data_len</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pp</span><span class="o">-&gt;</span><span class="n">busy</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">.</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">hdr</span><span class="p">.</span><span class="n">cmd</span><span class="p">;</span>
	<span class="n">pp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">.</span><span class="n">data_len</span> <span class="o">=</span> <span class="n">hdr</span><span class="p">.</span><span class="n">data_len</span><span class="p">;</span>
	<span class="n">pp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">.</span><span class="n">reply_len</span> <span class="o">=</span> <span class="n">SMU_MAX_DATA</span><span class="p">;</span>
	<span class="n">pp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">.</span><span class="n">data_buf</span> <span class="o">=</span> <span class="n">pp</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">;</span>
	<span class="n">pp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">.</span><span class="n">reply_buf</span> <span class="o">=</span> <span class="n">pp</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">;</span>
	<span class="n">pp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">.</span><span class="n">done</span> <span class="o">=</span> <span class="n">smu_user_cmd_done</span><span class="p">;</span>
	<span class="n">pp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">.</span><span class="n">misc</span> <span class="o">=</span> <span class="n">pp</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">smu_queue_cmd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">smu_read_command</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">smu_private</span> <span class="o">*</span><span class="n">pp</span><span class="p">,</span>
				<span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DECLARE_WAITQUEUE</span><span class="p">(</span><span class="n">wait</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">smu_user_reply_hdr</span> <span class="n">hdr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">busy</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">smu_user_reply_hdr</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOVERFLOW</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">.</span><span class="n">status</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">add_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
			<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">.</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ERESTARTSYS</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">schedule</span><span class="p">();</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span>
		<span class="n">remove_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">.</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">pp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">.</span><span class="n">reply_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">hdr</span><span class="p">)</span> <span class="o">+</span> <span class="n">pp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">.</span><span class="n">reply_len</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">)</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">hdr</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="n">pp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">.</span><span class="n">status</span><span class="p">;</span>
	<span class="n">hdr</span><span class="p">.</span><span class="n">reply_len</span> <span class="o">=</span> <span class="n">pp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">.</span><span class="n">reply_len</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hdr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">hdr</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="n">size</span> <span class="o">-=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">hdr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&amp;&amp;</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">hdr</span><span class="p">),</span> <span class="n">pp</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="n">size</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="n">pp</span><span class="o">-&gt;</span><span class="n">busy</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">smu_read_events</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">smu_private</span> <span class="o">*</span><span class="n">pp</span><span class="p">,</span>
			       <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Not implemented */</span>
	<span class="n">msleep_interruptible</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">smu_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			<span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smu_private</span> <span class="o">*</span><span class="n">pp</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">==</span> <span class="n">smu_file_commands</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">smu_read_command</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">pp</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">==</span> <span class="n">smu_file_events</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">smu_read_events</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">pp</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">EBADFD</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">smu_fpoll</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">poll_table</span> <span class="o">*</span><span class="n">wait</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smu_private</span> <span class="o">*</span><span class="n">pp</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pp</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">==</span> <span class="n">smu_file_commands</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">poll_wait</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">,</span> <span class="n">wait</span><span class="p">);</span>

		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">busy</span> <span class="o">&amp;&amp;</span> <span class="n">pp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">.</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">mask</span> <span class="o">|=</span> <span class="n">POLLIN</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">if</span> <span class="p">(</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">==</span> <span class="n">smu_file_events</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Not yet implemented */</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">mask</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">smu_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smu_private</span> <span class="o">*</span><span class="n">pp</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">busy</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pp</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Mark file as closing to avoid races with new request */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">pp</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">smu_file_closing</span><span class="p">;</span>
	<span class="n">busy</span> <span class="o">=</span> <span class="n">pp</span><span class="o">-&gt;</span><span class="n">busy</span><span class="p">;</span>

	<span class="cm">/* Wait for any pending request to complete */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">busy</span> <span class="o">&amp;&amp;</span> <span class="n">pp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">.</span><span class="n">status</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DECLARE_WAITQUEUE</span><span class="p">(</span><span class="n">wait</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>

		<span class="n">add_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
			<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">.</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">schedule</span><span class="p">();</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span>
		<span class="n">remove_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smu_clist_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smu_clist_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">pp</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">smu_device_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">no_llseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">smu_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">smu_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">poll</span>		<span class="o">=</span> <span class="n">smu_fpoll</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">smu_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">smu_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">miscdevice</span> <span class="n">pmu_device</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">MISC_DYNAMIC_MINOR</span><span class="p">,</span> <span class="s">&quot;smu&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">smu_device_fops</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">smu_device_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">smu</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">misc_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pmu_device</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;via-pmu: cannot register misc device.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">device_initcall</span><span class="p">(</span><span class="n">smu_device_init</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
