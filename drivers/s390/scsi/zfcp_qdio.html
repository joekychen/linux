<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › s390 › scsi › zfcp_qdio.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>zfcp_qdio.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * zfcp device driver</span>
<span class="cm"> *</span>
<span class="cm"> * Header file for zfcp qdio interface</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright IBM Corporation 2010</span>
<span class="cm"> */</span>

<span class="cp">#ifndef ZFCP_QDIO_H</span>
<span class="cp">#define ZFCP_QDIO_H</span>

<span class="cp">#include &lt;asm/qdio.h&gt;</span>

<span class="cp">#define ZFCP_QDIO_SBALE_LEN	PAGE_SIZE</span>

<span class="cm">/* Max SBALS for chaining */</span>
<span class="cp">#define ZFCP_QDIO_MAX_SBALS_PER_REQ	36</span>

<span class="cm">/**</span>
<span class="cm"> * struct zfcp_qdio - basic qdio data structure</span>
<span class="cm"> * @res_q: response queue</span>
<span class="cm"> * @req_q: request queue</span>
<span class="cm"> * @req_q_idx: index of next free buffer</span>
<span class="cm"> * @req_q_free: number of free buffers in queue</span>
<span class="cm"> * @stat_lock: lock to protect req_q_util and req_q_time</span>
<span class="cm"> * @req_q_lock: lock to serialize access to request queue</span>
<span class="cm"> * @req_q_time: time of last fill level change</span>
<span class="cm"> * @req_q_util: used for accounting</span>
<span class="cm"> * @req_q_full: queue full incidents</span>
<span class="cm"> * @req_q_wq: used to wait for SBAL availability</span>
<span class="cm"> * @adapter: adapter used in conjunction with this qdio structure</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">zfcp_qdio</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">qdio_buffer</span>	<span class="o">*</span><span class="n">res_q</span><span class="p">[</span><span class="n">QDIO_MAX_BUFFERS_PER_Q</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">qdio_buffer</span>	<span class="o">*</span><span class="n">req_q</span><span class="p">[</span><span class="n">QDIO_MAX_BUFFERS_PER_Q</span><span class="p">];</span>
	<span class="n">u8</span>			<span class="n">req_q_idx</span><span class="p">;</span>
	<span class="n">atomic_t</span>		<span class="n">req_q_free</span><span class="p">;</span>
	<span class="n">spinlock_t</span>		<span class="n">stat_lock</span><span class="p">;</span>
	<span class="n">spinlock_t</span>		<span class="n">req_q_lock</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span>	<span class="n">req_q_time</span><span class="p">;</span>
	<span class="n">u64</span>			<span class="n">req_q_util</span><span class="p">;</span>
	<span class="n">atomic_t</span>		<span class="n">req_q_full</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span>	<span class="n">req_q_wq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">zfcp_adapter</span>	<span class="o">*</span><span class="n">adapter</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">max_sbale_per_sbal</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">max_sbale_per_req</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct zfcp_qdio_req - qdio queue related values for a request</span>
<span class="cm"> * @sbtype: sbal type flags for sbale 0</span>
<span class="cm"> * @sbal_number: number of free sbals</span>
<span class="cm"> * @sbal_first: first sbal for this request</span>
<span class="cm"> * @sbal_last: last sbal for this request</span>
<span class="cm"> * @sbal_limit: last possible sbal for this request</span>
<span class="cm"> * @sbale_curr: current sbale at creation of this request</span>
<span class="cm"> * @sbal_response: sbal used in interrupt</span>
<span class="cm"> * @qdio_outb_usage: usage of outbound queue</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">zfcp_qdio_req</span> <span class="p">{</span>
	<span class="n">u8</span>	<span class="n">sbtype</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">sbal_number</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">sbal_first</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">sbal_last</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">sbal_limit</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">sbale_curr</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">sbal_response</span><span class="p">;</span>
	<span class="n">u16</span>	<span class="n">qdio_outb_usage</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * zfcp_qdio_sbale_req - return pointer to sbale on req_q for a request</span>
<span class="cm"> * @qdio: pointer to struct zfcp_qdio</span>
<span class="cm"> * @q_rec: pointer to struct zfcp_qdio_req</span>
<span class="cm"> * Returns: pointer to qdio_buffer_element (sbale) structure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">qdio_buffer_element</span> <span class="o">*</span>
<span class="nf">zfcp_qdio_sbale_req</span><span class="p">(</span><span class="k">struct</span> <span class="n">zfcp_qdio</span> <span class="o">*</span><span class="n">qdio</span><span class="p">,</span> <span class="k">struct</span> <span class="n">zfcp_qdio_req</span> <span class="o">*</span><span class="n">q_req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">qdio</span><span class="o">-&gt;</span><span class="n">req_q</span><span class="p">[</span><span class="n">q_req</span><span class="o">-&gt;</span><span class="n">sbal_last</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">element</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * zfcp_qdio_sbale_curr - return current sbale on req_q for a request</span>
<span class="cm"> * @qdio: pointer to struct zfcp_qdio</span>
<span class="cm"> * @fsf_req: pointer to struct zfcp_fsf_req</span>
<span class="cm"> * Returns: pointer to qdio_buffer_element (sbale) structure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">qdio_buffer_element</span> <span class="o">*</span>
<span class="nf">zfcp_qdio_sbale_curr</span><span class="p">(</span><span class="k">struct</span> <span class="n">zfcp_qdio</span> <span class="o">*</span><span class="n">qdio</span><span class="p">,</span> <span class="k">struct</span> <span class="n">zfcp_qdio_req</span> <span class="o">*</span><span class="n">q_req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">qdio</span><span class="o">-&gt;</span><span class="n">req_q</span><span class="p">[</span><span class="n">q_req</span><span class="o">-&gt;</span><span class="n">sbal_last</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">element</span><span class="p">[</span><span class="n">q_req</span><span class="o">-&gt;</span><span class="n">sbale_curr</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * zfcp_qdio_req_init - initialize qdio request</span>
<span class="cm"> * @qdio: request queue where to start putting the request</span>
<span class="cm"> * @q_req: the qdio request to start</span>
<span class="cm"> * @req_id: The request id</span>
<span class="cm"> * @sbtype: type flags to set for all sbals</span>
<span class="cm"> * @data: First data block</span>
<span class="cm"> * @len: Length of first data block</span>
<span class="cm"> *</span>
<span class="cm"> * This is the start of putting the request into the queue, the last</span>
<span class="cm"> * step is passing the request to zfcp_qdio_send. The request queue</span>
<span class="cm"> * lock must be held during the whole process from init to send.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">void</span> <span class="nf">zfcp_qdio_req_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">zfcp_qdio</span> <span class="o">*</span><span class="n">qdio</span><span class="p">,</span> <span class="k">struct</span> <span class="n">zfcp_qdio_req</span> <span class="o">*</span><span class="n">q_req</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">req_id</span><span class="p">,</span> <span class="n">u8</span> <span class="n">sbtype</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">u32</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">qdio_buffer_element</span> <span class="o">*</span><span class="n">sbale</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qdio</span><span class="o">-&gt;</span><span class="n">req_q_free</span><span class="p">),</span>
			<span class="n">ZFCP_QDIO_MAX_SBALS_PER_REQ</span><span class="p">);</span>

	<span class="n">q_req</span><span class="o">-&gt;</span><span class="n">sbal_first</span> <span class="o">=</span> <span class="n">q_req</span><span class="o">-&gt;</span><span class="n">sbal_last</span> <span class="o">=</span> <span class="n">qdio</span><span class="o">-&gt;</span><span class="n">req_q_idx</span><span class="p">;</span>
	<span class="n">q_req</span><span class="o">-&gt;</span><span class="n">sbal_number</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">q_req</span><span class="o">-&gt;</span><span class="n">sbtype</span> <span class="o">=</span> <span class="n">sbtype</span><span class="p">;</span>
	<span class="n">q_req</span><span class="o">-&gt;</span><span class="n">sbale_curr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">q_req</span><span class="o">-&gt;</span><span class="n">sbal_limit</span> <span class="o">=</span> <span class="p">(</span><span class="n">q_req</span><span class="o">-&gt;</span><span class="n">sbal_first</span> <span class="o">+</span> <span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
					<span class="o">%</span> <span class="n">QDIO_MAX_BUFFERS_PER_Q</span><span class="p">;</span>

	<span class="n">sbale</span> <span class="o">=</span> <span class="n">zfcp_qdio_sbale_req</span><span class="p">(</span><span class="n">qdio</span><span class="p">,</span> <span class="n">q_req</span><span class="p">);</span>
	<span class="n">sbale</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">req_id</span><span class="p">;</span>
	<span class="n">sbale</span><span class="o">-&gt;</span><span class="n">eflags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sbale</span><span class="o">-&gt;</span><span class="n">sflags</span> <span class="o">=</span> <span class="n">SBAL_SFLAGS0_COMMAND</span> <span class="o">|</span> <span class="n">sbtype</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">data</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">sbale</span><span class="o">++</span><span class="p">;</span>
	<span class="n">sbale</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">sbale</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * zfcp_qdio_fill_next - Fill next sbale, only for single sbal requests</span>
<span class="cm"> * @qdio: pointer to struct zfcp_qdio</span>
<span class="cm"> * @q_req: pointer to struct zfcp_queue_req</span>
<span class="cm"> *</span>
<span class="cm"> * This is only required for single sbal requests, calling it when</span>
<span class="cm"> * wrapping around to the next sbal is a bug.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">void</span> <span class="nf">zfcp_qdio_fill_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">zfcp_qdio</span> <span class="o">*</span><span class="n">qdio</span><span class="p">,</span> <span class="k">struct</span> <span class="n">zfcp_qdio_req</span> <span class="o">*</span><span class="n">q_req</span><span class="p">,</span>
			 <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">u32</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">qdio_buffer_element</span> <span class="o">*</span><span class="n">sbale</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">q_req</span><span class="o">-&gt;</span><span class="n">sbale_curr</span> <span class="o">==</span> <span class="n">qdio</span><span class="o">-&gt;</span><span class="n">max_sbale_per_sbal</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">q_req</span><span class="o">-&gt;</span><span class="n">sbale_curr</span><span class="o">++</span><span class="p">;</span>
	<span class="n">sbale</span> <span class="o">=</span> <span class="n">zfcp_qdio_sbale_curr</span><span class="p">(</span><span class="n">qdio</span><span class="p">,</span> <span class="n">q_req</span><span class="p">);</span>
	<span class="n">sbale</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">sbale</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * zfcp_qdio_set_sbale_last - set last entry flag in current sbale</span>
<span class="cm"> * @qdio: pointer to struct zfcp_qdio</span>
<span class="cm"> * @q_req: pointer to struct zfcp_queue_req</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">void</span> <span class="nf">zfcp_qdio_set_sbale_last</span><span class="p">(</span><span class="k">struct</span> <span class="n">zfcp_qdio</span> <span class="o">*</span><span class="n">qdio</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">zfcp_qdio_req</span> <span class="o">*</span><span class="n">q_req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">qdio_buffer_element</span> <span class="o">*</span><span class="n">sbale</span><span class="p">;</span>

	<span class="n">sbale</span> <span class="o">=</span> <span class="n">zfcp_qdio_sbale_curr</span><span class="p">(</span><span class="n">qdio</span><span class="p">,</span> <span class="n">q_req</span><span class="p">);</span>
	<span class="n">sbale</span><span class="o">-&gt;</span><span class="n">eflags</span> <span class="o">|=</span> <span class="n">SBAL_EFLAGS_LAST_ENTRY</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * zfcp_qdio_sg_one_sbal - check if one sbale is enough for sg data</span>
<span class="cm"> * @sg: The scatterlist where to check the data size</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: 1 when one sbale is enough for the data in the scatterlist,</span>
<span class="cm"> *	    0 if not.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">int</span> <span class="nf">zfcp_qdio_sg_one_sbale</span><span class="p">(</span><span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sg_is_last</span><span class="p">(</span><span class="n">sg</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">sg</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">&lt;=</span> <span class="n">ZFCP_QDIO_SBALE_LEN</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * zfcp_qdio_skip_to_last_sbale - skip to last sbale in sbal</span>
<span class="cm"> * @q_req: The current zfcp_qdio_req</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">void</span> <span class="nf">zfcp_qdio_skip_to_last_sbale</span><span class="p">(</span><span class="k">struct</span> <span class="n">zfcp_qdio</span> <span class="o">*</span><span class="n">qdio</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">zfcp_qdio_req</span> <span class="o">*</span><span class="n">q_req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">q_req</span><span class="o">-&gt;</span><span class="n">sbale_curr</span> <span class="o">=</span> <span class="n">qdio</span><span class="o">-&gt;</span><span class="n">max_sbale_per_sbal</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * zfcp_qdio_sbal_limit - set the sbal limit for a request in q_req</span>
<span class="cm"> * @qdio: pointer to struct zfcp_qdio</span>
<span class="cm"> * @q_req: The current zfcp_qdio_req</span>
<span class="cm"> * @max_sbals: maximum number of SBALs allowed</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">void</span> <span class="nf">zfcp_qdio_sbal_limit</span><span class="p">(</span><span class="k">struct</span> <span class="n">zfcp_qdio</span> <span class="o">*</span><span class="n">qdio</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">zfcp_qdio_req</span> <span class="o">*</span><span class="n">q_req</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max_sbals</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qdio</span><span class="o">-&gt;</span><span class="n">req_q_free</span><span class="p">),</span> <span class="n">max_sbals</span><span class="p">);</span>

	<span class="n">q_req</span><span class="o">-&gt;</span><span class="n">sbal_limit</span> <span class="o">=</span> <span class="p">(</span><span class="n">q_req</span><span class="o">-&gt;</span><span class="n">sbal_first</span> <span class="o">+</span> <span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span>
				<span class="n">QDIO_MAX_BUFFERS_PER_Q</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * zfcp_qdio_set_data_div - set data division count</span>
<span class="cm"> * @qdio: pointer to struct zfcp_qdio</span>
<span class="cm"> * @q_req: The current zfcp_qdio_req</span>
<span class="cm"> * @count: The data division count</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">void</span> <span class="nf">zfcp_qdio_set_data_div</span><span class="p">(</span><span class="k">struct</span> <span class="n">zfcp_qdio</span> <span class="o">*</span><span class="n">qdio</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">zfcp_qdio_req</span> <span class="o">*</span><span class="n">q_req</span><span class="p">,</span> <span class="n">u32</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">qdio_buffer_element</span> <span class="o">*</span><span class="n">sbale</span><span class="p">;</span>

	<span class="n">sbale</span> <span class="o">=</span> <span class="n">qdio</span><span class="o">-&gt;</span><span class="n">req_q</span><span class="p">[</span><span class="n">q_req</span><span class="o">-&gt;</span><span class="n">sbal_first</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">element</span><span class="p">;</span>
	<span class="n">sbale</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * zfcp_qdio_sbale_count - count sbale used</span>
<span class="cm"> * @sg: pointer to struct scatterlist</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">zfcp_qdio_sbale_count</span><span class="p">(</span><span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;</span> <span class="n">sg</span><span class="p">;</span> <span class="n">sg</span> <span class="o">=</span> <span class="n">sg_next</span><span class="p">(</span><span class="n">sg</span><span class="p">))</span>
		<span class="n">count</span><span class="o">++</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * zfcp_qdio_real_bytes - count bytes used</span>
<span class="cm"> * @sg: pointer to struct scatterlist</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">zfcp_qdio_real_bytes</span><span class="p">(</span><span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">real_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;</span> <span class="n">sg</span><span class="p">;</span> <span class="n">sg</span> <span class="o">=</span> <span class="n">sg_next</span><span class="p">(</span><span class="n">sg</span><span class="p">))</span>
		<span class="n">real_bytes</span> <span class="o">+=</span> <span class="n">sg</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">real_bytes</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * zfcp_qdio_set_scount - set SBAL count value</span>
<span class="cm"> * @qdio: pointer to struct zfcp_qdio</span>
<span class="cm"> * @q_req: The current zfcp_qdio_req</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">void</span> <span class="nf">zfcp_qdio_set_scount</span><span class="p">(</span><span class="k">struct</span> <span class="n">zfcp_qdio</span> <span class="o">*</span><span class="n">qdio</span><span class="p">,</span> <span class="k">struct</span> <span class="n">zfcp_qdio_req</span> <span class="o">*</span><span class="n">q_req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">qdio_buffer_element</span> <span class="o">*</span><span class="n">sbale</span><span class="p">;</span>

	<span class="n">sbale</span> <span class="o">=</span> <span class="n">qdio</span><span class="o">-&gt;</span><span class="n">req_q</span><span class="p">[</span><span class="n">q_req</span><span class="o">-&gt;</span><span class="n">sbal_first</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">element</span><span class="p">;</span>
	<span class="n">sbale</span><span class="o">-&gt;</span><span class="n">scount</span> <span class="o">=</span> <span class="n">q_req</span><span class="o">-&gt;</span><span class="n">sbal_number</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* ZFCP_QDIO_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
