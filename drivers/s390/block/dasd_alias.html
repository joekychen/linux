<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › s390 › block › dasd_alias.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>dasd_alias.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * PAV alias management for the DASD ECKD discipline</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright IBM Corporation, 2007</span>
<span class="cm"> * Author(s): Stefan Weinhuber &lt;wein@de.ibm.com&gt;</span>
<span class="cm"> */</span>

<span class="cp">#define KMSG_COMPONENT &quot;dasd-eckd&quot;</span>

<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;asm/ebcdic.h&gt;</span>
<span class="cp">#include &quot;dasd_int.h&quot;</span>
<span class="cp">#include &quot;dasd_eckd.h&quot;</span>

<span class="cp">#ifdef PRINTK_HEADER</span>
<span class="cp">#undef PRINTK_HEADER</span>
<span class="cp">#endif				</span><span class="cm">/* PRINTK_HEADER */</span><span class="cp"></span>
<span class="cp">#define PRINTK_HEADER &quot;dasd(eckd):&quot;</span>


<span class="cm">/*</span>
<span class="cm"> * General concept of alias management:</span>
<span class="cm"> * - PAV and DASD alias management is specific to the eckd discipline.</span>
<span class="cm"> * - A device is connected to an lcu as long as the device exists.</span>
<span class="cm"> *   dasd_alias_make_device_known_to_lcu will be called wenn the</span>
<span class="cm"> *   device is checked by the eckd discipline and</span>
<span class="cm"> *   dasd_alias_disconnect_device_from_lcu will be called</span>
<span class="cm"> *   before the device is deleted.</span>
<span class="cm"> * - The dasd_alias_add_device / dasd_alias_remove_device</span>
<span class="cm"> *   functions mark the point when a device is &#39;ready for service&#39;.</span>
<span class="cm"> * - A summary unit check is a rare occasion, but it is mandatory to</span>
<span class="cm"> *   support it. It requires some complex recovery actions before the</span>
<span class="cm"> *   devices can be used again (see dasd_alias_handle_summary_unit_check).</span>
<span class="cm"> * - dasd_alias_get_start_dev will find an alias device that can be used</span>
<span class="cm"> *   instead of the base device and does some (very simple) load balancing.</span>
<span class="cm"> *   This is the function that gets called for each I/O, so when improving</span>
<span class="cm"> *   something, this function should get faster or better, the rest has just</span>
<span class="cm"> *   to be correct.</span>
<span class="cm"> */</span>


<span class="k">static</span> <span class="kt">void</span> <span class="n">summary_unit_check_handling_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">lcu_update_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">_schedule_lcu_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">alias_lcu</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">alias_root</span> <span class="n">aliastree</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">serverlist</span> <span class="o">=</span> <span class="n">LIST_HEAD_INIT</span><span class="p">(</span><span class="n">aliastree</span><span class="p">.</span><span class="n">serverlist</span><span class="p">),</span>
	<span class="p">.</span><span class="n">lock</span> <span class="o">=</span> <span class="n">__SPIN_LOCK_UNLOCKED</span><span class="p">(</span><span class="n">aliastree</span><span class="p">.</span><span class="n">lock</span><span class="p">),</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">alias_server</span> <span class="o">*</span><span class="nf">_find_server</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_uid</span> <span class="o">*</span><span class="n">uid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">alias_server</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">aliastree</span><span class="p">.</span><span class="n">serverlist</span><span class="p">,</span> <span class="n">server</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">pos</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">.</span><span class="n">vendor</span><span class="p">,</span> <span class="n">uid</span><span class="o">-&gt;</span><span class="n">vendor</span><span class="p">,</span>
			     <span class="k">sizeof</span><span class="p">(</span><span class="n">uid</span><span class="o">-&gt;</span><span class="n">vendor</span><span class="p">))</span>
		    <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">pos</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">.</span><span class="n">serial</span><span class="p">,</span> <span class="n">uid</span><span class="o">-&gt;</span><span class="n">serial</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="n">uid</span><span class="o">-&gt;</span><span class="n">serial</span><span class="p">)))</span>
			<span class="k">return</span> <span class="n">pos</span><span class="p">;</span>
	<span class="p">};</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">alias_lcu</span> <span class="o">*</span><span class="nf">_find_lcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">alias_server</span> <span class="o">*</span><span class="n">server</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">dasd_uid</span> <span class="o">*</span><span class="n">uid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">alias_lcu</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">lculist</span><span class="p">,</span> <span class="n">lcu</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pos</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">.</span><span class="n">ssid</span> <span class="o">==</span> <span class="n">uid</span><span class="o">-&gt;</span><span class="n">ssid</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">pos</span><span class="p">;</span>
	<span class="p">};</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">alias_pav_group</span> <span class="o">*</span><span class="nf">_find_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">alias_lcu</span> <span class="o">*</span><span class="n">lcu</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">dasd_uid</span> <span class="o">*</span><span class="n">uid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">alias_pav_group</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">search_unit_addr</span><span class="p">;</span>

	<span class="cm">/* for hyper pav there is only one group */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">pav</span> <span class="o">==</span> <span class="n">HYPER_PAV</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">grouplist</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">grouplist</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">alias_pav_group</span><span class="p">,</span> <span class="n">group</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* for base pav we have to find the group that matches the base */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">uid</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">UA_BASE_DEVICE</span><span class="p">)</span>
		<span class="n">search_unit_addr</span> <span class="o">=</span> <span class="n">uid</span><span class="o">-&gt;</span><span class="n">real_unit_addr</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">search_unit_addr</span> <span class="o">=</span> <span class="n">uid</span><span class="o">-&gt;</span><span class="n">base_unit_addr</span><span class="p">;</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">grouplist</span><span class="p">,</span> <span class="n">group</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pos</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">.</span><span class="n">base_unit_addr</span> <span class="o">==</span> <span class="n">search_unit_addr</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">pos</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">.</span><span class="n">vduit</span><span class="p">,</span> <span class="n">uid</span><span class="o">-&gt;</span><span class="n">vduit</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">uid</span><span class="o">-&gt;</span><span class="n">vduit</span><span class="p">)))</span>
			<span class="k">return</span> <span class="n">pos</span><span class="p">;</span>
	<span class="p">};</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">alias_server</span> <span class="o">*</span><span class="nf">_allocate_server</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_uid</span> <span class="o">*</span><span class="n">uid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">alias_server</span> <span class="o">*</span><span class="n">server</span><span class="p">;</span>

	<span class="n">server</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">server</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">server</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">.</span><span class="n">vendor</span><span class="p">,</span> <span class="n">uid</span><span class="o">-&gt;</span><span class="n">vendor</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">uid</span><span class="o">-&gt;</span><span class="n">vendor</span><span class="p">));</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">.</span><span class="n">serial</span><span class="p">,</span> <span class="n">uid</span><span class="o">-&gt;</span><span class="n">serial</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">uid</span><span class="o">-&gt;</span><span class="n">serial</span><span class="p">));</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">server</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">lculist</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">server</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">_free_server</span><span class="p">(</span><span class="k">struct</span> <span class="n">alias_server</span> <span class="o">*</span><span class="n">server</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">server</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">alias_lcu</span> <span class="o">*</span><span class="nf">_allocate_lcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_uid</span> <span class="o">*</span><span class="n">uid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">alias_lcu</span> <span class="o">*</span><span class="n">lcu</span><span class="p">;</span>

	<span class="n">lcu</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">lcu</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lcu</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
	<span class="n">lcu</span><span class="o">-&gt;</span><span class="n">uac</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">uac</span><span class="p">)),</span> <span class="n">GFP_KERNEL</span> <span class="o">|</span> <span class="n">GFP_DMA</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">uac</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_err1</span><span class="p">;</span>
	<span class="n">lcu</span><span class="o">-&gt;</span><span class="n">rsu_cqr</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">rsu_cqr</span><span class="p">),</span> <span class="n">GFP_KERNEL</span> <span class="o">|</span> <span class="n">GFP_DMA</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">rsu_cqr</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_err2</span><span class="p">;</span>
	<span class="n">lcu</span><span class="o">-&gt;</span><span class="n">rsu_cqr</span><span class="o">-&gt;</span><span class="n">cpaddr</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ccw1</span><span class="p">),</span>
				       <span class="n">GFP_KERNEL</span> <span class="o">|</span> <span class="n">GFP_DMA</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">rsu_cqr</span><span class="o">-&gt;</span><span class="n">cpaddr</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_err3</span><span class="p">;</span>
	<span class="n">lcu</span><span class="o">-&gt;</span><span class="n">rsu_cqr</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="n">GFP_KERNEL</span> <span class="o">|</span> <span class="n">GFP_DMA</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">rsu_cqr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_err4</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">.</span><span class="n">vendor</span><span class="p">,</span> <span class="n">uid</span><span class="o">-&gt;</span><span class="n">vendor</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">uid</span><span class="o">-&gt;</span><span class="n">vendor</span><span class="p">));</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">.</span><span class="n">serial</span><span class="p">,</span> <span class="n">uid</span><span class="o">-&gt;</span><span class="n">serial</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">uid</span><span class="o">-&gt;</span><span class="n">serial</span><span class="p">));</span>
	<span class="n">lcu</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">.</span><span class="n">ssid</span> <span class="o">=</span> <span class="n">uid</span><span class="o">-&gt;</span><span class="n">ssid</span><span class="p">;</span>
	<span class="n">lcu</span><span class="o">-&gt;</span><span class="n">pav</span> <span class="o">=</span> <span class="n">NO_PAV</span><span class="p">;</span>
	<span class="n">lcu</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">NEED_UAC_UPDATE</span> <span class="o">|</span> <span class="n">UPDATE_PENDING</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">lcu</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">inactive_devices</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">active_devices</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">grouplist</span><span class="p">);</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">suc_data</span><span class="p">.</span><span class="n">worker</span><span class="p">,</span> <span class="n">summary_unit_check_handling_work</span><span class="p">);</span>
	<span class="n">INIT_DELAYED_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">ruac_data</span><span class="p">.</span><span class="n">dwork</span><span class="p">,</span> <span class="n">lcu_update_work</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">lcu_setup</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">lcu</span><span class="p">;</span>

<span class="nl">out_err4:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">rsu_cqr</span><span class="o">-&gt;</span><span class="n">cpaddr</span><span class="p">);</span>
<span class="nl">out_err3:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">rsu_cqr</span><span class="p">);</span>
<span class="nl">out_err2:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">uac</span><span class="p">);</span>
<span class="nl">out_err1:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">lcu</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">_free_lcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">alias_lcu</span> <span class="o">*</span><span class="n">lcu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">rsu_cqr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">rsu_cqr</span><span class="o">-&gt;</span><span class="n">cpaddr</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">rsu_cqr</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">uac</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">lcu</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is the function that will allocate all the server and lcu data,</span>
<span class="cm"> * so this function must be called first for a new device.</span>
<span class="cm"> * If the return value is 1, the lcu was already known before, if it</span>
<span class="cm"> * is 0, this is a new lcu.</span>
<span class="cm"> * Negative return code indicates that something went wrong (e.g. -ENOMEM)</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dasd_alias_make_device_known_to_lcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dasd_eckd_private</span> <span class="o">*</span><span class="n">private</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">alias_server</span> <span class="o">*</span><span class="n">server</span><span class="p">,</span> <span class="o">*</span><span class="n">newserver</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">alias_lcu</span> <span class="o">*</span><span class="n">lcu</span><span class="p">,</span> <span class="o">*</span><span class="n">newlcu</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dasd_uid</span> <span class="n">uid</span><span class="p">;</span>

	<span class="n">private</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dasd_eckd_private</span> <span class="o">*</span><span class="p">)</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>

	<span class="n">device</span><span class="o">-&gt;</span><span class="n">discipline</span><span class="o">-&gt;</span><span class="n">get_uid</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uid</span><span class="p">);</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aliastree</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">server</span> <span class="o">=</span> <span class="n">_find_server</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">server</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aliastree</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">newserver</span> <span class="o">=</span> <span class="n">_allocate_server</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">newserver</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">newserver</span><span class="p">);</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aliastree</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">server</span> <span class="o">=</span> <span class="n">_find_server</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">server</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newserver</span><span class="o">-&gt;</span><span class="n">server</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">aliastree</span><span class="p">.</span><span class="n">serverlist</span><span class="p">);</span>
			<span class="n">server</span> <span class="o">=</span> <span class="n">newserver</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* someone was faster */</span>
			<span class="n">_free_server</span><span class="p">(</span><span class="n">newserver</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">lcu</span> <span class="o">=</span> <span class="n">_find_lcu</span><span class="p">(</span><span class="n">server</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lcu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aliastree</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">newlcu</span> <span class="o">=</span> <span class="n">_allocate_lcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">newlcu</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">newlcu</span><span class="p">);</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aliastree</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">lcu</span> <span class="o">=</span> <span class="n">_find_lcu</span><span class="p">(</span><span class="n">server</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lcu</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newlcu</span><span class="o">-&gt;</span><span class="n">lcu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">lculist</span><span class="p">);</span>
			<span class="n">lcu</span> <span class="o">=</span> <span class="n">newlcu</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* someone was faster */</span>
			<span class="n">_free_lcu</span><span class="p">(</span><span class="n">newlcu</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">alias_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">inactive_devices</span><span class="p">);</span>
	<span class="n">private</span><span class="o">-&gt;</span><span class="n">lcu</span> <span class="o">=</span> <span class="n">lcu</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aliastree</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This function removes a device from the scope of alias management.</span>
<span class="cm"> * The complicated part is to make sure that it is not in use by</span>
<span class="cm"> * any of the workers. If necessary cancel the work.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">dasd_alias_disconnect_device_from_lcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dasd_eckd_private</span> <span class="o">*</span><span class="n">private</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">alias_lcu</span> <span class="o">*</span><span class="n">lcu</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">alias_server</span> <span class="o">*</span><span class="n">server</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">was_pending</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dasd_uid</span> <span class="n">uid</span><span class="p">;</span>

	<span class="n">private</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dasd_eckd_private</span> <span class="o">*</span><span class="p">)</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="n">lcu</span> <span class="o">=</span> <span class="n">private</span><span class="o">-&gt;</span><span class="n">lcu</span><span class="p">;</span>
	<span class="cm">/* nothing to do if already disconnected */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lcu</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">device</span><span class="o">-&gt;</span><span class="n">discipline</span><span class="o">-&gt;</span><span class="n">get_uid</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uid</span><span class="p">);</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">alias_list</span><span class="p">);</span>
	<span class="cm">/* make sure that the workers don&#39;t use this device */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">device</span> <span class="o">==</span> <span class="n">lcu</span><span class="o">-&gt;</span><span class="n">suc_data</span><span class="p">.</span><span class="n">device</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">cancel_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">suc_data</span><span class="p">.</span><span class="n">worker</span><span class="p">);</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">device</span> <span class="o">==</span> <span class="n">lcu</span><span class="o">-&gt;</span><span class="n">suc_data</span><span class="p">.</span><span class="n">device</span><span class="p">)</span>
			<span class="n">lcu</span><span class="o">-&gt;</span><span class="n">suc_data</span><span class="p">.</span><span class="n">device</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">was_pending</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">device</span> <span class="o">==</span> <span class="n">lcu</span><span class="o">-&gt;</span><span class="n">ruac_data</span><span class="p">.</span><span class="n">device</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">was_pending</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">cancel_delayed_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">ruac_data</span><span class="p">.</span><span class="n">dwork</span><span class="p">);</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">device</span> <span class="o">==</span> <span class="n">lcu</span><span class="o">-&gt;</span><span class="n">ruac_data</span><span class="p">.</span><span class="n">device</span><span class="p">)</span>
			<span class="n">lcu</span><span class="o">-&gt;</span><span class="n">ruac_data</span><span class="p">.</span><span class="n">device</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">private</span><span class="o">-&gt;</span><span class="n">lcu</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aliastree</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">grouplist</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">active_devices</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">inactive_devices</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">lcu</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">_free_lcu</span><span class="p">(</span><span class="n">lcu</span><span class="p">);</span>
		<span class="n">lcu</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">was_pending</span><span class="p">)</span>
			<span class="n">_schedule_lcu_update</span><span class="p">(</span><span class="n">lcu</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">server</span> <span class="o">=</span> <span class="n">_find_server</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">server</span> <span class="o">&amp;&amp;</span> <span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">lculist</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">server</span><span class="p">);</span>
		<span class="n">_free_server</span><span class="p">(</span><span class="n">server</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aliastree</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This function assumes that the unit address configuration stored</span>
<span class="cm"> * in the lcu is up to date and will update the device uid before</span>
<span class="cm"> * adding it to a pav group.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">_add_device_to_lcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">alias_lcu</span> <span class="o">*</span><span class="n">lcu</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>

	<span class="k">struct</span> <span class="n">dasd_eckd_private</span> <span class="o">*</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">alias_pav_group</span> <span class="o">*</span><span class="n">group</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dasd_uid</span> <span class="n">uid</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">private</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dasd_eckd_private</span> <span class="o">*</span><span class="p">)</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>

	<span class="cm">/* only lock if not already locked */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">device</span> <span class="o">!=</span> <span class="n">pos</span><span class="p">)</span>
		<span class="n">spin_lock_irqsave_nested</span><span class="p">(</span><span class="n">get_ccwdev_lock</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">),</span> <span class="n">flags</span><span class="p">,</span>
					 <span class="n">CDEV_NESTED_SECOND</span><span class="p">);</span>
	<span class="n">private</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">lcu</span><span class="o">-&gt;</span><span class="n">uac</span><span class="o">-&gt;</span><span class="n">unit</span><span class="p">[</span><span class="n">private</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">.</span><span class="n">real_unit_addr</span><span class="p">].</span><span class="n">ua_type</span><span class="p">;</span>
	<span class="n">private</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">.</span><span class="n">base_unit_addr</span> <span class="o">=</span>
		<span class="n">lcu</span><span class="o">-&gt;</span><span class="n">uac</span><span class="o">-&gt;</span><span class="n">unit</span><span class="p">[</span><span class="n">private</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">.</span><span class="n">real_unit_addr</span><span class="p">].</span><span class="n">base_ua</span><span class="p">;</span>
	<span class="n">uid</span> <span class="o">=</span> <span class="n">private</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">device</span> <span class="o">!=</span> <span class="n">pos</span><span class="p">)</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">get_ccwdev_lock</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* if we have no PAV anyway, we don&#39;t need to bother with PAV groups */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">pav</span> <span class="o">==</span> <span class="n">NO_PAV</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">alias_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">active_devices</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">group</span> <span class="o">=</span> <span class="n">_find_group</span><span class="p">(</span><span class="n">lcu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">group</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">group</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">group</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">group</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">group</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">.</span><span class="n">vendor</span><span class="p">,</span> <span class="n">uid</span><span class="p">.</span><span class="n">vendor</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">uid</span><span class="p">.</span><span class="n">vendor</span><span class="p">));</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">group</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">.</span><span class="n">serial</span><span class="p">,</span> <span class="n">uid</span><span class="p">.</span><span class="n">serial</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">uid</span><span class="p">.</span><span class="n">serial</span><span class="p">));</span>
		<span class="n">group</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">.</span><span class="n">ssid</span> <span class="o">=</span> <span class="n">uid</span><span class="p">.</span><span class="n">ssid</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">uid</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">UA_BASE_DEVICE</span><span class="p">)</span>
			<span class="n">group</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">.</span><span class="n">base_unit_addr</span> <span class="o">=</span> <span class="n">uid</span><span class="p">.</span><span class="n">real_unit_addr</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">group</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">.</span><span class="n">base_unit_addr</span> <span class="o">=</span> <span class="n">uid</span><span class="p">.</span><span class="n">base_unit_addr</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">group</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">.</span><span class="n">vduit</span><span class="p">,</span> <span class="n">uid</span><span class="p">.</span><span class="n">vduit</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">uid</span><span class="p">.</span><span class="n">vduit</span><span class="p">));</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">group</span><span class="o">-&gt;</span><span class="n">group</span><span class="p">);</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">group</span><span class="o">-&gt;</span><span class="n">baselist</span><span class="p">);</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">group</span><span class="o">-&gt;</span><span class="n">aliaslist</span><span class="p">);</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">group</span><span class="o">-&gt;</span><span class="n">group</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">grouplist</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">uid</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">UA_BASE_DEVICE</span><span class="p">)</span>
		<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">alias_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">group</span><span class="o">-&gt;</span><span class="n">baselist</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">alias_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">group</span><span class="o">-&gt;</span><span class="n">aliaslist</span><span class="p">);</span>
	<span class="n">private</span><span class="o">-&gt;</span><span class="n">pavgroup</span> <span class="o">=</span> <span class="n">group</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">_remove_device_from_lcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">alias_lcu</span> <span class="o">*</span><span class="n">lcu</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dasd_eckd_private</span> <span class="o">*</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">alias_pav_group</span> <span class="o">*</span><span class="n">group</span><span class="p">;</span>

	<span class="n">private</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dasd_eckd_private</span> <span class="o">*</span><span class="p">)</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">alias_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">inactive_devices</span><span class="p">);</span>
	<span class="n">group</span> <span class="o">=</span> <span class="n">private</span><span class="o">-&gt;</span><span class="n">pavgroup</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">group</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">private</span><span class="o">-&gt;</span><span class="n">pavgroup</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">group</span><span class="o">-&gt;</span><span class="n">baselist</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">group</span><span class="o">-&gt;</span><span class="n">aliaslist</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">group</span><span class="o">-&gt;</span><span class="n">group</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">group</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">group</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="n">device</span><span class="p">)</span>
		<span class="n">group</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">read_unit_address_configuration</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">alias_lcu</span> <span class="o">*</span><span class="n">lcu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dasd_psf_prssd_data</span> <span class="o">*</span><span class="n">prssdp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dasd_ccw_req</span> <span class="o">*</span><span class="n">cqr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ccw1</span> <span class="o">*</span><span class="n">ccw</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">cqr</span> <span class="o">=</span> <span class="n">dasd_kmalloc_request</span><span class="p">(</span><span class="n">DASD_ECKD_MAGIC</span><span class="p">,</span> <span class="mi">1</span> <span class="cm">/* PSF */</span>	<span class="o">+</span> <span class="mi">1</span> <span class="cm">/* RSSD */</span><span class="p">,</span>
				   <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_psf_prssd_data</span><span class="p">)),</span>
				   <span class="n">device</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">cqr</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">cqr</span><span class="p">);</span>
	<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">startdev</span> <span class="o">=</span> <span class="n">device</span><span class="p">;</span>
	<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">memdev</span> <span class="o">=</span> <span class="n">device</span><span class="p">;</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">DASD_CQR_FLAGS_USE_ERP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">retries</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
	<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">expires</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">;</span>

	<span class="cm">/* Prepare for Read Subsystem Data */</span>
	<span class="n">prssdp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dasd_psf_prssd_data</span> <span class="o">*</span><span class="p">)</span> <span class="n">cqr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">prssdp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_psf_prssd_data</span><span class="p">));</span>
	<span class="n">prssdp</span><span class="o">-&gt;</span><span class="n">order</span> <span class="o">=</span> <span class="n">PSF_ORDER_PRSSD</span><span class="p">;</span>
	<span class="n">prssdp</span><span class="o">-&gt;</span><span class="n">suborder</span> <span class="o">=</span> <span class="mh">0x0e</span><span class="p">;</span>	<span class="cm">/* Read unit address configuration */</span>
	<span class="cm">/* all other bytes of prssdp must be zero */</span>

	<span class="n">ccw</span> <span class="o">=</span> <span class="n">cqr</span><span class="o">-&gt;</span><span class="n">cpaddr</span><span class="p">;</span>
	<span class="n">ccw</span><span class="o">-&gt;</span><span class="n">cmd_code</span> <span class="o">=</span> <span class="n">DASD_ECKD_CCW_PSF</span><span class="p">;</span>
	<span class="n">ccw</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_psf_prssd_data</span><span class="p">);</span>
	<span class="n">ccw</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">CCW_FLAG_CC</span><span class="p">;</span>
	<span class="n">ccw</span><span class="o">-&gt;</span><span class="n">cda</span> <span class="o">=</span> <span class="p">(</span><span class="n">__u32</span><span class="p">)(</span><span class="n">addr_t</span><span class="p">)</span> <span class="n">prssdp</span><span class="p">;</span>

	<span class="cm">/* Read Subsystem Data - feature codes */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">uac</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">uac</span><span class="p">)));</span>

	<span class="n">ccw</span><span class="o">++</span><span class="p">;</span>
	<span class="n">ccw</span><span class="o">-&gt;</span><span class="n">cmd_code</span> <span class="o">=</span> <span class="n">DASD_ECKD_CCW_RSSD</span><span class="p">;</span>
	<span class="n">ccw</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">uac</span><span class="p">));</span>
	<span class="n">ccw</span><span class="o">-&gt;</span><span class="n">cda</span> <span class="o">=</span> <span class="p">(</span><span class="n">__u32</span><span class="p">)(</span><span class="n">addr_t</span><span class="p">)</span> <span class="n">lcu</span><span class="o">-&gt;</span><span class="n">uac</span><span class="p">;</span>

	<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">buildclk</span> <span class="o">=</span> <span class="n">get_clock</span><span class="p">();</span>
	<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">DASD_CQR_FILLED</span><span class="p">;</span>

	<span class="cm">/* need to unset flag here to detect race with summary unit check */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">lcu</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NEED_UAC_UPDATE</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">dasd_sleep_on</span><span class="p">(</span><span class="n">cqr</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">retries</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">lcu</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">NEED_UAC_UPDATE</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">dasd_kfree_request</span><span class="p">(</span><span class="n">cqr</span><span class="p">,</span> <span class="n">cqr</span><span class="o">-&gt;</span><span class="n">memdev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">_lcu_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">refdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">alias_lcu</span> <span class="o">*</span><span class="n">lcu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">alias_pav_group</span> <span class="o">*</span><span class="n">pavgroup</span><span class="p">,</span> <span class="o">*</span><span class="n">tempgroup</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">,</span> <span class="o">*</span><span class="n">tempdev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dasd_eckd_private</span> <span class="o">*</span><span class="n">private</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">pavgroup</span><span class="p">,</span> <span class="n">tempgroup</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">grouplist</span><span class="p">,</span> <span class="n">group</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">tempdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pavgroup</span><span class="o">-&gt;</span><span class="n">baselist</span><span class="p">,</span>
					 <span class="n">alias_list</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">alias_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">active_devices</span><span class="p">);</span>
			<span class="n">private</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dasd_eckd_private</span> <span class="o">*</span><span class="p">)</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
			<span class="n">private</span><span class="o">-&gt;</span><span class="n">pavgroup</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">tempdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pavgroup</span><span class="o">-&gt;</span><span class="n">aliaslist</span><span class="p">,</span>
					 <span class="n">alias_list</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">alias_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">active_devices</span><span class="p">);</span>
			<span class="n">private</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dasd_eckd_private</span> <span class="o">*</span><span class="p">)</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
			<span class="n">private</span><span class="o">-&gt;</span><span class="n">pavgroup</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pavgroup</span><span class="o">-&gt;</span><span class="n">group</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">pavgroup</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">read_unit_address_configuration</span><span class="p">(</span><span class="n">refdev</span><span class="p">,</span> <span class="n">lcu</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* need to take cdev lock before lcu lock */</span>
	<span class="n">spin_lock_irqsave_nested</span><span class="p">(</span><span class="n">get_ccwdev_lock</span><span class="p">(</span><span class="n">refdev</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">),</span> <span class="n">flags</span><span class="p">,</span>
				 <span class="n">CDEV_NESTED_FIRST</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">lcu</span><span class="o">-&gt;</span><span class="n">pav</span> <span class="o">=</span> <span class="n">NO_PAV</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_DEVICES_PER_LCU</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">uac</span><span class="o">-&gt;</span><span class="n">unit</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">ua_type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">UA_BASE_PAV_ALIAS</span>:
			<span class="n">lcu</span><span class="o">-&gt;</span><span class="n">pav</span> <span class="o">=</span> <span class="n">BASE_PAV</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">UA_HYPER_PAV_ALIAS</span>:
			<span class="n">lcu</span><span class="o">-&gt;</span><span class="n">pav</span> <span class="o">=</span> <span class="n">HYPER_PAV</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">pav</span> <span class="o">!=</span> <span class="n">NO_PAV</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">tempdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">active_devices</span><span class="p">,</span>
				 <span class="n">alias_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">_add_device_to_lcu</span><span class="p">(</span><span class="n">lcu</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="n">refdev</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">get_ccwdev_lock</span><span class="p">(</span><span class="n">refdev</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">lcu_update_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">alias_lcu</span> <span class="o">*</span><span class="n">lcu</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">read_uac_work_data</span> <span class="o">*</span><span class="n">ruac_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">ruac_data</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">read_uac_work_data</span><span class="p">,</span> <span class="n">dwork</span><span class="p">.</span><span class="n">work</span><span class="p">);</span>
	<span class="n">lcu</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">ruac_data</span><span class="p">,</span> <span class="k">struct</span> <span class="n">alias_lcu</span><span class="p">,</span> <span class="n">ruac_data</span><span class="p">);</span>
	<span class="n">device</span> <span class="o">=</span> <span class="n">ruac_data</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">_lcu_update</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">lcu</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Need to check flags again, as there could have been another</span>
<span class="cm">	 * prepare_update or a new device a new device while we were still</span>
<span class="cm">	 * processing the data</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">||</span> <span class="p">(</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">NEED_UAC_UPDATE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">DBF_DEV_EVENT</span><span class="p">(</span><span class="n">DBF_WARNING</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="s">&quot;could not update&quot;</span>
			    <span class="s">&quot; alias data in lcu (rc = %d), retry later&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="n">schedule_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">ruac_data</span><span class="p">.</span><span class="n">dwork</span><span class="p">,</span> <span class="mi">30</span><span class="o">*</span><span class="n">HZ</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">lcu</span><span class="o">-&gt;</span><span class="n">ruac_data</span><span class="p">.</span><span class="n">device</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">lcu</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">UPDATE_PENDING</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">_schedule_lcu_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">alias_lcu</span> <span class="o">*</span><span class="n">lcu</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">usedev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">alias_pav_group</span> <span class="o">*</span><span class="n">group</span><span class="p">;</span>

	<span class="n">lcu</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">NEED_UAC_UPDATE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">ruac_data</span><span class="p">.</span><span class="n">device</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* already scheduled or running */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">device</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">alias_list</span><span class="p">))</span>
		<span class="n">usedev</span> <span class="o">=</span> <span class="n">device</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">usedev</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">grouplist</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">group</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">grouplist</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">alias_pav_group</span><span class="p">,</span> <span class="n">group</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">group</span><span class="o">-&gt;</span><span class="n">baselist</span><span class="p">))</span>
			<span class="n">usedev</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">group</span><span class="o">-&gt;</span><span class="n">baselist</span><span class="p">,</span>
						  <span class="k">struct</span> <span class="n">dasd_device</span><span class="p">,</span>
						  <span class="n">alias_list</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">group</span><span class="o">-&gt;</span><span class="n">aliaslist</span><span class="p">))</span>
			<span class="n">usedev</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">group</span><span class="o">-&gt;</span><span class="n">aliaslist</span><span class="p">,</span>
						  <span class="k">struct</span> <span class="n">dasd_device</span><span class="p">,</span>
						  <span class="n">alias_list</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">usedev</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">active_devices</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">usedev</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">active_devices</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">dasd_device</span><span class="p">,</span> <span class="n">alias_list</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * if we haven&#39;t found a proper device yet, give up for now, the next</span>
<span class="cm">	 * device that will be set active will trigger an lcu update</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">usedev</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">lcu</span><span class="o">-&gt;</span><span class="n">ruac_data</span><span class="p">.</span><span class="n">device</span> <span class="o">=</span> <span class="n">usedev</span><span class="p">;</span>
	<span class="n">schedule_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">ruac_data</span><span class="p">.</span><span class="n">dwork</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">dasd_alias_add_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dasd_eckd_private</span> <span class="o">*</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">alias_lcu</span> <span class="o">*</span><span class="n">lcu</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">private</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dasd_eckd_private</span> <span class="o">*</span><span class="p">)</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="n">lcu</span> <span class="o">=</span> <span class="n">private</span><span class="o">-&gt;</span><span class="n">lcu</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* need to take cdev lock before lcu lock */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">get_ccwdev_lock</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">UPDATE_PENDING</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">_add_device_to_lcu</span><span class="p">(</span><span class="n">lcu</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="n">device</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="n">lcu</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">UPDATE_PENDING</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">UPDATE_PENDING</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">alias_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">active_devices</span><span class="p">);</span>
		<span class="n">_schedule_lcu_update</span><span class="p">(</span><span class="n">lcu</span><span class="p">,</span> <span class="n">device</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">get_ccwdev_lock</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">dasd_alias_update_add_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dasd_eckd_private</span> <span class="o">*</span><span class="n">private</span><span class="p">;</span>
	<span class="n">private</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dasd_eckd_private</span> <span class="o">*</span><span class="p">)</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="n">private</span><span class="o">-&gt;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">UPDATE_PENDING</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">dasd_alias_add_device</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">dasd_alias_remove_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dasd_eckd_private</span> <span class="o">*</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">alias_lcu</span> <span class="o">*</span><span class="n">lcu</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">private</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dasd_eckd_private</span> <span class="o">*</span><span class="p">)</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="n">lcu</span> <span class="o">=</span> <span class="n">private</span><span class="o">-&gt;</span><span class="n">lcu</span><span class="p">;</span>
	<span class="cm">/* nothing to do if already removed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lcu</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">_remove_device_from_lcu</span><span class="p">(</span><span class="n">lcu</span><span class="p">,</span> <span class="n">device</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="nf">dasd_alias_get_start_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">base_device</span><span class="p">)</span>
<span class="p">{</span>

	<span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">alias_device</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">alias_pav_group</span> <span class="o">*</span><span class="n">group</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">alias_lcu</span> <span class="o">*</span><span class="n">lcu</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dasd_eckd_private</span> <span class="o">*</span><span class="n">private</span><span class="p">,</span> <span class="o">*</span><span class="n">alias_priv</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">private</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dasd_eckd_private</span> <span class="o">*</span><span class="p">)</span> <span class="n">base_device</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="n">group</span> <span class="o">=</span> <span class="n">private</span><span class="o">-&gt;</span><span class="n">pavgroup</span><span class="p">;</span>
	<span class="n">lcu</span> <span class="o">=</span> <span class="n">private</span><span class="o">-&gt;</span><span class="n">lcu</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">group</span> <span class="o">||</span> <span class="o">!</span><span class="n">lcu</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">pav</span> <span class="o">==</span> <span class="n">NO_PAV</span> <span class="o">||</span>
	    <span class="n">lcu</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">NEED_UAC_UPDATE</span> <span class="o">|</span> <span class="n">UPDATE_PENDING</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">private</span><span class="o">-&gt;</span><span class="n">features</span><span class="p">.</span><span class="n">feature</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">)))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * PAV enabled but prefix not, very unlikely</span>
<span class="cm">		 * seems to be a lost pathgroup</span>
<span class="cm">		 * use base device to do IO</span>
<span class="cm">		 */</span>
		<span class="n">DBF_DEV_EVENT</span><span class="p">(</span><span class="n">DBF_ERR</span><span class="p">,</span> <span class="n">base_device</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span>
			      <span class="s">&quot;Prefix not enabled with PAV enabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">alias_device</span> <span class="o">=</span> <span class="n">group</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">alias_device</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">group</span><span class="o">-&gt;</span><span class="n">aliaslist</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">alias_device</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">group</span><span class="o">-&gt;</span><span class="n">aliaslist</span><span class="p">,</span>
							<span class="k">struct</span> <span class="n">dasd_device</span><span class="p">,</span>
							<span class="n">alias_list</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_is_last</span><span class="p">(</span><span class="o">&amp;</span><span class="n">alias_device</span><span class="o">-&gt;</span><span class="n">alias_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">group</span><span class="o">-&gt;</span><span class="n">aliaslist</span><span class="p">))</span>
		<span class="n">group</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">group</span><span class="o">-&gt;</span><span class="n">aliaslist</span><span class="p">,</span>
					       <span class="k">struct</span> <span class="n">dasd_device</span><span class="p">,</span> <span class="n">alias_list</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">group</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">alias_device</span><span class="o">-&gt;</span><span class="n">alias_list</span><span class="p">,</span>
					       <span class="k">struct</span> <span class="n">dasd_device</span><span class="p">,</span> <span class="n">alias_list</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">alias_priv</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dasd_eckd_private</span> <span class="o">*</span><span class="p">)</span> <span class="n">alias_device</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">alias_priv</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">private</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">alias_device</span><span class="o">-&gt;</span><span class="n">stopped</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">alias_device</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Summary unit check handling depends on the way alias devices</span>
<span class="cm"> * are handled so it is done here rather then in dasd_eckd.c</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">reset_summary_unit_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">alias_lcu</span> <span class="o">*</span><span class="n">lcu</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">,</span>
				    <span class="kt">char</span> <span class="n">reason</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dasd_ccw_req</span> <span class="o">*</span><span class="n">cqr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ccw1</span> <span class="o">*</span><span class="n">ccw</span><span class="p">;</span>

	<span class="n">cqr</span> <span class="o">=</span> <span class="n">lcu</span><span class="o">-&gt;</span><span class="n">rsu_cqr</span><span class="p">;</span>
	<span class="n">strncpy</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">magic</span><span class="p">,</span> <span class="s">&quot;ECKD&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
	<span class="n">ASCEBC</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">magic</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
	<span class="n">ccw</span> <span class="o">=</span> <span class="n">cqr</span><span class="o">-&gt;</span><span class="n">cpaddr</span><span class="p">;</span>
	<span class="n">ccw</span><span class="o">-&gt;</span><span class="n">cmd_code</span> <span class="o">=</span> <span class="n">DASD_ECKD_CCW_RSCK</span><span class="p">;</span>
	<span class="n">ccw</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
	<span class="n">ccw</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
	<span class="n">ccw</span><span class="o">-&gt;</span><span class="n">cda</span> <span class="o">=</span> <span class="p">(</span><span class="n">__u32</span><span class="p">)(</span><span class="n">addr_t</span><span class="p">)</span> <span class="n">cqr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">reason</span><span class="p">;</span>

	<span class="n">clear_bit</span><span class="p">(</span><span class="n">DASD_CQR_FLAGS_USE_ERP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">retries</span> <span class="o">=</span> <span class="mi">255</span><span class="p">;</span>	<span class="cm">/* set retry counter to enable basic ERP */</span>
	<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">startdev</span> <span class="o">=</span> <span class="n">device</span><span class="p">;</span>
	<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">memdev</span> <span class="o">=</span> <span class="n">device</span><span class="p">;</span>
	<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">block</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">expires</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">;</span>
	<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">buildclk</span> <span class="o">=</span> <span class="n">get_clock</span><span class="p">();</span>
	<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">DASD_CQR_FILLED</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">dasd_sleep_on_immediatly</span><span class="p">(</span><span class="n">cqr</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">_restart_all_base_devices_on_lcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">alias_lcu</span> <span class="o">*</span><span class="n">lcu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">alias_pav_group</span> <span class="o">*</span><span class="n">pavgroup</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dasd_eckd_private</span> <span class="o">*</span><span class="n">private</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* active and inactive list can contain alias as well as base devices */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">active_devices</span><span class="p">,</span> <span class="n">alias_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">private</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dasd_eckd_private</span> <span class="o">*</span><span class="p">)</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">get_ccwdev_lock</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">private</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">UA_BASE_DEVICE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">get_ccwdev_lock</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">),</span>
					       <span class="n">flags</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">get_ccwdev_lock</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">dasd_schedule_block_bh</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">);</span>
		<span class="n">dasd_schedule_device_bh</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">inactive_devices</span><span class="p">,</span> <span class="n">alias_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">private</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dasd_eckd_private</span> <span class="o">*</span><span class="p">)</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">get_ccwdev_lock</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">private</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">UA_BASE_DEVICE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">get_ccwdev_lock</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">),</span>
					       <span class="n">flags</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">get_ccwdev_lock</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">dasd_schedule_block_bh</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">);</span>
		<span class="n">dasd_schedule_device_bh</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">pavgroup</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">grouplist</span><span class="p">,</span> <span class="n">group</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pavgroup</span><span class="o">-&gt;</span><span class="n">baselist</span><span class="p">,</span> <span class="n">alias_list</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dasd_schedule_block_bh</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">);</span>
			<span class="n">dasd_schedule_device_bh</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">flush_all_alias_devices_on_lcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">alias_lcu</span> <span class="o">*</span><span class="n">lcu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">alias_pav_group</span> <span class="o">*</span><span class="n">pavgroup</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">,</span> <span class="o">*</span><span class="n">temp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dasd_eckd_private</span> <span class="o">*</span><span class="n">private</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">active</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Problem here ist that dasd_flush_device_queue may wait</span>
<span class="cm">	 * for termination of a request to complete. We can&#39;t keep</span>
<span class="cm">	 * the lcu lock during that time, so we must assume that</span>
<span class="cm">	 * the lists may have changed.</span>
<span class="cm">	 * Idea: first gather all active alias devices in a separate list,</span>
<span class="cm">	 * then flush the first element of this list unlocked, and afterwards</span>
<span class="cm">	 * check if it is still on the list before moving it to the</span>
<span class="cm">	 * active_devices list.</span>
<span class="cm">	 */</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">active_devices</span><span class="p">,</span>
				 <span class="n">alias_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">private</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dasd_eckd_private</span> <span class="o">*</span><span class="p">)</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">private</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">UA_BASE_DEVICE</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">alias_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">active</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">pavgroup</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">grouplist</span><span class="p">,</span> <span class="n">group</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pavgroup</span><span class="o">-&gt;</span><span class="n">aliaslist</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">active</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">active</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">device</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">active</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dasd_device</span><span class="p">,</span>
					  <span class="n">alias_list</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">dasd_flush_device_queue</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * only move device around if it wasn&#39;t moved away while we</span>
<span class="cm">		 * were waiting for the flush</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">device</span> <span class="o">==</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">active</span><span class="p">,</span>
					       <span class="k">struct</span> <span class="n">dasd_device</span><span class="p">,</span> <span class="n">alias_list</span><span class="p">))</span>
			<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">alias_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">active_devices</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__stop_device_on_lcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* If pos == device then device is already locked! */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">==</span> <span class="n">device</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dasd_device_set_stop_bits</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">DASD_STOPPED_SU</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="n">get_ccwdev_lock</span><span class="p">(</span><span class="n">pos</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">));</span>
	<span class="n">dasd_device_set_stop_bits</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">DASD_STOPPED_SU</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="n">get_ccwdev_lock</span><span class="p">(</span><span class="n">pos</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This function is called in interrupt context, so the</span>
<span class="cm"> * cdev lock for device is already locked!</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">_stop_all_devices_on_lcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">alias_lcu</span> <span class="o">*</span><span class="n">lcu</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">alias_pav_group</span> <span class="o">*</span><span class="n">pavgroup</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">active_devices</span><span class="p">,</span> <span class="n">alias_list</span><span class="p">)</span>
		<span class="n">__stop_device_on_lcu</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">inactive_devices</span><span class="p">,</span> <span class="n">alias_list</span><span class="p">)</span>
		<span class="n">__stop_device_on_lcu</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">pavgroup</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">grouplist</span><span class="p">,</span> <span class="n">group</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pavgroup</span><span class="o">-&gt;</span><span class="n">baselist</span><span class="p">,</span> <span class="n">alias_list</span><span class="p">)</span>
			<span class="n">__stop_device_on_lcu</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pavgroup</span><span class="o">-&gt;</span><span class="n">aliaslist</span><span class="p">,</span> <span class="n">alias_list</span><span class="p">)</span>
			<span class="n">__stop_device_on_lcu</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">_unstop_all_devices_on_lcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">alias_lcu</span> <span class="o">*</span><span class="n">lcu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">alias_pav_group</span> <span class="o">*</span><span class="n">pavgroup</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">active_devices</span><span class="p">,</span> <span class="n">alias_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">get_ccwdev_lock</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">dasd_device_remove_stop_bits</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">DASD_STOPPED_SU</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">get_ccwdev_lock</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">inactive_devices</span><span class="p">,</span> <span class="n">alias_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">get_ccwdev_lock</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">dasd_device_remove_stop_bits</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">DASD_STOPPED_SU</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">get_ccwdev_lock</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">pavgroup</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">grouplist</span><span class="p">,</span> <span class="n">group</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pavgroup</span><span class="o">-&gt;</span><span class="n">baselist</span><span class="p">,</span> <span class="n">alias_list</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">get_ccwdev_lock</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">dasd_device_remove_stop_bits</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">DASD_STOPPED_SU</span><span class="p">);</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">get_ccwdev_lock</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">),</span>
					       <span class="n">flags</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pavgroup</span><span class="o">-&gt;</span><span class="n">aliaslist</span><span class="p">,</span> <span class="n">alias_list</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">get_ccwdev_lock</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">dasd_device_remove_stop_bits</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">DASD_STOPPED_SU</span><span class="p">);</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">get_ccwdev_lock</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">),</span>
					       <span class="n">flags</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">summary_unit_check_handling_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">alias_lcu</span> <span class="o">*</span><span class="n">lcu</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">summary_unit_check_work_data</span> <span class="o">*</span><span class="n">suc_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">;</span>

	<span class="n">suc_data</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">summary_unit_check_work_data</span><span class="p">,</span>
				<span class="n">worker</span><span class="p">);</span>
	<span class="n">lcu</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">suc_data</span><span class="p">,</span> <span class="k">struct</span> <span class="n">alias_lcu</span><span class="p">,</span> <span class="n">suc_data</span><span class="p">);</span>
	<span class="n">device</span> <span class="o">=</span> <span class="n">suc_data</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">;</span>

	<span class="cm">/* 1. flush alias devices */</span>
	<span class="n">flush_all_alias_devices_on_lcu</span><span class="p">(</span><span class="n">lcu</span><span class="p">);</span>

	<span class="cm">/* 2. reset summary unit check */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">get_ccwdev_lock</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">dasd_device_remove_stop_bits</span><span class="p">(</span><span class="n">device</span><span class="p">,</span>
				     <span class="p">(</span><span class="n">DASD_STOPPED_SU</span> <span class="o">|</span> <span class="n">DASD_STOPPED_PENDING</span><span class="p">));</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">get_ccwdev_lock</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">reset_summary_unit_check</span><span class="p">(</span><span class="n">lcu</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="n">suc_data</span><span class="o">-&gt;</span><span class="n">reason</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">_unstop_all_devices_on_lcu</span><span class="p">(</span><span class="n">lcu</span><span class="p">);</span>
	<span class="n">_restart_all_base_devices_on_lcu</span><span class="p">(</span><span class="n">lcu</span><span class="p">);</span>
	<span class="cm">/* 3. read new alias configuration */</span>
	<span class="n">_schedule_lcu_update</span><span class="p">(</span><span class="n">lcu</span><span class="p">,</span> <span class="n">device</span><span class="p">);</span>
	<span class="n">lcu</span><span class="o">-&gt;</span><span class="n">suc_data</span><span class="p">.</span><span class="n">device</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * note: this will be called from int handler context (cdev locked)</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">dasd_alias_handle_summary_unit_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">irb</span> <span class="o">*</span><span class="n">irb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">alias_lcu</span> <span class="o">*</span><span class="n">lcu</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">reason</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dasd_eckd_private</span> <span class="o">*</span><span class="n">private</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">sense</span><span class="p">;</span>

	<span class="n">private</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dasd_eckd_private</span> <span class="o">*</span><span class="p">)</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>

	<span class="n">sense</span> <span class="o">=</span> <span class="n">dasd_get_sense</span><span class="p">(</span><span class="n">irb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sense</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reason</span> <span class="o">=</span> <span class="n">sense</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
		<span class="n">DBF_DEV_EVENT</span><span class="p">(</span><span class="n">DBF_NOTICE</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="s">&quot;%s %x&quot;</span><span class="p">,</span>
			    <span class="s">&quot;eckd handle summary unit check: reason&quot;</span><span class="p">,</span> <span class="n">reason</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">DBF_DEV_EVENT</span><span class="p">(</span><span class="n">DBF_WARNING</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span>
			    <span class="s">&quot;eckd handle summary unit check:&quot;</span>
			    <span class="s">&quot; no reason code available&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lcu</span> <span class="o">=</span> <span class="n">private</span><span class="o">-&gt;</span><span class="n">lcu</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lcu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DBF_DEV_EVENT</span><span class="p">(</span><span class="n">DBF_WARNING</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span>
			    <span class="s">&quot;device not ready to handle summary&quot;</span>
			    <span class="s">&quot; unit check (no lcu structure)&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">_stop_all_devices_on_lcu</span><span class="p">(</span><span class="n">lcu</span><span class="p">,</span> <span class="n">device</span><span class="p">);</span>
	<span class="cm">/* prepare for lcu_update */</span>
	<span class="n">private</span><span class="o">-&gt;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">NEED_UAC_UPDATE</span> <span class="o">|</span> <span class="n">UPDATE_PENDING</span><span class="p">;</span>
	<span class="cm">/* If this device is about to be removed just return and wait for</span>
<span class="cm">	 * the next interrupt on a different device</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">alias_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">DBF_DEV_EVENT</span><span class="p">(</span><span class="n">DBF_WARNING</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span>
			    <span class="s">&quot;device is in offline processing,&quot;</span>
			    <span class="s">&quot; don&#39;t do summary unit check handling&quot;</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">suc_data</span><span class="p">.</span><span class="n">device</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* already scheduled or running */</span>
		<span class="n">DBF_DEV_EVENT</span><span class="p">(</span><span class="n">DBF_WARNING</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span>
			    <span class="s">&quot;previous instance of summary unit check worker&quot;</span>
			    <span class="s">&quot; still pending&quot;</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="p">;</span>
	<span class="p">}</span>
	<span class="n">lcu</span><span class="o">-&gt;</span><span class="n">suc_data</span><span class="p">.</span><span class="n">reason</span> <span class="o">=</span> <span class="n">reason</span><span class="p">;</span>
	<span class="n">lcu</span><span class="o">-&gt;</span><span class="n">suc_data</span><span class="p">.</span><span class="n">device</span> <span class="o">=</span> <span class="n">device</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lcu</span><span class="o">-&gt;</span><span class="n">suc_data</span><span class="p">.</span><span class="n">worker</span><span class="p">);</span>
<span class="p">};</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
