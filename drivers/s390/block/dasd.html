<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › s390 › block › dasd.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>dasd.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * File...........: linux/drivers/s390/block/dasd.c</span>
<span class="cm"> * Author(s)......: Holger Smolinski &lt;Holger.Smolinski@de.ibm.com&gt;</span>
<span class="cm"> *		    Horst Hummel &lt;Horst.Hummel@de.ibm.com&gt;</span>
<span class="cm"> *		    Carsten Otte &lt;Cotte@de.ibm.com&gt;</span>
<span class="cm"> *		    Martin Schwidefsky &lt;schwidefsky@de.ibm.com&gt;</span>
<span class="cm"> * Bugreports.to..: &lt;Linux390@de.ibm.com&gt;</span>
<span class="cm"> * Copyright IBM Corp. 1999, 2009</span>
<span class="cm"> */</span>

<span class="cp">#define KMSG_COMPONENT &quot;dasd&quot;</span>
<span class="cp">#define pr_fmt(fmt) KMSG_COMPONENT &quot;: &quot; fmt</span>

<span class="cp">#include &lt;linux/kmod.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/ctype.h&gt;</span>
<span class="cp">#include &lt;linux/major.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/hdreg.h&gt;</span>
<span class="cp">#include &lt;linux/async.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/debugfs.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/vmalloc.h&gt;</span>

<span class="cp">#include &lt;asm/ccwdev.h&gt;</span>
<span class="cp">#include &lt;asm/ebcdic.h&gt;</span>
<span class="cp">#include &lt;asm/idals.h&gt;</span>
<span class="cp">#include &lt;asm/itcw.h&gt;</span>
<span class="cp">#include &lt;asm/diag.h&gt;</span>

<span class="cm">/* This is ugly... */</span>
<span class="cp">#define PRINTK_HEADER &quot;dasd:&quot;</span>

<span class="cp">#include &quot;dasd_int.h&quot;</span>
<span class="cm">/*</span>
<span class="cm"> * SECTION: Constant definitions to be used within this file</span>
<span class="cm"> */</span>
<span class="cp">#define DASD_CHANQ_MAX_SIZE 4</span>

<span class="cp">#define DASD_SLEEPON_START_TAG	(void *) 1</span>
<span class="cp">#define DASD_SLEEPON_END_TAG	(void *) 2</span>

<span class="cm">/*</span>
<span class="cm"> * SECTION: exported variables of dasd.c</span>
<span class="cm"> */</span>
<span class="n">debug_info_t</span> <span class="o">*</span><span class="n">dasd_debug_area</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dasd_debugfs_root_entry</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">dasd_discipline</span> <span class="o">*</span><span class="n">dasd_diag_discipline_pointer</span><span class="p">;</span>
<span class="kt">void</span> <span class="n">dasd_int_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">ccw_device</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irb</span> <span class="o">*</span><span class="p">);</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Holger Smolinski &lt;Holger.Smolinski@de.ibm.com&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Linux on S/390 DASD device driver,&quot;</span>
		   <span class="s">&quot; Copyright 2000 IBM Corporation&quot;</span><span class="p">);</span>
<span class="n">MODULE_SUPPORTED_DEVICE</span><span class="p">(</span><span class="s">&quot;dasd&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * SECTION: prototypes for static functions of dasd.c</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>  <span class="n">dasd_alloc_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_block</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">dasd_setup_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_block</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">dasd_free_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_block</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">dasd_flush_request_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_block</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">dasd_flush_block_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_block</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">dasd_device_tasklet</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">dasd_block_tasklet</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_block</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">do_kick_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">do_restore_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">do_reload_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">dasd_return_cqr_cb</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_ccw_req</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">dasd_device_timeout</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">dasd_block_timeout</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__dasd_process_erp</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dasd_ccw_req</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">dasd_profile_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_profile</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">dasd_profile_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_profile</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * SECTION: Operations on the device structure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">wait_queue_head_t</span> <span class="n">dasd_init_waitq</span><span class="p">;</span>
<span class="k">static</span> <span class="n">wait_queue_head_t</span> <span class="n">dasd_flush_wq</span><span class="p">;</span>
<span class="k">static</span> <span class="n">wait_queue_head_t</span> <span class="n">generic_waitq</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate memory for a new device structure.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="nf">dasd_alloc_device</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">;</span>

	<span class="n">device</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_device</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">device</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>

	<span class="cm">/* Get two pages for normal block device operations. */</span>
	<span class="n">device</span><span class="o">-&gt;</span><span class="n">ccw_mem</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">__get_free_pages</span><span class="p">(</span><span class="n">GFP_ATOMIC</span> <span class="o">|</span> <span class="n">GFP_DMA</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">ccw_mem</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* Get one page for error recovery. */</span>
	<span class="n">device</span><span class="o">-&gt;</span><span class="n">erp_mem</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">get_zeroed_page</span><span class="p">(</span><span class="n">GFP_ATOMIC</span> <span class="o">|</span> <span class="n">GFP_DMA</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">erp_mem</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">free_pages</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">ccw_mem</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">dasd_init_chunklist</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">ccw_chunks</span><span class="p">,</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">ccw_mem</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="o">*</span><span class="mi">2</span><span class="p">);</span>
	<span class="n">dasd_init_chunklist</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">erp_chunks</span><span class="p">,</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">erp_mem</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">mem_lock</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">tasklet_scheduled</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">tasklet_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">tasklet</span><span class="p">,</span>
		     <span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">))</span> <span class="n">dasd_device_tasklet</span><span class="p">,</span>
		     <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">device</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">ccw_queue</span><span class="p">);</span>
	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>
	<span class="n">device</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">dasd_device_timeout</span><span class="p">;</span>
	<span class="n">device</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">device</span><span class="p">;</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">kick_work</span><span class="p">,</span> <span class="n">do_kick_device</span><span class="p">);</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">restore_device</span><span class="p">,</span> <span class="n">do_restore_device</span><span class="p">);</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">reload_device</span><span class="p">,</span> <span class="n">do_reload_device</span><span class="p">);</span>
	<span class="n">device</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">DASD_STATE_NEW</span><span class="p">;</span>
	<span class="n">device</span><span class="o">-&gt;</span><span class="n">target</span> <span class="o">=</span> <span class="n">DASD_STATE_NEW</span><span class="p">;</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">state_mutex</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">profile</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">device</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Free memory of a device structure.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">dasd_free_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">);</span>
	<span class="n">free_page</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">erp_mem</span><span class="p">);</span>
	<span class="n">free_pages</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">ccw_mem</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate memory for a new device structure.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">dasd_block</span> <span class="o">*</span><span class="nf">dasd_alloc_block</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dasd_block</span> <span class="o">*</span><span class="n">block</span><span class="p">;</span>

	<span class="n">block</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">block</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">block</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
	<span class="cm">/* open_count = 0 means device online but not in use */</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">open_count</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">request_queue_lock</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">tasklet_scheduled</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">tasklet_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">tasklet</span><span class="p">,</span>
		     <span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">))</span> <span class="n">dasd_block_tasklet</span><span class="p">,</span>
		     <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">block</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">ccw_queue</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>
	<span class="n">block</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">dasd_block_timeout</span><span class="p">;</span>
	<span class="n">block</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">block</span><span class="p">;</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">profile</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">block</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Free memory of a device structure.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">dasd_free_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_block</span> <span class="o">*</span><span class="n">block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">block</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Make a new device known to the system.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dasd_state_new_to_known</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * As long as the device is not in state DASD_STATE_NEW we want to</span>
<span class="cm">	 * keep the reference count &gt; 0.</span>
<span class="cm">	 */</span>
	<span class="n">dasd_get_device</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">dasd_alloc_queue</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dasd_put_device</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">device</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">DASD_STATE_KNOWN</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Let the system forget about a device.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dasd_state_known_to_new</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Disable extended error reporting for this device. */</span>
	<span class="n">dasd_eer_disable</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
	<span class="cm">/* Forget the discipline information. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">discipline</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">discipline</span><span class="o">-&gt;</span><span class="n">uncheck_device</span><span class="p">)</span>
			<span class="n">device</span><span class="o">-&gt;</span><span class="n">discipline</span><span class="o">-&gt;</span><span class="n">uncheck_device</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
		<span class="n">module_put</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">discipline</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">device</span><span class="o">-&gt;</span><span class="n">discipline</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">base_discipline</span><span class="p">)</span>
		<span class="n">module_put</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">base_discipline</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">);</span>
	<span class="n">device</span><span class="o">-&gt;</span><span class="n">base_discipline</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">device</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">DASD_STATE_NEW</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">)</span>
		<span class="n">dasd_free_queue</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">);</span>

	<span class="cm">/* Give up reference we took in dasd_state_new_to_known. */</span>
	<span class="n">dasd_put_device</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">dasd_debugfs_setup</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">base_dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">pde</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">base_dentry</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">pde</span> <span class="o">=</span> <span class="n">debugfs_create_dir</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">base_dentry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pde</span> <span class="o">||</span> <span class="n">IS_ERR</span><span class="p">(</span><span class="n">pde</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">pde</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Request the irq line for the device.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dasd_state_known_to_basic</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dasd_block</span> <span class="o">*</span><span class="n">block</span> <span class="o">=</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* Allocate and register gendisk structure. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">block</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">dasd_gendisk_alloc</span><span class="p">(</span><span class="n">block</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
		<span class="n">block</span><span class="o">-&gt;</span><span class="n">debugfs_dentry</span> <span class="o">=</span>
			<span class="n">dasd_debugfs_setup</span><span class="p">(</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">gdp</span><span class="o">-&gt;</span><span class="n">disk_name</span><span class="p">,</span>
					   <span class="n">dasd_debugfs_root_entry</span><span class="p">);</span>
		<span class="n">dasd_profile_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">profile</span><span class="p">,</span> <span class="n">block</span><span class="o">-&gt;</span><span class="n">debugfs_dentry</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dasd_global_profile_level</span> <span class="o">==</span> <span class="n">DASD_PROFILE_ON</span><span class="p">)</span>
			<span class="n">dasd_profile_on</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">profile</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">device</span><span class="o">-&gt;</span><span class="n">debugfs_dentry</span> <span class="o">=</span>
		<span class="n">dasd_debugfs_setup</span><span class="p">(</span><span class="n">dev_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">),</span>
				   <span class="n">dasd_debugfs_root_entry</span><span class="p">);</span>
	<span class="n">dasd_profile_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">profile</span><span class="p">,</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">debugfs_dentry</span><span class="p">);</span>

	<span class="cm">/* register &#39;device&#39; debug area, used for all DBF_DEV_XXX calls */</span>
	<span class="n">device</span><span class="o">-&gt;</span><span class="n">debug_area</span> <span class="o">=</span> <span class="n">debug_register</span><span class="p">(</span><span class="n">dev_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">),</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
					    <span class="mi">8</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">));</span>
	<span class="n">debug_register_view</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">debug_area</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">debug_sprintf_view</span><span class="p">);</span>
	<span class="n">debug_set_level</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">debug_area</span><span class="p">,</span> <span class="n">DBF_WARNING</span><span class="p">);</span>
	<span class="n">DBF_DEV_EVENT</span><span class="p">(</span><span class="n">DBF_EMERG</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="s">&quot;debug area created&quot;</span><span class="p">);</span>

	<span class="n">device</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">DASD_STATE_BASIC</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Release the irq line for the device. Terminate any running i/o.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dasd_state_basic_to_known</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dasd_profile_exit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">profile</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">debugfs_dentry</span><span class="p">)</span>
			<span class="n">debugfs_remove</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">debugfs_dentry</span><span class="p">);</span>
		<span class="n">dasd_gendisk_free</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">);</span>
		<span class="n">dasd_block_clear_timer</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">dasd_flush_device_queue</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">dasd_device_clear_timer</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
	<span class="n">dasd_profile_exit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">profile</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">debugfs_dentry</span><span class="p">)</span>
		<span class="n">debugfs_remove</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">debugfs_dentry</span><span class="p">);</span>

	<span class="n">DBF_DEV_EVENT</span><span class="p">(</span><span class="n">DBF_EMERG</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="s">&quot;%p debug area deleted&quot;</span><span class="p">,</span> <span class="n">device</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">debug_area</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">debug_unregister</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">debug_area</span><span class="p">);</span>
		<span class="n">device</span><span class="o">-&gt;</span><span class="n">debug_area</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">device</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">DASD_STATE_KNOWN</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Do the initial analysis. The do_analysis function may return</span>
<span class="cm"> * -EAGAIN in which case the device keeps the state DASD_STATE_BASIC</span>
<span class="cm"> * until the discipline decides to continue the startup sequence</span>
<span class="cm"> * by calling the function dasd_change_state. The eckd disciplines</span>
<span class="cm"> * uses this to start a ccw that detects the format. The completion</span>
<span class="cm"> * interrupt for this detection ccw uses the kernel event daemon to</span>
<span class="cm"> * trigger the call to dasd_change_state. All this is done in the</span>
<span class="cm"> * discipline code, see dasd_eckd.c.</span>
<span class="cm"> * After the analysis ccw is done (do_analysis returned 0) the block</span>
<span class="cm"> * device is setup.</span>
<span class="cm"> * In case the analysis returns an error, the device setup is stopped</span>
<span class="cm"> * (a fake disk was already added to allow formatting).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dasd_state_basic_to_ready</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dasd_block</span> <span class="o">*</span><span class="n">block</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">block</span> <span class="o">=</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">;</span>
	<span class="cm">/* make disk known with correct capacity */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">block</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">discipline</span><span class="o">-&gt;</span><span class="n">do_analysis</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">block</span><span class="o">-&gt;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">discipline</span><span class="o">-&gt;</span><span class="n">do_analysis</span><span class="p">(</span><span class="n">block</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span>
				<span class="n">device</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">DASD_STATE_UNFMT</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">dasd_setup_queue</span><span class="p">(</span><span class="n">block</span><span class="p">);</span>
		<span class="n">set_capacity</span><span class="p">(</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">gdp</span><span class="p">,</span>
			     <span class="n">block</span><span class="o">-&gt;</span><span class="n">blocks</span> <span class="o">&lt;&lt;</span> <span class="n">block</span><span class="o">-&gt;</span><span class="n">s2b_shift</span><span class="p">);</span>
		<span class="n">device</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">DASD_STATE_READY</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">dasd_scan_partitions</span><span class="p">(</span><span class="n">block</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="n">device</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">DASD_STATE_BASIC</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">device</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">DASD_STATE_READY</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Remove device from block device layer. Destroy dirty buffers.</span>
<span class="cm"> * Forget format information. Check if the target level is basic</span>
<span class="cm"> * and if it is create fake disk for formatting.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dasd_state_ready_to_basic</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">device</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">DASD_STATE_BASIC</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">dasd_block</span> <span class="o">*</span><span class="n">block</span> <span class="o">=</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">dasd_flush_block_queue</span><span class="p">(</span><span class="n">block</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">device</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">DASD_STATE_READY</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">dasd_flush_request_queue</span><span class="p">(</span><span class="n">block</span><span class="p">);</span>
		<span class="n">dasd_destroy_partitions</span><span class="p">(</span><span class="n">block</span><span class="p">);</span>
		<span class="n">block</span><span class="o">-&gt;</span><span class="n">blocks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">block</span><span class="o">-&gt;</span><span class="n">bp_block</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">block</span><span class="o">-&gt;</span><span class="n">s2b_shift</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Back to basic.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dasd_state_unfmt_to_basic</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">device</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">DASD_STATE_BASIC</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Make the device online and schedule the bottom half to start</span>
<span class="cm"> * the requeueing of requests from the linux request queue to the</span>
<span class="cm"> * ccw queue.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">dasd_state_ready_to_online</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span> <span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">disk_part_iter</span> <span class="n">piter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hd_struct</span> <span class="o">*</span><span class="n">part</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">discipline</span><span class="o">-&gt;</span><span class="n">ready_to_online</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">discipline</span><span class="o">-&gt;</span><span class="n">ready_to_online</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">device</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">DASD_STATE_ONLINE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dasd_schedule_block_bh</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">DASD_FEATURE_USERAW</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">disk</span> <span class="o">=</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">gdp</span><span class="p">;</span>
			<span class="n">kobject_uevent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">disk_to_dev</span><span class="p">(</span><span class="n">disk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="n">KOBJ_CHANGE</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">disk</span> <span class="o">=</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="o">-&gt;</span><span class="n">bd_disk</span><span class="p">;</span>
		<span class="n">disk_part_iter_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">piter</span><span class="p">,</span> <span class="n">disk</span><span class="p">,</span> <span class="n">DISK_PITER_INCL_PART0</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">((</span><span class="n">part</span> <span class="o">=</span> <span class="n">disk_part_iter_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">piter</span><span class="p">)))</span>
			<span class="n">kobject_uevent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">part_to_dev</span><span class="p">(</span><span class="n">part</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="n">KOBJ_CHANGE</span><span class="p">);</span>
		<span class="n">disk_part_iter_exit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">piter</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Stop the requeueing of requests again.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dasd_state_online_to_ready</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">disk_part_iter</span> <span class="n">piter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hd_struct</span> <span class="o">*</span><span class="n">part</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">discipline</span><span class="o">-&gt;</span><span class="n">online_to_ready</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">discipline</span><span class="o">-&gt;</span><span class="n">online_to_ready</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">device</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">DASD_STATE_READY</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">block</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">DASD_FEATURE_USERAW</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">disk</span> <span class="o">=</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="o">-&gt;</span><span class="n">bd_disk</span><span class="p">;</span>
		<span class="n">disk_part_iter_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">piter</span><span class="p">,</span> <span class="n">disk</span><span class="p">,</span> <span class="n">DISK_PITER_INCL_PART0</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">((</span><span class="n">part</span> <span class="o">=</span> <span class="n">disk_part_iter_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">piter</span><span class="p">)))</span>
			<span class="n">kobject_uevent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">part_to_dev</span><span class="p">(</span><span class="n">part</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="n">KOBJ_CHANGE</span><span class="p">);</span>
		<span class="n">disk_part_iter_exit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">piter</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Device startup state changes.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dasd_increase_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">DASD_STATE_NEW</span> <span class="o">&amp;&amp;</span>
	    <span class="n">device</span><span class="o">-&gt;</span><span class="n">target</span> <span class="o">&gt;=</span> <span class="n">DASD_STATE_KNOWN</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">dasd_state_new_to_known</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span> <span class="o">&amp;&amp;</span>
	    <span class="n">device</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">DASD_STATE_KNOWN</span> <span class="o">&amp;&amp;</span>
	    <span class="n">device</span><span class="o">-&gt;</span><span class="n">target</span> <span class="o">&gt;=</span> <span class="n">DASD_STATE_BASIC</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">dasd_state_known_to_basic</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span> <span class="o">&amp;&amp;</span>
	    <span class="n">device</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">DASD_STATE_BASIC</span> <span class="o">&amp;&amp;</span>
	    <span class="n">device</span><span class="o">-&gt;</span><span class="n">target</span> <span class="o">&gt;=</span> <span class="n">DASD_STATE_READY</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">dasd_state_basic_to_ready</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span> <span class="o">&amp;&amp;</span>
	    <span class="n">device</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">DASD_STATE_UNFMT</span> <span class="o">&amp;&amp;</span>
	    <span class="n">device</span><span class="o">-&gt;</span><span class="n">target</span> <span class="o">&gt;</span> <span class="n">DASD_STATE_UNFMT</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span> <span class="o">&amp;&amp;</span>
	    <span class="n">device</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">DASD_STATE_READY</span> <span class="o">&amp;&amp;</span>
	    <span class="n">device</span><span class="o">-&gt;</span><span class="n">target</span> <span class="o">&gt;=</span> <span class="n">DASD_STATE_ONLINE</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">dasd_state_ready_to_online</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Device shutdown state changes.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dasd_decrease_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">DASD_STATE_ONLINE</span> <span class="o">&amp;&amp;</span>
	    <span class="n">device</span><span class="o">-&gt;</span><span class="n">target</span> <span class="o">&lt;=</span> <span class="n">DASD_STATE_READY</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">dasd_state_online_to_ready</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span> <span class="o">&amp;&amp;</span>
	    <span class="n">device</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">DASD_STATE_READY</span> <span class="o">&amp;&amp;</span>
	    <span class="n">device</span><span class="o">-&gt;</span><span class="n">target</span> <span class="o">&lt;=</span> <span class="n">DASD_STATE_BASIC</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">dasd_state_ready_to_basic</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span> <span class="o">&amp;&amp;</span>
	    <span class="n">device</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">DASD_STATE_UNFMT</span> <span class="o">&amp;&amp;</span>
	    <span class="n">device</span><span class="o">-&gt;</span><span class="n">target</span> <span class="o">&lt;=</span> <span class="n">DASD_STATE_BASIC</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">dasd_state_unfmt_to_basic</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span> <span class="o">&amp;&amp;</span>
	    <span class="n">device</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">DASD_STATE_BASIC</span> <span class="o">&amp;&amp;</span>
	    <span class="n">device</span><span class="o">-&gt;</span><span class="n">target</span> <span class="o">&lt;=</span> <span class="n">DASD_STATE_KNOWN</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">dasd_state_basic_to_known</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span> <span class="o">&amp;&amp;</span>
	    <span class="n">device</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">DASD_STATE_KNOWN</span> <span class="o">&amp;&amp;</span>
	    <span class="n">device</span><span class="o">-&gt;</span><span class="n">target</span> <span class="o">&lt;=</span> <span class="n">DASD_STATE_NEW</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">dasd_state_known_to_new</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is the main startup/shutdown routine.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">dasd_change_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">)</span>
		<span class="cm">/* Already where we want to go today... */</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&lt;</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">dasd_increase_state</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">dasd_decrease_state</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="n">device</span><span class="o">-&gt;</span><span class="n">target</span> <span class="o">=</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">)</span>
		<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dasd_init_waitq</span><span class="p">);</span>

	<span class="cm">/* let user-space know that the device status changed */</span>
	<span class="n">kobject_uevent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">kobj</span><span class="p">,</span> <span class="n">KOBJ_CHANGE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Kick starter for devices that did not complete the startup/shutdown</span>
<span class="cm"> * procedure or were sleeping because of a pending state.</span>
<span class="cm"> * dasd_kick_device will schedule a call do do_kick_device to the kernel</span>
<span class="cm"> * event daemon.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">do_kick_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dasd_device</span><span class="p">,</span> <span class="n">kick_work</span><span class="p">);</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">state_mutex</span><span class="p">);</span>
	<span class="n">dasd_change_state</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">state_mutex</span><span class="p">);</span>
	<span class="n">dasd_schedule_device_bh</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
	<span class="n">dasd_put_device</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">dasd_kick_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dasd_get_device</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
	<span class="cm">/* queue call to dasd_kick_device to the kernel event daemon. */</span>
	<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">kick_work</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * dasd_reload_device will schedule a call do do_reload_device to the kernel</span>
<span class="cm"> * event daemon.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">do_reload_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dasd_device</span><span class="p">,</span>
						  <span class="n">reload_device</span><span class="p">);</span>
	<span class="n">device</span><span class="o">-&gt;</span><span class="n">discipline</span><span class="o">-&gt;</span><span class="n">reload</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
	<span class="n">dasd_put_device</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">dasd_reload_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dasd_get_device</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
	<span class="cm">/* queue call to dasd_reload_device to the kernel event daemon. */</span>
	<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">reload_device</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dasd_reload_device</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * dasd_restore_device will schedule a call do do_restore_device to the kernel</span>
<span class="cm"> * event daemon.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">do_restore_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dasd_device</span><span class="p">,</span>
						  <span class="n">restore_device</span><span class="p">);</span>
	<span class="n">device</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="o">-&gt;</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">restore</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">);</span>
	<span class="n">dasd_put_device</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">dasd_restore_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dasd_get_device</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
	<span class="cm">/* queue call to dasd_restore_device to the kernel event daemon. */</span>
	<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">restore_device</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Set the target state for a device and starts the state change.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">dasd_set_target_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dasd_get_device</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">state_mutex</span><span class="p">);</span>
	<span class="cm">/* If we are in probeonly mode stop at DASD_STATE_READY. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dasd_probeonly</span> <span class="o">&amp;&amp;</span> <span class="n">target</span> <span class="o">&gt;</span> <span class="n">DASD_STATE_READY</span><span class="p">)</span>
		<span class="n">target</span> <span class="o">=</span> <span class="n">DASD_STATE_READY</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">target</span> <span class="o">!=</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">target</span><span class="p">)</span>
			<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dasd_init_waitq</span><span class="p">);</span>
		<span class="n">device</span><span class="o">-&gt;</span><span class="n">target</span> <span class="o">=</span> <span class="n">target</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">)</span>
		<span class="n">dasd_change_state</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">state_mutex</span><span class="p">);</span>
	<span class="n">dasd_put_device</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Enable devices with device numbers in [from..to].</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">_wait_for_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">dasd_enable_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dasd_set_target_state</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">DASD_STATE_ONLINE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&lt;=</span> <span class="n">DASD_STATE_KNOWN</span><span class="p">)</span>
		<span class="cm">/* No discipline for device found. */</span>
		<span class="n">dasd_set_target_state</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">DASD_STATE_NEW</span><span class="p">);</span>
	<span class="cm">/* Now wait for the devices to come up. */</span>
	<span class="n">wait_event</span><span class="p">(</span><span class="n">dasd_init_waitq</span><span class="p">,</span> <span class="n">_wait_for_device</span><span class="p">(</span><span class="n">device</span><span class="p">));</span>

	<span class="n">dasd_reload_device</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">discipline</span><span class="o">-&gt;</span><span class="n">kick_validate</span><span class="p">)</span>
		<span class="n">device</span><span class="o">-&gt;</span><span class="n">discipline</span><span class="o">-&gt;</span><span class="n">kick_validate</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * SECTION: device operation (interrupt handler, start i/o, term i/o ...)</span>
<span class="cm"> */</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dasd_global_profile_level</span> <span class="o">=</span> <span class="n">DASD_PROFILE_OFF</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_DASD_PROFILE</span>
<span class="k">struct</span> <span class="n">dasd_profile_info</span> <span class="n">dasd_global_profile_data</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dasd_global_profile_dentry</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dasd_debugfs_global_entry</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Add profiling information for cqr before execution.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">dasd_profile_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_block</span> <span class="o">*</span><span class="n">block</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">dasd_ccw_req</span> <span class="o">*</span><span class="n">cqr</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">l</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">counter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">;</span>

	<span class="cm">/* count the length of the chanq for statistics */</span>
	<span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dasd_global_profile_level</span> <span class="o">||</span> <span class="n">block</span><span class="o">-&gt;</span><span class="n">profile</span><span class="p">.</span><span class="n">data</span><span class="p">)</span>
		<span class="n">list_for_each</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">ccw_queue</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">counter</span> <span class="o">&gt;=</span> <span class="mi">31</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dasd_global_profile_level</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dasd_global_profile_data</span><span class="p">.</span><span class="n">dasd_io_nr_req</span><span class="p">[</span><span class="n">counter</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rq_data_dir</span><span class="p">(</span><span class="n">req</span><span class="p">)</span> <span class="o">==</span> <span class="n">READ</span><span class="p">)</span>
			<span class="n">dasd_global_profile_data</span><span class="p">.</span><span class="n">dasd_read_nr_req</span><span class="p">[</span><span class="n">counter</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">profile</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">profile</span><span class="p">.</span><span class="n">data</span><span class="p">)</span>
		<span class="n">block</span><span class="o">-&gt;</span><span class="n">profile</span><span class="p">.</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">dasd_io_nr_req</span><span class="p">[</span><span class="n">counter</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rq_data_dir</span><span class="p">(</span><span class="n">req</span><span class="p">)</span> <span class="o">==</span> <span class="n">READ</span><span class="p">)</span>
			<span class="n">block</span><span class="o">-&gt;</span><span class="n">profile</span><span class="p">.</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">dasd_read_nr_req</span><span class="p">[</span><span class="n">counter</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">profile</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We count the request for the start device, even though it may run on</span>
<span class="cm">	 * some other device due to error recovery. This way we make sure that</span>
<span class="cm">	 * we count each request only once.</span>
<span class="cm">	 */</span>
	<span class="n">device</span> <span class="o">=</span> <span class="n">cqr</span><span class="o">-&gt;</span><span class="n">startdev</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">profile</span><span class="p">.</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">counter</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* request is not yet queued on the start device */</span>
		<span class="n">list_for_each</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">ccw_queue</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">counter</span> <span class="o">&gt;=</span> <span class="mi">31</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">profile</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">profile</span><span class="p">.</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">device</span><span class="o">-&gt;</span><span class="n">profile</span><span class="p">.</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">dasd_io_nr_req</span><span class="p">[</span><span class="n">counter</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rq_data_dir</span><span class="p">(</span><span class="n">req</span><span class="p">)</span> <span class="o">==</span> <span class="n">READ</span><span class="p">)</span>
			<span class="n">device</span><span class="o">-&gt;</span><span class="n">profile</span><span class="p">.</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">dasd_read_nr_req</span><span class="p">[</span><span class="n">counter</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">profile</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Add profiling information for cqr after execution.</span>
<span class="cm"> */</span>

<span class="cp">#define dasd_profile_counter(value, index)			   \</span>
<span class="cp">{								   \</span>
<span class="cp">	for (index = 0; index &lt; 31 &amp;&amp; value &gt;&gt; (2+index); index++) \</span>
<span class="cp">		;						   \</span>
<span class="cp">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dasd_profile_end_add_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_profile_info</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
				      <span class="kt">int</span> <span class="n">is_alias</span><span class="p">,</span>
				      <span class="kt">int</span> <span class="n">is_tpm</span><span class="p">,</span>
				      <span class="kt">int</span> <span class="n">is_read</span><span class="p">,</span>
				      <span class="kt">long</span> <span class="n">sectors</span><span class="p">,</span>
				      <span class="kt">int</span> <span class="n">sectors_ind</span><span class="p">,</span>
				      <span class="kt">int</span> <span class="n">tottime_ind</span><span class="p">,</span>
				      <span class="kt">int</span> <span class="n">tottimeps_ind</span><span class="p">,</span>
				      <span class="kt">int</span> <span class="n">strtime_ind</span><span class="p">,</span>
				      <span class="kt">int</span> <span class="n">irqtime_ind</span><span class="p">,</span>
				      <span class="kt">int</span> <span class="n">irqtimeps_ind</span><span class="p">,</span>
				      <span class="kt">int</span> <span class="n">endtime_ind</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* in case of an overflow, reset the whole profile */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">dasd_io_reqs</span> <span class="o">==</span> <span class="n">UINT_MAX</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">memset</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">data</span><span class="p">));</span>
			<span class="n">getnstimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">starttod</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">data</span><span class="o">-&gt;</span><span class="n">dasd_io_reqs</span><span class="o">++</span><span class="p">;</span>
	<span class="n">data</span><span class="o">-&gt;</span><span class="n">dasd_io_sects</span> <span class="o">+=</span> <span class="n">sectors</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_alias</span><span class="p">)</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">dasd_io_alias</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_tpm</span><span class="p">)</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">dasd_io_tpm</span><span class="o">++</span><span class="p">;</span>

	<span class="n">data</span><span class="o">-&gt;</span><span class="n">dasd_io_secs</span><span class="p">[</span><span class="n">sectors_ind</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
	<span class="n">data</span><span class="o">-&gt;</span><span class="n">dasd_io_times</span><span class="p">[</span><span class="n">tottime_ind</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
	<span class="n">data</span><span class="o">-&gt;</span><span class="n">dasd_io_timps</span><span class="p">[</span><span class="n">tottimeps_ind</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
	<span class="n">data</span><span class="o">-&gt;</span><span class="n">dasd_io_time1</span><span class="p">[</span><span class="n">strtime_ind</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
	<span class="n">data</span><span class="o">-&gt;</span><span class="n">dasd_io_time2</span><span class="p">[</span><span class="n">irqtime_ind</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
	<span class="n">data</span><span class="o">-&gt;</span><span class="n">dasd_io_time2ps</span><span class="p">[</span><span class="n">irqtimeps_ind</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
	<span class="n">data</span><span class="o">-&gt;</span><span class="n">dasd_io_time3</span><span class="p">[</span><span class="n">endtime_ind</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_read</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">dasd_read_reqs</span><span class="o">++</span><span class="p">;</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">dasd_read_sects</span> <span class="o">+=</span> <span class="n">sectors</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_alias</span><span class="p">)</span>
			<span class="n">data</span><span class="o">-&gt;</span><span class="n">dasd_read_alias</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_tpm</span><span class="p">)</span>
			<span class="n">data</span><span class="o">-&gt;</span><span class="n">dasd_read_tpm</span><span class="o">++</span><span class="p">;</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">dasd_read_secs</span><span class="p">[</span><span class="n">sectors_ind</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">dasd_read_times</span><span class="p">[</span><span class="n">tottime_ind</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">dasd_read_time1</span><span class="p">[</span><span class="n">strtime_ind</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">dasd_read_time2</span><span class="p">[</span><span class="n">irqtime_ind</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">dasd_read_time3</span><span class="p">[</span><span class="n">endtime_ind</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dasd_profile_end</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_block</span> <span class="o">*</span><span class="n">block</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">dasd_ccw_req</span> <span class="o">*</span><span class="n">cqr</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">strtime</span><span class="p">,</span> <span class="n">irqtime</span><span class="p">,</span> <span class="n">endtime</span><span class="p">,</span> <span class="n">tottime</span><span class="p">;</span>	<span class="cm">/* in microseconds */</span>
	<span class="kt">long</span> <span class="n">tottimeps</span><span class="p">,</span> <span class="n">sectors</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sectors_ind</span><span class="p">,</span> <span class="n">tottime_ind</span><span class="p">,</span> <span class="n">tottimeps_ind</span><span class="p">,</span> <span class="n">strtime_ind</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">irqtime_ind</span><span class="p">,</span> <span class="n">irqtimeps_ind</span><span class="p">,</span> <span class="n">endtime_ind</span><span class="p">;</span>

	<span class="n">device</span> <span class="o">=</span> <span class="n">cqr</span><span class="o">-&gt;</span><span class="n">startdev</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">dasd_global_profile_level</span> <span class="o">||</span>
	      <span class="n">block</span><span class="o">-&gt;</span><span class="n">profile</span><span class="p">.</span><span class="n">data</span> <span class="o">||</span>
	      <span class="n">device</span><span class="o">-&gt;</span><span class="n">profile</span><span class="p">.</span><span class="n">data</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">sectors</span> <span class="o">=</span> <span class="n">blk_rq_sectors</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">buildclk</span> <span class="o">||</span> <span class="o">!</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">startclk</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">stopclk</span> <span class="o">||</span> <span class="o">!</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">endclk</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">sectors</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">strtime</span> <span class="o">=</span> <span class="p">((</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">startclk</span> <span class="o">-</span> <span class="n">cqr</span><span class="o">-&gt;</span><span class="n">buildclk</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">);</span>
	<span class="n">irqtime</span> <span class="o">=</span> <span class="p">((</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">stopclk</span> <span class="o">-</span> <span class="n">cqr</span><span class="o">-&gt;</span><span class="n">startclk</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">);</span>
	<span class="n">endtime</span> <span class="o">=</span> <span class="p">((</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">endclk</span> <span class="o">-</span> <span class="n">cqr</span><span class="o">-&gt;</span><span class="n">stopclk</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">);</span>
	<span class="n">tottime</span> <span class="o">=</span> <span class="p">((</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">endclk</span> <span class="o">-</span> <span class="n">cqr</span><span class="o">-&gt;</span><span class="n">buildclk</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">);</span>
	<span class="n">tottimeps</span> <span class="o">=</span> <span class="n">tottime</span> <span class="o">/</span> <span class="n">sectors</span><span class="p">;</span>

	<span class="n">dasd_profile_counter</span><span class="p">(</span><span class="n">sectors</span><span class="p">,</span> <span class="n">sectors_ind</span><span class="p">);</span>
	<span class="n">dasd_profile_counter</span><span class="p">(</span><span class="n">tottime</span><span class="p">,</span> <span class="n">tottime_ind</span><span class="p">);</span>
	<span class="n">dasd_profile_counter</span><span class="p">(</span><span class="n">tottimeps</span><span class="p">,</span> <span class="n">tottimeps_ind</span><span class="p">);</span>
	<span class="n">dasd_profile_counter</span><span class="p">(</span><span class="n">strtime</span><span class="p">,</span> <span class="n">strtime_ind</span><span class="p">);</span>
	<span class="n">dasd_profile_counter</span><span class="p">(</span><span class="n">irqtime</span><span class="p">,</span> <span class="n">irqtime_ind</span><span class="p">);</span>
	<span class="n">dasd_profile_counter</span><span class="p">(</span><span class="n">irqtime</span> <span class="o">/</span> <span class="n">sectors</span><span class="p">,</span> <span class="n">irqtimeps_ind</span><span class="p">);</span>
	<span class="n">dasd_profile_counter</span><span class="p">(</span><span class="n">endtime</span><span class="p">,</span> <span class="n">endtime_ind</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dasd_global_profile_level</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dasd_profile_end_add_data</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dasd_global_profile_data</span><span class="p">,</span>
					  <span class="n">cqr</span><span class="o">-&gt;</span><span class="n">startdev</span> <span class="o">!=</span> <span class="n">block</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span>
					  <span class="n">cqr</span><span class="o">-&gt;</span><span class="n">cpmode</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span>
					  <span class="n">rq_data_dir</span><span class="p">(</span><span class="n">req</span><span class="p">)</span> <span class="o">==</span> <span class="n">READ</span><span class="p">,</span>
					  <span class="n">sectors</span><span class="p">,</span> <span class="n">sectors_ind</span><span class="p">,</span> <span class="n">tottime_ind</span><span class="p">,</span>
					  <span class="n">tottimeps_ind</span><span class="p">,</span> <span class="n">strtime_ind</span><span class="p">,</span>
					  <span class="n">irqtime_ind</span><span class="p">,</span> <span class="n">irqtimeps_ind</span><span class="p">,</span>
					  <span class="n">endtime_ind</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">profile</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">profile</span><span class="p">.</span><span class="n">data</span><span class="p">)</span>
		<span class="n">dasd_profile_end_add_data</span><span class="p">(</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">profile</span><span class="p">.</span><span class="n">data</span><span class="p">,</span>
					  <span class="n">cqr</span><span class="o">-&gt;</span><span class="n">startdev</span> <span class="o">!=</span> <span class="n">block</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span>
					  <span class="n">cqr</span><span class="o">-&gt;</span><span class="n">cpmode</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span>
					  <span class="n">rq_data_dir</span><span class="p">(</span><span class="n">req</span><span class="p">)</span> <span class="o">==</span> <span class="n">READ</span><span class="p">,</span>
					  <span class="n">sectors</span><span class="p">,</span> <span class="n">sectors_ind</span><span class="p">,</span> <span class="n">tottime_ind</span><span class="p">,</span>
					  <span class="n">tottimeps_ind</span><span class="p">,</span> <span class="n">strtime_ind</span><span class="p">,</span>
					  <span class="n">irqtime_ind</span><span class="p">,</span> <span class="n">irqtimeps_ind</span><span class="p">,</span>
					  <span class="n">endtime_ind</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">profile</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">profile</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">profile</span><span class="p">.</span><span class="n">data</span><span class="p">)</span>
		<span class="n">dasd_profile_end_add_data</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">profile</span><span class="p">.</span><span class="n">data</span><span class="p">,</span>
					  <span class="n">cqr</span><span class="o">-&gt;</span><span class="n">startdev</span> <span class="o">!=</span> <span class="n">block</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span>
					  <span class="n">cqr</span><span class="o">-&gt;</span><span class="n">cpmode</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span>
					  <span class="n">rq_data_dir</span><span class="p">(</span><span class="n">req</span><span class="p">)</span> <span class="o">==</span> <span class="n">READ</span><span class="p">,</span>
					  <span class="n">sectors</span><span class="p">,</span> <span class="n">sectors_ind</span><span class="p">,</span> <span class="n">tottime_ind</span><span class="p">,</span>
					  <span class="n">tottimeps_ind</span><span class="p">,</span> <span class="n">strtime_ind</span><span class="p">,</span>
					  <span class="n">irqtime_ind</span><span class="p">,</span> <span class="n">irqtimeps_ind</span><span class="p">,</span>
					  <span class="n">endtime_ind</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">profile</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">dasd_profile_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_profile</span> <span class="o">*</span><span class="n">profile</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dasd_profile_info</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">profile</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">data</span> <span class="o">=</span> <span class="n">profile</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">profile</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">data</span><span class="p">));</span>
	<span class="n">getnstimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">starttod</span><span class="p">);</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">profile</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">dasd_global_profile_reset</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dasd_global_profile_data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">dasd_global_profile_data</span><span class="p">));</span>
	<span class="n">getnstimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dasd_global_profile_data</span><span class="p">.</span><span class="n">starttod</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">dasd_profile_on</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_profile</span> <span class="o">*</span><span class="n">profile</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dasd_profile_info</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>

	<span class="n">data</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">data</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">data</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">profile</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">profile</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">profile</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">getnstimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">starttod</span><span class="p">);</span>
	<span class="n">profile</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">profile</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">dasd_profile_off</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_profile</span> <span class="o">*</span><span class="n">profile</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">profile</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">profile</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
	<span class="n">profile</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">profile</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">char</span> <span class="o">*</span><span class="nf">dasd_get_user_string</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">user_buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">user_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">;</span>

	<span class="n">buffer</span> <span class="o">=</span> <span class="n">vmalloc</span><span class="p">(</span><span class="n">user_len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buffer</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">user_buf</span><span class="p">,</span> <span class="n">user_len</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vfree</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EFAULT</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* got the string, now strip linefeed. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buffer</span><span class="p">[</span><span class="n">user_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\n&#39;</span><span class="p">)</span>
		<span class="n">buffer</span><span class="p">[</span><span class="n">user_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">buffer</span><span class="p">[</span><span class="n">user_len</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">buffer</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">dasd_stats_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">user_buf</span><span class="p">,</span>
				<span class="kt">size_t</span> <span class="n">user_len</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="o">*</span><span class="n">str</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="p">)</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dasd_profile</span> <span class="o">*</span><span class="n">prof</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">user_len</span> <span class="o">&gt;</span> <span class="mi">65536</span><span class="p">)</span>
		<span class="n">user_len</span> <span class="o">=</span> <span class="mi">65536</span><span class="p">;</span>
	<span class="n">buffer</span> <span class="o">=</span> <span class="n">dasd_get_user_string</span><span class="p">(</span><span class="n">user_buf</span><span class="p">,</span> <span class="n">user_len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">buffer</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>

	<span class="n">str</span> <span class="o">=</span> <span class="n">skip_spaces</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">user_len</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;reset&quot;</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dasd_profile_reset</span><span class="p">(</span><span class="n">prof</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;on&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">dasd_profile_on</span><span class="p">(</span><span class="n">prof</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span><span class="p">)</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">user_len</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;off&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dasd_profile_off</span><span class="p">(</span><span class="n">prof</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">vfree</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dasd_stats_array</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">array</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;%u &quot;</span><span class="p">,</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="n">seq_putc</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="sc">&#39;\n&#39;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dasd_stats_seq_print</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">dasd_profile_info</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;start_time %ld.%09ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">data</span><span class="o">-&gt;</span><span class="n">starttod</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">starttod</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;total_requests %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">dasd_io_reqs</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;total_sectors %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">dasd_io_sects</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;total_pav %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">dasd_io_alias</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;total_hpf %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">dasd_io_tpm</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;histogram_sectors &quot;</span><span class="p">);</span>
	<span class="n">dasd_stats_array</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">dasd_io_secs</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;histogram_io_times &quot;</span><span class="p">);</span>
	<span class="n">dasd_stats_array</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">dasd_io_times</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;histogram_io_times_weighted &quot;</span><span class="p">);</span>
	<span class="n">dasd_stats_array</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">dasd_io_timps</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;histogram_time_build_to_ssch &quot;</span><span class="p">);</span>
	<span class="n">dasd_stats_array</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">dasd_io_time1</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;histogram_time_ssch_to_irq &quot;</span><span class="p">);</span>
	<span class="n">dasd_stats_array</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">dasd_io_time2</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;histogram_time_ssch_to_irq_weighted &quot;</span><span class="p">);</span>
	<span class="n">dasd_stats_array</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">dasd_io_time2ps</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;histogram_time_irq_to_end &quot;</span><span class="p">);</span>
	<span class="n">dasd_stats_array</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">dasd_io_time3</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;histogram_ccw_queue_length &quot;</span><span class="p">);</span>
	<span class="n">dasd_stats_array</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">dasd_io_nr_req</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;total_read_requests %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">dasd_read_reqs</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;total_read_sectors %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">dasd_read_sects</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;total_read_pav %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">dasd_read_alias</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;total_read_hpf %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">dasd_read_tpm</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;histogram_read_sectors &quot;</span><span class="p">);</span>
	<span class="n">dasd_stats_array</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">dasd_read_secs</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;histogram_read_times &quot;</span><span class="p">);</span>
	<span class="n">dasd_stats_array</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">dasd_read_times</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;histogram_read_time_build_to_ssch &quot;</span><span class="p">);</span>
	<span class="n">dasd_stats_array</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">dasd_read_time1</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;histogram_read_time_ssch_to_irq &quot;</span><span class="p">);</span>
	<span class="n">dasd_stats_array</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">dasd_read_time2</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;histogram_read_time_irq_to_end &quot;</span><span class="p">);</span>
	<span class="n">dasd_stats_array</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">dasd_read_time3</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;histogram_read_ccw_queue_length &quot;</span><span class="p">);</span>
	<span class="n">dasd_stats_array</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">dasd_read_nr_req</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dasd_stats_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dasd_profile</span> <span class="o">*</span><span class="n">profile</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dasd_profile_info</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>

	<span class="n">profile</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">profile</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">data</span> <span class="o">=</span> <span class="n">profile</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">profile</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;disabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dasd_stats_seq_print</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">profile</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dasd_stats_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dasd_profile</span> <span class="o">*</span><span class="n">profile</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_private</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">single_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">dasd_stats_show</span><span class="p">,</span> <span class="n">profile</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">dasd_stats_raw_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">dasd_stats_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">single_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">dasd_stats_write</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">dasd_stats_global_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
				       <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">user_buf</span><span class="p">,</span>
				       <span class="kt">size_t</span> <span class="n">user_len</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="o">*</span><span class="n">str</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">user_len</span> <span class="o">&gt;</span> <span class="mi">65536</span><span class="p">)</span>
		<span class="n">user_len</span> <span class="o">=</span> <span class="mi">65536</span><span class="p">;</span>
	<span class="n">buffer</span> <span class="o">=</span> <span class="n">dasd_get_user_string</span><span class="p">(</span><span class="n">user_buf</span><span class="p">,</span> <span class="n">user_len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">buffer</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
	<span class="n">str</span> <span class="o">=</span> <span class="n">skip_spaces</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">user_len</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;reset&quot;</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dasd_global_profile_reset</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;on&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dasd_global_profile_reset</span><span class="p">();</span>
		<span class="n">dasd_global_profile_level</span> <span class="o">=</span> <span class="n">DASD_PROFILE_GLOBAL_ONLY</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;off&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dasd_global_profile_level</span> <span class="o">=</span> <span class="n">DASD_PROFILE_OFF</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">vfree</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dasd_stats_global_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dasd_global_profile_level</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;disabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dasd_stats_seq_print</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dasd_global_profile_data</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dasd_stats_global_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">single_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">dasd_stats_global_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">dasd_stats_global_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">dasd_stats_global_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">single_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">dasd_stats_global_write</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dasd_profile_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_profile</span> <span class="o">*</span><span class="n">profile</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">base_dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">umode_t</span> <span class="n">mode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">pde</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">base_dentry</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">profile</span><span class="o">-&gt;</span><span class="n">dentry</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">profile</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">mode</span> <span class="o">=</span> <span class="p">(</span><span class="n">S_IRUSR</span> <span class="o">|</span> <span class="n">S_IWUSR</span> <span class="o">|</span> <span class="n">S_IFREG</span><span class="p">);</span>
	<span class="n">pde</span> <span class="o">=</span> <span class="n">debugfs_create_file</span><span class="p">(</span><span class="s">&quot;statistics&quot;</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">base_dentry</span><span class="p">,</span>
				  <span class="n">profile</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dasd_stats_raw_fops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pde</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">pde</span><span class="p">))</span>
		<span class="n">profile</span><span class="o">-&gt;</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">pde</span><span class="p">;</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dasd_profile_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_profile</span> <span class="o">*</span><span class="n">profile</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dasd_profile_off</span><span class="p">(</span><span class="n">profile</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">profile</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">debugfs_remove</span><span class="p">(</span><span class="n">profile</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">);</span>
		<span class="n">profile</span><span class="o">-&gt;</span><span class="n">dentry</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dasd_statistics_removeroot</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dasd_global_profile_level</span> <span class="o">=</span> <span class="n">DASD_PROFILE_OFF</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dasd_global_profile_dentry</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">debugfs_remove</span><span class="p">(</span><span class="n">dasd_global_profile_dentry</span><span class="p">);</span>
		<span class="n">dasd_global_profile_dentry</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dasd_debugfs_global_entry</span><span class="p">)</span>
		<span class="n">debugfs_remove</span><span class="p">(</span><span class="n">dasd_debugfs_global_entry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dasd_debugfs_root_entry</span><span class="p">)</span>
		<span class="n">debugfs_remove</span><span class="p">(</span><span class="n">dasd_debugfs_root_entry</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dasd_statistics_createroot</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">umode_t</span> <span class="n">mode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">pde</span><span class="p">;</span>

	<span class="n">dasd_debugfs_root_entry</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">dasd_debugfs_global_entry</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">dasd_global_profile_dentry</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">pde</span> <span class="o">=</span> <span class="n">debugfs_create_dir</span><span class="p">(</span><span class="s">&quot;dasd&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pde</span> <span class="o">||</span> <span class="n">IS_ERR</span><span class="p">(</span><span class="n">pde</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="n">dasd_debugfs_root_entry</span> <span class="o">=</span> <span class="n">pde</span><span class="p">;</span>
	<span class="n">pde</span> <span class="o">=</span> <span class="n">debugfs_create_dir</span><span class="p">(</span><span class="s">&quot;global&quot;</span><span class="p">,</span> <span class="n">dasd_debugfs_root_entry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pde</span> <span class="o">||</span> <span class="n">IS_ERR</span><span class="p">(</span><span class="n">pde</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="n">dasd_debugfs_global_entry</span> <span class="o">=</span> <span class="n">pde</span><span class="p">;</span>

	<span class="n">mode</span> <span class="o">=</span> <span class="p">(</span><span class="n">S_IRUSR</span> <span class="o">|</span> <span class="n">S_IWUSR</span> <span class="o">|</span> <span class="n">S_IFREG</span><span class="p">);</span>
	<span class="n">pde</span> <span class="o">=</span> <span class="n">debugfs_create_file</span><span class="p">(</span><span class="s">&quot;statistics&quot;</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">dasd_debugfs_global_entry</span><span class="p">,</span>
				  <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dasd_stats_global_fops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pde</span> <span class="o">||</span> <span class="n">IS_ERR</span><span class="p">(</span><span class="n">pde</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="n">dasd_global_profile_dentry</span> <span class="o">=</span> <span class="n">pde</span><span class="p">;</span>
	<span class="k">return</span><span class="p">;</span>

<span class="nl">error:</span>
	<span class="n">DBF_EVENT</span><span class="p">(</span><span class="n">DBF_ERR</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span>
		  <span class="s">&quot;Creation of the dasd debugfs interface failed&quot;</span><span class="p">);</span>
	<span class="n">dasd_statistics_removeroot</span><span class="p">();</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#else</span>
<span class="cp">#define dasd_profile_start(block, cqr, req) do {} while (0)</span>
<span class="cp">#define dasd_profile_end(block, cqr, req) do {} while (0)</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dasd_statistics_createroot</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dasd_statistics_removeroot</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">dasd_stats_generic_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;Statistics are not activated in this kernel</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dasd_profile_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_profile</span> <span class="o">*</span><span class="n">profile</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">base_dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dasd_profile_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_profile</span> <span class="o">*</span><span class="n">profile</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">dasd_profile_on</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_profile</span> <span class="o">*</span><span class="n">profile</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif				</span><span class="cm">/* CONFIG_DASD_PROFILE */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Allocate memory for a channel program with &#39;cplength&#39; channel</span>
<span class="cm"> * command words and &#39;datasize&#39; additional space. There are two</span>
<span class="cm"> * variantes: 1) dasd_kmalloc_request uses kmalloc to get the needed</span>
<span class="cm"> * memory and 2) dasd_smalloc_request uses the static ccw memory</span>
<span class="cm"> * that gets allocated for each device.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">dasd_ccw_req</span> <span class="o">*</span><span class="nf">dasd_kmalloc_request</span><span class="p">(</span><span class="kt">int</span> <span class="n">magic</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cplength</span><span class="p">,</span>
					  <span class="kt">int</span> <span class="n">datasize</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dasd_ccw_req</span> <span class="o">*</span><span class="n">cqr</span><span class="p">;</span>

	<span class="cm">/* Sanity checks */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">datasize</span> <span class="o">&gt;</span> <span class="n">PAGE_SIZE</span> <span class="o">||</span>
	     <span class="p">(</span><span class="n">cplength</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ccw1</span><span class="p">))</span> <span class="o">&gt;</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>

	<span class="n">cqr</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_ccw_req</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cqr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
	<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">cpaddr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cplength</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">cpaddr</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">cplength</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ccw1</span><span class="p">),</span>
				      <span class="n">GFP_ATOMIC</span> <span class="o">|</span> <span class="n">GFP_DMA</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">cpaddr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">cqr</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">datasize</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">datasize</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span> <span class="o">|</span> <span class="n">GFP_DMA</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">cpaddr</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">cqr</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">=</span>  <span class="n">magic</span><span class="p">;</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">DASD_CQR_FLAGS_USE_ERP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">dasd_get_device</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">cqr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">dasd_ccw_req</span> <span class="o">*</span><span class="nf">dasd_smalloc_request</span><span class="p">(</span><span class="kt">int</span> <span class="n">magic</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cplength</span><span class="p">,</span>
					  <span class="kt">int</span> <span class="n">datasize</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dasd_ccw_req</span> <span class="o">*</span><span class="n">cqr</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_ccw_req</span><span class="p">)</span> <span class="o">+</span> <span class="mi">7L</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">-</span><span class="mi">8L</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cplength</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">size</span> <span class="o">+=</span> <span class="n">cplength</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ccw1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">datasize</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">size</span> <span class="o">+=</span> <span class="n">datasize</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">mem_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">cqr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dasd_ccw_req</span> <span class="o">*</span><span class="p">)</span>
		<span class="n">dasd_alloc_chunk</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">ccw_chunks</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">mem_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cqr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">cqr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_ccw_req</span><span class="p">));</span>
	<span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">cqr</span> <span class="o">+</span> <span class="p">((</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_ccw_req</span><span class="p">)</span> <span class="o">+</span> <span class="mi">7L</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">-</span><span class="mi">8L</span><span class="p">);</span>
	<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">cpaddr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cplength</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">cpaddr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ccw1</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">;</span>
		<span class="n">data</span> <span class="o">+=</span> <span class="n">cplength</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ccw1</span><span class="p">);</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">cpaddr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cplength</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ccw1</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">datasize</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
 		<span class="n">memset</span><span class="p">(</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">datasize</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">=</span> <span class="n">magic</span><span class="p">;</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">DASD_CQR_FLAGS_USE_ERP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">dasd_get_device</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">cqr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Free memory of a channel program. This function needs to free all the</span>
<span class="cm"> * idal lists that might have been created by dasd_set_cda and the</span>
<span class="cm"> * struct dasd_ccw_req itself.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">dasd_kfree_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_ccw_req</span> <span class="o">*</span><span class="n">cqr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_64BIT</span>
	<span class="k">struct</span> <span class="n">ccw1</span> <span class="o">*</span><span class="n">ccw</span><span class="p">;</span>

	<span class="cm">/* Clear any idals used for the request. */</span>
	<span class="n">ccw</span> <span class="o">=</span> <span class="n">cqr</span><span class="o">-&gt;</span><span class="n">cpaddr</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">clear_normalized_cda</span><span class="p">(</span><span class="n">ccw</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">ccw</span><span class="o">++-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">CCW_FLAG_CC</span> <span class="o">|</span> <span class="n">CCW_FLAG_DC</span><span class="p">));</span>
<span class="cp">#endif</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">cpaddr</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">cqr</span><span class="p">);</span>
	<span class="n">dasd_put_device</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">dasd_sfree_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_ccw_req</span> <span class="o">*</span><span class="n">cqr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">mem_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">dasd_free_chunk</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">ccw_chunks</span><span class="p">,</span> <span class="n">cqr</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">mem_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">dasd_put_device</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check discipline magic in cqr.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">dasd_check_cqr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_ccw_req</span> <span class="o">*</span><span class="n">cqr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cqr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">device</span> <span class="o">=</span> <span class="n">cqr</span><span class="o">-&gt;</span><span class="n">startdev</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">magic</span><span class="p">,</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">discipline</span><span class="o">-&gt;</span><span class="n">ebcname</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">DBF_DEV_EVENT</span><span class="p">(</span><span class="n">DBF_WARNING</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span>
			    <span class="s">&quot; dasd_ccw_req 0x%08x magic doesn&#39;t match&quot;</span>
			    <span class="s">&quot; discipline 0x%08x&quot;</span><span class="p">,</span>
			    <span class="n">cqr</span><span class="o">-&gt;</span><span class="n">magic</span><span class="p">,</span>
			    <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">discipline</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Terminate the current i/o and set the request to clear_pending.</span>
<span class="cm"> * Timer keeps device runnig.</span>
<span class="cm"> * ccw_device_clear can fail if the i/o subsystem</span>
<span class="cm"> * is in a bad mood.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dasd_term_IO</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_ccw_req</span> <span class="o">*</span><span class="n">cqr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retries</span><span class="p">,</span> <span class="n">rc</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">errorstring</span><span class="p">[</span><span class="n">ERRORLENGTH</span><span class="p">];</span>

	<span class="cm">/* Check the cqr */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">dasd_check_cqr</span><span class="p">(</span><span class="n">cqr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">retries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">device</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="p">)</span> <span class="n">cqr</span><span class="o">-&gt;</span><span class="n">startdev</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">retries</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="n">DASD_CQR_IN_IO</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">ccw_device_clear</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">cqr</span><span class="p">);</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">0</span>:	<span class="cm">/* termination successful */</span>
			<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">DASD_CQR_CLEAR_PENDING</span><span class="p">;</span>
			<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">stopclk</span> <span class="o">=</span> <span class="n">get_clock</span><span class="p">();</span>
			<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">starttime</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">DBF_DEV_EVENT</span><span class="p">(</span><span class="n">DBF_DEBUG</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span>
				      <span class="s">&quot;terminate cqr %p successful&quot;</span><span class="p">,</span>
				      <span class="n">cqr</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="o">-</span><span class="n">ENODEV</span>:
			<span class="n">DBF_DEV_EVENT</span><span class="p">(</span><span class="n">DBF_ERR</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span>
				      <span class="s">&quot;device gone, retry&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="o">-</span><span class="n">EIO</span>:
			<span class="n">DBF_DEV_EVENT</span><span class="p">(</span><span class="n">DBF_ERR</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span>
				      <span class="s">&quot;I/O error, retry&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="o">-</span><span class="n">EINVAL</span>:
		<span class="k">case</span> <span class="o">-</span><span class="n">EBUSY</span>:
			<span class="n">DBF_DEV_EVENT</span><span class="p">(</span><span class="n">DBF_ERR</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span>
				      <span class="s">&quot;device busy, retry later&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="cm">/* internal error 10 - unknown rc*/</span>
			<span class="n">snprintf</span><span class="p">(</span><span class="n">errorstring</span><span class="p">,</span> <span class="n">ERRORLENGTH</span><span class="p">,</span> <span class="s">&quot;10 %d&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;An error occurred in the &quot;</span>
				<span class="s">&quot;DASD device driver, reason=%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">errorstring</span><span class="p">);</span>
			<span class="n">BUG</span><span class="p">();</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">retries</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dasd_schedule_device_bh</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Start the i/o. This start_IO can fail if the channel is really busy.</span>
<span class="cm"> * In that case set up a timer to start the request later.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dasd_start_IO</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_ccw_req</span> <span class="o">*</span><span class="n">cqr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">errorstring</span><span class="p">[</span><span class="n">ERRORLENGTH</span><span class="p">];</span>

	<span class="cm">/* Check the cqr */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">dasd_check_cqr</span><span class="p">(</span><span class="n">cqr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">intrc</span> <span class="o">=</span> <span class="n">rc</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">device</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="p">)</span> <span class="n">cqr</span><span class="o">-&gt;</span><span class="n">startdev</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(((</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">block</span> <span class="o">&amp;&amp;</span>
	      <span class="n">test_bit</span><span class="p">(</span><span class="n">DASD_FLAG_LOCK_STOLEN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="o">||</span>
	     <span class="n">test_bit</span><span class="p">(</span><span class="n">DASD_FLAG_LOCK_STOLEN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">DASD_CQR_ALLOW_SLOCK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">DBF_DEV_EVENT</span><span class="p">(</span><span class="n">DBF_DEBUG</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="s">&quot;start_IO: return request %p &quot;</span>
			      <span class="s">&quot;because of stolen lock&quot;</span><span class="p">,</span> <span class="n">cqr</span><span class="p">);</span>
		<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">DASD_CQR_ERROR</span><span class="p">;</span>
		<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">intrc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">retries</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* internal error 14 - start_IO run out of retries */</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">errorstring</span><span class="p">,</span> <span class="s">&quot;14 %p&quot;</span><span class="p">,</span> <span class="n">cqr</span><span class="p">);</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;An error occurred in the DASD &quot;</span>
			<span class="s">&quot;device driver, reason=%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">errorstring</span><span class="p">);</span>
		<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">DASD_CQR_ERROR</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">startclk</span> <span class="o">=</span> <span class="n">get_clock</span><span class="p">();</span>
	<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">starttime</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">retries</span><span class="o">--</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">DASD_CQR_VERIFY_PATH</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">lpm</span> <span class="o">&amp;=</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">path_data</span><span class="p">.</span><span class="n">opm</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">lpm</span><span class="p">)</span>
			<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">lpm</span> <span class="o">=</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">path_data</span><span class="p">.</span><span class="n">opm</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">cpmode</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">ccw_device_tm_start</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">,</span> <span class="n">cqr</span><span class="o">-&gt;</span><span class="n">cpaddr</span><span class="p">,</span>
					 <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">cqr</span><span class="p">,</span> <span class="n">cqr</span><span class="o">-&gt;</span><span class="n">lpm</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">ccw_device_start</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">,</span> <span class="n">cqr</span><span class="o">-&gt;</span><span class="n">cpaddr</span><span class="p">,</span>
				      <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">cqr</span><span class="p">,</span> <span class="n">cqr</span><span class="o">-&gt;</span><span class="n">lpm</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">DASD_CQR_IN_IO</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">EBUSY</span>:
		<span class="n">DBF_DEV_EVENT</span><span class="p">(</span><span class="n">DBF_WARNING</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span>
			      <span class="s">&quot;start_IO: device busy, retry later&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">ETIMEDOUT</span>:
		<span class="n">DBF_DEV_EVENT</span><span class="p">(</span><span class="n">DBF_WARNING</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span>
			      <span class="s">&quot;start_IO: request timeout, retry later&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">EACCES</span>:
		<span class="cm">/* -EACCES indicates that the request used only a subset of the</span>
<span class="cm">		 * available paths and all these paths are gone. If the lpm of</span>
<span class="cm">		 * this request was only a subset of the opm (e.g. the ppm) then</span>
<span class="cm">		 * we just do a retry with all available paths.</span>
<span class="cm">		 * If we already use the full opm, something is amiss, and we</span>
<span class="cm">		 * need a full path verification.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">DASD_CQR_VERIFY_PATH</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">DBF_DEV_EVENT</span><span class="p">(</span><span class="n">DBF_WARNING</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span>
				      <span class="s">&quot;start_IO: selected paths gone (%x)&quot;</span><span class="p">,</span>
				      <span class="n">cqr</span><span class="o">-&gt;</span><span class="n">lpm</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">lpm</span> <span class="o">!=</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">path_data</span><span class="p">.</span><span class="n">opm</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">lpm</span> <span class="o">=</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">path_data</span><span class="p">.</span><span class="n">opm</span><span class="p">;</span>
			<span class="n">DBF_DEV_EVENT</span><span class="p">(</span><span class="n">DBF_DEBUG</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span>
				      <span class="s">&quot;start_IO: selected paths gone,&quot;</span>
				      <span class="s">&quot; retry on all paths&quot;</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">DBF_DEV_EVENT</span><span class="p">(</span><span class="n">DBF_WARNING</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span>
				      <span class="s">&quot;start_IO: all paths in opm gone,&quot;</span>
				      <span class="s">&quot; do path verification&quot;</span><span class="p">);</span>
			<span class="n">dasd_generic_last_path_gone</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
			<span class="n">device</span><span class="o">-&gt;</span><span class="n">path_data</span><span class="p">.</span><span class="n">opm</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">device</span><span class="o">-&gt;</span><span class="n">path_data</span><span class="p">.</span><span class="n">ppm</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">device</span><span class="o">-&gt;</span><span class="n">path_data</span><span class="p">.</span><span class="n">npm</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">device</span><span class="o">-&gt;</span><span class="n">path_data</span><span class="p">.</span><span class="n">tbvpm</span> <span class="o">=</span>
				<span class="n">ccw_device_get_path_mask</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">ENODEV</span>:
		<span class="n">DBF_DEV_EVENT</span><span class="p">(</span><span class="n">DBF_WARNING</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span>
			      <span class="s">&quot;start_IO: -ENODEV device gone, retry&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">EIO</span>:
		<span class="n">DBF_DEV_EVENT</span><span class="p">(</span><span class="n">DBF_WARNING</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span>
			      <span class="s">&quot;start_IO: -EIO device gone, retry&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">EINVAL</span>:
		<span class="cm">/* most likely caused in power management context */</span>
		<span class="n">DBF_DEV_EVENT</span><span class="p">(</span><span class="n">DBF_WARNING</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span>
			      <span class="s">&quot;start_IO: -EINVAL device currently &quot;</span>
			      <span class="s">&quot;not accessible&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="cm">/* internal error 11 - unknown rc */</span>
		<span class="n">snprintf</span><span class="p">(</span><span class="n">errorstring</span><span class="p">,</span> <span class="n">ERRORLENGTH</span><span class="p">,</span> <span class="s">&quot;11 %d&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;An error occurred in the DASD device driver, &quot;</span>
			<span class="s">&quot;reason=%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">errorstring</span><span class="p">);</span>
		<span class="n">BUG</span><span class="p">();</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">intrc</span> <span class="o">=</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Timeout function for dasd devices. This is used for different purposes</span>
<span class="cm"> *  1) missing interrupt handler for normal operation</span>
<span class="cm"> *  2) delayed start of request where start_IO failed with -EBUSY</span>
<span class="cm"> *  3) timeout for missing state change interrupts</span>
<span class="cm"> * The head of the ccw queue will have status DASD_CQR_IN_IO for 1),</span>
<span class="cm"> * DASD_CQR_QUEUED for 2) and 3).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">dasd_device_timeout</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">;</span>

	<span class="n">device</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="p">)</span> <span class="n">ptr</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">get_ccwdev_lock</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>
	<span class="cm">/* re-activate request queue */</span>
	<span class="n">dasd_device_remove_stop_bits</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">DASD_STOPPED_PENDING</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">get_ccwdev_lock</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">dasd_schedule_device_bh</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Setup timeout for a device in jiffies.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">dasd_device_set_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">,</span> <span class="kt">int</span> <span class="n">expires</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">expires</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">expires</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Clear timeout for a device.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">dasd_device_clear_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dasd_handle_killed_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">ccw_device</span> <span class="o">*</span><span class="n">cdev</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">intparm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dasd_ccw_req</span> <span class="o">*</span><span class="n">cqr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">intparm</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">cqr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dasd_ccw_req</span> <span class="o">*</span><span class="p">)</span> <span class="n">intparm</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">!=</span> <span class="n">DASD_CQR_IN_IO</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DBF_EVENT_DEVID</span><span class="p">(</span><span class="n">DBF_DEBUG</span><span class="p">,</span> <span class="n">cdev</span><span class="p">,</span>
				<span class="s">&quot;invalid status in handle_killed_request: &quot;</span>
				<span class="s">&quot;%02x&quot;</span><span class="p">,</span> <span class="n">cqr</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">device</span> <span class="o">=</span> <span class="n">dasd_device_from_cdev_locked</span><span class="p">(</span><span class="n">cdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">device</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">DBF_EVENT_DEVID</span><span class="p">(</span><span class="n">DBF_DEBUG</span><span class="p">,</span> <span class="n">cdev</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span>
				<span class="s">&quot;unable to get device from cdev&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">startdev</span> <span class="o">||</span>
	    <span class="n">device</span> <span class="o">!=</span> <span class="n">cqr</span><span class="o">-&gt;</span><span class="n">startdev</span> <span class="o">||</span>
	    <span class="n">strncmp</span><span class="p">(</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">startdev</span><span class="o">-&gt;</span><span class="n">discipline</span><span class="o">-&gt;</span><span class="n">ebcname</span><span class="p">,</span>
		    <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">magic</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">DBF_EVENT_DEVID</span><span class="p">(</span><span class="n">DBF_DEBUG</span><span class="p">,</span> <span class="n">cdev</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span>
				<span class="s">&quot;invalid device in request&quot;</span><span class="p">);</span>
		<span class="n">dasd_put_device</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Schedule request to be retried. */</span>
	<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">DASD_CQR_QUEUED</span><span class="p">;</span>

	<span class="n">dasd_device_clear_timer</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
	<span class="n">dasd_schedule_device_bh</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
	<span class="n">dasd_put_device</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">dasd_generic_handle_state_change</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* First of all start sense subsystem status request. */</span>
	<span class="n">dasd_eer_snss</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>

	<span class="n">dasd_device_remove_stop_bits</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">DASD_STOPPED_PENDING</span><span class="p">);</span>
	<span class="n">dasd_schedule_device_bh</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">)</span>
		<span class="n">dasd_schedule_block_bh</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Interrupt handler for &quot;normal&quot; ssch-io based dasd devices.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">dasd_int_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">ccw_device</span> <span class="o">*</span><span class="n">cdev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">intparm</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">irb</span> <span class="o">*</span><span class="n">irb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dasd_ccw_req</span> <span class="o">*</span><span class="n">cqr</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">now</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">expires</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">irb</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">PTR_ERR</span><span class="p">(</span><span class="n">irb</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">case</span> <span class="o">-</span><span class="n">EIO</span>:
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="o">-</span><span class="n">ETIMEDOUT</span>:
			<span class="n">DBF_EVENT_DEVID</span><span class="p">(</span><span class="n">DBF_WARNING</span><span class="p">,</span> <span class="n">cdev</span><span class="p">,</span> <span class="s">&quot;%s: &quot;</span>
					<span class="s">&quot;request timed out</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">DBF_EVENT_DEVID</span><span class="p">(</span><span class="n">DBF_WARNING</span><span class="p">,</span> <span class="n">cdev</span><span class="p">,</span> <span class="s">&quot;%s: &quot;</span>
					<span class="s">&quot;unknown error %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
					<span class="n">PTR_ERR</span><span class="p">(</span><span class="n">irb</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="n">dasd_handle_killed_request</span><span class="p">(</span><span class="n">cdev</span><span class="p">,</span> <span class="n">intparm</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">now</span> <span class="o">=</span> <span class="n">get_clock</span><span class="p">();</span>
	<span class="n">cqr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dasd_ccw_req</span> <span class="o">*</span><span class="p">)</span> <span class="n">intparm</span><span class="p">;</span>
	<span class="cm">/* check for conditions that should be handled immediately */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cqr</span> <span class="o">||</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">scsw_dstat</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irb</span><span class="o">-&gt;</span><span class="n">scsw</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">DEV_STAT_CHN_END</span> <span class="o">|</span> <span class="n">DEV_STAT_DEV_END</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	      <span class="n">scsw_cstat</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irb</span><span class="o">-&gt;</span><span class="n">scsw</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cqr</span><span class="p">)</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">irb</span><span class="p">,</span> <span class="n">irb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">irb</span><span class="p">));</span>
		<span class="n">device</span> <span class="o">=</span> <span class="n">dasd_device_from_cdev_locked</span><span class="p">(</span><span class="n">cdev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">device</span><span class="p">))</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="cm">/* ignore unsolicited interrupts for DIAG discipline */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">discipline</span> <span class="o">==</span> <span class="n">dasd_diag_discipline_pointer</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dasd_put_device</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">device</span><span class="o">-&gt;</span><span class="n">discipline</span><span class="o">-&gt;</span><span class="n">dump_sense_dbf</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">irb</span><span class="p">,</span> <span class="s">&quot;int&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">DASD_FEATURE_ERPLOG</span><span class="p">)</span>
			<span class="n">device</span><span class="o">-&gt;</span><span class="n">discipline</span><span class="o">-&gt;</span><span class="n">dump_sense</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">cqr</span><span class="p">,</span> <span class="n">irb</span><span class="p">);</span>
		<span class="n">device</span><span class="o">-&gt;</span><span class="n">discipline</span><span class="o">-&gt;</span><span class="n">check_for_device_change</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">cqr</span><span class="p">,</span> <span class="n">irb</span><span class="p">);</span>
		<span class="n">dasd_put_device</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cqr</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">device</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="p">)</span> <span class="n">cqr</span><span class="o">-&gt;</span><span class="n">startdev</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">device</span> <span class="o">||</span>
	    <span class="n">strncmp</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">discipline</span><span class="o">-&gt;</span><span class="n">ebcname</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">magic</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">DBF_EVENT_DEVID</span><span class="p">(</span><span class="n">DBF_DEBUG</span><span class="p">,</span> <span class="n">cdev</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span>
				<span class="s">&quot;invalid device in request&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Check for clear pending */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="n">DASD_CQR_CLEAR_PENDING</span> <span class="o">&amp;&amp;</span>
	    <span class="n">scsw_fctl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irb</span><span class="o">-&gt;</span><span class="n">scsw</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SCSW_FCTL_CLEAR_FUNC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">DASD_CQR_CLEARED</span><span class="p">;</span>
		<span class="n">dasd_device_clear_timer</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
		<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dasd_flush_wq</span><span class="p">);</span>
		<span class="n">dasd_schedule_device_bh</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* check status - the request might have been killed by dyn detach */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">!=</span> <span class="n">DASD_CQR_IN_IO</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DBF_DEV_EVENT</span><span class="p">(</span><span class="n">DBF_DEBUG</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="s">&quot;invalid status: bus_id %s, &quot;</span>
			      <span class="s">&quot;status %02x&quot;</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">),</span> <span class="n">cqr</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">expires</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">scsw_dstat</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irb</span><span class="o">-&gt;</span><span class="n">scsw</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">DEV_STAT_CHN_END</span> <span class="o">|</span> <span class="n">DEV_STAT_DEV_END</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">scsw_cstat</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irb</span><span class="o">-&gt;</span><span class="n">scsw</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* request was completed successfully */</span>
		<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">DASD_CQR_SUCCESS</span><span class="p">;</span>
		<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">stopclk</span> <span class="o">=</span> <span class="n">now</span><span class="p">;</span>
		<span class="cm">/* Start first request on queue if possible -&gt; fast_io. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">devlist</span><span class="p">.</span><span class="n">next</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">ccw_queue</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">next</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">devlist</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">dasd_ccw_req</span><span class="p">,</span> <span class="n">devlist</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>  <span class="cm">/* error */</span>
		<span class="cm">/*</span>
<span class="cm">		 * If we don&#39;t want complex ERP for this request, then just</span>
<span class="cm">		 * reset this and retry it in the fastpath</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">DASD_CQR_FLAGS_USE_ERP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">cqr</span><span class="o">-&gt;</span><span class="n">retries</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">lpm</span> <span class="o">==</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">path_data</span><span class="p">.</span><span class="n">opm</span><span class="p">)</span>
				<span class="n">DBF_DEV_EVENT</span><span class="p">(</span><span class="n">DBF_DEBUG</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span>
					      <span class="s">&quot;default ERP in fastpath &quot;</span>
					      <span class="s">&quot;(%i retries left)&quot;</span><span class="p">,</span>
					      <span class="n">cqr</span><span class="o">-&gt;</span><span class="n">retries</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">DASD_CQR_VERIFY_PATH</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
				<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">lpm</span> <span class="o">=</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">path_data</span><span class="p">.</span><span class="n">opm</span><span class="p">;</span>
			<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">DASD_CQR_QUEUED</span><span class="p">;</span>
			<span class="n">next</span> <span class="o">=</span> <span class="n">cqr</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">DASD_CQR_ERROR</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="n">DASD_CQR_QUEUED</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="o">!</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">stopped</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">discipline</span><span class="o">-&gt;</span><span class="n">start_IO</span><span class="p">(</span><span class="n">next</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">expires</span> <span class="o">=</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">expires</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">expires</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">dasd_device_set_timer</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">expires</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">dasd_device_clear_timer</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
	<span class="n">dasd_schedule_device_bh</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="n">uc_todo</span> <span class="nf">dasd_generic_uc_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">ccw_device</span> <span class="o">*</span><span class="n">cdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irb</span> <span class="o">*</span><span class="n">irb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">;</span>

	<span class="n">device</span> <span class="o">=</span> <span class="n">dasd_device_from_cdev_locked</span><span class="p">(</span><span class="n">cdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">device</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">DASD_FLAG_OFFLINE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span> <span class="o">||</span>
	   <span class="n">device</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">target</span> <span class="o">||</span>
	   <span class="o">!</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">discipline</span><span class="o">-&gt;</span><span class="n">check_for_device_change</span><span class="p">){</span>
		<span class="n">dasd_put_device</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">discipline</span><span class="o">-&gt;</span><span class="n">dump_sense_dbf</span><span class="p">)</span>
		<span class="n">device</span><span class="o">-&gt;</span><span class="n">discipline</span><span class="o">-&gt;</span><span class="n">dump_sense_dbf</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">irb</span><span class="p">,</span> <span class="s">&quot;uc&quot;</span><span class="p">);</span>
	<span class="n">device</span><span class="o">-&gt;</span><span class="n">discipline</span><span class="o">-&gt;</span><span class="n">check_for_device_change</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">irb</span><span class="p">);</span>
	<span class="n">dasd_put_device</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">UC_TODO_RETRY</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">dasd_generic_uc_handler</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * If we have an error on a dasd_block layer request then we cancel</span>
<span class="cm"> * and return all further requests from the same dasd_block as well.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__dasd_device_recovery</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">dasd_ccw_req</span> <span class="o">*</span><span class="n">ref_cqr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">l</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dasd_ccw_req</span> <span class="o">*</span><span class="n">cqr</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * only requeue request that came from the dasd_block layer</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ref_cqr</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">list_for_each_safe</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">ccw_queue</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cqr</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dasd_ccw_req</span><span class="p">,</span> <span class="n">devlist</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="n">DASD_CQR_QUEUED</span> <span class="o">&amp;&amp;</span>
		    <span class="n">ref_cqr</span><span class="o">-&gt;</span><span class="n">block</span> <span class="o">==</span> <span class="n">cqr</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">DASD_CQR_CLEARED</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Remove those ccw requests from the queue that need to be returned</span>
<span class="cm"> * to the upper layer.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__dasd_device_process_ccw_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">final_queue</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">l</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dasd_ccw_req</span> <span class="o">*</span><span class="n">cqr</span><span class="p">;</span>

	<span class="cm">/* Process request with final status. */</span>
	<span class="n">list_for_each_safe</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">ccw_queue</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cqr</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dasd_ccw_req</span><span class="p">,</span> <span class="n">devlist</span><span class="p">);</span>

		<span class="cm">/* Stop list processing at the first non-final request. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="n">DASD_CQR_QUEUED</span> <span class="o">||</span>
		    <span class="n">cqr</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="n">DASD_CQR_IN_IO</span> <span class="o">||</span>
		    <span class="n">cqr</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="n">DASD_CQR_CLEAR_PENDING</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="n">DASD_CQR_ERROR</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">__dasd_device_recovery</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">cqr</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* Rechain finished requests to final queue */</span>
		<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">devlist</span><span class="p">,</span> <span class="n">final_queue</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * the cqrs from the final queue are returned to the upper layer</span>
<span class="cm"> * by setting a dasd_block state and calling the callback function</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__dasd_device_process_final_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">,</span>
					      <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">final_queue</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">l</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dasd_ccw_req</span> <span class="o">*</span><span class="n">cqr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dasd_block</span> <span class="o">*</span><span class="n">block</span><span class="p">;</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">callback</span><span class="p">)(</span><span class="k">struct</span> <span class="n">dasd_ccw_req</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">callback_data</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">errorstring</span><span class="p">[</span><span class="n">ERRORLENGTH</span><span class="p">];</span>

	<span class="n">list_for_each_safe</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">final_queue</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cqr</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dasd_ccw_req</span><span class="p">,</span> <span class="n">devlist</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">devlist</span><span class="p">);</span>
		<span class="n">block</span> <span class="o">=</span> <span class="n">cqr</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">;</span>
		<span class="n">callback</span> <span class="o">=</span> <span class="n">cqr</span><span class="o">-&gt;</span><span class="n">callback</span><span class="p">;</span>
		<span class="n">callback_data</span> <span class="o">=</span> <span class="n">cqr</span><span class="o">-&gt;</span><span class="n">callback_data</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">block</span><span class="p">)</span>
			<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">DASD_CQR_SUCCESS</span>:
			<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">DASD_CQR_DONE</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">DASD_CQR_ERROR</span>:
			<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">DASD_CQR_NEED_ERP</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">DASD_CQR_CLEARED</span>:
			<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">DASD_CQR_TERMINATED</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="cm">/* internal error 12 - wrong cqr status*/</span>
			<span class="n">snprintf</span><span class="p">(</span><span class="n">errorstring</span><span class="p">,</span> <span class="n">ERRORLENGTH</span><span class="p">,</span> <span class="s">&quot;12 %p %x02&quot;</span><span class="p">,</span> <span class="n">cqr</span><span class="p">,</span> <span class="n">cqr</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;An error occurred in the DASD device driver, &quot;</span>
				<span class="s">&quot;reason=%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">errorstring</span><span class="p">);</span>
			<span class="n">BUG</span><span class="p">();</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">callback</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="p">(</span><span class="n">callback</span><span class="p">)(</span><span class="n">cqr</span><span class="p">,</span> <span class="n">callback_data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">block</span><span class="p">)</span>
			<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Take a look at the first request on the ccw queue and check</span>
<span class="cm"> * if it reached its expire time. If so, terminate the IO.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__dasd_device_check_expire</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dasd_ccw_req</span> <span class="o">*</span><span class="n">cqr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">ccw_queue</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">cqr</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">ccw_queue</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dasd_ccw_req</span><span class="p">,</span> <span class="n">devlist</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="n">DASD_CQR_IN_IO</span> <span class="o">&amp;&amp;</span> <span class="n">cqr</span><span class="o">-&gt;</span><span class="n">expires</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">time_after_eq</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">cqr</span><span class="o">-&gt;</span><span class="n">expires</span> <span class="o">+</span> <span class="n">cqr</span><span class="o">-&gt;</span><span class="n">starttime</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">discipline</span><span class="o">-&gt;</span><span class="n">term_IO</span><span class="p">(</span><span class="n">cqr</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Hmpf, try again in 5 sec */</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;cqr %p timed out (%lus) but cannot be &quot;</span>
				<span class="s">&quot;ended, retrying in 5 s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">cqr</span><span class="p">,</span> <span class="p">(</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">expires</span><span class="o">/</span><span class="n">HZ</span><span class="p">));</span>
			<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">expires</span> <span class="o">+=</span> <span class="mi">5</span><span class="o">*</span><span class="n">HZ</span><span class="p">;</span>
			<span class="n">dasd_device_set_timer</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="mi">5</span><span class="o">*</span><span class="n">HZ</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;cqr %p timed out (%lus), %i retries &quot;</span>
				<span class="s">&quot;remaining</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cqr</span><span class="p">,</span> <span class="p">(</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">expires</span><span class="o">/</span><span class="n">HZ</span><span class="p">),</span>
				<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">retries</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Take a look at the first request on the ccw queue and check</span>
<span class="cm"> * if it needs to be started.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__dasd_device_start_head</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dasd_ccw_req</span> <span class="o">*</span><span class="n">cqr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">ccw_queue</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">cqr</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">ccw_queue</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dasd_ccw_req</span><span class="p">,</span> <span class="n">devlist</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">!=</span> <span class="n">DASD_CQR_QUEUED</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="cm">/* when device is stopped, return request to previous layer</span>
<span class="cm">	 * exception: only the disconnect or unresumed bits are set and the</span>
<span class="cm">	 * cqr is a path verification request</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">stopped</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">stopped</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">DASD_STOPPED_DC_WAIT</span> <span class="o">|</span> <span class="n">DASD_UNRESUMED_PM</span><span class="p">))</span>
	      <span class="o">&amp;&amp;</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">DASD_CQR_VERIFY_PATH</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">intrc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
		<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">DASD_CQR_CLEARED</span><span class="p">;</span>
		<span class="n">dasd_schedule_device_bh</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">discipline</span><span class="o">-&gt;</span><span class="n">start_IO</span><span class="p">(</span><span class="n">cqr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">dasd_device_set_timer</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">cqr</span><span class="o">-&gt;</span><span class="n">expires</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dasd_schedule_device_bh</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="cm">/* Hmpf, try again in 1/2 sec */</span>
		<span class="n">dasd_device_set_timer</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__dasd_device_check_path_events</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">path_data</span><span class="p">.</span><span class="n">tbvpm</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">stopped</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">DASD_STOPPED_DC_WAIT</span> <span class="o">|</span>
					<span class="n">DASD_UNRESUMED_PM</span><span class="p">))</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">discipline</span><span class="o">-&gt;</span><span class="n">verify_path</span><span class="p">(</span>
			<span class="n">device</span><span class="p">,</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">path_data</span><span class="p">.</span><span class="n">tbvpm</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="n">dasd_device_set_timer</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">device</span><span class="o">-&gt;</span><span class="n">path_data</span><span class="p">.</span><span class="n">tbvpm</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Go through all request on the dasd_device request queue,</span>
<span class="cm"> * terminate them on the cdev if necessary, and return them to the</span>
<span class="cm"> * submitting layer via callback.</span>
<span class="cm"> * Note:</span>
<span class="cm"> * Make sure that all &#39;submitting layers&#39; still exist when</span>
<span class="cm"> * this function is called!. In other words, when &#39;device&#39; is a base</span>
<span class="cm"> * device then all block layer requests must have been removed before</span>
<span class="cm"> * via dasd_flush_block_queue.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dasd_flush_device_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dasd_ccw_req</span> <span class="o">*</span><span class="n">cqr</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">flush_queue</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">flush_queue</span><span class="p">);</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">get_ccwdev_lock</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">));</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">cqr</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">ccw_queue</span><span class="p">,</span> <span class="n">devlist</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Check status and move request to flush_queue */</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">DASD_CQR_IN_IO</span>:
			<span class="n">rc</span> <span class="o">=</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">discipline</span><span class="o">-&gt;</span><span class="n">term_IO</span><span class="p">(</span><span class="n">cqr</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* unable to terminate requeust */</span>
				<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="s">&quot;Flushing the DASD request queue &quot;</span>
					<span class="s">&quot;failed for request %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cqr</span><span class="p">);</span>
				<span class="cm">/* stop flush processing */</span>
				<span class="k">goto</span> <span class="n">finished</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">DASD_CQR_QUEUED</span>:
			<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">stopclk</span> <span class="o">=</span> <span class="n">get_clock</span><span class="p">();</span>
			<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">DASD_CQR_CLEARED</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span> <span class="cm">/* no need to modify the others */</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">devlist</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flush_queue</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">finished:</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">get_ccwdev_lock</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">));</span>
	<span class="cm">/*</span>
<span class="cm">	 * After this point all requests must be in state CLEAR_PENDING,</span>
<span class="cm">	 * CLEARED, SUCCESS or ERROR. Now wait for CLEAR_PENDING to become</span>
<span class="cm">	 * one of the others.</span>
<span class="cm">	 */</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">cqr</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flush_queue</span><span class="p">,</span> <span class="n">devlist</span><span class="p">)</span>
		<span class="n">wait_event</span><span class="p">(</span><span class="n">dasd_flush_wq</span><span class="p">,</span>
			   <span class="p">(</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">!=</span> <span class="n">DASD_CQR_CLEAR_PENDING</span><span class="p">));</span>
	<span class="cm">/*</span>
<span class="cm">	 * Now set each request back to TERMINATED, DONE or NEED_ERP</span>
<span class="cm">	 * and call the callback function of flushed requests</span>
<span class="cm">	 */</span>
	<span class="n">__dasd_device_process_final_queue</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flush_queue</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Acquire the device lock and process queues for the device.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">dasd_device_tasklet</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">final_queue</span><span class="p">;</span>

	<span class="n">atomic_set</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">tasklet_scheduled</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">final_queue</span><span class="p">);</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">get_ccwdev_lock</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">));</span>
	<span class="cm">/* Check expire time of first request on the ccw queue. */</span>
	<span class="n">__dasd_device_check_expire</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
	<span class="cm">/* find final requests on ccw queue */</span>
	<span class="n">__dasd_device_process_ccw_queue</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">final_queue</span><span class="p">);</span>
	<span class="n">__dasd_device_check_path_events</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">get_ccwdev_lock</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">));</span>
	<span class="cm">/* Now call the callback function of requests with final status */</span>
	<span class="n">__dasd_device_process_final_queue</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">final_queue</span><span class="p">);</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">get_ccwdev_lock</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">));</span>
	<span class="cm">/* Now check if the head of the ccw queue needs to be started. */</span>
	<span class="n">__dasd_device_start_head</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">get_ccwdev_lock</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">));</span>
	<span class="n">dasd_put_device</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Schedules a call to dasd_tasklet over the device tasklet.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">dasd_schedule_device_bh</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Protect against rescheduling. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_cmpxchg</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">tasklet_scheduled</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">dasd_get_device</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
	<span class="n">tasklet_hi_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">tasklet</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">dasd_device_set_stop_bits</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">device</span><span class="o">-&gt;</span><span class="n">stopped</span> <span class="o">|=</span> <span class="n">bits</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">dasd_device_set_stop_bits</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">dasd_device_remove_stop_bits</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">device</span><span class="o">-&gt;</span><span class="n">stopped</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">bits</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">stopped</span><span class="p">)</span>
		<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">generic_waitq</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">dasd_device_remove_stop_bits</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Queue a request to the head of the device ccw_queue.</span>
<span class="cm"> * Start the I/O if possible.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">dasd_add_request_head</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_ccw_req</span> <span class="o">*</span><span class="n">cqr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">device</span> <span class="o">=</span> <span class="n">cqr</span><span class="o">-&gt;</span><span class="n">startdev</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">get_ccwdev_lock</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">DASD_CQR_QUEUED</span><span class="p">;</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">devlist</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">ccw_queue</span><span class="p">);</span>
	<span class="cm">/* let the bh start the request to keep them in order */</span>
	<span class="n">dasd_schedule_device_bh</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">get_ccwdev_lock</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Queue a request to the tail of the device ccw_queue.</span>
<span class="cm"> * Start the I/O if possible.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">dasd_add_request_tail</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_ccw_req</span> <span class="o">*</span><span class="n">cqr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">device</span> <span class="o">=</span> <span class="n">cqr</span><span class="o">-&gt;</span><span class="n">startdev</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">get_ccwdev_lock</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">DASD_CQR_QUEUED</span><span class="p">;</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">devlist</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">ccw_queue</span><span class="p">);</span>
	<span class="cm">/* let the bh start the request to keep them in order */</span>
	<span class="n">dasd_schedule_device_bh</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">get_ccwdev_lock</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Wakeup helper for the &#39;sleep_on&#39; functions.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">dasd_wakeup_cb</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_ccw_req</span> <span class="o">*</span><span class="n">cqr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">get_ccwdev_lock</span><span class="p">(</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">startdev</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">));</span>
	<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">callback_data</span> <span class="o">=</span> <span class="n">DASD_SLEEPON_END_TAG</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">get_ccwdev_lock</span><span class="p">(</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">startdev</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">));</span>
	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">generic_waitq</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">dasd_wakeup_cb</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">_wait_for_wakeup</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_ccw_req</span> <span class="o">*</span><span class="n">cqr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">device</span> <span class="o">=</span> <span class="n">cqr</span><span class="o">-&gt;</span><span class="n">startdev</span><span class="p">;</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">get_ccwdev_lock</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">));</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="p">(</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">callback_data</span> <span class="o">==</span> <span class="n">DASD_SLEEPON_END_TAG</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">get_ccwdev_lock</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * checks if error recovery is necessary, returns 1 if yes, 0 otherwise.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__dasd_sleep_on_erp</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_ccw_req</span> <span class="o">*</span><span class="n">cqr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">;</span>
	<span class="n">dasd_erp_fn_t</span> <span class="n">erp_fn</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="n">DASD_CQR_FILLED</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">device</span> <span class="o">=</span> <span class="n">cqr</span><span class="o">-&gt;</span><span class="n">startdev</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">DASD_CQR_FLAGS_USE_ERP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="n">DASD_CQR_TERMINATED</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">device</span><span class="o">-&gt;</span><span class="n">discipline</span><span class="o">-&gt;</span><span class="n">handle_terminated_request</span><span class="p">(</span><span class="n">cqr</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="n">DASD_CQR_NEED_ERP</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">erp_fn</span> <span class="o">=</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">discipline</span><span class="o">-&gt;</span><span class="n">erp_action</span><span class="p">(</span><span class="n">cqr</span><span class="p">);</span>
			<span class="n">erp_fn</span><span class="p">(</span><span class="n">cqr</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="n">DASD_CQR_FAILED</span><span class="p">)</span>
			<span class="n">dasd_log_sense</span><span class="p">(</span><span class="n">cqr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">irb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">refers</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">__dasd_process_erp</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">cqr</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__dasd_sleep_on_loop_condition</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_ccw_req</span> <span class="o">*</span><span class="n">cqr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">DASD_CQR_FLAGS_USE_ERP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">refers</span><span class="p">)</span> <span class="cm">/* erp is not done yet */</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span> <span class="p">((</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">!=</span> <span class="n">DASD_CQR_DONE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">!=</span> <span class="n">DASD_CQR_FAILED</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="n">DASD_CQR_FILLED</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">_dasd_sleep_on</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_ccw_req</span> <span class="o">*</span><span class="n">maincqr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">interruptible</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">ccw_queue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dasd_ccw_req</span> <span class="o">*</span><span class="n">cqr</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ccw_queue</span><span class="p">);</span>
	<span class="n">maincqr</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">DASD_CQR_FILLED</span><span class="p">;</span>
	<span class="n">device</span> <span class="o">=</span> <span class="n">maincqr</span><span class="o">-&gt;</span><span class="n">startdev</span><span class="p">;</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">maincqr</span><span class="o">-&gt;</span><span class="n">blocklist</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ccw_queue</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">cqr</span> <span class="o">=</span> <span class="n">maincqr</span><span class="p">;</span>  <span class="n">__dasd_sleep_on_loop_condition</span><span class="p">(</span><span class="n">cqr</span><span class="p">);</span>
	     <span class="n">cqr</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ccw_queue</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">dasd_ccw_req</span><span class="p">,</span> <span class="n">blocklist</span><span class="p">))</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">__dasd_sleep_on_erp</span><span class="p">(</span><span class="n">cqr</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">!=</span> <span class="n">DASD_CQR_FILLED</span><span class="p">)</span> <span class="cm">/* could be failed */</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">DASD_FLAG_LOCK_STOLEN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">DASD_CQR_ALLOW_SLOCK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">DASD_CQR_FAILED</span><span class="p">;</span>
			<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">intrc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Non-temporary stop condition will trigger fail fast */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">stopped</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">DASD_STOPPED_PENDING</span> <span class="o">&amp;&amp;</span>
		    <span class="n">test_bit</span><span class="p">(</span><span class="n">DASD_CQR_FLAGS_FAILFAST</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="o">!</span><span class="n">dasd_eer_enabled</span><span class="p">(</span><span class="n">device</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">DASD_CQR_FAILED</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Don&#39;t try to start requests if device is stopped */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">interruptible</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">wait_event_interruptible</span><span class="p">(</span>
				<span class="n">generic_waitq</span><span class="p">,</span> <span class="o">!</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">stopped</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">ERESTARTSYS</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">DASD_CQR_FAILED</span><span class="p">;</span>
				<span class="n">maincqr</span><span class="o">-&gt;</span><span class="n">intrc</span> <span class="o">=</span> <span class="n">rc</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">wait_event</span><span class="p">(</span><span class="n">generic_waitq</span><span class="p">,</span> <span class="o">!</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">stopped</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">callback</span><span class="p">)</span>
			<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">callback</span> <span class="o">=</span> <span class="n">dasd_wakeup_cb</span><span class="p">;</span>

		<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">callback_data</span> <span class="o">=</span> <span class="n">DASD_SLEEPON_START_TAG</span><span class="p">;</span>
		<span class="n">dasd_add_request_tail</span><span class="p">(</span><span class="n">cqr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">interruptible</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">wait_event_interruptible</span><span class="p">(</span>
				<span class="n">generic_waitq</span><span class="p">,</span> <span class="n">_wait_for_wakeup</span><span class="p">(</span><span class="n">cqr</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">ERESTARTSYS</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dasd_cancel_req</span><span class="p">(</span><span class="n">cqr</span><span class="p">);</span>
				<span class="cm">/* wait (non-interruptible) for final status */</span>
				<span class="n">wait_event</span><span class="p">(</span><span class="n">generic_waitq</span><span class="p">,</span>
					   <span class="n">_wait_for_wakeup</span><span class="p">(</span><span class="n">cqr</span><span class="p">));</span>
				<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">DASD_CQR_FAILED</span><span class="p">;</span>
				<span class="n">maincqr</span><span class="o">-&gt;</span><span class="n">intrc</span> <span class="o">=</span> <span class="n">rc</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">wait_event</span><span class="p">(</span><span class="n">generic_waitq</span><span class="p">,</span> <span class="n">_wait_for_wakeup</span><span class="p">(</span><span class="n">cqr</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">maincqr</span><span class="o">-&gt;</span><span class="n">endclk</span> <span class="o">=</span> <span class="n">get_clock</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">maincqr</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">!=</span> <span class="n">DASD_CQR_DONE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">maincqr</span><span class="o">-&gt;</span><span class="n">intrc</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ERESTARTSYS</span><span class="p">))</span>
		<span class="n">dasd_log_sense</span><span class="p">(</span><span class="n">maincqr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">maincqr</span><span class="o">-&gt;</span><span class="n">irb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">maincqr</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="n">DASD_CQR_DONE</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">maincqr</span><span class="o">-&gt;</span><span class="n">intrc</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">maincqr</span><span class="o">-&gt;</span><span class="n">intrc</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Queue a request to the tail of the device ccw_queue and wait for</span>
<span class="cm"> * it&#39;s completion.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dasd_sleep_on</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_ccw_req</span> <span class="o">*</span><span class="n">cqr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">_dasd_sleep_on</span><span class="p">(</span><span class="n">cqr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Queue a request to the tail of the device ccw_queue and wait</span>
<span class="cm"> * interruptible for it&#39;s completion.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dasd_sleep_on_interruptible</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_ccw_req</span> <span class="o">*</span><span class="n">cqr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">_dasd_sleep_on</span><span class="p">(</span><span class="n">cqr</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Whoa nelly now it gets really hairy. For some functions (e.g. steal lock</span>
<span class="cm"> * for eckd devices) the currently running request has to be terminated</span>
<span class="cm"> * and be put back to status queued, before the special request is added</span>
<span class="cm"> * to the head of the queue. Then the special request is waited on normally.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">_dasd_term_running_cqr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dasd_ccw_req</span> <span class="o">*</span><span class="n">cqr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">ccw_queue</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cqr</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">ccw_queue</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dasd_ccw_req</span><span class="p">,</span> <span class="n">devlist</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">discipline</span><span class="o">-&gt;</span><span class="n">term_IO</span><span class="p">(</span><span class="n">cqr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span><span class="p">)</span>
		<span class="cm">/*</span>
<span class="cm">		 * CQR terminated because a more important request is pending.</span>
<span class="cm">		 * Undo decreasing of retry counter because this is</span>
<span class="cm">		 * not an error case.</span>
<span class="cm">		 */</span>
		<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">retries</span><span class="o">++</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">dasd_sleep_on_immediatly</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_ccw_req</span> <span class="o">*</span><span class="n">cqr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">device</span> <span class="o">=</span> <span class="n">cqr</span><span class="o">-&gt;</span><span class="n">startdev</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">DASD_FLAG_LOCK_STOLEN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">DASD_CQR_ALLOW_SLOCK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">DASD_CQR_FAILED</span><span class="p">;</span>
		<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">intrc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">get_ccwdev_lock</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">));</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">_dasd_term_running_cqr</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">get_ccwdev_lock</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">));</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">callback</span> <span class="o">=</span> <span class="n">dasd_wakeup_cb</span><span class="p">;</span>
	<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">callback_data</span> <span class="o">=</span> <span class="n">DASD_SLEEPON_START_TAG</span><span class="p">;</span>
	<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">DASD_CQR_QUEUED</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * add new request as second</span>
<span class="cm">	 * first the terminated cqr needs to be finished</span>
<span class="cm">	 */</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">devlist</span><span class="p">,</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">ccw_queue</span><span class="p">.</span><span class="n">next</span><span class="p">);</span>

	<span class="cm">/* let the bh start the request to keep them in order */</span>
	<span class="n">dasd_schedule_device_bh</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>

	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">get_ccwdev_lock</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">));</span>

	<span class="n">wait_event</span><span class="p">(</span><span class="n">generic_waitq</span><span class="p">,</span> <span class="n">_wait_for_wakeup</span><span class="p">(</span><span class="n">cqr</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="n">DASD_CQR_DONE</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">intrc</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">cqr</span><span class="o">-&gt;</span><span class="n">intrc</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Cancels a request that was started with dasd_sleep_on_req.</span>
<span class="cm"> * This is useful to timeout requests. The request will be</span>
<span class="cm"> * terminated if it is currently in i/o.</span>
<span class="cm"> * Returns 1 if the request has been terminated.</span>
<span class="cm"> *	   0 if there was no need to terminate the request (not started yet)</span>
<span class="cm"> *	   negative error code if termination failed</span>
<span class="cm"> * Cancellation of a request is an asynchronous operation! The calling</span>
<span class="cm"> * function has to wait until the request is properly returned via callback.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dasd_cancel_req</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_ccw_req</span> <span class="o">*</span><span class="n">cqr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span> <span class="o">=</span> <span class="n">cqr</span><span class="o">-&gt;</span><span class="n">startdev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">get_ccwdev_lock</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">DASD_CQR_QUEUED</span>:
		<span class="cm">/* request was not started - just set to cleared */</span>
		<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">DASD_CQR_CLEARED</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DASD_CQR_IN_IO</span>:
		<span class="cm">/* request in IO - terminate IO and release again */</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">discipline</span><span class="o">-&gt;</span><span class="n">term_IO</span><span class="p">(</span><span class="n">cqr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;Cancelling request %p failed with rc=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">cqr</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">stopclk</span> <span class="o">=</span> <span class="n">get_clock</span><span class="p">();</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span> <span class="cm">/* already finished or clear pending - do nothing */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">get_ccwdev_lock</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">dasd_schedule_device_bh</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * SECTION: Operations of the dasd_block layer.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Timeout function for dasd_block. This is used when the block layer</span>
<span class="cm"> * is waiting for something that may not come reliably, (e.g. a state</span>
<span class="cm"> * change interrupt)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">dasd_block_timeout</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dasd_block</span> <span class="o">*</span><span class="n">block</span><span class="p">;</span>

	<span class="n">block</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dasd_block</span> <span class="o">*</span><span class="p">)</span> <span class="n">ptr</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">get_ccwdev_lock</span><span class="p">(</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>
	<span class="cm">/* re-activate request queue */</span>
	<span class="n">dasd_device_remove_stop_bits</span><span class="p">(</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span> <span class="n">DASD_STOPPED_PENDING</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">get_ccwdev_lock</span><span class="p">(</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">dasd_schedule_block_bh</span><span class="p">(</span><span class="n">block</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Setup timeout for a dasd_block in jiffies.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">dasd_block_set_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_block</span> <span class="o">*</span><span class="n">block</span><span class="p">,</span> <span class="kt">int</span> <span class="n">expires</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">expires</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">expires</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Clear timeout for a dasd_block.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">dasd_block_clear_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_block</span> <span class="o">*</span><span class="n">block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Process finished error recovery ccw.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__dasd_process_erp</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">dasd_ccw_req</span> <span class="o">*</span><span class="n">cqr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dasd_erp_fn_t</span> <span class="n">erp_fn</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="n">DASD_CQR_DONE</span><span class="p">)</span>
		<span class="n">DBF_DEV_EVENT</span><span class="p">(</span><span class="n">DBF_NOTICE</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="s">&quot;ERP successful&quot;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;ERP failed for the DASD</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">erp_fn</span> <span class="o">=</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">discipline</span><span class="o">-&gt;</span><span class="n">erp_postaction</span><span class="p">(</span><span class="n">cqr</span><span class="p">);</span>
	<span class="n">erp_fn</span><span class="p">(</span><span class="n">cqr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Fetch requests from the block device queue.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__dasd_process_request_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_block</span> <span class="o">*</span><span class="n">block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">queue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">req</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dasd_ccw_req</span> <span class="o">*</span><span class="n">cqr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">basedev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">queue</span> <span class="o">=</span> <span class="n">block</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="p">;</span>
	<span class="n">basedev</span> <span class="o">=</span> <span class="n">block</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>
	<span class="cm">/* No queue ? Then there is nothing to do. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">queue</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We requeue request from the block device queue to the ccw</span>
<span class="cm">	 * queue only in two states. In state DASD_STATE_READY the</span>
<span class="cm">	 * partition detection is done and we need to requeue requests</span>
<span class="cm">	 * for that. State DASD_STATE_ONLINE is normal block device</span>
<span class="cm">	 * operation.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">basedev</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&lt;</span> <span class="n">DASD_STATE_READY</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">((</span><span class="n">req</span> <span class="o">=</span> <span class="n">blk_fetch_request</span><span class="p">(</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="p">)))</span>
			<span class="n">__blk_end_request_all</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="o">-</span><span class="n">EIO</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Now we try to fetch requests from the request queue */</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">req</span> <span class="o">=</span> <span class="n">blk_peek_request</span><span class="p">(</span><span class="n">queue</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">basedev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">DASD_FEATURE_READONLY</span> <span class="o">&amp;&amp;</span>
		    <span class="n">rq_data_dir</span><span class="p">(</span><span class="n">req</span><span class="p">)</span> <span class="o">==</span> <span class="n">WRITE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DBF_DEV_EVENT</span><span class="p">(</span><span class="n">DBF_ERR</span><span class="p">,</span> <span class="n">basedev</span><span class="p">,</span>
				      <span class="s">&quot;Rejecting write request %p&quot;</span><span class="p">,</span>
				      <span class="n">req</span><span class="p">);</span>
			<span class="n">blk_start_request</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
			<span class="n">__blk_end_request_all</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="o">-</span><span class="n">EIO</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">cqr</span> <span class="o">=</span> <span class="n">basedev</span><span class="o">-&gt;</span><span class="n">discipline</span><span class="o">-&gt;</span><span class="n">build_cp</span><span class="p">(</span><span class="n">basedev</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">cqr</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">PTR_ERR</span><span class="p">(</span><span class="n">cqr</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>	<span class="cm">/* normal end condition */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">PTR_ERR</span><span class="p">(</span><span class="n">cqr</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>	<span class="cm">/* terminate request queue loop */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">PTR_ERR</span><span class="p">(</span><span class="n">cqr</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * The current request cannot be build right</span>
<span class="cm">				 * now, we have to try later. If this request</span>
<span class="cm">				 * is the head-of-queue we stop the device</span>
<span class="cm">				 * for 1/2 second.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">ccw_queue</span><span class="p">))</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="n">spin_lock_irqsave</span><span class="p">(</span>
					<span class="n">get_ccwdev_lock</span><span class="p">(</span><span class="n">basedev</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>
				<span class="n">dasd_device_set_stop_bits</span><span class="p">(</span><span class="n">basedev</span><span class="p">,</span>
							  <span class="n">DASD_STOPPED_PENDING</span><span class="p">);</span>
				<span class="n">spin_unlock_irqrestore</span><span class="p">(</span>
					<span class="n">get_ccwdev_lock</span><span class="p">(</span><span class="n">basedev</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>
				<span class="n">dasd_block_set_timer</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">HZ</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">DBF_DEV_EVENT</span><span class="p">(</span><span class="n">DBF_ERR</span><span class="p">,</span> <span class="n">basedev</span><span class="p">,</span>
				      <span class="s">&quot;CCW creation failed (rc=%ld) &quot;</span>
				      <span class="s">&quot;on request %p&quot;</span><span class="p">,</span>
				      <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">cqr</span><span class="p">),</span> <span class="n">req</span><span class="p">);</span>
			<span class="n">blk_start_request</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
			<span class="n">__blk_end_request_all</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="o">-</span><span class="n">EIO</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 *  Note: callback is set to dasd_return_cqr_cb in</span>
<span class="cm">		 * __dasd_block_start_head to cover erp requests as well</span>
<span class="cm">		 */</span>
		<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">callback_data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">req</span><span class="p">;</span>
		<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">DASD_CQR_FILLED</span><span class="p">;</span>
		<span class="n">blk_start_request</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">blocklist</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">ccw_queue</span><span class="p">);</span>
		<span class="n">dasd_profile_start</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">cqr</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__dasd_cleanup_cqr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_ccw_req</span> <span class="o">*</span><span class="n">cqr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">req</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">req</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="p">)</span> <span class="n">cqr</span><span class="o">-&gt;</span><span class="n">callback_data</span><span class="p">;</span>
	<span class="n">dasd_profile_end</span><span class="p">(</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">,</span> <span class="n">cqr</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">cqr</span><span class="o">-&gt;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">discipline</span><span class="o">-&gt;</span><span class="n">free_cp</span><span class="p">(</span><span class="n">cqr</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">status</span> <span class="o">?</span> <span class="n">status</span> <span class="o">:</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="n">__blk_end_request_all</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Process ccw request queue.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__dasd_process_block_ccw_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_block</span> <span class="o">*</span><span class="n">block</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">final_queue</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">l</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dasd_ccw_req</span> <span class="o">*</span><span class="n">cqr</span><span class="p">;</span>
	<span class="n">dasd_erp_fn_t</span> <span class="n">erp_fn</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="n">block</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>

<span class="nl">restart:</span>
	<span class="cm">/* Process request with final status. */</span>
	<span class="n">list_for_each_safe</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">ccw_queue</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cqr</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dasd_ccw_req</span><span class="p">,</span> <span class="n">blocklist</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">!=</span> <span class="n">DASD_CQR_DONE</span> <span class="o">&amp;&amp;</span>
		    <span class="n">cqr</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">!=</span> <span class="n">DASD_CQR_FAILED</span> <span class="o">&amp;&amp;</span>
		    <span class="n">cqr</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">!=</span> <span class="n">DASD_CQR_NEED_ERP</span> <span class="o">&amp;&amp;</span>
		    <span class="n">cqr</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">!=</span> <span class="n">DASD_CQR_TERMINATED</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="n">DASD_CQR_TERMINATED</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">base</span><span class="o">-&gt;</span><span class="n">discipline</span><span class="o">-&gt;</span><span class="n">handle_terminated_request</span><span class="p">(</span><span class="n">cqr</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*  Process requests that may be recovered */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="n">DASD_CQR_NEED_ERP</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">erp_fn</span> <span class="o">=</span> <span class="n">base</span><span class="o">-&gt;</span><span class="n">discipline</span><span class="o">-&gt;</span><span class="n">erp_action</span><span class="p">(</span><span class="n">cqr</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">erp_fn</span><span class="p">(</span><span class="n">cqr</span><span class="p">)))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* log sense for fatal error */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="n">DASD_CQR_FAILED</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dasd_log_sense</span><span class="p">(</span><span class="n">cqr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">irb</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* First of all call extended error reporting. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dasd_eer_enabled</span><span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">cqr</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="n">DASD_CQR_FAILED</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dasd_eer_write</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">cqr</span><span class="p">,</span> <span class="n">DASD_EER_FATALERROR</span><span class="p">);</span>

			<span class="cm">/* restart request  */</span>
			<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">DASD_CQR_FILLED</span><span class="p">;</span>
			<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">retries</span> <span class="o">=</span> <span class="mi">255</span><span class="p">;</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">get_ccwdev_lock</span><span class="p">(</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">dasd_device_set_stop_bits</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">DASD_STOPPED_QUIESCE</span><span class="p">);</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">get_ccwdev_lock</span><span class="p">(</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">),</span>
					       <span class="n">flags</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Process finished ERP request. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">refers</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">__dasd_process_erp</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">cqr</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Rechain finished requests to final queue */</span>
		<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">endclk</span> <span class="o">=</span> <span class="n">get_clock</span><span class="p">();</span>
		<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">blocklist</span><span class="p">,</span> <span class="n">final_queue</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dasd_return_cqr_cb</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_ccw_req</span> <span class="o">*</span><span class="n">cqr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dasd_schedule_block_bh</span><span class="p">(</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__dasd_block_start_head</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_block</span> <span class="o">*</span><span class="n">block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dasd_ccw_req</span> <span class="o">*</span><span class="n">cqr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">ccw_queue</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="cm">/* We allways begin with the first requests on the queue, as some</span>
<span class="cm">	 * of previously started requests have to be enqueued on a</span>
<span class="cm">	 * dasd_device again for error recovery.</span>
<span class="cm">	 */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">cqr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">ccw_queue</span><span class="p">,</span> <span class="n">blocklist</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">!=</span> <span class="n">DASD_CQR_FILLED</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">DASD_FLAG_LOCK_STOLEN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">DASD_CQR_ALLOW_SLOCK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">DASD_CQR_FAILED</span><span class="p">;</span>
			<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">intrc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
			<span class="n">dasd_schedule_block_bh</span><span class="p">(</span><span class="n">block</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Non-temporary stop condition will trigger fail fast */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">stopped</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">DASD_STOPPED_PENDING</span> <span class="o">&amp;&amp;</span>
		    <span class="n">test_bit</span><span class="p">(</span><span class="n">DASD_CQR_FLAGS_FAILFAST</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="o">!</span><span class="n">dasd_eer_enabled</span><span class="p">(</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">DASD_CQR_FAILED</span><span class="p">;</span>
			<span class="n">dasd_schedule_block_bh</span><span class="p">(</span><span class="n">block</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Don&#39;t try to start requests if device is stopped */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">stopped</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="cm">/* just a fail safe check, should not happen */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">startdev</span><span class="p">)</span>
			<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">startdev</span> <span class="o">=</span> <span class="n">block</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>

		<span class="cm">/* make sure that the requests we submit find their way back */</span>
		<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">callback</span> <span class="o">=</span> <span class="n">dasd_return_cqr_cb</span><span class="p">;</span>

		<span class="n">dasd_add_request_tail</span><span class="p">(</span><span class="n">cqr</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Central dasd_block layer routine. Takes requests from the generic</span>
<span class="cm"> * block layer request queue, creates ccw requests, enqueues them on</span>
<span class="cm"> * a dasd_device and processes ccw requests that have been returned.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">dasd_block_tasklet</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_block</span> <span class="o">*</span><span class="n">block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">final_queue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">l</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dasd_ccw_req</span> <span class="o">*</span><span class="n">cqr</span><span class="p">;</span>

	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">tasklet_scheduled</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">final_queue</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="cm">/* Finish off requests on ccw queue */</span>
	<span class="n">__dasd_process_block_ccw_queue</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">final_queue</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="cm">/* Now call the callback function of requests with final status */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">request_queue_lock</span><span class="p">);</span>
	<span class="n">list_for_each_safe</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">final_queue</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cqr</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dasd_ccw_req</span><span class="p">,</span> <span class="n">blocklist</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">blocklist</span><span class="p">);</span>
		<span class="n">__dasd_cleanup_cqr</span><span class="p">(</span><span class="n">cqr</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="cm">/* Get new request from the block device request queue */</span>
	<span class="n">__dasd_process_request_queue</span><span class="p">(</span><span class="n">block</span><span class="p">);</span>
	<span class="cm">/* Now check if the head of the ccw queue needs to be started. */</span>
	<span class="n">__dasd_block_start_head</span><span class="p">(</span><span class="n">block</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">request_queue_lock</span><span class="p">);</span>
	<span class="n">dasd_put_device</span><span class="p">(</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">_dasd_wake_block_flush_cb</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_ccw_req</span> <span class="o">*</span><span class="n">cqr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dasd_flush_wq</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Go through all request on the dasd_block request queue, cancel them</span>
<span class="cm"> * on the respective dasd_device, and return them to the generic</span>
<span class="cm"> * block layer.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dasd_flush_block_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_block</span> <span class="o">*</span><span class="n">block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dasd_ccw_req</span> <span class="o">*</span><span class="n">cqr</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">flush_queue</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">flush_queue</span><span class="p">);</span>
	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">restart:</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">cqr</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">ccw_queue</span><span class="p">,</span> <span class="n">blocklist</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* if this request currently owned by a dasd_device cancel it */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&gt;=</span> <span class="n">DASD_CQR_QUEUED</span><span class="p">)</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">dasd_cancel_req</span><span class="p">(</span><span class="n">cqr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="cm">/* Rechain request (including erp chain) so it won&#39;t be</span>
<span class="cm">		 * touched by the dasd_block_tasklet anymore.</span>
<span class="cm">		 * Replace the callback so we notice when the request</span>
<span class="cm">		 * is returned from the dasd_device layer.</span>
<span class="cm">		 */</span>
		<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">callback</span> <span class="o">=</span> <span class="n">_dasd_wake_block_flush_cb</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">cqr</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">cqr</span> <span class="o">=</span> <span class="n">cqr</span><span class="o">-&gt;</span><span class="n">refers</span><span class="p">,</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">blocklist</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flush_queue</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
			<span class="cm">/* moved more than one request - need to restart */</span>
			<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="cm">/* Now call the callback function of flushed requests */</span>
<span class="nl">restart_cb:</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">cqr</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flush_queue</span><span class="p">,</span> <span class="n">blocklist</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">wait_event</span><span class="p">(</span><span class="n">dasd_flush_wq</span><span class="p">,</span> <span class="p">(</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&lt;</span> <span class="n">DASD_CQR_QUEUED</span><span class="p">));</span>
		<span class="cm">/* Process finished ERP request. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">refers</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>
			<span class="n">__dasd_process_erp</span><span class="p">(</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span> <span class="n">cqr</span><span class="p">);</span>
			<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>
			<span class="cm">/* restart list_for_xx loop since dasd_process_erp</span>
<span class="cm">			 * might remove multiple elements */</span>
			<span class="k">goto</span> <span class="n">restart_cb</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* call the callback function */</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">request_queue_lock</span><span class="p">);</span>
		<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">endclk</span> <span class="o">=</span> <span class="n">get_clock</span><span class="p">();</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">blocklist</span><span class="p">);</span>
		<span class="n">__dasd_cleanup_cqr</span><span class="p">(</span><span class="n">cqr</span><span class="p">);</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">request_queue_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Schedules a call to dasd_tasklet over the device tasklet.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">dasd_schedule_block_bh</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_block</span> <span class="o">*</span><span class="n">block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Protect against rescheduling. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_cmpxchg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">tasklet_scheduled</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="cm">/* life cycle of block is bound to it&#39;s base device */</span>
	<span class="n">dasd_get_device</span><span class="p">(</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>
	<span class="n">tasklet_hi_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">tasklet</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * SECTION: external block device operations</span>
<span class="cm"> * (request queue handling, open, release, etc.)</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Dasd request queue function. Called from ll_rw_blk.c</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">do_dasd_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">queue</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dasd_block</span> <span class="o">*</span><span class="n">block</span><span class="p">;</span>

	<span class="n">block</span> <span class="o">=</span> <span class="n">queue</span><span class="o">-&gt;</span><span class="n">queuedata</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>
	<span class="cm">/* Get new request from the block device request queue */</span>
	<span class="n">__dasd_process_request_queue</span><span class="p">(</span><span class="n">block</span><span class="p">);</span>
	<span class="cm">/* Now check if the head of the ccw queue needs to be started. */</span>
	<span class="n">__dasd_block_start_head</span><span class="p">(</span><span class="n">block</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate and initialize request queue and default I/O scheduler.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dasd_alloc_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_block</span> <span class="o">*</span><span class="n">block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">block</span><span class="o">-&gt;</span><span class="n">request_queue</span> <span class="o">=</span> <span class="n">blk_init_queue</span><span class="p">(</span><span class="n">do_dasd_request</span><span class="p">,</span>
					       <span class="o">&amp;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">request_queue_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">request_queue</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">block</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="o">-&gt;</span><span class="n">queuedata</span> <span class="o">=</span> <span class="n">block</span><span class="p">;</span>

	<span class="n">elevator_exit</span><span class="p">(</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="o">-&gt;</span><span class="n">elevator</span><span class="p">);</span>
	<span class="n">block</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="o">-&gt;</span><span class="n">elevator</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">elevator_init</span><span class="p">(</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="p">,</span> <span class="s">&quot;deadline&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">blk_cleanup_queue</span><span class="p">(</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate and initialize request queue.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">dasd_setup_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_block</span> <span class="o">*</span><span class="n">block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">max</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">DASD_FEATURE_USERAW</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * the max_blocks value for raw_track access is 256</span>
<span class="cm">		 * it is higher than the native ECKD value because we</span>
<span class="cm">		 * only need one ccw per track</span>
<span class="cm">		 * so the max_hw_sectors are</span>
<span class="cm">		 * 2048 x 512B = 1024kB = 16 tracks</span>
<span class="cm">		 */</span>
		<span class="n">max</span> <span class="o">=</span> <span class="mi">2048</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">max</span> <span class="o">=</span> <span class="n">block</span><span class="o">-&gt;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">discipline</span><span class="o">-&gt;</span><span class="n">max_blocks</span> <span class="o">&lt;&lt;</span> <span class="n">block</span><span class="o">-&gt;</span><span class="n">s2b_shift</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">blk_queue_logical_block_size</span><span class="p">(</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="p">,</span>
				     <span class="n">block</span><span class="o">-&gt;</span><span class="n">bp_block</span><span class="p">);</span>
	<span class="n">blk_queue_max_hw_sectors</span><span class="p">(</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="p">,</span> <span class="n">max</span><span class="p">);</span>
	<span class="n">blk_queue_max_segments</span><span class="p">(</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="p">,</span> <span class="o">-</span><span class="mi">1L</span><span class="p">);</span>
	<span class="cm">/* with page sized segments we can translate each segement into</span>
<span class="cm">	 * one idaw/tidaw</span>
<span class="cm">	 */</span>
	<span class="n">blk_queue_max_segment_size</span><span class="p">(</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="n">blk_queue_segment_boundary</span><span class="p">(</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="p">,</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Deactivate and free request queue.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">dasd_free_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_block</span> <span class="o">*</span><span class="n">block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">blk_cleanup_queue</span><span class="p">(</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="p">);</span>
		<span class="n">block</span><span class="o">-&gt;</span><span class="n">request_queue</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Flush request on the request queue.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">dasd_flush_request_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_block</span> <span class="o">*</span><span class="n">block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">req</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">request_queue_lock</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">req</span> <span class="o">=</span> <span class="n">blk_fetch_request</span><span class="p">(</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="p">)))</span>
		<span class="n">__blk_end_request_all</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="o">-</span><span class="n">EIO</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">request_queue_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dasd_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span> <span class="n">fmode_t</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">base</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">base</span> <span class="o">=</span> <span class="n">dasd_device_from_gendisk</span><span class="p">(</span><span class="n">bdev</span><span class="o">-&gt;</span><span class="n">bd_disk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">base</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">open_count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">DASD_FLAG_OFFLINE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">try_module_get</span><span class="p">(</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">discipline</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dasd_probeonly</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			 <span class="s">&quot;Accessing the DASD failed because it is in &quot;</span>
			 <span class="s">&quot;probeonly mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&lt;=</span> <span class="n">DASD_STATE_BASIC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DBF_DEV_EVENT</span><span class="p">(</span><span class="n">DBF_ERR</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="s">&quot; %s&quot;</span><span class="p">,</span>
			      <span class="s">&quot; Cannot open unrecognized device&quot;</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">FMODE_WRITE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">DASD_FLAG_DEVICE_RO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span> <span class="o">||</span>
	     <span class="p">(</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">DASD_FEATURE_READONLY</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dasd_put_device</span><span class="p">(</span><span class="n">base</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">module_put</span><span class="p">(</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">discipline</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">);</span>
<span class="nl">unlock:</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">open_count</span><span class="p">);</span>
	<span class="n">dasd_put_device</span><span class="p">(</span><span class="n">base</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dasd_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">,</span> <span class="n">fmode_t</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">base</span><span class="p">;</span>

	<span class="n">base</span> <span class="o">=</span> <span class="n">dasd_device_from_gendisk</span><span class="p">(</span><span class="n">disk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">base</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">open_count</span><span class="p">);</span>
	<span class="n">module_put</span><span class="p">(</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">discipline</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">);</span>
	<span class="n">dasd_put_device</span><span class="p">(</span><span class="n">base</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return disk geometry.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dasd_getgeo</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hd_geometry</span> <span class="o">*</span><span class="n">geo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">base</span><span class="p">;</span>

	<span class="n">base</span> <span class="o">=</span> <span class="n">dasd_device_from_gendisk</span><span class="p">(</span><span class="n">bdev</span><span class="o">-&gt;</span><span class="n">bd_disk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">base</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">discipline</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">discipline</span><span class="o">-&gt;</span><span class="n">fill_geometry</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dasd_put_device</span><span class="p">(</span><span class="n">base</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">base</span><span class="o">-&gt;</span><span class="n">discipline</span><span class="o">-&gt;</span><span class="n">fill_geometry</span><span class="p">(</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">,</span> <span class="n">geo</span><span class="p">);</span>
	<span class="n">geo</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">get_start_sect</span><span class="p">(</span><span class="n">bdev</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">base</span><span class="o">-&gt;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">s2b_shift</span><span class="p">;</span>
	<span class="n">dasd_put_device</span><span class="p">(</span><span class="n">base</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">block_device_operations</span>
<span class="n">dasd_device_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">dasd_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">dasd_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ioctl</span>		<span class="o">=</span> <span class="n">dasd_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">compat_ioctl</span>	<span class="o">=</span> <span class="n">dasd_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">getgeo</span>		<span class="o">=</span> <span class="n">dasd_getgeo</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*******************************************************************************</span>
<span class="cm"> * end of block device operations</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">dasd_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_PROC_FS</span>
	<span class="n">dasd_proc_exit</span><span class="p">();</span>
<span class="cp">#endif</span>
	<span class="n">dasd_eer_exit</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dasd_page_cache</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">dasd_page_cache</span><span class="p">);</span>
		<span class="n">dasd_page_cache</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dasd_gendisk_exit</span><span class="p">();</span>
	<span class="n">dasd_devmap_exit</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dasd_debug_area</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">debug_unregister</span><span class="p">(</span><span class="n">dasd_debug_area</span><span class="p">);</span>
		<span class="n">dasd_debug_area</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dasd_statistics_removeroot</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * SECTION: common functions for ccw_driver use</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Is the device read-only?</span>
<span class="cm"> * Note that this function does not report the setting of the</span>
<span class="cm"> * readonly device attribute, but how it is configured in z/VM.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dasd_device_is_ro</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ccw_dev_id</span> <span class="n">dev_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">diag210</span> <span class="n">diag_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">MACHINE_IS_VM</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ccw_device_get_id</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_id</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">diag_data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">diag_data</span><span class="p">));</span>
	<span class="n">diag_data</span><span class="p">.</span><span class="n">vrdcdvno</span> <span class="o">=</span> <span class="n">dev_id</span><span class="p">.</span><span class="n">devno</span><span class="p">;</span>
	<span class="n">diag_data</span><span class="p">.</span><span class="n">vrdclen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">diag_data</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">diag210</span><span class="p">(</span><span class="o">&amp;</span><span class="n">diag_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">rc</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">diag_data</span><span class="p">.</span><span class="n">vrdcvfla</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">DBF_EVENT</span><span class="p">(</span><span class="n">DBF_WARNING</span><span class="p">,</span> <span class="s">&quot;diag210 failed for dev=%04x with rc=%d&quot;</span><span class="p">,</span>
			  <span class="n">dev_id</span><span class="p">.</span><span class="n">devno</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">dasd_device_is_ro</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dasd_generic_auto_online</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">async_cookie_t</span> <span class="n">cookie</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ccw_device</span> <span class="o">*</span><span class="n">cdev</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">ccw_device_set_online</span><span class="p">(</span><span class="n">cdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;%s: Setting the DASD online failed with rc=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">dev_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">),</span> <span class="n">ret</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Initial attempt at a probe function. this can be simplified once</span>
<span class="cm"> * the other detection code is gone.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dasd_generic_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">ccw_device</span> <span class="o">*</span><span class="n">cdev</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">dasd_discipline</span> <span class="o">*</span><span class="n">discipline</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">dasd_add_sysfs_files</span><span class="p">(</span><span class="n">cdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DBF_EVENT_DEVID</span><span class="p">(</span><span class="n">DBF_WARNING</span><span class="p">,</span> <span class="n">cdev</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span>
				<span class="s">&quot;dasd_generic_probe: could not add &quot;</span>
				<span class="s">&quot;sysfs entries&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cdev</span><span class="o">-&gt;</span><span class="n">handler</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dasd_int_handler</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Automatically online either all dasd devices (dasd_autodetect)</span>
<span class="cm">	 * or all devices specified with dasd= parameters during</span>
<span class="cm">	 * initial probe.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">dasd_get_feature</span><span class="p">(</span><span class="n">cdev</span><span class="p">,</span> <span class="n">DASD_FEATURE_INITIAL_ONLINE</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">dasd_autodetect</span> <span class="o">&amp;&amp;</span> <span class="n">dasd_busid_known</span><span class="p">(</span><span class="n">dev_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">async_schedule</span><span class="p">(</span><span class="n">dasd_generic_auto_online</span><span class="p">,</span> <span class="n">cdev</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This will one day be called from a global not_oper handler.</span>
<span class="cm"> * It is also used by driver_unregister during module unload.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">dasd_generic_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">ccw_device</span> <span class="o">*</span><span class="n">cdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dasd_block</span> <span class="o">*</span><span class="n">block</span><span class="p">;</span>

	<span class="n">cdev</span><span class="o">-&gt;</span><span class="n">handler</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">dasd_remove_sysfs_files</span><span class="p">(</span><span class="n">cdev</span><span class="p">);</span>
	<span class="n">device</span> <span class="o">=</span> <span class="n">dasd_device_from_cdev</span><span class="p">(</span><span class="n">cdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">device</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">DASD_FLAG_OFFLINE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Already doing offline processing */</span>
		<span class="n">dasd_put_device</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * This device is removed unconditionally. Set offline</span>
<span class="cm">	 * flag to prevent dasd_open from opening it while it is</span>
<span class="cm">	 * no quite down yet.</span>
<span class="cm">	 */</span>
	<span class="n">dasd_set_target_state</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">DASD_STATE_NEW</span><span class="p">);</span>
	<span class="cm">/* dasd_delete_device destroys the device reference. */</span>
	<span class="n">block</span> <span class="o">=</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">;</span>
	<span class="n">dasd_delete_device</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * life cycle of block is bound to device, so delete it after</span>
<span class="cm">	 * device was safely removed</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">block</span><span class="p">)</span>
		<span class="n">dasd_free_block</span><span class="p">(</span><span class="n">block</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Activate a device. This is called from dasd_{eckd,fba}_probe() when either</span>
<span class="cm"> * the device is detected for the first time and is supposed to be used</span>
<span class="cm"> * or the user has started activation through sysfs.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dasd_generic_set_online</span><span class="p">(</span><span class="k">struct</span> <span class="n">ccw_device</span> <span class="o">*</span><span class="n">cdev</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">dasd_discipline</span> <span class="o">*</span><span class="n">base_discipline</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dasd_discipline</span> <span class="o">*</span><span class="n">discipline</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* first online clears initial online feature flag */</span>
	<span class="n">dasd_set_feature</span><span class="p">(</span><span class="n">cdev</span><span class="p">,</span> <span class="n">DASD_FEATURE_INITIAL_ONLINE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">device</span> <span class="o">=</span> <span class="n">dasd_create_device</span><span class="p">(</span><span class="n">cdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">device</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>

	<span class="n">discipline</span> <span class="o">=</span> <span class="n">base_discipline</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">DASD_FEATURE_USEDIAG</span><span class="p">)</span> <span class="p">{</span>
	  	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dasd_diag_discipline_pointer</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;%s Setting the DASD online failed because &quot;</span>
				   <span class="s">&quot;of missing DIAG discipline</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">dev_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">));</span>
			<span class="n">dasd_delete_device</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">discipline</span> <span class="o">=</span> <span class="n">dasd_diag_discipline_pointer</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">try_module_get</span><span class="p">(</span><span class="n">base_discipline</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dasd_delete_device</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">try_module_get</span><span class="p">(</span><span class="n">discipline</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">module_put</span><span class="p">(</span><span class="n">base_discipline</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">);</span>
		<span class="n">dasd_delete_device</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">device</span><span class="o">-&gt;</span><span class="n">base_discipline</span> <span class="o">=</span> <span class="n">base_discipline</span><span class="p">;</span>
	<span class="n">device</span><span class="o">-&gt;</span><span class="n">discipline</span> <span class="o">=</span> <span class="n">discipline</span><span class="p">;</span>

	<span class="cm">/* check_device will allocate block device if necessary */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">discipline</span><span class="o">-&gt;</span><span class="n">check_device</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;%s Setting the DASD online with discipline %s &quot;</span>
			   <span class="s">&quot;failed with rc=%i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">dev_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">),</span> <span class="n">discipline</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="n">module_put</span><span class="p">(</span><span class="n">discipline</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">);</span>
		<span class="n">module_put</span><span class="p">(</span><span class="n">base_discipline</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">);</span>
		<span class="n">dasd_delete_device</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dasd_set_target_state</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">DASD_STATE_ONLINE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&lt;=</span> <span class="n">DASD_STATE_KNOWN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;%s Setting the DASD online failed because of a &quot;</span>
			   <span class="s">&quot;missing discipline</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">));</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="n">dasd_set_target_state</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">DASD_STATE_NEW</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">)</span>
			<span class="n">dasd_free_block</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">);</span>
		<span class="n">dasd_delete_device</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;dasd_generic device %s found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">dev_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">));</span>

	<span class="n">wait_event</span><span class="p">(</span><span class="n">dasd_init_waitq</span><span class="p">,</span> <span class="n">_wait_for_device</span><span class="p">(</span><span class="n">device</span><span class="p">));</span>

	<span class="n">dasd_put_device</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">dasd_generic_set_offline</span><span class="p">(</span><span class="k">struct</span> <span class="n">ccw_device</span> <span class="o">*</span><span class="n">cdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dasd_block</span> <span class="o">*</span><span class="n">block</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">max_count</span><span class="p">,</span> <span class="n">open_count</span><span class="p">;</span>

	<span class="n">device</span> <span class="o">=</span> <span class="n">dasd_device_from_cdev</span><span class="p">(</span><span class="n">cdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">device</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">DASD_FLAG_OFFLINE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Already doing offline processing */</span>
		<span class="n">dasd_put_device</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * We must make sure that this device is currently not in use.</span>
<span class="cm">	 * The open_count is increased for every opener, that includes</span>
<span class="cm">	 * the blkdev_get in dasd_scan_partitions. We are only interested</span>
<span class="cm">	 * in the other openers.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">max_count</span> <span class="o">=</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">bdev</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">open_count</span> <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">open_count</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">open_count</span> <span class="o">&gt;</span> <span class="n">max_count</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">open_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;%s: The DASD cannot be set offline &quot;</span>
					   <span class="s">&quot;with open count %i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					   <span class="n">dev_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">),</span> <span class="n">open_count</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;%s: The DASD cannot be set offline &quot;</span>
					   <span class="s">&quot;while it is in use</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					   <span class="n">dev_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">));</span>
			<span class="n">clear_bit</span><span class="p">(</span><span class="n">DASD_FLAG_OFFLINE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
			<span class="n">dasd_put_device</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">dasd_set_target_state</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">DASD_STATE_NEW</span><span class="p">);</span>
	<span class="cm">/* dasd_delete_device destroys the device reference. */</span>
	<span class="n">block</span> <span class="o">=</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">;</span>
	<span class="n">dasd_delete_device</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * life cycle of block is bound to device, so delete it after</span>
<span class="cm">	 * device was safely removed</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">block</span><span class="p">)</span>
		<span class="n">dasd_free_block</span><span class="p">(</span><span class="n">block</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">dasd_generic_last_path_gone</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dasd_ccw_req</span> <span class="o">*</span><span class="n">cqr</span><span class="p">;</span>

	<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;No operational channel path is left &quot;</span>
		 <span class="s">&quot;for the device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">DBF_DEV_EVENT</span><span class="p">(</span><span class="n">DBF_WARNING</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="s">&quot;last path gone&quot;</span><span class="p">);</span>
	<span class="cm">/* First of all call extended error reporting. */</span>
	<span class="n">dasd_eer_write</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">DASD_EER_NOPATH</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&lt;</span> <span class="n">DASD_STATE_BASIC</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* Device is active. We want to keep it. */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">cqr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">ccw_queue</span><span class="p">,</span> <span class="n">devlist</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="n">DASD_CQR_IN_IO</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="n">DASD_CQR_CLEAR_PENDING</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">DASD_CQR_QUEUED</span><span class="p">;</span>
			<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">retries</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="n">dasd_device_set_stop_bits</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">DASD_STOPPED_DC_WAIT</span><span class="p">);</span>
	<span class="n">dasd_device_clear_timer</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
	<span class="n">dasd_schedule_device_bh</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">dasd_generic_last_path_gone</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">dasd_generic_path_operational</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;A channel path to the device has become &quot;</span>
		 <span class="s">&quot;operational</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">DBF_DEV_EVENT</span><span class="p">(</span><span class="n">DBF_WARNING</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="s">&quot;path operational&quot;</span><span class="p">);</span>
	<span class="n">dasd_device_remove_stop_bits</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">DASD_STOPPED_DC_WAIT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">stopped</span> <span class="o">&amp;</span> <span class="n">DASD_UNRESUMED_PM</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dasd_device_remove_stop_bits</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">DASD_UNRESUMED_PM</span><span class="p">);</span>
		<span class="n">dasd_restore_device</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dasd_schedule_device_bh</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">)</span>
		<span class="n">dasd_schedule_block_bh</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">dasd_generic_path_operational</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">dasd_generic_notify</span><span class="p">(</span><span class="k">struct</span> <span class="n">ccw_device</span> <span class="o">*</span><span class="n">cdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">device</span> <span class="o">=</span> <span class="n">dasd_device_from_cdev_locked</span><span class="p">(</span><span class="n">cdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">device</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CIO_GONE</span>:
	<span class="k">case</span> <span class="n">CIO_BOXED</span>:
	<span class="k">case</span> <span class="n">CIO_NO_PATH</span>:
		<span class="n">device</span><span class="o">-&gt;</span><span class="n">path_data</span><span class="p">.</span><span class="n">opm</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">device</span><span class="o">-&gt;</span><span class="n">path_data</span><span class="p">.</span><span class="n">ppm</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">device</span><span class="o">-&gt;</span><span class="n">path_data</span><span class="p">.</span><span class="n">npm</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">dasd_generic_last_path_gone</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CIO_OPER</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">path_data</span><span class="p">.</span><span class="n">opm</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">dasd_generic_path_operational</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dasd_put_device</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">dasd_generic_path_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">ccw_device</span> <span class="o">*</span><span class="n">cdev</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">path_event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">chp</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">oldopm</span><span class="p">,</span> <span class="n">eventlpm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">;</span>

	<span class="n">device</span> <span class="o">=</span> <span class="n">dasd_device_from_cdev_locked</span><span class="p">(</span><span class="n">cdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">device</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">chp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">chp</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">chp</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">eventlpm</span> <span class="o">=</span> <span class="mh">0x80</span> <span class="o">&gt;&gt;</span> <span class="n">chp</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">path_event</span><span class="p">[</span><span class="n">chp</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">PE_PATH_GONE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">oldopm</span> <span class="o">=</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">path_data</span><span class="p">.</span><span class="n">opm</span><span class="p">;</span>
			<span class="n">device</span><span class="o">-&gt;</span><span class="n">path_data</span><span class="p">.</span><span class="n">opm</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">eventlpm</span><span class="p">;</span>
			<span class="n">device</span><span class="o">-&gt;</span><span class="n">path_data</span><span class="p">.</span><span class="n">ppm</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">eventlpm</span><span class="p">;</span>
			<span class="n">device</span><span class="o">-&gt;</span><span class="n">path_data</span><span class="p">.</span><span class="n">npm</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">eventlpm</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">oldopm</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">path_data</span><span class="p">.</span><span class="n">opm</span><span class="p">)</span>
				<span class="n">dasd_generic_last_path_gone</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">path_event</span><span class="p">[</span><span class="n">chp</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">PE_PATH_AVAILABLE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">device</span><span class="o">-&gt;</span><span class="n">path_data</span><span class="p">.</span><span class="n">opm</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">eventlpm</span><span class="p">;</span>
			<span class="n">device</span><span class="o">-&gt;</span><span class="n">path_data</span><span class="p">.</span><span class="n">ppm</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">eventlpm</span><span class="p">;</span>
			<span class="n">device</span><span class="o">-&gt;</span><span class="n">path_data</span><span class="p">.</span><span class="n">npm</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">eventlpm</span><span class="p">;</span>
			<span class="n">device</span><span class="o">-&gt;</span><span class="n">path_data</span><span class="p">.</span><span class="n">tbvpm</span> <span class="o">|=</span> <span class="n">eventlpm</span><span class="p">;</span>
			<span class="n">dasd_schedule_device_bh</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">path_event</span><span class="p">[</span><span class="n">chp</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">PE_PATHGROUP_ESTABLISHED</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DBF_DEV_EVENT</span><span class="p">(</span><span class="n">DBF_WARNING</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span>
				      <span class="s">&quot;Pathgroup re-established</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">discipline</span><span class="o">-&gt;</span><span class="n">kick_validate</span><span class="p">)</span>
				<span class="n">device</span><span class="o">-&gt;</span><span class="n">discipline</span><span class="o">-&gt;</span><span class="n">kick_validate</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">dasd_put_device</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">dasd_generic_path_event</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">dasd_generic_verify_path</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">,</span> <span class="n">__u8</span> <span class="n">lpm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">path_data</span><span class="p">.</span><span class="n">opm</span> <span class="o">&amp;&amp;</span> <span class="n">lpm</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">device</span><span class="o">-&gt;</span><span class="n">path_data</span><span class="p">.</span><span class="n">opm</span> <span class="o">=</span> <span class="n">lpm</span><span class="p">;</span>
		<span class="n">dasd_generic_path_operational</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">device</span><span class="o">-&gt;</span><span class="n">path_data</span><span class="p">.</span><span class="n">opm</span> <span class="o">|=</span> <span class="n">lpm</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">dasd_generic_verify_path</span><span class="p">);</span>


<span class="kt">int</span> <span class="nf">dasd_generic_pm_freeze</span><span class="p">(</span><span class="k">struct</span> <span class="n">ccw_device</span> <span class="o">*</span><span class="n">cdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dasd_ccw_req</span> <span class="o">*</span><span class="n">cqr</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">freeze_queue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span> <span class="o">=</span> <span class="n">dasd_device_from_cdev</span><span class="p">(</span><span class="n">cdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">device</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>

	<span class="cm">/* mark device as suspended */</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">DASD_FLAG_SUSPENDED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">discipline</span><span class="o">-&gt;</span><span class="n">freeze</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">discipline</span><span class="o">-&gt;</span><span class="n">freeze</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>

	<span class="cm">/* disallow new I/O  */</span>
	<span class="n">dasd_device_set_stop_bits</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">DASD_STOPPED_PM</span><span class="p">);</span>
	<span class="cm">/* clear active requests */</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">freeze_queue</span><span class="p">);</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">get_ccwdev_lock</span><span class="p">(</span><span class="n">cdev</span><span class="p">));</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">cqr</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">ccw_queue</span><span class="p">,</span> <span class="n">devlist</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Check status and move request to flush_queue */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="n">DASD_CQR_IN_IO</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">discipline</span><span class="o">-&gt;</span><span class="n">term_IO</span><span class="p">(</span><span class="n">cqr</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* unable to terminate requeust */</span>
				<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="s">&quot;Unable to terminate request %p &quot;</span>
					<span class="s">&quot;on suspend</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cqr</span><span class="p">);</span>
				<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">get_ccwdev_lock</span><span class="p">(</span><span class="n">cdev</span><span class="p">));</span>
				<span class="n">dasd_put_device</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">devlist</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">freeze_queue</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">get_ccwdev_lock</span><span class="p">(</span><span class="n">cdev</span><span class="p">));</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">cqr</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">freeze_queue</span><span class="p">,</span> <span class="n">devlist</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">wait_event</span><span class="p">(</span><span class="n">dasd_flush_wq</span><span class="p">,</span>
			   <span class="p">(</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">!=</span> <span class="n">DASD_CQR_CLEAR_PENDING</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="n">DASD_CQR_CLEARED</span><span class="p">)</span>
			<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">DASD_CQR_QUEUED</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* move freeze_queue to start of the ccw_queue */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">get_ccwdev_lock</span><span class="p">(</span><span class="n">cdev</span><span class="p">));</span>
	<span class="n">list_splice_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">freeze_queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">ccw_queue</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">get_ccwdev_lock</span><span class="p">(</span><span class="n">cdev</span><span class="p">));</span>

	<span class="n">dasd_put_device</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">dasd_generic_pm_freeze</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">dasd_generic_restore_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">ccw_device</span> <span class="o">*</span><span class="n">cdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span> <span class="o">=</span> <span class="n">dasd_device_from_cdev</span><span class="p">(</span><span class="n">cdev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">device</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>

	<span class="cm">/* allow new IO again */</span>
	<span class="n">dasd_device_remove_stop_bits</span><span class="p">(</span><span class="n">device</span><span class="p">,</span>
				     <span class="p">(</span><span class="n">DASD_STOPPED_PM</span> <span class="o">|</span> <span class="n">DASD_UNRESUMED_PM</span><span class="p">));</span>

	<span class="n">dasd_schedule_device_bh</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * call discipline restore function</span>
<span class="cm">	 * if device is stopped do nothing e.g. for disconnected devices</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">discipline</span><span class="o">-&gt;</span><span class="n">restore</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">stopped</span><span class="p">))</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">discipline</span><span class="o">-&gt;</span><span class="n">restore</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">||</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">stopped</span><span class="p">)</span>
		<span class="cm">/*</span>
<span class="cm">		 * if the resume failed for the DASD we put it in</span>
<span class="cm">		 * an UNRESUMED stop state</span>
<span class="cm">		 */</span>
		<span class="n">device</span><span class="o">-&gt;</span><span class="n">stopped</span> <span class="o">|=</span> <span class="n">DASD_UNRESUMED_PM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">)</span>
		<span class="n">dasd_schedule_block_bh</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">);</span>

	<span class="n">clear_bit</span><span class="p">(</span><span class="n">DASD_FLAG_SUSPENDED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">dasd_put_device</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">dasd_generic_restore_device</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dasd_ccw_req</span> <span class="o">*</span><span class="nf">dasd_generic_build_rdc</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">,</span>
						   <span class="kt">void</span> <span class="o">*</span><span class="n">rdc_buffer</span><span class="p">,</span>
						   <span class="kt">int</span> <span class="n">rdc_buffer_size</span><span class="p">,</span>
						   <span class="kt">int</span> <span class="n">magic</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dasd_ccw_req</span> <span class="o">*</span><span class="n">cqr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ccw1</span> <span class="o">*</span><span class="n">ccw</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">idaw</span><span class="p">;</span>

	<span class="n">cqr</span> <span class="o">=</span> <span class="n">dasd_smalloc_request</span><span class="p">(</span><span class="n">magic</span><span class="p">,</span> <span class="mi">1</span> <span class="cm">/* RDC */</span><span class="p">,</span> <span class="n">rdc_buffer_size</span><span class="p">,</span> <span class="n">device</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">cqr</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* internal error 13 - Allocating the RDC request failed*/</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			 <span class="s">&quot;An error occurred in the DASD device driver, &quot;</span>
			 <span class="s">&quot;reason=%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;13&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">cqr</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ccw</span> <span class="o">=</span> <span class="n">cqr</span><span class="o">-&gt;</span><span class="n">cpaddr</span><span class="p">;</span>
	<span class="n">ccw</span><span class="o">-&gt;</span><span class="n">cmd_code</span> <span class="o">=</span> <span class="n">CCW_CMD_RDC</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">idal_is_needed</span><span class="p">(</span><span class="n">rdc_buffer</span><span class="p">,</span> <span class="n">rdc_buffer_size</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">idaw</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">cqr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
		<span class="n">ccw</span><span class="o">-&gt;</span><span class="n">cda</span> <span class="o">=</span> <span class="p">(</span><span class="n">__u32</span><span class="p">)(</span><span class="n">addr_t</span><span class="p">)</span> <span class="n">idaw</span><span class="p">;</span>
		<span class="n">ccw</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">CCW_FLAG_IDA</span><span class="p">;</span>
		<span class="n">idaw</span> <span class="o">=</span> <span class="n">idal_create_words</span><span class="p">(</span><span class="n">idaw</span><span class="p">,</span> <span class="n">rdc_buffer</span><span class="p">,</span> <span class="n">rdc_buffer_size</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ccw</span><span class="o">-&gt;</span><span class="n">cda</span> <span class="o">=</span> <span class="p">(</span><span class="n">__u32</span><span class="p">)(</span><span class="n">addr_t</span><span class="p">)</span> <span class="n">rdc_buffer</span><span class="p">;</span>
		<span class="n">ccw</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ccw</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="n">rdc_buffer_size</span><span class="p">;</span>
	<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">startdev</span> <span class="o">=</span> <span class="n">device</span><span class="p">;</span>
	<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">memdev</span> <span class="o">=</span> <span class="n">device</span><span class="p">;</span>
	<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">expires</span> <span class="o">=</span> <span class="mi">10</span><span class="o">*</span><span class="n">HZ</span><span class="p">;</span>
	<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">retries</span> <span class="o">=</span> <span class="mi">256</span><span class="p">;</span>
	<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">buildclk</span> <span class="o">=</span> <span class="n">get_clock</span><span class="p">();</span>
	<span class="n">cqr</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">DASD_CQR_FILLED</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">cqr</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">dasd_generic_read_dev_chars</span><span class="p">(</span><span class="k">struct</span> <span class="n">dasd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">,</span> <span class="kt">int</span> <span class="n">magic</span><span class="p">,</span>
				<span class="kt">void</span> <span class="o">*</span><span class="n">rdc_buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rdc_buffer_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dasd_ccw_req</span> <span class="o">*</span><span class="n">cqr</span><span class="p">;</span>

	<span class="n">cqr</span> <span class="o">=</span> <span class="n">dasd_generic_build_rdc</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">rdc_buffer</span><span class="p">,</span> <span class="n">rdc_buffer_size</span><span class="p">,</span>
				     <span class="n">magic</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">cqr</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">cqr</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">dasd_sleep_on</span><span class="p">(</span><span class="n">cqr</span><span class="p">);</span>
	<span class="n">dasd_sfree_request</span><span class="p">(</span><span class="n">cqr</span><span class="p">,</span> <span class="n">cqr</span><span class="o">-&gt;</span><span class="n">memdev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">dasd_generic_read_dev_chars</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *   In command mode and transport mode we need to look for sense</span>
<span class="cm"> *   data in different places. The sense data itself is allways</span>
<span class="cm"> *   an array of 32 bytes, so we can unify the sense data access</span>
<span class="cm"> *   for both modes.</span>
<span class="cm"> */</span>
<span class="kt">char</span> <span class="o">*</span><span class="nf">dasd_get_sense</span><span class="p">(</span><span class="k">struct</span> <span class="n">irb</span> <span class="o">*</span><span class="n">irb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tsb</span> <span class="o">*</span><span class="n">tsb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">sense</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">scsw_is_tm</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irb</span><span class="o">-&gt;</span><span class="n">scsw</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">irb</span><span class="o">-&gt;</span><span class="n">scsw</span><span class="p">.</span><span class="n">tm</span><span class="p">.</span><span class="n">fcxs</span> <span class="o">==</span> <span class="mh">0x01</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">irb</span><span class="o">-&gt;</span><span class="n">scsw</span><span class="p">.</span><span class="n">tm</span><span class="p">.</span><span class="n">tcw</span><span class="p">)</span>
			<span class="n">tsb</span> <span class="o">=</span> <span class="n">tcw_get_tsb</span><span class="p">((</span><span class="k">struct</span> <span class="n">tcw</span> <span class="o">*</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span>
					  <span class="n">irb</span><span class="o">-&gt;</span><span class="n">scsw</span><span class="p">.</span><span class="n">tm</span><span class="p">.</span><span class="n">tcw</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tsb</span> <span class="o">&amp;&amp;</span> <span class="n">tsb</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">==</span> <span class="mi">64</span> <span class="o">&amp;&amp;</span> <span class="n">tsb</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">tsb</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="mh">0x07</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="mi">1</span>:	<span class="cm">/* tsa_iostat */</span>
				<span class="n">sense</span> <span class="o">=</span> <span class="n">tsb</span><span class="o">-&gt;</span><span class="n">tsa</span><span class="p">.</span><span class="n">iostat</span><span class="p">.</span><span class="n">sense</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="mi">2</span>: <span class="cm">/* tsa_ddpc */</span>
				<span class="n">sense</span> <span class="o">=</span> <span class="n">tsb</span><span class="o">-&gt;</span><span class="n">tsa</span><span class="p">.</span><span class="n">ddpc</span><span class="p">.</span><span class="n">sense</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="nl">default:</span>
				<span class="cm">/* currently we don&#39;t use interrogate data */</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">irb</span><span class="o">-&gt;</span><span class="n">esw</span><span class="p">.</span><span class="n">esw0</span><span class="p">.</span><span class="n">erw</span><span class="p">.</span><span class="n">cons</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sense</span> <span class="o">=</span> <span class="n">irb</span><span class="o">-&gt;</span><span class="n">ecw</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">sense</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">dasd_get_sense</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">dasd_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dasd_init_waitq</span><span class="p">);</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dasd_flush_wq</span><span class="p">);</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">generic_waitq</span><span class="p">);</span>

	<span class="cm">/* register &#39;common&#39; DASD debug area, used for all DBF_XXX calls */</span>
	<span class="n">dasd_debug_area</span> <span class="o">=</span> <span class="n">debug_register</span><span class="p">(</span><span class="s">&quot;dasd&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">8</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dasd_debug_area</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">debug_register_view</span><span class="p">(</span><span class="n">dasd_debug_area</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">debug_sprintf_view</span><span class="p">);</span>
	<span class="n">debug_set_level</span><span class="p">(</span><span class="n">dasd_debug_area</span><span class="p">,</span> <span class="n">DBF_WARNING</span><span class="p">);</span>

	<span class="n">DBF_EVENT</span><span class="p">(</span><span class="n">DBF_EMERG</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="s">&quot;debug area created&quot;</span><span class="p">);</span>

	<span class="n">dasd_diag_discipline_pointer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">dasd_statistics_createroot</span><span class="p">();</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">dasd_devmap_init</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">dasd_gendisk_init</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">dasd_parse</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">dasd_eer_init</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_PROC_FS</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">dasd_proc_init</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">failed:</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;The DASD device driver could not be initialized</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">dasd_exit</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">dasd_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">dasd_exit</span><span class="p">);</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dasd_debug_area</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dasd_diag_discipline_pointer</span><span class="p">);</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dasd_add_request_head</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dasd_add_request_tail</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dasd_cancel_req</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dasd_device_clear_timer</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dasd_block_clear_timer</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dasd_enable_device</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dasd_int_handler</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dasd_kfree_request</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dasd_kick_device</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dasd_kmalloc_request</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dasd_schedule_device_bh</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dasd_schedule_block_bh</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dasd_set_target_state</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dasd_device_set_timer</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dasd_block_set_timer</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dasd_sfree_request</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dasd_sleep_on</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dasd_sleep_on_immediatly</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dasd_sleep_on_interruptible</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dasd_smalloc_request</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dasd_start_IO</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dasd_term_IO</span><span class="p">);</span>

<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">dasd_generic_probe</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">dasd_generic_remove</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">dasd_generic_notify</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">dasd_generic_set_online</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">dasd_generic_set_offline</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">dasd_generic_handle_state_change</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">dasd_flush_device_queue</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">dasd_alloc_block</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">dasd_free_block</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
