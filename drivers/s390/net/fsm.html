<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › s390 › net › fsm.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>fsm.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _FSM_H_</span>
<span class="cp">#define _FSM_H_</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;linux/time.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/atomic.h&gt;</span>

<span class="cm">/**</span>
<span class="cm"> * Define this to get debugging messages.</span>
<span class="cm"> */</span>
<span class="cp">#define FSM_DEBUG         0</span>

<span class="cm">/**</span>
<span class="cm"> * Define this to get debugging massages for</span>
<span class="cm"> * timer handling.</span>
<span class="cm"> */</span>
<span class="cp">#define FSM_TIMER_DEBUG   0</span>

<span class="cm">/**</span>
<span class="cm"> * Define these to record a history of</span>
<span class="cm"> * Events/Statechanges and print it if a</span>
<span class="cm"> * action_function is not found.</span>
<span class="cm"> */</span>
<span class="cp">#define FSM_DEBUG_HISTORY 0</span>
<span class="cp">#define FSM_HISTORY_SIZE  40</span>

<span class="k">struct</span> <span class="n">fsm_instance_t</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * Definition of an action function, called by a FSM</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">fsm_function_t</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fsm_instance_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Internal jump table for a FSM</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">fsm_function_t</span> <span class="o">*</span><span class="n">jumpmatrix</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr_events</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr_states</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">event_names</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">state_names</span><span class="p">;</span>
<span class="p">}</span> <span class="n">fsm</span><span class="p">;</span>

<span class="cp">#if FSM_DEBUG_HISTORY</span>
<span class="cm">/**</span>
<span class="cm"> * Element of State/Event history used for debugging.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">state</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">event</span><span class="p">;</span>
<span class="p">}</span> <span class="n">fsm_history</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * Representation of a FSM</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">fsm_instance_t</span> <span class="p">{</span>
	<span class="n">fsm</span> <span class="o">*</span><span class="n">f</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">state</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">userdata</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">userint</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span> <span class="n">wait_q</span><span class="p">;</span>
<span class="cp">#if FSM_DEBUG_HISTORY</span>
	<span class="kt">int</span>         <span class="n">history_index</span><span class="p">;</span>
	<span class="kt">int</span>         <span class="n">history_size</span><span class="p">;</span>
	<span class="n">fsm_history</span> <span class="n">history</span><span class="p">[</span><span class="n">FSM_HISTORY_SIZE</span><span class="p">];</span>
<span class="cp">#endif</span>
<span class="p">}</span> <span class="n">fsm_instance</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * Description of a state-event combination</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">cond_state</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cond_event</span><span class="p">;</span>
	<span class="n">fsm_function_t</span> <span class="n">function</span><span class="p">;</span>
<span class="p">}</span> <span class="n">fsm_node</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * Description of a FSM Timer.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">fsm_instance</span> <span class="o">*</span><span class="n">fi</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">tl</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">expire_event</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">event_arg</span><span class="p">;</span>
<span class="p">}</span> <span class="n">fsm_timer</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * Creates an FSM</span>
<span class="cm"> *</span>
<span class="cm"> * @param name        Name of this instance for logging purposes.</span>
<span class="cm"> * @param state_names An array of names for all states for logging purposes.</span>
<span class="cm"> * @param event_names An array of names for all events for logging purposes.</span>
<span class="cm"> * @param nr_states   Number of states for this instance.</span>
<span class="cm"> * @param nr_events   Number of events for this instance.</span>
<span class="cm"> * @param tmpl        An array of fsm_nodes, describing this FSM.</span>
<span class="cm"> * @param tmpl_len    Length of the describing array.</span>
<span class="cm"> * @param order       Parameter for allocation of the FSM data structs.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="n">fsm_instance</span> <span class="o">*</span>
<span class="n">init_fsm</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">state_names</span><span class="p">,</span>
	 <span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">event_names</span><span class="p">,</span>
	 <span class="kt">int</span> <span class="n">nr_states</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nr_events</span><span class="p">,</span> <span class="k">const</span> <span class="n">fsm_node</span> <span class="o">*</span><span class="n">tmpl</span><span class="p">,</span>
	 <span class="kt">int</span> <span class="n">tmpl_len</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">order</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Releases an FSM</span>
<span class="cm"> *</span>
<span class="cm"> * @param fi Pointer to an FSM, previously created with init_fsm.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">kfree_fsm</span><span class="p">(</span><span class="n">fsm_instance</span> <span class="o">*</span><span class="n">fi</span><span class="p">);</span>

<span class="cp">#if FSM_DEBUG_HISTORY</span>
<span class="k">extern</span> <span class="kt">void</span>
<span class="n">fsm_print_history</span><span class="p">(</span><span class="n">fsm_instance</span> <span class="o">*</span><span class="n">fi</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span>
<span class="n">fsm_record_history</span><span class="p">(</span><span class="n">fsm_instance</span> <span class="o">*</span><span class="n">fi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">state</span><span class="p">,</span> <span class="kt">int</span> <span class="n">event</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * Emits an event to a FSM.</span>
<span class="cm"> * If an action function is defined for the current state/event combination,</span>
<span class="cm"> * this function is called.</span>
<span class="cm"> *</span>
<span class="cm"> * @param fi    Pointer to FSM which should receive the event.</span>
<span class="cm"> * @param event The event do be delivered.</span>
<span class="cm"> * @param arg   A generic argument, handed to the action function.</span>
<span class="cm"> *</span>
<span class="cm"> * @return      0  on success,</span>
<span class="cm"> *              1  if current state or event is out of range</span>
<span class="cm"> *              !0 if state and event in range, but no action defined.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">fsm_event</span><span class="p">(</span><span class="n">fsm_instance</span> <span class="o">*</span><span class="n">fi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">event</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">fsm_function_t</span> <span class="n">r</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">state</span> <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fi</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">state</span> <span class="o">&gt;=</span> <span class="n">fi</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">nr_states</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">event</span> <span class="o">&gt;=</span> <span class="n">fi</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">nr_events</span><span class="p">)</span>       <span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;fsm(%s): Invalid state st(%ld/%ld) ev(%d/%ld)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">fi</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">state</span><span class="p">,(</span><span class="kt">long</span><span class="p">)</span><span class="n">fi</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">nr_states</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">fi</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">nr_events</span><span class="p">);</span>
<span class="cp">#if FSM_DEBUG_HISTORY</span>
		<span class="n">fsm_print_history</span><span class="p">(</span><span class="n">fi</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">fi</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">jumpmatrix</span><span class="p">[</span><span class="n">fi</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">nr_states</span> <span class="o">*</span> <span class="n">event</span> <span class="o">+</span> <span class="n">state</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#if FSM_DEBUG</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;fsm(%s): state %s event %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">fi</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">fi</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">state_names</span><span class="p">[</span><span class="n">state</span><span class="p">],</span>
		       <span class="n">fi</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">event_names</span><span class="p">[</span><span class="n">event</span><span class="p">]);</span>
<span class="cp">#endif</span>
<span class="cp">#if FSM_DEBUG_HISTORY</span>
		<span class="n">fsm_record_history</span><span class="p">(</span><span class="n">fi</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="n">r</span><span class="p">(</span><span class="n">fi</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="cp">#if FSM_DEBUG || FSM_DEBUG_HISTORY</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;fsm(%s): no function for event %s in state %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">fi</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">fi</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">event_names</span><span class="p">[</span><span class="n">event</span><span class="p">],</span>
		       <span class="n">fi</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">state_names</span><span class="p">[</span><span class="n">state</span><span class="p">]);</span>
<span class="cp">#endif</span>
<span class="cp">#if FSM_DEBUG_HISTORY</span>
		<span class="n">fsm_print_history</span><span class="p">(</span><span class="n">fi</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="k">return</span> <span class="o">!</span><span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Modifies the state of an FSM.</span>
<span class="cm"> * This does &lt;em&gt;not&lt;/em&gt; trigger an event or calls an action function.</span>
<span class="cm"> *</span>
<span class="cm"> * @param fi    Pointer to FSM</span>
<span class="cm"> * @param state The new state for this FSM.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">fsm_newstate</span><span class="p">(</span><span class="n">fsm_instance</span> <span class="o">*</span><span class="n">fi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">newstate</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fi</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">,</span><span class="n">newstate</span><span class="p">);</span>
<span class="cp">#if FSM_DEBUG_HISTORY</span>
	<span class="n">fsm_record_history</span><span class="p">(</span><span class="n">fi</span><span class="p">,</span> <span class="n">newstate</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#if FSM_DEBUG</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;fsm(%s): New state %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fi</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
		<span class="n">fi</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">state_names</span><span class="p">[</span><span class="n">newstate</span><span class="p">]);</span>
<span class="cp">#endif</span>
	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fi</span><span class="o">-&gt;</span><span class="n">wait_q</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Retrieves the state of an FSM</span>
<span class="cm"> *</span>
<span class="cm"> * @param fi Pointer to FSM</span>
<span class="cm"> *</span>
<span class="cm"> * @return The current state of the FSM.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">fsm_getstate</span><span class="p">(</span><span class="n">fsm_instance</span> <span class="o">*</span><span class="n">fi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fi</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Retrieves the name of the state of an FSM</span>
<span class="cm"> *</span>
<span class="cm"> * @param fi Pointer to FSM</span>
<span class="cm"> *</span>
<span class="cm"> * @return The current state of the FSM in a human readable form.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fsm_getstate_str</span><span class="p">(</span><span class="n">fsm_instance</span> <span class="o">*</span><span class="n">fi</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Initializes a timer for an FSM.</span>
<span class="cm"> * This prepares an fsm_timer for usage with fsm_addtimer.</span>
<span class="cm"> *</span>
<span class="cm"> * @param fi    Pointer to FSM</span>
<span class="cm"> * @param timer The timer to be initialized.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">fsm_settimer</span><span class="p">(</span><span class="n">fsm_instance</span> <span class="o">*</span><span class="n">fi</span><span class="p">,</span> <span class="n">fsm_timer</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Clears a pending timer of an FSM instance.</span>
<span class="cm"> *</span>
<span class="cm"> * @param timer The timer to clear.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">fsm_deltimer</span><span class="p">(</span><span class="n">fsm_timer</span> <span class="o">*</span><span class="n">timer</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Adds and starts a timer to an FSM instance.</span>
<span class="cm"> *</span>
<span class="cm"> * @param timer    The timer to be added. The field fi of that timer</span>
<span class="cm"> *                 must have been set to point to the instance.</span>
<span class="cm"> * @param millisec Duration, after which the timer should expire.</span>
<span class="cm"> * @param event    Event, to trigger if timer expires.</span>
<span class="cm"> * @param arg      Generic argument, provided to expiry function.</span>
<span class="cm"> *</span>
<span class="cm"> * @return         0 on success, -1 if timer is already active.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">fsm_addtimer</span><span class="p">(</span><span class="n">fsm_timer</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">millisec</span><span class="p">,</span> <span class="kt">int</span> <span class="n">event</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Modifies a timer of an FSM.</span>
<span class="cm"> *</span>
<span class="cm"> * @param timer    The timer to modify.</span>
<span class="cm"> * @param millisec Duration, after which the timer should expire.</span>
<span class="cm"> * @param event    Event, to trigger if timer expires.</span>
<span class="cm"> * @param arg      Generic argument, provided to expiry function.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">fsm_modtimer</span><span class="p">(</span><span class="n">fsm_timer</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">millisec</span><span class="p">,</span> <span class="kt">int</span> <span class="n">event</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* _FSM_H_ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
