<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › s390 › cio › qdio.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>qdio.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * linux/drivers/s390/cio/qdio.h</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright 2000,2009 IBM Corp.</span>
<span class="cm"> * Author(s): Utz Bacher &lt;utz.bacher@de.ibm.com&gt;</span>
<span class="cm"> *	      Jan Glauber &lt;jang@linux.vnet.ibm.com&gt;</span>
<span class="cm"> */</span>
<span class="cp">#ifndef _CIO_QDIO_H</span>
<span class="cp">#define _CIO_QDIO_H</span>

<span class="cp">#include &lt;asm/page.h&gt;</span>
<span class="cp">#include &lt;asm/schid.h&gt;</span>
<span class="cp">#include &lt;asm/debug.h&gt;</span>
<span class="cp">#include &quot;chsc.h&quot;</span>

<span class="cp">#define QDIO_BUSY_BIT_PATIENCE		(100 &lt;&lt; 12)	</span><span class="cm">/* 100 microseconds */</span><span class="cp"></span>
<span class="cp">#define QDIO_BUSY_BIT_RETRY_DELAY	10		</span><span class="cm">/* 10 milliseconds */</span><span class="cp"></span>
<span class="cp">#define QDIO_BUSY_BIT_RETRIES		1000		</span><span class="cm">/* = 10s retry time */</span><span class="cp"></span>
<span class="cp">#define QDIO_INPUT_THRESHOLD		(500 &lt;&lt; 12)	</span><span class="cm">/* 500 microseconds */</span><span class="cp"></span>

<span class="k">enum</span> <span class="n">qdio_irq_states</span> <span class="p">{</span>
	<span class="n">QDIO_IRQ_STATE_INACTIVE</span><span class="p">,</span>
	<span class="n">QDIO_IRQ_STATE_ESTABLISHED</span><span class="p">,</span>
	<span class="n">QDIO_IRQ_STATE_ACTIVE</span><span class="p">,</span>
	<span class="n">QDIO_IRQ_STATE_STOPPED</span><span class="p">,</span>
	<span class="n">QDIO_IRQ_STATE_CLEANUP</span><span class="p">,</span>
	<span class="n">QDIO_IRQ_STATE_ERR</span><span class="p">,</span>
	<span class="n">NR_QDIO_IRQ_STATES</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* used as intparm in do_IO */</span>
<span class="cp">#define QDIO_DOING_ESTABLISH	1</span>
<span class="cp">#define QDIO_DOING_ACTIVATE	2</span>
<span class="cp">#define QDIO_DOING_CLEANUP	3</span>

<span class="cp">#define SLSB_STATE_NOT_INIT	0x0</span>
<span class="cp">#define SLSB_STATE_EMPTY	0x1</span>
<span class="cp">#define SLSB_STATE_PRIMED	0x2</span>
<span class="cp">#define SLSB_STATE_PENDING	0x3</span>
<span class="cp">#define SLSB_STATE_HALTED	0xe</span>
<span class="cp">#define SLSB_STATE_ERROR	0xf</span>
<span class="cp">#define SLSB_TYPE_INPUT		0x0</span>
<span class="cp">#define SLSB_TYPE_OUTPUT	0x20</span>
<span class="cp">#define SLSB_OWNER_PROG		0x80</span>
<span class="cp">#define SLSB_OWNER_CU		0x40</span>

<span class="cp">#define SLSB_P_INPUT_NOT_INIT	\</span>
<span class="cp">	(SLSB_OWNER_PROG | SLSB_TYPE_INPUT | SLSB_STATE_NOT_INIT)  </span><span class="cm">/* 0x80 */</span><span class="cp"></span>
<span class="cp">#define SLSB_P_INPUT_ACK	\</span>
<span class="cp">	(SLSB_OWNER_PROG | SLSB_TYPE_INPUT | SLSB_STATE_EMPTY)	   </span><span class="cm">/* 0x81 */</span><span class="cp"></span>
<span class="cp">#define SLSB_CU_INPUT_EMPTY	\</span>
<span class="cp">	(SLSB_OWNER_CU | SLSB_TYPE_INPUT | SLSB_STATE_EMPTY)	   </span><span class="cm">/* 0x41 */</span><span class="cp"></span>
<span class="cp">#define SLSB_P_INPUT_PRIMED	\</span>
<span class="cp">	(SLSB_OWNER_PROG | SLSB_TYPE_INPUT | SLSB_STATE_PRIMED)	   </span><span class="cm">/* 0x82 */</span><span class="cp"></span>
<span class="cp">#define SLSB_P_INPUT_HALTED	\</span>
<span class="cp">	(SLSB_OWNER_PROG | SLSB_TYPE_INPUT | SLSB_STATE_HALTED)	   </span><span class="cm">/* 0x8e */</span><span class="cp"></span>
<span class="cp">#define SLSB_P_INPUT_ERROR	\</span>
<span class="cp">	(SLSB_OWNER_PROG | SLSB_TYPE_INPUT | SLSB_STATE_ERROR)	   </span><span class="cm">/* 0x8f */</span><span class="cp"></span>
<span class="cp">#define SLSB_P_OUTPUT_NOT_INIT	\</span>
<span class="cp">	(SLSB_OWNER_PROG | SLSB_TYPE_OUTPUT | SLSB_STATE_NOT_INIT) </span><span class="cm">/* 0xa0 */</span><span class="cp"></span>
<span class="cp">#define SLSB_P_OUTPUT_EMPTY	\</span>
<span class="cp">	(SLSB_OWNER_PROG | SLSB_TYPE_OUTPUT | SLSB_STATE_EMPTY)	   </span><span class="cm">/* 0xa1 */</span><span class="cp"></span>
<span class="cp">#define SLSB_P_OUTPUT_PENDING \</span>
<span class="cp">	(SLSB_OWNER_PROG | SLSB_TYPE_OUTPUT | SLSB_STATE_PENDING)  </span><span class="cm">/* 0xa3 */</span><span class="cp"></span>
<span class="cp">#define SLSB_CU_OUTPUT_PRIMED	\</span>
<span class="cp">	(SLSB_OWNER_CU | SLSB_TYPE_OUTPUT | SLSB_STATE_PRIMED)	   </span><span class="cm">/* 0x62 */</span><span class="cp"></span>
<span class="cp">#define SLSB_P_OUTPUT_HALTED	\</span>
<span class="cp">	(SLSB_OWNER_PROG | SLSB_TYPE_OUTPUT | SLSB_STATE_HALTED)   </span><span class="cm">/* 0xae */</span><span class="cp"></span>
<span class="cp">#define SLSB_P_OUTPUT_ERROR	\</span>
<span class="cp">	(SLSB_OWNER_PROG | SLSB_TYPE_OUTPUT | SLSB_STATE_ERROR)	   </span><span class="cm">/* 0xaf */</span><span class="cp"></span>

<span class="cp">#define SLSB_ERROR_DURING_LOOKUP  0xff</span>

<span class="cm">/* additional CIWs returned by extended Sense-ID */</span>
<span class="cp">#define CIW_TYPE_EQUEUE			0x3 </span><span class="cm">/* establish QDIO queues */</span><span class="cp"></span>
<span class="cp">#define CIW_TYPE_AQUEUE			0x4 </span><span class="cm">/* activate QDIO queues */</span><span class="cp"></span>

<span class="cm">/* flags for st qdio sch data */</span>
<span class="cp">#define CHSC_FLAG_QDIO_CAPABILITY	0x80</span>
<span class="cp">#define CHSC_FLAG_VALIDITY		0x40</span>

<span class="cm">/* SIGA flags */</span>
<span class="cp">#define QDIO_SIGA_WRITE		0x00</span>
<span class="cp">#define QDIO_SIGA_READ		0x01</span>
<span class="cp">#define QDIO_SIGA_SYNC		0x02</span>
<span class="cp">#define QDIO_SIGA_WRITEQ	0x04</span>
<span class="cp">#define QDIO_SIGA_QEBSM_FLAG	0x80</span>

<span class="cp">#ifdef CONFIG_64BIT</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">do_sqbs</span><span class="p">(</span><span class="n">u64</span> <span class="n">token</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">state</span><span class="p">,</span> <span class="kt">int</span> <span class="n">queue</span><span class="p">,</span>
			  <span class="kt">int</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">register</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">_ccq</span> <span class="n">asm</span> <span class="p">(</span><span class="s">&quot;0&quot;</span><span class="p">)</span> <span class="o">=</span> <span class="o">*</span><span class="n">count</span><span class="p">;</span>
	<span class="k">register</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">_token</span> <span class="n">asm</span> <span class="p">(</span><span class="s">&quot;1&quot;</span><span class="p">)</span> <span class="o">=</span> <span class="n">token</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">_queuestart</span> <span class="o">=</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">queue</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">|</span> <span class="o">*</span><span class="n">start</span><span class="p">;</span>

	<span class="n">asm</span> <span class="k">volatile</span><span class="p">(</span>
		<span class="s">&quot;	.insn	rsy,0xeb000000008A,%1,0,0(%2)&quot;</span>
		<span class="o">:</span> <span class="s">&quot;+d&quot;</span> <span class="p">(</span><span class="n">_ccq</span><span class="p">),</span> <span class="s">&quot;+d&quot;</span> <span class="p">(</span><span class="n">_queuestart</span><span class="p">)</span>
		<span class="o">:</span> <span class="s">&quot;d&quot;</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">state</span><span class="p">),</span> <span class="s">&quot;d&quot;</span> <span class="p">(</span><span class="n">_token</span><span class="p">)</span>
		<span class="o">:</span> <span class="s">&quot;memory&quot;</span><span class="p">,</span> <span class="s">&quot;cc&quot;</span><span class="p">);</span>
	<span class="o">*</span><span class="n">count</span> <span class="o">=</span> <span class="n">_ccq</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="o">*</span><span class="n">start</span> <span class="o">=</span> <span class="n">_queuestart</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">_ccq</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">do_eqbs</span><span class="p">(</span><span class="n">u64</span> <span class="n">token</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span> <span class="kt">int</span> <span class="n">queue</span><span class="p">,</span>
			  <span class="kt">int</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">count</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ack</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">register</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">_ccq</span> <span class="n">asm</span> <span class="p">(</span><span class="s">&quot;0&quot;</span><span class="p">)</span> <span class="o">=</span> <span class="o">*</span><span class="n">count</span><span class="p">;</span>
	<span class="k">register</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">_token</span> <span class="n">asm</span> <span class="p">(</span><span class="s">&quot;1&quot;</span><span class="p">)</span> <span class="o">=</span> <span class="n">token</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">_queuestart</span> <span class="o">=</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">queue</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">|</span> <span class="o">*</span><span class="n">start</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">_state</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ack</span> <span class="o">&lt;&lt;</span> <span class="mi">63</span><span class="p">;</span>

	<span class="n">asm</span> <span class="k">volatile</span><span class="p">(</span>
		<span class="s">&quot;	.insn	rrf,0xB99c0000,%1,%2,0,0&quot;</span>
		<span class="o">:</span> <span class="s">&quot;+d&quot;</span> <span class="p">(</span><span class="n">_ccq</span><span class="p">),</span> <span class="s">&quot;+d&quot;</span> <span class="p">(</span><span class="n">_queuestart</span><span class="p">),</span> <span class="s">&quot;+d&quot;</span> <span class="p">(</span><span class="n">_state</span><span class="p">)</span>
		<span class="o">:</span> <span class="s">&quot;d&quot;</span> <span class="p">(</span><span class="n">_token</span><span class="p">)</span>
		<span class="o">:</span> <span class="s">&quot;memory&quot;</span><span class="p">,</span> <span class="s">&quot;cc&quot;</span><span class="p">);</span>
	<span class="o">*</span><span class="n">count</span> <span class="o">=</span> <span class="n">_ccq</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="o">*</span><span class="n">start</span> <span class="o">=</span> <span class="n">_queuestart</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">_state</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">_ccq</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">do_sqbs</span><span class="p">(</span><span class="n">u64</span> <span class="n">token</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">state</span><span class="p">,</span> <span class="kt">int</span> <span class="n">queue</span><span class="p">,</span>
			  <span class="kt">int</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">do_eqbs</span><span class="p">(</span><span class="n">u64</span> <span class="n">token</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span> <span class="kt">int</span> <span class="n">queue</span><span class="p">,</span>
			  <span class="kt">int</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">count</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ack</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_64BIT */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">qdio_irq</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">siga_flag</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">input</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">output</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">sync</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">sync_after_ai</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">sync_out_after_pci</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="nl">u8:</span><span class="mi">3</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="k">struct</span> <span class="n">chsc_ssqd_area</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">chsc_header</span> <span class="n">request</span><span class="p">;</span>
	<span class="nl">u16:</span><span class="mi">10</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ssid</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">fmt</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">first_sch</span><span class="p">;</span>
	<span class="nl">u16:</span><span class="mi">16</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">last_sch</span><span class="p">;</span>
	<span class="nl">u32:</span><span class="mi">32</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">chsc_header</span> <span class="n">response</span><span class="p">;</span>
	<span class="nl">u32:</span><span class="mi">32</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">qdio_ssqd_desc</span> <span class="n">qdio_ssqd</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="k">struct</span> <span class="n">scssc_area</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">chsc_header</span> <span class="n">request</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">operation_code</span><span class="p">;</span>
	<span class="nl">u16:</span><span class="mi">16</span><span class="p">;</span>
	<span class="nl">u32:</span><span class="mi">32</span><span class="p">;</span>
	<span class="nl">u32:</span><span class="mi">32</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">summary_indicator_addr</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">subchannel_indicator_addr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ks</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">kc</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
	<span class="nl">u32:</span><span class="mi">21</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">isc</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">word_with_d_bit</span><span class="p">;</span>
	<span class="nl">u32:</span><span class="mi">32</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">subchannel_id</span> <span class="n">schid</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reserved</span><span class="p">[</span><span class="mi">1004</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">chsc_header</span> <span class="n">response</span><span class="p">;</span>
	<span class="nl">u32:</span><span class="mi">32</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="k">struct</span> <span class="n">qdio_dev_perf_stat</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">adapter_int</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">qdio_int</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pci_request_int</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tasklet_inbound</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tasklet_inbound_resched</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tasklet_inbound_resched2</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tasklet_outbound</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">siga_read</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">siga_write</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">siga_sync</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">inbound_call</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">inbound_handler</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">stop_polling</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">inbound_queue_full</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">outbound_call</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">outbound_handler</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">outbound_queue_full</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fast_requeue</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">target_full</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">eqbs</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">eqbs_partial</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sqbs</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sqbs_partial</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">int_discarded</span><span class="p">;</span>
<span class="p">}</span> <span class="n">____cacheline_aligned</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">qdio_queue_perf_stat</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Sorted into order-2 buckets: 1, 2-3, 4-7, ... 64-127, 128.</span>
<span class="cm">	 * Since max. 127 SBALs are scanned reuse entry for 128 as queue full</span>
<span class="cm">	 * aka 127 SBALs found.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_sbals</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_sbal_error</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_sbal_nop</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_sbal_total</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">qdio_queue_irq_states</span> <span class="p">{</span>
	<span class="n">QDIO_QUEUE_IRQS_DISABLED</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">qdio_input_q</span> <span class="p">{</span>
	<span class="cm">/* input buffer acknowledgement flag */</span>
	<span class="kt">int</span> <span class="n">polling</span><span class="p">;</span>
	<span class="cm">/* first ACK&#39;ed buffer */</span>
	<span class="kt">int</span> <span class="n">ack_start</span><span class="p">;</span>
	<span class="cm">/* how much sbals are acknowledged with qebsm */</span>
	<span class="kt">int</span> <span class="n">ack_count</span><span class="p">;</span>
	<span class="cm">/* last time of noticing incoming data */</span>
	<span class="n">u64</span> <span class="n">timestamp</span><span class="p">;</span>
	<span class="cm">/* upper-layer polling flag */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">queue_irq_state</span><span class="p">;</span>
	<span class="cm">/* callback to start upper-layer polling */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">queue_start_poll</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ccw_device</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">qdio_output_q</span> <span class="p">{</span>
	<span class="cm">/* PCIs are enabled for the queue */</span>
	<span class="kt">int</span> <span class="n">pci_out_enabled</span><span class="p">;</span>
	<span class="cm">/* cq: use asynchronous output buffers */</span>
	<span class="kt">int</span> <span class="n">use_cq</span><span class="p">;</span>
	<span class="cm">/* cq: aobs used for particual SBAL */</span>
	<span class="k">struct</span> <span class="n">qaob</span> <span class="o">**</span><span class="n">aobs</span><span class="p">;</span>
	<span class="cm">/* cq: sbal state related to asynchronous operation */</span>
	<span class="k">struct</span> <span class="n">qdio_outbuf_state</span> <span class="o">*</span><span class="n">sbal_state</span><span class="p">;</span>
	<span class="cm">/* timer to check for more outbound work */</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">timer</span><span class="p">;</span>
	<span class="cm">/* used SBALs before tasklet schedule */</span>
	<span class="kt">int</span> <span class="n">scan_threshold</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Note on cache alignment: grouped slsb and write mostly data at the beginning</span>
<span class="cm"> * sbal[] is read-only and starts on a new cacheline followed by read mostly.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">qdio_q</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">slsb</span> <span class="n">slsb</span><span class="p">;</span>

	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">qdio_input_q</span> <span class="n">in</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">qdio_output_q</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">u</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * inbound: next buffer the program should check for</span>
<span class="cm">	 * outbound: next buffer to check if adapter processed it</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">first_to_check</span><span class="p">;</span>

	<span class="cm">/* first_to_check of the last time */</span>
	<span class="kt">int</span> <span class="n">last_move</span><span class="p">;</span>

	<span class="cm">/* beginning position for calling the program */</span>
	<span class="kt">int</span> <span class="n">first_to_kick</span><span class="p">;</span>

	<span class="cm">/* number of buffers in use by the adapter */</span>
	<span class="n">atomic_t</span> <span class="n">nr_buf_used</span><span class="p">;</span>

	<span class="cm">/* error condition during a data transfer */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">qdio_error</span><span class="p">;</span>

	<span class="cm">/* last scan of the queue */</span>
	<span class="n">u64</span> <span class="n">timestamp</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">tasklet_struct</span> <span class="n">tasklet</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">qdio_queue_perf_stat</span> <span class="n">q_stats</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">qdio_buffer</span> <span class="o">*</span><span class="n">sbal</span><span class="p">[</span><span class="n">QDIO_MAX_BUFFERS_PER_Q</span><span class="p">]</span> <span class="n">____cacheline_aligned</span><span class="p">;</span>

	<span class="cm">/* queue number */</span>
	<span class="kt">int</span> <span class="n">nr</span><span class="p">;</span>

	<span class="cm">/* bitmask of queue number */</span>
	<span class="kt">int</span> <span class="n">mask</span><span class="p">;</span>

	<span class="cm">/* input or output queue */</span>
	<span class="kt">int</span> <span class="n">is_input_q</span><span class="p">;</span>

	<span class="cm">/* list of thinint input queues */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">entry</span><span class="p">;</span>

	<span class="cm">/* upper-layer program handler */</span>
	<span class="n">qdio_handler_t</span> <span class="p">(</span><span class="o">*</span><span class="n">handler</span><span class="p">);</span>

	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">debugfs_q</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">qdio_irq</span> <span class="o">*</span><span class="n">irq_ptr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sl</span> <span class="o">*</span><span class="n">sl</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * A page is allocated under this pointer and used for slib and sl.</span>
<span class="cm">	 * slib is 2048 bytes big and sl points to offset PAGE_SIZE / 2.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">slib</span> <span class="o">*</span><span class="n">slib</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="mi">256</span><span class="p">)));</span>

<span class="k">struct</span> <span class="n">qdio_irq</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">qib</span> <span class="n">qib</span><span class="p">;</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">dsci</span><span class="p">;</span>		<span class="cm">/* address of device state change indicator */</span>
	<span class="k">struct</span> <span class="n">ccw_device</span> <span class="o">*</span><span class="n">cdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">debugfs_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">debugfs_perf</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">int_parm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">subchannel_id</span> <span class="n">schid</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sch_token</span><span class="p">;</span>	<span class="cm">/* QEBSM facility */</span>

	<span class="k">enum</span> <span class="n">qdio_irq_states</span> <span class="n">state</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">siga_flag</span> <span class="n">siga_flag</span><span class="p">;</span>	<span class="cm">/* siga sync information from qdioac */</span>

	<span class="kt">int</span> <span class="n">nr_input_qs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr_output_qs</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">ccw1</span> <span class="n">ccw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ciw</span> <span class="n">equeue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ciw</span> <span class="n">aqueue</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">qdio_ssqd_desc</span> <span class="n">ssqd_desc</span><span class="p">;</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">orig_handler</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ccw_device</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irb</span> <span class="o">*</span><span class="p">);</span>

	<span class="kt">int</span> <span class="n">perf_stat_enabled</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">qdr</span> <span class="o">*</span><span class="n">qdr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">chsc_page</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">qdio_q</span> <span class="o">*</span><span class="n">input_qs</span><span class="p">[</span><span class="n">QDIO_MAX_QUEUES_PER_IRQ</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">qdio_q</span> <span class="o">*</span><span class="n">output_qs</span><span class="p">[</span><span class="n">QDIO_MAX_QUEUES_PER_IRQ</span><span class="p">];</span>

	<span class="n">debug_info_t</span> <span class="o">*</span><span class="n">debug_area</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">setup_mutex</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">qdio_dev_perf_stat</span> <span class="n">perf_stat</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* helper functions */</span>
<span class="cp">#define queue_type(q)	q-&gt;irq_ptr-&gt;qib.qfmt</span>
<span class="cp">#define SCH_NO(q)	(q-&gt;irq_ptr-&gt;schid.sch_no)</span>

<span class="cp">#define is_thinint_irq(irq) \</span>
<span class="cp">	(irq-&gt;qib.qfmt == QDIO_IQDIO_QFMT || \</span>
<span class="cp">	 css_general_characteristics.aif_osa)</span>

<span class="cp">#define qperf(__qdev, __attr)	((__qdev)-&gt;perf_stat.(__attr))</span>

<span class="cp">#define qperf_inc(__q, __attr)						\</span>
<span class="cp">({									\</span>
<span class="cp">	struct qdio_irq *qdev = (__q)-&gt;irq_ptr;				\</span>
<span class="cp">	if (qdev-&gt;perf_stat_enabled)					\</span>
<span class="cp">		(qdev-&gt;perf_stat.__attr)++;				\</span>
<span class="cp">})</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">account_sbals_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">qdio_q</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">q_stats</span><span class="p">.</span><span class="n">nr_sbal_error</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">q_stats</span><span class="p">.</span><span class="n">nr_sbal_total</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* the highest iqdio queue is used for multicast */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">multicast_outbound</span><span class="p">(</span><span class="k">struct</span> <span class="n">qdio_q</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">irq_ptr</span><span class="o">-&gt;</span><span class="n">nr_output_qs</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	       <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">nr</span> <span class="o">==</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">irq_ptr</span><span class="o">-&gt;</span><span class="n">nr_output_qs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define pci_out_supported(q) \</span>
<span class="cp">	(q-&gt;irq_ptr-&gt;qib.ac &amp; QIB_AC_OUTBOUND_PCI_SUPPORTED)</span>
<span class="cp">#define is_qebsm(q)			(q-&gt;irq_ptr-&gt;sch_token != 0)</span>

<span class="cp">#define need_siga_in(q)			(q-&gt;irq_ptr-&gt;siga_flag.input)</span>
<span class="cp">#define need_siga_out(q)		(q-&gt;irq_ptr-&gt;siga_flag.output)</span>
<span class="cp">#define need_siga_sync(q)		(unlikely(q-&gt;irq_ptr-&gt;siga_flag.sync))</span>
<span class="cp">#define need_siga_sync_after_ai(q)	\</span>
<span class="cp">	(unlikely(q-&gt;irq_ptr-&gt;siga_flag.sync_after_ai))</span>
<span class="cp">#define need_siga_sync_out_after_pci(q)	\</span>
<span class="cp">	(unlikely(q-&gt;irq_ptr-&gt;siga_flag.sync_out_after_pci))</span>

<span class="cp">#define for_each_input_queue(irq_ptr, q, i)	\</span>
<span class="cp">	for (i = 0, q = irq_ptr-&gt;input_qs[0];	\</span>
<span class="cp">		i &lt; irq_ptr-&gt;nr_input_qs;	\</span>
<span class="cp">		q = irq_ptr-&gt;input_qs[++i])</span>
<span class="cp">#define for_each_output_queue(irq_ptr, q, i)	\</span>
<span class="cp">	for (i = 0, q = irq_ptr-&gt;output_qs[0];	\</span>
<span class="cp">		i &lt; irq_ptr-&gt;nr_output_qs;	\</span>
<span class="cp">		q = irq_ptr-&gt;output_qs[++i])</span>

<span class="cp">#define prev_buf(bufnr)	\</span>
<span class="cp">	((bufnr + QDIO_MAX_BUFFERS_MASK) &amp; QDIO_MAX_BUFFERS_MASK)</span>
<span class="cp">#define next_buf(bufnr)	\</span>
<span class="cp">	((bufnr + 1) &amp; QDIO_MAX_BUFFERS_MASK)</span>
<span class="cp">#define add_buf(bufnr, inc) \</span>
<span class="cp">	((bufnr + inc) &amp; QDIO_MAX_BUFFERS_MASK)</span>
<span class="cp">#define sub_buf(bufnr, dec) \</span>
<span class="cp">	((bufnr - dec) &amp; QDIO_MAX_BUFFERS_MASK)</span>

<span class="cp">#define queue_irqs_enabled(q)			\</span>
<span class="cp">	(test_bit(QDIO_QUEUE_IRQS_DISABLED, &amp;q-&gt;u.in.queue_irq_state) == 0)</span>
<span class="cp">#define queue_irqs_disabled(q)			\</span>
<span class="cp">	(test_bit(QDIO_QUEUE_IRQS_DISABLED, &amp;q-&gt;u.in.queue_irq_state) != 0)</span>

<span class="k">extern</span> <span class="n">u64</span> <span class="n">last_ai_time</span><span class="p">;</span>

<span class="cm">/* prototypes for thin interrupt */</span>
<span class="kt">void</span> <span class="n">qdio_setup_thinint</span><span class="p">(</span><span class="k">struct</span> <span class="n">qdio_irq</span> <span class="o">*</span><span class="n">irq_ptr</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">qdio_establish_thinint</span><span class="p">(</span><span class="k">struct</span> <span class="n">qdio_irq</span> <span class="o">*</span><span class="n">irq_ptr</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">qdio_shutdown_thinint</span><span class="p">(</span><span class="k">struct</span> <span class="n">qdio_irq</span> <span class="o">*</span><span class="n">irq_ptr</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">tiqdio_add_input_queues</span><span class="p">(</span><span class="k">struct</span> <span class="n">qdio_irq</span> <span class="o">*</span><span class="n">irq_ptr</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">tiqdio_remove_input_queues</span><span class="p">(</span><span class="k">struct</span> <span class="n">qdio_irq</span> <span class="o">*</span><span class="n">irq_ptr</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">tiqdio_inbound_processing</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">q</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">tiqdio_allocate_memory</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">tiqdio_free_memory</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">tiqdio_register_thinints</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">tiqdio_unregister_thinints</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">clear_nonshared_ind</span><span class="p">(</span><span class="k">struct</span> <span class="n">qdio_irq</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">test_nonshared_ind</span><span class="p">(</span><span class="k">struct</span> <span class="n">qdio_irq</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/* prototypes for setup */</span>
<span class="kt">void</span> <span class="n">qdio_inbound_processing</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">qdio_outbound_processing</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">qdio_outbound_timer</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">qdio_int_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">ccw_device</span> <span class="o">*</span><span class="n">cdev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">intparm</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">irb</span> <span class="o">*</span><span class="n">irb</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">qdio_allocate_qs</span><span class="p">(</span><span class="k">struct</span> <span class="n">qdio_irq</span> <span class="o">*</span><span class="n">irq_ptr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nr_input_qs</span><span class="p">,</span>
		     <span class="kt">int</span> <span class="n">nr_output_qs</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">qdio_setup_ssqd_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">qdio_irq</span> <span class="o">*</span><span class="n">irq_ptr</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">qdio_setup_get_ssqd</span><span class="p">(</span><span class="k">struct</span> <span class="n">qdio_irq</span> <span class="o">*</span><span class="n">irq_ptr</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">subchannel_id</span> <span class="o">*</span><span class="n">schid</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">qdio_ssqd_desc</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">qdio_setup_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">qdio_initialize</span> <span class="o">*</span><span class="n">init_data</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">qdio_print_subchannel_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">qdio_irq</span> <span class="o">*</span><span class="n">irq_ptr</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ccw_device</span> <span class="o">*</span><span class="n">cdev</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">qdio_release_memory</span><span class="p">(</span><span class="k">struct</span> <span class="n">qdio_irq</span> <span class="o">*</span><span class="n">irq_ptr</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">qdio_setup_create_sysfs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ccw_device</span> <span class="o">*</span><span class="n">cdev</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">qdio_setup_destroy_sysfs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ccw_device</span> <span class="o">*</span><span class="n">cdev</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">qdio_setup_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">qdio_setup_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">qdio_enable_async_operation</span><span class="p">(</span><span class="k">struct</span> <span class="n">qdio_output_q</span> <span class="o">*</span><span class="n">q</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">qdio_disable_async_operation</span><span class="p">(</span><span class="k">struct</span> <span class="n">qdio_output_q</span> <span class="o">*</span><span class="n">q</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">qaob</span> <span class="o">*</span><span class="n">qdio_allocate_aob</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">debug_get_buf_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">qdio_q</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bufnr</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">state</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* _CIO_QDIO_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
