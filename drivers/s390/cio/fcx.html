<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › s390 › cio › fcx.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>fcx.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  Functions for assembling fcx enabled I/O control blocks.</span>
<span class="cm"> *</span>
<span class="cm"> *    Copyright IBM Corp. 2008</span>
<span class="cm"> *    Author(s): Peter Oberparleiter &lt;peter.oberparleiter@de.ibm.com&gt;</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/err.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;asm/fcx.h&gt;</span>
<span class="cp">#include &quot;cio.h&quot;</span>

<span class="cm">/**</span>
<span class="cm"> * tcw_get_intrg - return pointer to associated interrogate tcw</span>
<span class="cm"> * @tcw: pointer to the original tcw</span>
<span class="cm"> *</span>
<span class="cm"> * Return a pointer to the interrogate tcw associated with the specified tcw</span>
<span class="cm"> * or %NULL if there is no associated interrogate tcw.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">tcw</span> <span class="o">*</span><span class="nf">tcw_get_intrg</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcw</span> <span class="o">*</span><span class="n">tcw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tcw</span> <span class="o">*</span><span class="p">)</span> <span class="p">((</span><span class="n">addr_t</span><span class="p">)</span> <span class="n">tcw</span><span class="o">-&gt;</span><span class="n">intrg</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tcw_get_intrg</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * tcw_get_data - return pointer to input/output data associated with tcw</span>
<span class="cm"> * @tcw: pointer to the tcw</span>
<span class="cm"> *</span>
<span class="cm"> * Return the input or output data address specified in the tcw depending</span>
<span class="cm"> * on whether the r-bit or the w-bit is set. If neither bit is set, return</span>
<span class="cm"> * %NULL.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">tcw_get_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcw</span> <span class="o">*</span><span class="n">tcw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tcw</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="p">((</span><span class="n">addr_t</span><span class="p">)</span> <span class="n">tcw</span><span class="o">-&gt;</span><span class="n">input</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tcw</span><span class="o">-&gt;</span><span class="n">w</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="p">((</span><span class="n">addr_t</span><span class="p">)</span> <span class="n">tcw</span><span class="o">-&gt;</span><span class="n">output</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tcw_get_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * tcw_get_tccb - return pointer to tccb associated with tcw</span>
<span class="cm"> * @tcw: pointer to the tcw</span>
<span class="cm"> *</span>
<span class="cm"> * Return pointer to the tccb associated with this tcw.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">tccb</span> <span class="o">*</span><span class="nf">tcw_get_tccb</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcw</span> <span class="o">*</span><span class="n">tcw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tccb</span> <span class="o">*</span><span class="p">)</span> <span class="p">((</span><span class="n">addr_t</span><span class="p">)</span> <span class="n">tcw</span><span class="o">-&gt;</span><span class="n">tccb</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tcw_get_tccb</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * tcw_get_tsb - return pointer to tsb associated with tcw</span>
<span class="cm"> * @tcw: pointer to the tcw</span>
<span class="cm"> *</span>
<span class="cm"> * Return pointer to the tsb associated with this tcw.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">tsb</span> <span class="o">*</span><span class="nf">tcw_get_tsb</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcw</span> <span class="o">*</span><span class="n">tcw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tsb</span> <span class="o">*</span><span class="p">)</span> <span class="p">((</span><span class="n">addr_t</span><span class="p">)</span> <span class="n">tcw</span><span class="o">-&gt;</span><span class="n">tsb</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tcw_get_tsb</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * tcw_init - initialize tcw data structure</span>
<span class="cm"> * @tcw: pointer to the tcw to be initialized</span>
<span class="cm"> * @r: initial value of the r-bit</span>
<span class="cm"> * @w: initial value of the w-bit</span>
<span class="cm"> *</span>
<span class="cm"> * Initialize all fields of the specified tcw data structure with zero and</span>
<span class="cm"> * fill in the format, flags, r and w fields.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">tcw_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcw</span> <span class="o">*</span><span class="n">tcw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">,</span> <span class="kt">int</span> <span class="n">w</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">tcw</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcw</span><span class="p">));</span>
	<span class="n">tcw</span><span class="o">-&gt;</span><span class="n">format</span> <span class="o">=</span> <span class="n">TCW_FORMAT_DEFAULT</span><span class="p">;</span>
	<span class="n">tcw</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">TCW_FLAGS_TIDAW_FORMAT</span><span class="p">(</span><span class="n">TCW_TIDAW_FORMAT_DEFAULT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="n">tcw</span><span class="o">-&gt;</span><span class="n">r</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">w</span><span class="p">)</span>
		<span class="n">tcw</span><span class="o">-&gt;</span><span class="n">w</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tcw_init</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">size_t</span> <span class="nf">tca_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">tccb</span> <span class="o">*</span><span class="n">tccb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">tccb</span><span class="o">-&gt;</span><span class="n">tcah</span><span class="p">.</span><span class="n">tcal</span> <span class="o">-</span> <span class="mi">12</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">calc_dcw_count</span><span class="p">(</span><span class="k">struct</span> <span class="n">tccb</span> <span class="o">*</span><span class="n">tccb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">offset</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dcw</span> <span class="o">*</span><span class="n">dcw</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="n">tca_size</span><span class="p">(</span><span class="n">tccb</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">offset</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;)</span> <span class="p">{</span>
		<span class="n">dcw</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dcw</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">tccb</span><span class="o">-&gt;</span><span class="n">tca</span><span class="p">[</span><span class="n">offset</span><span class="p">];</span>
		<span class="n">count</span> <span class="o">+=</span> <span class="n">dcw</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">dcw</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DCW_FLAGS_CC</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">offset</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dcw</span><span class="p">)</span> <span class="o">+</span> <span class="n">ALIGN</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span> <span class="n">dcw</span><span class="o">-&gt;</span><span class="n">cd_count</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">calc_cbc_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">tidaw</span> <span class="o">*</span><span class="n">tidaw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">cbc_data</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">cbc_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">data_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tidaw</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TIDAW_FLAGS_LAST</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="cm">/* TODO: find out if padding applies to total of data</span>
<span class="cm">		 * transferred or data transferred by this tidaw. Assumption:</span>
<span class="cm">		 * applies to total. */</span>
		<span class="n">data_count</span> <span class="o">+=</span> <span class="n">tidaw</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">count</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tidaw</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TIDAW_FLAGS_INSERT_CBC</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cbc_data</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">+</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">data_count</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">-</span> <span class="n">data_count</span><span class="p">;</span>
			<span class="n">cbc_count</span> <span class="o">+=</span> <span class="n">cbc_data</span><span class="p">;</span>
			<span class="n">data_count</span> <span class="o">+=</span> <span class="n">cbc_data</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">cbc_count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * tcw_finalize - finalize tcw length fields and tidaw list</span>
<span class="cm"> * @tcw: pointer to the tcw</span>
<span class="cm"> * @num_tidaws: the number of tidaws used to address input/output data or zero</span>
<span class="cm"> * if no tida is used</span>
<span class="cm"> *</span>
<span class="cm"> * Calculate the input-/output-count and tccbl field in the tcw, add a</span>
<span class="cm"> * tcat the tccb and terminate the data tidaw list if used.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: in case input- or output-tida is used, the tidaw-list must be stored</span>
<span class="cm"> * in contiguous storage (no ttic). The tcal field in the tccb must be</span>
<span class="cm"> * up-to-date.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">tcw_finalize</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcw</span> <span class="o">*</span><span class="n">tcw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num_tidaws</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tidaw</span> <span class="o">*</span><span class="n">tidaw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tccb</span> <span class="o">*</span><span class="n">tccb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tccb_tcat</span> <span class="o">*</span><span class="n">tcat</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">count</span><span class="p">;</span>

	<span class="cm">/* Terminate tidaw list. */</span>
	<span class="n">tidaw</span> <span class="o">=</span> <span class="n">tcw_get_data</span><span class="p">(</span><span class="n">tcw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">num_tidaws</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">tidaw</span><span class="p">[</span><span class="n">num_tidaws</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">TIDAW_FLAGS_LAST</span><span class="p">;</span>
	<span class="cm">/* Add tcat to tccb. */</span>
	<span class="n">tccb</span> <span class="o">=</span> <span class="n">tcw_get_tccb</span><span class="p">(</span><span class="n">tcw</span><span class="p">);</span>
	<span class="n">tcat</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tccb_tcat</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">tccb</span><span class="o">-&gt;</span><span class="n">tca</span><span class="p">[</span><span class="n">tca_size</span><span class="p">(</span><span class="n">tccb</span><span class="p">)];</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">tcat</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">tcat</span><span class="p">));</span>
	<span class="cm">/* Calculate tcw input/output count and tcat transport count. */</span>
	<span class="n">count</span> <span class="o">=</span> <span class="n">calc_dcw_count</span><span class="p">(</span><span class="n">tccb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tcw</span><span class="o">-&gt;</span><span class="n">w</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">tcw</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TCW_FLAGS_OUTPUT_TIDA</span><span class="p">))</span>
		<span class="n">count</span> <span class="o">+=</span> <span class="n">calc_cbc_size</span><span class="p">(</span><span class="n">tidaw</span><span class="p">,</span> <span class="n">num_tidaws</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tcw</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">)</span>
		<span class="n">tcw</span><span class="o">-&gt;</span><span class="n">input_count</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tcw</span><span class="o">-&gt;</span><span class="n">w</span><span class="p">)</span>
		<span class="n">tcw</span><span class="o">-&gt;</span><span class="n">output_count</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
	<span class="n">tcat</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="mi">4</span><span class="p">;</span>
	<span class="cm">/* Calculate tccbl. */</span>
	<span class="n">tcw</span><span class="o">-&gt;</span><span class="n">tccbl</span> <span class="o">=</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tccb</span><span class="p">)</span> <span class="o">+</span> <span class="n">tca_size</span><span class="p">(</span><span class="n">tccb</span><span class="p">)</span> <span class="o">+</span>
		      <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tccb_tcat</span><span class="p">)</span> <span class="o">-</span> <span class="mi">20</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tcw_finalize</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * tcw_set_intrg - set the interrogate tcw address of a tcw</span>
<span class="cm"> * @tcw: the tcw address</span>
<span class="cm"> * @intrg_tcw: the address of the interrogate tcw</span>
<span class="cm"> *</span>
<span class="cm"> * Set the address of the interrogate tcw in the specified tcw.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">tcw_set_intrg</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcw</span> <span class="o">*</span><span class="n">tcw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tcw</span> <span class="o">*</span><span class="n">intrg_tcw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tcw</span><span class="o">-&gt;</span><span class="n">intrg</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="p">((</span><span class="n">addr_t</span><span class="p">)</span> <span class="n">intrg_tcw</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tcw_set_intrg</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * tcw_set_data - set data address and tida flag of a tcw</span>
<span class="cm"> * @tcw: the tcw address</span>
<span class="cm"> * @data: the data address</span>
<span class="cm"> * @use_tidal: zero of the data address specifies a contiguous block of data,</span>
<span class="cm"> * non-zero if it specifies a list if tidaws.</span>
<span class="cm"> *</span>
<span class="cm"> * Set the input/output data address of a tcw (depending on the value of the</span>
<span class="cm"> * r-flag and w-flag). If @use_tidal is non-zero, the corresponding tida flag</span>
<span class="cm"> * is set as well.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">tcw_set_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcw</span> <span class="o">*</span><span class="n">tcw</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">use_tidal</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tcw</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tcw</span><span class="o">-&gt;</span><span class="n">input</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="p">((</span><span class="n">addr_t</span><span class="p">)</span> <span class="n">data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">use_tidal</span><span class="p">)</span>
			<span class="n">tcw</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">TCW_FLAGS_INPUT_TIDA</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tcw</span><span class="o">-&gt;</span><span class="n">w</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tcw</span><span class="o">-&gt;</span><span class="n">output</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="p">((</span><span class="n">addr_t</span><span class="p">)</span> <span class="n">data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">use_tidal</span><span class="p">)</span>
			<span class="n">tcw</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">TCW_FLAGS_OUTPUT_TIDA</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tcw_set_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * tcw_set_tccb - set tccb address of a tcw</span>
<span class="cm"> * @tcw: the tcw address</span>
<span class="cm"> * @tccb: the tccb address</span>
<span class="cm"> *</span>
<span class="cm"> * Set the address of the tccb in the specified tcw.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">tcw_set_tccb</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcw</span> <span class="o">*</span><span class="n">tcw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tccb</span> <span class="o">*</span><span class="n">tccb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tcw</span><span class="o">-&gt;</span><span class="n">tccb</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="p">((</span><span class="n">addr_t</span><span class="p">)</span> <span class="n">tccb</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tcw_set_tccb</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * tcw_set_tsb - set tsb address of a tcw</span>
<span class="cm"> * @tcw: the tcw address</span>
<span class="cm"> * @tsb: the tsb address</span>
<span class="cm"> *</span>
<span class="cm"> * Set the address of the tsb in the specified tcw.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">tcw_set_tsb</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcw</span> <span class="o">*</span><span class="n">tcw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tsb</span> <span class="o">*</span><span class="n">tsb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tcw</span><span class="o">-&gt;</span><span class="n">tsb</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="p">((</span><span class="n">addr_t</span><span class="p">)</span> <span class="n">tsb</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tcw_set_tsb</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * tccb_init - initialize tccb</span>
<span class="cm"> * @tccb: the tccb address</span>
<span class="cm"> * @size: the maximum size of the tccb</span>
<span class="cm"> * @sac: the service-action-code to be user</span>
<span class="cm"> *</span>
<span class="cm"> * Initialize the header of the specified tccb by resetting all values to zero</span>
<span class="cm"> * and filling in defaults for format, sac and initial tcal fields.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">tccb_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">tccb</span> <span class="o">*</span><span class="n">tccb</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">u32</span> <span class="n">sac</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">tccb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">tccb</span><span class="o">-&gt;</span><span class="n">tcah</span><span class="p">.</span><span class="n">format</span> <span class="o">=</span> <span class="n">TCCB_FORMAT_DEFAULT</span><span class="p">;</span>
	<span class="n">tccb</span><span class="o">-&gt;</span><span class="n">tcah</span><span class="p">.</span><span class="n">sac</span> <span class="o">=</span> <span class="n">sac</span><span class="p">;</span>
	<span class="n">tccb</span><span class="o">-&gt;</span><span class="n">tcah</span><span class="p">.</span><span class="n">tcal</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tccb_init</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * tsb_init - initialize tsb</span>
<span class="cm"> * @tsb: the tsb address</span>
<span class="cm"> *</span>
<span class="cm"> * Initialize the specified tsb by resetting all values to zero.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">tsb_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">tsb</span> <span class="o">*</span><span class="n">tsb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">tsb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">tsb</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tsb_init</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * tccb_add_dcw - add a dcw to the tccb</span>
<span class="cm"> * @tccb: the tccb address</span>
<span class="cm"> * @tccb_size: the maximum tccb size</span>
<span class="cm"> * @cmd: the dcw command</span>
<span class="cm"> * @flags: flags for the dcw</span>
<span class="cm"> * @cd: pointer to control data for this dcw or NULL if none is required</span>
<span class="cm"> * @cd_count: number of control data bytes for this dcw</span>
<span class="cm"> * @count: number of data bytes for this dcw</span>
<span class="cm"> *</span>
<span class="cm"> * Add a new dcw to the specified tccb by writing the dcw information specified</span>
<span class="cm"> * by @cmd, @flags, @cd, @cd_count and @count to the tca of the tccb. Return</span>
<span class="cm"> * a pointer to the newly added dcw on success or -%ENOSPC if the new dcw</span>
<span class="cm"> * would exceed the available space as defined by @tccb_size.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: the tcal field of the tccb header will be updates to reflect added</span>
<span class="cm"> * content.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">dcw</span> <span class="o">*</span><span class="nf">tccb_add_dcw</span><span class="p">(</span><span class="k">struct</span> <span class="n">tccb</span> <span class="o">*</span><span class="n">tccb</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">tccb_size</span><span class="p">,</span> <span class="n">u8</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">u8</span> <span class="n">flags</span><span class="p">,</span>
			 <span class="kt">void</span> <span class="o">*</span><span class="n">cd</span><span class="p">,</span> <span class="n">u8</span> <span class="n">cd_count</span><span class="p">,</span> <span class="n">u32</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dcw</span> <span class="o">*</span><span class="n">dcw</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tca_offset</span><span class="p">;</span>

	<span class="cm">/* Check for space. */</span>
	<span class="n">tca_offset</span> <span class="o">=</span> <span class="n">tca_size</span><span class="p">(</span><span class="n">tccb</span><span class="p">);</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dcw</span><span class="p">)</span> <span class="o">+</span> <span class="n">cd_count</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tccb_tcah</span><span class="p">)</span> <span class="o">+</span> <span class="n">tca_offset</span> <span class="o">+</span> <span class="n">size</span> <span class="o">+</span>
	    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tccb_tcat</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">tccb_size</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOSPC</span><span class="p">);</span>
	<span class="cm">/* Add dcw to tca. */</span>
	<span class="n">dcw</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dcw</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">tccb</span><span class="o">-&gt;</span><span class="n">tca</span><span class="p">[</span><span class="n">tca_offset</span><span class="p">];</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">dcw</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">dcw</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">;</span>
	<span class="n">dcw</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">dcw</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
	<span class="n">dcw</span><span class="o">-&gt;</span><span class="n">cd_count</span> <span class="o">=</span> <span class="n">cd_count</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cd</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dcw</span><span class="o">-&gt;</span><span class="n">cd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cd</span><span class="p">,</span> <span class="n">cd_count</span><span class="p">);</span>
	<span class="n">tccb</span><span class="o">-&gt;</span><span class="n">tcah</span><span class="p">.</span><span class="n">tcal</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">dcw</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tccb_add_dcw</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * tcw_add_tidaw - add a tidaw to a tcw</span>
<span class="cm"> * @tcw: the tcw address</span>
<span class="cm"> * @num_tidaws: the current number of tidaws</span>
<span class="cm"> * @flags: flags for the new tidaw</span>
<span class="cm"> * @addr: address value for the new tidaw</span>
<span class="cm"> * @count: count value for the new tidaw</span>
<span class="cm"> *</span>
<span class="cm"> * Add a new tidaw to the input/output data tidaw-list of the specified tcw</span>
<span class="cm"> * (depending on the value of the r-flag and w-flag) and return a pointer to</span>
<span class="cm"> * the new tidaw.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: the tidaw-list is assumed to be contiguous with no ttics. The caller</span>
<span class="cm"> * must ensure that there is enough space for the new tidaw. The last-tidaw</span>
<span class="cm"> * flag for the last tidaw in the list will be set by tcw_finalize.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">tidaw</span> <span class="o">*</span><span class="nf">tcw_add_tidaw</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcw</span> <span class="o">*</span><span class="n">tcw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num_tidaws</span><span class="p">,</span> <span class="n">u8</span> <span class="n">flags</span><span class="p">,</span>
			    <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tidaw</span> <span class="o">*</span><span class="n">tidaw</span><span class="p">;</span>

	<span class="cm">/* Add tidaw to tidaw-list. */</span>
	<span class="n">tidaw</span> <span class="o">=</span> <span class="p">((</span><span class="k">struct</span> <span class="n">tidaw</span> <span class="o">*</span><span class="p">)</span> <span class="n">tcw_get_data</span><span class="p">(</span><span class="n">tcw</span><span class="p">))</span> <span class="o">+</span> <span class="n">num_tidaws</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">tidaw</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tidaw</span><span class="p">));</span>
	<span class="n">tidaw</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">tidaw</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
	<span class="n">tidaw</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="p">((</span><span class="n">addr_t</span><span class="p">)</span> <span class="n">addr</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">tidaw</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tcw_add_tidaw</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
