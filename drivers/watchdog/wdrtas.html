<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › watchdog › wdrtas.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>wdrtas.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * FIXME: add wdrtas_get_status and wdrtas_get_boot_status as soon as</span>
<span class="cm"> * RTAS calls are available</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * RTAS watchdog driver</span>
<span class="cm"> *</span>
<span class="cm"> * (C) Copyright IBM Corp. 2005</span>
<span class="cm"> * device driver to exploit watchdog RTAS functions</span>
<span class="cm"> *</span>
<span class="cm"> * Authors : Utz Bacher &lt;utz.bacher@de.ibm.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2, or (at your option)</span>
<span class="cm"> * any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
<span class="cm"> */</span>

<span class="cp">#define pr_fmt(fmt) KBUILD_MODNAME &quot;: &quot; fmt</span>

<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/miscdevice.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/notifier.h&gt;</span>
<span class="cp">#include &lt;linux/reboot.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/watchdog.h&gt;</span>
<span class="cp">#include &lt;linux/uaccess.h&gt;</span>

<span class="cp">#include &lt;asm/rtas.h&gt;</span>

<span class="cp">#define WDRTAS_MAGIC_CHAR		42</span>
<span class="cp">#define WDRTAS_SUPPORTED_MASK		(WDIOF_SETTIMEOUT | \</span>
<span class="cp">					 WDIOF_MAGICCLOSE)</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Utz Bacher &lt;utz.bacher@de.ibm.com&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;RTAS watchdog driver&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_ALIAS_MISCDEV</span><span class="p">(</span><span class="n">WATCHDOG_MINOR</span><span class="p">);</span>
<span class="n">MODULE_ALIAS_MISCDEV</span><span class="p">(</span><span class="n">TEMP_MINOR</span><span class="p">);</span>

<span class="k">static</span> <span class="n">bool</span> <span class="n">wdrtas_nowayout</span> <span class="o">=</span> <span class="n">WATCHDOG_NOWAYOUT</span><span class="p">;</span>
<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">wdrtas_miscdev_open</span> <span class="o">=</span> <span class="n">ATOMIC_INIT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">char</span> <span class="n">wdrtas_expect_close</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">wdrtas_interval</span><span class="p">;</span>

<span class="cp">#define WDRTAS_THERMAL_SENSOR		3</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">wdrtas_token_get_sensor_state</span><span class="p">;</span>
<span class="cp">#define WDRTAS_SURVEILLANCE_IND		9000</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">wdrtas_token_set_indicator</span><span class="p">;</span>
<span class="cp">#define WDRTAS_SP_SPI			28</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">wdrtas_token_get_sp</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">wdrtas_token_event_scan</span><span class="p">;</span>

<span class="cp">#define WDRTAS_DEFAULT_INTERVAL		300</span>

<span class="cp">#define WDRTAS_LOGBUFFER_LEN		128</span>
<span class="k">static</span> <span class="kt">char</span> <span class="n">wdrtas_logbuffer</span><span class="p">[</span><span class="n">WDRTAS_LOGBUFFER_LEN</span><span class="p">];</span>


<span class="cm">/*** watchdog access functions */</span>

<span class="cm">/**</span>
<span class="cm"> * wdrtas_set_interval - sets the watchdog interval</span>
<span class="cm"> * @interval: new interval</span>
<span class="cm"> *</span>
<span class="cm"> * returns 0 on success, &lt;0 on failures</span>
<span class="cm"> *</span>
<span class="cm"> * wdrtas_set_interval sets the watchdog keepalive interval by calling the</span>
<span class="cm"> * RTAS function set-indicator (surveillance). The unit of interval is</span>
<span class="cm"> * seconds.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">wdrtas_set_interval</span><span class="p">(</span><span class="kt">int</span> <span class="n">interval</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">result</span><span class="p">;</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">print_msg</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

	<span class="cm">/* rtas uses minutes */</span>
	<span class="n">interval</span> <span class="o">=</span> <span class="p">(</span><span class="n">interval</span> <span class="o">+</span> <span class="mi">59</span><span class="p">)</span> <span class="o">/</span> <span class="mi">60</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">rtas_call</span><span class="p">(</span><span class="n">wdrtas_token_set_indicator</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
			   <span class="n">WDRTAS_SURVEILLANCE_IND</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">interval</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">print_msg</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;setting the watchdog to %i timeout failed: %li</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">interval</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
		<span class="n">print_msg</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define WDRTAS_SP_SPI_LEN 4</span>

<span class="cm">/**</span>
<span class="cm"> * wdrtas_get_interval - returns the current watchdog interval</span>
<span class="cm"> * @fallback_value: value (in seconds) to use, if the RTAS call fails</span>
<span class="cm"> *</span>
<span class="cm"> * returns the interval</span>
<span class="cm"> *</span>
<span class="cm"> * wdrtas_get_interval returns the current watchdog keepalive interval</span>
<span class="cm"> * as reported by the RTAS function ibm,get-system-parameter. The unit</span>
<span class="cm"> * of the return value is seconds.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">wdrtas_get_interval</span><span class="p">(</span><span class="kt">int</span> <span class="n">fallback_value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">result</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">value</span><span class="p">[</span><span class="n">WDRTAS_SP_SPI_LEN</span><span class="p">];</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtas_data_buf_lock</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">rtas_data_buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">WDRTAS_SP_SPI_LEN</span><span class="p">);</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">rtas_call</span><span class="p">(</span><span class="n">wdrtas_token_get_sp</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
			   <span class="n">WDRTAS_SP_SPI</span><span class="p">,</span> <span class="n">__pa</span><span class="p">(</span><span class="n">rtas_data_buf</span><span class="p">),</span>
			   <span class="n">WDRTAS_SP_SPI_LEN</span><span class="p">);</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">rtas_data_buf</span><span class="p">,</span> <span class="n">WDRTAS_SP_SPI_LEN</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtas_data_buf_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">2</span> <span class="o">||</span> <span class="n">value</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;could not get sp_spi watchdog timeout (%li). Continuing</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">result</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">fallback_value</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* rtas uses minutes */</span>
	<span class="k">return</span> <span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">value</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">*</span> <span class="mi">60</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * wdrtas_timer_start - starts watchdog</span>
<span class="cm"> *</span>
<span class="cm"> * wdrtas_timer_start starts the watchdog by calling the RTAS function</span>
<span class="cm"> * set-interval (surveillance)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">wdrtas_timer_start</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">wdrtas_set_interval</span><span class="p">(</span><span class="n">wdrtas_interval</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * wdrtas_timer_stop - stops watchdog</span>
<span class="cm"> *</span>
<span class="cm"> * wdrtas_timer_stop stops the watchdog timer by calling the RTAS function</span>
<span class="cm"> * set-interval (surveillance)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">wdrtas_timer_stop</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">wdrtas_set_interval</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * wdrtas_log_scanned_event - logs an event we received during keepalive</span>
<span class="cm"> *</span>
<span class="cm"> * wdrtas_log_scanned_event prints a message to the log buffer dumping</span>
<span class="cm"> * the results of the last event-scan call</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">wdrtas_log_scanned_event</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">WDRTAS_LOGBUFFER_LEN</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">16</span><span class="p">)</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;dumping event (line %i/%i), data = &quot;</span>
			<span class="s">&quot;%02x %02x %02x %02x  %02x %02x %02x %02x   &quot;</span>
			<span class="s">&quot;%02x %02x %02x %02x  %02x %02x %02x %02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="n">i</span> <span class="o">/</span> <span class="mi">16</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">WDRTAS_LOGBUFFER_LEN</span> <span class="o">/</span> <span class="mi">16</span><span class="p">),</span>
			<span class="n">wdrtas_logbuffer</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">0</span><span class="p">],</span> <span class="n">wdrtas_logbuffer</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
			<span class="n">wdrtas_logbuffer</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">],</span> <span class="n">wdrtas_logbuffer</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">3</span><span class="p">],</span>
			<span class="n">wdrtas_logbuffer</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">4</span><span class="p">],</span> <span class="n">wdrtas_logbuffer</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">5</span><span class="p">],</span>
			<span class="n">wdrtas_logbuffer</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">6</span><span class="p">],</span> <span class="n">wdrtas_logbuffer</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">7</span><span class="p">],</span>
			<span class="n">wdrtas_logbuffer</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">8</span><span class="p">],</span> <span class="n">wdrtas_logbuffer</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">9</span><span class="p">],</span>
			<span class="n">wdrtas_logbuffer</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">10</span><span class="p">],</span> <span class="n">wdrtas_logbuffer</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">11</span><span class="p">],</span>
			<span class="n">wdrtas_logbuffer</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">12</span><span class="p">],</span> <span class="n">wdrtas_logbuffer</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">13</span><span class="p">],</span>
			<span class="n">wdrtas_logbuffer</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">14</span><span class="p">],</span> <span class="n">wdrtas_logbuffer</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">15</span><span class="p">]);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * wdrtas_timer_keepalive - resets watchdog timer to keep system alive</span>
<span class="cm"> *</span>
<span class="cm"> * wdrtas_timer_keepalive restarts the watchdog timer by calling the</span>
<span class="cm"> * RTAS function event-scan and repeats these calls as long as there are</span>
<span class="cm"> * events available. All events will be dumped.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">wdrtas_timer_keepalive</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">result</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">rtas_call</span><span class="p">(</span><span class="n">wdrtas_token_event_scan</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
				   <span class="n">RTAS_EVENT_SCAN_ALL_EVENTS</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				   <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">__pa</span><span class="p">(</span><span class="n">wdrtas_logbuffer</span><span class="p">),</span>
				   <span class="n">WDRTAS_LOGBUFFER_LEN</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;event-scan failed: %li</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">wdrtas_log_scanned_event</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * wdrtas_get_temperature - returns current temperature</span>
<span class="cm"> *</span>
<span class="cm"> * returns temperature or &lt;0 on failures</span>
<span class="cm"> *</span>
<span class="cm"> * wdrtas_get_temperature returns the current temperature in Fahrenheit. It</span>
<span class="cm"> * uses the RTAS call get-sensor-state, token 3 to do so</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">wdrtas_get_temperature</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">temperature</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">rtas_get_sensor</span><span class="p">(</span><span class="n">WDRTAS_THERMAL_SENSOR</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">temperature</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;reading the thermal sensor failed: %i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">temperature</span> <span class="o">=</span> <span class="p">((</span><span class="n">temperature</span> <span class="o">*</span> <span class="mi">9</span><span class="p">)</span> <span class="o">/</span> <span class="mi">5</span><span class="p">)</span> <span class="o">+</span> <span class="mi">32</span><span class="p">;</span> <span class="cm">/* fahrenheit */</span>

	<span class="k">return</span> <span class="n">temperature</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * wdrtas_get_status - returns the status of the watchdog</span>
<span class="cm"> *</span>
<span class="cm"> * returns a bitmask of defines WDIOF_... as defined in</span>
<span class="cm"> * include/linux/watchdog.h</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">wdrtas_get_status</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* TODO */</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * wdrtas_get_boot_status - returns the reason for the last boot</span>
<span class="cm"> *</span>
<span class="cm"> * returns a bitmask of defines WDIOF_... as defined in</span>
<span class="cm"> * include/linux/watchdog.h, indicating why the watchdog rebooted the system</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">wdrtas_get_boot_status</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* TODO */</span>
<span class="p">}</span>

<span class="cm">/*** watchdog API and operations stuff */</span>

<span class="cm">/* wdrtas_write - called when watchdog device is written to</span>
<span class="cm"> * @file: file structure</span>
<span class="cm"> * @buf: user buffer with data</span>
<span class="cm"> * @len: amount to data written</span>
<span class="cm"> * @ppos: position in file</span>
<span class="cm"> *</span>
<span class="cm"> * returns the number of successfully processed characters, which is always</span>
<span class="cm"> * the number of bytes passed to this function</span>
<span class="cm"> *</span>
<span class="cm"> * wdrtas_write processes all the data given to it and looks for the magic</span>
<span class="cm"> * character &#39;V&#39;. This character allows the watchdog device to be closed</span>
<span class="cm"> * properly.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">wdrtas_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
	     <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">c</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">len</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wdrtas_nowayout</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">wdrtas_expect_close</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="cm">/* look for &#39;V&#39; */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">buf</span> <span class="o">+</span> <span class="n">i</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="cm">/* allow to close device */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;V&#39;</span><span class="p">)</span>
				<span class="n">wdrtas_expect_close</span> <span class="o">=</span> <span class="n">WDRTAS_MAGIC_CHAR</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">wdrtas_timer_keepalive</span><span class="p">();</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * wdrtas_ioctl - ioctl function for the watchdog device</span>
<span class="cm"> * @file: file structure</span>
<span class="cm"> * @cmd: command for ioctl</span>
<span class="cm"> * @arg: argument pointer</span>
<span class="cm"> *</span>
<span class="cm"> * returns 0 on success, &lt;0 on failure</span>
<span class="cm"> *</span>
<span class="cm"> * wdrtas_ioctl implements the watchdog API ioctls</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">long</span> <span class="nf">wdrtas_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span>
							<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">argp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">watchdog_info</span> <span class="n">wdinfo</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">options</span> <span class="o">=</span> <span class="n">WDRTAS_SUPPORTED_MASK</span><span class="p">,</span>
		<span class="p">.</span><span class="n">firmware_version</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
		<span class="p">.</span><span class="n">identity</span> <span class="o">=</span> <span class="s">&quot;wdrtas&quot;</span><span class="p">,</span>
	<span class="p">};</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">WDIOC_GETSUPPORT</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">argp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wdinfo</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">wdinfo</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">WDIOC_GETSTATUS</span>:
		<span class="n">i</span> <span class="o">=</span> <span class="n">wdrtas_get_status</span><span class="p">();</span>
		<span class="k">return</span> <span class="n">put_user</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">argp</span><span class="p">);</span>

	<span class="k">case</span> <span class="n">WDIOC_GETBOOTSTATUS</span>:
		<span class="n">i</span> <span class="o">=</span> <span class="n">wdrtas_get_boot_status</span><span class="p">();</span>
		<span class="k">return</span> <span class="n">put_user</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">argp</span><span class="p">);</span>

	<span class="k">case</span> <span class="n">WDIOC_GETTEMP</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">wdrtas_token_get_sensor_state</span> <span class="o">==</span> <span class="n">RTAS_UNKNOWN_SERVICE</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

		<span class="n">i</span> <span class="o">=</span> <span class="n">wdrtas_get_temperature</span><span class="p">();</span>
		<span class="k">return</span> <span class="n">put_user</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">argp</span><span class="p">);</span>

	<span class="k">case</span> <span class="n">WDIOC_SETOPTIONS</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">argp</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&amp;</span> <span class="n">WDIOS_DISABLECARD</span><span class="p">)</span>
			<span class="n">wdrtas_timer_stop</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&amp;</span> <span class="n">WDIOS_ENABLECARD</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">wdrtas_timer_keepalive</span><span class="p">();</span>
			<span class="n">wdrtas_timer_start</span><span class="p">();</span>
		<span class="p">}</span>
		<span class="cm">/* not implemented. Done by H8</span>
<span class="cm">		if (i &amp; WDIOS_TEMPPANIC) {</span>
<span class="cm">		} */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">WDIOC_KEEPALIVE</span>:
		<span class="n">wdrtas_timer_keepalive</span><span class="p">();</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">WDIOC_SETTIMEOUT</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">argp</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">wdrtas_set_interval</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="n">wdrtas_timer_keepalive</span><span class="p">();</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">wdrtas_token_get_sp</span> <span class="o">==</span> <span class="n">RTAS_UNKNOWN_SERVICE</span><span class="p">)</span>
			<span class="n">wdrtas_interval</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">wdrtas_interval</span> <span class="o">=</span> <span class="n">wdrtas_get_interval</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
		<span class="cm">/* fallthrough */</span>

	<span class="k">case</span> <span class="n">WDIOC_GETTIMEOUT</span>:
		<span class="k">return</span> <span class="n">put_user</span><span class="p">(</span><span class="n">wdrtas_interval</span><span class="p">,</span> <span class="n">argp</span><span class="p">);</span>

	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * wdrtas_open - open function of watchdog device</span>
<span class="cm"> * @inode: inode structure</span>
<span class="cm"> * @file: file structure</span>
<span class="cm"> *</span>
<span class="cm"> * returns 0 on success, -EBUSY if the file has been opened already, &lt;0 on</span>
<span class="cm"> * other failures</span>
<span class="cm"> *</span>
<span class="cm"> * function called when watchdog device is opened</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">wdrtas_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* only open once */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_inc_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wdrtas_miscdev_open</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wdrtas_miscdev_open</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">wdrtas_timer_start</span><span class="p">();</span>
	<span class="n">wdrtas_timer_keepalive</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">nonseekable_open</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * wdrtas_close - close function of watchdog device</span>
<span class="cm"> * @inode: inode structure</span>
<span class="cm"> * @file: file structure</span>
<span class="cm"> *</span>
<span class="cm"> * returns 0 on success</span>
<span class="cm"> *</span>
<span class="cm"> * close function. Always succeeds</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">wdrtas_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* only stop watchdog, if this was announced using &#39;V&#39; before */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wdrtas_expect_close</span> <span class="o">==</span> <span class="n">WDRTAS_MAGIC_CHAR</span><span class="p">)</span>
		<span class="n">wdrtas_timer_stop</span><span class="p">();</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;got unexpected close. Watchdog not stopped.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">wdrtas_timer_keepalive</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">wdrtas_expect_close</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wdrtas_miscdev_open</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * wdrtas_temp_read - gives back the temperature in fahrenheit</span>
<span class="cm"> * @file: file structure</span>
<span class="cm"> * @buf: user buffer</span>
<span class="cm"> * @count: number of bytes to be read</span>
<span class="cm"> * @ppos: position in file</span>
<span class="cm"> *</span>
<span class="cm"> * returns always 1 or -EFAULT in case of user space copy failures, &lt;0 on</span>
<span class="cm"> * other failures</span>
<span class="cm"> *</span>
<span class="cm"> * wdrtas_temp_read gives the temperature to the users by copying this</span>
<span class="cm"> * value as one byte into the user space buffer. The unit is Fahrenheit...</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">wdrtas_temp_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
		 <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">temperature</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">temperature</span> <span class="o">=</span> <span class="n">wdrtas_get_temperature</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">temperature</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">temperature</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">temperature</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * wdrtas_temp_open - open function of temperature device</span>
<span class="cm"> * @inode: inode structure</span>
<span class="cm"> * @file: file structure</span>
<span class="cm"> *</span>
<span class="cm"> * returns 0 on success, &lt;0 on failure</span>
<span class="cm"> *</span>
<span class="cm"> * function called when temperature device is opened</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">wdrtas_temp_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">nonseekable_open</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * wdrtas_temp_close - close function of temperature device</span>
<span class="cm"> * @inode: inode structure</span>
<span class="cm"> * @file: file structure</span>
<span class="cm"> *</span>
<span class="cm"> * returns 0 on success</span>
<span class="cm"> *</span>
<span class="cm"> * close function. Always succeeds</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">wdrtas_temp_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * wdrtas_reboot - reboot notifier function</span>
<span class="cm"> * @nb: notifier block structure</span>
<span class="cm"> * @code: reboot code</span>
<span class="cm"> * @ptr: unused</span>
<span class="cm"> *</span>
<span class="cm"> * returns NOTIFY_DONE</span>
<span class="cm"> *</span>
<span class="cm"> * wdrtas_reboot stops the watchdog in case of a reboot</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">wdrtas_reboot</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">this</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">code</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">code</span> <span class="o">==</span> <span class="n">SYS_DOWN</span> <span class="o">||</span> <span class="n">code</span> <span class="o">==</span> <span class="n">SYS_HALT</span><span class="p">)</span>
		<span class="n">wdrtas_timer_stop</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">NOTIFY_DONE</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*** initialization stuff */</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">wdrtas_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">no_llseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">wdrtas_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unlocked_ioctl</span>	<span class="o">=</span> <span class="n">wdrtas_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">wdrtas_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">wdrtas_close</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">miscdevice</span> <span class="n">wdrtas_miscdev</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">minor</span> <span class="o">=</span>	<span class="n">WATCHDOG_MINOR</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span>		<span class="s">&quot;watchdog&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fops</span> <span class="o">=</span>		<span class="o">&amp;</span><span class="n">wdrtas_fops</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">wdrtas_temp_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">no_llseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">wdrtas_temp_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">wdrtas_temp_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">wdrtas_temp_close</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">miscdevice</span> <span class="n">wdrtas_tempdev</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">minor</span> <span class="o">=</span>	<span class="n">TEMP_MINOR</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span>		<span class="s">&quot;temperature&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fops</span> <span class="o">=</span>		<span class="o">&amp;</span><span class="n">wdrtas_temp_fops</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">wdrtas_notifier</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">notifier_call</span> <span class="o">=</span>	<span class="n">wdrtas_reboot</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * wdrtas_get_tokens - reads in RTAS tokens</span>
<span class="cm"> *</span>
<span class="cm"> * returns 0 on success, &lt;0 on failure</span>
<span class="cm"> *</span>
<span class="cm"> * wdrtas_get_tokens reads in the tokens for the RTAS calls used in</span>
<span class="cm"> * this watchdog driver. It tolerates, if &quot;get-sensor-state&quot; and</span>
<span class="cm"> * &quot;ibm,get-system-parameter&quot; are not available.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">wdrtas_get_tokens</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">wdrtas_token_get_sensor_state</span> <span class="o">=</span> <span class="n">rtas_token</span><span class="p">(</span><span class="s">&quot;get-sensor-state&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wdrtas_token_get_sensor_state</span> <span class="o">==</span> <span class="n">RTAS_UNKNOWN_SERVICE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;couldn&#39;t get token for get-sensor-state. Trying to continue without temperature support.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">wdrtas_token_get_sp</span> <span class="o">=</span> <span class="n">rtas_token</span><span class="p">(</span><span class="s">&quot;ibm,get-system-parameter&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wdrtas_token_get_sp</span> <span class="o">==</span> <span class="n">RTAS_UNKNOWN_SERVICE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;couldn&#39;t get token for ibm,get-system-parameter. Trying to continue with a default timeout value of %i seconds.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">WDRTAS_DEFAULT_INTERVAL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">wdrtas_token_set_indicator</span> <span class="o">=</span> <span class="n">rtas_token</span><span class="p">(</span><span class="s">&quot;set-indicator&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wdrtas_token_set_indicator</span> <span class="o">==</span> <span class="n">RTAS_UNKNOWN_SERVICE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;couldn&#39;t get token for set-indicator. Terminating watchdog code.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">wdrtas_token_event_scan</span> <span class="o">=</span> <span class="n">rtas_token</span><span class="p">(</span><span class="s">&quot;event-scan&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wdrtas_token_event_scan</span> <span class="o">==</span> <span class="n">RTAS_UNKNOWN_SERVICE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;couldn&#39;t get token for event-scan. Terminating watchdog code.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * wdrtas_unregister_devs - unregisters the misc dev handlers</span>
<span class="cm"> *</span>
<span class="cm"> * wdrtas_register_devs unregisters the watchdog and temperature watchdog</span>
<span class="cm"> * misc devs</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">wdrtas_unregister_devs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">misc_deregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wdrtas_miscdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wdrtas_token_get_sensor_state</span> <span class="o">!=</span> <span class="n">RTAS_UNKNOWN_SERVICE</span><span class="p">)</span>
		<span class="n">misc_deregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wdrtas_tempdev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * wdrtas_register_devs - registers the misc dev handlers</span>
<span class="cm"> *</span>
<span class="cm"> * returns 0 on success, &lt;0 on failure</span>
<span class="cm"> *</span>
<span class="cm"> * wdrtas_register_devs registers the watchdog and temperature watchdog</span>
<span class="cm"> * misc devs</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">wdrtas_register_devs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">misc_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wdrtas_miscdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;couldn&#39;t register watchdog misc device. Terminating watchdog code.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wdrtas_token_get_sensor_state</span> <span class="o">!=</span> <span class="n">RTAS_UNKNOWN_SERVICE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">misc_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wdrtas_tempdev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;couldn&#39;t register watchdog temperature misc device. Continuing without temperature support.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">wdrtas_token_get_sensor_state</span> <span class="o">=</span> <span class="n">RTAS_UNKNOWN_SERVICE</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * wdrtas_init - init function of the watchdog driver</span>
<span class="cm"> *</span>
<span class="cm"> * returns 0 on success, &lt;0 on failure</span>
<span class="cm"> *</span>
<span class="cm"> * registers the file handlers and the reboot notifier</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">wdrtas_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wdrtas_get_tokens</span><span class="p">())</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wdrtas_register_devs</span><span class="p">())</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">register_reboot_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wdrtas_notifier</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;could not register reboot notifier. Terminating watchdog code.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">wdrtas_unregister_devs</span><span class="p">();</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wdrtas_token_get_sp</span> <span class="o">==</span> <span class="n">RTAS_UNKNOWN_SERVICE</span><span class="p">)</span>
		<span class="n">wdrtas_interval</span> <span class="o">=</span> <span class="n">WDRTAS_DEFAULT_INTERVAL</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">wdrtas_interval</span> <span class="o">=</span> <span class="n">wdrtas_get_interval</span><span class="p">(</span><span class="n">WDRTAS_DEFAULT_INTERVAL</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * wdrtas_exit - exit function of the watchdog driver</span>
<span class="cm"> *</span>
<span class="cm"> * unregisters the file handlers and the reboot notifier</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">wdrtas_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wdrtas_nowayout</span><span class="p">)</span>
		<span class="n">wdrtas_timer_stop</span><span class="p">();</span>

	<span class="n">wdrtas_unregister_devs</span><span class="p">();</span>

	<span class="n">unregister_reboot_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wdrtas_notifier</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">wdrtas_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">wdrtas_exit</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
