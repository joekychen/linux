<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › watchdog › intel_scu_watchdog.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>intel_scu_watchdog.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *      Intel_SCU 0.2:  An Intel SCU IOH Based Watchdog Device</span>
<span class="cm"> *			for Intel part #(s):</span>
<span class="cm"> *				- AF82MP20 PCH</span>
<span class="cm"> *</span>
<span class="cm"> *      Copyright (C) 2009-2010 Intel Corporation. All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> *      This program is free software; you can redistribute it and/or</span>
<span class="cm"> *      modify it under the terms of version 2 of the GNU General</span>
<span class="cm"> *      Public License as published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> *      This program is distributed in the hope that it will be</span>
<span class="cm"> *      useful, but WITHOUT ANY WARRANTY; without even the implied</span>
<span class="cm"> *      warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR</span>
<span class="cm"> *      PURPOSE.  See the GNU General Public License for more details.</span>
<span class="cm"> *      You should have received a copy of the GNU General Public</span>
<span class="cm"> *      License along with this program; if not, write to the Free</span>
<span class="cm"> *      Software Foundation, Inc., 59 Temple Place - Suite 330,</span>
<span class="cm"> *      Boston, MA  02111-1307, USA.</span>
<span class="cm"> *      The full GNU General Public License is included in this</span>
<span class="cm"> *      distribution in the file called COPYING.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#define pr_fmt(fmt) KBUILD_MODNAME &quot;: &quot; fmt</span>

<span class="cp">#include &lt;linux/compiler.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/moduleparam.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/miscdevice.h&gt;</span>
<span class="cp">#include &lt;linux/watchdog.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/notifier.h&gt;</span>
<span class="cp">#include &lt;linux/reboot.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/jiffies.h&gt;</span>
<span class="cp">#include &lt;linux/uaccess.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/signal.h&gt;</span>
<span class="cp">#include &lt;linux/sfi.h&gt;</span>
<span class="cp">#include &lt;asm/irq.h&gt;</span>
<span class="cp">#include &lt;linux/atomic.h&gt;</span>
<span class="cp">#include &lt;asm/intel_scu_ipc.h&gt;</span>
<span class="cp">#include &lt;asm/apb_timer.h&gt;</span>
<span class="cp">#include &lt;asm/mrst.h&gt;</span>

<span class="cp">#include &quot;intel_scu_watchdog.h&quot;</span>

<span class="cm">/* Bounds number of times we will retry loading time count */</span>
<span class="cm">/* This retry is a work around for a silicon bug.	   */</span>
<span class="cp">#define MAX_RETRY 16</span>

<span class="cp">#define IPC_SET_WATCHDOG_TIMER	0xF8</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">timer_margin</span> <span class="o">=</span> <span class="n">DEFAULT_SOFT_TO_HARD_MARGIN</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">timer_margin</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">timer_margin</span><span class="p">,</span>
		<span class="s">&quot;Watchdog timer margin&quot;</span>
		<span class="s">&quot;Time between interrupt and resetting the system&quot;</span>
		<span class="s">&quot;The range is from 1 to 160&quot;</span>
		<span class="s">&quot;This is the time for all keep alives to arrive&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">timer_set</span> <span class="o">=</span> <span class="n">DEFAULT_TIME</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">timer_set</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">timer_set</span><span class="p">,</span>
		<span class="s">&quot;Default Watchdog timer setting&quot;</span>
		<span class="s">&quot;Complete cycle time&quot;</span>
		<span class="s">&quot;The range is from 1 to 170&quot;</span>
		<span class="s">&quot;This is the time for all keep alives to arrive&quot;</span><span class="p">);</span>

<span class="cm">/* After watchdog device is closed, check force_boot. If:</span>
<span class="cm"> * force_boot == 0, then force boot on next watchdog interrupt after close,</span>
<span class="cm"> * force_boot == 1, then force boot immediately when device is closed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">force_boot</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">force_boot</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">force_boot</span><span class="p">,</span>
		<span class="s">&quot;A value of 1 means that the driver will reboot&quot;</span>
		<span class="s">&quot;the system immediately if the /dev/watchdog device is closed&quot;</span>
		<span class="s">&quot;A value of 0 means that when /dev/watchdog device is closed&quot;</span>
		<span class="s">&quot;the watchdog timer will be refreshed for one more interval&quot;</span>
		<span class="s">&quot;of length: timer_set. At the end of this interval, the&quot;</span>
		<span class="s">&quot;watchdog timer will reset the system.&quot;</span>
		<span class="p">);</span>

<span class="cm">/* there is only one device in the system now; this can be made into</span>
<span class="cm"> * an array in the future if we have more than one device */</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">intel_scu_watchdog_dev</span> <span class="n">watchdog_device</span><span class="p">;</span>

<span class="cm">/* Forces restart, if force_reboot is set */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">watchdog_fire</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">force_boot</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_crit</span><span class="p">(</span><span class="s">&quot;Initiating system reboot</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">emergency_restart</span><span class="p">();</span>
		<span class="n">pr_crit</span><span class="p">(</span><span class="s">&quot;Reboot didn&#39;t ?????</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">else</span> <span class="p">{</span>
		<span class="n">pr_crit</span><span class="p">(</span><span class="s">&quot;Immediate Reboot Disabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">pr_crit</span><span class="p">(</span><span class="s">&quot;System will reset when watchdog timer times out!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">check_timer_margin</span><span class="p">(</span><span class="kt">int</span> <span class="n">new_margin</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">new_margin</span> <span class="o">&lt;</span> <span class="n">MIN_TIME_CYCLE</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">new_margin</span> <span class="o">&gt;</span> <span class="n">MAX_TIME</span> <span class="o">-</span> <span class="n">timer_set</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;value of new_margin %d is out of the range %d to %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">new_margin</span><span class="p">,</span> <span class="n">MIN_TIME_CYCLE</span><span class="p">,</span> <span class="n">MAX_TIME</span> <span class="o">-</span> <span class="n">timer_set</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * IPC operations</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">watchdog_set_ipc</span><span class="p">(</span><span class="kt">int</span> <span class="n">soft_threshold</span><span class="p">,</span> <span class="kt">int</span> <span class="n">threshold</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span>	<span class="o">*</span><span class="n">ipc_wbuf</span><span class="p">;</span>
	<span class="n">u8</span>	 <span class="n">cbuf</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="sc">&#39;\0&#39;</span> <span class="p">};</span>
	<span class="kt">int</span>	 <span class="n">ipc_ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ipc_wbuf</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">cbuf</span><span class="p">;</span>
	<span class="n">ipc_wbuf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">soft_threshold</span><span class="p">;</span>
	<span class="n">ipc_wbuf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">threshold</span><span class="p">;</span>

	<span class="n">ipc_ret</span> <span class="o">=</span> <span class="n">intel_scu_ipc_command</span><span class="p">(</span>
			<span class="n">IPC_SET_WATCHDOG_TIMER</span><span class="p">,</span>
			<span class="mi">0</span><span class="p">,</span>
			<span class="n">ipc_wbuf</span><span class="p">,</span>
			<span class="mi">2</span><span class="p">,</span>
			<span class="nb">NULL</span><span class="p">,</span>
			<span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ipc_ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Error setting SCU watchdog timer: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ipc_ret</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ipc_ret</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *      Intel_SCU operations</span>
<span class="cm"> */</span>

<span class="cm">/* timer interrupt handler */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">watchdog_timer_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">int_status</span><span class="p">;</span>
	<span class="n">int_status</span> <span class="o">=</span> <span class="n">ioread32</span><span class="p">(</span><span class="n">watchdog_device</span><span class="p">.</span><span class="n">timer_interrupt_status_addr</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;irq, int_status: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">int_status</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">int_status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>

	<span class="cm">/* has the timer been started? If not, then this is spurious */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">watchdog_device</span><span class="p">.</span><span class="n">timer_started</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;spurious interrupt received</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* temporarily disable the timer */</span>
	<span class="n">iowrite32</span><span class="p">(</span><span class="mh">0x00000002</span><span class="p">,</span> <span class="n">watchdog_device</span><span class="p">.</span><span class="n">timer_control_addr</span><span class="p">);</span>

	<span class="cm">/* set the timer to the threshold */</span>
	<span class="n">iowrite32</span><span class="p">(</span><span class="n">watchdog_device</span><span class="p">.</span><span class="n">threshold</span><span class="p">,</span>
		  <span class="n">watchdog_device</span><span class="p">.</span><span class="n">timer_load_count_addr</span><span class="p">);</span>

	<span class="cm">/* allow the timer to run */</span>
	<span class="n">iowrite32</span><span class="p">(</span><span class="mh">0x00000003</span><span class="p">,</span> <span class="n">watchdog_device</span><span class="p">.</span><span class="n">timer_control_addr</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">intel_scu_keepalive</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>

	<span class="cm">/* read eoi register - clears interrupt */</span>
	<span class="n">ioread32</span><span class="p">(</span><span class="n">watchdog_device</span><span class="p">.</span><span class="n">timer_clear_interrupt_addr</span><span class="p">);</span>

	<span class="cm">/* temporarily disable the timer */</span>
	<span class="n">iowrite32</span><span class="p">(</span><span class="mh">0x00000002</span><span class="p">,</span> <span class="n">watchdog_device</span><span class="p">.</span><span class="n">timer_control_addr</span><span class="p">);</span>

	<span class="cm">/* set the timer to the soft_threshold */</span>
	<span class="n">iowrite32</span><span class="p">(</span><span class="n">watchdog_device</span><span class="p">.</span><span class="n">soft_threshold</span><span class="p">,</span>
		  <span class="n">watchdog_device</span><span class="p">.</span><span class="n">timer_load_count_addr</span><span class="p">);</span>

	<span class="cm">/* allow the timer to run */</span>
	<span class="n">iowrite32</span><span class="p">(</span><span class="mh">0x00000003</span><span class="p">,</span> <span class="n">watchdog_device</span><span class="p">.</span><span class="n">timer_control_addr</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">intel_scu_stop</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">iowrite32</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">watchdog_device</span><span class="p">.</span><span class="n">timer_control_addr</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">intel_scu_set_heartbeat</span><span class="p">(</span><span class="n">u32</span> <span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>			 <span class="n">ipc_ret</span><span class="p">;</span>
	<span class="kt">int</span>			 <span class="n">retry_count</span><span class="p">;</span>
	<span class="n">u32</span>			 <span class="n">soft_value</span><span class="p">;</span>
	<span class="n">u32</span>			 <span class="n">hw_pre_value</span><span class="p">;</span>
	<span class="n">u32</span>			 <span class="n">hw_value</span><span class="p">;</span>

	<span class="n">watchdog_device</span><span class="p">.</span><span class="n">timer_set</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
	<span class="n">watchdog_device</span><span class="p">.</span><span class="n">threshold</span> <span class="o">=</span>
		<span class="n">timer_margin</span> <span class="o">*</span> <span class="n">watchdog_device</span><span class="p">.</span><span class="n">timer_tbl_ptr</span><span class="o">-&gt;</span><span class="n">freq_hz</span><span class="p">;</span>
	<span class="n">watchdog_device</span><span class="p">.</span><span class="n">soft_threshold</span> <span class="o">=</span>
		<span class="p">(</span><span class="n">watchdog_device</span><span class="p">.</span><span class="n">timer_set</span> <span class="o">-</span> <span class="n">timer_margin</span><span class="p">)</span>
		<span class="o">*</span> <span class="n">watchdog_device</span><span class="p">.</span><span class="n">timer_tbl_ptr</span><span class="o">-&gt;</span><span class="n">freq_hz</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;set_heartbeat: timer freq is %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">watchdog_device</span><span class="p">.</span><span class="n">timer_tbl_ptr</span><span class="o">-&gt;</span><span class="n">freq_hz</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;set_heartbeat: timer_set is %x (hex)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">watchdog_device</span><span class="p">.</span><span class="n">timer_set</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;set_hearbeat: timer_margin is %x (hex)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">timer_margin</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;set_heartbeat: threshold is %x (hex)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">watchdog_device</span><span class="p">.</span><span class="n">threshold</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;set_heartbeat: soft_threshold is %x (hex)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">watchdog_device</span><span class="p">.</span><span class="n">soft_threshold</span><span class="p">);</span>

	<span class="cm">/* Adjust thresholds by FREQ_ADJUSTMENT factor, to make the */</span>
	<span class="cm">/* watchdog timing come out right. */</span>
	<span class="n">watchdog_device</span><span class="p">.</span><span class="n">threshold</span> <span class="o">=</span>
		<span class="n">watchdog_device</span><span class="p">.</span><span class="n">threshold</span> <span class="o">/</span> <span class="n">FREQ_ADJUSTMENT</span><span class="p">;</span>
	<span class="n">watchdog_device</span><span class="p">.</span><span class="n">soft_threshold</span> <span class="o">=</span>
		<span class="n">watchdog_device</span><span class="p">.</span><span class="n">soft_threshold</span> <span class="o">/</span> <span class="n">FREQ_ADJUSTMENT</span><span class="p">;</span>

	<span class="cm">/* temporarily disable the timer */</span>
	<span class="n">iowrite32</span><span class="p">(</span><span class="mh">0x00000002</span><span class="p">,</span> <span class="n">watchdog_device</span><span class="p">.</span><span class="n">timer_control_addr</span><span class="p">);</span>

	<span class="cm">/* send the threshold and soft_threshold via IPC to the processor */</span>
	<span class="n">ipc_ret</span> <span class="o">=</span> <span class="n">watchdog_set_ipc</span><span class="p">(</span><span class="n">watchdog_device</span><span class="p">.</span><span class="n">soft_threshold</span><span class="p">,</span>
				   <span class="n">watchdog_device</span><span class="p">.</span><span class="n">threshold</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ipc_ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Make sure the watchdog timer is stopped */</span>
		<span class="n">intel_scu_stop</span><span class="p">();</span>
		<span class="k">return</span> <span class="n">ipc_ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Soft Threshold set loop. Early versions of silicon did */</span>
	<span class="cm">/* not always set this count correctly.  This loop checks */</span>
	<span class="cm">/* the value and retries if it was not set correctly.     */</span>

	<span class="n">retry_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">soft_value</span> <span class="o">=</span> <span class="n">watchdog_device</span><span class="p">.</span><span class="n">soft_threshold</span> <span class="o">&amp;</span> <span class="mh">0xFFFF0000</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>

		<span class="cm">/* Make sure timer is stopped */</span>
		<span class="n">intel_scu_stop</span><span class="p">();</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">MAX_RETRY</span> <span class="o">&lt;</span> <span class="n">retry_count</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Unable to set timer value */</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Unable to set timer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* set the timer to the soft threshold */</span>
		<span class="n">iowrite32</span><span class="p">(</span><span class="n">watchdog_device</span><span class="p">.</span><span class="n">soft_threshold</span><span class="p">,</span>
			<span class="n">watchdog_device</span><span class="p">.</span><span class="n">timer_load_count_addr</span><span class="p">);</span>

		<span class="cm">/* read count value before starting timer */</span>
		<span class="n">hw_pre_value</span> <span class="o">=</span> <span class="n">ioread32</span><span class="p">(</span><span class="n">watchdog_device</span><span class="p">.</span><span class="n">timer_load_count_addr</span><span class="p">);</span>
		<span class="n">hw_pre_value</span> <span class="o">=</span> <span class="n">hw_pre_value</span> <span class="o">&amp;</span> <span class="mh">0xFFFF0000</span><span class="p">;</span>

		<span class="cm">/* Start the timer */</span>
		<span class="n">iowrite32</span><span class="p">(</span><span class="mh">0x00000003</span><span class="p">,</span> <span class="n">watchdog_device</span><span class="p">.</span><span class="n">timer_control_addr</span><span class="p">);</span>

		<span class="cm">/* read the value the time loaded into its count reg */</span>
		<span class="n">hw_value</span> <span class="o">=</span> <span class="n">ioread32</span><span class="p">(</span><span class="n">watchdog_device</span><span class="p">.</span><span class="n">timer_load_count_addr</span><span class="p">);</span>
		<span class="n">hw_value</span> <span class="o">=</span> <span class="n">hw_value</span> <span class="o">&amp;</span> <span class="mh">0xFFFF0000</span><span class="p">;</span>


	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">soft_value</span> <span class="o">!=</span> <span class="n">hw_value</span><span class="p">);</span>

	<span class="n">watchdog_device</span><span class="p">.</span><span class="n">timer_started</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * /dev/watchdog handling</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">intel_scu_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>

	<span class="cm">/* Set flag to indicate that watchdog device is open */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">watchdog_device</span><span class="p">.</span><span class="n">driver_open</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="cm">/* Check for reopen of driver. Reopens are not allowed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">watchdog_device</span><span class="p">.</span><span class="n">driver_closed</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">nonseekable_open</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">intel_scu_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * This watchdog should not be closed, after the timer</span>
<span class="cm">	 * is started with the WDIPC_SETTIMEOUT ioctl</span>
<span class="cm">	 * If force_boot is set watchdog_fire() will cause an</span>
<span class="cm">	 * immediate reset. If force_boot is not set, the watchdog</span>
<span class="cm">	 * timer is refreshed for one more interval. At the end</span>
<span class="cm">	 * of that interval, the watchdog timer will reset the system.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">watchdog_device</span><span class="p">.</span><span class="n">driver_open</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;intel_scu_release, without open</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">watchdog_device</span><span class="p">.</span><span class="n">timer_started</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Just close, since timer has not been started */</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;closed, without starting timer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pr_crit</span><span class="p">(</span><span class="s">&quot;Unexpected close of /dev/watchdog!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Since the timer was started, prevent future reopens */</span>
	<span class="n">watchdog_device</span><span class="p">.</span><span class="n">driver_closed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Refresh the timer for one more interval */</span>
	<span class="n">intel_scu_keepalive</span><span class="p">();</span>

	<span class="cm">/* Reboot system (if force_boot is set) */</span>
	<span class="n">watchdog_fire</span><span class="p">();</span>

	<span class="cm">/* We should only reach this point if force_boot is not set */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">intel_scu_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
			      <span class="kt">char</span> <span class="k">const</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			      <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span>
			      <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">watchdog_device</span><span class="p">.</span><span class="n">timer_started</span><span class="p">)</span>
		<span class="cm">/* Watchdog already started, keep it alive */</span>
		<span class="n">intel_scu_keepalive</span><span class="p">();</span>
	<span class="k">else</span>
		<span class="cm">/* Start watchdog with timer value set by init */</span>
		<span class="n">intel_scu_set_heartbeat</span><span class="p">(</span><span class="n">watchdog_device</span><span class="p">.</span><span class="n">timer_set</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">long</span> <span class="nf">intel_scu_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">argp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">__user</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">argp</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">new_margin</span><span class="p">;</span>


	<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">watchdog_info</span> <span class="n">ident</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">options</span> <span class="o">=</span>          <span class="n">WDIOF_SETTIMEOUT</span>
				    <span class="o">|</span> <span class="n">WDIOF_KEEPALIVEPING</span><span class="p">,</span>
		<span class="p">.</span><span class="n">firmware_version</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>  <span class="cm">/* @todo Get from SCU via</span>
<span class="cm">						 ipc_get_scu_fw_version()? */</span>
		<span class="p">.</span><span class="n">identity</span> <span class="o">=</span>         <span class="s">&quot;Intel_SCU IOH Watchdog&quot;</span>  <span class="cm">/* len &lt; 32 */</span>
	<span class="p">};</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">WDIOC_GETSUPPORT</span>:
		<span class="k">return</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">argp</span><span class="p">,</span>
				    <span class="o">&amp;</span><span class="n">ident</span><span class="p">,</span>
				    <span class="k">sizeof</span><span class="p">(</span><span class="n">ident</span><span class="p">))</span> <span class="o">?</span> <span class="o">-</span><span class="n">EFAULT</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">WDIOC_GETSTATUS</span>:
	<span class="k">case</span> <span class="n">WDIOC_GETBOOTSTATUS</span>:
		<span class="k">return</span> <span class="n">put_user</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">WDIOC_KEEPALIVE</span>:
		<span class="n">intel_scu_keepalive</span><span class="p">();</span>

		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">WDIOC_SETTIMEOUT</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">new_margin</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">check_timer_margin</span><span class="p">(</span><span class="n">new_margin</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">intel_scu_set_heartbeat</span><span class="p">(</span><span class="n">new_margin</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">WDIOC_GETTIMEOUT</span>:
		<span class="k">return</span> <span class="n">put_user</span><span class="p">(</span><span class="n">watchdog_device</span><span class="p">.</span><span class="n">soft_threshold</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>

	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *      Notifier for system down</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">intel_scu_notify_sys</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">this</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">code</span><span class="p">,</span>
			       <span class="kt">void</span> <span class="o">*</span><span class="n">another_unused</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">code</span> <span class="o">==</span> <span class="n">SYS_DOWN</span> <span class="o">||</span> <span class="n">code</span> <span class="o">==</span> <span class="n">SYS_HALT</span><span class="p">)</span>
		<span class="cm">/* Turn off the watchdog timer. */</span>
		<span class="n">intel_scu_stop</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">NOTIFY_DONE</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *      Kernel Interfaces</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">intel_scu_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>          <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>         <span class="o">=</span> <span class="n">no_llseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>          <span class="o">=</span> <span class="n">intel_scu_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unlocked_ioctl</span> <span class="o">=</span> <span class="n">intel_scu_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span>           <span class="o">=</span> <span class="n">intel_scu_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>        <span class="o">=</span> <span class="n">intel_scu_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">intel_scu_watchdog_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">tmp_addr</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We don&#39;t really need to check this as the SFI timer get will fail</span>
<span class="cm">	 * but if we do so we can exit with a clearer reason and no noise.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If it isn&#39;t an intel MID device then it doesn&#39;t have this watchdog</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mrst_identify_cpu</span><span class="p">())</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="cm">/* Check boot parameters to verify that their initial values */</span>
	<span class="cm">/* are in range. */</span>
	<span class="cm">/* Check value of timer_set boot parameter */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">timer_set</span> <span class="o">&lt;</span> <span class="n">MIN_TIME_CYCLE</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">timer_set</span> <span class="o">&gt;</span> <span class="n">MAX_TIME</span> <span class="o">-</span> <span class="n">MIN_TIME_CYCLE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;value of timer_set %x (hex) is out of range from %x to %x (hex)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">timer_set</span><span class="p">,</span> <span class="n">MIN_TIME_CYCLE</span><span class="p">,</span> <span class="n">MAX_TIME</span> <span class="o">-</span> <span class="n">MIN_TIME_CYCLE</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Check value of timer_margin boot parameter */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">check_timer_margin</span><span class="p">(</span><span class="n">timer_margin</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">watchdog_device</span><span class="p">.</span><span class="n">timer_tbl_ptr</span> <span class="o">=</span> <span class="n">sfi_get_mtmr</span><span class="p">(</span><span class="n">sfi_mtimer_num</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">watchdog_device</span><span class="p">.</span><span class="n">timer_tbl_ptr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;timer is not available</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* make sure the timer exists */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">watchdog_device</span><span class="p">.</span><span class="n">timer_tbl_ptr</span><span class="o">-&gt;</span><span class="n">phys_addr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;timer %d does not have valid physical memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">sfi_mtimer_num</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">watchdog_device</span><span class="p">.</span><span class="n">timer_tbl_ptr</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;timer %d invalid irq</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sfi_mtimer_num</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tmp_addr</span> <span class="o">=</span> <span class="n">ioremap_nocache</span><span class="p">(</span><span class="n">watchdog_device</span><span class="p">.</span><span class="n">timer_tbl_ptr</span><span class="o">-&gt;</span><span class="n">phys_addr</span><span class="p">,</span>
			<span class="mi">20</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tmp_addr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;timer unable to ioremap</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">watchdog_device</span><span class="p">.</span><span class="n">timer_load_count_addr</span> <span class="o">=</span> <span class="n">tmp_addr</span><span class="o">++</span><span class="p">;</span>
	<span class="n">watchdog_device</span><span class="p">.</span><span class="n">timer_current_value_addr</span> <span class="o">=</span> <span class="n">tmp_addr</span><span class="o">++</span><span class="p">;</span>
	<span class="n">watchdog_device</span><span class="p">.</span><span class="n">timer_control_addr</span> <span class="o">=</span> <span class="n">tmp_addr</span><span class="o">++</span><span class="p">;</span>
	<span class="n">watchdog_device</span><span class="p">.</span><span class="n">timer_clear_interrupt_addr</span> <span class="o">=</span> <span class="n">tmp_addr</span><span class="o">++</span><span class="p">;</span>
	<span class="n">watchdog_device</span><span class="p">.</span><span class="n">timer_interrupt_status_addr</span> <span class="o">=</span> <span class="n">tmp_addr</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* Set the default time values in device structure */</span>

	<span class="n">watchdog_device</span><span class="p">.</span><span class="n">timer_set</span> <span class="o">=</span> <span class="n">timer_set</span><span class="p">;</span>
	<span class="n">watchdog_device</span><span class="p">.</span><span class="n">threshold</span> <span class="o">=</span>
		<span class="n">timer_margin</span> <span class="o">*</span> <span class="n">watchdog_device</span><span class="p">.</span><span class="n">timer_tbl_ptr</span><span class="o">-&gt;</span><span class="n">freq_hz</span><span class="p">;</span>
	<span class="n">watchdog_device</span><span class="p">.</span><span class="n">soft_threshold</span> <span class="o">=</span>
		<span class="p">(</span><span class="n">watchdog_device</span><span class="p">.</span><span class="n">timer_set</span> <span class="o">-</span> <span class="n">timer_margin</span><span class="p">)</span>
		<span class="o">*</span> <span class="n">watchdog_device</span><span class="p">.</span><span class="n">timer_tbl_ptr</span><span class="o">-&gt;</span><span class="n">freq_hz</span><span class="p">;</span>


	<span class="n">watchdog_device</span><span class="p">.</span><span class="n">intel_scu_notifier</span><span class="p">.</span><span class="n">notifier_call</span> <span class="o">=</span>
		<span class="n">intel_scu_notify_sys</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">register_reboot_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">watchdog_device</span><span class="p">.</span><span class="n">intel_scu_notifier</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;cannot register notifier %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">register_reboot_error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">watchdog_device</span><span class="p">.</span><span class="n">miscdev</span><span class="p">.</span><span class="n">minor</span> <span class="o">=</span> <span class="n">WATCHDOG_MINOR</span><span class="p">;</span>
	<span class="n">watchdog_device</span><span class="p">.</span><span class="n">miscdev</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;watchdog&quot;</span><span class="p">;</span>
	<span class="n">watchdog_device</span><span class="p">.</span><span class="n">miscdev</span><span class="p">.</span><span class="n">fops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">intel_scu_fops</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">misc_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">watchdog_device</span><span class="p">.</span><span class="n">miscdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;cannot register miscdev %d err =%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">WATCHDOG_MINOR</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">misc_register_error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">watchdog_device</span><span class="p">.</span><span class="n">timer_tbl_ptr</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span>
		<span class="n">watchdog_timer_interrupt</span><span class="p">,</span>
		<span class="n">IRQF_SHARED</span><span class="p">,</span> <span class="s">&quot;watchdog&quot;</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">watchdog_device</span><span class="p">.</span><span class="n">timer_load_count_addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;error requesting irq %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">request_irq_error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Make sure timer is disabled before returning */</span>
	<span class="n">intel_scu_stop</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="cm">/* error cleanup */</span>

<span class="nl">request_irq_error:</span>
	<span class="n">misc_deregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">watchdog_device</span><span class="p">.</span><span class="n">miscdev</span><span class="p">);</span>
<span class="nl">misc_register_error:</span>
	<span class="n">unregister_reboot_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">watchdog_device</span><span class="p">.</span><span class="n">intel_scu_notifier</span><span class="p">);</span>
<span class="nl">register_reboot_error:</span>
	<span class="n">intel_scu_stop</span><span class="p">();</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">watchdog_device</span><span class="p">.</span><span class="n">timer_load_count_addr</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">intel_scu_watchdog_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>

	<span class="n">misc_deregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">watchdog_device</span><span class="p">.</span><span class="n">miscdev</span><span class="p">);</span>
	<span class="n">unregister_reboot_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">watchdog_device</span><span class="p">.</span><span class="n">intel_scu_notifier</span><span class="p">);</span>
	<span class="cm">/* disable the timer */</span>
	<span class="n">iowrite32</span><span class="p">(</span><span class="mh">0x00000002</span><span class="p">,</span> <span class="n">watchdog_device</span><span class="p">.</span><span class="n">timer_control_addr</span><span class="p">);</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">watchdog_device</span><span class="p">.</span><span class="n">timer_load_count_addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">late_initcall</span><span class="p">(</span><span class="n">intel_scu_watchdog_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">intel_scu_watchdog_exit</span><span class="p">);</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Intel Corporation&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Intel SCU Watchdog Device Driver&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_ALIAS_MISCDEV</span><span class="p">(</span><span class="n">WATCHDOG_MINOR</span><span class="p">);</span>
<span class="n">MODULE_VERSION</span><span class="p">(</span><span class="n">WDT_VER</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
