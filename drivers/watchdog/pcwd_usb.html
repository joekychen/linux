<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › watchdog › pcwd_usb.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>pcwd_usb.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *	Berkshire USB-PC Watchdog Card Driver</span>
<span class="cm"> *</span>
<span class="cm"> *	(c) Copyright 2004-2007 Wim Van Sebroeck &lt;wim@iguana.be&gt;.</span>
<span class="cm"> *</span>
<span class="cm"> *	Based on source code of the following authors:</span>
<span class="cm"> *	  Ken Hollis &lt;kenji@bitgate.com&gt;,</span>
<span class="cm"> *	  Alan Cox &lt;alan@lxorguk.ukuu.org.uk&gt;,</span>
<span class="cm"> *	  Matt Domsch &lt;Matt_Domsch@dell.com&gt;,</span>
<span class="cm"> *	  Rob Radez &lt;rob@osinvestor.com&gt;,</span>
<span class="cm"> *	  Greg Kroah-Hartman &lt;greg@kroah.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *	This program is free software; you can redistribute it and/or</span>
<span class="cm"> *	modify it under the terms of the GNU General Public License</span>
<span class="cm"> *	as published by the Free Software Foundation; either version</span>
<span class="cm"> *	2 of the License, or (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *	Neither Wim Van Sebroeck nor Iguana vzw. admit liability nor</span>
<span class="cm"> *	provide warranty for any of this software. This material is</span>
<span class="cm"> *	provided &quot;AS-IS&quot; and at no charge.</span>
<span class="cm"> *</span>
<span class="cm"> *	Thanks also to Simon Machell at Berkshire Products Inc. for</span>
<span class="cm"> *	providing the test hardware. More info is available at</span>
<span class="cm"> *	http://www.berkprod.com/ or http://www.pcwatchdog.com/</span>
<span class="cm"> */</span>

<span class="cp">#define pr_fmt(fmt) KBUILD_MODNAME &quot;: &quot; fmt</span>

<span class="cp">#include &lt;linux/module.h&gt;	</span><span class="cm">/* For module specific items */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/moduleparam.h&gt;	</span><span class="cm">/* For new moduleparam&#39;s */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/types.h&gt;	</span><span class="cm">/* For standard types (like size_t) */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/errno.h&gt;	</span><span class="cm">/* For the -ENODEV/... values */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/kernel.h&gt;	</span><span class="cm">/* For printk/panic/... */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/delay.h&gt;	</span><span class="cm">/* For mdelay function */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/miscdevice.h&gt;	</span><span class="cm">/* For MODULE_ALIAS_MISCDEV(WATCHDOG_MINOR) */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/watchdog.h&gt;	</span><span class="cm">/* For the watchdog specific items */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/notifier.h&gt;	</span><span class="cm">/* For notifier support */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/reboot.h&gt;	</span><span class="cm">/* For reboot_notifier stuff */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/init.h&gt;		</span><span class="cm">/* For __init/__exit/... */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/fs.h&gt;		</span><span class="cm">/* For file operations */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/usb.h&gt;		</span><span class="cm">/* For USB functions */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/slab.h&gt;		</span><span class="cm">/* For kmalloc, ... */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/mutex.h&gt;	</span><span class="cm">/* For mutex locking */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/hid.h&gt;		</span><span class="cm">/* For HID_REQ_SET_REPORT &amp; HID_DT_REPORT */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/uaccess.h&gt;	</span><span class="cm">/* For copy_to_user/put_user/... */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_USB_DEBUG</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">debug</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">debug</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cm">/* Use our own dbg macro */</span>

<span class="cp">#undef dbg</span>
<span class="cp">#ifndef DEBUG</span>
<span class="cp">#define DEBUG</span>
<span class="cp">#endif</span>
<span class="cp">#define dbg(format, ...)				\</span>
<span class="cp">do {							\</span>
<span class="cp">	if (debug)					\</span>
<span class="cp">		pr_debug(format &quot;\n&quot;, ##__VA_ARGS__);	\</span>
<span class="cp">} while (0)</span>

<span class="cm">/* Module and Version Information */</span>
<span class="cp">#define DRIVER_VERSION &quot;1.02&quot;</span>
<span class="cp">#define DRIVER_AUTHOR &quot;Wim Van Sebroeck &lt;wim@iguana.be&gt;&quot;</span>
<span class="cp">#define DRIVER_DESC &quot;Berkshire USB-PC Watchdog driver&quot;</span>
<span class="cp">#define DRIVER_LICENSE &quot;GPL&quot;</span>
<span class="cp">#define DRIVER_NAME &quot;pcwd_usb&quot;</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="n">DRIVER_AUTHOR</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="n">DRIVER_DESC</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="n">DRIVER_LICENSE</span><span class="p">);</span>
<span class="n">MODULE_ALIAS_MISCDEV</span><span class="p">(</span><span class="n">WATCHDOG_MINOR</span><span class="p">);</span>
<span class="n">MODULE_ALIAS_MISCDEV</span><span class="p">(</span><span class="n">TEMP_MINOR</span><span class="p">);</span>

<span class="cm">/* Module Parameters */</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">debug</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">debug</span><span class="p">,</span> <span class="s">&quot;Debug enabled or not&quot;</span><span class="p">);</span>

<span class="cp">#define WATCHDOG_HEARTBEAT 0	</span><span class="cm">/* default heartbeat =</span>
<span class="cm">						delay-time from dip-switches */</span><span class="cp"></span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">heartbeat</span> <span class="o">=</span> <span class="n">WATCHDOG_HEARTBEAT</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">heartbeat</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">heartbeat</span><span class="p">,</span> <span class="s">&quot;Watchdog heartbeat in seconds. &quot;</span>
	<span class="s">&quot;(0&lt;heartbeat&lt;65536 or 0=delay-time from dip-switches, default=&quot;</span>
				<span class="n">__MODULE_STRING</span><span class="p">(</span><span class="n">WATCHDOG_HEARTBEAT</span><span class="p">)</span> <span class="s">&quot;)&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="n">bool</span> <span class="n">nowayout</span> <span class="o">=</span> <span class="n">WATCHDOG_NOWAYOUT</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">nowayout</span><span class="p">,</span> <span class="n">bool</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">nowayout</span><span class="p">,</span> <span class="s">&quot;Watchdog cannot be stopped once started (default=&quot;</span>
				<span class="n">__MODULE_STRING</span><span class="p">(</span><span class="n">WATCHDOG_NOWAYOUT</span><span class="p">)</span> <span class="s">&quot;)&quot;</span><span class="p">);</span>

<span class="cm">/* The vendor and product id&#39;s for the USB-PC Watchdog card */</span>
<span class="cp">#define USB_PCWD_VENDOR_ID	0x0c98</span>
<span class="cp">#define USB_PCWD_PRODUCT_ID	0x1140</span>

<span class="cm">/* table of devices that work with this driver */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">usb_device_id</span> <span class="n">usb_pcwd_table</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">USB_DEVICE</span><span class="p">(</span><span class="n">USB_PCWD_VENDOR_ID</span><span class="p">,</span> <span class="n">USB_PCWD_PRODUCT_ID</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="p">}</span>					<span class="cm">/* Terminating entry */</span>
<span class="p">};</span>
<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">usb</span><span class="p">,</span> <span class="n">usb_pcwd_table</span><span class="p">);</span>

<span class="cm">/* according to documentation max. time to process a command for the USB</span>
<span class="cm"> * watchdog card is 100 or 200 ms, so we give it 250 ms to do it&#39;s job */</span>
<span class="cp">#define USB_COMMAND_TIMEOUT	250</span>

<span class="cm">/* Watchdog&#39;s internal commands */</span>
<span class="cp">#define CMD_READ_TEMP			0x02	</span><span class="cm">/* Read Temperature;</span>
<span class="cm">							Re-trigger Watchdog */</span><span class="cp"></span>
<span class="cp">#define CMD_TRIGGER			CMD_READ_TEMP</span>
<span class="cp">#define CMD_GET_STATUS			0x04	</span><span class="cm">/* Get Status Information */</span><span class="cp"></span>
<span class="cp">#define CMD_GET_FIRMWARE_VERSION	0x08	</span><span class="cm">/* Get Firmware Version */</span><span class="cp"></span>
<span class="cp">#define CMD_GET_DIP_SWITCH_SETTINGS	0x0c	</span><span class="cm">/* Get Dip Switch Settings */</span><span class="cp"></span>
<span class="cp">#define CMD_READ_WATCHDOG_TIMEOUT	0x18	</span><span class="cm">/* Read Current Watchdog Time */</span><span class="cp"></span>
<span class="cp">#define CMD_WRITE_WATCHDOG_TIMEOUT	0x19	</span><span class="cm">/* Write Current WatchdogTime */</span><span class="cp"></span>
<span class="cp">#define CMD_ENABLE_WATCHDOG		0x30	</span><span class="cm">/* Enable / Disable Watchdog */</span><span class="cp"></span>
<span class="cp">#define CMD_DISABLE_WATCHDOG		CMD_ENABLE_WATCHDOG</span>

<span class="cm">/* Watchdog&#39;s Dip Switch heartbeat values */</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">heartbeat_tbl</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="mi">5</span><span class="p">,</span>	<span class="cm">/* OFF-OFF-OFF	=  5 Sec  */</span>
	<span class="mi">10</span><span class="p">,</span>	<span class="cm">/* OFF-OFF-ON	= 10 Sec  */</span>
	<span class="mi">30</span><span class="p">,</span>	<span class="cm">/* OFF-ON-OFF	= 30 Sec  */</span>
	<span class="mi">60</span><span class="p">,</span>	<span class="cm">/* OFF-ON-ON	=  1 Min  */</span>
	<span class="mi">300</span><span class="p">,</span>	<span class="cm">/* ON-OFF-OFF	=  5 Min  */</span>
	<span class="mi">600</span><span class="p">,</span>	<span class="cm">/* ON-OFF-ON	= 10 Min  */</span>
	<span class="mi">1800</span><span class="p">,</span>	<span class="cm">/* ON-ON-OFF	= 30 Min  */</span>
	<span class="mi">3600</span><span class="p">,</span>	<span class="cm">/* ON-ON-ON	=  1 hour */</span>
<span class="p">};</span>

<span class="cm">/* We can only use 1 card due to the /dev/watchdog restriction */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">cards_found</span><span class="p">;</span>

<span class="cm">/* some internal variables */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">is_active</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">char</span> <span class="n">expect_release</span><span class="p">;</span>

<span class="cm">/* Structure to hold all of our device specific stuff */</span>
<span class="k">struct</span> <span class="n">usb_pcwd_private</span> <span class="p">{</span>
	<span class="cm">/* save off the usb device pointer */</span>
	<span class="k">struct</span> <span class="n">usb_device</span>	<span class="o">*</span><span class="n">udev</span><span class="p">;</span>
	<span class="cm">/* the interface for this device */</span>
	<span class="k">struct</span> <span class="n">usb_interface</span>	<span class="o">*</span><span class="n">interface</span><span class="p">;</span>

	<span class="cm">/* the interface number used for cmd&#39;s */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">interface_number</span><span class="p">;</span>

	<span class="cm">/* the buffer to intr data */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="o">*</span><span class="n">intr_buffer</span><span class="p">;</span>
	<span class="cm">/* the dma address for the intr buffer */</span>
	<span class="n">dma_addr_t</span>		<span class="n">intr_dma</span><span class="p">;</span>
	<span class="cm">/* the size of the intr buffer */</span>
	<span class="kt">size_t</span>			<span class="n">intr_size</span><span class="p">;</span>
	<span class="cm">/* the urb used for the intr pipe */</span>
	<span class="k">struct</span> <span class="n">urb</span>		<span class="o">*</span><span class="n">intr_urb</span><span class="p">;</span>

	<span class="cm">/* The command that is reported back */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">cmd_command</span><span class="p">;</span>
	<span class="cm">/* The data MSB that is reported back */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">cmd_data_msb</span><span class="p">;</span>
	<span class="cm">/* The data LSB that is reported back */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">cmd_data_lsb</span><span class="p">;</span>
	<span class="cm">/* true if we received a report after a command */</span>
	<span class="n">atomic_t</span>		<span class="n">cmd_received</span><span class="p">;</span>

	<span class="cm">/* Wether or not the device exists */</span>
	<span class="kt">int</span>			<span class="n">exists</span><span class="p">;</span>
	<span class="cm">/* locks this structure */</span>
	<span class="k">struct</span> <span class="n">mutex</span>		<span class="n">mtx</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">usb_pcwd_private</span> <span class="o">*</span><span class="n">usb_pcwd_device</span><span class="p">;</span>

<span class="cm">/* prevent races between open() and disconnect() */</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">disconnect_mutex</span><span class="p">);</span>

<span class="cm">/* local function prototypes */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">usb_pcwd_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">interface</span><span class="p">,</span>
						<span class="k">const</span> <span class="k">struct</span> <span class="n">usb_device_id</span> <span class="o">*</span><span class="n">id</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">usb_pcwd_disconnect</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">interface</span><span class="p">);</span>

<span class="cm">/* usb specific object needed to register this driver with the usb subsystem */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">usb_driver</span> <span class="n">usb_pcwd_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span>		<span class="n">DRIVER_NAME</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span> <span class="o">=</span>	<span class="n">usb_pcwd_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">disconnect</span> <span class="o">=</span>	<span class="n">usb_pcwd_disconnect</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_table</span> <span class="o">=</span>	<span class="n">usb_pcwd_table</span><span class="p">,</span>
<span class="p">};</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">usb_pcwd_intr_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_pcwd_private</span> <span class="o">*</span><span class="n">usb_pcwd</span> <span class="o">=</span>
				<span class="p">(</span><span class="k">struct</span> <span class="n">usb_pcwd_private</span> <span class="o">*</span><span class="p">)</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">usb_pcwd</span><span class="o">-&gt;</span><span class="n">intr_buffer</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:			<span class="cm">/* success */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">ECONNRESET</span>:	<span class="cm">/* unlink */</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">ENOENT</span>:
	<span class="k">case</span> <span class="o">-</span><span class="n">ESHUTDOWN</span>:
		<span class="cm">/* this urb is terminated, clean up */</span>
		<span class="n">dbg</span><span class="p">(</span><span class="s">&quot;%s - urb shutting down with status: %d&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
								<span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="cm">/* -EPIPE:  should clear the halt */</span>
	<span class="nl">default:</span>		<span class="cm">/* error */</span>
		<span class="n">dbg</span><span class="p">(</span><span class="s">&quot;%s - nonzero urb status received: %d&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
								<span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">resubmit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dbg</span><span class="p">(</span><span class="s">&quot;received following data cmd=0x%02x msb=0x%02x lsb=0x%02x&quot;</span><span class="p">,</span>
		<span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>

	<span class="n">usb_pcwd</span><span class="o">-&gt;</span><span class="n">cmd_command</span>  <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">usb_pcwd</span><span class="o">-&gt;</span><span class="n">cmd_data_msb</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">usb_pcwd</span><span class="o">-&gt;</span><span class="n">cmd_data_lsb</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

	<span class="cm">/* notify anyone waiting that the cmd has finished */</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usb_pcwd</span><span class="o">-&gt;</span><span class="n">cmd_received</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

<span class="nl">resubmit:</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">usb_submit_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;can&#39;t resubmit intr, usb_submit_urb failed with result %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">retval</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usb_pcwd_send_command</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_pcwd_private</span> <span class="o">*</span><span class="n">usb_pcwd</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">lsb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">got_response</span><span class="p">,</span> <span class="n">count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>

	<span class="cm">/* We will not send any commands if the USB PCWD device does</span>
<span class="cm">	 * not exist */</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">usb_pcwd</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="n">usb_pcwd</span><span class="o">-&gt;</span><span class="n">exists</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* The USB PC Watchdog uses a 6 byte report format.</span>
<span class="cm">	 * The board currently uses only 3 of the six bytes of the report. */</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">;</span>			<span class="cm">/* Byte 0 = CMD */</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">*</span><span class="n">msb</span><span class="p">;</span>			<span class="cm">/* Byte 1 = Data MSB */</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="o">*</span><span class="n">lsb</span><span class="p">;</span>			<span class="cm">/* Byte 2 = Data LSB */</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">buf</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">buf</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* All other bytes not used */</span>

	<span class="n">dbg</span><span class="p">(</span><span class="s">&quot;sending following data cmd=0x%02x msb=0x%02x lsb=0x%02x&quot;</span><span class="p">,</span>
		<span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">buf</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>

	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usb_pcwd</span><span class="o">-&gt;</span><span class="n">cmd_received</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">usb_control_msg</span><span class="p">(</span><span class="n">usb_pcwd</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span> <span class="n">usb_sndctrlpipe</span><span class="p">(</span><span class="n">usb_pcwd</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
			<span class="n">HID_REQ_SET_REPORT</span><span class="p">,</span> <span class="n">HID_DT_REPORT</span><span class="p">,</span>
			<span class="mh">0x0200</span><span class="p">,</span> <span class="n">usb_pcwd</span><span class="o">-&gt;</span><span class="n">interface_number</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span>
			<span class="n">USB_COMMAND_TIMEOUT</span><span class="p">)</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dbg</span><span class="p">(</span><span class="s">&quot;usb_pcwd_send_command: error in usb_control_msg for &quot;</span>
				<span class="s">&quot;cmd 0x%x 0x%x 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="o">*</span><span class="n">msb</span><span class="p">,</span> <span class="o">*</span><span class="n">lsb</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* wait till the usb card processed the command,</span>
<span class="cm">	 * with a max. timeout of USB_COMMAND_TIMEOUT */</span>
	<span class="n">got_response</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">USB_COMMAND_TIMEOUT</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">got_response</span><span class="p">);</span>
								<span class="n">count</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mdelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usb_pcwd</span><span class="o">-&gt;</span><span class="n">cmd_received</span><span class="p">))</span>
			<span class="n">got_response</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">got_response</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">usb_pcwd</span><span class="o">-&gt;</span><span class="n">cmd_command</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* read back response */</span>
		<span class="o">*</span><span class="n">msb</span> <span class="o">=</span> <span class="n">usb_pcwd</span><span class="o">-&gt;</span><span class="n">cmd_data_msb</span><span class="p">;</span>
		<span class="o">*</span><span class="n">lsb</span> <span class="o">=</span> <span class="n">usb_pcwd</span><span class="o">-&gt;</span><span class="n">cmd_data_lsb</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">got_response</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usb_pcwd_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_pcwd_private</span> <span class="o">*</span><span class="n">usb_pcwd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">msb</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">lsb</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="cm">/* Enable Watchdog */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">usb_pcwd_send_command</span><span class="p">(</span><span class="n">usb_pcwd</span><span class="p">,</span> <span class="n">CMD_ENABLE_WATCHDOG</span><span class="p">,</span>
								<span class="o">&amp;</span><span class="n">msb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lsb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">retval</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">lsb</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Card did not acknowledge enable attempt</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usb_pcwd_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_pcwd_private</span> <span class="o">*</span><span class="n">usb_pcwd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">msb</span> <span class="o">=</span> <span class="mh">0xA5</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">lsb</span> <span class="o">=</span> <span class="mh">0xC3</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="cm">/* Disable Watchdog */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">usb_pcwd_send_command</span><span class="p">(</span><span class="n">usb_pcwd</span><span class="p">,</span> <span class="n">CMD_DISABLE_WATCHDOG</span><span class="p">,</span>
								<span class="o">&amp;</span><span class="n">msb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lsb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">retval</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">lsb</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Card did not acknowledge disable attempt</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usb_pcwd_keepalive</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_pcwd_private</span> <span class="o">*</span><span class="n">usb_pcwd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">dummy</span><span class="p">;</span>

	<span class="cm">/* Re-trigger Watchdog */</span>
	<span class="n">usb_pcwd_send_command</span><span class="p">(</span><span class="n">usb_pcwd</span><span class="p">,</span> <span class="n">CMD_TRIGGER</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dummy</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dummy</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usb_pcwd_set_heartbeat</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_pcwd_private</span> <span class="o">*</span><span class="n">usb_pcwd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">msb</span> <span class="o">=</span> <span class="n">t</span> <span class="o">/</span> <span class="mi">256</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">lsb</span> <span class="o">=</span> <span class="n">t</span> <span class="o">%</span> <span class="mi">256</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">t</span> <span class="o">&lt;</span> <span class="mh">0x0001</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">t</span> <span class="o">&gt;</span> <span class="mh">0xFFFF</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* Write new heartbeat to watchdog */</span>
	<span class="n">usb_pcwd_send_command</span><span class="p">(</span><span class="n">usb_pcwd</span><span class="p">,</span> <span class="n">CMD_WRITE_WATCHDOG_TIMEOUT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lsb</span><span class="p">);</span>

	<span class="n">heartbeat</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usb_pcwd_get_temperature</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_pcwd_private</span> <span class="o">*</span><span class="n">usb_pcwd</span><span class="p">,</span>
							<span class="kt">int</span> <span class="o">*</span><span class="n">temperature</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">msb</span><span class="p">,</span> <span class="n">lsb</span><span class="p">;</span>

	<span class="n">usb_pcwd_send_command</span><span class="p">(</span><span class="n">usb_pcwd</span><span class="p">,</span> <span class="n">CMD_READ_TEMP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lsb</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Convert celsius to fahrenheit, since this was</span>
<span class="cm">	 * the decided &#39;standard&#39; for this return value.</span>
<span class="cm">	 */</span>
	<span class="o">*</span><span class="n">temperature</span> <span class="o">=</span> <span class="p">(</span><span class="n">lsb</span> <span class="o">*</span> <span class="mi">9</span> <span class="o">/</span> <span class="mi">5</span><span class="p">)</span> <span class="o">+</span> <span class="mi">32</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usb_pcwd_get_timeleft</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_pcwd_private</span> <span class="o">*</span><span class="n">usb_pcwd</span><span class="p">,</span>
								<span class="kt">int</span> <span class="o">*</span><span class="n">time_left</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">msb</span><span class="p">,</span> <span class="n">lsb</span><span class="p">;</span>

	<span class="cm">/* Read the time that&#39;s left before rebooting */</span>
	<span class="cm">/* Note: if the board is not yet armed then we will read 0xFFFF */</span>
	<span class="n">usb_pcwd_send_command</span><span class="p">(</span><span class="n">usb_pcwd</span><span class="p">,</span> <span class="n">CMD_READ_WATCHDOG_TIMEOUT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lsb</span><span class="p">);</span>

	<span class="o">*</span><span class="n">time_left</span> <span class="o">=</span> <span class="p">(</span><span class="n">msb</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="n">lsb</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	/dev/watchdog handling</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">usb_pcwd_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
						<span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* See if we got the magic character &#39;V&#39; and reload the timer */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nowayout</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">size_t</span> <span class="n">i</span><span class="p">;</span>

			<span class="cm">/* note: just in case someone wrote the magic character</span>
<span class="cm">			 * five months ago... */</span>
			<span class="n">expect_release</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="cm">/* scan to see whether or not we got the</span>
<span class="cm">			 * magic character */</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="kt">char</span> <span class="n">c</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">data</span> <span class="o">+</span> <span class="n">i</span><span class="p">))</span>
					<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;V&#39;</span><span class="p">)</span>
					<span class="n">expect_release</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* someone wrote to us, we should reload the timer */</span>
		<span class="n">usb_pcwd_keepalive</span><span class="p">(</span><span class="n">usb_pcwd_device</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">long</span> <span class="nf">usb_pcwd_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span>
						<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">argp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">argp</span><span class="p">;</span>
	<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">watchdog_info</span> <span class="n">ident</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">options</span> <span class="o">=</span>		<span class="n">WDIOF_KEEPALIVEPING</span> <span class="o">|</span>
					<span class="n">WDIOF_SETTIMEOUT</span> <span class="o">|</span>
					<span class="n">WDIOF_MAGICCLOSE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">firmware_version</span> <span class="o">=</span>	<span class="mi">1</span><span class="p">,</span>
		<span class="p">.</span><span class="n">identity</span> <span class="o">=</span>		<span class="n">DRIVER_NAME</span><span class="p">,</span>
	<span class="p">};</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">WDIOC_GETSUPPORT</span>:
		<span class="k">return</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">argp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ident</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ident</span><span class="p">))</span> <span class="o">?</span> <span class="o">-</span><span class="n">EFAULT</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">WDIOC_GETSTATUS</span>:
	<span class="k">case</span> <span class="n">WDIOC_GETBOOTSTATUS</span>:
		<span class="k">return</span> <span class="n">put_user</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>

	<span class="k">case</span> <span class="n">WDIOC_GETTEMP</span>:
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">temperature</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">usb_pcwd_get_temperature</span><span class="p">(</span><span class="n">usb_pcwd_device</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">temperature</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

		<span class="k">return</span> <span class="n">put_user</span><span class="p">(</span><span class="n">temperature</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">case</span> <span class="n">WDIOC_SETOPTIONS</span>:
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">new_options</span><span class="p">,</span> <span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">new_options</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">new_options</span> <span class="o">&amp;</span> <span class="n">WDIOS_DISABLECARD</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">usb_pcwd_stop</span><span class="p">(</span><span class="n">usb_pcwd_device</span><span class="p">);</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">new_options</span> <span class="o">&amp;</span> <span class="n">WDIOS_ENABLECARD</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">usb_pcwd_start</span><span class="p">(</span><span class="n">usb_pcwd_device</span><span class="p">);</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">case</span> <span class="n">WDIOC_KEEPALIVE</span>:
		<span class="n">usb_pcwd_keepalive</span><span class="p">(</span><span class="n">usb_pcwd_device</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">WDIOC_SETTIMEOUT</span>:
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">new_heartbeat</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">new_heartbeat</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">usb_pcwd_set_heartbeat</span><span class="p">(</span><span class="n">usb_pcwd_device</span><span class="p">,</span> <span class="n">new_heartbeat</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="n">usb_pcwd_keepalive</span><span class="p">(</span><span class="n">usb_pcwd_device</span><span class="p">);</span>
		<span class="cm">/* Fall */</span>
	<span class="p">}</span>

	<span class="k">case</span> <span class="n">WDIOC_GETTIMEOUT</span>:
		<span class="k">return</span> <span class="n">put_user</span><span class="p">(</span><span class="n">heartbeat</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>

	<span class="k">case</span> <span class="n">WDIOC_GETTIMELEFT</span>:
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">time_left</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">usb_pcwd_get_timeleft</span><span class="p">(</span><span class="n">usb_pcwd_device</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">time_left</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

		<span class="k">return</span> <span class="n">put_user</span><span class="p">(</span><span class="n">time_left</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usb_pcwd_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* /dev/watchdog can only be opened once */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">is_active</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="cm">/* Activate */</span>
	<span class="n">usb_pcwd_start</span><span class="p">(</span><span class="n">usb_pcwd_device</span><span class="p">);</span>
	<span class="n">usb_pcwd_keepalive</span><span class="p">(</span><span class="n">usb_pcwd_device</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">nonseekable_open</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usb_pcwd_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 *      Shut off the timer.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">expect_release</span> <span class="o">==</span> <span class="mi">42</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">usb_pcwd_stop</span><span class="p">(</span><span class="n">usb_pcwd_device</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pr_crit</span><span class="p">(</span><span class="s">&quot;Unexpected close, not stopping watchdog!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">usb_pcwd_keepalive</span><span class="p">(</span><span class="n">usb_pcwd_device</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">expect_release</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">is_active</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	/dev/temperature handling</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">usb_pcwd_temperature_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
				<span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">temperature</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">usb_pcwd_get_temperature</span><span class="p">(</span><span class="n">usb_pcwd_device</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">temperature</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">temperature</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usb_pcwd_temperature_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">nonseekable_open</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usb_pcwd_temperature_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	Notify system</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">usb_pcwd_notify_sys</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">this</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">code</span><span class="p">,</span>
								<span class="kt">void</span> <span class="o">*</span><span class="n">unused</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">code</span> <span class="o">==</span> <span class="n">SYS_DOWN</span> <span class="o">||</span> <span class="n">code</span> <span class="o">==</span> <span class="n">SYS_HALT</span><span class="p">)</span>
		<span class="n">usb_pcwd_stop</span><span class="p">(</span><span class="n">usb_pcwd_device</span><span class="p">);</span>	<span class="cm">/* Turn the WDT off */</span>

	<span class="k">return</span> <span class="n">NOTIFY_DONE</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	Kernel Interfaces</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">usb_pcwd_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span> <span class="o">=</span>	<span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span>	<span class="n">no_llseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span> <span class="o">=</span>	<span class="n">usb_pcwd_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unlocked_ioctl</span> <span class="o">=</span> <span class="n">usb_pcwd_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span>		<span class="n">usb_pcwd_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span>	<span class="n">usb_pcwd_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">miscdevice</span> <span class="n">usb_pcwd_miscdev</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">minor</span> <span class="o">=</span>	<span class="n">WATCHDOG_MINOR</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span>		<span class="s">&quot;watchdog&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fops</span> <span class="o">=</span>		<span class="o">&amp;</span><span class="n">usb_pcwd_fops</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">usb_pcwd_temperature_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span> <span class="o">=</span>	<span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span>	<span class="n">no_llseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span>		<span class="n">usb_pcwd_temperature_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span>		<span class="n">usb_pcwd_temperature_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span>	<span class="n">usb_pcwd_temperature_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">miscdevice</span> <span class="n">usb_pcwd_temperature_miscdev</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">minor</span> <span class="o">=</span>	<span class="n">TEMP_MINOR</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span>		<span class="s">&quot;temperature&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fops</span> <span class="o">=</span>		<span class="o">&amp;</span><span class="n">usb_pcwd_temperature_fops</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">usb_pcwd_notifier</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">notifier_call</span> <span class="o">=</span>	<span class="n">usb_pcwd_notify_sys</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> *	usb_pcwd_delete</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">usb_pcwd_delete</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_pcwd_private</span> <span class="o">*</span><span class="n">usb_pcwd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">usb_free_urb</span><span class="p">(</span><span class="n">usb_pcwd</span><span class="o">-&gt;</span><span class="n">intr_urb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usb_pcwd</span><span class="o">-&gt;</span><span class="n">intr_buffer</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">usb_free_coherent</span><span class="p">(</span><span class="n">usb_pcwd</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span> <span class="n">usb_pcwd</span><span class="o">-&gt;</span><span class="n">intr_size</span><span class="p">,</span>
				  <span class="n">usb_pcwd</span><span class="o">-&gt;</span><span class="n">intr_buffer</span><span class="p">,</span> <span class="n">usb_pcwd</span><span class="o">-&gt;</span><span class="n">intr_dma</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">usb_pcwd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	usb_pcwd_probe</span>
<span class="cm"> *</span>
<span class="cm"> *	Called by the usb core when a new device is connected that it thinks</span>
<span class="cm"> *	this driver might be interested in.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usb_pcwd_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">interface</span><span class="p">,</span>
						<span class="k">const</span> <span class="k">struct</span> <span class="n">usb_device_id</span> <span class="o">*</span><span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span> <span class="o">=</span> <span class="n">interface_to_usbdev</span><span class="p">(</span><span class="n">interface</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usb_host_interface</span> <span class="o">*</span><span class="n">iface_desc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_endpoint_descriptor</span> <span class="o">*</span><span class="n">endpoint</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_pcwd_private</span> <span class="o">*</span><span class="n">usb_pcwd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pipe</span><span class="p">,</span> <span class="n">maxp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">got_fw_rev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">fw_rev_major</span><span class="p">,</span> <span class="n">fw_rev_minor</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">fw_ver_str</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">option_switches</span><span class="p">,</span> <span class="n">dummy</span><span class="p">;</span>

	<span class="n">cards_found</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cards_found</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;This driver only supports 1 device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* get the active interface descriptor */</span>
	<span class="n">iface_desc</span> <span class="o">=</span> <span class="n">interface</span><span class="o">-&gt;</span><span class="n">cur_altsetting</span><span class="p">;</span>

	<span class="cm">/* check out that we have a HID device */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">iface_desc</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bInterfaceClass</span> <span class="o">==</span> <span class="n">USB_CLASS_HID</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;The device isn&#39;t a Human Interface Device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* check out the endpoint: it has to be Interrupt &amp; IN */</span>
	<span class="n">endpoint</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iface_desc</span><span class="o">-&gt;</span><span class="n">endpoint</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">desc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">usb_endpoint_is_int_in</span><span class="p">(</span><span class="n">endpoint</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* we didn&#39;t find a Interrupt endpoint with direction IN */</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Couldn&#39;t find an INTR &amp; IN endpoint</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* get a handle to the interrupt data pipe */</span>
	<span class="n">pipe</span> <span class="o">=</span> <span class="n">usb_rcvintpipe</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">-&gt;</span><span class="n">bEndpointAddress</span><span class="p">);</span>
	<span class="n">maxp</span> <span class="o">=</span> <span class="n">usb_maxpacket</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">pipe</span><span class="p">,</span> <span class="n">usb_pipeout</span><span class="p">(</span><span class="n">pipe</span><span class="p">));</span>

	<span class="cm">/* allocate memory for our device and initialize it */</span>
	<span class="n">usb_pcwd</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_pcwd_private</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usb_pcwd</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Out of memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">usb_pcwd_device</span> <span class="o">=</span> <span class="n">usb_pcwd</span><span class="p">;</span>

	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usb_pcwd</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>
	<span class="n">usb_pcwd</span><span class="o">-&gt;</span><span class="n">udev</span> <span class="o">=</span> <span class="n">udev</span><span class="p">;</span>
	<span class="n">usb_pcwd</span><span class="o">-&gt;</span><span class="n">interface</span> <span class="o">=</span> <span class="n">interface</span><span class="p">;</span>
	<span class="n">usb_pcwd</span><span class="o">-&gt;</span><span class="n">interface_number</span> <span class="o">=</span> <span class="n">iface_desc</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bInterfaceNumber</span><span class="p">;</span>
	<span class="n">usb_pcwd</span><span class="o">-&gt;</span><span class="n">intr_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">endpoint</span><span class="o">-&gt;</span><span class="n">wMaxPacketSize</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">8</span> <span class="o">?</span>
				<span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">endpoint</span><span class="o">-&gt;</span><span class="n">wMaxPacketSize</span><span class="p">)</span> <span class="o">:</span> <span class="mi">8</span><span class="p">);</span>

	<span class="cm">/* set up the memory buffer&#39;s */</span>
	<span class="n">usb_pcwd</span><span class="o">-&gt;</span><span class="n">intr_buffer</span> <span class="o">=</span> <span class="n">usb_alloc_coherent</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">usb_pcwd</span><span class="o">-&gt;</span><span class="n">intr_size</span><span class="p">,</span>
					<span class="n">GFP_ATOMIC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">usb_pcwd</span><span class="o">-&gt;</span><span class="n">intr_dma</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">usb_pcwd</span><span class="o">-&gt;</span><span class="n">intr_buffer</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Out of memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* allocate the urb&#39;s */</span>
	<span class="n">usb_pcwd</span><span class="o">-&gt;</span><span class="n">intr_urb</span> <span class="o">=</span> <span class="n">usb_alloc_urb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">usb_pcwd</span><span class="o">-&gt;</span><span class="n">intr_urb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Out of memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* initialise the intr urb&#39;s */</span>
	<span class="n">usb_fill_int_urb</span><span class="p">(</span><span class="n">usb_pcwd</span><span class="o">-&gt;</span><span class="n">intr_urb</span><span class="p">,</span> <span class="n">udev</span><span class="p">,</span> <span class="n">pipe</span><span class="p">,</span>
			<span class="n">usb_pcwd</span><span class="o">-&gt;</span><span class="n">intr_buffer</span><span class="p">,</span> <span class="n">usb_pcwd</span><span class="o">-&gt;</span><span class="n">intr_size</span><span class="p">,</span>
			<span class="n">usb_pcwd_intr_done</span><span class="p">,</span> <span class="n">usb_pcwd</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">-&gt;</span><span class="n">bInterval</span><span class="p">);</span>
	<span class="n">usb_pcwd</span><span class="o">-&gt;</span><span class="n">intr_urb</span><span class="o">-&gt;</span><span class="n">transfer_dma</span> <span class="o">=</span> <span class="n">usb_pcwd</span><span class="o">-&gt;</span><span class="n">intr_dma</span><span class="p">;</span>
	<span class="n">usb_pcwd</span><span class="o">-&gt;</span><span class="n">intr_urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">|=</span> <span class="n">URB_NO_TRANSFER_DMA_MAP</span><span class="p">;</span>

	<span class="cm">/* register our interrupt URB with the USB system */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usb_submit_urb</span><span class="p">(</span><span class="n">usb_pcwd</span><span class="o">-&gt;</span><span class="n">intr_urb</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Problem registering interrupt URB</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span> <span class="cm">/* failure */</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* The device exists and can be communicated with */</span>
	<span class="n">usb_pcwd</span><span class="o">-&gt;</span><span class="n">exists</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* disable card */</span>
	<span class="n">usb_pcwd_stop</span><span class="p">(</span><span class="n">usb_pcwd</span><span class="p">);</span>

	<span class="cm">/* Get the Firmware Version */</span>
	<span class="n">got_fw_rev</span> <span class="o">=</span> <span class="n">usb_pcwd_send_command</span><span class="p">(</span><span class="n">usb_pcwd</span><span class="p">,</span> <span class="n">CMD_GET_FIRMWARE_VERSION</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">fw_rev_major</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fw_rev_minor</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">got_fw_rev</span><span class="p">)</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">fw_ver_str</span><span class="p">,</span> <span class="s">&quot;%u.%02u&quot;</span><span class="p">,</span> <span class="n">fw_rev_major</span><span class="p">,</span> <span class="n">fw_rev_minor</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">fw_ver_str</span><span class="p">,</span> <span class="s">&quot;&lt;card no answer&gt;&quot;</span><span class="p">);</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Found card (Firmware: %s) with temp option</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fw_ver_str</span><span class="p">);</span>

	<span class="cm">/* Get switch settings */</span>
	<span class="n">usb_pcwd_send_command</span><span class="p">(</span><span class="n">usb_pcwd</span><span class="p">,</span> <span class="n">CMD_GET_DIP_SWITCH_SETTINGS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dummy</span><span class="p">,</span>
							<span class="o">&amp;</span><span class="n">option_switches</span><span class="p">);</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Option switches (0x%02x): Temperature Reset Enable=%s, Power On Delay=%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">option_switches</span><span class="p">,</span>
		<span class="p">((</span><span class="n">option_switches</span> <span class="o">&amp;</span> <span class="mh">0x10</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;ON&quot;</span> <span class="o">:</span> <span class="s">&quot;OFF&quot;</span><span class="p">),</span>
		<span class="p">((</span><span class="n">option_switches</span> <span class="o">&amp;</span> <span class="mh">0x08</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;ON&quot;</span> <span class="o">:</span> <span class="s">&quot;OFF&quot;</span><span class="p">));</span>

	<span class="cm">/* If heartbeat = 0 then we use the heartbeat from the dip-switches */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">heartbeat</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">heartbeat</span> <span class="o">=</span> <span class="n">heartbeat_tbl</span><span class="p">[(</span><span class="n">option_switches</span> <span class="o">&amp;</span> <span class="mh">0x07</span><span class="p">)];</span>

	<span class="cm">/* Check that the heartbeat value is within it&#39;s range ;</span>
<span class="cm">	 * if not reset to the default */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usb_pcwd_set_heartbeat</span><span class="p">(</span><span class="n">usb_pcwd</span><span class="p">,</span> <span class="n">heartbeat</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">usb_pcwd_set_heartbeat</span><span class="p">(</span><span class="n">usb_pcwd</span><span class="p">,</span> <span class="n">WATCHDOG_HEARTBEAT</span><span class="p">);</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;heartbeat value must be 0&lt;heartbeat&lt;65536, using %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">WATCHDOG_HEARTBEAT</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">register_reboot_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usb_pcwd_notifier</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;cannot register reboot notifier (err=%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">misc_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usb_pcwd_temperature_miscdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;cannot register miscdev on minor=%d (err=%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">TEMP_MINOR</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_out_unregister_reboot</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">misc_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usb_pcwd_miscdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;cannot register miscdev on minor=%d (err=%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">WATCHDOG_MINOR</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_out_misc_deregister</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* we can register the device now, as it is ready */</span>
	<span class="n">usb_set_intfdata</span><span class="p">(</span><span class="n">interface</span><span class="p">,</span> <span class="n">usb_pcwd</span><span class="p">);</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;initialized. heartbeat=%d sec (nowayout=%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">heartbeat</span><span class="p">,</span> <span class="n">nowayout</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_out_misc_deregister:</span>
	<span class="n">misc_deregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usb_pcwd_temperature_miscdev</span><span class="p">);</span>
<span class="nl">err_out_unregister_reboot:</span>
	<span class="n">unregister_reboot_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usb_pcwd_notifier</span><span class="p">);</span>
<span class="nl">error:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usb_pcwd</span><span class="p">)</span>
		<span class="n">usb_pcwd_delete</span><span class="p">(</span><span class="n">usb_pcwd</span><span class="p">);</span>
	<span class="n">usb_pcwd_device</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> *	usb_pcwd_disconnect</span>
<span class="cm"> *</span>
<span class="cm"> *	Called by the usb core when the device is removed from the system.</span>
<span class="cm"> *</span>
<span class="cm"> *	This routine guarantees that the driver will not submit any more urbs</span>
<span class="cm"> *	by clearing dev-&gt;udev.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">usb_pcwd_disconnect</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">interface</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_pcwd_private</span> <span class="o">*</span><span class="n">usb_pcwd</span><span class="p">;</span>

	<span class="cm">/* prevent races with open() */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">disconnect_mutex</span><span class="p">);</span>

	<span class="n">usb_pcwd</span> <span class="o">=</span> <span class="n">usb_get_intfdata</span><span class="p">(</span><span class="n">interface</span><span class="p">);</span>
	<span class="n">usb_set_intfdata</span><span class="p">(</span><span class="n">interface</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usb_pcwd</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>

	<span class="cm">/* Stop the timer before we leave */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nowayout</span><span class="p">)</span>
		<span class="n">usb_pcwd_stop</span><span class="p">(</span><span class="n">usb_pcwd</span><span class="p">);</span>

	<span class="cm">/* We should now stop communicating with the USB PCWD device */</span>
	<span class="n">usb_pcwd</span><span class="o">-&gt;</span><span class="n">exists</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Deregister */</span>
	<span class="n">misc_deregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usb_pcwd_miscdev</span><span class="p">);</span>
	<span class="n">misc_deregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usb_pcwd_temperature_miscdev</span><span class="p">);</span>
	<span class="n">unregister_reboot_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usb_pcwd_notifier</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usb_pcwd</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>

	<span class="cm">/* Delete the USB PCWD device */</span>
	<span class="n">usb_pcwd_delete</span><span class="p">(</span><span class="n">usb_pcwd</span><span class="p">);</span>

	<span class="n">cards_found</span><span class="o">--</span><span class="p">;</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">disconnect_mutex</span><span class="p">);</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;USB PC Watchdog disconnected</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_usb_driver</span><span class="p">(</span><span class="n">usb_pcwd_driver</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
