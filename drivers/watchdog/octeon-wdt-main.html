<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › watchdog › octeon-wdt-main.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>octeon-wdt-main.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Octeon Watchdog driver</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2007, 2008, 2009, 2010 Cavium Networks</span>
<span class="cm"> *</span>
<span class="cm"> * Some parts derived from wdt.c</span>
<span class="cm"> *</span>
<span class="cm"> *	(c) Copyright 1996-1997 Alan Cox &lt;alan@lxorguk.ukuu.org.uk&gt;,</span>
<span class="cm"> *						All Rights Reserved.</span>
<span class="cm"> *</span>
<span class="cm"> *	This program is free software; you can redistribute it and/or</span>
<span class="cm"> *	modify it under the terms of the GNU General Public License</span>
<span class="cm"> *	as published by the Free Software Foundation; either version</span>
<span class="cm"> *	2 of the License, or (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *	Neither Alan Cox nor CymruNet Ltd. admit liability nor provide</span>
<span class="cm"> *	warranty for any of this software. This material is provided</span>
<span class="cm"> *	&quot;AS-IS&quot; and at no charge.</span>
<span class="cm"> *</span>
<span class="cm"> *	(c) Copyright 1995    Alan Cox &lt;alan@lxorguk.ukuu.org.uk&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This file is subject to the terms and conditions of the GNU General Public</span>
<span class="cm"> * License.  See the file &quot;COPYING&quot; in the main directory of this archive</span>
<span class="cm"> * for more details.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * The OCTEON watchdog has a maximum timeout of 2^32 * io_clock.</span>
<span class="cm"> * For most systems this is less than 10 seconds, so to allow for</span>
<span class="cm"> * software to request longer watchdog heartbeats, we maintain software</span>
<span class="cm"> * counters to count multiples of the base rate.  If the system locks</span>
<span class="cm"> * up in such a manner that we can not run the software counters, the</span>
<span class="cm"> * only result is a watchdog reset sooner than was requested.  But</span>
<span class="cm"> * that is OK, because in this case userspace would likely not be able</span>
<span class="cm"> * to do anything anyhow.</span>
<span class="cm"> *</span>
<span class="cm"> * The hardware watchdog interval we call the period.  The OCTEON</span>
<span class="cm"> * watchdog goes through several stages, after the first period an</span>
<span class="cm"> * irq is asserted, then if it is not reset, after the next period NMI</span>
<span class="cm"> * is asserted, then after an additional period a chip wide soft reset.</span>
<span class="cm"> * So for the software counters, we reset watchdog after each period</span>
<span class="cm"> * and decrement the counter.  But for the last two periods we need to</span>
<span class="cm"> * let the watchdog progress to the NMI stage so we disable the irq</span>
<span class="cm"> * and let it proceed.  Once in the NMI, we print the register state</span>
<span class="cm"> * to the serial port and then wait for the reset.</span>
<span class="cm"> *</span>
<span class="cm"> * A watchdog is maintained for each CPU in the system, that way if</span>
<span class="cm"> * one CPU suffers a lockup, we also get a register dump and reset.</span>
<span class="cm"> * The userspace ping resets the watchdog on all CPUs.</span>
<span class="cm"> *</span>
<span class="cm"> * Before userspace opens the watchdog device, we still run the</span>
<span class="cm"> * watchdogs to catch any lockups that may be kernel related.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#define pr_fmt(fmt) KBUILD_MODNAME &quot;: &quot; fmt</span>

<span class="cp">#include &lt;linux/miscdevice.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/watchdog.h&gt;</span>
<span class="cp">#include &lt;linux/cpumask.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/cpu.h&gt;</span>
<span class="cp">#include &lt;linux/smp.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/irq.h&gt;</span>

<span class="cp">#include &lt;asm/mipsregs.h&gt;</span>
<span class="cp">#include &lt;asm/uasm.h&gt;</span>

<span class="cp">#include &lt;asm/octeon/octeon.h&gt;</span>

<span class="cm">/* The count needed to achieve timeout_sec. */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">timeout_cnt</span><span class="p">;</span>

<span class="cm">/* The maximum period supported. */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_timeout_sec</span><span class="p">;</span>

<span class="cm">/* The current period.  */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">timeout_sec</span><span class="p">;</span>

<span class="cm">/* Set to non-zero when userspace countdown mode active */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">do_coundown</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">countdown_reset</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">per_cpu_countdown</span><span class="p">[</span><span class="n">NR_CPUS</span><span class="p">];</span>

<span class="k">static</span> <span class="n">cpumask_t</span> <span class="n">irq_enabled_cpus</span><span class="p">;</span>

<span class="cp">#define WD_TIMO 60			</span><span class="cm">/* Default heartbeat = 60 seconds */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">heartbeat</span> <span class="o">=</span> <span class="n">WD_TIMO</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">heartbeat</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">heartbeat</span><span class="p">,</span>
	<span class="s">&quot;Watchdog heartbeat in seconds. (0 &lt; heartbeat, default=&quot;</span>
				<span class="n">__MODULE_STRING</span><span class="p">(</span><span class="n">WD_TIMO</span><span class="p">)</span> <span class="s">&quot;)&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="n">bool</span> <span class="n">nowayout</span> <span class="o">=</span> <span class="n">WATCHDOG_NOWAYOUT</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">nowayout</span><span class="p">,</span> <span class="n">bool</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">nowayout</span><span class="p">,</span>
	<span class="s">&quot;Watchdog cannot be stopped once started (default=&quot;</span>
				<span class="n">__MODULE_STRING</span><span class="p">(</span><span class="n">WATCHDOG_NOWAYOUT</span><span class="p">)</span> <span class="s">&quot;)&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">octeon_wdt_is_open</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">char</span> <span class="n">expect_close</span><span class="p">;</span>

<span class="k">static</span> <span class="n">u32</span> <span class="n">__initdata</span> <span class="n">nmi_stage1_insns</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
<span class="cm">/* We need one branch and therefore one relocation per target label. */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">uasm_label</span> <span class="n">__initdata</span> <span class="n">labels</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">uasm_reloc</span> <span class="n">__initdata</span> <span class="n">relocs</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>

<span class="k">enum</span> <span class="n">lable_id</span> <span class="p">{</span>
	<span class="n">label_enter_bootloader</span> <span class="o">=</span> <span class="mi">1</span>
<span class="p">};</span>

<span class="cm">/* Some CP0 registers */</span>
<span class="cp">#define K0		26</span>
<span class="cp">#define C0_CVMMEMCTL 11, 7</span>
<span class="cp">#define C0_STATUS 12, 0</span>
<span class="cp">#define C0_EBASE 15, 1</span>
<span class="cp">#define C0_DESAVE 31, 0</span>

<span class="kt">void</span> <span class="n">octeon_wdt_nmi_stage2</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">octeon_wdt_build_stage1</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">nmi_stage1_insns</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_HOTPLUG_CPU</span>
	<span class="k">struct</span> <span class="n">uasm_label</span> <span class="o">*</span><span class="n">l</span> <span class="o">=</span> <span class="n">labels</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uasm_reloc</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="n">relocs</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 * For the next few instructions running the debugger may</span>
<span class="cm">	 * cause corruption of k0 in the saved registers. Since we&#39;re</span>
<span class="cm">	 * about to crash, nobody probably cares.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Save K0 into the debug scratch register</span>
<span class="cm">	 */</span>
	<span class="n">uasm_i_dmtc0</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="n">C0_DESAVE</span><span class="p">);</span>

	<span class="n">uasm_i_mfc0</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="n">C0_STATUS</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_HOTPLUG_CPU</span>
	<span class="n">uasm_il_bbit0</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="n">ilog2</span><span class="p">(</span><span class="n">ST0_NMI</span><span class="p">),</span> <span class="n">label_enter_bootloader</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="cm">/* Force 64-bit addressing enabled */</span>
	<span class="n">uasm_i_ori</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="n">ST0_UX</span> <span class="o">|</span> <span class="n">ST0_SX</span> <span class="o">|</span> <span class="n">ST0_KX</span><span class="p">);</span>
	<span class="n">uasm_i_mtc0</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="n">C0_STATUS</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_HOTPLUG_CPU</span>
	<span class="n">uasm_i_mfc0</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="n">C0_EBASE</span><span class="p">);</span>
	<span class="cm">/* Coreid number in K0 */</span>
	<span class="n">uasm_i_andi</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="mh">0xf</span><span class="p">);</span>
	<span class="cm">/* 8 * coreid in bits 16-31 */</span>
	<span class="n">uasm_i_dsll_safe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">16</span><span class="p">);</span>
	<span class="n">uasm_i_ori</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="mh">0x8001</span><span class="p">);</span>
	<span class="n">uasm_i_dsll_safe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
	<span class="n">uasm_i_ori</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="mh">0x0700</span><span class="p">);</span>
	<span class="n">uasm_i_drotr_safe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Should result in: 0x8001,0700,0000,8*coreid which is</span>
<span class="cm">	 * CVMX_CIU_WDOGX(coreid) - 0x0500</span>
<span class="cm">	 *</span>
<span class="cm">	 * Now ld K0, CVMX_CIU_WDOGX(coreid)</span>
<span class="cm">	 */</span>
	<span class="n">uasm_i_ld</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="mh">0x500</span><span class="p">,</span> <span class="n">K0</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * If bit one set handle the NMI as a watchdog event.</span>
<span class="cm">	 * otherwise transfer control to bootloader.</span>
<span class="cm">	 */</span>
	<span class="n">uasm_il_bbit0</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">label_enter_bootloader</span><span class="p">);</span>
	<span class="n">uasm_i_nop</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/* Clear Dcache so cvmseg works right. */</span>
	<span class="n">uasm_i_cache</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Use K0 to do a read/modify/write of CVMMEMCTL */</span>
	<span class="n">uasm_i_dmfc0</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="n">C0_CVMMEMCTL</span><span class="p">);</span>
	<span class="cm">/* Clear out the size of CVMSEG	*/</span>
	<span class="n">uasm_i_dins</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
	<span class="cm">/* Set CVMSEG to its largest value */</span>
	<span class="n">uasm_i_ori</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="mh">0x1c0</span> <span class="o">|</span> <span class="mi">54</span><span class="p">);</span>
	<span class="cm">/* Store the CVMMEMCTL value */</span>
	<span class="n">uasm_i_dmtc0</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="n">C0_CVMMEMCTL</span><span class="p">);</span>

	<span class="cm">/* Load the address of the second stage handler */</span>
	<span class="n">UASM_i_LA</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">octeon_wdt_nmi_stage2</span><span class="p">);</span>
	<span class="n">uasm_i_jr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">K0</span><span class="p">);</span>
	<span class="n">uasm_i_dmfc0</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="n">C0_DESAVE</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_HOTPLUG_CPU</span>
	<span class="n">uasm_build_label</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">label_enter_bootloader</span><span class="p">);</span>
	<span class="cm">/* Jump to the bootloader and restore K0 */</span>
	<span class="n">UASM_i_LA</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">octeon_bootloader_entry_addr</span><span class="p">);</span>
	<span class="n">uasm_i_jr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">K0</span><span class="p">);</span>
	<span class="n">uasm_i_dmfc0</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="n">C0_DESAVE</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">uasm_resolve_relocs</span><span class="p">(</span><span class="n">relocs</span><span class="p">,</span> <span class="n">labels</span><span class="p">);</span>

	<span class="n">len</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">p</span> <span class="o">-</span> <span class="n">nmi_stage1_insns</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Synthesized NMI stage 1 handler (%d instructions)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">.set push</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">.set noreorder</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">.word 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">nmi_stage1_insns</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">.set pop</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">32</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;NMI stage 1 handler exceeds 32 instructions, was %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cpu2core</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="k">return</span> <span class="n">cpu_logical_map</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="k">return</span> <span class="n">cvmx_get_core_num</span><span class="p">();</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">core2cpu</span><span class="p">(</span><span class="kt">int</span> <span class="n">coreid</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="k">return</span> <span class="n">cpu_number_map</span><span class="p">(</span><span class="n">coreid</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Poke the watchdog when an interrupt is received</span>
<span class="cm"> *</span>
<span class="cm"> * @cpl:</span>
<span class="cm"> * @dev_id:</span>
<span class="cm"> *</span>
<span class="cm"> * Returns</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">octeon_wdt_poke_irq</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpl</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">core</span> <span class="o">=</span> <span class="n">cvmx_get_core_num</span><span class="p">();</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">core2cpu</span><span class="p">(</span><span class="n">core</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">do_coundown</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">per_cpu_countdown</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* We&#39;re alive, poke the watchdog */</span>
			<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_CIU_PP_POKEX</span><span class="p">(</span><span class="n">core</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">per_cpu_countdown</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Bad news, you are about to reboot. */</span>
			<span class="n">disable_irq_nosync</span><span class="p">(</span><span class="n">cpl</span><span class="p">);</span>
			<span class="n">cpumask_clear_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">irq_enabled_cpus</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Not open, just ping away... */</span>
		<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_CIU_PP_POKEX</span><span class="p">(</span><span class="n">core</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* From setup.c */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">prom_putchar</span><span class="p">(</span><span class="kt">char</span> <span class="n">c</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Write a string to the uart</span>
<span class="cm"> *</span>
<span class="cm"> * @str:        String to write</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">octeon_wdt_write_string</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Just loop writing one byte at a time */</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">str</span><span class="p">)</span>
		<span class="n">prom_putchar</span><span class="p">(</span><span class="o">*</span><span class="n">str</span><span class="o">++</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Write a hex number out of the uart</span>
<span class="cm"> *</span>
<span class="cm"> * @value:      Number to display</span>
<span class="cm"> * @digits:     Number of digits to print (1 to 16)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">octeon_wdt_write_hex</span><span class="p">(</span><span class="n">u64</span> <span class="n">value</span><span class="p">,</span> <span class="kt">int</span> <span class="n">digits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">d</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">v</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">d</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="n">digits</span><span class="p">;</span> <span class="n">d</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">v</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span> <span class="o">&gt;&gt;</span> <span class="p">((</span><span class="n">digits</span> <span class="o">-</span> <span class="n">d</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">&gt;=</span> <span class="mi">10</span><span class="p">)</span>
			<span class="n">prom_putchar</span><span class="p">(</span><span class="sc">&#39;a&#39;</span> <span class="o">+</span> <span class="n">v</span> <span class="o">-</span> <span class="mi">10</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">prom_putchar</span><span class="p">(</span><span class="sc">&#39;0&#39;</span> <span class="o">+</span> <span class="n">v</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">reg_name</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="s">&quot;$0&quot;</span><span class="p">,</span> <span class="s">&quot;at&quot;</span><span class="p">,</span> <span class="s">&quot;v0&quot;</span><span class="p">,</span> <span class="s">&quot;v1&quot;</span><span class="p">,</span> <span class="s">&quot;a0&quot;</span><span class="p">,</span> <span class="s">&quot;a1&quot;</span><span class="p">,</span> <span class="s">&quot;a2&quot;</span><span class="p">,</span> <span class="s">&quot;a3&quot;</span><span class="p">,</span>
	<span class="s">&quot;a4&quot;</span><span class="p">,</span> <span class="s">&quot;a5&quot;</span><span class="p">,</span> <span class="s">&quot;a6&quot;</span><span class="p">,</span> <span class="s">&quot;a7&quot;</span><span class="p">,</span> <span class="s">&quot;t0&quot;</span><span class="p">,</span> <span class="s">&quot;t1&quot;</span><span class="p">,</span> <span class="s">&quot;t2&quot;</span><span class="p">,</span> <span class="s">&quot;t3&quot;</span><span class="p">,</span>
	<span class="s">&quot;s0&quot;</span><span class="p">,</span> <span class="s">&quot;s1&quot;</span><span class="p">,</span> <span class="s">&quot;s2&quot;</span><span class="p">,</span> <span class="s">&quot;s3&quot;</span><span class="p">,</span> <span class="s">&quot;s4&quot;</span><span class="p">,</span> <span class="s">&quot;s5&quot;</span><span class="p">,</span> <span class="s">&quot;s6&quot;</span><span class="p">,</span> <span class="s">&quot;s7&quot;</span><span class="p">,</span>
	<span class="s">&quot;t8&quot;</span><span class="p">,</span> <span class="s">&quot;t9&quot;</span><span class="p">,</span> <span class="s">&quot;k0&quot;</span><span class="p">,</span> <span class="s">&quot;k1&quot;</span><span class="p">,</span> <span class="s">&quot;gp&quot;</span><span class="p">,</span> <span class="s">&quot;sp&quot;</span><span class="p">,</span> <span class="s">&quot;s8&quot;</span><span class="p">,</span> <span class="s">&quot;ra&quot;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * NMI stage 3 handler. NMIs are handled in the following manner:</span>
<span class="cm"> * 1) The first NMI handler enables CVMSEG and transfers from</span>
<span class="cm"> * the bootbus region into normal memory. It is careful to not</span>
<span class="cm"> * destroy any registers.</span>
<span class="cm"> * 2) The second stage handler uses CVMSEG to save the registers</span>
<span class="cm"> * and create a stack for C code. It then calls the third level</span>
<span class="cm"> * handler with one argument, a pointer to the register values.</span>
<span class="cm"> * 3) The third, and final, level handler is the following C</span>
<span class="cm"> * function that prints out some useful infomration.</span>
<span class="cm"> *</span>
<span class="cm"> * @reg:    Pointer to register state before the NMI</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">octeon_wdt_nmi_stage3</span><span class="p">(</span><span class="n">u64</span> <span class="n">reg</span><span class="p">[</span><span class="mi">32</span><span class="p">])</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">i</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">coreid</span> <span class="o">=</span> <span class="n">cvmx_get_core_num</span><span class="p">();</span>
	<span class="cm">/*</span>
<span class="cm">	 * Save status and cause early to get them before any changes</span>
<span class="cm">	 * might happen.</span>
<span class="cm">	 */</span>
	<span class="n">u64</span> <span class="n">cp0_cause</span> <span class="o">=</span> <span class="n">read_c0_cause</span><span class="p">();</span>
	<span class="n">u64</span> <span class="n">cp0_status</span> <span class="o">=</span> <span class="n">read_c0_status</span><span class="p">();</span>
	<span class="n">u64</span> <span class="n">cp0_error_epc</span> <span class="o">=</span> <span class="n">read_c0_errorepc</span><span class="p">();</span>
	<span class="n">u64</span> <span class="n">cp0_epc</span> <span class="o">=</span> <span class="n">read_c0_epc</span><span class="p">();</span>

	<span class="cm">/* Delay so output from all cores output is not jumbled together. */</span>
	<span class="n">__delay</span><span class="p">(</span><span class="mi">100000000ull</span> <span class="o">*</span> <span class="n">coreid</span><span class="p">);</span>

	<span class="n">octeon_wdt_write_string</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\r\n</span><span class="s">*** NMI Watchdog interrupt on Core 0x&quot;</span><span class="p">);</span>
	<span class="n">octeon_wdt_write_hex</span><span class="p">(</span><span class="n">coreid</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">octeon_wdt_write_string</span><span class="p">(</span><span class="s">&quot; ***</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">octeon_wdt_write_string</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">octeon_wdt_write_string</span><span class="p">(</span><span class="n">reg_name</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">octeon_wdt_write_string</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">0x&quot;</span><span class="p">);</span>
		<span class="n">octeon_wdt_write_hex</span><span class="p">(</span><span class="n">reg</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">16</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">octeon_wdt_write_string</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">octeon_wdt_write_string</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">err_epc</span><span class="se">\t</span><span class="s">0x&quot;</span><span class="p">);</span>
	<span class="n">octeon_wdt_write_hex</span><span class="p">(</span><span class="n">cp0_error_epc</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>

	<span class="n">octeon_wdt_write_string</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">epc</span><span class="se">\t</span><span class="s">0x&quot;</span><span class="p">);</span>
	<span class="n">octeon_wdt_write_hex</span><span class="p">(</span><span class="n">cp0_epc</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
	<span class="n">octeon_wdt_write_string</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">octeon_wdt_write_string</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">status</span><span class="se">\t</span><span class="s">0x&quot;</span><span class="p">);</span>
	<span class="n">octeon_wdt_write_hex</span><span class="p">(</span><span class="n">cp0_status</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
	<span class="n">octeon_wdt_write_string</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">cause</span><span class="se">\t</span><span class="s">0x&quot;</span><span class="p">);</span>
	<span class="n">octeon_wdt_write_hex</span><span class="p">(</span><span class="n">cp0_cause</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
	<span class="n">octeon_wdt_write_string</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">octeon_wdt_write_string</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">sum0</span><span class="se">\t</span><span class="s">0x&quot;</span><span class="p">);</span>
	<span class="n">octeon_wdt_write_hex</span><span class="p">(</span><span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_CIU_INTX_SUM0</span><span class="p">(</span><span class="n">coreid</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)),</span> <span class="mi">16</span><span class="p">);</span>
	<span class="n">octeon_wdt_write_string</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">en0</span><span class="se">\t</span><span class="s">0x&quot;</span><span class="p">);</span>
	<span class="n">octeon_wdt_write_hex</span><span class="p">(</span><span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_CIU_INTX_EN0</span><span class="p">(</span><span class="n">coreid</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)),</span> <span class="mi">16</span><span class="p">);</span>
	<span class="n">octeon_wdt_write_string</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">octeon_wdt_write_string</span><span class="p">(</span><span class="s">&quot;*** Chip soft reset soon ***</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">octeon_wdt_disable_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">core</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">cvmx_ciu_wdogx</span> <span class="n">ciu_wdog</span><span class="p">;</span>

	<span class="n">core</span> <span class="o">=</span> <span class="n">cpu2core</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>

	<span class="n">irq</span> <span class="o">=</span> <span class="n">OCTEON_IRQ_WDOG0</span> <span class="o">+</span> <span class="n">core</span><span class="p">;</span>

	<span class="cm">/* Poke the watchdog to clear out its state */</span>
	<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_CIU_PP_POKEX</span><span class="p">(</span><span class="n">core</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* Disable the hardware. */</span>
	<span class="n">ciu_wdog</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_CIU_WDOGX</span><span class="p">(</span><span class="n">core</span><span class="p">),</span> <span class="n">ciu_wdog</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>

	<span class="n">free_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">octeon_wdt_poke_irq</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">octeon_wdt_setup_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">core</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">cvmx_ciu_wdogx</span> <span class="n">ciu_wdog</span><span class="p">;</span>

	<span class="n">core</span> <span class="o">=</span> <span class="n">cpu2core</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>

	<span class="cm">/* Disable it before doing anything with the interrupts. */</span>
	<span class="n">ciu_wdog</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_CIU_WDOGX</span><span class="p">(</span><span class="n">core</span><span class="p">),</span> <span class="n">ciu_wdog</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>

	<span class="n">per_cpu_countdown</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">=</span> <span class="n">countdown_reset</span><span class="p">;</span>

	<span class="n">irq</span> <span class="o">=</span> <span class="n">OCTEON_IRQ_WDOG0</span> <span class="o">+</span> <span class="n">core</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">request_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">octeon_wdt_poke_irq</span><span class="p">,</span>
			<span class="n">IRQF_NO_THREAD</span><span class="p">,</span> <span class="s">&quot;octeon_wdt&quot;</span><span class="p">,</span> <span class="n">octeon_wdt_poke_irq</span><span class="p">))</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;octeon_wdt: Couldn&#39;t obtain irq %d&quot;</span><span class="p">,</span> <span class="n">irq</span><span class="p">);</span>

	<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">irq_enabled_cpus</span><span class="p">);</span>

	<span class="cm">/* Poke the watchdog to clear out its state */</span>
	<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_CIU_PP_POKEX</span><span class="p">(</span><span class="n">core</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* Finally enable the watchdog now that all handlers are installed */</span>
	<span class="n">ciu_wdog</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ciu_wdog</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">timeout_cnt</span><span class="p">;</span>
	<span class="n">ciu_wdog</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">mode</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>	<span class="cm">/* 3 = Interrupt + NMI + Soft-Reset */</span>
	<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_CIU_WDOGX</span><span class="p">(</span><span class="n">core</span><span class="p">),</span> <span class="n">ciu_wdog</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">octeon_wdt_cpu_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nfb</span><span class="p">,</span>
					   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">action</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">hcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">hcpu</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">action</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CPU_DOWN_PREPARE</span>:
		<span class="n">octeon_wdt_disable_interrupt</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CPU_ONLINE</span>:
	<span class="k">case</span> <span class="n">CPU_DOWN_FAILED</span>:
		<span class="n">octeon_wdt_setup_interrupt</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">NOTIFY_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">octeon_wdt_ping</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">coreid</span><span class="p">;</span>

	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">coreid</span> <span class="o">=</span> <span class="n">cpu2core</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
		<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_CIU_PP_POKEX</span><span class="p">(</span><span class="n">coreid</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">per_cpu_countdown</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">=</span> <span class="n">countdown_reset</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">countdown_reset</span> <span class="o">||</span> <span class="o">!</span><span class="n">do_coundown</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">irq_enabled_cpus</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* We have to enable the irq */</span>
			<span class="kt">int</span> <span class="n">irq</span> <span class="o">=</span> <span class="n">OCTEON_IRQ_WDOG0</span> <span class="o">+</span> <span class="n">coreid</span><span class="p">;</span>
			<span class="n">enable_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
			<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">irq_enabled_cpus</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">octeon_wdt_calc_parameters</span><span class="p">(</span><span class="kt">int</span> <span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">periods</span><span class="p">;</span>

	<span class="n">timeout_sec</span> <span class="o">=</span> <span class="n">max_timeout_sec</span><span class="p">;</span>


	<span class="cm">/*</span>
<span class="cm">	 * Find the largest interrupt period, that can evenly divide</span>
<span class="cm">	 * the requested heartbeat time.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">t</span> <span class="o">%</span> <span class="n">timeout_sec</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">timeout_sec</span><span class="o">--</span><span class="p">;</span>

	<span class="n">periods</span> <span class="o">=</span> <span class="n">t</span> <span class="o">/</span> <span class="n">timeout_sec</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The last two periods are after the irq is disabled, and</span>
<span class="cm">	 * then to the nmi, so we subtract them off.</span>
<span class="cm">	 */</span>

	<span class="n">countdown_reset</span> <span class="o">=</span> <span class="n">periods</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="o">?</span> <span class="n">periods</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">heartbeat</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
	<span class="n">timeout_cnt</span> <span class="o">=</span> <span class="p">((</span><span class="n">octeon_get_io_clock_rate</span><span class="p">()</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">*</span> <span class="n">timeout_sec</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">octeon_wdt_set_heartbeat</span><span class="p">(</span><span class="kt">int</span> <span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">coreid</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">cvmx_ciu_wdogx</span> <span class="n">ciu_wdog</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">octeon_wdt_calc_parameters</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>

	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">coreid</span> <span class="o">=</span> <span class="n">cpu2core</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
		<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_CIU_PP_POKEX</span><span class="p">(</span><span class="n">coreid</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">ciu_wdog</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ciu_wdog</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">timeout_cnt</span><span class="p">;</span>
		<span class="n">ciu_wdog</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">mode</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>	<span class="cm">/* 3 = Interrupt + NMI + Soft-Reset */</span>
		<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_CIU_WDOGX</span><span class="p">(</span><span class="n">coreid</span><span class="p">),</span> <span class="n">ciu_wdog</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>
		<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_CIU_PP_POKEX</span><span class="p">(</span><span class="n">coreid</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">octeon_wdt_ping</span><span class="p">();</span> <span class="cm">/* Get the irqs back on. */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	octeon_wdt_write:</span>
<span class="cm"> *	@file: file handle to the watchdog</span>
<span class="cm"> *	@buf: buffer to write (unused as data does not matter here</span>
<span class="cm"> *	@count: count of bytes</span>
<span class="cm"> *	@ppos: pointer to the position to write. No seeks allowed</span>
<span class="cm"> *</span>
<span class="cm"> *	A write to a watchdog device is defined as a keepalive signal. Any</span>
<span class="cm"> *	write of data will do, as we we don&#39;t define content meaning.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">octeon_wdt_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				<span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nowayout</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">size_t</span> <span class="n">i</span><span class="p">;</span>

			<span class="cm">/* In case it was set long ago */</span>
			<span class="n">expect_close</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="kt">char</span> <span class="n">c</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">buf</span> <span class="o">+</span> <span class="n">i</span><span class="p">))</span>
					<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;V&#39;</span><span class="p">)</span>
					<span class="n">expect_close</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">octeon_wdt_ping</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	octeon_wdt_ioctl:</span>
<span class="cm"> *	@file: file handle to the device</span>
<span class="cm"> *	@cmd: watchdog command</span>
<span class="cm"> *	@arg: argument pointer</span>
<span class="cm"> *</span>
<span class="cm"> *	The watchdog API defines a common set of functions for all</span>
<span class="cm"> *	watchdogs according to their available features. We only</span>
<span class="cm"> *	actually usefully support querying capabilities and setting</span>
<span class="cm"> *	the timeout.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">long</span> <span class="nf">octeon_wdt_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">argp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">argp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">new_heartbeat</span><span class="p">;</span>

	<span class="k">static</span> <span class="k">struct</span> <span class="n">watchdog_info</span> <span class="n">ident</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">options</span> <span class="o">=</span>		<span class="n">WDIOF_SETTIMEOUT</span><span class="o">|</span>
					<span class="n">WDIOF_MAGICCLOSE</span><span class="o">|</span>
					<span class="n">WDIOF_KEEPALIVEPING</span><span class="p">,</span>
		<span class="p">.</span><span class="n">firmware_version</span> <span class="o">=</span>	<span class="mi">1</span><span class="p">,</span>
		<span class="p">.</span><span class="n">identity</span> <span class="o">=</span>		<span class="s">&quot;OCTEON&quot;</span><span class="p">,</span>
	<span class="p">};</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">WDIOC_GETSUPPORT</span>:
		<span class="k">return</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">argp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ident</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ident</span><span class="p">))</span> <span class="o">?</span> <span class="o">-</span><span class="n">EFAULT</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">WDIOC_GETSTATUS</span>:
	<span class="k">case</span> <span class="n">WDIOC_GETBOOTSTATUS</span>:
		<span class="k">return</span> <span class="n">put_user</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">WDIOC_KEEPALIVE</span>:
		<span class="n">octeon_wdt_ping</span><span class="p">();</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">WDIOC_SETTIMEOUT</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">new_heartbeat</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">octeon_wdt_set_heartbeat</span><span class="p">(</span><span class="n">new_heartbeat</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="cm">/* Fall through. */</span>
	<span class="k">case</span> <span class="n">WDIOC_GETTIMEOUT</span>:
		<span class="k">return</span> <span class="n">put_user</span><span class="p">(</span><span class="n">heartbeat</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	octeon_wdt_open:</span>
<span class="cm"> *	@inode: inode of device</span>
<span class="cm"> *	@file: file handle to device</span>
<span class="cm"> *</span>
<span class="cm"> *	The watchdog device has been opened. The watchdog device is single</span>
<span class="cm"> *	open and on opening we do a ping to reset the counters.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">octeon_wdt_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">octeon_wdt_is_open</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 *	Activate</span>
<span class="cm">	 */</span>
	<span class="n">octeon_wdt_ping</span><span class="p">();</span>
	<span class="n">do_coundown</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">nonseekable_open</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	octeon_wdt_release:</span>
<span class="cm"> *	@inode: inode to board</span>
<span class="cm"> *	@file: file handle to board</span>
<span class="cm"> *</span>
<span class="cm"> *	The watchdog has a configurable API. There is a religious dispute</span>
<span class="cm"> *	between people who want their watchdog to be able to shut down and</span>
<span class="cm"> *	those who want to be sure if the watchdog manager dies the machine</span>
<span class="cm"> *	reboots. In the former case we disable the counters, in the latter</span>
<span class="cm"> *	case you have to open it again very soon.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">octeon_wdt_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">expect_close</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">do_coundown</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">octeon_wdt_ping</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pr_crit</span><span class="p">(</span><span class="s">&quot;WDT device closed unexpectedly.  WDT will not stop!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">octeon_wdt_is_open</span><span class="p">);</span>
	<span class="n">expect_close</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">octeon_wdt_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">no_llseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">octeon_wdt_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unlocked_ioctl</span>	<span class="o">=</span> <span class="n">octeon_wdt_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">octeon_wdt_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">octeon_wdt_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">miscdevice</span> <span class="n">octeon_wdt_miscdev</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">minor</span>	<span class="o">=</span> <span class="n">WATCHDOG_MINOR</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span>	<span class="o">=</span> <span class="s">&quot;watchdog&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fops</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">octeon_wdt_fops</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">octeon_wdt_cpu_notifier</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">notifier_call</span> <span class="o">=</span> <span class="n">octeon_wdt_cpu_callback</span><span class="p">,</span>
<span class="p">};</span>


<span class="cm">/**</span>
<span class="cm"> * Module/ driver initialization.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns Zero on success</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">octeon_wdt_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="n">u64</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Watchdog time expiration length = The 16 bits of LEN</span>
<span class="cm">	 * represent the most significant bits of a 24 bit decrementer</span>
<span class="cm">	 * that decrements every 256 cycles.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Try for a timeout of 5 sec, if that fails a smaller number</span>
<span class="cm">	 * of even seconds,</span>
<span class="cm">	 */</span>
	<span class="n">max_timeout_sec</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">max_timeout_sec</span><span class="o">--</span><span class="p">;</span>
		<span class="n">timeout_cnt</span> <span class="o">=</span> <span class="p">((</span><span class="n">octeon_get_io_clock_rate</span><span class="p">()</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">*</span> <span class="n">max_timeout_sec</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">timeout_cnt</span> <span class="o">&gt;</span> <span class="mi">65535</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">timeout_cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">octeon_wdt_calc_parameters</span><span class="p">(</span><span class="n">heartbeat</span><span class="p">);</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Initial granularity %d Sec</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">timeout_sec</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">misc_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">octeon_wdt_miscdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;cannot register miscdev on minor=%d (err=%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">WATCHDOG_MINOR</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Build the NMI handler ... */</span>
	<span class="n">octeon_wdt_build_stage1</span><span class="p">();</span>

	<span class="cm">/* ... and install it. */</span>
	<span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="p">)</span> <span class="n">nmi_stage1_insns</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_MIO_BOOT_LOC_ADR</span><span class="p">,</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">8</span><span class="p">);</span>
		<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_MIO_BOOT_LOC_DAT</span><span class="p">,</span> <span class="n">ptr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_MIO_BOOT_LOC_CFGX</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mh">0x81fc0000</span><span class="p">);</span>

	<span class="n">cpumask_clear</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irq_enabled_cpus</span><span class="p">);</span>

	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span>
		<span class="n">octeon_wdt_setup_interrupt</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>

	<span class="n">register_hotcpu_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">octeon_wdt_cpu_notifier</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Module / driver shutdown</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">octeon_wdt_cleanup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">misc_deregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">octeon_wdt_miscdev</span><span class="p">);</span>

	<span class="n">unregister_hotcpu_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">octeon_wdt_cpu_notifier</span><span class="p">);</span>

	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">core</span> <span class="o">=</span> <span class="n">cpu2core</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
		<span class="cm">/* Disable the watchdog */</span>
		<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_CIU_WDOGX</span><span class="p">(</span><span class="n">core</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
		<span class="cm">/* Free the interrupt handler */</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">OCTEON_IRQ_WDOG0</span> <span class="o">+</span> <span class="n">core</span><span class="p">,</span> <span class="n">octeon_wdt_poke_irq</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Disable the boot-bus memory, the code it points to is soon</span>
<span class="cm">	 * to go missing.</span>
<span class="cm">	 */</span>
	<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_MIO_BOOT_LOC_CFGX</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Cavium Networks &lt;support@caviumnetworks.com&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Cavium Networks Octeon Watchdog driver.&quot;</span><span class="p">);</span>
<span class="n">module_init</span><span class="p">(</span><span class="n">octeon_wdt_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">octeon_wdt_cleanup</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
