<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › mmc › host › mmc_spi.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>mmc_spi.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * mmc_spi.c - Access SD/MMC cards through SPI master controllers</span>
<span class="cm"> *</span>
<span class="cm"> * (C) Copyright 2005, Intec Automation,</span>
<span class="cm"> *		Mike Lavender (mike@steroidmicros)</span>
<span class="cm"> * (C) Copyright 2006-2007, David Brownell</span>
<span class="cm"> * (C) Copyright 2007, Axis Communications,</span>
<span class="cm"> *		Hans-Peter Nilsson (hp@axis.com)</span>
<span class="cm"> * (C) Copyright 2007, ATRON electronic GmbH,</span>
<span class="cm"> *		Jan Nikitenko &lt;jan.nikitenko@gmail.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/bio.h&gt;</span>
<span class="cp">#include &lt;linux/dma-mapping.h&gt;</span>
<span class="cp">#include &lt;linux/crc7.h&gt;</span>
<span class="cp">#include &lt;linux/crc-itu-t.h&gt;</span>
<span class="cp">#include &lt;linux/scatterlist.h&gt;</span>

<span class="cp">#include &lt;linux/mmc/host.h&gt;</span>
<span class="cp">#include &lt;linux/mmc/mmc.h&gt;		</span><span class="cm">/* for R1_SPI_* bit values */</span><span class="cp"></span>

<span class="cp">#include &lt;linux/spi/spi.h&gt;</span>
<span class="cp">#include &lt;linux/spi/mmc_spi.h&gt;</span>

<span class="cp">#include &lt;asm/unaligned.h&gt;</span>


<span class="cm">/* NOTES:</span>
<span class="cm"> *</span>
<span class="cm"> * - For now, we won&#39;t try to interoperate with a real mmc/sd/sdio</span>
<span class="cm"> *   controller, although some of them do have hardware support for</span>
<span class="cm"> *   SPI protocol.  The main reason for such configs would be mmc-ish</span>
<span class="cm"> *   cards like DataFlash, which don&#39;t support that &quot;native&quot; protocol.</span>
<span class="cm"> *</span>
<span class="cm"> *   We don&#39;t have a &quot;DataFlash/MMC/SD/SDIO card slot&quot; abstraction to</span>
<span class="cm"> *   switch between driver stacks, and in any case if &quot;native&quot; mode</span>
<span class="cm"> *   is available, it will be faster and hence preferable.</span>
<span class="cm"> *</span>
<span class="cm"> * - MMC depends on a different chipselect management policy than the</span>
<span class="cm"> *   SPI interface currently supports for shared bus segments:  it needs</span>
<span class="cm"> *   to issue multiple spi_message requests with the chipselect active,</span>
<span class="cm"> *   using the results of one message to decide the next one to issue.</span>
<span class="cm"> *</span>
<span class="cm"> *   Pending updates to the programming interface, this driver expects</span>
<span class="cm"> *   that it not share the bus with other drivers (precluding conflicts).</span>
<span class="cm"> *</span>
<span class="cm"> * - We tell the controller to keep the chipselect active from the</span>
<span class="cm"> *   beginning of an mmc_host_ops.request until the end.  So beware</span>
<span class="cm"> *   of SPI controller drivers that mis-handle the cs_change flag!</span>
<span class="cm"> *</span>
<span class="cm"> *   However, many cards seem OK with chipselect flapping up/down</span>
<span class="cm"> *   during that time ... at least on unshared bus segments.</span>
<span class="cm"> */</span>


<span class="cm">/*</span>
<span class="cm"> * Local protocol constants, internal to data block protocols.</span>
<span class="cm"> */</span>

<span class="cm">/* Response tokens used to ack each block written: */</span>
<span class="cp">#define SPI_MMC_RESPONSE_CODE(x)	((x) &amp; 0x1f)</span>
<span class="cp">#define SPI_RESPONSE_ACCEPTED		((2 &lt;&lt; 1)|1)</span>
<span class="cp">#define SPI_RESPONSE_CRC_ERR		((5 &lt;&lt; 1)|1)</span>
<span class="cp">#define SPI_RESPONSE_WRITE_ERR		((6 &lt;&lt; 1)|1)</span>

<span class="cm">/* Read and write blocks start with these tokens and end with crc;</span>
<span class="cm"> * on error, read tokens act like a subset of R2_SPI_* values.</span>
<span class="cm"> */</span>
<span class="cp">#define SPI_TOKEN_SINGLE	0xfe	</span><span class="cm">/* single block r/w, multiblock read */</span><span class="cp"></span>
<span class="cp">#define SPI_TOKEN_MULTI_WRITE	0xfc	</span><span class="cm">/* multiblock write */</span><span class="cp"></span>
<span class="cp">#define SPI_TOKEN_STOP_TRAN	0xfd	</span><span class="cm">/* terminate multiblock write */</span><span class="cp"></span>

<span class="cp">#define MMC_SPI_BLOCKSIZE	512</span>


<span class="cm">/* These fixed timeouts come from the latest SD specs, which say to ignore</span>
<span class="cm"> * the CSD values.  The R1B value is for card erase (e.g. the &quot;I forgot the</span>
<span class="cm"> * card&#39;s password&quot; scenario); it&#39;s mostly applied to STOP_TRANSMISSION after</span>
<span class="cm"> * reads which takes nowhere near that long.  Older cards may be able to use</span>
<span class="cm"> * shorter timeouts ... but why bother?</span>
<span class="cm"> */</span>
<span class="cp">#define r1b_timeout		(HZ * 3)</span>

<span class="cm">/* One of the critical speed parameters is the amount of data which may</span>
<span class="cm"> * be transferred in one command. If this value is too low, the SD card</span>
<span class="cm"> * controller has to do multiple partial block writes (argggh!). With</span>
<span class="cm"> * today (2008) SD cards there is little speed gain if we transfer more</span>
<span class="cm"> * than 64 KBytes at a time. So use this value until there is any indication</span>
<span class="cm"> * that we should do more here.</span>
<span class="cm"> */</span>
<span class="cp">#define MMC_SPI_BLOCKSATONCE	128</span>

<span class="cm">/****************************************************************************/</span>

<span class="cm">/*</span>
<span class="cm"> * Local Data Structures</span>
<span class="cm"> */</span>

<span class="cm">/* &quot;scratch&quot; is per-{command,block} data exchanged with the card */</span>
<span class="k">struct</span> <span class="n">scratch</span> <span class="p">{</span>
	<span class="n">u8</span>			<span class="n">status</span><span class="p">[</span><span class="mi">29</span><span class="p">];</span>
	<span class="n">u8</span>			<span class="n">data_token</span><span class="p">;</span>
	<span class="n">__be16</span>			<span class="n">crc_val</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">mmc_spi_host</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">mmc_host</span>		<span class="o">*</span><span class="n">mmc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">spi_device</span>	<span class="o">*</span><span class="n">spi</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">power_mode</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">powerup_msecs</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">mmc_spi_platform_data</span>	<span class="o">*</span><span class="n">pdata</span><span class="p">;</span>

	<span class="cm">/* for bulk data transfers */</span>
	<span class="k">struct</span> <span class="n">spi_transfer</span>	<span class="n">token</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">crc</span><span class="p">,</span> <span class="n">early_status</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">spi_message</span>	<span class="n">m</span><span class="p">;</span>

	<span class="cm">/* for status readback */</span>
	<span class="k">struct</span> <span class="n">spi_transfer</span>	<span class="n">status</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">spi_message</span>	<span class="n">readback</span><span class="p">;</span>

	<span class="cm">/* underlying DMA-aware controller, or null */</span>
	<span class="k">struct</span> <span class="n">device</span>		<span class="o">*</span><span class="n">dma_dev</span><span class="p">;</span>

	<span class="cm">/* buffer used for commands and for message &quot;overhead&quot; */</span>
	<span class="k">struct</span> <span class="n">scratch</span>		<span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>		<span class="n">data_dma</span><span class="p">;</span>

	<span class="cm">/* Specs say to write ones most of the time, even when the card</span>
<span class="cm">	 * has no need to read its input data; and many cards won&#39;t care.</span>
<span class="cm">	 * This is our source of those ones.</span>
<span class="cm">	 */</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">ones</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>		<span class="n">ones_dma</span><span class="p">;</span>
<span class="p">};</span>


<span class="cm">/****************************************************************************/</span>

<span class="cm">/*</span>
<span class="cm"> * MMC-over-SPI protocol glue, used by the MMC stack interface</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">mmc_cs_off</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmc_spi_host</span> <span class="o">*</span><span class="n">host</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* chipselect will always be inactive after setup() */</span>
	<span class="k">return</span> <span class="n">spi_setup</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">spi</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">mmc_spi_readbytes</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmc_spi_host</span> <span class="o">*</span><span class="n">host</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">host</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">dma_dev</span><span class="p">)</span>
		<span class="n">dma_sync_single_for_device</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">dma_dev</span><span class="p">,</span>
				<span class="n">host</span><span class="o">-&gt;</span><span class="n">data_dma</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">),</span>
				<span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">spi_sync_locked</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">spi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">readback</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">dma_dev</span><span class="p">)</span>
		<span class="n">dma_sync_single_for_cpu</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">dma_dev</span><span class="p">,</span>
				<span class="n">host</span><span class="o">-&gt;</span><span class="n">data_dma</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">),</span>
				<span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mmc_spi_skip</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmc_spi_host</span> <span class="o">*</span><span class="n">host</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="n">n</span><span class="p">,</span> <span class="n">u8</span> <span class="n">byte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span>		<span class="o">*</span><span class="n">cp</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span>		<span class="n">status</span><span class="p">;</span>
		<span class="kt">unsigned</span>	<span class="n">i</span><span class="p">;</span>

		<span class="n">status</span> <span class="o">=</span> <span class="n">mmc_spi_readbytes</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">status</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">byte</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">cp</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">time_is_before_jiffies</span><span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">timeout</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* If we need long timeouts, we may release the CPU.</span>
<span class="cm">		 * We use jiffies here because we want to have a relation</span>
<span class="cm">		 * between elapsed time and the blocking of the scheduler.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">time_is_before_jiffies</span><span class="p">(</span><span class="n">start</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
			<span class="n">schedule</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">mmc_spi_wait_unbusy</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmc_spi_host</span> <span class="o">*</span><span class="n">host</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">mmc_spi_skip</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">timeout</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mmc_spi_readtoken</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmc_spi_host</span> <span class="o">*</span><span class="n">host</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">mmc_spi_skip</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">timeout</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Note that for SPI, cmd-&gt;resp[0] is not the same data as &quot;native&quot; protocol</span>
<span class="cm"> * hosts return!  The low byte holds R1_SPI bits.  The next byte may hold</span>
<span class="cm"> * R2_SPI bits ... for SEND_STATUS, or after data read errors.</span>
<span class="cm"> *</span>
<span class="cm"> * cmd-&gt;resp[1] holds any four-byte response, for R3 (READ_OCR) and on</span>
<span class="cm"> * newer cards R7 (IF_COND).</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">maptype</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmc_command</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">mmc_spi_resp_type</span><span class="p">(</span><span class="n">cmd</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">MMC_RSP_SPI_R1</span>:	<span class="k">return</span> <span class="s">&quot;R1&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MMC_RSP_SPI_R1B</span>:	<span class="k">return</span> <span class="s">&quot;R1B&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MMC_RSP_SPI_R2</span>:	<span class="k">return</span> <span class="s">&quot;R2/R5&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MMC_RSP_SPI_R3</span>:	<span class="k">return</span> <span class="s">&quot;R3/R4/R7&quot;</span><span class="p">;</span>
	<span class="nl">default:</span>		<span class="k">return</span> <span class="s">&quot;?&quot;</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* return zero, else negative errno after setting cmd-&gt;error */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mmc_spi_response_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmc_spi_host</span> <span class="o">*</span><span class="n">host</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">mmc_command</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cs_on</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span>	<span class="o">*</span><span class="n">cp</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="o">*</span><span class="n">end</span> <span class="o">=</span> <span class="n">cp</span> <span class="o">+</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">t</span><span class="p">.</span><span class="n">len</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">bitshift</span><span class="p">;</span>
	<span class="n">u8</span> 	<span class="n">leftover</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">rotator</span><span class="p">;</span>
	<span class="kt">int</span> 	<span class="n">i</span><span class="p">;</span>
	<span class="kt">char</span>	<span class="n">tag</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>

	<span class="n">snprintf</span><span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tag</span><span class="p">),</span> <span class="s">&quot;  ... CMD%d response SPI_%s&quot;</span><span class="p">,</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">opcode</span><span class="p">,</span> <span class="n">maptype</span><span class="p">(</span><span class="n">cmd</span><span class="p">));</span>

	<span class="cm">/* Except for data block reads, the whole response will already</span>
<span class="cm">	 * be stored in the scratch buffer.  It&#39;s somewhere after the</span>
<span class="cm">	 * command and the first byte we read after it.  We ignore that</span>
<span class="cm">	 * first byte.  After STOP_TRANSMISSION command it may include</span>
<span class="cm">	 * two data bits, but otherwise it&#39;s all ones.</span>
<span class="cm">	 */</span>
	<span class="n">cp</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">cp</span> <span class="o">&lt;</span> <span class="n">end</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">cp</span> <span class="o">==</span> <span class="mh">0xff</span><span class="p">)</span>
		<span class="n">cp</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* Data block reads (R1 response types) may need more data... */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cp</span> <span class="o">==</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cp</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">;</span>
		<span class="n">end</span> <span class="o">=</span> <span class="n">cp</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* Card sends N(CR) (== 1..8) bytes of all-ones then one</span>
<span class="cm">		 * status byte ... and we already scanned 2 bytes.</span>
<span class="cm">		 *</span>
<span class="cm">		 * REVISIT block read paths use nasty byte-at-a-time I/O</span>
<span class="cm">		 * so it can always DMA directly into the target buffer.</span>
<span class="cm">		 * It&#39;d probably be better to memcpy() the first chunk and</span>
<span class="cm">		 * avoid extra i/o calls...</span>
<span class="cm">		 *</span>
<span class="cm">		 * Note we check for more than 8 bytes, because in practice,</span>
<span class="cm">		 * some SD cards are slow...</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">value</span> <span class="o">=</span> <span class="n">mmc_spi_readbytes</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">cp</span> <span class="o">!=</span> <span class="mh">0xff</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">checkstatus</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">value</span> <span class="o">=</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">checkstatus:</span>
	<span class="n">bitshift</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">cp</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">)</span>	<span class="p">{</span>
		<span class="cm">/* Houston, we have an ugly card with a bit-shifted response */</span>
		<span class="n">rotator</span> <span class="o">=</span> <span class="o">*</span><span class="n">cp</span><span class="o">++</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>
		<span class="cm">/* read the next byte */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cp</span> <span class="o">==</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">value</span> <span class="o">=</span> <span class="n">mmc_spi_readbytes</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
			<span class="n">cp</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">;</span>
			<span class="n">end</span> <span class="o">=</span> <span class="n">cp</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">rotator</span> <span class="o">|=</span> <span class="o">*</span><span class="n">cp</span><span class="o">++</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">rotator</span> <span class="o">&amp;</span> <span class="mh">0x8000</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">bitshift</span><span class="o">++</span><span class="p">;</span>
			<span class="n">rotator</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">resp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">rotator</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">leftover</span> <span class="o">=</span> <span class="n">rotator</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">resp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">*</span><span class="n">cp</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Status byte: the entire seven-bit R1 response.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">resp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">R1_SPI_PARAMETER</span> <span class="o">|</span> <span class="n">R1_SPI_ADDRESS</span><span class="p">)</span>
				<span class="o">&amp;</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">resp</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
			<span class="n">value</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span> <span class="cm">/* Bad address */</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">R1_SPI_ILLEGAL_COMMAND</span> <span class="o">&amp;</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">resp</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
			<span class="n">value</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span> <span class="cm">/* Function not implemented */</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">R1_SPI_COM_CRC</span> <span class="o">&amp;</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">resp</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
			<span class="n">value</span> <span class="o">=</span> <span class="o">-</span><span class="n">EILSEQ</span><span class="p">;</span> <span class="cm">/* Illegal byte sequence */</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">R1_SPI_ERASE_SEQ</span> <span class="o">|</span> <span class="n">R1_SPI_ERASE_RESET</span><span class="p">)</span>
				<span class="o">&amp;</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">resp</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
			<span class="n">value</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>    <span class="cm">/* I/O error */</span>
		<span class="cm">/* else R1_SPI_IDLE, &quot;it&#39;s resetting&quot; */</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">mmc_spi_resp_type</span><span class="p">(</span><span class="n">cmd</span><span class="p">))</span> <span class="p">{</span>

	<span class="cm">/* SPI R1B == R1 + busy; STOP_TRANSMISSION (for multiblock reads)</span>
<span class="cm">	 * and less-common stuff like various erase operations.</span>
<span class="cm">	 */</span>
	<span class="k">case</span> <span class="n">MMC_RSP_SPI_R1B</span>:
		<span class="cm">/* maybe we read all the busy tokens already */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">cp</span> <span class="o">&lt;</span> <span class="n">end</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">cp</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">cp</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cp</span> <span class="o">==</span> <span class="n">end</span><span class="p">)</span>
			<span class="n">mmc_spi_wait_unbusy</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">r1b_timeout</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="cm">/* SPI R2 == R1 + second status byte; SEND_STATUS</span>
<span class="cm">	 * SPI R5 == R1 + data byte; IO_RW_DIRECT</span>
<span class="cm">	 */</span>
	<span class="k">case</span> <span class="n">MMC_RSP_SPI_R2</span>:
		<span class="cm">/* read the next byte */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cp</span> <span class="o">==</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">value</span> <span class="o">=</span> <span class="n">mmc_spi_readbytes</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
			<span class="n">cp</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">;</span>
			<span class="n">end</span> <span class="o">=</span> <span class="n">cp</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bitshift</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rotator</span> <span class="o">=</span> <span class="n">leftover</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>
			<span class="n">rotator</span> <span class="o">|=</span> <span class="o">*</span><span class="n">cp</span> <span class="o">&lt;&lt;</span> <span class="n">bitshift</span><span class="p">;</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">resp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|=</span> <span class="p">(</span><span class="n">rotator</span> <span class="o">&amp;</span> <span class="mh">0xFF00</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">resp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|=</span> <span class="o">*</span><span class="n">cp</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="cm">/* SPI R3, R4, or R7 == R1 + 4 bytes */</span>
	<span class="k">case</span> <span class="n">MMC_RSP_SPI_R3</span>:
		<span class="n">rotator</span> <span class="o">=</span> <span class="n">leftover</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">resp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">resp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;=</span> <span class="mi">8</span><span class="p">;</span>
			<span class="cm">/* read the next byte */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cp</span> <span class="o">==</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">value</span> <span class="o">=</span> <span class="n">mmc_spi_readbytes</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
				<span class="n">cp</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">;</span>
				<span class="n">end</span> <span class="o">=</span> <span class="n">cp</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bitshift</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">rotator</span> <span class="o">|=</span> <span class="o">*</span><span class="n">cp</span><span class="o">++</span> <span class="o">&lt;&lt;</span> <span class="n">bitshift</span><span class="p">;</span>
				<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">resp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">|=</span> <span class="p">(</span><span class="n">rotator</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">);</span>
				<span class="n">rotator</span> <span class="o">&lt;&lt;=</span> <span class="mi">8</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">resp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">|=</span> <span class="o">*</span><span class="n">cp</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="cm">/* SPI R1 == just one status byte */</span>
	<span class="k">case</span> <span class="n">MMC_RSP_SPI_R1</span>:
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;bad response type %04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">mmc_spi_resp_type</span><span class="p">(</span><span class="n">cmd</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">value</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: resp %04x %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">tag</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">resp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">resp</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

	<span class="cm">/* disable chipselect on errors and some success cases */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">cs_on</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">value</span><span class="p">;</span>
<span class="nl">done:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
	<span class="n">mmc_cs_off</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Issue command and read its response.</span>
<span class="cm"> * Returns zero on success, negative for error.</span>
<span class="cm"> *</span>
<span class="cm"> * On error, caller must cope with mmc core retry mechanism.  That</span>
<span class="cm"> * means immediate low-level resubmit, which affects the bus lock...</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">mmc_spi_command_send</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmc_spi_host</span> <span class="o">*</span><span class="n">host</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">mmc_request</span> <span class="o">*</span><span class="n">mrq</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">mmc_command</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cs_on</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scratch</span>		<span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="o">*</span><span class="n">cp</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">arg</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">arg</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">status</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">spi_transfer</span>	<span class="o">*</span><span class="n">t</span><span class="p">;</span>

	<span class="cm">/* We can handle most commands (except block reads) in one full</span>
<span class="cm">	 * duplex I/O operation before either starting the next transfer</span>
<span class="cm">	 * (data block or command) or else deselecting the card.</span>
<span class="cm">	 *</span>
<span class="cm">	 * First, write 7 bytes:</span>
<span class="cm">	 *  - an all-ones byte to ensure the card is ready</span>
<span class="cm">	 *  - opcode byte (plus start and transmission bits)</span>
<span class="cm">	 *  - four bytes of big-endian argument</span>
<span class="cm">	 *  - crc7 (plus end bit) ... always computed, it&#39;s cheap</span>
<span class="cm">	 *</span>
<span class="cm">	 * We init the whole buffer to all-ones, which is what we need</span>
<span class="cm">	 * to write while we&#39;re reading (later) response data.</span>
<span class="cm">	 */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">cp</span><span class="o">++</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">));</span>

	<span class="o">*</span><span class="n">cp</span><span class="o">++</span> <span class="o">=</span> <span class="mh">0x40</span> <span class="o">|</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">opcode</span><span class="p">;</span>
	<span class="o">*</span><span class="n">cp</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)(</span><span class="n">arg</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">);</span>
	<span class="o">*</span><span class="n">cp</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)(</span><span class="n">arg</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">);</span>
	<span class="o">*</span><span class="n">cp</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)(</span><span class="n">arg</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">);</span>
	<span class="o">*</span><span class="n">cp</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
	<span class="o">*</span><span class="n">cp</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="n">crc7</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">5</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x01</span><span class="p">;</span>

	<span class="cm">/* Then, read up to 13 bytes (while writing all-ones):</span>
<span class="cm">	 *  - N(CR) (== 1..8) bytes of all-ones</span>
<span class="cm">	 *  - status byte (for all response types)</span>
<span class="cm">	 *  - the rest of the response, either:</span>
<span class="cm">	 *      + nothing, for R1 or R1B responses</span>
<span class="cm">	 *	+ second status byte, for R2 responses</span>
<span class="cm">	 *	+ four data bytes, for R3 and R7 responses</span>
<span class="cm">	 *</span>
<span class="cm">	 * Finally, read some more bytes ... in the nice cases we know in</span>
<span class="cm">	 * advance how many, and reading 1 more is always OK:</span>
<span class="cm">	 *  - N(EC) (== 0..N) bytes of all-ones, before deselect/finish</span>
<span class="cm">	 *  - N(RC) (== 1..N) bytes of all-ones, before next command</span>
<span class="cm">	 *  - N(WR) (== 1..N) bytes of all-ones, before data write</span>
<span class="cm">	 *</span>
<span class="cm">	 * So in those cases one full duplex I/O of at most 21 bytes will</span>
<span class="cm">	 * handle the whole command, leaving the card ready to receive a</span>
<span class="cm">	 * data block or new command.  We do that whenever we can, shaving</span>
<span class="cm">	 * CPU and IRQ costs (especially when using DMA or FIFOs).</span>
<span class="cm">	 *</span>
<span class="cm">	 * There are two other cases, where it&#39;s not generally practical</span>
<span class="cm">	 * to rely on a single I/O:</span>
<span class="cm">	 *</span>
<span class="cm">	 *  - R1B responses need at least N(EC) bytes of all-zeroes.</span>
<span class="cm">	 *</span>
<span class="cm">	 *    In this case we can *try* to fit it into one I/O, then</span>
<span class="cm">	 *    maybe read more data later.</span>
<span class="cm">	 *</span>
<span class="cm">	 *  - Data block reads are more troublesome, since a variable</span>
<span class="cm">	 *    number of padding bytes precede the token and data.</span>
<span class="cm">	 *      + N(CX) (== 0..8) bytes of all-ones, before CSD or CID</span>
<span class="cm">	 *      + N(AC) (== 1..many) bytes of all-ones</span>
<span class="cm">	 *</span>
<span class="cm">	 *    In this case we currently only have minimal speedups here:</span>
<span class="cm">	 *    when N(CR) == 1 we can avoid I/O in response_get().</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cs_on</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">mrq</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MMC_DATA_READ</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cp</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>	<span class="cm">/* min(N(CR)) + status */</span>
		<span class="cm">/* R1 */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">cp</span> <span class="o">+=</span> <span class="mi">10</span><span class="p">;</span>	<span class="cm">/* max(N(CR)) + status + min(N(RC),N(WR)) */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MMC_RSP_SPI_S2</span><span class="p">)</span>	<span class="cm">/* R2/R5 */</span>
			<span class="n">cp</span><span class="o">++</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MMC_RSP_SPI_B4</span><span class="p">)</span>	<span class="cm">/* R3/R4/R7 */</span>
			<span class="n">cp</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MMC_RSP_BUSY</span><span class="p">)</span>	<span class="cm">/* R1B */</span>
			<span class="n">cp</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
		<span class="cm">/* else:  R1 (most commands) */</span>
	<span class="p">}</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;  mmc_spi: CMD%d, resp %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">opcode</span><span class="p">,</span> <span class="n">maptype</span><span class="p">(</span><span class="n">cmd</span><span class="p">));</span>

	<span class="cm">/* send command, leaving chipselect active */</span>
	<span class="n">spi_message_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">);</span>

	<span class="n">t</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">t</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">t</span><span class="p">));</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">tx_buf</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">rx_buf</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">;</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">tx_dma</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">rx_dma</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">data_dma</span><span class="p">;</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">cp</span> <span class="o">-</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">;</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">cs_change</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">spi_message_add_tail</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">dma_dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">host</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">.</span><span class="n">is_dma_mapped</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">dma_sync_single_for_device</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">dma_dev</span><span class="p">,</span>
				<span class="n">host</span><span class="o">-&gt;</span><span class="n">data_dma</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">),</span>
				<span class="n">DMA_BIDIRECTIONAL</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">spi_sync_locked</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">spi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">dma_dev</span><span class="p">)</span>
		<span class="n">dma_sync_single_for_cpu</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">dma_dev</span><span class="p">,</span>
				<span class="n">host</span><span class="o">-&gt;</span><span class="n">data_dma</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">),</span>
				<span class="n">DMA_BIDIRECTIONAL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;  ... write returned %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="n">status</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* after no-data commands and STOP_TRANSMISSION, chipselect off */</span>
	<span class="k">return</span> <span class="n">mmc_spi_response_get</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">cs_on</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Build data message with up to four separate transfers.  For TX, we</span>
<span class="cm"> * start by writing the data token.  And in most cases, we finish with</span>
<span class="cm"> * a status transfer.</span>
<span class="cm"> *</span>
<span class="cm"> * We always provide TX data for data and CRC.  The MMC/SD protocol</span>
<span class="cm"> * requires us to write ones; but Linux defaults to writing zeroes;</span>
<span class="cm"> * so we explicitly initialize it to all ones on RX paths.</span>
<span class="cm"> *</span>
<span class="cm"> * We also handle DMA mapping, so the underlying SPI controller does</span>
<span class="cm"> * not need to (re)do it for each message.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">mmc_spi_setup_data_message</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">mmc_spi_host</span>	<span class="o">*</span><span class="n">host</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">multiple</span><span class="p">,</span>
	<span class="k">enum</span> <span class="n">dma_data_direction</span>	<span class="n">direction</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spi_transfer</span>	<span class="o">*</span><span class="n">t</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scratch</span>		<span class="o">*</span><span class="n">scratch</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>		<span class="n">dma</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">data_dma</span><span class="p">;</span>

	<span class="n">spi_message_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dma</span><span class="p">)</span>
		<span class="n">host</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">.</span><span class="n">is_dma_mapped</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* for reads, readblock() skips 0xff bytes before finding</span>
<span class="cm">	 * the token; for writes, this transfer issues that token.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">direction</span> <span class="o">==</span> <span class="n">DMA_TO_DEVICE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">t</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">token</span><span class="p">;</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">t</span><span class="p">));</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">multiple</span><span class="p">)</span>
			<span class="n">scratch</span><span class="o">-&gt;</span><span class="n">data_token</span> <span class="o">=</span> <span class="n">SPI_TOKEN_MULTI_WRITE</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">scratch</span><span class="o">-&gt;</span><span class="n">data_token</span> <span class="o">=</span> <span class="n">SPI_TOKEN_SINGLE</span><span class="p">;</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">tx_buf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">scratch</span><span class="o">-&gt;</span><span class="n">data_token</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dma</span><span class="p">)</span>
			<span class="n">t</span><span class="o">-&gt;</span><span class="n">tx_dma</span> <span class="o">=</span> <span class="n">dma</span> <span class="o">+</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">scratch</span><span class="p">,</span> <span class="n">data_token</span><span class="p">);</span>
		<span class="n">spi_message_add_tail</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Body of transfer is buffer, then CRC ...</span>
<span class="cm">	 * either TX-only, or RX with TX-ones.</span>
<span class="cm">	 */</span>
	<span class="n">t</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">t</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">t</span><span class="p">));</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">tx_buf</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">ones</span><span class="p">;</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">tx_dma</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">ones_dma</span><span class="p">;</span>
	<span class="cm">/* length and actual buffer info are written later */</span>
	<span class="n">spi_message_add_tail</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">);</span>

	<span class="n">t</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">crc</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">t</span><span class="p">));</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">direction</span> <span class="o">==</span> <span class="n">DMA_TO_DEVICE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* the actual CRC may get written later */</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">tx_buf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">scratch</span><span class="o">-&gt;</span><span class="n">crc_val</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dma</span><span class="p">)</span>
			<span class="n">t</span><span class="o">-&gt;</span><span class="n">tx_dma</span> <span class="o">=</span> <span class="n">dma</span> <span class="o">+</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">scratch</span><span class="p">,</span> <span class="n">crc_val</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">tx_buf</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">ones</span><span class="p">;</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">tx_dma</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">ones_dma</span><span class="p">;</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">rx_buf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">scratch</span><span class="o">-&gt;</span><span class="n">crc_val</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dma</span><span class="p">)</span>
			<span class="n">t</span><span class="o">-&gt;</span><span class="n">rx_dma</span> <span class="o">=</span> <span class="n">dma</span> <span class="o">+</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">scratch</span><span class="p">,</span> <span class="n">crc_val</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spi_message_add_tail</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * A single block read is followed by N(EC) [0+] all-ones bytes</span>
<span class="cm">	 * before deselect ... don&#39;t bother.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Multiblock reads are followed by N(AC) [1+] all-ones bytes before</span>
<span class="cm">	 * the next block is read, or a STOP_TRANSMISSION is issued.  We&#39;ll</span>
<span class="cm">	 * collect that single byte, so readblock() doesn&#39;t need to.</span>
<span class="cm">	 *</span>
<span class="cm">	 * For a write, the one-byte data response follows immediately, then</span>
<span class="cm">	 * come zero or more busy bytes, then N(WR) [1+] all-ones bytes.</span>
<span class="cm">	 * Then single block reads may deselect, and multiblock ones issue</span>
<span class="cm">	 * the next token (next data block, or STOP_TRAN).  We can try to</span>
<span class="cm">	 * minimize I/O ops by using a single read to collect end-of-busy.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">multiple</span> <span class="o">||</span> <span class="n">direction</span> <span class="o">==</span> <span class="n">DMA_TO_DEVICE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">t</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">early_status</span><span class="p">;</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">t</span><span class="p">));</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="p">(</span><span class="n">direction</span> <span class="o">==</span> <span class="n">DMA_TO_DEVICE</span><span class="p">)</span>
				<span class="o">?</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">scratch</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">)</span>
				<span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">tx_buf</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">ones</span><span class="p">;</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">tx_dma</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">ones_dma</span><span class="p">;</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">rx_buf</span> <span class="o">=</span> <span class="n">scratch</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dma</span><span class="p">)</span>
			<span class="n">t</span><span class="o">-&gt;</span><span class="n">rx_dma</span> <span class="o">=</span> <span class="n">dma</span> <span class="o">+</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">scratch</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">cs_change</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">spi_message_add_tail</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Write one block:</span>
<span class="cm"> *  - caller handled preceding N(WR) [1+] all-ones bytes</span>
<span class="cm"> *  - data block</span>
<span class="cm"> *	+ token</span>
<span class="cm"> *	+ data bytes</span>
<span class="cm"> *	+ crc16</span>
<span class="cm"> *  - an all-ones byte ... card writes a data-response byte</span>
<span class="cm"> *  - followed by N(EC) [0+] all-ones bytes, card writes zero/&#39;busy&#39;</span>
<span class="cm"> *</span>
<span class="cm"> * Return negative errno, else success.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">mmc_spi_writeblock</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmc_spi_host</span> <span class="o">*</span><span class="n">host</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spi_transfer</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spi_device</span>	<span class="o">*</span><span class="n">spi</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">spi</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">status</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scratch</span>		<span class="o">*</span><span class="n">scratch</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">pattern</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">mmc</span><span class="o">-&gt;</span><span class="n">use_spi_crc</span><span class="p">)</span>
		<span class="n">scratch</span><span class="o">-&gt;</span><span class="n">crc_val</span> <span class="o">=</span> <span class="n">cpu_to_be16</span><span class="p">(</span>
				<span class="n">crc_itu_t</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">tx_buf</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">dma_dev</span><span class="p">)</span>
		<span class="n">dma_sync_single_for_device</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">dma_dev</span><span class="p">,</span>
				<span class="n">host</span><span class="o">-&gt;</span><span class="n">data_dma</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">scratch</span><span class="p">),</span>
				<span class="n">DMA_BIDIRECTIONAL</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">spi_sync_locked</span><span class="p">(</span><span class="n">spi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;write error (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">dma_dev</span><span class="p">)</span>
		<span class="n">dma_sync_single_for_cpu</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">dma_dev</span><span class="p">,</span>
				<span class="n">host</span><span class="o">-&gt;</span><span class="n">data_dma</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">scratch</span><span class="p">),</span>
				<span class="n">DMA_BIDIRECTIONAL</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Get the transmission data-response reply.  It must follow</span>
<span class="cm">	 * immediately after the data block we transferred.  This reply</span>
<span class="cm">	 * doesn&#39;t necessarily tell whether the write operation succeeded;</span>
<span class="cm">	 * it just says if the transmission was ok and whether *earlier*</span>
<span class="cm">	 * writes succeeded; see the standard.</span>
<span class="cm">	 *</span>
<span class="cm">	 * In practice, there are (even modern SDHC-)cards which are late</span>
<span class="cm">	 * in sending the response, and miss the time frame by a few bits,</span>
<span class="cm">	 * so we have to cope with this situation and check the response</span>
<span class="cm">	 * bit-by-bit. Arggh!!!</span>
<span class="cm">	 */</span>
	<span class="n">pattern</span>  <span class="o">=</span> <span class="n">scratch</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">;</span>
	<span class="n">pattern</span> <span class="o">|=</span> <span class="n">scratch</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
	<span class="n">pattern</span> <span class="o">|=</span> <span class="n">scratch</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">pattern</span> <span class="o">|=</span> <span class="n">scratch</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>

	<span class="cm">/* First 3 bit of pattern are undefined */</span>
	<span class="n">pattern</span> <span class="o">|=</span> <span class="mh">0xE0000000</span><span class="p">;</span>

	<span class="cm">/* left-adjust to leading 0 bit */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">pattern</span> <span class="o">&amp;</span> <span class="mh">0x80000000</span><span class="p">)</span>
		<span class="n">pattern</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/* right-adjust for pattern matching. Code is in bit 4..0 now. */</span>
	<span class="n">pattern</span> <span class="o">&gt;&gt;=</span> <span class="mi">27</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">pattern</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SPI_RESPONSE_ACCEPTED</span>:
		<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SPI_RESPONSE_CRC_ERR</span>:
		<span class="cm">/* host shall then issue MMC_STOP_TRANSMISSION */</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EILSEQ</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SPI_RESPONSE_WRITE_ERR</span>:
		<span class="cm">/* host shall then issue MMC_STOP_TRANSMISSION,</span>
<span class="cm">		 * and should MMC_SEND_STATUS to sort it out</span>
<span class="cm">		 */</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPROTO</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;write error %02x (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">scratch</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">status</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">t</span><span class="o">-&gt;</span><span class="n">tx_buf</span> <span class="o">+=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">dma_dev</span><span class="p">)</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">tx_dma</span> <span class="o">+=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

	<span class="cm">/* Return when not busy.  If we didn&#39;t collect that status yet,</span>
<span class="cm">	 * we&#39;ll need some more I/O.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">scratch</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* card is non-busy if the most recent bit is 1 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">scratch</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">mmc_spi_wait_unbusy</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Read one block:</span>
<span class="cm"> *  - skip leading all-ones bytes ... either</span>
<span class="cm"> *      + N(AC) [1..f(clock,CSD)] usually, else</span>
<span class="cm"> *      + N(CX) [0..8] when reading CSD or CID</span>
<span class="cm"> *  - data block</span>
<span class="cm"> *	+ token ... if error token, no data or crc</span>
<span class="cm"> *	+ data bytes</span>
<span class="cm"> *	+ crc16</span>
<span class="cm"> *</span>
<span class="cm"> * After single block reads, we&#39;re done; N(EC) [0+] all-ones bytes follow</span>
<span class="cm"> * before dropping chipselect.</span>
<span class="cm"> *</span>
<span class="cm"> * For multiblock reads, caller either reads the next block or issues a</span>
<span class="cm"> * STOP_TRANSMISSION command.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">mmc_spi_readblock</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmc_spi_host</span> <span class="o">*</span><span class="n">host</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spi_transfer</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spi_device</span>	<span class="o">*</span><span class="n">spi</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">spi</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">status</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scratch</span>		<span class="o">*</span><span class="n">scratch</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> 		<span class="n">bitshift</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">leftover</span><span class="p">;</span>

	<span class="cm">/* At least one SD card sends an all-zeroes byte when N(CX)</span>
<span class="cm">	 * applies, before the all-ones bytes ... just cope with that.</span>
<span class="cm">	 */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">mmc_spi_readbytes</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">scratch</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mh">0xff</span> <span class="o">||</span> <span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">mmc_spi_readtoken</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;read error %02x (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* The token may be bit-shifted...</span>
<span class="cm">	 * the first 0-bit precedes the data stream.</span>
<span class="cm">	 */</span>
	<span class="n">bitshift</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">bitshift</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">leftover</span> <span class="o">=</span> <span class="n">status</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">dma_dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dma_sync_single_for_device</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">dma_dev</span><span class="p">,</span>
				<span class="n">host</span><span class="o">-&gt;</span><span class="n">data_dma</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">scratch</span><span class="p">),</span>
				<span class="n">DMA_BIDIRECTIONAL</span><span class="p">);</span>
		<span class="n">dma_sync_single_for_device</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">dma_dev</span><span class="p">,</span>
				<span class="n">t</span><span class="o">-&gt;</span><span class="n">rx_dma</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
				<span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">spi_sync_locked</span><span class="p">(</span><span class="n">spi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">dma_dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dma_sync_single_for_cpu</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">dma_dev</span><span class="p">,</span>
				<span class="n">host</span><span class="o">-&gt;</span><span class="n">data_dma</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">scratch</span><span class="p">),</span>
				<span class="n">DMA_BIDIRECTIONAL</span><span class="p">);</span>
		<span class="n">dma_sync_single_for_cpu</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">dma_dev</span><span class="p">,</span>
				<span class="n">t</span><span class="o">-&gt;</span><span class="n">rx_dma</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
				<span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bitshift</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Walk through the data and the crc and do</span>
<span class="cm">		 * all the magic to get byte-aligned data.</span>
<span class="cm">		 */</span>
		<span class="n">u8</span> <span class="o">*</span><span class="n">cp</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">rx_buf</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bitright</span> <span class="o">=</span> <span class="mi">8</span> <span class="o">-</span> <span class="n">bitshift</span><span class="p">;</span>
		<span class="n">u8</span> <span class="n">temp</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">len</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span> <span class="n">len</span><span class="p">;</span> <span class="n">len</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">temp</span> <span class="o">=</span> <span class="o">*</span><span class="n">cp</span><span class="p">;</span>
			<span class="o">*</span><span class="n">cp</span><span class="o">++</span> <span class="o">=</span> <span class="n">leftover</span> <span class="o">|</span> <span class="p">(</span><span class="n">temp</span> <span class="o">&gt;&gt;</span> <span class="n">bitshift</span><span class="p">);</span>
			<span class="n">leftover</span> <span class="o">=</span> <span class="n">temp</span> <span class="o">&lt;&lt;</span> <span class="n">bitright</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">cp</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">scratch</span><span class="o">-&gt;</span><span class="n">crc_val</span><span class="p">;</span>
		<span class="n">temp</span> <span class="o">=</span> <span class="o">*</span><span class="n">cp</span><span class="p">;</span>
		<span class="o">*</span><span class="n">cp</span><span class="o">++</span> <span class="o">=</span> <span class="n">leftover</span> <span class="o">|</span> <span class="p">(</span><span class="n">temp</span> <span class="o">&gt;&gt;</span> <span class="n">bitshift</span><span class="p">);</span>
		<span class="n">leftover</span> <span class="o">=</span> <span class="n">temp</span> <span class="o">&lt;&lt;</span> <span class="n">bitright</span><span class="p">;</span>
		<span class="n">temp</span> <span class="o">=</span> <span class="o">*</span><span class="n">cp</span><span class="p">;</span>
		<span class="o">*</span><span class="n">cp</span> <span class="o">=</span> <span class="n">leftover</span> <span class="o">|</span> <span class="p">(</span><span class="n">temp</span> <span class="o">&gt;&gt;</span> <span class="n">bitshift</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">mmc</span><span class="o">-&gt;</span><span class="n">use_spi_crc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u16</span> <span class="n">crc</span> <span class="o">=</span> <span class="n">crc_itu_t</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">rx_buf</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>

		<span class="n">be16_to_cpus</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scratch</span><span class="o">-&gt;</span><span class="n">crc_val</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">scratch</span><span class="o">-&gt;</span><span class="n">crc_val</span> <span class="o">!=</span> <span class="n">crc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;read - crc error: crc_val=0x%04x, &quot;</span>
					<span class="s">&quot;computed=0x%04x len=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">scratch</span><span class="o">-&gt;</span><span class="n">crc_val</span><span class="p">,</span> <span class="n">crc</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EILSEQ</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">t</span><span class="o">-&gt;</span><span class="n">rx_buf</span> <span class="o">+=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">dma_dev</span><span class="p">)</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">rx_dma</span> <span class="o">+=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * An MMC/SD data stage includes one or more blocks, optional CRCs,</span>
<span class="cm"> * and inline handshaking.  That handhaking makes it unlike most</span>
<span class="cm"> * other SPI protocol stacks.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">mmc_spi_data_do</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmc_spi_host</span> <span class="o">*</span><span class="n">host</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mmc_command</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">mmc_data</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">u32</span> <span class="n">blk_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spi_device</span>	<span class="o">*</span><span class="n">spi</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">spi</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span>		<span class="o">*</span><span class="n">dma_dev</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">dma_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">spi_transfer</span>	<span class="o">*</span><span class="n">t</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">dma_data_direction</span>	<span class="n">direction</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span>	<span class="o">*</span><span class="n">sg</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">n_sg</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">multiple</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">blocks</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">u32</span>			<span class="n">clock_rate</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">timeout</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MMC_DATA_READ</span><span class="p">)</span>
		<span class="n">direction</span> <span class="o">=</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">direction</span> <span class="o">=</span> <span class="n">DMA_TO_DEVICE</span><span class="p">;</span>
	<span class="n">mmc_spi_setup_data_message</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">multiple</span><span class="p">,</span> <span class="n">direction</span><span class="p">);</span>
	<span class="n">t</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">t</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">speed_hz</span><span class="p">)</span>
		<span class="n">clock_rate</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">speed_hz</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">clock_rate</span> <span class="o">=</span> <span class="n">spi</span><span class="o">-&gt;</span><span class="n">max_speed_hz</span><span class="p">;</span>

	<span class="n">timeout</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">timeout_ns</span> <span class="o">+</span>
		  <span class="n">data</span><span class="o">-&gt;</span><span class="n">timeout_clks</span> <span class="o">*</span> <span class="mi">1000000</span> <span class="o">/</span> <span class="n">clock_rate</span><span class="p">;</span>
	<span class="n">timeout</span> <span class="o">=</span> <span class="n">usecs_to_jiffies</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)(</span><span class="n">timeout</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Handle scatterlist segments one at a time, with synch for</span>
<span class="cm">	 * each 512-byte block</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">sg</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">sg</span><span class="p">,</span> <span class="n">n_sg</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">sg_len</span><span class="p">;</span> <span class="n">n_sg</span><span class="p">;</span> <span class="n">n_sg</span><span class="o">--</span><span class="p">,</span> <span class="n">sg</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span>			<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">dma_addr_t</span>		<span class="n">dma_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="kt">void</span>			<span class="o">*</span><span class="n">kmap_addr</span><span class="p">;</span>
		<span class="kt">unsigned</span>		<span class="n">length</span> <span class="o">=</span> <span class="n">sg</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
		<span class="k">enum</span> <span class="n">dma_data_direction</span>	<span class="n">dir</span> <span class="o">=</span> <span class="n">direction</span><span class="p">;</span>

		<span class="cm">/* set up dma mapping for controller drivers that might</span>
<span class="cm">		 * use DMA ... though they may fall back to PIO</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dma_dev</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* never invalidate whole *shared* pages ... */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">sg</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">length</span> <span class="o">!=</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
					<span class="o">&amp;&amp;</span> <span class="n">dir</span> <span class="o">==</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">)</span>
				<span class="n">dir</span> <span class="o">=</span> <span class="n">DMA_BIDIRECTIONAL</span><span class="p">;</span>

			<span class="n">dma_addr</span> <span class="o">=</span> <span class="n">dma_map_page</span><span class="p">(</span><span class="n">dma_dev</span><span class="p">,</span> <span class="n">sg_page</span><span class="p">(</span><span class="n">sg</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
						<span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">direction</span> <span class="o">==</span> <span class="n">DMA_TO_DEVICE</span><span class="p">)</span>
				<span class="n">t</span><span class="o">-&gt;</span><span class="n">tx_dma</span> <span class="o">=</span> <span class="n">dma_addr</span> <span class="o">+</span> <span class="n">sg</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">t</span><span class="o">-&gt;</span><span class="n">rx_dma</span> <span class="o">=</span> <span class="n">dma_addr</span> <span class="o">+</span> <span class="n">sg</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* allow pio too; we don&#39;t allow highmem */</span>
		<span class="n">kmap_addr</span> <span class="o">=</span> <span class="n">kmap</span><span class="p">(</span><span class="n">sg_page</span><span class="p">(</span><span class="n">sg</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">direction</span> <span class="o">==</span> <span class="n">DMA_TO_DEVICE</span><span class="p">)</span>
			<span class="n">t</span><span class="o">-&gt;</span><span class="n">tx_buf</span> <span class="o">=</span> <span class="n">kmap_addr</span> <span class="o">+</span> <span class="n">sg</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">t</span><span class="o">-&gt;</span><span class="n">rx_buf</span> <span class="o">=</span> <span class="n">kmap_addr</span> <span class="o">+</span> <span class="n">sg</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">;</span>

		<span class="cm">/* transfer each block, and update request status */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">length</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">t</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="n">blk_size</span><span class="p">);</span>

			<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;    mmc_spi: %s block, %d bytes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="n">direction</span> <span class="o">==</span> <span class="n">DMA_TO_DEVICE</span><span class="p">)</span>
				<span class="o">?</span> <span class="s">&quot;write&quot;</span>
				<span class="o">:</span> <span class="s">&quot;read&quot;</span><span class="p">,</span>
				<span class="n">t</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">direction</span> <span class="o">==</span> <span class="n">DMA_TO_DEVICE</span><span class="p">)</span>
				<span class="n">status</span> <span class="o">=</span> <span class="n">mmc_spi_writeblock</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">status</span> <span class="o">=</span> <span class="n">mmc_spi_readblock</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="n">data</span><span class="o">-&gt;</span><span class="n">bytes_xfered</span> <span class="o">+=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
			<span class="n">length</span> <span class="o">-=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">multiple</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* discard mappings */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">direction</span> <span class="o">==</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">)</span>
			<span class="n">flush_kernel_dcache_page</span><span class="p">(</span><span class="n">sg_page</span><span class="p">(</span><span class="n">sg</span><span class="p">));</span>
		<span class="n">kunmap</span><span class="p">(</span><span class="n">sg_page</span><span class="p">(</span><span class="n">sg</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dma_dev</span><span class="p">)</span>
			<span class="n">dma_unmap_page</span><span class="p">(</span><span class="n">dma_dev</span><span class="p">,</span> <span class="n">dma_addr</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">data</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="n">status</span><span class="p">;</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s status %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="n">direction</span> <span class="o">==</span> <span class="n">DMA_TO_DEVICE</span><span class="p">)</span>
					<span class="o">?</span> <span class="s">&quot;write&quot;</span> <span class="o">:</span> <span class="s">&quot;read&quot;</span><span class="p">,</span>
				<span class="n">status</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* NOTE some docs describe an MMC-only SET_BLOCK_COUNT (CMD23) that</span>
<span class="cm">	 * can be issued before multiblock writes.  Unlike its more widely</span>
<span class="cm">	 * documented analogue for SD cards (SET_WR_BLK_ERASE_COUNT, ACMD23),</span>
<span class="cm">	 * that can affect the STOP_TRAN logic.   Complete (and current)</span>
<span class="cm">	 * MMC specs should sort that out before Linux starts using CMD23.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">direction</span> <span class="o">==</span> <span class="n">DMA_TO_DEVICE</span> <span class="o">&amp;&amp;</span> <span class="n">multiple</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">scratch</span>	<span class="o">*</span><span class="n">scratch</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
		<span class="kt">int</span>		<span class="n">tmp</span><span class="p">;</span>
		<span class="k">const</span> <span class="kt">unsigned</span>	<span class="n">statlen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">scratch</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>

		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;    mmc_spi: STOP_TRAN</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="cm">/* Tweak the per-block message we set up earlier by morphing</span>
<span class="cm">		 * it to hold single buffer with the token followed by some</span>
<span class="cm">		 * all-ones bytes ... skip N(BR) (0..1), scan the rest for</span>
<span class="cm">		 * &quot;not busy any longer&quot; status, and leave chip selected.</span>
<span class="cm">		 */</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">.</span><span class="n">transfers</span><span class="p">);</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">early_status</span><span class="p">.</span><span class="n">transfer_list</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">.</span><span class="n">transfers</span><span class="p">);</span>

		<span class="n">memset</span><span class="p">(</span><span class="n">scratch</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="n">statlen</span><span class="p">);</span>
		<span class="n">scratch</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">SPI_TOKEN_STOP_TRAN</span><span class="p">;</span>

		<span class="n">host</span><span class="o">-&gt;</span><span class="n">early_status</span><span class="p">.</span><span class="n">tx_buf</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">early_status</span><span class="p">.</span><span class="n">rx_buf</span><span class="p">;</span>
		<span class="n">host</span><span class="o">-&gt;</span><span class="n">early_status</span><span class="p">.</span><span class="n">tx_dma</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">early_status</span><span class="p">.</span><span class="n">rx_dma</span><span class="p">;</span>
		<span class="n">host</span><span class="o">-&gt;</span><span class="n">early_status</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">statlen</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">dma_dev</span><span class="p">)</span>
			<span class="n">dma_sync_single_for_device</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">dma_dev</span><span class="p">,</span>
					<span class="n">host</span><span class="o">-&gt;</span><span class="n">data_dma</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">scratch</span><span class="p">),</span>
					<span class="n">DMA_BIDIRECTIONAL</span><span class="p">);</span>

		<span class="n">tmp</span> <span class="o">=</span> <span class="n">spi_sync_locked</span><span class="p">(</span><span class="n">spi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">dma_dev</span><span class="p">)</span>
			<span class="n">dma_sync_single_for_cpu</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">dma_dev</span><span class="p">,</span>
					<span class="n">host</span><span class="o">-&gt;</span><span class="n">data_dma</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">scratch</span><span class="p">),</span>
					<span class="n">DMA_BIDIRECTIONAL</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">error</span><span class="p">)</span>
				<span class="n">data</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Ideally we collected &quot;not busy&quot; status with one I/O,</span>
<span class="cm">		 * avoiding wasteful byte-at-a-time scanning... but more</span>
<span class="cm">		 * I/O is often needed.</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">tmp</span> <span class="o">&lt;</span> <span class="n">statlen</span><span class="p">;</span> <span class="n">tmp</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">scratch</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">[</span><span class="n">tmp</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">mmc_spi_wait_unbusy</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">error</span><span class="p">)</span>
			<span class="n">data</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/****************************************************************************/</span>

<span class="cm">/*</span>
<span class="cm"> * MMC driver implementation -- the interface to the MMC stack</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mmc_spi_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmc_host</span> <span class="o">*</span><span class="n">mmc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mmc_request</span> <span class="o">*</span><span class="n">mrq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mmc_spi_host</span>	<span class="o">*</span><span class="n">host</span> <span class="o">=</span> <span class="n">mmc_priv</span><span class="p">(</span><span class="n">mmc</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">crc_retry</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mmc_command</span>	<span class="n">stop</span><span class="p">;</span>

<span class="cp">#ifdef DEBUG</span>
	<span class="cm">/* MMC core and layered drivers *MUST* issue SPI-aware commands */</span>
	<span class="p">{</span>
		<span class="k">struct</span> <span class="n">mmc_command</span>	<span class="o">*</span><span class="n">cmd</span><span class="p">;</span>
		<span class="kt">int</span>			<span class="n">invalid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">cmd</span> <span class="o">=</span> <span class="n">mrq</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mmc_spi_resp_type</span><span class="p">(</span><span class="n">cmd</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;bogus command</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="n">invalid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">cmd</span> <span class="o">=</span> <span class="n">mrq</span><span class="o">-&gt;</span><span class="n">stop</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">mmc_spi_resp_type</span><span class="p">(</span><span class="n">cmd</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;bogus STOP command</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="n">invalid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">invalid</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dump_stack</span><span class="p">();</span>
			<span class="n">mmc_request_done</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">mmc</span><span class="p">,</span> <span class="n">mrq</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="cm">/* request exclusive bus access */</span>
	<span class="n">spi_bus_lock</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">master</span><span class="p">);</span>

<span class="nl">crc_recover:</span>
	<span class="cm">/* issue command; then optionally data and stop */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">mmc_spi_command_send</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">mrq</span><span class="p">,</span> <span class="n">mrq</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">,</span> <span class="n">mrq</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">mrq</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mmc_spi_data_do</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">mrq</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">,</span> <span class="n">mrq</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">mrq</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">blksz</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * The SPI bus is not always reliable for large data transfers.</span>
<span class="cm">		 * If an occasional crc error is reported by the SD device with</span>
<span class="cm">		 * data read/write over SPI, it may be recovered by repeating</span>
<span class="cm">		 * the last SD command again. The retry count is set to 5 to</span>
<span class="cm">		 * ensure the driver passes stress tests.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mrq</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">==</span> <span class="o">-</span><span class="n">EILSEQ</span> <span class="o">&amp;&amp;</span> <span class="n">crc_retry</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">stop</span><span class="p">.</span><span class="n">opcode</span> <span class="o">=</span> <span class="n">MMC_STOP_TRANSMISSION</span><span class="p">;</span>
			<span class="n">stop</span><span class="p">.</span><span class="n">arg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">stop</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">MMC_RSP_SPI_R1B</span> <span class="o">|</span> <span class="n">MMC_RSP_R1B</span> <span class="o">|</span> <span class="n">MMC_CMD_AC</span><span class="p">;</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">mmc_spi_command_send</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">mrq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stop</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">crc_retry</span><span class="o">--</span><span class="p">;</span>
			<span class="n">mrq</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">crc_recover</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">mrq</span><span class="o">-&gt;</span><span class="n">stop</span><span class="p">)</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">mmc_spi_command_send</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">mrq</span><span class="p">,</span> <span class="n">mrq</span><span class="o">-&gt;</span><span class="n">stop</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">mmc_cs_off</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* release the bus */</span>
	<span class="n">spi_bus_unlock</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">master</span><span class="p">);</span>

	<span class="n">mmc_request_done</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">mmc</span><span class="p">,</span> <span class="n">mrq</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* See Section 6.4.1, in SD &quot;Simplified Physical Layer Specification 2.0&quot;</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE that here we can&#39;t know that the card has just been powered up;</span>
<span class="cm"> * not all MMC/SD sockets support power switching.</span>
<span class="cm"> *</span>
<span class="cm"> * FIXME when the card is still in SPI mode, e.g. from a previous kernel,</span>
<span class="cm"> * this doesn&#39;t seem to do the right thing at all...</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mmc_spi_initsequence</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmc_spi_host</span> <span class="o">*</span><span class="n">host</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Try to be very sure any previous command has completed;</span>
<span class="cm">	 * wait till not-busy, skip debris from any old commands.</span>
<span class="cm">	 */</span>
	<span class="n">mmc_spi_wait_unbusy</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">r1b_timeout</span><span class="p">);</span>
	<span class="n">mmc_spi_readbytes</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Do a burst with chipselect active-high.  We need to do this to</span>
<span class="cm">	 * meet the requirement of 74 clock cycles with both chipselect</span>
<span class="cm">	 * and CMD (MOSI) high before CMD0 ... after the card has been</span>
<span class="cm">	 * powered up to Vdd(min), and so is ready to take commands.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Some cards are particularly needy of this (e.g. Viking &quot;SD256&quot;)</span>
<span class="cm">	 * while most others don&#39;t seem to care.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note that this is one of the places MMC/SD plays games with the</span>
<span class="cm">	 * SPI protocol.  Another is that when chipselect is released while</span>
<span class="cm">	 * the card returns BUSY status, the clock must issue several cycles</span>
<span class="cm">	 * with chipselect high before the card will stop driving its output.</span>
<span class="cm">	 */</span>
	<span class="n">host</span><span class="o">-&gt;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">|=</span> <span class="n">SPI_CS_HIGH</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">spi_setup</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">spi</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Just warn; most cards work without it. */</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;can&#39;t change chip-select polarity</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">host</span><span class="o">-&gt;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SPI_CS_HIGH</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">mmc_spi_readbytes</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="mi">18</span><span class="p">);</span>

		<span class="n">host</span><span class="o">-&gt;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SPI_CS_HIGH</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">spi_setup</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">spi</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Wot, we can&#39;t get the same setup we had before? */</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="s">&quot;can&#39;t restore chip-select polarity</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">mmc_powerstring</span><span class="p">(</span><span class="n">u8</span> <span class="n">power_mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">power_mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">MMC_POWER_OFF</span>: <span class="k">return</span> <span class="s">&quot;off&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MMC_POWER_UP</span>:  <span class="k">return</span> <span class="s">&quot;up&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MMC_POWER_ON</span>:  <span class="k">return</span> <span class="s">&quot;on&quot;</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="s">&quot;?&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mmc_spi_set_ios</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmc_host</span> <span class="o">*</span><span class="n">mmc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mmc_ios</span> <span class="o">*</span><span class="n">ios</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mmc_spi_host</span> <span class="o">*</span><span class="n">host</span> <span class="o">=</span> <span class="n">mmc_priv</span><span class="p">(</span><span class="n">mmc</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">power_mode</span> <span class="o">!=</span> <span class="n">ios</span><span class="o">-&gt;</span><span class="n">power_mode</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span>		<span class="n">canpower</span><span class="p">;</span>

		<span class="n">canpower</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">pdata</span> <span class="o">&amp;&amp;</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">setpower</span><span class="p">;</span>

		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;mmc_spi: power %s (%d)%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">mmc_powerstring</span><span class="p">(</span><span class="n">ios</span><span class="o">-&gt;</span><span class="n">power_mode</span><span class="p">),</span>
				<span class="n">ios</span><span class="o">-&gt;</span><span class="n">vdd</span><span class="p">,</span>
				<span class="n">canpower</span> <span class="o">?</span> <span class="s">&quot;, can switch&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">);</span>

		<span class="cm">/* switch power on/off if possible, accounting for</span>
<span class="cm">		 * max 250msec powerup time if needed.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">canpower</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">ios</span><span class="o">-&gt;</span><span class="n">power_mode</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">MMC_POWER_OFF</span>:
			<span class="k">case</span> <span class="n">MMC_POWER_UP</span>:
				<span class="n">host</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">setpower</span><span class="p">(</span><span class="o">&amp;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
						<span class="n">ios</span><span class="o">-&gt;</span><span class="n">vdd</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ios</span><span class="o">-&gt;</span><span class="n">power_mode</span> <span class="o">==</span> <span class="n">MMC_POWER_UP</span><span class="p">)</span>
					<span class="n">msleep</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">powerup_msecs</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* See 6.4.1 in the simplified SD card physical spec 2.0 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ios</span><span class="o">-&gt;</span><span class="n">power_mode</span> <span class="o">==</span> <span class="n">MMC_POWER_ON</span><span class="p">)</span>
			<span class="n">mmc_spi_initsequence</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>

		<span class="cm">/* If powering down, ground all card inputs to avoid power</span>
<span class="cm">		 * delivery from data lines!  On a shared SPI bus, this</span>
<span class="cm">		 * will probably be temporary; 6.4.2 of the simplified SD</span>
<span class="cm">		 * spec says this must last at least 1msec.</span>
<span class="cm">		 *</span>
<span class="cm">		 *   - Clock low means CPOL 0, e.g. mode 0</span>
<span class="cm">		 *   - MOSI low comes from writing zero</span>
<span class="cm">		 *   - Chipselect is usually active low...</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">canpower</span> <span class="o">&amp;&amp;</span> <span class="n">ios</span><span class="o">-&gt;</span><span class="n">power_mode</span> <span class="o">==</span> <span class="n">MMC_POWER_OFF</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">mres</span><span class="p">;</span>
			<span class="n">u8</span> <span class="n">nullbyte</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="n">host</span><span class="o">-&gt;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">SPI_CPOL</span><span class="o">|</span><span class="n">SPI_CPHA</span><span class="p">);</span>
			<span class="n">mres</span> <span class="o">=</span> <span class="n">spi_setup</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">spi</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mres</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="s">&quot;switch to SPI mode 0 failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">spi_write</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">spi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nullbyte</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="s">&quot;put spi signals to low failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * Now clock should be low due to spi mode 0;</span>
<span class="cm">			 * MOSI should be low because of written 0x00;</span>
<span class="cm">			 * chipselect should be low (it is active low)</span>
<span class="cm">			 * power supply is off, so now MMC is off too!</span>
<span class="cm">			 *</span>
<span class="cm">			 * FIXME no, chipselect can be high since the</span>
<span class="cm">			 * device is inactive and SPI_CS_HIGH is clear...</span>
<span class="cm">			 */</span>
			<span class="n">msleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mres</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">host</span><span class="o">-&gt;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">|=</span> <span class="p">(</span><span class="n">SPI_CPOL</span><span class="o">|</span><span class="n">SPI_CPHA</span><span class="p">);</span>
				<span class="n">mres</span> <span class="o">=</span> <span class="n">spi_setup</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">spi</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">mres</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
					<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
						<span class="s">&quot;switch back to SPI mode 3&quot;</span>
						<span class="s">&quot; failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">host</span><span class="o">-&gt;</span><span class="n">power_mode</span> <span class="o">=</span> <span class="n">ios</span><span class="o">-&gt;</span><span class="n">power_mode</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">max_speed_hz</span> <span class="o">!=</span> <span class="n">ios</span><span class="o">-&gt;</span><span class="n">clock</span> <span class="o">&amp;&amp;</span> <span class="n">ios</span><span class="o">-&gt;</span><span class="n">clock</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span>		<span class="n">status</span><span class="p">;</span>

		<span class="n">host</span><span class="o">-&gt;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">max_speed_hz</span> <span class="o">=</span> <span class="n">ios</span><span class="o">-&gt;</span><span class="n">clock</span><span class="p">;</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">spi_setup</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">spi</span><span class="p">);</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;mmc_spi:  clock to %d Hz, %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">host</span><span class="o">-&gt;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">max_speed_hz</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mmc_spi_get_ro</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmc_host</span> <span class="o">*</span><span class="n">mmc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mmc_spi_host</span> <span class="o">*</span><span class="n">host</span> <span class="o">=</span> <span class="n">mmc_priv</span><span class="p">(</span><span class="n">mmc</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">pdata</span> <span class="o">&amp;&amp;</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">get_ro</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">!!</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">get_ro</span><span class="p">(</span><span class="n">mmc</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Board doesn&#39;t support read only detection; let the mmc core</span>
<span class="cm">	 * decide what to do.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mmc_spi_get_cd</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmc_host</span> <span class="o">*</span><span class="n">mmc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mmc_spi_host</span> <span class="o">*</span><span class="n">host</span> <span class="o">=</span> <span class="n">mmc_priv</span><span class="p">(</span><span class="n">mmc</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">pdata</span> <span class="o">&amp;&amp;</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">get_cd</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">!!</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">get_cd</span><span class="p">(</span><span class="n">mmc</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">mmc_host_ops</span> <span class="n">mmc_spi_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">request</span>	<span class="o">=</span> <span class="n">mmc_spi_request</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_ios</span>	<span class="o">=</span> <span class="n">mmc_spi_set_ios</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_ro</span>		<span class="o">=</span> <span class="n">mmc_spi_get_ro</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_cd</span>		<span class="o">=</span> <span class="n">mmc_spi_get_cd</span><span class="p">,</span>
<span class="p">};</span>


<span class="cm">/****************************************************************************/</span>

<span class="cm">/*</span>
<span class="cm"> * SPI driver implementation</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">irqreturn_t</span>
<span class="nf">mmc_spi_detect_irq</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">mmc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mmc_spi_host</span> <span class="o">*</span><span class="n">host</span> <span class="o">=</span> <span class="n">mmc_priv</span><span class="p">(</span><span class="n">mmc</span><span class="p">);</span>
	<span class="n">u16</span> <span class="n">delay_msec</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">detect_delay</span><span class="p">,</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span><span class="mi">100</span><span class="p">);</span>

	<span class="n">mmc_detect_change</span><span class="p">(</span><span class="n">mmc</span><span class="p">,</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">delay_msec</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mmc_spi_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">ones</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mmc_host</span>		<span class="o">*</span><span class="n">mmc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mmc_spi_host</span>	<span class="o">*</span><span class="n">host</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">status</span><span class="p">;</span>

	<span class="cm">/* We rely on full duplex transfers, mostly to reduce</span>
<span class="cm">	 * per-transfer overheads (by making fewer transfers).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SPI_MASTER_HALF_DUPLEX</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* MMC and SD specs only seem to care that sampling is on the</span>
<span class="cm">	 * rising edge ... meaning SPI modes 0 or 3.  So either SPI mode</span>
<span class="cm">	 * should be legit.  We&#39;ll use mode 0 since the steady state is 0,</span>
<span class="cm">	 * which is appropriate for hotplugging, unless the platform data</span>
<span class="cm">	 * specify mode 3 (if hardware is not compatible to mode 0).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">!=</span> <span class="n">SPI_MODE_3</span><span class="p">)</span>
		<span class="n">spi</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">SPI_MODE_0</span><span class="p">;</span>
	<span class="n">spi</span><span class="o">-&gt;</span><span class="n">bits_per_word</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">spi_setup</span><span class="p">(</span><span class="n">spi</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;needs SPI mode %02x, %d KHz; %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">spi</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">,</span> <span class="n">spi</span><span class="o">-&gt;</span><span class="n">max_speed_hz</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">,</span>
				<span class="n">status</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* We need a supply of ones to transmit.  This is the only time</span>
<span class="cm">	 * the CPU touches these, so cache coherency isn&#39;t a concern.</span>
<span class="cm">	 *</span>
<span class="cm">	 * NOTE if many systems use more than one MMC-over-SPI connector</span>
<span class="cm">	 * it&#39;d save some memory to share this.  That&#39;s evidently rare.</span>
<span class="cm">	 */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">ones</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">MMC_SPI_BLOCKSIZE</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ones</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nomem</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">ones</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="n">MMC_SPI_BLOCKSIZE</span><span class="p">);</span>

	<span class="n">mmc</span> <span class="o">=</span> <span class="n">mmc_alloc_host</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">host</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mmc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nomem</span><span class="p">;</span>

	<span class="n">mmc</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mmc_spi_ops</span><span class="p">;</span>
	<span class="n">mmc</span><span class="o">-&gt;</span><span class="n">max_blk_size</span> <span class="o">=</span> <span class="n">MMC_SPI_BLOCKSIZE</span><span class="p">;</span>
	<span class="n">mmc</span><span class="o">-&gt;</span><span class="n">max_segs</span> <span class="o">=</span> <span class="n">MMC_SPI_BLOCKSATONCE</span><span class="p">;</span>
	<span class="n">mmc</span><span class="o">-&gt;</span><span class="n">max_req_size</span> <span class="o">=</span> <span class="n">MMC_SPI_BLOCKSATONCE</span> <span class="o">*</span> <span class="n">MMC_SPI_BLOCKSIZE</span><span class="p">;</span>
	<span class="n">mmc</span><span class="o">-&gt;</span><span class="n">max_blk_count</span> <span class="o">=</span> <span class="n">MMC_SPI_BLOCKSATONCE</span><span class="p">;</span>

	<span class="n">mmc</span><span class="o">-&gt;</span><span class="n">caps</span> <span class="o">=</span> <span class="n">MMC_CAP_SPI</span><span class="p">;</span>

	<span class="cm">/* SPI doesn&#39;t need the lowspeed device identification thing for</span>
<span class="cm">	 * MMC or SD cards, since it never comes up in open drain mode.</span>
<span class="cm">	 * That&#39;s good; some SPI masters can&#39;t handle very low speeds!</span>
<span class="cm">	 *</span>
<span class="cm">	 * However, low speed SDIO cards need not handle over 400 KHz;</span>
<span class="cm">	 * that&#39;s the only reason not to use a few MHz for f_min (until</span>
<span class="cm">	 * the upper layer reads the target frequency from the CSD).</span>
<span class="cm">	 */</span>
	<span class="n">mmc</span><span class="o">-&gt;</span><span class="n">f_min</span> <span class="o">=</span> <span class="mi">400000</span><span class="p">;</span>
	<span class="n">mmc</span><span class="o">-&gt;</span><span class="n">f_max</span> <span class="o">=</span> <span class="n">spi</span><span class="o">-&gt;</span><span class="n">max_speed_hz</span><span class="p">;</span>

	<span class="n">host</span> <span class="o">=</span> <span class="n">mmc_priv</span><span class="p">(</span><span class="n">mmc</span><span class="p">);</span>
	<span class="n">host</span><span class="o">-&gt;</span><span class="n">mmc</span> <span class="o">=</span> <span class="n">mmc</span><span class="p">;</span>
	<span class="n">host</span><span class="o">-&gt;</span><span class="n">spi</span> <span class="o">=</span> <span class="n">spi</span><span class="p">;</span>

	<span class="n">host</span><span class="o">-&gt;</span><span class="n">ones</span> <span class="o">=</span> <span class="n">ones</span><span class="p">;</span>

	<span class="cm">/* Platform data is used to hook up things like card sensing</span>
<span class="cm">	 * and power switching gpios.</span>
<span class="cm">	 */</span>
	<span class="n">host</span><span class="o">-&gt;</span><span class="n">pdata</span> <span class="o">=</span> <span class="n">mmc_spi_get_pdata</span><span class="p">(</span><span class="n">spi</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="p">)</span>
		<span class="n">mmc</span><span class="o">-&gt;</span><span class="n">ocr_avail</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">ocr_mask</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mmc</span><span class="o">-&gt;</span><span class="n">ocr_avail</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;ASSUMING 3.2-3.4 V slot power</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">mmc</span><span class="o">-&gt;</span><span class="n">ocr_avail</span> <span class="o">=</span> <span class="n">MMC_VDD_32_33</span><span class="o">|</span><span class="n">MMC_VDD_33_34</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">pdata</span> <span class="o">&amp;&amp;</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">setpower</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">host</span><span class="o">-&gt;</span><span class="n">powerup_msecs</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">powerup_msecs</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">powerup_msecs</span> <span class="o">||</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">powerup_msecs</span> <span class="o">&gt;</span> <span class="mi">250</span><span class="p">)</span>
			<span class="n">host</span><span class="o">-&gt;</span><span class="n">powerup_msecs</span> <span class="o">=</span> <span class="mi">250</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev_set_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">mmc</span><span class="p">);</span>

	<span class="cm">/* preallocate dma buffers */</span>
	<span class="n">host</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail_nobuf1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">dma_mask</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">device</span>	<span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">spi</span><span class="o">-&gt;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">;</span>

		<span class="n">host</span><span class="o">-&gt;</span><span class="n">dma_dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
		<span class="n">host</span><span class="o">-&gt;</span><span class="n">ones_dma</span> <span class="o">=</span> <span class="n">dma_map_single</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ones</span><span class="p">,</span>
				<span class="n">MMC_SPI_BLOCKSIZE</span><span class="p">,</span> <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
		<span class="n">host</span><span class="o">-&gt;</span><span class="n">data_dma</span> <span class="o">=</span> <span class="n">dma_map_single</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">),</span> <span class="n">DMA_BIDIRECTIONAL</span><span class="p">);</span>

		<span class="cm">/* REVISIT in theory those map operations can fail... */</span>

		<span class="n">dma_sync_single_for_cpu</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">dma_dev</span><span class="p">,</span>
				<span class="n">host</span><span class="o">-&gt;</span><span class="n">data_dma</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">),</span>
				<span class="n">DMA_BIDIRECTIONAL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* setup message for status/busy readback */</span>
	<span class="n">spi_message_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">readback</span><span class="p">);</span>
	<span class="n">host</span><span class="o">-&gt;</span><span class="n">readback</span><span class="p">.</span><span class="n">is_dma_mapped</span> <span class="o">=</span> <span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">dma_dev</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">spi_message_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">readback</span><span class="p">);</span>
	<span class="n">host</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">.</span><span class="n">tx_buf</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">ones</span><span class="p">;</span>
	<span class="n">host</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">.</span><span class="n">tx_dma</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">ones_dma</span><span class="p">;</span>
	<span class="n">host</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">.</span><span class="n">rx_buf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">;</span>
	<span class="n">host</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">.</span><span class="n">rx_dma</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">data_dma</span> <span class="o">+</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">scratch</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="n">host</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">.</span><span class="n">cs_change</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* register card detect irq */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">pdata</span> <span class="o">&amp;&amp;</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">mmc_spi_detect_irq</span><span class="p">,</span> <span class="n">mmc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">fail_glue_init</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* pass platform capabilities, if any */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="p">)</span>
		<span class="n">mmc</span><span class="o">-&gt;</span><span class="n">caps</span> <span class="o">|=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">caps</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">mmc_add_host</span><span class="p">(</span><span class="n">mmc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail_add_host</span><span class="p">;</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;SD/MMC host %s%s%s%s%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">dev_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mmc</span><span class="o">-&gt;</span><span class="n">class_dev</span><span class="p">),</span>
			<span class="n">host</span><span class="o">-&gt;</span><span class="n">dma_dev</span> <span class="o">?</span> <span class="s">&quot;&quot;</span> <span class="o">:</span> <span class="s">&quot;, no DMA&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">pdata</span> <span class="o">&amp;&amp;</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">get_ro</span><span class="p">)</span>
				<span class="o">?</span> <span class="s">&quot;&quot;</span> <span class="o">:</span> <span class="s">&quot;, no WP&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">pdata</span> <span class="o">&amp;&amp;</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">setpower</span><span class="p">)</span>
				<span class="o">?</span> <span class="s">&quot;&quot;</span> <span class="o">:</span> <span class="s">&quot;, no poweroff&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="n">mmc</span><span class="o">-&gt;</span><span class="n">caps</span> <span class="o">&amp;</span> <span class="n">MMC_CAP_NEEDS_POLL</span><span class="p">)</span>
				<span class="o">?</span> <span class="s">&quot;, cd polling&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fail_add_host:</span>
	<span class="n">mmc_remove_host</span> <span class="p">(</span><span class="n">mmc</span><span class="p">);</span>
<span class="nl">fail_glue_init:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">dma_dev</span><span class="p">)</span>
		<span class="n">dma_unmap_single</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">dma_dev</span><span class="p">,</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">data_dma</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">),</span> <span class="n">DMA_BIDIRECTIONAL</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>

<span class="nl">fail_nobuf1:</span>
	<span class="n">mmc_free_host</span><span class="p">(</span><span class="n">mmc</span><span class="p">);</span>
	<span class="n">mmc_spi_put_pdata</span><span class="p">(</span><span class="n">spi</span><span class="p">);</span>
	<span class="n">dev_set_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="nl">nomem:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ones</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="n">__devexit</span> <span class="nf">mmc_spi_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mmc_host</span>		<span class="o">*</span><span class="n">mmc</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">mmc_spi_host</span>	<span class="o">*</span><span class="n">host</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mmc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">host</span> <span class="o">=</span> <span class="n">mmc_priv</span><span class="p">(</span><span class="n">mmc</span><span class="p">);</span>

		<span class="cm">/* prevent new mmc_detect_change() calls */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">pdata</span> <span class="o">&amp;&amp;</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">exit</span><span class="p">)</span>
			<span class="n">host</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">exit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">mmc</span><span class="p">);</span>

		<span class="n">mmc_remove_host</span><span class="p">(</span><span class="n">mmc</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">dma_dev</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dma_unmap_single</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">dma_dev</span><span class="p">,</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">ones_dma</span><span class="p">,</span>
				<span class="n">MMC_SPI_BLOCKSIZE</span><span class="p">,</span> <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
			<span class="n">dma_unmap_single</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">dma_dev</span><span class="p">,</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">data_dma</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">),</span> <span class="n">DMA_BIDIRECTIONAL</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">kfree</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">ones</span><span class="p">);</span>

		<span class="n">spi</span><span class="o">-&gt;</span><span class="n">max_speed_hz</span> <span class="o">=</span> <span class="n">mmc</span><span class="o">-&gt;</span><span class="n">f_max</span><span class="p">;</span>
		<span class="n">mmc_free_host</span><span class="p">(</span><span class="n">mmc</span><span class="p">);</span>
		<span class="n">mmc_spi_put_pdata</span><span class="p">(</span><span class="n">spi</span><span class="p">);</span>
		<span class="n">dev_set_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">of_device_id</span> <span class="n">mmc_spi_of_match_table</span><span class="p">[]</span> <span class="n">__devinitdata</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="p">.</span><span class="n">compatible</span> <span class="o">=</span> <span class="s">&quot;mmc-spi-slot&quot;</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{},</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">spi_driver</span> <span class="n">mmc_spi_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span>		<span class="s">&quot;mmc_spi&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">owner</span> <span class="o">=</span>	<span class="n">THIS_MODULE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">of_match_table</span> <span class="o">=</span> <span class="n">mmc_spi_of_match_table</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">.</span><span class="n">probe</span> <span class="o">=</span>	<span class="n">mmc_spi_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span> <span class="o">=</span>	<span class="n">__devexit_p</span><span class="p">(</span><span class="n">mmc_spi_remove</span><span class="p">),</span>
<span class="p">};</span>


<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">mmc_spi_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">spi_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mmc_spi_driver</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">module_init</span><span class="p">(</span><span class="n">mmc_spi_init</span><span class="p">);</span>


<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">mmc_spi_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spi_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mmc_spi_driver</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">mmc_spi_exit</span><span class="p">);</span>


<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Mike Lavender, David Brownell, &quot;</span>
		<span class="s">&quot;Hans-Peter Nilsson, Jan Nikitenko&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;SPI SD/MMC host driver&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_ALIAS</span><span class="p">(</span><span class="s">&quot;spi:mmc_spi&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
