<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › gpu › drm › nouveau › nouveau_bios.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>nouveau_bios.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright 2005-2006 Erik Waling</span>
<span class="cm"> * Copyright 2006 Stephane Marchesin</span>
<span class="cm"> * Copyright 2007-2009 Stuart Bennett</span>
<span class="cm"> *</span>
<span class="cm"> * Permission is hereby granted, free of charge, to any person obtaining a</span>
<span class="cm"> * copy of this software and associated documentation files (the &quot;Software&quot;),</span>
<span class="cm"> * to deal in the Software without restriction, including without limitation</span>
<span class="cm"> * the rights to use, copy, modify, merge, publish, distribute, sublicense,</span>
<span class="cm"> * and/or sell copies of the Software, and to permit persons to whom the</span>
<span class="cm"> * Software is furnished to do so, subject to the following conditions:</span>
<span class="cm"> *</span>
<span class="cm"> * The above copyright notice and this permission notice shall be included in</span>
<span class="cm"> * all copies or substantial portions of the Software.</span>
<span class="cm"> *</span>
<span class="cm"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span>
<span class="cm"> * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL</span>
<span class="cm"> * THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,</span>
<span class="cm"> * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF</span>
<span class="cm"> * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE</span>
<span class="cm"> * SOFTWARE.</span>
<span class="cm"> */</span>

<span class="cp">#include &quot;drmP.h&quot;</span>
<span class="cp">#define NV_DEBUG_NOTRACE</span>
<span class="cp">#include &quot;nouveau_drv.h&quot;</span>
<span class="cp">#include &quot;nouveau_hw.h&quot;</span>
<span class="cp">#include &quot;nouveau_encoder.h&quot;</span>
<span class="cp">#include &quot;nouveau_gpio.h&quot;</span>

<span class="cp">#include &lt;linux/io-mapping.h&gt;</span>
<span class="cp">#include &lt;linux/firmware.h&gt;</span>

<span class="cm">/* these defines are made up */</span>
<span class="cp">#define NV_CIO_CRE_44_HEADA 0x0</span>
<span class="cp">#define NV_CIO_CRE_44_HEADB 0x3</span>
<span class="cp">#define FEATURE_MOBILE 0x10	</span><span class="cm">/* also FEATURE_QUADRO for BMP */</span><span class="cp"></span>

<span class="cp">#define EDID1_LEN 128</span>

<span class="cp">#define BIOSLOG(sip, fmt, arg...) NV_DEBUG(sip-&gt;dev, fmt, ##arg)</span>
<span class="cp">#define LOG_OLD_VALUE(x)</span>

<span class="k">struct</span> <span class="n">init_exec</span> <span class="p">{</span>
	<span class="n">bool</span> <span class="n">execute</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">repeat</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">nv_cksum</span><span class="p">(</span><span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * There&#39;s a few checksums in the BIOS, so here&#39;s a generic checking</span>
<span class="cm">	 * function.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">sum</span> <span class="o">+=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sum</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">score_vbios</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="k">const</span> <span class="n">bool</span> <span class="n">writeable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">||</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mh">0x55</span> <span class="o">||</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mh">0xAA</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">NV_TRACEWARN</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;... BIOS signature not found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nv_cksum</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="mi">512</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">NV_TRACEWARN</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;... BIOS checksum invalid</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="cm">/* if a ro image is somewhat bad, it&#39;s probably all rubbish */</span>
		<span class="k">return</span> <span class="n">writeable</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">NV_TRACE</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;... appears to be valid</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">bios_shadow_prom</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_nouveau_private</span> <span class="o">*</span><span class="n">dev_priv</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_private</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pcireg</span><span class="p">,</span> <span class="n">access</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">pcir</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* enable access to rom */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">card_type</span> <span class="o">&gt;=</span> <span class="n">NV_50</span><span class="p">)</span>
		<span class="n">pcireg</span> <span class="o">=</span> <span class="mh">0x088050</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">pcireg</span> <span class="o">=</span> <span class="n">NV_PBUS_PCI_NV_20</span><span class="p">;</span>
	<span class="n">access</span> <span class="o">=</span> <span class="n">nv_mask</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pcireg</span><span class="p">,</span> <span class="mh">0x00000001</span><span class="p">,</span> <span class="mh">0x00000000</span><span class="p">);</span>

	<span class="cm">/* bail if no rom signature, with a workaround for a PROM reading</span>
<span class="cm">	 * issue on some chipsets.  the first read after a period of</span>
<span class="cm">	 * inactivity returns the wrong result, so retry the first header</span>
<span class="cm">	 * byte a few times before giving up as a workaround</span>
<span class="cm">	 */</span>
	<span class="n">i</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nv_rd08</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">NV_PROM_OFFSET</span> <span class="o">+</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x55</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="o">--</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i</span> <span class="o">||</span> <span class="n">nv_rd08</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">NV_PROM_OFFSET</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mh">0xaa</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* additional check (see note below) - read PCI record header */</span>
	<span class="n">pcir</span> <span class="o">=</span> <span class="n">nv_rd08</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">NV_PROM_OFFSET</span> <span class="o">+</span> <span class="mh">0x18</span><span class="p">)</span> <span class="o">|</span>
	       <span class="n">nv_rd08</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">NV_PROM_OFFSET</span> <span class="o">+</span> <span class="mh">0x19</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nv_rd08</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">NV_PROM_OFFSET</span> <span class="o">+</span> <span class="n">pcir</span> <span class="o">+</span> <span class="mi">0</span><span class="p">)</span> <span class="o">!=</span> <span class="sc">&#39;P&#39;</span> <span class="o">||</span>
	    <span class="n">nv_rd08</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">NV_PROM_OFFSET</span> <span class="o">+</span> <span class="n">pcir</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="sc">&#39;C&#39;</span> <span class="o">||</span>
	    <span class="n">nv_rd08</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">NV_PROM_OFFSET</span> <span class="o">+</span> <span class="n">pcir</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">!=</span> <span class="sc">&#39;I&#39;</span> <span class="o">||</span>
	    <span class="n">nv_rd08</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">NV_PROM_OFFSET</span> <span class="o">+</span> <span class="n">pcir</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">!=</span> <span class="sc">&#39;R&#39;</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* read entire bios image to system memory */</span>
	<span class="n">bios</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">nv_rd08</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">NV_PROM_OFFSET</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="mi">512</span><span class="p">;</span>
	<span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nv_rd08</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">NV_PROM_OFFSET</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="cm">/* disable access to rom */</span>
	<span class="n">nv_wr32</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pcireg</span><span class="p">,</span> <span class="n">access</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">bios_shadow_pramin</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_nouveau_private</span> <span class="o">*</span><span class="n">dev_priv</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_private</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">bar0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">card_type</span> <span class="o">&gt;=</span> <span class="n">NV_50</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)(</span><span class="n">nv_rd32</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x619f04</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffffff00</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">addr</span>  <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">nv_rd32</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x001700</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
			<span class="n">addr</span> <span class="o">+=</span> <span class="mh">0xf0000</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">bar0</span> <span class="o">=</span> <span class="n">nv_mask</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x001700</span><span class="p">,</span> <span class="mh">0xffffffff</span><span class="p">,</span> <span class="n">addr</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* bail if no rom signature */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nv_rd08</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">NV_PRAMIN_OFFSET</span> <span class="o">+</span> <span class="mi">0</span><span class="p">)</span> <span class="o">!=</span> <span class="mh">0x55</span> <span class="o">||</span>
	    <span class="n">nv_rd08</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">NV_PRAMIN_OFFSET</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mh">0xaa</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">bios</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">nv_rd08</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">NV_PRAMIN_OFFSET</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="mi">512</span><span class="p">;</span>
	<span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nv_rd08</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">NV_PRAMIN_OFFSET</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">card_type</span> <span class="o">&gt;=</span> <span class="n">NV_50</span><span class="p">)</span>
		<span class="n">nv_wr32</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x001700</span><span class="p">,</span> <span class="n">bar0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">bios_shadow_pci</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">length</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pci_enable_rom</span><span class="p">(</span><span class="n">pdev</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">rom</span> <span class="o">=</span> <span class="n">pci_map_rom</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">length</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rom</span> <span class="o">&amp;&amp;</span> <span class="n">length</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">memcpy_fromio</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">rom</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
				<span class="n">bios</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">length</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rom</span><span class="p">)</span>
			<span class="n">pci_unmap_rom</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">rom</span><span class="p">);</span>

		<span class="n">pci_disable_rom</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">bios_shadow_acpi</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">65536</span> <span class="o">/</span> <span class="n">ROM_BIOS_PAGE</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nouveau_acpi_rom_supported</span><span class="p">(</span><span class="n">pdev</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">cnt</span> <span class="o">*</span> <span class="n">ROM_BIOS_PAGE</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">bios</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">cnt</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">nouveau_acpi_get_bios_chunk</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span>
						  <span class="n">ROM_BIOS_PAGE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">ROM_BIOS_PAGE</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="n">bios</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">+=</span> <span class="n">ROM_BIOS_PAGE</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">methods</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="n">desc</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">shadow</span><span class="p">)(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="p">);</span>
	<span class="k">const</span> <span class="n">bool</span> <span class="n">rw</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">score</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">bool</span>
<span class="nf">bios_shadow</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">methods</span> <span class="n">shadow_methods</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">{</span> <span class="s">&quot;PRAMIN&quot;</span><span class="p">,</span> <span class="n">bios_shadow_pramin</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">},</span>
		<span class="p">{</span> <span class="s">&quot;PROM&quot;</span><span class="p">,</span> <span class="n">bios_shadow_prom</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">},</span>
		<span class="p">{</span> <span class="s">&quot;ACPI&quot;</span><span class="p">,</span> <span class="n">bios_shadow_acpi</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">},</span>
		<span class="p">{</span> <span class="s">&quot;PCIROM&quot;</span><span class="p">,</span> <span class="n">bios_shadow_pci</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">},</span>
		<span class="p">{}</span>
	<span class="p">};</span>
	<span class="k">struct</span> <span class="n">drm_nouveau_private</span> <span class="o">*</span><span class="n">dev_priv</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">vbios</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">methods</span> <span class="o">*</span><span class="n">mthd</span><span class="p">,</span> <span class="o">*</span><span class="n">best</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">firmware</span> <span class="o">*</span><span class="n">fw</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">fname</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nouveau_vbios</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* try to match one of the built-in methods */</span>
		<span class="n">mthd</span> <span class="o">=</span> <span class="n">shadow_methods</span><span class="p">;</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">nouveau_vbios</span><span class="p">,</span> <span class="n">mthd</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">NV_INFO</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;VBIOS source: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mthd</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">);</span>

			<span class="n">mthd</span><span class="o">-&gt;</span><span class="n">shadow</span><span class="p">(</span><span class="n">bios</span><span class="p">);</span>
			<span class="n">mthd</span><span class="o">-&gt;</span><span class="n">score</span> <span class="o">=</span> <span class="n">score_vbios</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">mthd</span><span class="o">-&gt;</span><span class="n">rw</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mthd</span><span class="o">-&gt;</span><span class="n">score</span><span class="p">)</span>
				<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="o">++</span><span class="n">mthd</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">shadow</span><span class="p">);</span>

		<span class="cm">/* attempt to load firmware image */</span>
		<span class="n">snprintf</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">fname</span><span class="p">),</span> <span class="s">&quot;nouveau/%s&quot;</span><span class="p">,</span> <span class="n">nouveau_vbios</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">request_firmware</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fw</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">bios</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">fw</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
			<span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span>   <span class="o">=</span> <span class="n">kmemdup</span><span class="p">(</span><span class="n">fw</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">fw</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
			<span class="n">release_firmware</span><span class="p">(</span><span class="n">fw</span><span class="p">);</span>

			<span class="n">NV_INFO</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;VBIOS image: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">nouveau_vbios</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">score_vbios</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
				<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

			<span class="n">kfree</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
			<span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">NV_ERROR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;VBIOS source </span><span class="se">\&#39;</span><span class="s">%s</span><span class="se">\&#39;</span><span class="s"> invalid</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">nouveau_vbios</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">mthd</span> <span class="o">=</span> <span class="n">shadow_methods</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">NV_TRACE</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Checking %s for VBIOS</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mthd</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">);</span>
		<span class="n">mthd</span><span class="o">-&gt;</span><span class="n">shadow</span><span class="p">(</span><span class="n">bios</span><span class="p">);</span>
		<span class="n">mthd</span><span class="o">-&gt;</span><span class="n">score</span> <span class="o">=</span> <span class="n">score_vbios</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">mthd</span><span class="o">-&gt;</span><span class="n">rw</span><span class="p">);</span>
		<span class="n">mthd</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
		<span class="n">mthd</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
		<span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">mthd</span><span class="o">-&gt;</span><span class="n">score</span> <span class="o">!=</span> <span class="mi">3</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">++</span><span class="n">mthd</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">shadow</span><span class="p">);</span>

	<span class="n">mthd</span> <span class="o">=</span> <span class="n">shadow_methods</span><span class="p">;</span>
	<span class="n">best</span> <span class="o">=</span> <span class="n">mthd</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mthd</span><span class="o">-&gt;</span><span class="n">score</span> <span class="o">&gt;</span> <span class="n">best</span><span class="o">-&gt;</span><span class="n">score</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">best</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
			<span class="n">best</span> <span class="o">=</span> <span class="n">mthd</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="o">++</span><span class="n">mthd</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">shadow</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">best</span><span class="o">-&gt;</span><span class="n">score</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">NV_TRACE</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Using VBIOS from %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">best</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">);</span>
		<span class="n">bios</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">best</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
		<span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">best</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">NV_ERROR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;No valid VBIOS image found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">init_tbl_entry</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">id</span><span class="p">;</span>
	<span class="cm">/* Return:</span>
<span class="cm">	 *  &gt; 0: success, length of opcode</span>
<span class="cm">	 *    0: success, but abort further parsing of table (INIT_DONE etc)</span>
<span class="cm">	 *  &lt; 0: failure, table parsing will be aborted</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">handler</span><span class="p">)(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="p">,</span> <span class="kt">uint16_t</span><span class="p">,</span> <span class="k">struct</span> <span class="n">init_exec</span> <span class="o">*</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">parse_init_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="p">,</span> <span class="kt">uint16_t</span><span class="p">,</span> <span class="k">struct</span> <span class="n">init_exec</span> <span class="o">*</span><span class="p">);</span>

<span class="cp">#define MACRO_INDEX_SIZE	2</span>
<span class="cp">#define MACRO_SIZE		8</span>
<span class="cp">#define CONDITION_SIZE		12</span>
<span class="cp">#define IO_FLAG_CONDITION_SIZE	9</span>
<span class="cp">#define IO_CONDITION_SIZE	5</span>
<span class="cp">#define MEM_INIT_SIZE		66</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">still_alive</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	sync();</span>
<span class="c">	mdelay(2);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">uint32_t</span>
<span class="nf">munge_reg</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_nouveau_private</span> <span class="o">*</span><span class="n">dev_priv</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dcb_entry</span> <span class="o">*</span><span class="n">dcbent</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">display</span><span class="p">.</span><span class="n">output</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">card_type</span> <span class="o">&lt;</span> <span class="n">NV_50</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">reg</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">reg</span> <span class="o">&amp;</span> <span class="mh">0x80000000</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">display</span><span class="p">.</span><span class="n">crtc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">reg</span> <span class="o">+=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">display</span><span class="p">.</span><span class="n">crtc</span> <span class="o">*</span> <span class="mh">0x800</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">reg</span> <span class="o">&amp;</span> <span class="mh">0x40000000</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">dcbent</span><span class="p">);</span>

		<span class="n">reg</span> <span class="o">+=</span> <span class="p">(</span><span class="n">ffs</span><span class="p">(</span><span class="n">dcbent</span><span class="o">-&gt;</span><span class="n">or</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mh">0x800</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">reg</span> <span class="o">&amp;</span> <span class="mh">0x20000000</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">dcbent</span><span class="o">-&gt;</span><span class="n">sorconf</span><span class="p">.</span><span class="n">link</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">))</span>
			<span class="n">reg</span> <span class="o">+=</span> <span class="mh">0x00000080</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mh">0xe0000000</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">reg</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">valid_reg</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_nouveau_private</span> <span class="o">*</span><span class="n">dev_priv</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="cm">/* C51 has misaligned regs on purpose. Marvellous */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reg</span> <span class="o">&amp;</span> <span class="mh">0x2</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">reg</span> <span class="o">&amp;</span> <span class="mh">0x1</span> <span class="o">&amp;&amp;</span> <span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">vbios</span><span class="p">.</span><span class="n">chip_version</span> <span class="o">!=</span> <span class="mh">0x51</span><span class="p">))</span>
		<span class="n">NV_ERROR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;======= misaligned reg 0x%08X =======</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>

	<span class="cm">/* warn on C51 regs that haven&#39;t been verified accessible in tracing */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reg</span> <span class="o">&amp;</span> <span class="mh">0x1</span> <span class="o">&amp;&amp;</span> <span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">vbios</span><span class="p">.</span><span class="n">chip_version</span> <span class="o">==</span> <span class="mh">0x51</span> <span class="o">&amp;&amp;</span>
	    <span class="n">reg</span> <span class="o">!=</span> <span class="mh">0x130d</span> <span class="o">&amp;&amp;</span> <span class="n">reg</span> <span class="o">!=</span> <span class="mh">0x1311</span> <span class="o">&amp;&amp;</span> <span class="n">reg</span> <span class="o">!=</span> <span class="mh">0x60081d</span><span class="p">)</span>
		<span class="n">NV_WARN</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;=== C51 misaligned reg 0x%08X not verified ===</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">reg</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">reg</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">NV_ERROR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;=== reg 0x%08x out of mapped bounds ===</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span>
<span class="nf">valid_idx_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_nouveau_private</span> <span class="o">*</span><span class="n">dev_priv</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If adding more ports here, the read/write functions below will need</span>
<span class="cm">	 * updating so that the correct mmio range (PRMCIO, PRMDIO, PRMVIO) is</span>
<span class="cm">	 * used for the port in question</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">card_type</span> <span class="o">&lt;</span> <span class="n">NV_50</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">port</span> <span class="o">==</span> <span class="n">NV_CIO_CRX__COLOR</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">port</span> <span class="o">==</span> <span class="n">NV_VIO_SRX</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">port</span> <span class="o">==</span> <span class="n">NV_CIO_CRX__COLOR</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">NV_ERROR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;========== unknown indexed io port 0x%04X ==========</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">port</span><span class="p">);</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span>
<span class="nf">valid_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If adding more ports here, the read/write functions below will need</span>
<span class="cm">	 * updating so that the correct mmio range (PRMCIO, PRMDIO, PRMVIO) is</span>
<span class="cm">	 * used for the port in question</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">port</span> <span class="o">==</span> <span class="n">NV_VIO_VSE2</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="n">NV_ERROR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;========== unknown io port 0x%04X ==========</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">uint32_t</span>
<span class="nf">bios_rd32</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">data</span><span class="p">;</span>

	<span class="n">reg</span> <span class="o">=</span> <span class="n">munge_reg</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">valid_reg</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">reg</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * C51 sometimes uses regs with bit0 set in the address. For these</span>
<span class="cm">	 * cases there should exist a translation in a BIOS table to an IO</span>
<span class="cm">	 * port address which the BIOS uses for accessing the reg</span>
<span class="cm">	 *</span>
<span class="cm">	 * These only seem to appear for the power control regs to a flat panel,</span>
<span class="cm">	 * and the GPIO regs at 0x60081*.  In C51 mmio traces the normal regs</span>
<span class="cm">	 * for 0x1308 and 0x1310 are used - hence the mask below.  An S3</span>
<span class="cm">	 * suspend-resume mmio trace from a C51 will be required to see if this</span>
<span class="cm">	 * is true for the power microcode in 0x14.., or whether the direct IO</span>
<span class="cm">	 * port access method is needed</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reg</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span>
		<span class="n">reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mh">0x1</span><span class="p">;</span>

	<span class="n">data</span> <span class="o">=</span> <span class="n">nv_rd32</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>

	<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;	Read:  Reg: 0x%08X, Data: 0x%08X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">data</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">bios_wr32</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">reg</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_nouveau_private</span> <span class="o">*</span><span class="n">dev_priv</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_private</span><span class="p">;</span>

	<span class="n">reg</span> <span class="o">=</span> <span class="n">munge_reg</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">valid_reg</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">reg</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* see note in bios_rd32 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reg</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span>
		<span class="n">reg</span> <span class="o">&amp;=</span> <span class="mh">0xfffffffe</span><span class="p">;</span>

	<span class="n">LOG_OLD_VALUE</span><span class="p">(</span><span class="n">bios_rd32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">reg</span><span class="p">));</span>
	<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;	Write: Reg: 0x%08X, Data: 0x%08X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">vbios</span><span class="p">.</span><span class="n">execute</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">still_alive</span><span class="p">();</span>
		<span class="n">nv_wr32</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">uint8_t</span>
<span class="nf">bios_idxprt_rd</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">port</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_nouveau_private</span> <span class="o">*</span><span class="n">dev_priv</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">valid_idx_port</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">port</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">card_type</span> <span class="o">&lt;</span> <span class="n">NV_50</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">port</span> <span class="o">==</span> <span class="n">NV_VIO_SRX</span><span class="p">)</span>
			<span class="n">data</span> <span class="o">=</span> <span class="n">NVReadVgaSeq</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">.</span><span class="n">crtchead</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
		<span class="k">else</span>	<span class="cm">/* assume NV_CIO_CRX__COLOR */</span>
			<span class="n">data</span> <span class="o">=</span> <span class="n">NVReadVgaCrtc</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">.</span><span class="n">crtchead</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="kt">uint32_t</span> <span class="n">data32</span><span class="p">;</span>

		<span class="n">data32</span> <span class="o">=</span> <span class="n">bios_rd32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">NV50_PDISPLAY_VGACRTC</span><span class="p">(</span><span class="n">index</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">3</span><span class="p">));</span>
		<span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="n">data32</span> <span class="o">&gt;&gt;</span> <span class="p">((</span><span class="n">index</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;	Indexed IO read:  Port: 0x%04X, Index: 0x%02X, &quot;</span>
		      <span class="s">&quot;Head: 0x%02X, Data: 0x%02X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">port</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">.</span><span class="n">crtchead</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">data</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">bios_idxprt_wr</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">port</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">index</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_nouveau_private</span> <span class="o">*</span><span class="n">dev_priv</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">valid_idx_port</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">port</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The current head is maintained in the nvbios member  state.crtchead.</span>
<span class="cm">	 * We trap changes to CR44 and update the head variable and hence the</span>
<span class="cm">	 * register set written.</span>
<span class="cm">	 * As CR44 only exists on CRTC0, we update crtchead to head0 in advance</span>
<span class="cm">	 * of the write, and to head1 after the write</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">port</span> <span class="o">==</span> <span class="n">NV_CIO_CRX__COLOR</span> <span class="o">&amp;&amp;</span> <span class="n">index</span> <span class="o">==</span> <span class="n">NV_CIO_CRE_44</span> <span class="o">&amp;&amp;</span>
	    <span class="n">data</span> <span class="o">!=</span> <span class="n">NV_CIO_CRE_44_HEADB</span><span class="p">)</span>
		<span class="n">bios</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">.</span><span class="n">crtchead</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">LOG_OLD_VALUE</span><span class="p">(</span><span class="n">bios_idxprt_rd</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">index</span><span class="p">));</span>
	<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;	Indexed IO write: Port: 0x%04X, Index: 0x%02X, &quot;</span>
		      <span class="s">&quot;Head: 0x%02X, Data: 0x%02X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">port</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">.</span><span class="n">crtchead</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">execute</span> <span class="o">&amp;&amp;</span> <span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">card_type</span> <span class="o">&lt;</span> <span class="n">NV_50</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">still_alive</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">port</span> <span class="o">==</span> <span class="n">NV_VIO_SRX</span><span class="p">)</span>
			<span class="n">NVWriteVgaSeq</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">.</span><span class="n">crtchead</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
		<span class="k">else</span>	<span class="cm">/* assume NV_CIO_CRX__COLOR */</span>
			<span class="n">NVWriteVgaCrtc</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">.</span><span class="n">crtchead</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">uint32_t</span> <span class="n">data32</span><span class="p">,</span> <span class="n">shift</span> <span class="o">=</span> <span class="p">(</span><span class="n">index</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">;</span>

		<span class="n">still_alive</span><span class="p">();</span>

		<span class="n">data32</span>  <span class="o">=</span> <span class="n">bios_rd32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">NV50_PDISPLAY_VGACRTC</span><span class="p">(</span><span class="n">index</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">3</span><span class="p">));</span>
		<span class="n">data32</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mh">0xff</span> <span class="o">&lt;&lt;</span> <span class="n">shift</span><span class="p">);</span>
		<span class="n">data32</span> <span class="o">|=</span> <span class="p">(</span><span class="n">data</span> <span class="o">&lt;&lt;</span> <span class="n">shift</span><span class="p">);</span>
		<span class="n">bios_wr32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">NV50_PDISPLAY_VGACRTC</span><span class="p">(</span><span class="n">index</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">3</span><span class="p">),</span> <span class="n">data32</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">port</span> <span class="o">==</span> <span class="n">NV_CIO_CRX__COLOR</span> <span class="o">&amp;&amp;</span>
	    <span class="n">index</span> <span class="o">==</span> <span class="n">NV_CIO_CRE_44</span> <span class="o">&amp;&amp;</span> <span class="n">data</span> <span class="o">==</span> <span class="n">NV_CIO_CRE_44_HEADB</span><span class="p">)</span>
		<span class="n">bios</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">.</span><span class="n">crtchead</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">uint8_t</span>
<span class="nf">bios_port_rd</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint8_t</span> <span class="n">data</span><span class="p">,</span> <span class="n">head</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">.</span><span class="n">crtchead</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">valid_port</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">port</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">data</span> <span class="o">=</span> <span class="n">NVReadPRMVIO</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">NV_PRMVIO0_OFFSET</span> <span class="o">+</span> <span class="n">port</span><span class="p">);</span>

	<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;	IO read:  Port: 0x%04X, Head: 0x%02X, Data: 0x%02X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">port</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">data</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">bios_port_wr</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">port</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">head</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">.</span><span class="n">crtchead</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">valid_port</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">port</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">LOG_OLD_VALUE</span><span class="p">(</span><span class="n">bios_port_rd</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">port</span><span class="p">));</span>
	<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;	IO write: Port: 0x%04X, Head: 0x%02X, Data: 0x%02X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">port</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">still_alive</span><span class="p">();</span>
	<span class="n">NVWritePRMVIO</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">NV_PRMVIO0_OFFSET</span> <span class="o">+</span> <span class="n">port</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span>
<span class="nf">io_flag_condition_met</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">cond</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * The IO flag condition entry has 2 bytes for the CRTC port; 1 byte</span>
<span class="cm">	 * for the CRTC index; 1 byte for the mask to apply to the value</span>
<span class="cm">	 * retrieved from the CRTC; 1 byte for the shift right to apply to the</span>
<span class="cm">	 * masked CRTC value; 2 bytes for the offset to the flag array, to</span>
<span class="cm">	 * which the shifted value is added; 1 byte for the mask applied to the</span>
<span class="cm">	 * value read from the flag array; and 1 byte for the value to compare</span>
<span class="cm">	 * against the masked byte from the flag table.</span>
<span class="cm">	 */</span>

	<span class="kt">uint16_t</span> <span class="n">condptr</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">io_flag_condition_tbl_ptr</span> <span class="o">+</span> <span class="n">cond</span> <span class="o">*</span> <span class="n">IO_FLAG_CONDITION_SIZE</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">crtcport</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">condptr</span><span class="p">]);</span>
	<span class="kt">uint8_t</span> <span class="n">crtcindex</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">condptr</span> <span class="o">+</span> <span class="mi">2</span><span class="p">];</span>
	<span class="kt">uint8_t</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">condptr</span> <span class="o">+</span> <span class="mi">3</span><span class="p">];</span>
	<span class="kt">uint8_t</span> <span class="n">shift</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">condptr</span> <span class="o">+</span> <span class="mi">4</span><span class="p">];</span>
	<span class="kt">uint16_t</span> <span class="n">flagarray</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">condptr</span> <span class="o">+</span> <span class="mi">5</span><span class="p">]);</span>
	<span class="kt">uint8_t</span> <span class="n">flagarraymask</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">condptr</span> <span class="o">+</span> <span class="mi">7</span><span class="p">];</span>
	<span class="kt">uint8_t</span> <span class="n">cmpval</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">condptr</span> <span class="o">+</span> <span class="mi">8</span><span class="p">];</span>
	<span class="kt">uint8_t</span> <span class="n">data</span><span class="p">;</span>

	<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;0x%04X: Port: 0x%04X, Index: 0x%02X, Mask: 0x%02X, &quot;</span>
		      <span class="s">&quot;Shift: 0x%02X, FlagArray: 0x%04X, FAMask: 0x%02X, &quot;</span>
		      <span class="s">&quot;Cmpval: 0x%02X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">offset</span><span class="p">,</span> <span class="n">crtcport</span><span class="p">,</span> <span class="n">crtcindex</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">shift</span><span class="p">,</span> <span class="n">flagarray</span><span class="p">,</span> <span class="n">flagarraymask</span><span class="p">,</span> <span class="n">cmpval</span><span class="p">);</span>

	<span class="n">data</span> <span class="o">=</span> <span class="n">bios_idxprt_rd</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">crtcport</span><span class="p">,</span> <span class="n">crtcindex</span><span class="p">);</span>

	<span class="n">data</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">flagarray</span> <span class="o">+</span> <span class="p">((</span><span class="n">data</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">shift</span><span class="p">)];</span>
	<span class="n">data</span> <span class="o">&amp;=</span> <span class="n">flagarraymask</span><span class="p">;</span>

	<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;0x%04X: Checking if 0x%02X equals 0x%02X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">offset</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">cmpval</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">data</span> <span class="o">==</span> <span class="n">cmpval</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span>
<span class="nf">bios_condition_met</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">cond</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * The condition table entry has 4 bytes for the address of the</span>
<span class="cm">	 * register to check, 4 bytes for a mask to apply to the register and</span>
<span class="cm">	 * 4 for a test comparison value</span>
<span class="cm">	 */</span>

	<span class="kt">uint16_t</span> <span class="n">condptr</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">condition_tbl_ptr</span> <span class="o">+</span> <span class="n">cond</span> <span class="o">*</span> <span class="n">CONDITION_SIZE</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">reg</span> <span class="o">=</span> <span class="n">ROM32</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">condptr</span><span class="p">]);</span>
	<span class="kt">uint32_t</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">ROM32</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">condptr</span> <span class="o">+</span> <span class="mi">4</span><span class="p">]);</span>
	<span class="kt">uint32_t</span> <span class="n">cmpval</span> <span class="o">=</span> <span class="n">ROM32</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">condptr</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]);</span>
	<span class="kt">uint32_t</span> <span class="n">data</span><span class="p">;</span>

	<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;0x%04X: Cond: 0x%02X, Reg: 0x%08X, Mask: 0x%08X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">offset</span><span class="p">,</span> <span class="n">cond</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>

	<span class="n">data</span> <span class="o">=</span> <span class="n">bios_rd32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">reg</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">;</span>

	<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;0x%04X: Checking if 0x%08X equals 0x%08X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">offset</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">cmpval</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">data</span> <span class="o">==</span> <span class="n">cmpval</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span>
<span class="nf">io_condition_met</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">cond</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * The IO condition entry has 2 bytes for the IO port address; 1 byte</span>
<span class="cm">	 * for the index to write to io_port; 1 byte for the mask to apply to</span>
<span class="cm">	 * the byte read from io_port+1; and 1 byte for the value to compare</span>
<span class="cm">	 * against the masked byte.</span>
<span class="cm">	 */</span>

	<span class="kt">uint16_t</span> <span class="n">condptr</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">io_condition_tbl_ptr</span> <span class="o">+</span> <span class="n">cond</span> <span class="o">*</span> <span class="n">IO_CONDITION_SIZE</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">io_port</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">condptr</span><span class="p">]);</span>
	<span class="kt">uint8_t</span> <span class="n">port_index</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">condptr</span> <span class="o">+</span> <span class="mi">2</span><span class="p">];</span>
	<span class="kt">uint8_t</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">condptr</span> <span class="o">+</span> <span class="mi">3</span><span class="p">];</span>
	<span class="kt">uint8_t</span> <span class="n">cmpval</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">condptr</span> <span class="o">+</span> <span class="mi">4</span><span class="p">];</span>

	<span class="kt">uint8_t</span> <span class="n">data</span> <span class="o">=</span> <span class="n">bios_idxprt_rd</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">io_port</span><span class="p">,</span> <span class="n">port_index</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">;</span>

	<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;0x%04X: Checking if 0x%02X equals 0x%02X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">offset</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">cmpval</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">data</span> <span class="o">==</span> <span class="n">cmpval</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">nv50_pll_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">reg</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">clk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_nouveau_private</span> <span class="o">*</span><span class="n">dev_priv</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nouveau_pll_vals</span> <span class="n">pll</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pll_lims</span> <span class="n">pll_limits</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ctrl</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">coef</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">get_pll_limits</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pll_limits</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">clk</span> <span class="o">=</span> <span class="n">nouveau_calc_pll_mnp</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pll_limits</span><span class="p">,</span> <span class="n">clk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pll</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clk</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ERANGE</span><span class="p">;</span>

	<span class="n">coef</span> <span class="o">=</span> <span class="n">pll</span><span class="p">.</span><span class="n">N1</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span> <span class="o">|</span> <span class="n">pll</span><span class="p">.</span><span class="n">M1</span><span class="p">;</span>
	<span class="n">ctrl</span> <span class="o">=</span> <span class="n">pll</span><span class="p">.</span><span class="n">log2P</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
	<span class="n">mask</span> <span class="o">=</span> <span class="mh">0x00070000</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reg</span> <span class="o">==</span> <span class="mh">0x004008</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mask</span> <span class="o">|=</span> <span class="mh">0x01f80000</span><span class="p">;</span>
		<span class="n">ctrl</span> <span class="o">|=</span> <span class="p">(</span><span class="n">pll_limits</span><span class="p">.</span><span class="n">log2p_bias</span> <span class="o">&lt;&lt;</span> <span class="mi">19</span><span class="p">);</span>
		<span class="n">ctrl</span> <span class="o">|=</span> <span class="p">(</span><span class="n">pll</span><span class="p">.</span><span class="n">log2P</span> <span class="o">&lt;&lt;</span> <span class="mi">22</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">vbios</span><span class="p">.</span><span class="n">execute</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">nv_mask</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">reg</span> <span class="o">+</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">);</span>
	<span class="n">nv_wr32</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">reg</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="n">coef</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">setPLL</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">reg</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">clk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_nouveau_private</span> <span class="o">*</span><span class="n">dev_priv</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_private</span><span class="p">;</span>
	<span class="cm">/* clk in kHz */</span>
	<span class="k">struct</span> <span class="n">pll_lims</span> <span class="n">pll_lim</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nouveau_pll_vals</span> <span class="n">pllvals</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">card_type</span> <span class="o">&gt;=</span> <span class="n">NV_50</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">nv50_pll_set</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">clk</span><span class="p">);</span>

	<span class="cm">/* high regs (such as in the mac g5 table) are not -= 4 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">get_pll_limits</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">reg</span> <span class="o">&gt;</span> <span class="mh">0x405c</span> <span class="o">?</span> <span class="n">reg</span> <span class="o">:</span> <span class="n">reg</span> <span class="o">-</span> <span class="mi">4</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pll_lim</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">clk</span> <span class="o">=</span> <span class="n">nouveau_calc_pll_mnp</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pll_lim</span><span class="p">,</span> <span class="n">clk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pllvals</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clk</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ERANGE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">still_alive</span><span class="p">();</span>
		<span class="n">nouveau_hw_setpll</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pllvals</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dcb_entry_idx_from_crtchead</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_nouveau_private</span> <span class="o">*</span><span class="n">dev_priv</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">vbios</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * For the results of this function to be correct, CR44 must have been</span>
<span class="cm">	 * set (using bios_idxprt_wr to set crtchead), CR58 set for CR57 = 0,</span>
<span class="cm">	 * and the DCB table parsed, before the script calling the function is</span>
<span class="cm">	 * run.  run_digital_op_script is example of how to do such setup</span>
<span class="cm">	 */</span>

	<span class="kt">uint8_t</span> <span class="n">dcb_entry</span> <span class="o">=</span> <span class="n">NVReadVgaCrtc5758</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">.</span><span class="n">crtchead</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dcb_entry</span> <span class="o">&gt;</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">dcb</span><span class="p">.</span><span class="n">entries</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">NV_ERROR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;CR58 doesn&#39;t have a valid DCB entry currently &quot;</span>
				<span class="s">&quot;(%02X)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dcb_entry</span><span class="p">);</span>
		<span class="n">dcb_entry</span> <span class="o">=</span> <span class="mh">0x7f</span><span class="p">;</span>	<span class="cm">/* unused / invalid marker */</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">dcb_entry</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">nouveau_i2c_chan</span> <span class="o">*</span>
<span class="nf">init_i2c_device_find</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i2c_index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i2c_index</span> <span class="o">==</span> <span class="mh">0xff</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">drm_nouveau_private</span> <span class="o">*</span><span class="n">dev_priv</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_private</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">dcb_table</span> <span class="o">*</span><span class="n">dcb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">vbios</span><span class="p">.</span><span class="n">dcb</span><span class="p">;</span>
		<span class="cm">/* note: dcb_entry_idx_from_crtchead needs pre-script set-up */</span>
		<span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">dcb_entry_idx_from_crtchead</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

		<span class="n">i2c_index</span> <span class="o">=</span> <span class="n">NV_I2C_DEFAULT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">!=</span> <span class="mh">0x7f</span> <span class="o">&amp;&amp;</span> <span class="n">dcb</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">i2c_upper_default</span><span class="p">)</span>
			<span class="n">i2c_index</span> <span class="o">=</span> <span class="n">NV_I2C_DEFAULT</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">nouveau_i2c_find</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">i2c_index</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">uint32_t</span>
<span class="nf">get_tmds_index_reg</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">mlv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * For mlv &lt; 0x80, it is an index into a table of TMDS base addresses.</span>
<span class="cm">	 * For mlv == 0x80 use the &quot;or&quot; value of the dcb_entry indexed by</span>
<span class="cm">	 * CR58 for CR57 = 0 to index a table of offsets to the basic</span>
<span class="cm">	 * 0x6808b0 address.</span>
<span class="cm">	 * For mlv == 0x81 use the &quot;or&quot; value of the dcb_entry indexed by</span>
<span class="cm">	 * CR58 for CR57 = 0 to index a table of offsets to the basic</span>
<span class="cm">	 * 0x6808b0 address, and then flip the offset by 8.</span>
<span class="cm">	 */</span>

	<span class="k">struct</span> <span class="n">drm_nouveau_private</span> <span class="o">*</span><span class="n">dev_priv</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">vbios</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">pramdac_offset</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x2000</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x2008</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x2000</span> <span class="p">};</span>
	<span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">pramdac_table</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="mh">0x6808b0</span><span class="p">,</span> <span class="mh">0x6808b8</span><span class="p">,</span> <span class="mh">0x6828b0</span><span class="p">,</span> <span class="mh">0x6828b8</span> <span class="p">};</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mlv</span> <span class="o">&gt;=</span> <span class="mh">0x80</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">dcb_entry</span><span class="p">,</span> <span class="n">dacoffset</span><span class="p">;</span>

		<span class="cm">/* note: dcb_entry_idx_from_crtchead needs pre-script set-up */</span>
		<span class="n">dcb_entry</span> <span class="o">=</span> <span class="n">dcb_entry_idx_from_crtchead</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dcb_entry</span> <span class="o">==</span> <span class="mh">0x7f</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">dacoffset</span> <span class="o">=</span> <span class="n">pramdac_offset</span><span class="p">[</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">dcb</span><span class="p">.</span><span class="n">entry</span><span class="p">[</span><span class="n">dcb_entry</span><span class="p">].</span><span class="n">or</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mlv</span> <span class="o">==</span> <span class="mh">0x81</span><span class="p">)</span>
			<span class="n">dacoffset</span> <span class="o">^=</span> <span class="mi">8</span><span class="p">;</span>
		<span class="k">return</span> <span class="mh">0x6808b0</span> <span class="o">+</span> <span class="n">dacoffset</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mlv</span> <span class="o">&gt;=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">pramdac_table</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">NV_ERROR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Magic Lookup Value too big (%02X)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
									<span class="n">mlv</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">pramdac_table</span><span class="p">[</span><span class="n">mlv</span><span class="p">];</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">init_io_restrict_prog</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">offset</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">init_exec</span> <span class="o">*</span><span class="n">iexec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * INIT_IO_RESTRICT_PROG   opcode: 0x32 (&#39;2&#39;)</span>
<span class="cm">	 *</span>
<span class="cm">	 * offset      (8  bit): opcode</span>
<span class="cm">	 * offset + 1  (16 bit): CRTC port</span>
<span class="cm">	 * offset + 3  (8  bit): CRTC index</span>
<span class="cm">	 * offset + 4  (8  bit): mask</span>
<span class="cm">	 * offset + 5  (8  bit): shift</span>
<span class="cm">	 * offset + 6  (8  bit): count</span>
<span class="cm">	 * offset + 7  (32 bit): register</span>
<span class="cm">	 * offset + 11 (32 bit): configuration 1</span>
<span class="cm">	 * ...</span>
<span class="cm">	 *</span>
<span class="cm">	 * Starting at offset + 11 there are &quot;count&quot; 32 bit values.</span>
<span class="cm">	 * To find out which value to use read index &quot;CRTC index&quot; on &quot;CRTC</span>
<span class="cm">	 * port&quot;, AND this value with &quot;mask&quot; and then bit shift right &quot;shift&quot;</span>
<span class="cm">	 * bits.  Read the appropriate value using this index and write to</span>
<span class="cm">	 * &quot;register&quot;</span>
<span class="cm">	 */</span>

	<span class="kt">uint16_t</span> <span class="n">crtcport</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]);</span>
	<span class="kt">uint8_t</span> <span class="n">crtcindex</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">3</span><span class="p">];</span>
	<span class="kt">uint8_t</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">4</span><span class="p">];</span>
	<span class="kt">uint8_t</span> <span class="n">shift</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">5</span><span class="p">];</span>
	<span class="kt">uint8_t</span> <span class="n">count</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">6</span><span class="p">];</span>
	<span class="kt">uint32_t</span> <span class="n">reg</span> <span class="o">=</span> <span class="n">ROM32</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">7</span><span class="p">]);</span>
	<span class="kt">uint8_t</span> <span class="n">config</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">configval</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">11</span> <span class="o">+</span> <span class="n">count</span> <span class="o">*</span> <span class="mi">4</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iexec</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">len</span><span class="p">;</span>

	<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;0x%04X: Port: 0x%04X, Index: 0x%02X, Mask: 0x%02X, &quot;</span>
		      <span class="s">&quot;Shift: 0x%02X, Count: 0x%02X, Reg: 0x%08X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">offset</span><span class="p">,</span> <span class="n">crtcport</span><span class="p">,</span> <span class="n">crtcindex</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">shift</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>

	<span class="n">config</span> <span class="o">=</span> <span class="p">(</span><span class="n">bios_idxprt_rd</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">crtcport</span><span class="p">,</span> <span class="n">crtcindex</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">shift</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">config</span> <span class="o">&gt;</span> <span class="n">count</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">NV_ERROR</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			 <span class="s">&quot;0x%04X: Config 0x%02X exceeds maximal bound 0x%02X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">offset</span><span class="p">,</span> <span class="n">config</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">configval</span> <span class="o">=</span> <span class="n">ROM32</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">11</span> <span class="o">+</span> <span class="n">config</span> <span class="o">*</span> <span class="mi">4</span><span class="p">]);</span>

	<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;0x%04X: Writing config %02X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">config</span><span class="p">);</span>

	<span class="n">bios_wr32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">configval</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">init_repeat</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">offset</span><span class="p">,</span> <span class="k">struct</span> <span class="n">init_exec</span> <span class="o">*</span><span class="n">iexec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * INIT_REPEAT   opcode: 0x33 (&#39;3&#39;)</span>
<span class="cm">	 *</span>
<span class="cm">	 * offset      (8 bit): opcode</span>
<span class="cm">	 * offset + 1  (8 bit): count</span>
<span class="cm">	 *</span>
<span class="cm">	 * Execute script following this opcode up to INIT_REPEAT_END</span>
<span class="cm">	 * &quot;count&quot; times</span>
<span class="cm">	 */</span>

	<span class="kt">uint8_t</span> <span class="n">count</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="kt">uint8_t</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* no iexec-&gt;execute check by design */</span>

	<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;0x%04X: Repeating following segment %d times</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">offset</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>

	<span class="n">iexec</span><span class="o">-&gt;</span><span class="n">repeat</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * count - 1, as the script block will execute once when we leave this</span>
<span class="cm">	 * opcode -- this is compatible with bios behaviour as:</span>
<span class="cm">	 * a) the block is always executed at least once, even if count == 0</span>
<span class="cm">	 * b) the bios interpreter skips to the op following INIT_END_REPEAT,</span>
<span class="cm">	 * while we don&#39;t</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">parse_init_table</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">offset</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">iexec</span><span class="p">);</span>

	<span class="n">iexec</span><span class="o">-&gt;</span><span class="n">repeat</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">init_io_restrict_pll</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">offset</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">init_exec</span> <span class="o">*</span><span class="n">iexec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * INIT_IO_RESTRICT_PLL   opcode: 0x34 (&#39;4&#39;)</span>
<span class="cm">	 *</span>
<span class="cm">	 * offset      (8  bit): opcode</span>
<span class="cm">	 * offset + 1  (16 bit): CRTC port</span>
<span class="cm">	 * offset + 3  (8  bit): CRTC index</span>
<span class="cm">	 * offset + 4  (8  bit): mask</span>
<span class="cm">	 * offset + 5  (8  bit): shift</span>
<span class="cm">	 * offset + 6  (8  bit): IO flag condition index</span>
<span class="cm">	 * offset + 7  (8  bit): count</span>
<span class="cm">	 * offset + 8  (32 bit): register</span>
<span class="cm">	 * offset + 12 (16 bit): frequency 1</span>
<span class="cm">	 * ...</span>
<span class="cm">	 *</span>
<span class="cm">	 * Starting at offset + 12 there are &quot;count&quot; 16 bit frequencies (10kHz).</span>
<span class="cm">	 * Set PLL register &quot;register&quot; to coefficients for frequency n,</span>
<span class="cm">	 * selected by reading index &quot;CRTC index&quot; of &quot;CRTC port&quot; ANDed with</span>
<span class="cm">	 * &quot;mask&quot; and shifted right by &quot;shift&quot;.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If &quot;IO flag condition index&quot; &gt; 0, and condition met, double</span>
<span class="cm">	 * frequency before setting it.</span>
<span class="cm">	 */</span>

	<span class="kt">uint16_t</span> <span class="n">crtcport</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]);</span>
	<span class="kt">uint8_t</span> <span class="n">crtcindex</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">3</span><span class="p">];</span>
	<span class="kt">uint8_t</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">4</span><span class="p">];</span>
	<span class="kt">uint8_t</span> <span class="n">shift</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">5</span><span class="p">];</span>
	<span class="kt">int8_t</span> <span class="n">io_flag_condition_idx</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">6</span><span class="p">];</span>
	<span class="kt">uint8_t</span> <span class="n">count</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">7</span><span class="p">];</span>
	<span class="kt">uint32_t</span> <span class="n">reg</span> <span class="o">=</span> <span class="n">ROM32</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]);</span>
	<span class="kt">uint8_t</span> <span class="n">config</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">freq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">12</span> <span class="o">+</span> <span class="n">count</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iexec</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">len</span><span class="p">;</span>

	<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;0x%04X: Port: 0x%04X, Index: 0x%02X, Mask: 0x%02X, &quot;</span>
		      <span class="s">&quot;Shift: 0x%02X, IO Flag Condition: 0x%02X, &quot;</span>
		      <span class="s">&quot;Count: 0x%02X, Reg: 0x%08X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">offset</span><span class="p">,</span> <span class="n">crtcport</span><span class="p">,</span> <span class="n">crtcindex</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">shift</span><span class="p">,</span>
		<span class="n">io_flag_condition_idx</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>

	<span class="n">config</span> <span class="o">=</span> <span class="p">(</span><span class="n">bios_idxprt_rd</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">crtcport</span><span class="p">,</span> <span class="n">crtcindex</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">shift</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">config</span> <span class="o">&gt;</span> <span class="n">count</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">NV_ERROR</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			 <span class="s">&quot;0x%04X: Config 0x%02X exceeds maximal bound 0x%02X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">offset</span><span class="p">,</span> <span class="n">config</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">freq</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">12</span> <span class="o">+</span> <span class="n">config</span> <span class="o">*</span> <span class="mi">2</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">io_flag_condition_idx</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">io_flag_condition_met</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">io_flag_condition_idx</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;0x%04X: Condition fulfilled -- &quot;</span>
				      <span class="s">&quot;frequency doubled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
			<span class="n">freq</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;0x%04X: Condition not fulfilled -- &quot;</span>
				      <span class="s">&quot;frequency unchanged</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;0x%04X: Reg: 0x%08X, Config: 0x%02X, Freq: %d0kHz</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">offset</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">config</span><span class="p">,</span> <span class="n">freq</span><span class="p">);</span>

	<span class="n">setPLL</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">freq</span> <span class="o">*</span> <span class="mi">10</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">init_end_repeat</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">offset</span><span class="p">,</span> <span class="k">struct</span> <span class="n">init_exec</span> <span class="o">*</span><span class="n">iexec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * INIT_END_REPEAT   opcode: 0x36 (&#39;6&#39;)</span>
<span class="cm">	 *</span>
<span class="cm">	 * offset      (8 bit): opcode</span>
<span class="cm">	 *</span>
<span class="cm">	 * Marks the end of the block for INIT_REPEAT to repeat</span>
<span class="cm">	 */</span>

	<span class="cm">/* no iexec-&gt;execute check by design */</span>

	<span class="cm">/*</span>
<span class="cm">	 * iexec-&gt;repeat flag necessary to go past INIT_END_REPEAT opcode when</span>
<span class="cm">	 * we&#39;re not in repeat mode</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iexec</span><span class="o">-&gt;</span><span class="n">repeat</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">init_copy</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">offset</span><span class="p">,</span> <span class="k">struct</span> <span class="n">init_exec</span> <span class="o">*</span><span class="n">iexec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * INIT_COPY   opcode: 0x37 (&#39;7&#39;)</span>
<span class="cm">	 *</span>
<span class="cm">	 * offset      (8  bit): opcode</span>
<span class="cm">	 * offset + 1  (32 bit): register</span>
<span class="cm">	 * offset + 5  (8  bit): shift</span>
<span class="cm">	 * offset + 6  (8  bit): srcmask</span>
<span class="cm">	 * offset + 7  (16 bit): CRTC port</span>
<span class="cm">	 * offset + 9  (8 bit): CRTC index</span>
<span class="cm">	 * offset + 10  (8 bit): mask</span>
<span class="cm">	 *</span>
<span class="cm">	 * Read index &quot;CRTC index&quot; on &quot;CRTC port&quot;, AND with &quot;mask&quot;, OR with</span>
<span class="cm">	 * (REGVAL(&quot;register&quot;) &gt;&gt; &quot;shift&quot; &amp; &quot;srcmask&quot;) and write-back to CRTC</span>
<span class="cm">	 * port</span>
<span class="cm">	 */</span>

	<span class="kt">uint32_t</span> <span class="n">reg</span> <span class="o">=</span> <span class="n">ROM32</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]);</span>
	<span class="kt">uint8_t</span> <span class="n">shift</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">5</span><span class="p">];</span>
	<span class="kt">uint8_t</span> <span class="n">srcmask</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">6</span><span class="p">];</span>
	<span class="kt">uint16_t</span> <span class="n">crtcport</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">7</span><span class="p">]);</span>
	<span class="kt">uint8_t</span> <span class="n">crtcindex</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">9</span><span class="p">];</span>
	<span class="kt">uint8_t</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">10</span><span class="p">];</span>
	<span class="kt">uint32_t</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">crtcdata</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iexec</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">11</span><span class="p">;</span>

	<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;0x%04X: Reg: 0x%08X, Shift: 0x%02X, SrcMask: 0x%02X, &quot;</span>
		      <span class="s">&quot;Port: 0x%04X, Index: 0x%02X, Mask: 0x%02X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">offset</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">shift</span><span class="p">,</span> <span class="n">srcmask</span><span class="p">,</span> <span class="n">crtcport</span><span class="p">,</span> <span class="n">crtcindex</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>

	<span class="n">data</span> <span class="o">=</span> <span class="n">bios_rd32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">shift</span> <span class="o">&lt;</span> <span class="mh">0x80</span><span class="p">)</span>
		<span class="n">data</span> <span class="o">&gt;&gt;=</span> <span class="n">shift</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">data</span> <span class="o">&lt;&lt;=</span> <span class="p">(</span><span class="mh">0x100</span> <span class="o">-</span> <span class="n">shift</span><span class="p">);</span>

	<span class="n">data</span> <span class="o">&amp;=</span> <span class="n">srcmask</span><span class="p">;</span>

	<span class="n">crtcdata</span>  <span class="o">=</span> <span class="n">bios_idxprt_rd</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">crtcport</span><span class="p">,</span> <span class="n">crtcindex</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">;</span>
	<span class="n">crtcdata</span> <span class="o">|=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
	<span class="n">bios_idxprt_wr</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">crtcport</span><span class="p">,</span> <span class="n">crtcindex</span><span class="p">,</span> <span class="n">crtcdata</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">11</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">init_not</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">offset</span><span class="p">,</span> <span class="k">struct</span> <span class="n">init_exec</span> <span class="o">*</span><span class="n">iexec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * INIT_NOT   opcode: 0x38 (&#39;8&#39;)</span>
<span class="cm">	 *</span>
<span class="cm">	 * offset      (8  bit): opcode</span>
<span class="cm">	 *</span>
<span class="cm">	 * Invert the current execute / no-execute condition (i.e. &quot;else&quot;)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iexec</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">)</span>
		<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;0x%04X: ------ Skipping following commands  ------</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;0x%04X: ------ Executing following commands ------</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>

	<span class="n">iexec</span><span class="o">-&gt;</span><span class="n">execute</span> <span class="o">=</span> <span class="o">!</span><span class="n">iexec</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">init_io_flag_condition</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">offset</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">init_exec</span> <span class="o">*</span><span class="n">iexec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * INIT_IO_FLAG_CONDITION   opcode: 0x39 (&#39;9&#39;)</span>
<span class="cm">	 *</span>
<span class="cm">	 * offset      (8 bit): opcode</span>
<span class="cm">	 * offset + 1  (8 bit): condition number</span>
<span class="cm">	 *</span>
<span class="cm">	 * Check condition &quot;condition number&quot; in the IO flag condition table.</span>
<span class="cm">	 * If condition not met skip subsequent opcodes until condition is</span>
<span class="cm">	 * inverted (INIT_NOT), or we hit INIT_RESUME</span>
<span class="cm">	 */</span>

	<span class="kt">uint8_t</span> <span class="n">cond</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iexec</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">2</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">io_flag_condition_met</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">cond</span><span class="p">))</span>
		<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;0x%04X: Condition fulfilled -- continuing to execute</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;0x%04X: Condition not fulfilled -- skipping following commands</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
		<span class="n">iexec</span><span class="o">-&gt;</span><span class="n">execute</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">init_dp_condition</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">offset</span><span class="p">,</span> <span class="k">struct</span> <span class="n">init_exec</span> <span class="o">*</span><span class="n">iexec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * INIT_DP_CONDITION   opcode: 0x3A (&#39;&#39;)</span>
<span class="cm">	 *</span>
<span class="cm">	 * offset      (8 bit): opcode</span>
<span class="cm">	 * offset + 1  (8 bit): &quot;sub&quot; opcode</span>
<span class="cm">	 * offset + 2  (8 bit): unknown</span>
<span class="cm">	 *</span>
<span class="cm">	 */</span>

	<span class="k">struct</span> <span class="n">dcb_entry</span> <span class="o">*</span><span class="n">dcb</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">display</span><span class="p">.</span><span class="n">output</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">cond</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">table</span><span class="p">,</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>

	<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;0x%04X: subop 0x%02X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">cond</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iexec</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">3</span><span class="p">;</span>

	<span class="n">table</span> <span class="o">=</span> <span class="n">nouveau_dp_bios_data</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">dcb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">entry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">table</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">3</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cond</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="n">entry</span> <span class="o">=</span> <span class="n">dcb_conn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">dcb</span><span class="o">-&gt;</span><span class="n">connector</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">entry</span> <span class="o">||</span> <span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">DCB_CONNECTOR_eDP</span><span class="p">)</span>
			<span class="n">iexec</span><span class="o">-&gt;</span><span class="n">execute</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1</span>:
	<span class="k">case</span> <span class="mi">2</span>:
		<span class="k">if</span> <span class="p">((</span><span class="n">table</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="o">&lt;</span> <span class="mh">0x40</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">entry</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">cond</span><span class="p">))</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">table</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0x40</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">entry</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">cond</span><span class="p">)))</span>
			<span class="n">iexec</span><span class="o">-&gt;</span><span class="n">execute</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">5</span>:
	<span class="p">{</span>
		<span class="k">struct</span> <span class="n">nouveau_i2c_chan</span> <span class="o">*</span><span class="n">auxch</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

		<span class="n">auxch</span> <span class="o">=</span> <span class="n">nouveau_i2c_find</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">display</span><span class="p">.</span><span class="n">output</span><span class="o">-&gt;</span><span class="n">i2c_index</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">auxch</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">NV_ERROR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;0x%04X: couldn&#39;t get auxch</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">3</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">nouveau_dp_auxch</span><span class="p">(</span><span class="n">auxch</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mh">0xd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cond</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">NV_ERROR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;0x%04X: auxch rd fail: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">3</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">cond</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">))</span>
			<span class="n">iexec</span><span class="o">-&gt;</span><span class="n">execute</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">NV_WARN</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;0x%04X: unknown INIT_3A op: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">cond</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iexec</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">)</span>
		<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;0x%04X: continuing to execute</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;0x%04X: skipping following commands</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">init_op_3b</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">offset</span><span class="p">,</span> <span class="k">struct</span> <span class="n">init_exec</span> <span class="o">*</span><span class="n">iexec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * INIT_3B   opcode: 0x3B (&#39;&#39;)</span>
<span class="cm">	 *</span>
<span class="cm">	 * offset      (8 bit): opcode</span>
<span class="cm">	 * offset + 1  (8 bit): crtc index</span>
<span class="cm">	 *</span>
<span class="cm">	 */</span>

	<span class="kt">uint8_t</span> <span class="n">or</span> <span class="o">=</span> <span class="n">ffs</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">display</span><span class="p">.</span><span class="n">output</span><span class="o">-&gt;</span><span class="n">or</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">index</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="kt">uint8_t</span> <span class="n">data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iexec</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">2</span><span class="p">;</span>

	<span class="n">data</span> <span class="o">=</span> <span class="n">bios_idxprt_rd</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="mh">0x3d4</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
	<span class="n">bios_idxprt_wr</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="mh">0x3d4</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">data</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">or</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">init_op_3c</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">offset</span><span class="p">,</span> <span class="k">struct</span> <span class="n">init_exec</span> <span class="o">*</span><span class="n">iexec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * INIT_3C   opcode: 0x3C (&#39;&#39;)</span>
<span class="cm">	 *</span>
<span class="cm">	 * offset      (8 bit): opcode</span>
<span class="cm">	 * offset + 1  (8 bit): crtc index</span>
<span class="cm">	 *</span>
<span class="cm">	 */</span>

	<span class="kt">uint8_t</span> <span class="n">or</span> <span class="o">=</span> <span class="n">ffs</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">display</span><span class="p">.</span><span class="n">output</span><span class="o">-&gt;</span><span class="n">or</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">index</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="kt">uint8_t</span> <span class="n">data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iexec</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">2</span><span class="p">;</span>

	<span class="n">data</span> <span class="o">=</span> <span class="n">bios_idxprt_rd</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="mh">0x3d4</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
	<span class="n">bios_idxprt_wr</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="mh">0x3d4</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">data</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">or</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">init_idx_addr_latched</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">offset</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">init_exec</span> <span class="o">*</span><span class="n">iexec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * INIT_INDEX_ADDRESS_LATCHED   opcode: 0x49 (&#39;I&#39;)</span>
<span class="cm">	 *</span>
<span class="cm">	 * offset      (8  bit): opcode</span>
<span class="cm">	 * offset + 1  (32 bit): control register</span>
<span class="cm">	 * offset + 5  (32 bit): data register</span>
<span class="cm">	 * offset + 9  (32 bit): mask</span>
<span class="cm">	 * offset + 13 (32 bit): data</span>
<span class="cm">	 * offset + 17 (8  bit): count</span>
<span class="cm">	 * offset + 18 (8  bit): address 1</span>
<span class="cm">	 * offset + 19 (8  bit): data 1</span>
<span class="cm">	 * ...</span>
<span class="cm">	 *</span>
<span class="cm">	 * For each of &quot;count&quot; address and data pairs, write &quot;data n&quot; to</span>
<span class="cm">	 * &quot;data register&quot;, read the current value of &quot;control register&quot;,</span>
<span class="cm">	 * and write it back once ANDed with &quot;mask&quot;, ORed with &quot;data&quot;,</span>
<span class="cm">	 * and ORed with &quot;address n&quot;</span>
<span class="cm">	 */</span>

	<span class="kt">uint32_t</span> <span class="n">controlreg</span> <span class="o">=</span> <span class="n">ROM32</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]);</span>
	<span class="kt">uint32_t</span> <span class="n">datareg</span> <span class="o">=</span> <span class="n">ROM32</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">5</span><span class="p">]);</span>
	<span class="kt">uint32_t</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">ROM32</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">9</span><span class="p">]);</span>
	<span class="kt">uint32_t</span> <span class="n">data</span> <span class="o">=</span> <span class="n">ROM32</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">13</span><span class="p">]);</span>
	<span class="kt">uint8_t</span> <span class="n">count</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">17</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">18</span> <span class="o">+</span> <span class="n">count</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">value</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iexec</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">len</span><span class="p">;</span>

	<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;0x%04X: ControlReg: 0x%08X, DataReg: 0x%08X, &quot;</span>
		      <span class="s">&quot;Mask: 0x%08X, Data: 0x%08X, Count: 0x%02X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">offset</span><span class="p">,</span> <span class="n">controlreg</span><span class="p">,</span> <span class="n">datareg</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">uint8_t</span> <span class="n">instaddress</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">18</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="p">];</span>
		<span class="kt">uint8_t</span> <span class="n">instdata</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">19</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="p">];</span>

		<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;0x%04X: Address: 0x%02X, Data: 0x%02X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">offset</span><span class="p">,</span> <span class="n">instaddress</span><span class="p">,</span> <span class="n">instdata</span><span class="p">);</span>

		<span class="n">bios_wr32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">datareg</span><span class="p">,</span> <span class="n">instdata</span><span class="p">);</span>
		<span class="n">value</span>  <span class="o">=</span> <span class="n">bios_rd32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">controlreg</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">;</span>
		<span class="n">value</span> <span class="o">|=</span> <span class="n">data</span><span class="p">;</span>
		<span class="n">value</span> <span class="o">|=</span> <span class="n">instaddress</span><span class="p">;</span>
		<span class="n">bios_wr32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">controlreg</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">init_io_restrict_pll2</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">offset</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">init_exec</span> <span class="o">*</span><span class="n">iexec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * INIT_IO_RESTRICT_PLL2   opcode: 0x4A (&#39;J&#39;)</span>
<span class="cm">	 *</span>
<span class="cm">	 * offset      (8  bit): opcode</span>
<span class="cm">	 * offset + 1  (16 bit): CRTC port</span>
<span class="cm">	 * offset + 3  (8  bit): CRTC index</span>
<span class="cm">	 * offset + 4  (8  bit): mask</span>
<span class="cm">	 * offset + 5  (8  bit): shift</span>
<span class="cm">	 * offset + 6  (8  bit): count</span>
<span class="cm">	 * offset + 7  (32 bit): register</span>
<span class="cm">	 * offset + 11 (32 bit): frequency 1</span>
<span class="cm">	 * ...</span>
<span class="cm">	 *</span>
<span class="cm">	 * Starting at offset + 11 there are &quot;count&quot; 32 bit frequencies (kHz).</span>
<span class="cm">	 * Set PLL register &quot;register&quot; to coefficients for frequency n,</span>
<span class="cm">	 * selected by reading index &quot;CRTC index&quot; of &quot;CRTC port&quot; ANDed with</span>
<span class="cm">	 * &quot;mask&quot; and shifted right by &quot;shift&quot;.</span>
<span class="cm">	 */</span>

	<span class="kt">uint16_t</span> <span class="n">crtcport</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]);</span>
	<span class="kt">uint8_t</span> <span class="n">crtcindex</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">3</span><span class="p">];</span>
	<span class="kt">uint8_t</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">4</span><span class="p">];</span>
	<span class="kt">uint8_t</span> <span class="n">shift</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">5</span><span class="p">];</span>
	<span class="kt">uint8_t</span> <span class="n">count</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">6</span><span class="p">];</span>
	<span class="kt">uint32_t</span> <span class="n">reg</span> <span class="o">=</span> <span class="n">ROM32</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">7</span><span class="p">]);</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">11</span> <span class="o">+</span> <span class="n">count</span> <span class="o">*</span> <span class="mi">4</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">config</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">freq</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iexec</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">len</span><span class="p">;</span>

	<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;0x%04X: Port: 0x%04X, Index: 0x%02X, Mask: 0x%02X, &quot;</span>
		      <span class="s">&quot;Shift: 0x%02X, Count: 0x%02X, Reg: 0x%08X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">offset</span><span class="p">,</span> <span class="n">crtcport</span><span class="p">,</span> <span class="n">crtcindex</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">shift</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">reg</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">len</span><span class="p">;</span>

	<span class="n">config</span> <span class="o">=</span> <span class="p">(</span><span class="n">bios_idxprt_rd</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">crtcport</span><span class="p">,</span> <span class="n">crtcindex</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">shift</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">config</span> <span class="o">&gt;</span> <span class="n">count</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">NV_ERROR</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			 <span class="s">&quot;0x%04X: Config 0x%02X exceeds maximal bound 0x%02X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">offset</span><span class="p">,</span> <span class="n">config</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">freq</span> <span class="o">=</span> <span class="n">ROM32</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">11</span> <span class="o">+</span> <span class="n">config</span> <span class="o">*</span> <span class="mi">4</span><span class="p">]);</span>

	<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;0x%04X: Reg: 0x%08X, Config: 0x%02X, Freq: %dkHz</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">offset</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">config</span><span class="p">,</span> <span class="n">freq</span><span class="p">);</span>

	<span class="n">setPLL</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">freq</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">init_pll2</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">offset</span><span class="p">,</span> <span class="k">struct</span> <span class="n">init_exec</span> <span class="o">*</span><span class="n">iexec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * INIT_PLL2   opcode: 0x4B (&#39;K&#39;)</span>
<span class="cm">	 *</span>
<span class="cm">	 * offset      (8  bit): opcode</span>
<span class="cm">	 * offset + 1  (32 bit): register</span>
<span class="cm">	 * offset + 5  (32 bit): freq</span>
<span class="cm">	 *</span>
<span class="cm">	 * Set PLL register &quot;register&quot; to coefficients for frequency &quot;freq&quot;</span>
<span class="cm">	 */</span>

	<span class="kt">uint32_t</span> <span class="n">reg</span> <span class="o">=</span> <span class="n">ROM32</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]);</span>
	<span class="kt">uint32_t</span> <span class="n">freq</span> <span class="o">=</span> <span class="n">ROM32</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">5</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iexec</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">9</span><span class="p">;</span>

	<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;0x%04X: Reg: 0x%04X, Freq: %dkHz</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">offset</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">freq</span><span class="p">);</span>

	<span class="n">setPLL</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">freq</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">9</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">init_i2c_byte</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">offset</span><span class="p">,</span> <span class="k">struct</span> <span class="n">init_exec</span> <span class="o">*</span><span class="n">iexec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * INIT_I2C_BYTE   opcode: 0x4C (&#39;L&#39;)</span>
<span class="cm">	 *</span>
<span class="cm">	 * offset      (8 bit): opcode</span>
<span class="cm">	 * offset + 1  (8 bit): DCB I2C table entry index</span>
<span class="cm">	 * offset + 2  (8 bit): I2C slave address</span>
<span class="cm">	 * offset + 3  (8 bit): count</span>
<span class="cm">	 * offset + 4  (8 bit): I2C register 1</span>
<span class="cm">	 * offset + 5  (8 bit): mask 1</span>
<span class="cm">	 * offset + 6  (8 bit): data 1</span>
<span class="cm">	 * ...</span>
<span class="cm">	 *</span>
<span class="cm">	 * For each of &quot;count&quot; registers given by &quot;I2C register n&quot; on the device</span>
<span class="cm">	 * addressed by &quot;I2C slave address&quot; on the I2C bus given by</span>
<span class="cm">	 * &quot;DCB I2C table entry index&quot;, read the register, AND the result with</span>
<span class="cm">	 * &quot;mask n&quot; and OR it with &quot;data n&quot; before writing it back to the device</span>
<span class="cm">	 */</span>

	<span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">i2c_index</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="kt">uint8_t</span> <span class="n">i2c_address</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">count</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">3</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">nouveau_i2c_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">+</span> <span class="n">count</span> <span class="o">*</span> <span class="mi">3</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iexec</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">len</span><span class="p">;</span>

	<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;0x%04X: DCBI2CIndex: 0x%02X, I2CAddress: 0x%02X, &quot;</span>
		      <span class="s">&quot;Count: 0x%02X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">offset</span><span class="p">,</span> <span class="n">i2c_index</span><span class="p">,</span> <span class="n">i2c_address</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>

	<span class="n">chan</span> <span class="o">=</span> <span class="n">init_i2c_device_find</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">i2c_index</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chan</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">NV_ERROR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;0x%04X: i2c bus not found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">uint8_t</span> <span class="n">reg</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">3</span><span class="p">];</span>
		<span class="kt">uint8_t</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">5</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">3</span><span class="p">];</span>
		<span class="kt">uint8_t</span> <span class="n">data</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">6</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">3</span><span class="p">];</span>
		<span class="k">union</span> <span class="n">i2c_smbus_data</span> <span class="n">val</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">i2c_smbus_xfer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">,</span> <span class="n">i2c_address</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				     <span class="n">I2C_SMBUS_READ</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span>
				     <span class="n">I2C_SMBUS_BYTE_DATA</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">NV_ERROR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;0x%04X: i2c rd fail: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;0x%04X: I2CReg: 0x%02X, Value: 0x%02X, &quot;</span>
			      <span class="s">&quot;Mask: 0x%02X, Data: 0x%02X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">offset</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">val</span><span class="p">.</span><span class="n">byte</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">val</span><span class="p">.</span><span class="n">byte</span> <span class="o">&amp;=</span> <span class="n">mask</span><span class="p">;</span>
		<span class="n">val</span><span class="p">.</span><span class="n">byte</span> <span class="o">|=</span> <span class="n">data</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">i2c_smbus_xfer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">,</span> <span class="n">i2c_address</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				     <span class="n">I2C_SMBUS_WRITE</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span>
				     <span class="n">I2C_SMBUS_BYTE_DATA</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">NV_ERROR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;0x%04X: i2c wr fail: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">init_zm_i2c_byte</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">offset</span><span class="p">,</span> <span class="k">struct</span> <span class="n">init_exec</span> <span class="o">*</span><span class="n">iexec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * INIT_ZM_I2C_BYTE   opcode: 0x4D (&#39;M&#39;)</span>
<span class="cm">	 *</span>
<span class="cm">	 * offset      (8 bit): opcode</span>
<span class="cm">	 * offset + 1  (8 bit): DCB I2C table entry index</span>
<span class="cm">	 * offset + 2  (8 bit): I2C slave address</span>
<span class="cm">	 * offset + 3  (8 bit): count</span>
<span class="cm">	 * offset + 4  (8 bit): I2C register 1</span>
<span class="cm">	 * offset + 5  (8 bit): data 1</span>
<span class="cm">	 * ...</span>
<span class="cm">	 *</span>
<span class="cm">	 * For each of &quot;count&quot; registers given by &quot;I2C register n&quot; on the device</span>
<span class="cm">	 * addressed by &quot;I2C slave address&quot; on the I2C bus given by</span>
<span class="cm">	 * &quot;DCB I2C table entry index&quot;, set the register to &quot;data n&quot;</span>
<span class="cm">	 */</span>

	<span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">i2c_index</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="kt">uint8_t</span> <span class="n">i2c_address</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">count</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">3</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">nouveau_i2c_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">+</span> <span class="n">count</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iexec</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">len</span><span class="p">;</span>

	<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;0x%04X: DCBI2CIndex: 0x%02X, I2CAddress: 0x%02X, &quot;</span>
		      <span class="s">&quot;Count: 0x%02X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">offset</span><span class="p">,</span> <span class="n">i2c_index</span><span class="p">,</span> <span class="n">i2c_address</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>

	<span class="n">chan</span> <span class="o">=</span> <span class="n">init_i2c_device_find</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">i2c_index</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chan</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">NV_ERROR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;0x%04X: i2c bus not found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">uint8_t</span> <span class="n">reg</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="p">];</span>
		<span class="k">union</span> <span class="n">i2c_smbus_data</span> <span class="n">val</span><span class="p">;</span>

		<span class="n">val</span><span class="p">.</span><span class="n">byte</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">5</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="p">];</span>

		<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;0x%04X: I2CReg: 0x%02X, Data: 0x%02X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">offset</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">val</span><span class="p">.</span><span class="n">byte</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">i2c_smbus_xfer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">,</span> <span class="n">i2c_address</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				     <span class="n">I2C_SMBUS_WRITE</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span>
				     <span class="n">I2C_SMBUS_BYTE_DATA</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">NV_ERROR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;0x%04X: i2c wr fail: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">init_zm_i2c</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">offset</span><span class="p">,</span> <span class="k">struct</span> <span class="n">init_exec</span> <span class="o">*</span><span class="n">iexec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * INIT_ZM_I2C   opcode: 0x4E (&#39;N&#39;)</span>
<span class="cm">	 *</span>
<span class="cm">	 * offset      (8 bit): opcode</span>
<span class="cm">	 * offset + 1  (8 bit): DCB I2C table entry index</span>
<span class="cm">	 * offset + 2  (8 bit): I2C slave address</span>
<span class="cm">	 * offset + 3  (8 bit): count</span>
<span class="cm">	 * offset + 4  (8 bit): data 1</span>
<span class="cm">	 * ...</span>
<span class="cm">	 *</span>
<span class="cm">	 * Send &quot;count&quot; bytes (&quot;data n&quot;) to the device addressed by &quot;I2C slave</span>
<span class="cm">	 * address&quot; on the I2C bus given by &quot;DCB I2C table entry index&quot;</span>
<span class="cm">	 */</span>

	<span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">i2c_index</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="kt">uint8_t</span> <span class="n">i2c_address</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">count</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">3</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">+</span> <span class="n">count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nouveau_i2c_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i2c_msg</span> <span class="n">msg</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">data</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iexec</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">len</span><span class="p">;</span>

	<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;0x%04X: DCBI2CIndex: 0x%02X, I2CAddress: 0x%02X, &quot;</span>
		      <span class="s">&quot;Count: 0x%02X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">offset</span><span class="p">,</span> <span class="n">i2c_index</span><span class="p">,</span> <span class="n">i2c_address</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>

	<span class="n">chan</span> <span class="o">=</span> <span class="n">init_i2c_device_find</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">i2c_index</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chan</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">NV_ERROR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;0x%04X: i2c bus not found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">+</span> <span class="n">i</span><span class="p">];</span>

		<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;0x%04X: Data: 0x%02X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">msg</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="n">i2c_address</span><span class="p">;</span>
		<span class="n">msg</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">msg</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
		<span class="n">msg</span><span class="p">.</span><span class="n">buf</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">i2c_transfer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">NV_ERROR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;0x%04X: i2c wr fail: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">init_tmds</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">offset</span><span class="p">,</span> <span class="k">struct</span> <span class="n">init_exec</span> <span class="o">*</span><span class="n">iexec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * INIT_TMDS   opcode: 0x4F (&#39;O&#39;)	(non-canon name)</span>
<span class="cm">	 *</span>
<span class="cm">	 * offset      (8 bit): opcode</span>
<span class="cm">	 * offset + 1  (8 bit): magic lookup value</span>
<span class="cm">	 * offset + 2  (8 bit): TMDS address</span>
<span class="cm">	 * offset + 3  (8 bit): mask</span>
<span class="cm">	 * offset + 4  (8 bit): data</span>
<span class="cm">	 *</span>
<span class="cm">	 * Read the data reg for TMDS address &quot;TMDS address&quot;, AND it with mask</span>
<span class="cm">	 * and OR it with data, then write it back</span>
<span class="cm">	 * &quot;magic lookup value&quot; determines which TMDS base address register is</span>
<span class="cm">	 * used -- see get_tmds_index_reg()</span>
<span class="cm">	 */</span>

	<span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">mlv</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="kt">uint32_t</span> <span class="n">tmdsaddr</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">2</span><span class="p">];</span>
	<span class="kt">uint8_t</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">3</span><span class="p">];</span>
	<span class="kt">uint8_t</span> <span class="n">data</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">4</span><span class="p">];</span>
	<span class="kt">uint32_t</span> <span class="n">reg</span><span class="p">,</span> <span class="n">value</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iexec</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">5</span><span class="p">;</span>

	<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;0x%04X: MagicLookupValue: 0x%02X, TMDSAddr: 0x%02X, &quot;</span>
		      <span class="s">&quot;Mask: 0x%02X, Data: 0x%02X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">offset</span><span class="p">,</span> <span class="n">mlv</span><span class="p">,</span> <span class="n">tmdsaddr</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

	<span class="n">reg</span> <span class="o">=</span> <span class="n">get_tmds_index_reg</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">mlv</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">reg</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">NV_ERROR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;0x%04X: no tmds_index_reg</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">5</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">bios_wr32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span>
		  <span class="n">tmdsaddr</span> <span class="o">|</span> <span class="n">NV_PRAMDAC_FP_TMDS_CONTROL_WRITE_DISABLE</span><span class="p">);</span>
	<span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="n">bios_rd32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">reg</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">|</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">bios_wr32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">reg</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
	<span class="n">bios_wr32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">tmdsaddr</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">5</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">init_zm_tmds_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">offset</span><span class="p">,</span>
		   <span class="k">struct</span> <span class="n">init_exec</span> <span class="o">*</span><span class="n">iexec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * INIT_ZM_TMDS_GROUP   opcode: 0x50 (&#39;P&#39;)	(non-canon name)</span>
<span class="cm">	 *</span>
<span class="cm">	 * offset      (8 bit): opcode</span>
<span class="cm">	 * offset + 1  (8 bit): magic lookup value</span>
<span class="cm">	 * offset + 2  (8 bit): count</span>
<span class="cm">	 * offset + 3  (8 bit): addr 1</span>
<span class="cm">	 * offset + 4  (8 bit): data 1</span>
<span class="cm">	 * ...</span>
<span class="cm">	 *</span>
<span class="cm">	 * For each of &quot;count&quot; TMDS address and data pairs write &quot;data n&quot; to</span>
<span class="cm">	 * &quot;addr n&quot;.  &quot;magic lookup value&quot; determines which TMDS base address</span>
<span class="cm">	 * register is used -- see get_tmds_index_reg()</span>
<span class="cm">	 */</span>

	<span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">mlv</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="kt">uint8_t</span> <span class="n">count</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">2</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">+</span> <span class="n">count</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">reg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iexec</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">len</span><span class="p">;</span>

	<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;0x%04X: MagicLookupValue: 0x%02X, Count: 0x%02X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">offset</span><span class="p">,</span> <span class="n">mlv</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>

	<span class="n">reg</span> <span class="o">=</span> <span class="n">get_tmds_index_reg</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">mlv</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">reg</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">NV_ERROR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;0x%04X: no tmds_index_reg</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">uint8_t</span> <span class="n">tmdsaddr</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="p">];</span>
		<span class="kt">uint8_t</span> <span class="n">tmdsdata</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="p">];</span>

		<span class="n">bios_wr32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">reg</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="n">tmdsdata</span><span class="p">);</span>
		<span class="n">bios_wr32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">tmdsaddr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">init_cr_idx_adr_latch</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">offset</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">init_exec</span> <span class="o">*</span><span class="n">iexec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * INIT_CR_INDEX_ADDRESS_LATCHED   opcode: 0x51 (&#39;Q&#39;)</span>
<span class="cm">	 *</span>
<span class="cm">	 * offset      (8 bit): opcode</span>
<span class="cm">	 * offset + 1  (8 bit): CRTC index1</span>
<span class="cm">	 * offset + 2  (8 bit): CRTC index2</span>
<span class="cm">	 * offset + 3  (8 bit): baseaddr</span>
<span class="cm">	 * offset + 4  (8 bit): count</span>
<span class="cm">	 * offset + 5  (8 bit): data 1</span>
<span class="cm">	 * ...</span>
<span class="cm">	 *</span>
<span class="cm">	 * For each of &quot;count&quot; address and data pairs, write &quot;baseaddr + n&quot; to</span>
<span class="cm">	 * &quot;CRTC index1&quot; and &quot;data n&quot; to &quot;CRTC index2&quot;</span>
<span class="cm">	 * Once complete, restore initial value read from &quot;CRTC index1&quot;</span>
<span class="cm">	 */</span>
	<span class="kt">uint8_t</span> <span class="n">crtcindex1</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="kt">uint8_t</span> <span class="n">crtcindex2</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">2</span><span class="p">];</span>
	<span class="kt">uint8_t</span> <span class="n">baseaddr</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">3</span><span class="p">];</span>
	<span class="kt">uint8_t</span> <span class="n">count</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">4</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">+</span> <span class="n">count</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">oldaddr</span><span class="p">,</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iexec</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">len</span><span class="p">;</span>

	<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;0x%04X: Index1: 0x%02X, Index2: 0x%02X, &quot;</span>
		      <span class="s">&quot;BaseAddr: 0x%02X, Count: 0x%02X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">offset</span><span class="p">,</span> <span class="n">crtcindex1</span><span class="p">,</span> <span class="n">crtcindex2</span><span class="p">,</span> <span class="n">baseaddr</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>

	<span class="n">oldaddr</span> <span class="o">=</span> <span class="n">bios_idxprt_rd</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">NV_CIO_CRX__COLOR</span><span class="p">,</span> <span class="n">crtcindex1</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bios_idxprt_wr</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">NV_CIO_CRX__COLOR</span><span class="p">,</span> <span class="n">crtcindex1</span><span class="p">,</span>
				     <span class="n">baseaddr</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">data</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">5</span> <span class="o">+</span> <span class="n">i</span><span class="p">];</span>
		<span class="n">bios_idxprt_wr</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">NV_CIO_CRX__COLOR</span><span class="p">,</span> <span class="n">crtcindex2</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">bios_idxprt_wr</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">NV_CIO_CRX__COLOR</span><span class="p">,</span> <span class="n">crtcindex1</span><span class="p">,</span> <span class="n">oldaddr</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">init_cr</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">offset</span><span class="p">,</span> <span class="k">struct</span> <span class="n">init_exec</span> <span class="o">*</span><span class="n">iexec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * INIT_CR   opcode: 0x52 (&#39;R&#39;)</span>
<span class="cm">	 *</span>
<span class="cm">	 * offset      (8  bit): opcode</span>
<span class="cm">	 * offset + 1  (8  bit): CRTC index</span>
<span class="cm">	 * offset + 2  (8  bit): mask</span>
<span class="cm">	 * offset + 3  (8  bit): data</span>
<span class="cm">	 *</span>
<span class="cm">	 * Assign the value of at &quot;CRTC index&quot; ANDed with mask and ORed with</span>
<span class="cm">	 * data back to &quot;CRTC index&quot;</span>
<span class="cm">	 */</span>

	<span class="kt">uint8_t</span> <span class="n">crtcindex</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="kt">uint8_t</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">2</span><span class="p">];</span>
	<span class="kt">uint8_t</span> <span class="n">data</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">3</span><span class="p">];</span>
	<span class="kt">uint8_t</span> <span class="n">value</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iexec</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">4</span><span class="p">;</span>

	<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;0x%04X: Index: 0x%02X, Mask: 0x%02X, Data: 0x%02X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">offset</span><span class="p">,</span> <span class="n">crtcindex</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

	<span class="n">value</span>  <span class="o">=</span> <span class="n">bios_idxprt_rd</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">NV_CIO_CRX__COLOR</span><span class="p">,</span> <span class="n">crtcindex</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">;</span>
	<span class="n">value</span> <span class="o">|=</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">bios_idxprt_wr</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">NV_CIO_CRX__COLOR</span><span class="p">,</span> <span class="n">crtcindex</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">4</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">init_zm_cr</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">offset</span><span class="p">,</span> <span class="k">struct</span> <span class="n">init_exec</span> <span class="o">*</span><span class="n">iexec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * INIT_ZM_CR   opcode: 0x53 (&#39;S&#39;)</span>
<span class="cm">	 *</span>
<span class="cm">	 * offset      (8 bit): opcode</span>
<span class="cm">	 * offset + 1  (8 bit): CRTC index</span>
<span class="cm">	 * offset + 2  (8 bit): value</span>
<span class="cm">	 *</span>
<span class="cm">	 * Assign &quot;value&quot; to CRTC register with index &quot;CRTC index&quot;.</span>
<span class="cm">	 */</span>

	<span class="kt">uint8_t</span> <span class="n">crtcindex</span> <span class="o">=</span> <span class="n">ROM32</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]);</span>
	<span class="kt">uint8_t</span> <span class="n">data</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">2</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iexec</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">3</span><span class="p">;</span>

	<span class="n">bios_idxprt_wr</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">NV_CIO_CRX__COLOR</span><span class="p">,</span> <span class="n">crtcindex</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">init_zm_cr_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">offset</span><span class="p">,</span> <span class="k">struct</span> <span class="n">init_exec</span> <span class="o">*</span><span class="n">iexec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * INIT_ZM_CR_GROUP   opcode: 0x54 (&#39;T&#39;)</span>
<span class="cm">	 *</span>
<span class="cm">	 * offset      (8 bit): opcode</span>
<span class="cm">	 * offset + 1  (8 bit): count</span>
<span class="cm">	 * offset + 2  (8 bit): CRTC index 1</span>
<span class="cm">	 * offset + 3  (8 bit): value 1</span>
<span class="cm">	 * ...</span>
<span class="cm">	 *</span>
<span class="cm">	 * For &quot;count&quot;, assign &quot;value n&quot; to CRTC register with index</span>
<span class="cm">	 * &quot;CRTC index n&quot;.</span>
<span class="cm">	 */</span>

	<span class="kt">uint8_t</span> <span class="n">count</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">count</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iexec</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">len</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">init_zm_cr</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">offset</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iexec</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">init_condition_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">offset</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">init_exec</span> <span class="o">*</span><span class="n">iexec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * INIT_CONDITION_TIME   opcode: 0x56 (&#39;V&#39;)</span>
<span class="cm">	 *</span>
<span class="cm">	 * offset      (8 bit): opcode</span>
<span class="cm">	 * offset + 1  (8 bit): condition number</span>
<span class="cm">	 * offset + 2  (8 bit): retries / 50</span>
<span class="cm">	 *</span>
<span class="cm">	 * Check condition &quot;condition number&quot; in the condition table.</span>
<span class="cm">	 * Bios code then sleeps for 2ms if the condition is not met, and</span>
<span class="cm">	 * repeats up to &quot;retries&quot; times, but on one C51 this has proved</span>
<span class="cm">	 * insufficient.  In mmiotraces the driver sleeps for 20ms, so we do</span>
<span class="cm">	 * this, and bail after &quot;retries&quot; times, or 2s, whichever is less.</span>
<span class="cm">	 * If still not met after retries, clear execution flag for this table.</span>
<span class="cm">	 */</span>

	<span class="kt">uint8_t</span> <span class="n">cond</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="kt">uint16_t</span> <span class="n">retries</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="mi">50</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">cnt</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iexec</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">3</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">retries</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">)</span>
		<span class="n">retries</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>

	<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;0x%04X: Condition: 0x%02X, Retries: 0x%02X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">offset</span><span class="p">,</span> <span class="n">cond</span><span class="p">,</span> <span class="n">retries</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">)</span> <span class="cm">/* avoid 2s delays when &quot;faking&quot; execution */</span>
		<span class="n">retries</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">cnt</span> <span class="o">&lt;</span> <span class="n">retries</span><span class="p">;</span> <span class="n">cnt</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bios_condition_met</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">cond</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;0x%04X: Condition met, continuing</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
								<span class="n">offset</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;0x%04X: &quot;</span>
				<span class="s">&quot;Condition not met, sleeping for 20ms</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
								<span class="n">offset</span><span class="p">);</span>
			<span class="n">mdelay</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bios_condition_met</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">cond</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">NV_WARN</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;0x%04X: Condition still not met after %dms, &quot;</span>
			<span class="s">&quot;skipping following opcodes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="mi">20</span> <span class="o">*</span> <span class="n">retries</span><span class="p">);</span>
		<span class="n">iexec</span><span class="o">-&gt;</span><span class="n">execute</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">init_ltime</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">offset</span><span class="p">,</span> <span class="k">struct</span> <span class="n">init_exec</span> <span class="o">*</span><span class="n">iexec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * INIT_LTIME   opcode: 0x57 (&#39;V&#39;)</span>
<span class="cm">	 *</span>
<span class="cm">	 * offset      (8  bit): opcode</span>
<span class="cm">	 * offset + 1  (16 bit): time</span>
<span class="cm">	 *</span>
<span class="cm">	 * Sleep for &quot;time&quot; milliseconds.</span>
<span class="cm">	 */</span>

	<span class="kt">unsigned</span> <span class="n">time</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iexec</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">3</span><span class="p">;</span>

	<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;0x%04X: Sleeping for 0x%04X milliseconds</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">offset</span><span class="p">,</span> <span class="n">time</span><span class="p">);</span>

	<span class="n">mdelay</span><span class="p">(</span><span class="n">time</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">init_zm_reg_sequence</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">offset</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">init_exec</span> <span class="o">*</span><span class="n">iexec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * INIT_ZM_REG_SEQUENCE   opcode: 0x58 (&#39;X&#39;)</span>
<span class="cm">	 *</span>
<span class="cm">	 * offset      (8  bit): opcode</span>
<span class="cm">	 * offset + 1  (32 bit): base register</span>
<span class="cm">	 * offset + 5  (8  bit): count</span>
<span class="cm">	 * offset + 6  (32 bit): value 1</span>
<span class="cm">	 * ...</span>
<span class="cm">	 *</span>
<span class="cm">	 * Starting at offset + 6 there are &quot;count&quot; 32 bit values.</span>
<span class="cm">	 * For &quot;count&quot; iterations set &quot;base register&quot; + 4 * current_iteration</span>
<span class="cm">	 * to &quot;value current_iteration&quot;</span>
<span class="cm">	 */</span>

	<span class="kt">uint32_t</span> <span class="n">basereg</span> <span class="o">=</span> <span class="n">ROM32</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]);</span>
	<span class="kt">uint32_t</span> <span class="n">count</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">5</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">6</span> <span class="o">+</span> <span class="n">count</span> <span class="o">*</span> <span class="mi">4</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iexec</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">len</span><span class="p">;</span>

	<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;0x%04X: BaseReg: 0x%08X, Count: 0x%02X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">offset</span><span class="p">,</span> <span class="n">basereg</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">uint32_t</span> <span class="n">reg</span> <span class="o">=</span> <span class="n">basereg</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">4</span><span class="p">;</span>
		<span class="kt">uint32_t</span> <span class="n">data</span> <span class="o">=</span> <span class="n">ROM32</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">6</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">4</span><span class="p">]);</span>

		<span class="n">bios_wr32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">init_sub_direct</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">offset</span><span class="p">,</span> <span class="k">struct</span> <span class="n">init_exec</span> <span class="o">*</span><span class="n">iexec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * INIT_SUB_DIRECT   opcode: 0x5B (&#39;[&#39;)</span>
<span class="cm">	 *</span>
<span class="cm">	 * offset      (8  bit): opcode</span>
<span class="cm">	 * offset + 1  (16 bit): subroutine offset (in bios)</span>
<span class="cm">	 *</span>
<span class="cm">	 * Calls a subroutine that will execute commands until INIT_DONE</span>
<span class="cm">	 * is found.</span>
<span class="cm">	 */</span>

	<span class="kt">uint16_t</span> <span class="n">sub_offset</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iexec</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">3</span><span class="p">;</span>

	<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;0x%04X: Executing subroutine at 0x%04X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">offset</span><span class="p">,</span> <span class="n">sub_offset</span><span class="p">);</span>

	<span class="n">parse_init_table</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">sub_offset</span><span class="p">,</span> <span class="n">iexec</span><span class="p">);</span>

	<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;0x%04X: End of 0x%04X subroutine</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">sub_offset</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">init_jump</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">offset</span><span class="p">,</span> <span class="k">struct</span> <span class="n">init_exec</span> <span class="o">*</span><span class="n">iexec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * INIT_JUMP   opcode: 0x5C (&#39;\&#39;)</span>
<span class="cm">	 *</span>
<span class="cm">	 * offset      (8  bit): opcode</span>
<span class="cm">	 * offset + 1  (16 bit): offset (in bios)</span>
<span class="cm">	 *</span>
<span class="cm">	 * Continue execution of init table from &#39;offset&#39;</span>
<span class="cm">	 */</span>

	<span class="kt">uint16_t</span> <span class="n">jmp_offset</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iexec</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">3</span><span class="p">;</span>

	<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;0x%04X: Jump to 0x%04X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">jmp_offset</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">jmp_offset</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">init_i2c_if</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">offset</span><span class="p">,</span> <span class="k">struct</span> <span class="n">init_exec</span> <span class="o">*</span><span class="n">iexec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * INIT_I2C_IF   opcode: 0x5E (&#39;^&#39;)</span>
<span class="cm">	 *</span>
<span class="cm">	 * offset      (8 bit): opcode</span>
<span class="cm">	 * offset + 1  (8 bit): DCB I2C table entry index</span>
<span class="cm">	 * offset + 2  (8 bit): I2C slave address</span>
<span class="cm">	 * offset + 3  (8 bit): I2C register</span>
<span class="cm">	 * offset + 4  (8 bit): mask</span>
<span class="cm">	 * offset + 5  (8 bit): data</span>
<span class="cm">	 *</span>
<span class="cm">	 * Read the register given by &quot;I2C register&quot; on the device addressed</span>
<span class="cm">	 * by &quot;I2C slave address&quot; on the I2C bus given by &quot;DCB I2C table</span>
<span class="cm">	 * entry index&quot;. Compare the result AND &quot;mask&quot; to &quot;data&quot;.</span>
<span class="cm">	 * If they&#39;re not equal, skip subsequent opcodes until condition is</span>
<span class="cm">	 * inverted (INIT_NOT), or we hit INIT_RESUME</span>
<span class="cm">	 */</span>

	<span class="kt">uint8_t</span> <span class="n">i2c_index</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="kt">uint8_t</span> <span class="n">i2c_address</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">reg</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">3</span><span class="p">];</span>
	<span class="kt">uint8_t</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">4</span><span class="p">];</span>
	<span class="kt">uint8_t</span> <span class="n">data</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">5</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">nouveau_i2c_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">i2c_smbus_data</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* no execute check by design */</span>

	<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;0x%04X: DCBI2CIndex: 0x%02X, I2CAddress: 0x%02X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">offset</span><span class="p">,</span> <span class="n">i2c_index</span><span class="p">,</span> <span class="n">i2c_address</span><span class="p">);</span>

	<span class="n">chan</span> <span class="o">=</span> <span class="n">init_i2c_device_find</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">i2c_index</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chan</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">i2c_smbus_xfer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">,</span> <span class="n">i2c_address</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			     <span class="n">I2C_SMBUS_READ</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span>
			     <span class="n">I2C_SMBUS_BYTE_DATA</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;0x%04X: I2CReg: 0x%02X, Value: [no device], &quot;</span>
			      <span class="s">&quot;Mask: 0x%02X, Data: 0x%02X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">offset</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
		<span class="n">iexec</span><span class="o">-&gt;</span><span class="n">execute</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">6</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;0x%04X: I2CReg: 0x%02X, Value: 0x%02X, &quot;</span>
		      <span class="s">&quot;Mask: 0x%02X, Data: 0x%02X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">offset</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">val</span><span class="p">.</span><span class="n">byte</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

	<span class="n">iexec</span><span class="o">-&gt;</span><span class="n">execute</span> <span class="o">=</span> <span class="p">((</span><span class="n">val</span><span class="p">.</span><span class="n">byte</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">==</span> <span class="n">data</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">6</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">init_copy_nv_reg</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">offset</span><span class="p">,</span> <span class="k">struct</span> <span class="n">init_exec</span> <span class="o">*</span><span class="n">iexec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * INIT_COPY_NV_REG   opcode: 0x5F (&#39;_&#39;)</span>
<span class="cm">	 *</span>
<span class="cm">	 * offset      (8  bit): opcode</span>
<span class="cm">	 * offset + 1  (32 bit): src reg</span>
<span class="cm">	 * offset + 5  (8  bit): shift</span>
<span class="cm">	 * offset + 6  (32 bit): src mask</span>
<span class="cm">	 * offset + 10 (32 bit): xor</span>
<span class="cm">	 * offset + 14 (32 bit): dst reg</span>
<span class="cm">	 * offset + 18 (32 bit): dst mask</span>
<span class="cm">	 *</span>
<span class="cm">	 * Shift REGVAL(&quot;src reg&quot;) right by (signed) &quot;shift&quot;, AND result with</span>
<span class="cm">	 * &quot;src mask&quot;, then XOR with &quot;xor&quot;. Write this OR&#39;d with</span>
<span class="cm">	 * (REGVAL(&quot;dst reg&quot;) AND&#39;d with &quot;dst mask&quot;) to &quot;dst reg&quot;</span>
<span class="cm">	 */</span>

	<span class="kt">uint32_t</span> <span class="n">srcreg</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]));</span>
	<span class="kt">uint8_t</span> <span class="n">shift</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">5</span><span class="p">];</span>
	<span class="kt">uint32_t</span> <span class="n">srcmask</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">6</span><span class="p">]));</span>
	<span class="kt">uint32_t</span> <span class="n">xor</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">10</span><span class="p">]));</span>
	<span class="kt">uint32_t</span> <span class="n">dstreg</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">14</span><span class="p">]));</span>
	<span class="kt">uint32_t</span> <span class="n">dstmask</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">18</span><span class="p">]));</span>
	<span class="kt">uint32_t</span> <span class="n">srcvalue</span><span class="p">,</span> <span class="n">dstvalue</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iexec</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">22</span><span class="p">;</span>

	<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;0x%04X: SrcReg: 0x%08X, Shift: 0x%02X, SrcMask: 0x%08X, &quot;</span>
		      <span class="s">&quot;Xor: 0x%08X, DstReg: 0x%08X, DstMask: 0x%08X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">offset</span><span class="p">,</span> <span class="n">srcreg</span><span class="p">,</span> <span class="n">shift</span><span class="p">,</span> <span class="n">srcmask</span><span class="p">,</span> <span class="n">xor</span><span class="p">,</span> <span class="n">dstreg</span><span class="p">,</span> <span class="n">dstmask</span><span class="p">);</span>

	<span class="n">srcvalue</span> <span class="o">=</span> <span class="n">bios_rd32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">srcreg</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">shift</span> <span class="o">&lt;</span> <span class="mh">0x80</span><span class="p">)</span>
		<span class="n">srcvalue</span> <span class="o">&gt;&gt;=</span> <span class="n">shift</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">srcvalue</span> <span class="o">&lt;&lt;=</span> <span class="p">(</span><span class="mh">0x100</span> <span class="o">-</span> <span class="n">shift</span><span class="p">);</span>

	<span class="n">srcvalue</span> <span class="o">=</span> <span class="p">(</span><span class="n">srcvalue</span> <span class="o">&amp;</span> <span class="n">srcmask</span><span class="p">)</span> <span class="o">^</span> <span class="n">xor</span><span class="p">;</span>

	<span class="n">dstvalue</span> <span class="o">=</span> <span class="n">bios_rd32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">dstreg</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">dstmask</span><span class="p">;</span>

	<span class="n">bios_wr32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">dstreg</span><span class="p">,</span> <span class="n">dstvalue</span> <span class="o">|</span> <span class="n">srcvalue</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">22</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">init_zm_index_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">offset</span><span class="p">,</span> <span class="k">struct</span> <span class="n">init_exec</span> <span class="o">*</span><span class="n">iexec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * INIT_ZM_INDEX_IO   opcode: 0x62 (&#39;b&#39;)</span>
<span class="cm">	 *</span>
<span class="cm">	 * offset      (8  bit): opcode</span>
<span class="cm">	 * offset + 1  (16 bit): CRTC port</span>
<span class="cm">	 * offset + 3  (8  bit): CRTC index</span>
<span class="cm">	 * offset + 4  (8  bit): data</span>
<span class="cm">	 *</span>
<span class="cm">	 * Write &quot;data&quot; to index &quot;CRTC index&quot; of &quot;CRTC port&quot;</span>
<span class="cm">	 */</span>
	<span class="kt">uint16_t</span> <span class="n">crtcport</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]);</span>
	<span class="kt">uint8_t</span> <span class="n">crtcindex</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">3</span><span class="p">];</span>
	<span class="kt">uint8_t</span> <span class="n">data</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">4</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iexec</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">5</span><span class="p">;</span>

	<span class="n">bios_idxprt_wr</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">crtcport</span><span class="p">,</span> <span class="n">crtcindex</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">5</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">bios_md32</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">reg</span><span class="p">,</span>
	  <span class="kt">uint32_t</span> <span class="n">mask</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bios_wr32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="p">(</span><span class="n">bios_rd32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">reg</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">mask</span><span class="p">)</span> <span class="o">|</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">uint32_t</span>
<span class="nf">peek_fb</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">io_mapping</span> <span class="o">*</span><span class="n">fb</span><span class="p">,</span>
	<span class="kt">uint32_t</span> <span class="n">off</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">off</span> <span class="o">&lt;</span> <span class="n">pci_resource_len</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">uint8_t</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span>
			<span class="n">io_mapping_map_atomic_wc</span><span class="p">(</span><span class="n">fb</span><span class="p">,</span> <span class="n">off</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">);</span>

		<span class="n">val</span> <span class="o">=</span> <span class="n">ioread32</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="p">(</span><span class="n">off</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">));</span>

		<span class="n">io_mapping_unmap_atomic</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">poke_fb</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">io_mapping</span> <span class="o">*</span><span class="n">fb</span><span class="p">,</span>
	<span class="kt">uint32_t</span> <span class="n">off</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">off</span> <span class="o">&lt;</span> <span class="n">pci_resource_len</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">uint8_t</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span>
			<span class="n">io_mapping_map_atomic_wc</span><span class="p">(</span><span class="n">fb</span><span class="p">,</span> <span class="n">off</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">);</span>

		<span class="n">iowrite32</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">p</span> <span class="o">+</span> <span class="p">(</span><span class="n">off</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">));</span>
		<span class="n">wmb</span><span class="p">();</span>

		<span class="n">io_mapping_unmap_atomic</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span>
<span class="nf">read_back_fb</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">io_mapping</span> <span class="o">*</span><span class="n">fb</span><span class="p">,</span>
	     <span class="kt">uint32_t</span> <span class="n">off</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">poke_fb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">fb</span><span class="p">,</span> <span class="n">off</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">val</span> <span class="o">==</span> <span class="n">peek_fb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">fb</span><span class="p">,</span> <span class="n">off</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">nv04_init_compute_mem</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">patt</span> <span class="o">=</span> <span class="mh">0xdeadbeef</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">io_mapping</span> <span class="o">*</span><span class="n">fb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Map the framebuffer aperture */</span>
	<span class="n">fb</span> <span class="o">=</span> <span class="n">io_mapping_create_wc</span><span class="p">(</span><span class="n">pci_resource_start</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
				  <span class="n">pci_resource_len</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fb</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* Sequencer and refresh off */</span>
	<span class="n">NVWriteVgaSeq</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">NVReadVgaSeq</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x20</span><span class="p">);</span>
	<span class="n">bios_md32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">NV04_PFB_DEBUG_0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">NV04_PFB_DEBUG_0_REFRESH_OFF</span><span class="p">);</span>

	<span class="n">bios_md32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">NV04_PFB_BOOT_0</span><span class="p">,</span> <span class="o">~</span><span class="mi">0</span><span class="p">,</span>
		  <span class="n">NV04_PFB_BOOT_0_RAM_AMOUNT_16MB</span> <span class="o">|</span>
		  <span class="n">NV04_PFB_BOOT_0_RAM_WIDTH_128</span> <span class="o">|</span>
		  <span class="n">NV04_PFB_BOOT_0_RAM_TYPE_SGRAM_16MBIT</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">poke_fb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">fb</span><span class="p">,</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">i</span><span class="p">,</span> <span class="n">patt</span><span class="p">);</span>

	<span class="n">poke_fb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">fb</span><span class="p">,</span> <span class="mh">0x400000</span><span class="p">,</span> <span class="n">patt</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">peek_fb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">fb</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="n">patt</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bios_md32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">NV04_PFB_BOOT_0</span><span class="p">,</span> <span class="n">NV04_PFB_BOOT_0_RAM_TYPE</span><span class="p">,</span>
			  <span class="n">NV04_PFB_BOOT_0_RAM_TYPE_SDRAM_16MBIT</span><span class="p">);</span>
		<span class="n">bios_md32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">NV04_PFB_DEBUG_0</span><span class="p">,</span>
			  <span class="n">NV04_PFB_DEBUG_0_REFRESH_OFF</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">poke_fb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">fb</span><span class="p">,</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">i</span><span class="p">,</span> <span class="n">patt</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">peek_fb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">fb</span><span class="p">,</span> <span class="mh">0xc</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="n">patt</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">))</span>
			<span class="n">bios_md32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">NV04_PFB_BOOT_0</span><span class="p">,</span>
				  <span class="n">NV04_PFB_BOOT_0_RAM_WIDTH_128</span> <span class="o">|</span>
				  <span class="n">NV04_PFB_BOOT_0_RAM_AMOUNT</span><span class="p">,</span>
				  <span class="n">NV04_PFB_BOOT_0_RAM_AMOUNT_8MB</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">peek_fb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">fb</span><span class="p">,</span> <span class="mh">0xc</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffff0000</span><span class="p">)</span> <span class="o">!=</span>
		   <span class="p">(</span><span class="n">patt</span> <span class="o">&amp;</span> <span class="mh">0xffff0000</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">bios_md32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">NV04_PFB_BOOT_0</span><span class="p">,</span>
			  <span class="n">NV04_PFB_BOOT_0_RAM_WIDTH_128</span> <span class="o">|</span>
			  <span class="n">NV04_PFB_BOOT_0_RAM_AMOUNT</span><span class="p">,</span>
			  <span class="n">NV04_PFB_BOOT_0_RAM_AMOUNT_4MB</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">peek_fb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">fb</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">!=</span> <span class="n">patt</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">read_back_fb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">fb</span><span class="p">,</span> <span class="mh">0x800000</span><span class="p">,</span> <span class="n">patt</span><span class="p">))</span>
			<span class="n">bios_md32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">NV04_PFB_BOOT_0</span><span class="p">,</span>
				  <span class="n">NV04_PFB_BOOT_0_RAM_AMOUNT</span><span class="p">,</span>
				  <span class="n">NV04_PFB_BOOT_0_RAM_AMOUNT_8MB</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">bios_md32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">NV04_PFB_BOOT_0</span><span class="p">,</span>
				  <span class="n">NV04_PFB_BOOT_0_RAM_AMOUNT</span><span class="p">,</span>
				  <span class="n">NV04_PFB_BOOT_0_RAM_AMOUNT_4MB</span><span class="p">);</span>

		<span class="n">bios_md32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">NV04_PFB_BOOT_0</span><span class="p">,</span> <span class="n">NV04_PFB_BOOT_0_RAM_TYPE</span><span class="p">,</span>
			  <span class="n">NV04_PFB_BOOT_0_RAM_TYPE_SGRAM_8MBIT</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">read_back_fb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">fb</span><span class="p">,</span> <span class="mh">0x800000</span><span class="p">,</span> <span class="n">patt</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">bios_md32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">NV04_PFB_BOOT_0</span><span class="p">,</span> <span class="n">NV04_PFB_BOOT_0_RAM_AMOUNT</span><span class="p">,</span>
			  <span class="n">NV04_PFB_BOOT_0_RAM_AMOUNT_8MB</span><span class="p">);</span>

	<span class="p">}</span>

	<span class="cm">/* Refresh on, sequencer on */</span>
	<span class="n">bios_md32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">NV04_PFB_DEBUG_0</span><span class="p">,</span> <span class="n">NV04_PFB_DEBUG_0_REFRESH_OFF</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">NVWriteVgaSeq</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">NVReadVgaSeq</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x20</span><span class="p">);</span>

	<span class="n">io_mapping_free</span><span class="p">(</span><span class="n">fb</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span>
<span class="nf">nv05_memory_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Defaults for BIOSes lacking a memory config table */</span>
	<span class="k">static</span> <span class="k">const</span> <span class="kt">uint8_t</span> <span class="n">default_config_tab</span><span class="p">[][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">{</span> <span class="mh">0x24</span><span class="p">,</span> <span class="mh">0x00</span> <span class="p">},</span>
		<span class="p">{</span> <span class="mh">0x28</span><span class="p">,</span> <span class="mh">0x00</span> <span class="p">},</span>
		<span class="p">{</span> <span class="mh">0x24</span><span class="p">,</span> <span class="mh">0x01</span> <span class="p">},</span>
		<span class="p">{</span> <span class="mh">0x1f</span><span class="p">,</span> <span class="mh">0x00</span> <span class="p">},</span>
		<span class="p">{</span> <span class="mh">0x0f</span><span class="p">,</span> <span class="mh">0x00</span> <span class="p">},</span>
		<span class="p">{</span> <span class="mh">0x17</span><span class="p">,</span> <span class="mh">0x00</span> <span class="p">},</span>
		<span class="p">{</span> <span class="mh">0x06</span><span class="p">,</span> <span class="mh">0x00</span> <span class="p">},</span>
		<span class="p">{</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span> <span class="p">}</span>
	<span class="p">};</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">bios_rd32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">NV_PEXTDEV_BOOT_0</span><span class="p">)</span> <span class="o">&amp;</span>
		 <span class="n">NV_PEXTDEV_BOOT_0_RAMCFG</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">legacy</span><span class="p">.</span><span class="n">mem_init_tbl_ptr</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">&amp;</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">legacy</span><span class="p">.</span><span class="n">mem_init_tbl_ptr</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">];</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">default_config_tab</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">nv05_init_compute_mem</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">ramcfg</span> <span class="o">=</span> <span class="n">nv05_memory_config</span><span class="p">(</span><span class="n">bios</span><span class="p">);</span>
	<span class="kt">uint32_t</span> <span class="n">patt</span> <span class="o">=</span> <span class="mh">0xdeadbeef</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">io_mapping</span> <span class="o">*</span><span class="n">fb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">;</span>

	<span class="cm">/* Map the framebuffer aperture */</span>
	<span class="n">fb</span> <span class="o">=</span> <span class="n">io_mapping_create_wc</span><span class="p">(</span><span class="n">pci_resource_start</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
				  <span class="n">pci_resource_len</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fb</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* Sequencer off */</span>
	<span class="n">NVWriteVgaSeq</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">NVReadVgaSeq</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x20</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bios_rd32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">NV04_PFB_BOOT_0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">NV04_PFB_BOOT_0_UMA_ENABLE</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">bios_md32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">NV04_PFB_DEBUG_0</span><span class="p">,</span> <span class="n">NV04_PFB_DEBUG_0_REFRESH_OFF</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* If present load the hardcoded scrambling table */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">legacy</span><span class="p">.</span><span class="n">mem_init_tbl_ptr</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">uint32_t</span> <span class="o">*</span><span class="n">scramble_tab</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span>
			<span class="n">bios</span><span class="o">-&gt;</span><span class="n">legacy</span><span class="p">.</span><span class="n">mem_init_tbl_ptr</span> <span class="o">+</span> <span class="mh">0x10</span><span class="p">];</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">bios_wr32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">NV04_PFB_SCRAMBLE</span><span class="p">(</span><span class="n">i</span><span class="p">),</span>
				  <span class="n">ROM32</span><span class="p">(</span><span class="n">scramble_tab</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
	<span class="p">}</span>

	<span class="cm">/* Set memory type/width/length defaults depending on the straps */</span>
	<span class="n">bios_md32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">NV04_PFB_BOOT_0</span><span class="p">,</span> <span class="mh">0x3f</span><span class="p">,</span> <span class="n">ramcfg</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ramcfg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">)</span>
		<span class="n">bios_md32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">NV04_PFB_CFG0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">NV04_PFB_CFG0_SCRAMBLE</span><span class="p">);</span>

	<span class="n">bios_md32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">NV04_PFB_CFG1</span><span class="p">,</span> <span class="mh">0x700001</span><span class="p">,</span> <span class="p">(</span><span class="n">ramcfg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">);</span>
	<span class="n">bios_md32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">NV04_PFB_CFG1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* Probe memory bus width */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">poke_fb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">fb</span><span class="p">,</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">i</span><span class="p">,</span> <span class="n">patt</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">peek_fb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">fb</span><span class="p">,</span> <span class="mh">0xc</span><span class="p">)</span> <span class="o">!=</span> <span class="n">patt</span><span class="p">)</span>
		<span class="n">bios_md32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">NV04_PFB_BOOT_0</span><span class="p">,</span>
			  <span class="n">NV04_PFB_BOOT_0_RAM_WIDTH_128</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Probe memory length */</span>
	<span class="n">v</span> <span class="o">=</span> <span class="n">bios_rd32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">NV04_PFB_BOOT_0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">NV04_PFB_BOOT_0_RAM_AMOUNT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="n">NV04_PFB_BOOT_0_RAM_AMOUNT_32MB</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="o">!</span><span class="n">read_back_fb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">fb</span><span class="p">,</span> <span class="mh">0x1000000</span><span class="p">,</span> <span class="o">++</span><span class="n">patt</span><span class="p">)</span> <span class="o">||</span>
	     <span class="o">!</span><span class="n">read_back_fb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">fb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">++</span><span class="n">patt</span><span class="p">)))</span>
		<span class="n">bios_md32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">NV04_PFB_BOOT_0</span><span class="p">,</span> <span class="n">NV04_PFB_BOOT_0_RAM_AMOUNT</span><span class="p">,</span>
			  <span class="n">NV04_PFB_BOOT_0_RAM_AMOUNT_16MB</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="n">NV04_PFB_BOOT_0_RAM_AMOUNT_16MB</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">read_back_fb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">fb</span><span class="p">,</span> <span class="mh">0x800000</span><span class="p">,</span> <span class="o">++</span><span class="n">patt</span><span class="p">))</span>
		<span class="n">bios_md32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">NV04_PFB_BOOT_0</span><span class="p">,</span> <span class="n">NV04_PFB_BOOT_0_RAM_AMOUNT</span><span class="p">,</span>
			  <span class="n">NV04_PFB_BOOT_0_RAM_AMOUNT_8MB</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">read_back_fb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">fb</span><span class="p">,</span> <span class="mh">0x400000</span><span class="p">,</span> <span class="o">++</span><span class="n">patt</span><span class="p">))</span>
		<span class="n">bios_md32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">NV04_PFB_BOOT_0</span><span class="p">,</span> <span class="n">NV04_PFB_BOOT_0_RAM_AMOUNT</span><span class="p">,</span>
			  <span class="n">NV04_PFB_BOOT_0_RAM_AMOUNT_4MB</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="cm">/* Sequencer on */</span>
	<span class="n">NVWriteVgaSeq</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">NVReadVgaSeq</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x20</span><span class="p">);</span>

	<span class="n">io_mapping_free</span><span class="p">(</span><span class="n">fb</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">nv10_init_compute_mem</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_nouveau_private</span> <span class="o">*</span><span class="n">dev_priv</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_private</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">mem_width</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0x10</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x20</span> <span class="p">};</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">mem_width_count</span> <span class="o">=</span> <span class="p">(</span><span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">chipset</span> <span class="o">&gt;=</span> <span class="mh">0x17</span> <span class="o">?</span> <span class="mi">3</span> <span class="o">:</span> <span class="mi">2</span><span class="p">);</span>
	<span class="kt">uint32_t</span> <span class="n">patt</span> <span class="o">=</span> <span class="mh">0xdeadbeef</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">io_mapping</span> <span class="o">*</span><span class="n">fb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">;</span>

	<span class="cm">/* Map the framebuffer aperture */</span>
	<span class="n">fb</span> <span class="o">=</span> <span class="n">io_mapping_create_wc</span><span class="p">(</span><span class="n">pci_resource_start</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
				  <span class="n">pci_resource_len</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fb</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">bios_wr32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">NV10_PFB_REFCTRL</span><span class="p">,</span> <span class="n">NV10_PFB_REFCTRL_VALID_1</span><span class="p">);</span>

	<span class="cm">/* Probe memory bus width */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mem_width_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bios_md32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">NV04_PFB_CFG0</span><span class="p">,</span> <span class="mh">0x30</span><span class="p">,</span> <span class="n">mem_width</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>
				<span class="n">poke_fb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">fb</span><span class="p">,</span> <span class="mh">0x1c</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

			<span class="n">poke_fb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">fb</span><span class="p">,</span> <span class="mh">0x1c</span><span class="p">,</span> <span class="n">patt</span><span class="p">);</span>
			<span class="n">poke_fb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">fb</span><span class="p">,</span> <span class="mh">0x3c</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">peek_fb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">fb</span><span class="p">,</span> <span class="mh">0x1c</span><span class="p">)</span> <span class="o">==</span> <span class="n">patt</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">mem_width_found</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">mem_width_found:</span>
	<span class="n">patt</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Probe amount of installed memory */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">off</span> <span class="o">=</span> <span class="n">bios_rd32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">NV04_PFB_FIFO_DATA</span><span class="p">)</span> <span class="o">-</span> <span class="mh">0x100000</span><span class="p">;</span>

		<span class="n">poke_fb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">fb</span><span class="p">,</span> <span class="n">off</span><span class="p">,</span> <span class="n">patt</span><span class="p">);</span>
		<span class="n">poke_fb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">fb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="n">peek_fb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">fb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">peek_fb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">fb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">peek_fb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">fb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">peek_fb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">fb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">peek_fb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">fb</span><span class="p">,</span> <span class="n">off</span><span class="p">)</span> <span class="o">==</span> <span class="n">patt</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">amount_found</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* IC missing - disable the upper half memory space. */</span>
	<span class="n">bios_md32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">NV04_PFB_CFG0</span><span class="p">,</span> <span class="mh">0x1000</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="nl">amount_found:</span>
	<span class="n">io_mapping_free</span><span class="p">(</span><span class="n">fb</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">nv20_init_compute_mem</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_nouveau_private</span> <span class="o">*</span><span class="n">dev_priv</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_private</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">chipset</span> <span class="o">&gt;=</span> <span class="mh">0x25</span> <span class="o">?</span> <span class="mh">0x300</span> <span class="o">:</span> <span class="mh">0x900</span><span class="p">);</span>
	<span class="kt">uint32_t</span> <span class="n">amount</span><span class="p">,</span> <span class="n">off</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">io_mapping</span> <span class="o">*</span><span class="n">fb</span><span class="p">;</span>

	<span class="cm">/* Map the framebuffer aperture */</span>
	<span class="n">fb</span> <span class="o">=</span> <span class="n">io_mapping_create_wc</span><span class="p">(</span><span class="n">pci_resource_start</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
				  <span class="n">pci_resource_len</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fb</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">bios_wr32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">NV10_PFB_REFCTRL</span><span class="p">,</span> <span class="n">NV10_PFB_REFCTRL_VALID_1</span><span class="p">);</span>

	<span class="cm">/* Allow full addressing */</span>
	<span class="n">bios_md32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">NV04_PFB_CFG0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>

	<span class="n">amount</span> <span class="o">=</span> <span class="n">bios_rd32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">NV04_PFB_FIFO_DATA</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">off</span> <span class="o">=</span> <span class="n">amount</span><span class="p">;</span> <span class="n">off</span> <span class="o">&gt;</span> <span class="mh">0x2000000</span><span class="p">;</span> <span class="n">off</span> <span class="o">-=</span> <span class="mh">0x2000000</span><span class="p">)</span>
		<span class="n">poke_fb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">fb</span><span class="p">,</span> <span class="n">off</span> <span class="o">-</span> <span class="mi">4</span><span class="p">,</span> <span class="n">off</span><span class="p">);</span>

	<span class="n">amount</span> <span class="o">=</span> <span class="n">bios_rd32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">NV04_PFB_FIFO_DATA</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">amount</span> <span class="o">!=</span> <span class="n">peek_fb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">fb</span><span class="p">,</span> <span class="n">amount</span> <span class="o">-</span> <span class="mi">4</span><span class="p">))</span>
		<span class="cm">/* IC missing - disable the upper half memory space. */</span>
		<span class="n">bios_md32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">NV04_PFB_CFG0</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">io_mapping_free</span><span class="p">(</span><span class="n">fb</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">init_compute_mem</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">offset</span><span class="p">,</span> <span class="k">struct</span> <span class="n">init_exec</span> <span class="o">*</span><span class="n">iexec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * INIT_COMPUTE_MEM   opcode: 0x63 (&#39;c&#39;)</span>
<span class="cm">	 *</span>
<span class="cm">	 * offset      (8 bit): opcode</span>
<span class="cm">	 *</span>
<span class="cm">	 * This opcode is meant to set the PFB memory config registers</span>
<span class="cm">	 * appropriately so that we can correctly calculate how much VRAM it</span>
<span class="cm">	 * has (on nv10 and better chipsets the amount of installed VRAM is</span>
<span class="cm">	 * subsequently reported in NV_PFB_CSTATUS (0x10020C)).</span>
<span class="cm">	 *</span>
<span class="cm">	 * The implementation of this opcode in general consists of several</span>
<span class="cm">	 * parts:</span>
<span class="cm">	 *</span>
<span class="cm">	 * 1) Determination of memory type and density. Only necessary for</span>
<span class="cm">	 *    really old chipsets, the memory type reported by the strap bits</span>
<span class="cm">	 *    (0x101000) is assumed to be accurate on nv05 and newer.</span>
<span class="cm">	 *</span>
<span class="cm">	 * 2) Determination of the memory bus width. Usually done by a cunning</span>
<span class="cm">	 *    combination of writes to offsets 0x1c and 0x3c in the fb, and</span>
<span class="cm">	 *    seeing whether the written values are read back correctly.</span>
<span class="cm">	 *</span>
<span class="cm">	 *    Only necessary on nv0x-nv1x and nv34, on the other cards we can</span>
<span class="cm">	 *    trust the straps.</span>
<span class="cm">	 *</span>
<span class="cm">	 * 3) Determination of how many of the card&#39;s RAM pads have ICs</span>
<span class="cm">	 *    attached, usually done by a cunning combination of writes to an</span>
<span class="cm">	 *    offset slightly less than the maximum memory reported by</span>
<span class="cm">	 *    NV_PFB_CSTATUS, then seeing if the test pattern can be read back.</span>
<span class="cm">	 *</span>
<span class="cm">	 * This appears to be a NOP on IGPs and NV4x or newer chipsets, both io</span>
<span class="cm">	 * logs of the VBIOS and kmmio traces of the binary driver POSTing the</span>
<span class="cm">	 * card show nothing being done for this opcode. Why is it still listed</span>
<span class="cm">	 * in the table?!</span>
<span class="cm">	 */</span>

	<span class="cm">/* no iexec-&gt;execute check by design */</span>

	<span class="k">struct</span> <span class="n">drm_nouveau_private</span> <span class="o">*</span><span class="n">dev_priv</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_private</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">chipset</span> <span class="o">&gt;=</span> <span class="mh">0x40</span> <span class="o">||</span>
	    <span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">chipset</span> <span class="o">==</span> <span class="mh">0x1a</span> <span class="o">||</span>
	    <span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">chipset</span> <span class="o">==</span> <span class="mh">0x1f</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">chipset</span> <span class="o">&gt;=</span> <span class="mh">0x20</span> <span class="o">&amp;&amp;</span>
		 <span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">chipset</span> <span class="o">!=</span> <span class="mh">0x34</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">nv20_init_compute_mem</span><span class="p">(</span><span class="n">bios</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">chipset</span> <span class="o">&gt;=</span> <span class="mh">0x10</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">nv10_init_compute_mem</span><span class="p">(</span><span class="n">bios</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">chipset</span> <span class="o">&gt;=</span> <span class="mh">0x5</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">nv05_init_compute_mem</span><span class="p">(</span><span class="n">bios</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">nv04_init_compute_mem</span><span class="p">(</span><span class="n">bios</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">init_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">offset</span><span class="p">,</span> <span class="k">struct</span> <span class="n">init_exec</span> <span class="o">*</span><span class="n">iexec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * INIT_RESET   opcode: 0x65 (&#39;e&#39;)</span>
<span class="cm">	 *</span>
<span class="cm">	 * offset      (8  bit): opcode</span>
<span class="cm">	 * offset + 1  (32 bit): register</span>
<span class="cm">	 * offset + 5  (32 bit): value1</span>
<span class="cm">	 * offset + 9  (32 bit): value2</span>
<span class="cm">	 *</span>
<span class="cm">	 * Assign &quot;value1&quot; to &quot;register&quot;, then assign &quot;value2&quot; to &quot;register&quot;</span>
<span class="cm">	 */</span>

	<span class="kt">uint32_t</span> <span class="n">reg</span> <span class="o">=</span> <span class="n">ROM32</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]);</span>
	<span class="kt">uint32_t</span> <span class="n">value1</span> <span class="o">=</span> <span class="n">ROM32</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">5</span><span class="p">]);</span>
	<span class="kt">uint32_t</span> <span class="n">value2</span> <span class="o">=</span> <span class="n">ROM32</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">9</span><span class="p">]);</span>
	<span class="kt">uint32_t</span> <span class="n">pci_nv_19</span><span class="p">,</span> <span class="n">pci_nv_20</span><span class="p">;</span>

	<span class="cm">/* no iexec-&gt;execute check by design */</span>

	<span class="n">pci_nv_19</span> <span class="o">=</span> <span class="n">bios_rd32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">NV_PBUS_PCI_NV_19</span><span class="p">);</span>
	<span class="n">bios_wr32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">NV_PBUS_PCI_NV_19</span><span class="p">,</span> <span class="n">pci_nv_19</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0xf00</span><span class="p">);</span>

	<span class="n">bios_wr32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">value1</span><span class="p">);</span>

	<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

	<span class="n">bios_wr32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">value2</span><span class="p">);</span>
	<span class="n">bios_wr32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">NV_PBUS_PCI_NV_19</span><span class="p">,</span> <span class="n">pci_nv_19</span><span class="p">);</span>

	<span class="n">pci_nv_20</span> <span class="o">=</span> <span class="n">bios_rd32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">NV_PBUS_PCI_NV_20</span><span class="p">);</span>
	<span class="n">pci_nv_20</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NV_PBUS_PCI_NV_20_ROM_SHADOW_ENABLED</span><span class="p">;</span>	<span class="cm">/* 0xfffffffe */</span>
	<span class="n">bios_wr32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">NV_PBUS_PCI_NV_20</span><span class="p">,</span> <span class="n">pci_nv_20</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">13</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">init_configure_mem</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">offset</span><span class="p">,</span>
		   <span class="k">struct</span> <span class="n">init_exec</span> <span class="o">*</span><span class="n">iexec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * INIT_CONFIGURE_MEM   opcode: 0x66 (&#39;f&#39;)</span>
<span class="cm">	 *</span>
<span class="cm">	 * offset      (8 bit): opcode</span>
<span class="cm">	 *</span>
<span class="cm">	 * Equivalent to INIT_DONE on bios version 3 or greater.</span>
<span class="cm">	 * For early bios versions, sets up the memory registers, using values</span>
<span class="cm">	 * taken from the memory init table</span>
<span class="cm">	 */</span>

	<span class="cm">/* no iexec-&gt;execute check by design */</span>

	<span class="kt">uint16_t</span> <span class="n">meminitoffs</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">legacy</span><span class="p">.</span><span class="n">mem_init_tbl_ptr</span> <span class="o">+</span> <span class="n">MEM_INIT_SIZE</span> <span class="o">*</span> <span class="p">(</span><span class="n">bios_idxprt_rd</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">NV_CIO_CRX__COLOR</span><span class="p">,</span> <span class="n">NV_CIO_CRE_SCRATCH4__INDEX</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">);</span>
	<span class="kt">uint16_t</span> <span class="n">seqtbloffs</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">legacy</span><span class="p">.</span><span class="n">sdr_seq_tbl_ptr</span><span class="p">,</span> <span class="n">meminitdata</span> <span class="o">=</span> <span class="n">meminitoffs</span> <span class="o">+</span> <span class="mi">6</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">reg</span><span class="p">,</span> <span class="n">data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">major_version</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">bios_idxprt_wr</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">NV_VIO_SRX</span><span class="p">,</span> <span class="n">NV_VIO_SR_CLOCK_INDEX</span><span class="p">,</span> <span class="n">bios_idxprt_rd</span><span class="p">(</span>
		       <span class="n">bios</span><span class="p">,</span> <span class="n">NV_VIO_SRX</span><span class="p">,</span> <span class="n">NV_VIO_SR_CLOCK_INDEX</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x20</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">meminitoffs</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">seqtbloffs</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">legacy</span><span class="p">.</span><span class="n">ddr_seq_tbl_ptr</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">reg</span> <span class="o">=</span> <span class="n">ROM32</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">seqtbloffs</span><span class="p">]);</span>
	     <span class="n">reg</span> <span class="o">!=</span> <span class="mh">0xffffffff</span><span class="p">;</span>
	     <span class="n">reg</span> <span class="o">=</span> <span class="n">ROM32</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">seqtbloffs</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">]))</span> <span class="p">{</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">NV04_PFB_PRE</span>:
			<span class="n">data</span> <span class="o">=</span> <span class="n">NV04_PFB_PRE_CMD_PRECHARGE</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">NV04_PFB_PAD</span>:
			<span class="n">data</span> <span class="o">=</span> <span class="n">NV04_PFB_PAD_CKE_NORMAL</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">NV04_PFB_REF</span>:
			<span class="n">data</span> <span class="o">=</span> <span class="n">NV04_PFB_REF_CMD_REFRESH</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">data</span> <span class="o">=</span> <span class="n">ROM32</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">meminitdata</span><span class="p">]);</span>
			<span class="n">meminitdata</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">==</span> <span class="mh">0xffffffff</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">bios_wr32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">init_configure_clk</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">offset</span><span class="p">,</span>
		   <span class="k">struct</span> <span class="n">init_exec</span> <span class="o">*</span><span class="n">iexec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * INIT_CONFIGURE_CLK   opcode: 0x67 (&#39;g&#39;)</span>
<span class="cm">	 *</span>
<span class="cm">	 * offset      (8 bit): opcode</span>
<span class="cm">	 *</span>
<span class="cm">	 * Equivalent to INIT_DONE on bios version 3 or greater.</span>
<span class="cm">	 * For early bios versions, sets up the NVClk and MClk PLLs, using</span>
<span class="cm">	 * values taken from the memory init table</span>
<span class="cm">	 */</span>

	<span class="cm">/* no iexec-&gt;execute check by design */</span>

	<span class="kt">uint16_t</span> <span class="n">meminitoffs</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">legacy</span><span class="p">.</span><span class="n">mem_init_tbl_ptr</span> <span class="o">+</span> <span class="n">MEM_INIT_SIZE</span> <span class="o">*</span> <span class="p">(</span><span class="n">bios_idxprt_rd</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">NV_CIO_CRX__COLOR</span><span class="p">,</span> <span class="n">NV_CIO_CRE_SCRATCH4__INDEX</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">clock</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">major_version</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">clock</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">meminitoffs</span> <span class="o">+</span> <span class="mi">4</span><span class="p">])</span> <span class="o">*</span> <span class="mi">10</span><span class="p">;</span>
	<span class="n">setPLL</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">NV_PRAMDAC_NVPLL_COEFF</span><span class="p">,</span> <span class="n">clock</span><span class="p">);</span>

	<span class="n">clock</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">meminitoffs</span> <span class="o">+</span> <span class="mi">2</span><span class="p">])</span> <span class="o">*</span> <span class="mi">10</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">meminitoffs</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="cm">/* DDR */</span>
		<span class="n">clock</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">setPLL</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">NV_PRAMDAC_MPLL_COEFF</span><span class="p">,</span> <span class="n">clock</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">init_configure_preinit</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">offset</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">init_exec</span> <span class="o">*</span><span class="n">iexec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * INIT_CONFIGURE_PREINIT   opcode: 0x68 (&#39;h&#39;)</span>
<span class="cm">	 *</span>
<span class="cm">	 * offset      (8 bit): opcode</span>
<span class="cm">	 *</span>
<span class="cm">	 * Equivalent to INIT_DONE on bios version 3 or greater.</span>
<span class="cm">	 * For early bios versions, does early init, loading ram and crystal</span>
<span class="cm">	 * configuration from straps into CR3C</span>
<span class="cm">	 */</span>

	<span class="cm">/* no iexec-&gt;execute check by design */</span>

	<span class="kt">uint32_t</span> <span class="n">straps</span> <span class="o">=</span> <span class="n">bios_rd32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">NV_PEXTDEV_BOOT_0</span><span class="p">);</span>
	<span class="kt">uint8_t</span> <span class="n">cr3c</span> <span class="o">=</span> <span class="p">((</span><span class="n">straps</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">straps</span> <span class="o">&amp;</span> <span class="mh">0x40</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">6</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">major_version</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">bios_idxprt_wr</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">NV_CIO_CRX__COLOR</span><span class="p">,</span>
			     <span class="n">NV_CIO_CRE_SCRATCH4__INDEX</span><span class="p">,</span> <span class="n">cr3c</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">init_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">offset</span><span class="p">,</span> <span class="k">struct</span> <span class="n">init_exec</span> <span class="o">*</span><span class="n">iexec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * INIT_IO   opcode: 0x69 (&#39;i&#39;)</span>
<span class="cm">	 *</span>
<span class="cm">	 * offset      (8  bit): opcode</span>
<span class="cm">	 * offset + 1  (16 bit): CRTC port</span>
<span class="cm">	 * offset + 3  (8  bit): mask</span>
<span class="cm">	 * offset + 4  (8  bit): data</span>
<span class="cm">	 *</span>
<span class="cm">	 * Assign ((IOVAL(&quot;crtc port&quot;) &amp; &quot;mask&quot;) | &quot;data&quot;) to &quot;crtc port&quot;</span>
<span class="cm">	 */</span>

	<span class="k">struct</span> <span class="n">drm_nouveau_private</span> <span class="o">*</span><span class="n">dev_priv</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_private</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">crtcport</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]);</span>
	<span class="kt">uint8_t</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">3</span><span class="p">];</span>
	<span class="kt">uint8_t</span> <span class="n">data</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">4</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iexec</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">5</span><span class="p">;</span>

	<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;0x%04X: Port: 0x%04X, Mask: 0x%02X, Data: 0x%02X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">offset</span><span class="p">,</span> <span class="n">crtcport</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * I have no idea what this does, but NVIDIA do this magic sequence</span>
<span class="cm">	 * in the places where this INIT_IO happens..</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">card_type</span> <span class="o">&gt;=</span> <span class="n">NV_50</span> <span class="o">&amp;&amp;</span> <span class="n">crtcport</span> <span class="o">==</span> <span class="mh">0x3c3</span> <span class="o">&amp;&amp;</span> <span class="n">data</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

		<span class="n">bios_wr32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="mh">0x614100</span><span class="p">,</span> <span class="p">(</span><span class="n">bios_rd32</span><span class="p">(</span>
			  <span class="n">bios</span><span class="p">,</span> <span class="mh">0x614100</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0fffffff</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x00800000</span><span class="p">);</span>

		<span class="n">bios_wr32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="mh">0x00e18c</span><span class="p">,</span> <span class="n">bios_rd32</span><span class="p">(</span>
			  <span class="n">bios</span><span class="p">,</span> <span class="mh">0x00e18c</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x00020000</span><span class="p">);</span>

		<span class="n">bios_wr32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="mh">0x614900</span><span class="p">,</span> <span class="p">(</span><span class="n">bios_rd32</span><span class="p">(</span>
			  <span class="n">bios</span><span class="p">,</span> <span class="mh">0x614900</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0fffffff</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x00800000</span><span class="p">);</span>

		<span class="n">bios_wr32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="mh">0x000200</span><span class="p">,</span> <span class="n">bios_rd32</span><span class="p">(</span>
			  <span class="n">bios</span><span class="p">,</span> <span class="mh">0x000200</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x40000000</span><span class="p">);</span>

		<span class="n">mdelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

		<span class="n">bios_wr32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="mh">0x00e18c</span><span class="p">,</span> <span class="n">bios_rd32</span><span class="p">(</span>
			  <span class="n">bios</span><span class="p">,</span> <span class="mh">0x00e18c</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x00020000</span><span class="p">);</span>

		<span class="n">bios_wr32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="mh">0x000200</span><span class="p">,</span> <span class="n">bios_rd32</span><span class="p">(</span>
			  <span class="n">bios</span><span class="p">,</span> <span class="mh">0x000200</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x40000000</span><span class="p">);</span>

		<span class="n">bios_wr32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="mh">0x614100</span><span class="p">,</span> <span class="mh">0x00800018</span><span class="p">);</span>
		<span class="n">bios_wr32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="mh">0x614900</span><span class="p">,</span> <span class="mh">0x00800018</span><span class="p">);</span>

		<span class="n">mdelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

		<span class="n">bios_wr32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="mh">0x614100</span><span class="p">,</span> <span class="mh">0x10000018</span><span class="p">);</span>
		<span class="n">bios_wr32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="mh">0x614900</span><span class="p">,</span> <span class="mh">0x10000018</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">bios_wr32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="mh">0x614280</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="mh">0x800</span><span class="p">),</span> <span class="n">bios_rd32</span><span class="p">(</span>
				  <span class="n">bios</span><span class="p">,</span> <span class="mh">0x614280</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="mh">0x800</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mh">0xf0f0f0f0</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">bios_wr32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="mh">0x614300</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="mh">0x800</span><span class="p">),</span> <span class="n">bios_rd32</span><span class="p">(</span>
				  <span class="n">bios</span><span class="p">,</span> <span class="mh">0x614300</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="mh">0x800</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mh">0xfffff0f0</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">bios_wr32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="mh">0x614380</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="mh">0x800</span><span class="p">),</span> <span class="n">bios_rd32</span><span class="p">(</span>
				  <span class="n">bios</span><span class="p">,</span> <span class="mh">0x614380</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="mh">0x800</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mh">0xfffff0f0</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">bios_wr32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="mh">0x614200</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="mh">0x800</span><span class="p">),</span> <span class="n">bios_rd32</span><span class="p">(</span>
				  <span class="n">bios</span><span class="p">,</span> <span class="mh">0x614200</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="mh">0x800</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mh">0xfffffff0</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">bios_wr32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="mh">0x614108</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="mh">0x800</span><span class="p">),</span> <span class="n">bios_rd32</span><span class="p">(</span>
				  <span class="n">bios</span><span class="p">,</span> <span class="mh">0x614108</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="mh">0x800</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mh">0x0fffffff</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">5</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">bios_port_wr</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">crtcport</span><span class="p">,</span> <span class="p">(</span><span class="n">bios_port_rd</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">crtcport</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">|</span>
									<span class="n">data</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">5</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">init_sub</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">offset</span><span class="p">,</span> <span class="k">struct</span> <span class="n">init_exec</span> <span class="o">*</span><span class="n">iexec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * INIT_SUB   opcode: 0x6B (&#39;k&#39;)</span>
<span class="cm">	 *</span>
<span class="cm">	 * offset      (8 bit): opcode</span>
<span class="cm">	 * offset + 1  (8 bit): script number</span>
<span class="cm">	 *</span>
<span class="cm">	 * Execute script number &quot;script number&quot;, as a subroutine</span>
<span class="cm">	 */</span>

	<span class="kt">uint8_t</span> <span class="n">sub</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iexec</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">2</span><span class="p">;</span>

	<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;0x%04X: Calling script %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">sub</span><span class="p">);</span>

	<span class="n">parse_init_table</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span>
			 <span class="n">ROM16</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">init_script_tbls_ptr</span> <span class="o">+</span> <span class="n">sub</span> <span class="o">*</span> <span class="mi">2</span><span class="p">]),</span>
			 <span class="n">iexec</span><span class="p">);</span>

	<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;0x%04X: End of script %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">sub</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">init_ram_condition</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">offset</span><span class="p">,</span>
		   <span class="k">struct</span> <span class="n">init_exec</span> <span class="o">*</span><span class="n">iexec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * INIT_RAM_CONDITION   opcode: 0x6D (&#39;m&#39;)</span>
<span class="cm">	 *</span>
<span class="cm">	 * offset      (8 bit): opcode</span>
<span class="cm">	 * offset + 1  (8 bit): mask</span>
<span class="cm">	 * offset + 2  (8 bit): cmpval</span>
<span class="cm">	 *</span>
<span class="cm">	 * Test if (NV04_PFB_BOOT_0 &amp; &quot;mask&quot;) equals &quot;cmpval&quot;.</span>
<span class="cm">	 * If condition not met skip subsequent opcodes until condition is</span>
<span class="cm">	 * inverted (INIT_NOT), or we hit INIT_RESUME</span>
<span class="cm">	 */</span>

	<span class="kt">uint8_t</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="kt">uint8_t</span> <span class="n">cmpval</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">2</span><span class="p">];</span>
	<span class="kt">uint8_t</span> <span class="n">data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iexec</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">3</span><span class="p">;</span>

	<span class="n">data</span> <span class="o">=</span> <span class="n">bios_rd32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">NV04_PFB_BOOT_0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">;</span>

	<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;0x%04X: Checking if 0x%08X equals 0x%08X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">offset</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">cmpval</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">==</span> <span class="n">cmpval</span><span class="p">)</span>
		<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;0x%04X: Condition fulfilled -- continuing to execute</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;0x%04X: Condition not fulfilled -- skipping following commands</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
		<span class="n">iexec</span><span class="o">-&gt;</span><span class="n">execute</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">init_nv_reg</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">offset</span><span class="p">,</span> <span class="k">struct</span> <span class="n">init_exec</span> <span class="o">*</span><span class="n">iexec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * INIT_NV_REG   opcode: 0x6E (&#39;n&#39;)</span>
<span class="cm">	 *</span>
<span class="cm">	 * offset      (8  bit): opcode</span>
<span class="cm">	 * offset + 1  (32 bit): register</span>
<span class="cm">	 * offset + 5  (32 bit): mask</span>
<span class="cm">	 * offset + 9  (32 bit): data</span>
<span class="cm">	 *</span>
<span class="cm">	 * Assign ((REGVAL(&quot;register&quot;) &amp; &quot;mask&quot;) | &quot;data&quot;) to &quot;register&quot;</span>
<span class="cm">	 */</span>

	<span class="kt">uint32_t</span> <span class="n">reg</span> <span class="o">=</span> <span class="n">ROM32</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]);</span>
	<span class="kt">uint32_t</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">ROM32</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">5</span><span class="p">]);</span>
	<span class="kt">uint32_t</span> <span class="n">data</span> <span class="o">=</span> <span class="n">ROM32</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">9</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iexec</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">13</span><span class="p">;</span>

	<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;0x%04X: Reg: 0x%08X, Mask: 0x%08X, Data: 0x%08X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">offset</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

	<span class="n">bios_wr32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="p">(</span><span class="n">bios_rd32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">reg</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">|</span> <span class="n">data</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">13</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">init_macro</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">offset</span><span class="p">,</span> <span class="k">struct</span> <span class="n">init_exec</span> <span class="o">*</span><span class="n">iexec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * INIT_MACRO   opcode: 0x6F (&#39;o&#39;)</span>
<span class="cm">	 *</span>
<span class="cm">	 * offset      (8 bit): opcode</span>
<span class="cm">	 * offset + 1  (8 bit): macro number</span>
<span class="cm">	 *</span>
<span class="cm">	 * Look up macro index &quot;macro number&quot; in the macro index table.</span>
<span class="cm">	 * The macro index table entry has 1 byte for the index in the macro</span>
<span class="cm">	 * table, and 1 byte for the number of times to repeat the macro.</span>
<span class="cm">	 * The macro table entry has 4 bytes for the register address and</span>
<span class="cm">	 * 4 bytes for the value to write to that register</span>
<span class="cm">	 */</span>

	<span class="kt">uint8_t</span> <span class="n">macro_index_tbl_idx</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="kt">uint16_t</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">macro_index_tbl_ptr</span> <span class="o">+</span> <span class="p">(</span><span class="n">macro_index_tbl_idx</span> <span class="o">*</span> <span class="n">MACRO_INDEX_SIZE</span><span class="p">);</span>
	<span class="kt">uint8_t</span> <span class="n">macro_tbl_idx</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">tmp</span><span class="p">];</span>
	<span class="kt">uint8_t</span> <span class="n">count</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">tmp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="kt">uint32_t</span> <span class="n">reg</span><span class="p">,</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iexec</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">2</span><span class="p">;</span>

	<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;0x%04X: Macro: 0x%02X, MacroTableIndex: 0x%02X, &quot;</span>
		      <span class="s">&quot;Count: 0x%02X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">offset</span><span class="p">,</span> <span class="n">macro_index_tbl_idx</span><span class="p">,</span> <span class="n">macro_tbl_idx</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">uint16_t</span> <span class="n">macroentryptr</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">macro_tbl_ptr</span> <span class="o">+</span> <span class="p">(</span><span class="n">macro_tbl_idx</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">MACRO_SIZE</span><span class="p">;</span>

		<span class="n">reg</span> <span class="o">=</span> <span class="n">ROM32</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">macroentryptr</span><span class="p">]);</span>
		<span class="n">data</span> <span class="o">=</span> <span class="n">ROM32</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">macroentryptr</span> <span class="o">+</span> <span class="mi">4</span><span class="p">]);</span>

		<span class="n">bios_wr32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">init_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">offset</span><span class="p">,</span> <span class="k">struct</span> <span class="n">init_exec</span> <span class="o">*</span><span class="n">iexec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * INIT_DONE   opcode: 0x71 (&#39;q&#39;)</span>
<span class="cm">	 *</span>
<span class="cm">	 * offset      (8  bit): opcode</span>
<span class="cm">	 *</span>
<span class="cm">	 * End the current script</span>
<span class="cm">	 */</span>

	<span class="cm">/* mild retval abuse to stop parsing this table */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">init_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">offset</span><span class="p">,</span> <span class="k">struct</span> <span class="n">init_exec</span> <span class="o">*</span><span class="n">iexec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * INIT_RESUME   opcode: 0x72 (&#39;r&#39;)</span>
<span class="cm">	 *</span>
<span class="cm">	 * offset      (8  bit): opcode</span>
<span class="cm">	 *</span>
<span class="cm">	 * End the current execute / no-execute condition</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iexec</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">iexec</span><span class="o">-&gt;</span><span class="n">execute</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;0x%04X: ---- Executing following commands ----</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">init_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">offset</span><span class="p">,</span> <span class="k">struct</span> <span class="n">init_exec</span> <span class="o">*</span><span class="n">iexec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * INIT_TIME   opcode: 0x74 (&#39;t&#39;)</span>
<span class="cm">	 *</span>
<span class="cm">	 * offset      (8  bit): opcode</span>
<span class="cm">	 * offset + 1  (16 bit): time</span>
<span class="cm">	 *</span>
<span class="cm">	 * Sleep for &quot;time&quot; microseconds.</span>
<span class="cm">	 */</span>

	<span class="kt">unsigned</span> <span class="n">time</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iexec</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">3</span><span class="p">;</span>

	<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;0x%04X: Sleeping for 0x%04X microseconds</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">offset</span><span class="p">,</span> <span class="n">time</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">time</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">)</span>
		<span class="n">udelay</span><span class="p">(</span><span class="n">time</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">mdelay</span><span class="p">((</span><span class="n">time</span> <span class="o">+</span> <span class="mi">900</span><span class="p">)</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">init_condition</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">offset</span><span class="p">,</span> <span class="k">struct</span> <span class="n">init_exec</span> <span class="o">*</span><span class="n">iexec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * INIT_CONDITION   opcode: 0x75 (&#39;u&#39;)</span>
<span class="cm">	 *</span>
<span class="cm">	 * offset      (8 bit): opcode</span>
<span class="cm">	 * offset + 1  (8 bit): condition number</span>
<span class="cm">	 *</span>
<span class="cm">	 * Check condition &quot;condition number&quot; in the condition table.</span>
<span class="cm">	 * If condition not met skip subsequent opcodes until condition is</span>
<span class="cm">	 * inverted (INIT_NOT), or we hit INIT_RESUME</span>
<span class="cm">	 */</span>

	<span class="kt">uint8_t</span> <span class="n">cond</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iexec</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">2</span><span class="p">;</span>

	<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;0x%04X: Condition: 0x%02X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">cond</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bios_condition_met</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">cond</span><span class="p">))</span>
		<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;0x%04X: Condition fulfilled -- continuing to execute</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;0x%04X: Condition not fulfilled -- skipping following commands</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
		<span class="n">iexec</span><span class="o">-&gt;</span><span class="n">execute</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">init_io_condition</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">offset</span><span class="p">,</span> <span class="k">struct</span> <span class="n">init_exec</span> <span class="o">*</span><span class="n">iexec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * INIT_IO_CONDITION  opcode: 0x76</span>
<span class="cm">	 *</span>
<span class="cm">	 * offset      (8 bit): opcode</span>
<span class="cm">	 * offset + 1  (8 bit): condition number</span>
<span class="cm">	 *</span>
<span class="cm">	 * Check condition &quot;condition number&quot; in the io condition table.</span>
<span class="cm">	 * If condition not met skip subsequent opcodes until condition is</span>
<span class="cm">	 * inverted (INIT_NOT), or we hit INIT_RESUME</span>
<span class="cm">	 */</span>

	<span class="kt">uint8_t</span> <span class="n">cond</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iexec</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">2</span><span class="p">;</span>

	<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;0x%04X: IO condition: 0x%02X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">cond</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">io_condition_met</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">cond</span><span class="p">))</span>
		<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;0x%04X: Condition fulfilled -- continuing to execute</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;0x%04X: Condition not fulfilled -- skipping following commands</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
		<span class="n">iexec</span><span class="o">-&gt;</span><span class="n">execute</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">init_index_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">offset</span><span class="p">,</span> <span class="k">struct</span> <span class="n">init_exec</span> <span class="o">*</span><span class="n">iexec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * INIT_INDEX_IO   opcode: 0x78 (&#39;x&#39;)</span>
<span class="cm">	 *</span>
<span class="cm">	 * offset      (8  bit): opcode</span>
<span class="cm">	 * offset + 1  (16 bit): CRTC port</span>
<span class="cm">	 * offset + 3  (8  bit): CRTC index</span>
<span class="cm">	 * offset + 4  (8  bit): mask</span>
<span class="cm">	 * offset + 5  (8  bit): data</span>
<span class="cm">	 *</span>
<span class="cm">	 * Read value at index &quot;CRTC index&quot; on &quot;CRTC port&quot;, AND with &quot;mask&quot;,</span>
<span class="cm">	 * OR with &quot;data&quot;, write-back</span>
<span class="cm">	 */</span>

	<span class="kt">uint16_t</span> <span class="n">crtcport</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]);</span>
	<span class="kt">uint8_t</span> <span class="n">crtcindex</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">3</span><span class="p">];</span>
	<span class="kt">uint8_t</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">4</span><span class="p">];</span>
	<span class="kt">uint8_t</span> <span class="n">data</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">5</span><span class="p">];</span>
	<span class="kt">uint8_t</span> <span class="n">value</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iexec</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">6</span><span class="p">;</span>

	<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;0x%04X: Port: 0x%04X, Index: 0x%02X, Mask: 0x%02X, &quot;</span>
		      <span class="s">&quot;Data: 0x%02X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">offset</span><span class="p">,</span> <span class="n">crtcport</span><span class="p">,</span> <span class="n">crtcindex</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

	<span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="n">bios_idxprt_rd</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">crtcport</span><span class="p">,</span> <span class="n">crtcindex</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">|</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">bios_idxprt_wr</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">crtcport</span><span class="p">,</span> <span class="n">crtcindex</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">6</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">init_pll</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">offset</span><span class="p">,</span> <span class="k">struct</span> <span class="n">init_exec</span> <span class="o">*</span><span class="n">iexec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * INIT_PLL   opcode: 0x79 (&#39;y&#39;)</span>
<span class="cm">	 *</span>
<span class="cm">	 * offset      (8  bit): opcode</span>
<span class="cm">	 * offset + 1  (32 bit): register</span>
<span class="cm">	 * offset + 5  (16 bit): freq</span>
<span class="cm">	 *</span>
<span class="cm">	 * Set PLL register &quot;register&quot; to coefficients for frequency (10kHz)</span>
<span class="cm">	 * &quot;freq&quot;</span>
<span class="cm">	 */</span>

	<span class="kt">uint32_t</span> <span class="n">reg</span> <span class="o">=</span> <span class="n">ROM32</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]);</span>
	<span class="kt">uint16_t</span> <span class="n">freq</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">5</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iexec</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">7</span><span class="p">;</span>

	<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;0x%04X: Reg: 0x%08X, Freq: %d0kHz</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">freq</span><span class="p">);</span>

	<span class="n">setPLL</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">freq</span> <span class="o">*</span> <span class="mi">10</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">7</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">init_zm_reg</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">offset</span><span class="p">,</span> <span class="k">struct</span> <span class="n">init_exec</span> <span class="o">*</span><span class="n">iexec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * INIT_ZM_REG   opcode: 0x7A (&#39;z&#39;)</span>
<span class="cm">	 *</span>
<span class="cm">	 * offset      (8  bit): opcode</span>
<span class="cm">	 * offset + 1  (32 bit): register</span>
<span class="cm">	 * offset + 5  (32 bit): value</span>
<span class="cm">	 *</span>
<span class="cm">	 * Assign &quot;value&quot; to &quot;register&quot;</span>
<span class="cm">	 */</span>

	<span class="kt">uint32_t</span> <span class="n">reg</span> <span class="o">=</span> <span class="n">ROM32</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]);</span>
	<span class="kt">uint32_t</span> <span class="n">value</span> <span class="o">=</span> <span class="n">ROM32</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">5</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iexec</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">9</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">reg</span> <span class="o">==</span> <span class="mh">0x000200</span><span class="p">)</span>
		<span class="n">value</span> <span class="o">|=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">bios_wr32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">9</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">init_ram_restrict_pll</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">offset</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">init_exec</span> <span class="o">*</span><span class="n">iexec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * INIT_RAM_RESTRICT_PLL   opcode: 0x87 (&#39;&#39;)</span>
<span class="cm">	 *</span>
<span class="cm">	 * offset      (8 bit): opcode</span>
<span class="cm">	 * offset + 1  (8 bit): PLL type</span>
<span class="cm">	 * offset + 2 (32 bit): frequency 0</span>
<span class="cm">	 *</span>
<span class="cm">	 * Uses the RAMCFG strap of PEXTDEV_BOOT as an index into the table at</span>
<span class="cm">	 * ram_restrict_table_ptr.  The value read from there is used to select</span>
<span class="cm">	 * a frequency from the table starting at &#39;frequency 0&#39; to be</span>
<span class="cm">	 * programmed into the PLL corresponding to &#39;type&#39;.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The PLL limits table on cards using this opcode has a mapping of</span>
<span class="cm">	 * &#39;type&#39; to the relevant registers.</span>
<span class="cm">	 */</span>

	<span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">strap</span> <span class="o">=</span> <span class="p">(</span><span class="n">bios_rd32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">NV_PEXTDEV_BOOT_0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0000003c</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">index</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">ram_restrict_tbl_ptr</span> <span class="o">+</span> <span class="n">strap</span><span class="p">];</span>
	<span class="kt">uint8_t</span> <span class="n">type</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="kt">uint32_t</span> <span class="n">freq</span> <span class="o">=</span> <span class="n">ROM32</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">index</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)]);</span>
	<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">pll_limits</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">pll_limit_tbl_ptr</span><span class="p">],</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">ram_restrict_group_count</span> <span class="o">*</span> <span class="mi">4</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iexec</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">pll_limit_tbl_ptr</span> <span class="o">||</span> <span class="p">(</span><span class="n">pll_limits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xf0</span><span class="p">)</span> <span class="o">!=</span> <span class="mh">0x30</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">NV_ERROR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;PLL limits table not version 3.x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">len</span><span class="p">;</span> <span class="cm">/* deliberate, allow default clocks to remain */</span>
	<span class="p">}</span>

	<span class="n">entry</span> <span class="o">=</span> <span class="n">pll_limits</span> <span class="o">+</span> <span class="n">pll_limits</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pll_limits</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">entry</span> <span class="o">+=</span> <span class="n">pll_limits</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">type</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">uint32_t</span> <span class="n">reg</span> <span class="o">=</span> <span class="n">ROM32</span><span class="p">(</span><span class="n">entry</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>

			<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;0x%04X: &quot;</span>
				      <span class="s">&quot;Type %02x Reg 0x%08x Freq %dKHz</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">offset</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">freq</span><span class="p">);</span>

			<span class="n">setPLL</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">freq</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">NV_ERROR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;PLL type 0x%02x not found in PLL limits table&quot;</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">init_8c</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">offset</span><span class="p">,</span> <span class="k">struct</span> <span class="n">init_exec</span> <span class="o">*</span><span class="n">iexec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * INIT_8C   opcode: 0x8C (&#39;&#39;)</span>
<span class="cm">	 *</span>
<span class="cm">	 * NOP so far....</span>
<span class="cm">	 *</span>
<span class="cm">	 */</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">init_8d</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">offset</span><span class="p">,</span> <span class="k">struct</span> <span class="n">init_exec</span> <span class="o">*</span><span class="n">iexec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * INIT_8D   opcode: 0x8D (&#39;&#39;)</span>
<span class="cm">	 *</span>
<span class="cm">	 * NOP so far....</span>
<span class="cm">	 *</span>
<span class="cm">	 */</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">init_gpio</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">offset</span><span class="p">,</span> <span class="k">struct</span> <span class="n">init_exec</span> <span class="o">*</span><span class="n">iexec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * INIT_GPIO   opcode: 0x8E (&#39;&#39;)</span>
<span class="cm">	 *</span>
<span class="cm">	 * offset      (8 bit): opcode</span>
<span class="cm">	 *</span>
<span class="cm">	 * Loop over all entries in the DCB GPIO table, and initialise</span>
<span class="cm">	 * each GPIO according to various values listed in each entry</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iexec</span><span class="o">-&gt;</span><span class="n">execute</span> <span class="o">&amp;&amp;</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">)</span>
		<span class="n">nouveau_gpio_reset</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">init_ram_restrict_zm_reg_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">offset</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">init_exec</span> <span class="o">*</span><span class="n">iexec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * INIT_RAM_RESTRICT_ZM_REG_GROUP   opcode: 0x8F (&#39;&#39;)</span>
<span class="cm">	 *</span>
<span class="cm">	 * offset      (8  bit): opcode</span>
<span class="cm">	 * offset + 1  (32 bit): reg</span>
<span class="cm">	 * offset + 5  (8  bit): regincrement</span>
<span class="cm">	 * offset + 6  (8  bit): count</span>
<span class="cm">	 * offset + 7  (32 bit): value 1,1</span>
<span class="cm">	 * ...</span>
<span class="cm">	 *</span>
<span class="cm">	 * Use the RAMCFG strap of PEXTDEV_BOOT as an index into the table at</span>
<span class="cm">	 * ram_restrict_table_ptr. The value read from here is &#39;n&#39;, and</span>
<span class="cm">	 * &quot;value 1,n&quot; gets written to &quot;reg&quot;. This repeats &quot;count&quot; times and on</span>
<span class="cm">	 * each iteration &#39;m&#39;, &quot;reg&quot; increases by &quot;regincrement&quot; and</span>
<span class="cm">	 * &quot;value m,n&quot; is used. The extent of n is limited by a number read</span>
<span class="cm">	 * from the &#39;M&#39; BIT table, herein called &quot;blocklen&quot;</span>
<span class="cm">	 */</span>

	<span class="kt">uint32_t</span> <span class="n">reg</span> <span class="o">=</span> <span class="n">ROM32</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]);</span>
	<span class="kt">uint8_t</span> <span class="n">regincrement</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">5</span><span class="p">];</span>
	<span class="kt">uint8_t</span> <span class="n">count</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">6</span><span class="p">];</span>
	<span class="kt">uint32_t</span> <span class="n">strap_ramcfg</span><span class="p">,</span> <span class="n">data</span><span class="p">;</span>
	<span class="cm">/* previously set by &#39;M&#39; BIT table */</span>
	<span class="kt">uint16_t</span> <span class="n">blocklen</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">ram_restrict_group_count</span> <span class="o">*</span> <span class="mi">4</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">7</span> <span class="o">+</span> <span class="n">count</span> <span class="o">*</span> <span class="n">blocklen</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">index</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* critical! to know the length of the opcode */</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">blocklen</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">NV_ERROR</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			 <span class="s">&quot;0x%04X: Zero block length - has the M table &quot;</span>
			 <span class="s">&quot;been parsed?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iexec</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">len</span><span class="p">;</span>

	<span class="n">strap_ramcfg</span> <span class="o">=</span> <span class="p">(</span><span class="n">bios_rd32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">NV_PEXTDEV_BOOT_0</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">;</span>
	<span class="n">index</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">ram_restrict_tbl_ptr</span> <span class="o">+</span> <span class="n">strap_ramcfg</span><span class="p">];</span>

	<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;0x%04X: Reg: 0x%08X, RegIncrement: 0x%02X, &quot;</span>
		      <span class="s">&quot;Count: 0x%02X, StrapRamCfg: 0x%02X, Index: 0x%02X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">offset</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">regincrement</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">strap_ramcfg</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">data</span> <span class="o">=</span> <span class="n">ROM32</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">7</span> <span class="o">+</span> <span class="n">index</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="n">blocklen</span> <span class="o">*</span> <span class="n">i</span><span class="p">]);</span>

		<span class="n">bios_wr32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

		<span class="n">reg</span> <span class="o">+=</span> <span class="n">regincrement</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">init_copy_zm_reg</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">offset</span><span class="p">,</span> <span class="k">struct</span> <span class="n">init_exec</span> <span class="o">*</span><span class="n">iexec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * INIT_COPY_ZM_REG   opcode: 0x90 (&#39;&#39;)</span>
<span class="cm">	 *</span>
<span class="cm">	 * offset      (8  bit): opcode</span>
<span class="cm">	 * offset + 1  (32 bit): src reg</span>
<span class="cm">	 * offset + 5  (32 bit): dst reg</span>
<span class="cm">	 *</span>
<span class="cm">	 * Put contents of &quot;src reg&quot; into &quot;dst reg&quot;</span>
<span class="cm">	 */</span>

	<span class="kt">uint32_t</span> <span class="n">srcreg</span> <span class="o">=</span> <span class="n">ROM32</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]);</span>
	<span class="kt">uint32_t</span> <span class="n">dstreg</span> <span class="o">=</span> <span class="n">ROM32</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">5</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iexec</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">9</span><span class="p">;</span>

	<span class="n">bios_wr32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">dstreg</span><span class="p">,</span> <span class="n">bios_rd32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">srcreg</span><span class="p">));</span>

	<span class="k">return</span> <span class="mi">9</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">init_zm_reg_group_addr_latched</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">offset</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">init_exec</span> <span class="o">*</span><span class="n">iexec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * INIT_ZM_REG_GROUP_ADDRESS_LATCHED   opcode: 0x91 (&#39;&#39;)</span>
<span class="cm">	 *</span>
<span class="cm">	 * offset      (8  bit): opcode</span>
<span class="cm">	 * offset + 1  (32 bit): dst reg</span>
<span class="cm">	 * offset + 5  (8  bit): count</span>
<span class="cm">	 * offset + 6  (32 bit): data 1</span>
<span class="cm">	 * ...</span>
<span class="cm">	 *</span>
<span class="cm">	 * For each of &quot;count&quot; values write &quot;data n&quot; to &quot;dst reg&quot;</span>
<span class="cm">	 */</span>

	<span class="kt">uint32_t</span> <span class="n">reg</span> <span class="o">=</span> <span class="n">ROM32</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]);</span>
	<span class="kt">uint8_t</span> <span class="n">count</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">5</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">6</span> <span class="o">+</span> <span class="n">count</span> <span class="o">*</span> <span class="mi">4</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iexec</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">len</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">uint32_t</span> <span class="n">data</span> <span class="o">=</span> <span class="n">ROM32</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">6</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">i</span><span class="p">]);</span>
		<span class="n">bios_wr32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">init_reserved</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">offset</span><span class="p">,</span> <span class="k">struct</span> <span class="n">init_exec</span> <span class="o">*</span><span class="n">iexec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * INIT_RESERVED   opcode: 0x92 (&#39;&#39;)</span>
<span class="cm">	 *</span>
<span class="cm">	 * offset      (8 bit): opcode</span>
<span class="cm">	 *</span>
<span class="cm">	 * Seemingly does nothing</span>
<span class="cm">	 */</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">init_96</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">offset</span><span class="p">,</span> <span class="k">struct</span> <span class="n">init_exec</span> <span class="o">*</span><span class="n">iexec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * INIT_96   opcode: 0x96 (&#39;&#39;)</span>
<span class="cm">	 *</span>
<span class="cm">	 * offset      (8  bit): opcode</span>
<span class="cm">	 * offset + 1  (32 bit): sreg</span>
<span class="cm">	 * offset + 5  (8  bit): sshift</span>
<span class="cm">	 * offset + 6  (8  bit): smask</span>
<span class="cm">	 * offset + 7  (8  bit): index</span>
<span class="cm">	 * offset + 8  (32 bit): reg</span>
<span class="cm">	 * offset + 12 (32 bit): mask</span>
<span class="cm">	 * offset + 16 (8  bit): shift</span>
<span class="cm">	 *</span>
<span class="cm">	 */</span>

	<span class="kt">uint16_t</span> <span class="n">xlatptr</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">init96_tbl_ptr</span> <span class="o">+</span> <span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">7</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
	<span class="kt">uint32_t</span> <span class="n">reg</span> <span class="o">=</span> <span class="n">ROM32</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]);</span>
	<span class="kt">uint32_t</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">ROM32</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">12</span><span class="p">]);</span>
	<span class="kt">uint32_t</span> <span class="n">val</span><span class="p">;</span>

	<span class="n">val</span> <span class="o">=</span> <span class="n">bios_rd32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">ROM32</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">5</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mh">0x80</span><span class="p">)</span>
		<span class="n">val</span> <span class="o">&gt;&gt;=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">5</span><span class="p">];</span>
	<span class="k">else</span>
		<span class="n">val</span> <span class="o">&lt;&lt;=</span> <span class="p">(</span><span class="mh">0x100</span> <span class="o">-</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">5</span><span class="p">]);</span>
	<span class="n">val</span> <span class="o">&amp;=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">6</span><span class="p">];</span>

	<span class="n">val</span>   <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">ROM16</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">xlatptr</span><span class="p">])</span> <span class="o">+</span> <span class="n">val</span><span class="p">];</span>
	<span class="n">val</span> <span class="o">&lt;&lt;=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">16</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iexec</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">17</span><span class="p">;</span>

	<span class="n">bios_wr32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="p">(</span><span class="n">bios_rd32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">reg</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">|</span> <span class="n">val</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">17</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">init_97</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">offset</span><span class="p">,</span> <span class="k">struct</span> <span class="n">init_exec</span> <span class="o">*</span><span class="n">iexec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * INIT_97   opcode: 0x97 (&#39;&#39;)</span>
<span class="cm">	 *</span>
<span class="cm">	 * offset      (8  bit): opcode</span>
<span class="cm">	 * offset + 1  (32 bit): register</span>
<span class="cm">	 * offset + 5  (32 bit): mask</span>
<span class="cm">	 * offset + 9  (32 bit): value</span>
<span class="cm">	 *</span>
<span class="cm">	 * Adds &quot;value&quot; to &quot;register&quot; preserving the fields specified</span>
<span class="cm">	 * by &quot;mask&quot;</span>
<span class="cm">	 */</span>

	<span class="kt">uint32_t</span> <span class="n">reg</span> <span class="o">=</span> <span class="n">ROM32</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]);</span>
	<span class="kt">uint32_t</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">ROM32</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">5</span><span class="p">]);</span>
	<span class="kt">uint32_t</span> <span class="n">add</span> <span class="o">=</span> <span class="n">ROM32</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">9</span><span class="p">]);</span>
	<span class="kt">uint32_t</span> <span class="n">val</span><span class="p">;</span>

	<span class="n">val</span> <span class="o">=</span> <span class="n">bios_rd32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
	<span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">val</span> <span class="o">+</span> <span class="n">add</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">mask</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iexec</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">13</span><span class="p">;</span>

	<span class="n">bios_wr32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">13</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">init_auxch</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">offset</span><span class="p">,</span> <span class="k">struct</span> <span class="n">init_exec</span> <span class="o">*</span><span class="n">iexec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * INIT_AUXCH   opcode: 0x98 (&#39;&#39;)</span>
<span class="cm">	 *</span>
<span class="cm">	 * offset      (8  bit): opcode</span>
<span class="cm">	 * offset + 1  (32 bit): address</span>
<span class="cm">	 * offset + 5  (8  bit): count</span>
<span class="cm">	 * offset + 6  (8  bit): mask 0</span>
<span class="cm">	 * offset + 7  (8  bit): data 0</span>
<span class="cm">	 *  ...</span>
<span class="cm">	 *</span>
<span class="cm">	 */</span>

	<span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nouveau_i2c_chan</span> <span class="o">*</span><span class="n">auxch</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">ROM32</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]);</span>
	<span class="kt">uint8_t</span> <span class="n">count</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">5</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">6</span> <span class="o">+</span> <span class="n">count</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">display</span><span class="p">.</span><span class="n">output</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">NV_ERROR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;INIT_AUXCH: no active output</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">auxch</span> <span class="o">=</span> <span class="n">init_i2c_device_find</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">display</span><span class="p">.</span><span class="n">output</span><span class="o">-&gt;</span><span class="n">i2c_index</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">auxch</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">NV_ERROR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;INIT_AUXCH: couldn&#39;t get auxch %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">bios</span><span class="o">-&gt;</span><span class="n">display</span><span class="p">.</span><span class="n">output</span><span class="o">-&gt;</span><span class="n">i2c_index</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iexec</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">len</span><span class="p">;</span>

	<span class="n">offset</span> <span class="o">+=</span> <span class="mi">6</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">offset</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">uint8_t</span> <span class="n">data</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">nouveau_dp_auxch</span><span class="p">(</span><span class="n">auxch</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">NV_ERROR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;INIT_AUXCH: rd auxch fail %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">data</span> <span class="o">&amp;=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">0</span><span class="p">];</span>
		<span class="n">data</span> <span class="o">|=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">nouveau_dp_auxch</span><span class="p">(</span><span class="n">auxch</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">NV_ERROR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;INIT_AUXCH: wr auxch fail %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">init_zm_auxch</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">offset</span><span class="p">,</span> <span class="k">struct</span> <span class="n">init_exec</span> <span class="o">*</span><span class="n">iexec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * INIT_ZM_AUXCH   opcode: 0x99 (&#39;&#39;)</span>
<span class="cm">	 *</span>
<span class="cm">	 * offset      (8  bit): opcode</span>
<span class="cm">	 * offset + 1  (32 bit): address</span>
<span class="cm">	 * offset + 5  (8  bit): count</span>
<span class="cm">	 * offset + 6  (8  bit): data 0</span>
<span class="cm">	 *  ...</span>
<span class="cm">	 *</span>
<span class="cm">	 */</span>

	<span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nouveau_i2c_chan</span> <span class="o">*</span><span class="n">auxch</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">ROM32</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]);</span>
	<span class="kt">uint8_t</span> <span class="n">count</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">5</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">6</span> <span class="o">+</span> <span class="n">count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">display</span><span class="p">.</span><span class="n">output</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">NV_ERROR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;INIT_ZM_AUXCH: no active output</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">auxch</span> <span class="o">=</span> <span class="n">init_i2c_device_find</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">display</span><span class="p">.</span><span class="n">output</span><span class="o">-&gt;</span><span class="n">i2c_index</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">auxch</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">NV_ERROR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;INIT_ZM_AUXCH: couldn&#39;t get auxch %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">bios</span><span class="o">-&gt;</span><span class="n">display</span><span class="p">.</span><span class="n">output</span><span class="o">-&gt;</span><span class="n">i2c_index</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iexec</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">len</span><span class="p">;</span>

	<span class="n">offset</span> <span class="o">+=</span> <span class="mi">6</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">offset</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">nouveau_dp_auxch</span><span class="p">(</span><span class="n">auxch</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span><span class="p">],</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">NV_ERROR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;INIT_ZM_AUXCH: wr auxch fail %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">init_i2c_long_if</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">offset</span><span class="p">,</span> <span class="k">struct</span> <span class="n">init_exec</span> <span class="o">*</span><span class="n">iexec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * INIT_I2C_LONG_IF   opcode: 0x9A (&#39;&#39;)</span>
<span class="cm">	 *</span>
<span class="cm">	 * offset      (8 bit): opcode</span>
<span class="cm">	 * offset + 1  (8 bit): DCB I2C table entry index</span>
<span class="cm">	 * offset + 2  (8 bit): I2C slave address</span>
<span class="cm">	 * offset + 3  (16 bit): I2C register</span>
<span class="cm">	 * offset + 5  (8 bit): mask</span>
<span class="cm">	 * offset + 6  (8 bit): data</span>
<span class="cm">	 *</span>
<span class="cm">	 * Read the register given by &quot;I2C register&quot; on the device addressed</span>
<span class="cm">	 * by &quot;I2C slave address&quot; on the I2C bus given by &quot;DCB I2C table</span>
<span class="cm">	 * entry index&quot;. Compare the result AND &quot;mask&quot; to &quot;data&quot;.</span>
<span class="cm">	 * If they&#39;re not equal, skip subsequent opcodes until condition is</span>
<span class="cm">	 * inverted (INIT_NOT), or we hit INIT_RESUME</span>
<span class="cm">	 */</span>

	<span class="kt">uint8_t</span> <span class="n">i2c_index</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="kt">uint8_t</span> <span class="n">i2c_address</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">reglo</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">3</span><span class="p">];</span>
	<span class="kt">uint8_t</span> <span class="n">reghi</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">4</span><span class="p">];</span>
	<span class="kt">uint8_t</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">5</span><span class="p">];</span>
	<span class="kt">uint8_t</span> <span class="n">data</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">6</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">nouveau_i2c_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">buf0</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="n">reghi</span><span class="p">,</span> <span class="n">reglo</span> <span class="p">};</span>
	<span class="kt">uint8_t</span> <span class="n">buf1</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">i2c_msg</span> <span class="n">msg</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">{</span> <span class="n">i2c_address</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">buf0</span> <span class="p">},</span>
		<span class="p">{</span> <span class="n">i2c_address</span><span class="p">,</span> <span class="n">I2C_M_RD</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">buf1</span> <span class="p">},</span>
	<span class="p">};</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* no execute check by design */</span>

	<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;0x%04X: DCBI2CIndex: 0x%02X, I2CAddress: 0x%02X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">offset</span><span class="p">,</span> <span class="n">i2c_index</span><span class="p">,</span> <span class="n">i2c_address</span><span class="p">);</span>

	<span class="n">chan</span> <span class="o">=</span> <span class="n">init_i2c_device_find</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">i2c_index</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chan</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>


	<span class="n">ret</span> <span class="o">=</span> <span class="n">i2c_transfer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;0x%04X: I2CReg: 0x%02X:0x%02X, Value: [no device], &quot;</span>
			      <span class="s">&quot;Mask: 0x%02X, Data: 0x%02X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">offset</span><span class="p">,</span> <span class="n">reghi</span><span class="p">,</span> <span class="n">reglo</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
		<span class="n">iexec</span><span class="o">-&gt;</span><span class="n">execute</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">7</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;0x%04X: I2CReg: 0x%02X:0x%02X, Value: 0x%02X, &quot;</span>
		      <span class="s">&quot;Mask: 0x%02X, Data: 0x%02X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">offset</span><span class="p">,</span> <span class="n">reghi</span><span class="p">,</span> <span class="n">reglo</span><span class="p">,</span> <span class="n">buf1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">mask</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

	<span class="n">iexec</span><span class="o">-&gt;</span><span class="n">execute</span> <span class="o">=</span> <span class="p">((</span><span class="n">buf1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">==</span> <span class="n">data</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">7</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">init_tbl_entry</span> <span class="n">itbl_entry</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="cm">/* command name                       , id  , length  , offset  , mult    , command handler                 */</span>
	<span class="cm">/* INIT_PROG (0x31, 15, 10, 4) removed due to no example of use */</span>
	<span class="p">{</span> <span class="s">&quot;INIT_IO_RESTRICT_PROG&quot;</span>             <span class="p">,</span> <span class="mh">0x32</span><span class="p">,</span> <span class="n">init_io_restrict_prog</span>           <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;INIT_REPEAT&quot;</span>                       <span class="p">,</span> <span class="mh">0x33</span><span class="p">,</span> <span class="n">init_repeat</span>                     <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;INIT_IO_RESTRICT_PLL&quot;</span>              <span class="p">,</span> <span class="mh">0x34</span><span class="p">,</span> <span class="n">init_io_restrict_pll</span>            <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;INIT_END_REPEAT&quot;</span>                   <span class="p">,</span> <span class="mh">0x36</span><span class="p">,</span> <span class="n">init_end_repeat</span>                 <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;INIT_COPY&quot;</span>                         <span class="p">,</span> <span class="mh">0x37</span><span class="p">,</span> <span class="n">init_copy</span>                       <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;INIT_NOT&quot;</span>                          <span class="p">,</span> <span class="mh">0x38</span><span class="p">,</span> <span class="n">init_not</span>                        <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;INIT_IO_FLAG_CONDITION&quot;</span>            <span class="p">,</span> <span class="mh">0x39</span><span class="p">,</span> <span class="n">init_io_flag_condition</span>          <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;INIT_DP_CONDITION&quot;</span>                 <span class="p">,</span> <span class="mh">0x3A</span><span class="p">,</span> <span class="n">init_dp_condition</span>               <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;INIT_OP_3B&quot;</span>                        <span class="p">,</span> <span class="mh">0x3B</span><span class="p">,</span> <span class="n">init_op_3b</span>                      <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;INIT_OP_3C&quot;</span>                        <span class="p">,</span> <span class="mh">0x3C</span><span class="p">,</span> <span class="n">init_op_3c</span>                      <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;INIT_INDEX_ADDRESS_LATCHED&quot;</span>        <span class="p">,</span> <span class="mh">0x49</span><span class="p">,</span> <span class="n">init_idx_addr_latched</span>           <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;INIT_IO_RESTRICT_PLL2&quot;</span>             <span class="p">,</span> <span class="mh">0x4A</span><span class="p">,</span> <span class="n">init_io_restrict_pll2</span>           <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;INIT_PLL2&quot;</span>                         <span class="p">,</span> <span class="mh">0x4B</span><span class="p">,</span> <span class="n">init_pll2</span>                       <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;INIT_I2C_BYTE&quot;</span>                     <span class="p">,</span> <span class="mh">0x4C</span><span class="p">,</span> <span class="n">init_i2c_byte</span>                   <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;INIT_ZM_I2C_BYTE&quot;</span>                  <span class="p">,</span> <span class="mh">0x4D</span><span class="p">,</span> <span class="n">init_zm_i2c_byte</span>                <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;INIT_ZM_I2C&quot;</span>                       <span class="p">,</span> <span class="mh">0x4E</span><span class="p">,</span> <span class="n">init_zm_i2c</span>                     <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;INIT_TMDS&quot;</span>                         <span class="p">,</span> <span class="mh">0x4F</span><span class="p">,</span> <span class="n">init_tmds</span>                       <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;INIT_ZM_TMDS_GROUP&quot;</span>                <span class="p">,</span> <span class="mh">0x50</span><span class="p">,</span> <span class="n">init_zm_tmds_group</span>              <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;INIT_CR_INDEX_ADDRESS_LATCHED&quot;</span>     <span class="p">,</span> <span class="mh">0x51</span><span class="p">,</span> <span class="n">init_cr_idx_adr_latch</span>           <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;INIT_CR&quot;</span>                           <span class="p">,</span> <span class="mh">0x52</span><span class="p">,</span> <span class="n">init_cr</span>                         <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;INIT_ZM_CR&quot;</span>                        <span class="p">,</span> <span class="mh">0x53</span><span class="p">,</span> <span class="n">init_zm_cr</span>                      <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;INIT_ZM_CR_GROUP&quot;</span>                  <span class="p">,</span> <span class="mh">0x54</span><span class="p">,</span> <span class="n">init_zm_cr_group</span>                <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;INIT_CONDITION_TIME&quot;</span>               <span class="p">,</span> <span class="mh">0x56</span><span class="p">,</span> <span class="n">init_condition_time</span>             <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;INIT_LTIME&quot;</span>                        <span class="p">,</span> <span class="mh">0x57</span><span class="p">,</span> <span class="n">init_ltime</span>                      <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;INIT_ZM_REG_SEQUENCE&quot;</span>              <span class="p">,</span> <span class="mh">0x58</span><span class="p">,</span> <span class="n">init_zm_reg_sequence</span>            <span class="p">},</span>
	<span class="cm">/* INIT_INDIRECT_REG (0x5A, 7, 0, 0) removed due to no example of use */</span>
	<span class="p">{</span> <span class="s">&quot;INIT_SUB_DIRECT&quot;</span>                   <span class="p">,</span> <span class="mh">0x5B</span><span class="p">,</span> <span class="n">init_sub_direct</span>                 <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;INIT_JUMP&quot;</span>                         <span class="p">,</span> <span class="mh">0x5C</span><span class="p">,</span> <span class="n">init_jump</span>                       <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;INIT_I2C_IF&quot;</span>                       <span class="p">,</span> <span class="mh">0x5E</span><span class="p">,</span> <span class="n">init_i2c_if</span>                     <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;INIT_COPY_NV_REG&quot;</span>                  <span class="p">,</span> <span class="mh">0x5F</span><span class="p">,</span> <span class="n">init_copy_nv_reg</span>                <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;INIT_ZM_INDEX_IO&quot;</span>                  <span class="p">,</span> <span class="mh">0x62</span><span class="p">,</span> <span class="n">init_zm_index_io</span>                <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;INIT_COMPUTE_MEM&quot;</span>                  <span class="p">,</span> <span class="mh">0x63</span><span class="p">,</span> <span class="n">init_compute_mem</span>                <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;INIT_RESET&quot;</span>                        <span class="p">,</span> <span class="mh">0x65</span><span class="p">,</span> <span class="n">init_reset</span>                      <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;INIT_CONFIGURE_MEM&quot;</span>                <span class="p">,</span> <span class="mh">0x66</span><span class="p">,</span> <span class="n">init_configure_mem</span>              <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;INIT_CONFIGURE_CLK&quot;</span>                <span class="p">,</span> <span class="mh">0x67</span><span class="p">,</span> <span class="n">init_configure_clk</span>              <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;INIT_CONFIGURE_PREINIT&quot;</span>            <span class="p">,</span> <span class="mh">0x68</span><span class="p">,</span> <span class="n">init_configure_preinit</span>          <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;INIT_IO&quot;</span>                           <span class="p">,</span> <span class="mh">0x69</span><span class="p">,</span> <span class="n">init_io</span>                         <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;INIT_SUB&quot;</span>                          <span class="p">,</span> <span class="mh">0x6B</span><span class="p">,</span> <span class="n">init_sub</span>                        <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;INIT_RAM_CONDITION&quot;</span>                <span class="p">,</span> <span class="mh">0x6D</span><span class="p">,</span> <span class="n">init_ram_condition</span>              <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;INIT_NV_REG&quot;</span>                       <span class="p">,</span> <span class="mh">0x6E</span><span class="p">,</span> <span class="n">init_nv_reg</span>                     <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;INIT_MACRO&quot;</span>                        <span class="p">,</span> <span class="mh">0x6F</span><span class="p">,</span> <span class="n">init_macro</span>                      <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;INIT_DONE&quot;</span>                         <span class="p">,</span> <span class="mh">0x71</span><span class="p">,</span> <span class="n">init_done</span>                       <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;INIT_RESUME&quot;</span>                       <span class="p">,</span> <span class="mh">0x72</span><span class="p">,</span> <span class="n">init_resume</span>                     <span class="p">},</span>
	<span class="cm">/* INIT_RAM_CONDITION2 (0x73, 9, 0, 0) removed due to no example of use */</span>
	<span class="p">{</span> <span class="s">&quot;INIT_TIME&quot;</span>                         <span class="p">,</span> <span class="mh">0x74</span><span class="p">,</span> <span class="n">init_time</span>                       <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;INIT_CONDITION&quot;</span>                    <span class="p">,</span> <span class="mh">0x75</span><span class="p">,</span> <span class="n">init_condition</span>                  <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;INIT_IO_CONDITION&quot;</span>                 <span class="p">,</span> <span class="mh">0x76</span><span class="p">,</span> <span class="n">init_io_condition</span>               <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;INIT_INDEX_IO&quot;</span>                     <span class="p">,</span> <span class="mh">0x78</span><span class="p">,</span> <span class="n">init_index_io</span>                   <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;INIT_PLL&quot;</span>                          <span class="p">,</span> <span class="mh">0x79</span><span class="p">,</span> <span class="n">init_pll</span>                        <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;INIT_ZM_REG&quot;</span>                       <span class="p">,</span> <span class="mh">0x7A</span><span class="p">,</span> <span class="n">init_zm_reg</span>                     <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;INIT_RAM_RESTRICT_PLL&quot;</span>             <span class="p">,</span> <span class="mh">0x87</span><span class="p">,</span> <span class="n">init_ram_restrict_pll</span>           <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;INIT_8C&quot;</span>                           <span class="p">,</span> <span class="mh">0x8C</span><span class="p">,</span> <span class="n">init_8c</span>                         <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;INIT_8D&quot;</span>                           <span class="p">,</span> <span class="mh">0x8D</span><span class="p">,</span> <span class="n">init_8d</span>                         <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;INIT_GPIO&quot;</span>                         <span class="p">,</span> <span class="mh">0x8E</span><span class="p">,</span> <span class="n">init_gpio</span>                       <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;INIT_RAM_RESTRICT_ZM_REG_GROUP&quot;</span>    <span class="p">,</span> <span class="mh">0x8F</span><span class="p">,</span> <span class="n">init_ram_restrict_zm_reg_group</span>  <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;INIT_COPY_ZM_REG&quot;</span>                  <span class="p">,</span> <span class="mh">0x90</span><span class="p">,</span> <span class="n">init_copy_zm_reg</span>                <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;INIT_ZM_REG_GROUP_ADDRESS_LATCHED&quot;</span> <span class="p">,</span> <span class="mh">0x91</span><span class="p">,</span> <span class="n">init_zm_reg_group_addr_latched</span>  <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;INIT_RESERVED&quot;</span>                     <span class="p">,</span> <span class="mh">0x92</span><span class="p">,</span> <span class="n">init_reserved</span>                   <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;INIT_96&quot;</span>                           <span class="p">,</span> <span class="mh">0x96</span><span class="p">,</span> <span class="n">init_96</span>                         <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;INIT_97&quot;</span>                           <span class="p">,</span> <span class="mh">0x97</span><span class="p">,</span> <span class="n">init_97</span>                         <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;INIT_AUXCH&quot;</span>                        <span class="p">,</span> <span class="mh">0x98</span><span class="p">,</span> <span class="n">init_auxch</span>                      <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;INIT_ZM_AUXCH&quot;</span>                     <span class="p">,</span> <span class="mh">0x99</span><span class="p">,</span> <span class="n">init_zm_auxch</span>                   <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;INIT_I2C_LONG_IF&quot;</span>                  <span class="p">,</span> <span class="mh">0x9A</span><span class="p">,</span> <span class="n">init_i2c_long_if</span>                <span class="p">},</span>
	<span class="p">{</span> <span class="nb">NULL</span>                                <span class="p">,</span> <span class="mi">0</span>   <span class="p">,</span> <span class="nb">NULL</span>                            <span class="p">}</span>
<span class="p">};</span>

<span class="cp">#define MAX_TABLE_OPS 1000</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">parse_init_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">offset</span><span class="p">,</span> <span class="k">struct</span> <span class="n">init_exec</span> <span class="o">*</span><span class="n">iexec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Parses all commands in an init table.</span>
<span class="cm">	 *</span>
<span class="cm">	 * We start out executing all commands found in the init table. Some</span>
<span class="cm">	 * opcodes may change the status of iexec-&gt;execute to SKIP, which will</span>
<span class="cm">	 * cause the following opcodes to perform no operation until the value</span>
<span class="cm">	 * is changed back to EXECUTE.</span>
<span class="cm">	 */</span>

	<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">id</span><span class="p">;</span>

	<span class="cm">/* catch NULL script pointers */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Loop until INIT_DONE causes us to break out of the loop</span>
<span class="cm">	 * (or until offset &gt; bios length just in case... )</span>
<span class="cm">	 * (and no more than MAX_TABLE_OPS iterations, just in case... )</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">offset</span> <span class="o">&lt;</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">count</span><span class="o">++</span> <span class="o">&lt;</span> <span class="n">MAX_TABLE_OPS</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">id</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span><span class="p">];</span>

		<span class="cm">/* Find matching id in itbl_entry */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">itbl_entry</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">itbl_entry</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">id</span> <span class="o">!=</span> <span class="n">id</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">itbl_entry</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">NV_ERROR</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				 <span class="s">&quot;0x%04X: Init table command not found: &quot;</span>
				 <span class="s">&quot;0x%02X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;0x%04X: [ (0x%02X) - %s ]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span>
			<span class="n">itbl_entry</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">id</span><span class="p">,</span> <span class="n">itbl_entry</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">);</span>

		<span class="cm">/* execute eventual command handler */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">itbl_entry</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">handler</span><span class="p">)(</span><span class="n">bios</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">iexec</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">NV_ERROR</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;0x%04X: Failed parsing init &quot;</span>
				 <span class="s">&quot;table opcode: %s %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span>
				 <span class="n">itbl_entry</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Add the offset of the current command including all data</span>
<span class="cm">		 * of that command. The offset will then be pointing on the</span>
<span class="cm">		 * next op code.</span>
<span class="cm">		 */</span>
		<span class="n">offset</span> <span class="o">+=</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span>
		<span class="n">NV_WARN</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;Offset 0x%04X greater than known bios image length.  &quot;</span>
			<span class="s">&quot;Corrupt image?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="n">MAX_TABLE_OPS</span><span class="p">)</span>
		<span class="n">NV_WARN</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;More than %d opcodes to a table is unlikely, &quot;</span>
			<span class="s">&quot;is the bios image corrupt?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">MAX_TABLE_OPS</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">parse_init_tables</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Loops and calls parse_init_table() for each present table. */</span>

	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">table</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">init_exec</span> <span class="n">iexec</span> <span class="o">=</span> <span class="p">{</span><span class="nb">true</span><span class="p">,</span> <span class="nb">false</span><span class="p">};</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">old_style_init</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">init_script_tbls_ptr</span><span class="p">)</span>
			<span class="n">parse_init_table</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">init_script_tbls_ptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iexec</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">extra_init_script_tbl_ptr</span><span class="p">)</span>
			<span class="n">parse_init_table</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">extra_init_script_tbl_ptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iexec</span><span class="p">);</span>

		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">table</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">init_script_tbls_ptr</span> <span class="o">+</span> <span class="n">i</span><span class="p">])))</span> <span class="p">{</span>
		<span class="n">NV_INFO</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;Parsing VBIOS init table %d at offset 0x%04X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">i</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">table</span><span class="p">);</span>
		<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;0x%04X: ------ Executing following commands ------</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">table</span><span class="p">);</span>

		<span class="n">parse_init_table</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">table</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iexec</span><span class="p">);</span>
		<span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">uint16_t</span> <span class="nf">clkcmptable</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">clktable</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pxclk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">compare_record_len</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">compareclk</span><span class="p">,</span> <span class="n">scriptptr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">major_version</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="cm">/* pre BIT */</span>
		<span class="n">compare_record_len</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">compare_record_len</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">compareclk</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">clktable</span> <span class="o">+</span> <span class="n">compare_record_len</span> <span class="o">*</span> <span class="n">i</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pxclk</span> <span class="o">&gt;=</span> <span class="n">compareclk</span> <span class="o">*</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">major_version</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
				<span class="kt">uint8_t</span> <span class="n">tmdssub</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">clktable</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">compare_record_len</span> <span class="o">*</span> <span class="n">i</span><span class="p">];</span>
				<span class="n">scriptptr</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">init_script_tbls_ptr</span> <span class="o">+</span> <span class="n">tmdssub</span> <span class="o">*</span> <span class="mi">2</span><span class="p">]);</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="n">scriptptr</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">clktable</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">compare_record_len</span> <span class="o">*</span> <span class="n">i</span><span class="p">]);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">i</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">compareclk</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">scriptptr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">run_digital_op_script</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">scriptptr</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">dcb_entry</span> <span class="o">*</span><span class="n">dcbent</span><span class="p">,</span> <span class="kt">int</span> <span class="n">head</span><span class="p">,</span> <span class="n">bool</span> <span class="n">dl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_nouveau_private</span> <span class="o">*</span><span class="n">dev_priv</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">vbios</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">init_exec</span> <span class="n">iexec</span> <span class="o">=</span> <span class="p">{</span><span class="nb">true</span><span class="p">,</span> <span class="nb">false</span><span class="p">};</span>

	<span class="n">NV_TRACE</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;0x%04X: Parsing digital output script table</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">scriptptr</span><span class="p">);</span>
	<span class="n">bios_idxprt_wr</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">NV_CIO_CRX__COLOR</span><span class="p">,</span> <span class="n">NV_CIO_CRE_44</span><span class="p">,</span>
		       <span class="n">head</span> <span class="o">?</span> <span class="n">NV_CIO_CRE_44_HEADB</span> <span class="o">:</span> <span class="n">NV_CIO_CRE_44_HEADA</span><span class="p">);</span>
	<span class="cm">/* note: if dcb entries have been merged, index may be misleading */</span>
	<span class="n">NVWriteVgaCrtc5758</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dcbent</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>
	<span class="n">parse_init_table</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">scriptptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iexec</span><span class="p">);</span>

	<span class="n">nv04_dfp_bind_head</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">dcbent</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">dl</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">call_lvds_manufacturer_script</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dcb_entry</span> <span class="o">*</span><span class="n">dcbent</span><span class="p">,</span> <span class="kt">int</span> <span class="n">head</span><span class="p">,</span> <span class="k">enum</span> <span class="n">LVDS_script</span> <span class="n">script</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_nouveau_private</span> <span class="o">*</span><span class="n">dev_priv</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">vbios</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">sub</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">.</span><span class="n">xlated_entry</span> <span class="o">+</span> <span class="n">script</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">.</span><span class="n">link_c_increment</span> <span class="o">&amp;&amp;</span> <span class="n">dcbent</span><span class="o">-&gt;</span><span class="n">or</span> <span class="o">&amp;</span> <span class="n">OUTPUT_C</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
	<span class="kt">uint16_t</span> <span class="n">scriptofs</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">init_script_tbls_ptr</span> <span class="o">+</span> <span class="n">sub</span> <span class="o">*</span> <span class="mi">2</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">.</span><span class="n">xlated_entry</span> <span class="o">||</span> <span class="o">!</span><span class="n">sub</span> <span class="o">||</span> <span class="o">!</span><span class="n">scriptofs</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">run_digital_op_script</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">scriptofs</span><span class="p">,</span> <span class="n">dcbent</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">.</span><span class="n">dual_link</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">script</span> <span class="o">==</span> <span class="n">LVDS_PANEL_OFF</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* off-on delay in ms */</span>
		<span class="n">mdelay</span><span class="p">(</span><span class="n">ROM16</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">.</span><span class="n">xlated_entry</span> <span class="o">+</span> <span class="mi">7</span><span class="p">]));</span>
	<span class="p">}</span>
<span class="cp">#ifdef __powerpc__</span>
	<span class="cm">/* Powerbook specific quirks */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">script</span> <span class="o">==</span> <span class="n">LVDS_RESET</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pci_device</span> <span class="o">==</span> <span class="mh">0x0179</span> <span class="o">||</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">pci_device</span> <span class="o">==</span> <span class="mh">0x0189</span> <span class="o">||</span>
	     <span class="n">dev</span><span class="o">-&gt;</span><span class="n">pci_device</span> <span class="o">==</span> <span class="mh">0x0329</span><span class="p">))</span>
		<span class="n">nv_write_tmds</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">dcbent</span><span class="o">-&gt;</span><span class="n">or</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x02</span><span class="p">,</span> <span class="mh">0x72</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">run_lvds_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dcb_entry</span> <span class="o">*</span><span class="n">dcbent</span><span class="p">,</span> <span class="kt">int</span> <span class="n">head</span><span class="p">,</span> <span class="k">enum</span> <span class="n">LVDS_script</span> <span class="n">script</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pxclk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * The BIT LVDS table&#39;s header has the information to setup the</span>
<span class="cm">	 * necessary registers. Following the standard 4 byte header are:</span>
<span class="cm">	 * A bitmask byte and a dual-link transition pxclk value for use in</span>
<span class="cm">	 * selecting the init script when not using straps; 4 script pointers</span>
<span class="cm">	 * for panel power, selected by output and on/off; and 8 table pointers</span>
<span class="cm">	 * for panel init, the needed one determined by output, and bits in the</span>
<span class="cm">	 * conf byte. These tables are similar to the TMDS tables, consisting</span>
<span class="cm">	 * of a list of pxclks and script pointers.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">drm_nouveau_private</span> <span class="o">*</span><span class="n">dev_priv</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">vbios</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">outputset</span> <span class="o">=</span> <span class="p">(</span><span class="n">dcbent</span><span class="o">-&gt;</span><span class="n">or</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">scriptptr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">clktable</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * For now we assume version 3.0 table - g80 support will need some</span>
<span class="cm">	 * changes</span>
<span class="cm">	 */</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">script</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">LVDS_INIT</span>:
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LVDS_BACKLIGHT_ON</span>:
	<span class="k">case</span> <span class="n">LVDS_PANEL_ON</span>:
		<span class="n">scriptptr</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">.</span><span class="n">lvdsmanufacturerpointer</span> <span class="o">+</span> <span class="mi">7</span> <span class="o">+</span> <span class="n">outputset</span> <span class="o">*</span> <span class="mi">2</span><span class="p">]);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LVDS_BACKLIGHT_OFF</span>:
	<span class="k">case</span> <span class="n">LVDS_PANEL_OFF</span>:
		<span class="n">scriptptr</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">.</span><span class="n">lvdsmanufacturerpointer</span> <span class="o">+</span> <span class="mi">11</span> <span class="o">+</span> <span class="n">outputset</span> <span class="o">*</span> <span class="mi">2</span><span class="p">]);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LVDS_RESET</span>:
		<span class="n">clktable</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">.</span><span class="n">lvdsmanufacturerpointer</span> <span class="o">+</span> <span class="mi">15</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dcbent</span><span class="o">-&gt;</span><span class="n">or</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span>
			<span class="n">clktable</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">dcbent</span><span class="o">-&gt;</span><span class="n">lvdsconf</span><span class="p">.</span><span class="n">use_straps_for_mode</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">.</span><span class="n">dual_link</span><span class="p">)</span>
				<span class="n">clktable</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">.</span><span class="n">if_is_24bit</span><span class="p">)</span>
				<span class="n">clktable</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* using EDID */</span>
			<span class="kt">int</span> <span class="n">cmpval_24bit</span> <span class="o">=</span> <span class="p">(</span><span class="n">dcbent</span><span class="o">-&gt;</span><span class="n">or</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span> <span class="o">?</span> <span class="mi">4</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">.</span><span class="n">dual_link</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">clktable</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
				<span class="n">cmpval_24bit</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">.</span><span class="n">strapless_is_24bit</span> <span class="o">&amp;</span> <span class="n">cmpval_24bit</span><span class="p">)</span>
				<span class="n">clktable</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">clktable</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">clktable</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clktable</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">NV_ERROR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Pixel clock comparison table not found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">scriptptr</span> <span class="o">=</span> <span class="n">clkcmptable</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">clktable</span><span class="p">,</span> <span class="n">pxclk</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">scriptptr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">NV_ERROR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;LVDS output init script not found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">run_digital_op_script</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">scriptptr</span><span class="p">,</span> <span class="n">dcbent</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">.</span><span class="n">dual_link</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">call_lvds_script</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dcb_entry</span> <span class="o">*</span><span class="n">dcbent</span><span class="p">,</span> <span class="kt">int</span> <span class="n">head</span><span class="p">,</span> <span class="k">enum</span> <span class="n">LVDS_script</span> <span class="n">script</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pxclk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * LVDS operations are multiplexed in an effort to present a single API</span>
<span class="cm">	 * which works with two vastly differing underlying structures.</span>
<span class="cm">	 * This acts as the demux</span>
<span class="cm">	 */</span>

	<span class="k">struct</span> <span class="n">drm_nouveau_private</span> <span class="o">*</span><span class="n">dev_priv</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">vbios</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">lvds_ver</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">.</span><span class="n">lvdsmanufacturerpointer</span><span class="p">];</span>
	<span class="kt">uint32_t</span> <span class="n">sel_clk_binding</span><span class="p">,</span> <span class="n">sel_clk</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">.</span><span class="n">last_script_invoc</span> <span class="o">==</span> <span class="p">(</span><span class="n">script</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span> <span class="o">|</span> <span class="n">head</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">lvds_ver</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">lvds_ver</span> <span class="o">&gt;=</span> <span class="mh">0x30</span> <span class="o">&amp;&amp;</span> <span class="n">script</span> <span class="o">==</span> <span class="n">LVDS_INIT</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">.</span><span class="n">lvds_init_run</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bios</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">.</span><span class="n">lvds_init_run</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">call_lvds_script</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">dcbent</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">LVDS_INIT</span><span class="p">,</span> <span class="n">pxclk</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">script</span> <span class="o">==</span> <span class="n">LVDS_PANEL_ON</span> <span class="o">&amp;&amp;</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">.</span><span class="n">reset_after_pclk_change</span><span class="p">)</span>
		<span class="n">call_lvds_script</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">dcbent</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">LVDS_RESET</span><span class="p">,</span> <span class="n">pxclk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">script</span> <span class="o">==</span> <span class="n">LVDS_RESET</span> <span class="o">&amp;&amp;</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">.</span><span class="n">power_off_for_reset</span><span class="p">)</span>
		<span class="n">call_lvds_script</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">dcbent</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">LVDS_PANEL_OFF</span><span class="p">,</span> <span class="n">pxclk</span><span class="p">);</span>

	<span class="n">NV_TRACE</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Calling LVDS script %d:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">script</span><span class="p">);</span>

	<span class="cm">/* don&#39;t let script change pll-&gt;head binding */</span>
	<span class="n">sel_clk_binding</span> <span class="o">=</span> <span class="n">bios_rd32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">NV_PRAMDAC_SEL_CLK</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x50000</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lvds_ver</span> <span class="o">&lt;</span> <span class="mh">0x30</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">call_lvds_manufacturer_script</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">dcbent</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">script</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">run_lvds_table</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">dcbent</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">script</span><span class="p">,</span> <span class="n">pxclk</span><span class="p">);</span>

	<span class="n">bios</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">.</span><span class="n">last_script_invoc</span> <span class="o">=</span> <span class="p">(</span><span class="n">script</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span> <span class="o">|</span> <span class="n">head</span><span class="p">);</span>

	<span class="n">sel_clk</span> <span class="o">=</span> <span class="n">NVReadRAMDAC</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">NV_PRAMDAC_SEL_CLK</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x50000</span><span class="p">;</span>
	<span class="n">NVWriteRAMDAC</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">NV_PRAMDAC_SEL_CLK</span><span class="p">,</span> <span class="n">sel_clk</span> <span class="o">|</span> <span class="n">sel_clk_binding</span><span class="p">);</span>
	<span class="cm">/* some scripts set a value in NV_PBUS_POWERCTRL_2 and break video overlay */</span>
	<span class="n">nvWriteMC</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">NV_PBUS_POWERCTRL_2</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">lvdstableheader</span> <span class="p">{</span>
	<span class="kt">uint8_t</span> <span class="n">lvds_ver</span><span class="p">,</span> <span class="n">headerlen</span><span class="p">,</span> <span class="n">recordlen</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">parse_lvds_manufacturer_table_header</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lvdstableheader</span> <span class="o">*</span><span class="n">lth</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * BMP version (0xa) LVDS table has a simple header of version and</span>
<span class="cm">	 * record length. The BIT LVDS table has the typical BIT table header:</span>
<span class="cm">	 * version byte, header length byte, record length byte, and a byte for</span>
<span class="cm">	 * the maximum number of records that can be held in the table.</span>
<span class="cm">	 */</span>

	<span class="kt">uint8_t</span> <span class="n">lvds_ver</span><span class="p">,</span> <span class="n">headerlen</span><span class="p">,</span> <span class="n">recordlen</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">lth</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lvdstableheader</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">.</span><span class="n">lvdsmanufacturerpointer</span> <span class="o">==</span> <span class="mh">0x0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">NV_ERROR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Pointer to LVDS manufacturer table invalid</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lvds_ver</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">.</span><span class="n">lvdsmanufacturerpointer</span><span class="p">];</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">lvds_ver</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mh">0x0a</span>:	<span class="cm">/* pre NV40 */</span>
		<span class="n">headerlen</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">recordlen</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">.</span><span class="n">lvdsmanufacturerpointer</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x30</span>:	<span class="cm">/* NV4x */</span>
		<span class="n">headerlen</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">.</span><span class="n">lvdsmanufacturerpointer</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">headerlen</span> <span class="o">&lt;</span> <span class="mh">0x1f</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">NV_ERROR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;LVDS table header not understood</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">recordlen</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">.</span><span class="n">lvdsmanufacturerpointer</span> <span class="o">+</span> <span class="mi">2</span><span class="p">];</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x40</span>:	<span class="cm">/* G80/G90 */</span>
		<span class="n">headerlen</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">.</span><span class="n">lvdsmanufacturerpointer</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">headerlen</span> <span class="o">&lt;</span> <span class="mh">0x7</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">NV_ERROR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;LVDS table header not understood</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">recordlen</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">.</span><span class="n">lvdsmanufacturerpointer</span> <span class="o">+</span> <span class="mi">2</span><span class="p">];</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">NV_ERROR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
			 <span class="s">&quot;LVDS table revision %d.%d not currently supported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">lvds_ver</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">,</span> <span class="n">lvds_ver</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lth</span><span class="o">-&gt;</span><span class="n">lvds_ver</span> <span class="o">=</span> <span class="n">lvds_ver</span><span class="p">;</span>
	<span class="n">lth</span><span class="o">-&gt;</span><span class="n">headerlen</span> <span class="o">=</span> <span class="n">headerlen</span><span class="p">;</span>
	<span class="n">lth</span><span class="o">-&gt;</span><span class="n">recordlen</span> <span class="o">=</span> <span class="n">recordlen</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">get_fp_strap</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_nouveau_private</span> <span class="o">*</span><span class="n">dev_priv</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_private</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The fp strap is normally dictated by the &quot;User Strap&quot; in</span>
<span class="cm">	 * PEXTDEV_BOOT_0[20:16], but on BMP cards when bit 2 of the</span>
<span class="cm">	 * Internal_Flags struct at 0x48 is set, the user strap gets overriden</span>
<span class="cm">	 * by the PCI subsystem ID during POST, but not before the previous user</span>
<span class="cm">	 * strap has been committed to CR58 for CR57=0xf on head A, which may be</span>
<span class="cm">	 * read and used instead</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">major_version</span> <span class="o">&lt;</span> <span class="mi">5</span> <span class="o">&amp;&amp;</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mh">0x48</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x4</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NVReadVgaCrtc5758</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0xf</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">card_type</span> <span class="o">&gt;=</span> <span class="n">NV_50</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">bios_rd32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">NV_PEXTDEV_BOOT_0</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">bios_rd32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">NV_PEXTDEV_BOOT_0</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">parse_fp_mode_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">fptable</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">fptable_ver</span><span class="p">,</span> <span class="n">headerlen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">recordlen</span><span class="p">,</span> <span class="n">fpentries</span> <span class="o">=</span> <span class="mh">0xf</span><span class="p">,</span> <span class="n">fpindex</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">ofs</span><span class="p">,</span> <span class="n">fpstrapping</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lvdstableheader</span> <span class="n">lth</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">.</span><span class="n">fptablepointer</span> <span class="o">==</span> <span class="mh">0x0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Apple cards don&#39;t have the fp table; the laptops use DDC */</span>
		<span class="cm">/* The table is also missing on some x86 IGPs */</span>
<span class="cp">#ifndef __powerpc__</span>
		<span class="n">NV_ERROR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Pointer to flat panel table invalid</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="n">bios</span><span class="o">-&gt;</span><span class="n">digital_min_front_porch</span> <span class="o">=</span> <span class="mh">0x4b</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">fptable</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">.</span><span class="n">fptablepointer</span><span class="p">];</span>
	<span class="n">fptable_ver</span> <span class="o">=</span> <span class="n">fptable</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">fptable_ver</span><span class="p">)</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * BMP version 0x5.0x11 BIOSen have version 1 like tables, but no</span>
<span class="cm">	 * version field, and miss one of the spread spectrum/PWM bytes.</span>
<span class="cm">	 * This could affect early GF2Go parts (not seen any appropriate ROMs</span>
<span class="cm">	 * though). Here we assume that a version of 0x05 matches this case</span>
<span class="cm">	 * (combining with a BMP version check would be better), as the</span>
<span class="cm">	 * common case for the panel type field is 0x0005, and that is in</span>
<span class="cm">	 * fact what we are reading the first byte of.</span>
<span class="cm">	 */</span>
	<span class="k">case</span> <span class="mh">0x05</span>:	<span class="cm">/* some NV10, 11, 15, 16 */</span>
		<span class="n">recordlen</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
		<span class="n">ofs</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x10</span>:	<span class="cm">/* some NV15/16, and NV11+ */</span>
		<span class="n">recordlen</span> <span class="o">=</span> <span class="mi">44</span><span class="p">;</span>
		<span class="n">ofs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x20</span>:	<span class="cm">/* NV40+ */</span>
		<span class="n">headerlen</span> <span class="o">=</span> <span class="n">fptable</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
		<span class="n">recordlen</span> <span class="o">=</span> <span class="n">fptable</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
		<span class="n">fpentries</span> <span class="o">=</span> <span class="n">fptable</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
		<span class="cm">/*</span>
<span class="cm">		 * fptable[4] is the minimum</span>
<span class="cm">		 * RAMDAC_FP_HCRTC -&gt; RAMDAC_FP_HSYNC_START gap</span>
<span class="cm">		 */</span>
		<span class="n">bios</span><span class="o">-&gt;</span><span class="n">digital_min_front_porch</span> <span class="o">=</span> <span class="n">fptable</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
		<span class="n">ofs</span> <span class="o">=</span> <span class="o">-</span><span class="mi">7</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">NV_ERROR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
			 <span class="s">&quot;FP table revision %d.%d not currently supported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">fptable_ver</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">,</span> <span class="n">fptable_ver</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">is_mobile</span><span class="p">)</span> <span class="cm">/* !mobile only needs digital_min_front_porch */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">parse_lvds_manufacturer_table_header</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">bios</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lth</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lth</span><span class="p">.</span><span class="n">lvds_ver</span> <span class="o">==</span> <span class="mh">0x30</span> <span class="o">||</span> <span class="n">lth</span><span class="p">.</span><span class="n">lvds_ver</span> <span class="o">==</span> <span class="mh">0x40</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bios</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">.</span><span class="n">fpxlatetableptr</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">.</span><span class="n">lvdsmanufacturerpointer</span> <span class="o">+</span>
							<span class="n">lth</span><span class="p">.</span><span class="n">headerlen</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">bios</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">.</span><span class="n">xlatwidth</span> <span class="o">=</span> <span class="n">lth</span><span class="p">.</span><span class="n">recordlen</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">.</span><span class="n">fpxlatetableptr</span> <span class="o">==</span> <span class="mh">0x0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">NV_ERROR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Pointer to flat panel xlat table invalid</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">fpstrapping</span> <span class="o">=</span> <span class="n">get_fp_strap</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">bios</span><span class="p">);</span>

	<span class="n">fpindex</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">.</span><span class="n">fpxlatetableptr</span> <span class="o">+</span>
					<span class="n">fpstrapping</span> <span class="o">*</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">.</span><span class="n">xlatwidth</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fpindex</span> <span class="o">&gt;</span> <span class="n">fpentries</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">NV_ERROR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Bad flat panel table index</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* nv4x cards need both a strap value and fpindex of 0xf to use DDC */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lth</span><span class="p">.</span><span class="n">lvds_ver</span> <span class="o">&gt;</span> <span class="mh">0x10</span><span class="p">)</span>
		<span class="n">bios</span><span class="o">-&gt;</span><span class="n">fp_no_ddc</span> <span class="o">=</span> <span class="n">fpstrapping</span> <span class="o">!=</span> <span class="mh">0xf</span> <span class="o">||</span> <span class="n">fpindex</span> <span class="o">!=</span> <span class="mh">0xf</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If either the strap or xlated fpindex value are 0xf there is no</span>
<span class="cm">	 * panel using a strap-derived bios mode present.  this condition</span>
<span class="cm">	 * includes, but is different from, the DDC panel indicator above</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fpstrapping</span> <span class="o">==</span> <span class="mh">0xf</span> <span class="o">||</span> <span class="n">fpindex</span> <span class="o">==</span> <span class="mh">0xf</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">bios</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">.</span><span class="n">mode_ptr</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">.</span><span class="n">fptablepointer</span> <span class="o">+</span> <span class="n">headerlen</span> <span class="o">+</span>
			    <span class="n">recordlen</span> <span class="o">*</span> <span class="n">fpindex</span> <span class="o">+</span> <span class="n">ofs</span><span class="p">;</span>

	<span class="n">NV_TRACE</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;BIOS FP mode: %dx%d (%dkHz pixel clock)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">ROM16</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">.</span><span class="n">mode_ptr</span> <span class="o">+</span> <span class="mi">11</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
		 <span class="n">ROM16</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">.</span><span class="n">mode_ptr</span> <span class="o">+</span> <span class="mi">25</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
		 <span class="n">ROM16</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">.</span><span class="n">mode_ptr</span> <span class="o">+</span> <span class="mi">7</span><span class="p">])</span> <span class="o">*</span> <span class="mi">10</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">bool</span> <span class="nf">nouveau_bios_fp_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_nouveau_private</span> <span class="o">*</span><span class="n">dev_priv</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">vbios</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">mode_entry</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">.</span><span class="n">mode_ptr</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mode</span><span class="p">)</span>	<span class="cm">/* just checking whether we can produce a mode */</span>
		<span class="k">return</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">.</span><span class="n">mode_ptr</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_display_mode</span><span class="p">));</span>
	<span class="cm">/*</span>
<span class="cm">	 * For version 1.0 (version in byte 0):</span>
<span class="cm">	 * bytes 1-2 are &quot;panel type&quot;, including bits on whether Colour/mono,</span>
<span class="cm">	 * single/dual link, and type (TFT etc.)</span>
<span class="cm">	 * bytes 3-6 are bits per colour in RGBX</span>
<span class="cm">	 */</span>
	<span class="n">mode</span><span class="o">-&gt;</span><span class="n">clock</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">mode_entry</span><span class="p">[</span><span class="mi">7</span><span class="p">])</span> <span class="o">*</span> <span class="mi">10</span><span class="p">;</span>
	<span class="cm">/* bytes 9-10 is HActive */</span>
	<span class="n">mode</span><span class="o">-&gt;</span><span class="n">hdisplay</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">mode_entry</span><span class="p">[</span><span class="mi">11</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * bytes 13-14 is HValid Start</span>
<span class="cm">	 * bytes 15-16 is HValid End</span>
<span class="cm">	 */</span>
	<span class="n">mode</span><span class="o">-&gt;</span><span class="n">hsync_start</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">mode_entry</span><span class="p">[</span><span class="mi">17</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">mode</span><span class="o">-&gt;</span><span class="n">hsync_end</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">mode_entry</span><span class="p">[</span><span class="mi">19</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">mode</span><span class="o">-&gt;</span><span class="n">htotal</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">mode_entry</span><span class="p">[</span><span class="mi">21</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/* bytes 23-24, 27-30 similarly, but vertical */</span>
	<span class="n">mode</span><span class="o">-&gt;</span><span class="n">vdisplay</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">mode_entry</span><span class="p">[</span><span class="mi">25</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">mode</span><span class="o">-&gt;</span><span class="n">vsync_start</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">mode_entry</span><span class="p">[</span><span class="mi">31</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">mode</span><span class="o">-&gt;</span><span class="n">vsync_end</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">mode_entry</span><span class="p">[</span><span class="mi">33</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">mode</span><span class="o">-&gt;</span><span class="n">vtotal</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">mode_entry</span><span class="p">[</span><span class="mi">35</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">mode</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="p">(</span><span class="n">mode_entry</span><span class="p">[</span><span class="mi">37</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x10</span><span class="p">)</span> <span class="o">?</span>
			<span class="n">DRM_MODE_FLAG_PHSYNC</span> <span class="o">:</span> <span class="n">DRM_MODE_FLAG_NHSYNC</span><span class="p">;</span>
	<span class="n">mode</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="p">(</span><span class="n">mode_entry</span><span class="p">[</span><span class="mi">37</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span> <span class="o">?</span>
			<span class="n">DRM_MODE_FLAG_PVSYNC</span> <span class="o">:</span> <span class="n">DRM_MODE_FLAG_NVSYNC</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * bytes 38-39 relate to spread spectrum settings</span>
<span class="cm">	 * bytes 40-43 are something to do with PWM</span>
<span class="cm">	 */</span>

	<span class="n">mode</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">MODE_OK</span><span class="p">;</span>
	<span class="n">mode</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">DRM_MODE_TYPE_DRIVER</span> <span class="o">|</span> <span class="n">DRM_MODE_TYPE_PREFERRED</span><span class="p">;</span>
	<span class="n">drm_mode_set_name</span><span class="p">(</span><span class="n">mode</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">.</span><span class="n">mode_ptr</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">nouveau_bios_parse_lvds_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pxclk</span><span class="p">,</span> <span class="n">bool</span> <span class="o">*</span><span class="n">dl</span><span class="p">,</span> <span class="n">bool</span> <span class="o">*</span><span class="n">if_is_24bit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * The LVDS table header is (mostly) described in</span>
<span class="cm">	 * parse_lvds_manufacturer_table_header(): the BIT header additionally</span>
<span class="cm">	 * contains the dual-link transition pxclk (in 10s kHz), at byte 5 - if</span>
<span class="cm">	 * straps are not being used for the panel, this specifies the frequency</span>
<span class="cm">	 * at which modes should be set up in the dual link style.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Following the header, the BMP (ver 0xa) table has several records,</span>
<span class="cm">	 * indexed by a separate xlat table, indexed in turn by the fp strap in</span>
<span class="cm">	 * EXTDEV_BOOT. Each record had a config byte, followed by 6 script</span>
<span class="cm">	 * numbers for use by INIT_SUB which controlled panel init and power,</span>
<span class="cm">	 * and finally a dword of ms to sleep between power off and on</span>
<span class="cm">	 * operations.</span>
<span class="cm">	 *</span>
<span class="cm">	 * In the BIT versions, the table following the header serves as an</span>
<span class="cm">	 * integrated config and xlat table: the records in the table are</span>
<span class="cm">	 * indexed by the FP strap nibble in EXTDEV_BOOT, and each record has</span>
<span class="cm">	 * two bytes - the first as a config byte, the second for indexing the</span>
<span class="cm">	 * fp mode table pointed to by the BIT &#39;D&#39; table</span>
<span class="cm">	 *</span>
<span class="cm">	 * DDC is not used until after card init, so selecting the correct table</span>
<span class="cm">	 * entry and setting the dual link flag for EDID equipped panels,</span>
<span class="cm">	 * requiring tests against the native-mode pixel clock, cannot be done</span>
<span class="cm">	 * until later, when this function should be called with non-zero pxclk</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">drm_nouveau_private</span> <span class="o">*</span><span class="n">dev_priv</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">vbios</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fpstrapping</span> <span class="o">=</span> <span class="n">get_fp_strap</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">bios</span><span class="p">),</span> <span class="n">lvdsmanufacturerindex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lvdstableheader</span> <span class="n">lth</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">lvdsofs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">chip_version</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">chip_version</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">parse_lvds_manufacturer_table_header</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">bios</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lth</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">lth</span><span class="p">.</span><span class="n">lvds_ver</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mh">0x0a</span>:	<span class="cm">/* pre NV40 */</span>
		<span class="n">lvdsmanufacturerindex</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span>
					<span class="n">bios</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">.</span><span class="n">fpxlatemanufacturertableptr</span> <span class="o">+</span>
					<span class="n">fpstrapping</span><span class="p">];</span>

		<span class="cm">/* we&#39;re done if this isn&#39;t the EDID panel case */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pxclk</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">chip_version</span> <span class="o">&lt;</span> <span class="mh">0x25</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* nv17 behaviour</span>
<span class="cm">			 *</span>
<span class="cm">			 * It seems the old style lvds script pointer is reused</span>
<span class="cm">			 * to select 18/24 bit colour depth for EDID panels.</span>
<span class="cm">			 */</span>
			<span class="n">lvdsmanufacturerindex</span> <span class="o">=</span>
				<span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">legacy</span><span class="p">.</span><span class="n">lvds_single_a_script_ptr</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">?</span>
									<span class="mi">2</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pxclk</span> <span class="o">&gt;=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">.</span><span class="n">duallink_transition_clk</span><span class="p">)</span>
				<span class="n">lvdsmanufacturerindex</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">chip_version</span> <span class="o">&lt;</span> <span class="mh">0x30</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* nv28 behaviour (off-chip encoder)</span>
<span class="cm">			 *</span>
<span class="cm">			 * nv28 does a complex dance of first using byte 121 of</span>
<span class="cm">			 * the EDID to choose the lvdsmanufacturerindex, then</span>
<span class="cm">			 * later attempting to match the EDID manufacturer and</span>
<span class="cm">			 * product IDs in a table (signature &#39;pidt&#39; (panel id</span>
<span class="cm">			 * table?)), setting an lvdsmanufacturerindex of 0 and</span>
<span class="cm">			 * an fp strap of the match index (or 0xf if none)</span>
<span class="cm">			 */</span>
			<span class="n">lvdsmanufacturerindex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* nv31, nv34 behaviour */</span>
			<span class="n">lvdsmanufacturerindex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pxclk</span> <span class="o">&gt;=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">.</span><span class="n">duallink_transition_clk</span><span class="p">)</span>
				<span class="n">lvdsmanufacturerindex</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pxclk</span> <span class="o">&gt;=</span> <span class="mi">140000</span><span class="p">)</span>
				<span class="n">lvdsmanufacturerindex</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * nvidia set the high nibble of (cr57=f, cr58) to</span>
<span class="cm">		 * lvdsmanufacturerindex in this case; we don&#39;t</span>
<span class="cm">		 */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x30</span>:	<span class="cm">/* NV4x */</span>
	<span class="k">case</span> <span class="mh">0x40</span>:	<span class="cm">/* G80/G90 */</span>
		<span class="n">lvdsmanufacturerindex</span> <span class="o">=</span> <span class="n">fpstrapping</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">NV_ERROR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;LVDS table revision not currently supported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lvdsofs</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">.</span><span class="n">xlated_entry</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">.</span><span class="n">lvdsmanufacturerpointer</span> <span class="o">+</span> <span class="n">lth</span><span class="p">.</span><span class="n">headerlen</span> <span class="o">+</span> <span class="n">lth</span><span class="p">.</span><span class="n">recordlen</span> <span class="o">*</span> <span class="n">lvdsmanufacturerindex</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">lth</span><span class="p">.</span><span class="n">lvds_ver</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mh">0x0a</span>:
		<span class="n">bios</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">.</span><span class="n">power_off_for_reset</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">lvdsofs</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">bios</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">.</span><span class="n">reset_after_pclk_change</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">lvdsofs</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">bios</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">.</span><span class="n">dual_link</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">lvdsofs</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mi">4</span><span class="p">;</span>
		<span class="n">bios</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">.</span><span class="n">link_c_increment</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">lvdsofs</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mi">8</span><span class="p">;</span>
		<span class="o">*</span><span class="n">if_is_24bit</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">lvdsofs</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x30</span>:
	<span class="k">case</span> <span class="mh">0x40</span>:
		<span class="cm">/*</span>
<span class="cm">		 * No sign of the &quot;power off for reset&quot; or &quot;reset for panel</span>
<span class="cm">		 * on&quot; bits, but it&#39;s safer to assume we should</span>
<span class="cm">		 */</span>
		<span class="n">bios</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">.</span><span class="n">power_off_for_reset</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">bios</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">.</span><span class="n">reset_after_pclk_change</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * It&#39;s ok lvdsofs is wrong for nv4x edid case; dual_link is</span>
<span class="cm">		 * over-written, and if_is_24bit isn&#39;t used</span>
<span class="cm">		 */</span>
		<span class="n">bios</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">.</span><span class="n">dual_link</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">lvdsofs</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">bios</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">.</span><span class="n">if_is_24bit</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">lvdsofs</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">bios</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">.</span><span class="n">strapless_is_24bit</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">.</span><span class="n">lvdsmanufacturerpointer</span> <span class="o">+</span> <span class="mi">4</span><span class="p">];</span>
		<span class="n">bios</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">.</span><span class="n">duallink_transition_clk</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">.</span><span class="n">lvdsmanufacturerpointer</span> <span class="o">+</span> <span class="mi">5</span><span class="p">])</span> <span class="o">*</span> <span class="mi">10</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* set dual_link flag for EDID case */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pxclk</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">chip_version</span> <span class="o">&lt;</span> <span class="mh">0x25</span> <span class="o">||</span> <span class="n">chip_version</span> <span class="o">&gt;</span> <span class="mh">0x28</span><span class="p">))</span>
		<span class="n">bios</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">.</span><span class="n">dual_link</span> <span class="o">=</span> <span class="p">(</span><span class="n">pxclk</span> <span class="o">&gt;=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">.</span><span class="n">duallink_transition_clk</span><span class="p">);</span>

	<span class="o">*</span><span class="n">dl</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">.</span><span class="n">dual_link</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* BIT &#39;U&#39;/&#39;d&#39; table encoder subtables have hashes matching them to</span>
<span class="cm"> * a particular set of encoders.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns true if a particular DCB entry matches.</span>
<span class="cm"> */</span>
<span class="n">bool</span>
<span class="nf">bios_encoder_match</span><span class="p">(</span><span class="k">struct</span> <span class="n">dcb_entry</span> <span class="o">*</span><span class="n">dcb</span><span class="p">,</span> <span class="n">u32</span> <span class="n">hash</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">hash</span> <span class="o">&amp;</span> <span class="mh">0x000000f0</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="n">dcb</span><span class="o">-&gt;</span><span class="n">location</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">hash</span> <span class="o">&amp;</span> <span class="mh">0x0000000f</span><span class="p">)</span> <span class="o">!=</span> <span class="n">dcb</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">hash</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">dcb</span><span class="o">-&gt;</span><span class="n">or</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">dcb</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">OUTPUT_TMDS</span>:
	<span class="k">case</span> <span class="n">OUTPUT_LVDS</span>:
	<span class="k">case</span> <span class="n">OUTPUT_DP</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">hash</span> <span class="o">&amp;</span> <span class="mh">0x00c00000</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">hash</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">dcb</span><span class="o">-&gt;</span><span class="n">sorconf</span><span class="p">.</span><span class="n">link</span> <span class="o">&lt;&lt;</span> <span class="mi">22</span><span class="p">)))</span>
				<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">nouveau_bios_run_display_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u16</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pclk</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">dcb_entry</span> <span class="o">*</span><span class="n">dcbent</span><span class="p">,</span> <span class="kt">int</span> <span class="n">crtc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * The display script table is located by the BIT &#39;U&#39; table.</span>
<span class="cm">	 *</span>
<span class="cm">	 * It contains an array of pointers to various tables describing</span>
<span class="cm">	 * a particular output type.  The first 32-bits of the output</span>
<span class="cm">	 * tables contains similar information to a DCB entry, and is</span>
<span class="cm">	 * used to decide whether that particular table is suitable for</span>
<span class="cm">	 * the output you want to access.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The &quot;record header length&quot; field here seems to indicate the</span>
<span class="cm">	 * offset of the first configuration entry in the output tables.</span>
<span class="cm">	 * This is 10 on most cards I&#39;ve seen, but 12 has been witnessed</span>
<span class="cm">	 * on DP cards, and there&#39;s another script pointer within the</span>
<span class="cm">	 * header.</span>
<span class="cm">	 *</span>
<span class="cm">	 * offset + 0   ( 8 bits): version</span>
<span class="cm">	 * offset + 1   ( 8 bits): header length</span>
<span class="cm">	 * offset + 2   ( 8 bits): record length</span>
<span class="cm">	 * offset + 3   ( 8 bits): number of records</span>
<span class="cm">	 * offset + 4   ( 8 bits): record header length</span>
<span class="cm">	 * offset + 5   (16 bits): pointer to first output script table</span>
<span class="cm">	 */</span>

	<span class="k">struct</span> <span class="n">drm_nouveau_private</span> <span class="o">*</span><span class="n">dev_priv</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">vbios</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">table</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">display</span><span class="p">.</span><span class="n">script_table_ptr</span><span class="p">];</span>
	<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">otable</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">script</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">display</span><span class="p">.</span><span class="n">script_table_ptr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">NV_ERROR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;No pointer to output script table</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Nothing useful has been in any of the pre-2.0 tables I&#39;ve seen,</span>
<span class="cm">	 * so until they are, we really don&#39;t need to care.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">table</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mh">0x20</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">table</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mh">0x20</span> <span class="o">&amp;&amp;</span> <span class="n">table</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mh">0x21</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">NV_ERROR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Output script table version 0x%02x unknown</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">table</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * The output script tables describing a particular output type</span>
<span class="cm">	 * look as follows:</span>
<span class="cm">	 *</span>
<span class="cm">	 * offset + 0   (32 bits): output this table matches (hash of DCB)</span>
<span class="cm">	 * offset + 4   ( 8 bits): unknown</span>
<span class="cm">	 * offset + 5   ( 8 bits): number of configurations</span>
<span class="cm">	 * offset + 6   (16 bits): pointer to some script</span>
<span class="cm">	 * offset + 8   (16 bits): pointer to some script</span>
<span class="cm">	 *</span>
<span class="cm">	 * headerlen == 10</span>
<span class="cm">	 * offset + 10           : configuration 0</span>
<span class="cm">	 *</span>
<span class="cm">	 * headerlen == 12</span>
<span class="cm">	 * offset + 10           : pointer to some script</span>
<span class="cm">	 * offset + 12           : configuration 0</span>
<span class="cm">	 *</span>
<span class="cm">	 * Each config entry is as follows:</span>
<span class="cm">	 *</span>
<span class="cm">	 * offset + 0   (16 bits): unknown, assumed to be a match value</span>
<span class="cm">	 * offset + 2   (16 bits): pointer to script table (clock set?)</span>
<span class="cm">	 * offset + 4   (16 bits): pointer to script table (reset?)</span>
<span class="cm">	 *</span>
<span class="cm">	 * There doesn&#39;t appear to be a count value to say how many</span>
<span class="cm">	 * entries exist in each script table, instead, a 0 value in</span>
<span class="cm">	 * the first 16-bit word seems to indicate both the end of the</span>
<span class="cm">	 * list and the default entry.  The second 16-bit word in the</span>
<span class="cm">	 * script tables is a pointer to the script to execute.</span>
<span class="cm">	 */</span>

	<span class="n">NV_DEBUG_KMS</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Searching for output entry for %d %d %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">dcbent</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span> <span class="n">dcbent</span><span class="o">-&gt;</span><span class="n">location</span><span class="p">,</span> <span class="n">dcbent</span><span class="o">-&gt;</span><span class="n">or</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">table</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">otable</span> <span class="o">=</span> <span class="n">ROMPTR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">table</span><span class="p">[</span><span class="n">table</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">table</span><span class="p">[</span><span class="mi">2</span><span class="p">])]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">otable</span> <span class="o">&amp;&amp;</span> <span class="n">bios_encoder_match</span><span class="p">(</span><span class="n">dcbent</span><span class="p">,</span> <span class="n">ROM32</span><span class="p">(</span><span class="n">otable</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">otable</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">NV_DEBUG_KMS</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed to match any output table</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pclk</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span> <span class="o">||</span> <span class="n">pclk</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Try to find matching script table entry */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">otable</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ROM16</span><span class="p">(</span><span class="n">otable</span><span class="p">[</span><span class="n">table</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="mi">6</span><span class="p">])</span> <span class="o">==</span> <span class="n">type</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">otable</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">NV_ERROR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Table 0x%04x not found for %d/%d, &quot;</span>
				      <span class="s">&quot;using first</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">type</span><span class="p">,</span> <span class="n">dcbent</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span> <span class="n">dcbent</span><span class="o">-&gt;</span><span class="n">or</span><span class="p">);</span>
			<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pclk</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">script</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">otable</span><span class="p">[</span><span class="mi">6</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">script</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">NV_DEBUG_KMS</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;output script 0 not found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">NV_DEBUG_KMS</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;0x%04X: parsing output script 0</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">script</span><span class="p">);</span>
		<span class="n">nouveau_bios_run_init_table</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">script</span><span class="p">,</span> <span class="n">dcbent</span><span class="p">,</span> <span class="n">crtc</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pclk</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">script</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">otable</span><span class="p">[</span><span class="mi">8</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">script</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">NV_DEBUG_KMS</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;output script 1 not found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">NV_DEBUG_KMS</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;0x%04X: parsing output script 1</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">script</span><span class="p">);</span>
		<span class="n">nouveau_bios_run_init_table</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">script</span><span class="p">,</span> <span class="n">dcbent</span><span class="p">,</span> <span class="n">crtc</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pclk</span> <span class="o">==</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">table</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">12</span><span class="p">)</span>
			<span class="n">script</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">otable</span><span class="p">[</span><span class="mi">10</span><span class="p">]);</span>
		<span class="k">else</span>
			<span class="n">script</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">script</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">NV_DEBUG_KMS</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;output script 2 not found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">NV_DEBUG_KMS</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;0x%04X: parsing output script 2</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">script</span><span class="p">);</span>
		<span class="n">nouveau_bios_run_init_table</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">script</span><span class="p">,</span> <span class="n">dcbent</span><span class="p">,</span> <span class="n">crtc</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pclk</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">script</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">otable</span><span class="p">[</span><span class="n">table</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="mi">6</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">script</span><span class="p">)</span>
			<span class="n">script</span> <span class="o">=</span> <span class="n">clkcmptable</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">script</span><span class="p">,</span> <span class="n">pclk</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">script</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">NV_DEBUG_KMS</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;clock script 0 not found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">NV_DEBUG_KMS</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;0x%04X: parsing clock script 0</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">script</span><span class="p">);</span>
		<span class="n">nouveau_bios_run_init_table</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">script</span><span class="p">,</span> <span class="n">dcbent</span><span class="p">,</span> <span class="n">crtc</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pclk</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">script</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">otable</span><span class="p">[</span><span class="n">table</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="mi">6</span> <span class="o">+</span> <span class="mi">4</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">script</span><span class="p">)</span>
			<span class="n">script</span> <span class="o">=</span> <span class="n">clkcmptable</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">script</span><span class="p">,</span> <span class="o">-</span><span class="n">pclk</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">script</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">NV_DEBUG_KMS</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;clock script 1 not found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">NV_DEBUG_KMS</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;0x%04X: parsing clock script 1</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">script</span><span class="p">);</span>
		<span class="n">nouveau_bios_run_init_table</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">script</span><span class="p">,</span> <span class="n">dcbent</span><span class="p">,</span> <span class="n">crtc</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">run_tmds_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dcb_entry</span> <span class="o">*</span><span class="n">dcbent</span><span class="p">,</span> <span class="kt">int</span> <span class="n">head</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pxclk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * the pxclk parameter is in kHz</span>
<span class="cm">	 *</span>
<span class="cm">	 * This runs the TMDS regs setting code found on BIT bios cards</span>
<span class="cm">	 *</span>
<span class="cm">	 * For ffs(or) == 1 use the first table, for ffs(or) == 2 and</span>
<span class="cm">	 * ffs(or) == 3, use the second.</span>
<span class="cm">	 */</span>

	<span class="k">struct</span> <span class="n">drm_nouveau_private</span> <span class="o">*</span><span class="n">dev_priv</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">vbios</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cv</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">chip_version</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">clktable</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">scriptptr</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">sel_clk_binding</span><span class="p">,</span> <span class="n">sel_clk</span><span class="p">;</span>

	<span class="cm">/* pre-nv17 off-chip tmds uses scripts, post nv17 doesn&#39;t */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cv</span> <span class="o">&gt;=</span> <span class="mh">0x17</span> <span class="o">&amp;&amp;</span> <span class="n">cv</span> <span class="o">!=</span> <span class="mh">0x1a</span> <span class="o">&amp;&amp;</span> <span class="n">cv</span> <span class="o">!=</span> <span class="mh">0x20</span> <span class="o">&amp;&amp;</span>
	    <span class="n">dcbent</span><span class="o">-&gt;</span><span class="n">location</span> <span class="o">!=</span> <span class="n">DCB_LOC_ON_CHIP</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">ffs</span><span class="p">(</span><span class="n">dcbent</span><span class="o">-&gt;</span><span class="n">or</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="n">clktable</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">tmds</span><span class="p">.</span><span class="n">output0_script_ptr</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>:
	<span class="k">case</span> <span class="mi">3</span>:
		<span class="n">clktable</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">tmds</span><span class="p">.</span><span class="n">output1_script_ptr</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clktable</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">NV_ERROR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Pixel clock comparison table not found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">scriptptr</span> <span class="o">=</span> <span class="n">clkcmptable</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">clktable</span><span class="p">,</span> <span class="n">pxclk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">scriptptr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">NV_ERROR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;TMDS output init script not found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* don&#39;t let script change pll-&gt;head binding */</span>
	<span class="n">sel_clk_binding</span> <span class="o">=</span> <span class="n">bios_rd32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">NV_PRAMDAC_SEL_CLK</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x50000</span><span class="p">;</span>
	<span class="n">run_digital_op_script</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">scriptptr</span><span class="p">,</span> <span class="n">dcbent</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">pxclk</span> <span class="o">&gt;=</span> <span class="mi">165000</span><span class="p">);</span>
	<span class="n">sel_clk</span> <span class="o">=</span> <span class="n">NVReadRAMDAC</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">NV_PRAMDAC_SEL_CLK</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x50000</span><span class="p">;</span>
	<span class="n">NVWriteRAMDAC</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">NV_PRAMDAC_SEL_CLK</span><span class="p">,</span> <span class="n">sel_clk</span> <span class="o">|</span> <span class="n">sel_clk_binding</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">pll_mapping</span> <span class="p">{</span>
	<span class="n">u8</span>  <span class="n">type</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reg</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pll_mapping</span> <span class="n">nv04_pll_mapping</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">PLL_CORE</span>  <span class="p">,</span> <span class="n">NV_PRAMDAC_NVPLL_COEFF</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PLL_MEMORY</span><span class="p">,</span> <span class="n">NV_PRAMDAC_MPLL_COEFF</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PLL_VPLL0</span> <span class="p">,</span> <span class="n">NV_PRAMDAC_VPLL_COEFF</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PLL_VPLL1</span> <span class="p">,</span> <span class="n">NV_RAMDAC_VPLL2</span> <span class="p">},</span>
	<span class="p">{}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pll_mapping</span> <span class="n">nv40_pll_mapping</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">PLL_CORE</span>  <span class="p">,</span> <span class="mh">0x004000</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PLL_MEMORY</span><span class="p">,</span> <span class="mh">0x004020</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PLL_VPLL0</span> <span class="p">,</span> <span class="n">NV_PRAMDAC_VPLL_COEFF</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PLL_VPLL1</span> <span class="p">,</span> <span class="n">NV_RAMDAC_VPLL2</span> <span class="p">},</span>
	<span class="p">{}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pll_mapping</span> <span class="n">nv50_pll_mapping</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">PLL_CORE</span>  <span class="p">,</span> <span class="mh">0x004028</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PLL_SHADER</span><span class="p">,</span> <span class="mh">0x004020</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PLL_UNK03</span> <span class="p">,</span> <span class="mh">0x004000</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PLL_MEMORY</span><span class="p">,</span> <span class="mh">0x004008</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PLL_UNK40</span> <span class="p">,</span> <span class="mh">0x00e810</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PLL_UNK41</span> <span class="p">,</span> <span class="mh">0x00e818</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PLL_UNK42</span> <span class="p">,</span> <span class="mh">0x00e824</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PLL_VPLL0</span> <span class="p">,</span> <span class="mh">0x614100</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PLL_VPLL1</span> <span class="p">,</span> <span class="mh">0x614900</span> <span class="p">},</span>
	<span class="p">{}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pll_mapping</span> <span class="n">nv84_pll_mapping</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">PLL_CORE</span>  <span class="p">,</span> <span class="mh">0x004028</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PLL_SHADER</span><span class="p">,</span> <span class="mh">0x004020</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PLL_MEMORY</span><span class="p">,</span> <span class="mh">0x004008</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PLL_VDEC</span>  <span class="p">,</span> <span class="mh">0x004030</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PLL_UNK41</span> <span class="p">,</span> <span class="mh">0x00e818</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PLL_VPLL0</span> <span class="p">,</span> <span class="mh">0x614100</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PLL_VPLL1</span> <span class="p">,</span> <span class="mh">0x614900</span> <span class="p">},</span>
	<span class="p">{}</span>
<span class="p">};</span>

<span class="n">u32</span>
<span class="nf">get_pll_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">enum</span> <span class="n">pll_types</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_nouveau_private</span> <span class="o">*</span><span class="n">dev_priv</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">vbios</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pll_mapping</span> <span class="o">*</span><span class="n">map</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">card_type</span> <span class="o">&lt;</span> <span class="n">NV_40</span><span class="p">)</span>
		<span class="n">map</span> <span class="o">=</span> <span class="n">nv04_pll_mapping</span><span class="p">;</span>
	<span class="k">else</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">card_type</span> <span class="o">&lt;</span> <span class="n">NV_50</span><span class="p">)</span>
		<span class="n">map</span> <span class="o">=</span> <span class="n">nv40_pll_mapping</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">u8</span> <span class="o">*</span><span class="n">plim</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">pll_limit_tbl_ptr</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">plim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mh">0x30</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u8</span> <span class="o">*</span><span class="n">entry</span> <span class="o">=</span> <span class="n">plim</span> <span class="o">+</span> <span class="n">plim</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">plim</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">entry</span> <span class="o">+=</span> <span class="n">plim</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">type</span><span class="p">)</span>
					<span class="k">return</span> <span class="n">ROM32</span><span class="p">(</span><span class="n">entry</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
			<span class="p">}</span>

			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">chipset</span> <span class="o">==</span> <span class="mh">0x50</span><span class="p">)</span>
			<span class="n">map</span> <span class="o">=</span> <span class="n">nv50_pll_mapping</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">map</span> <span class="o">=</span> <span class="n">nv84_pll_mapping</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">reg</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">type</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">reg</span><span class="p">;</span>
		<span class="n">map</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">get_pll_limits</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">limit_match</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pll_lims</span> <span class="o">*</span><span class="n">pll_lim</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * PLL limits table</span>
<span class="cm">	 *</span>
<span class="cm">	 * Version 0x10: NV30, NV31</span>
<span class="cm">	 * One byte header (version), one record of 24 bytes</span>
<span class="cm">	 * Version 0x11: NV36 - Not implemented</span>
<span class="cm">	 * Seems to have same record style as 0x10, but 3 records rather than 1</span>
<span class="cm">	 * Version 0x20: Found on Geforce 6 cards</span>
<span class="cm">	 * Trivial 4 byte BIT header. 31 (0x1f) byte record length</span>
<span class="cm">	 * Version 0x21: Found on Geforce 7, 8 and some Geforce 6 cards</span>
<span class="cm">	 * 5 byte header, fifth byte of unknown purpose. 35 (0x23) byte record</span>
<span class="cm">	 * length in general, some (integrated) have an extra configuration byte</span>
<span class="cm">	 * Version 0x30: Found on Geforce 8, separates the register mapping</span>
<span class="cm">	 * from the limits tables.</span>
<span class="cm">	 */</span>

	<span class="k">struct</span> <span class="n">drm_nouveau_private</span> <span class="o">*</span><span class="n">dev_priv</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">vbios</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cv</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">chip_version</span><span class="p">,</span> <span class="n">pllindex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">pll_lim_ver</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">headerlen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">recordlen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">entries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">crystal_strap_mask</span><span class="p">,</span> <span class="n">crystal_straps</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">pll_limit_tbl_ptr</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cv</span> <span class="o">==</span> <span class="mh">0x30</span> <span class="o">||</span> <span class="n">cv</span> <span class="o">==</span> <span class="mh">0x31</span> <span class="o">||</span> <span class="n">cv</span> <span class="o">==</span> <span class="mh">0x35</span> <span class="o">||</span> <span class="n">cv</span> <span class="o">==</span> <span class="mh">0x36</span> <span class="o">||</span>
		    <span class="n">cv</span> <span class="o">&gt;=</span> <span class="mh">0x40</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">NV_ERROR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Pointer to PLL limits table invalid</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">pll_lim_ver</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">pll_limit_tbl_ptr</span><span class="p">];</span>

	<span class="n">crystal_strap_mask</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">;</span>
	<span class="cm">/* open coded dev-&gt;twoHeads test */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cv</span> <span class="o">&gt;</span> <span class="mh">0x10</span> <span class="o">&amp;&amp;</span> <span class="n">cv</span> <span class="o">!=</span> <span class="mh">0x15</span> <span class="o">&amp;&amp;</span> <span class="n">cv</span> <span class="o">!=</span> <span class="mh">0x1a</span> <span class="o">&amp;&amp;</span> <span class="n">cv</span> <span class="o">!=</span> <span class="mh">0x20</span><span class="p">)</span>
		<span class="n">crystal_strap_mask</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">22</span><span class="p">;</span>
	<span class="n">crystal_straps</span> <span class="o">=</span> <span class="n">nvReadEXTDEV</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">NV_PEXTDEV_BOOT_0</span><span class="p">)</span> <span class="o">&amp;</span>
							<span class="n">crystal_strap_mask</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">pll_lim_ver</span><span class="p">)</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * We use version 0 to indicate a pre limit table bios (single stage</span>
<span class="cm">	 * pll) and load the hard coded limits instead.</span>
<span class="cm">	 */</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x10</span>:
	<span class="k">case</span> <span class="mh">0x11</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Strictly v0x11 has 3 entries, but the last two don&#39;t seem</span>
<span class="cm">		 * to get used.</span>
<span class="cm">		 */</span>
		<span class="n">headerlen</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">recordlen</span> <span class="o">=</span> <span class="mh">0x18</span><span class="p">;</span>
		<span class="n">entries</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">pllindex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x20</span>:
	<span class="k">case</span> <span class="mh">0x21</span>:
	<span class="k">case</span> <span class="mh">0x30</span>:
	<span class="k">case</span> <span class="mh">0x40</span>:
		<span class="n">headerlen</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">pll_limit_tbl_ptr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
		<span class="n">recordlen</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">pll_limit_tbl_ptr</span> <span class="o">+</span> <span class="mi">2</span><span class="p">];</span>
		<span class="n">entries</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">pll_limit_tbl_ptr</span> <span class="o">+</span> <span class="mi">3</span><span class="p">];</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">NV_ERROR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;PLL limits table revision 0x%X not currently &quot;</span>
				<span class="s">&quot;supported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pll_lim_ver</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* initialize all members to zero */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">pll_lim</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pll_lims</span><span class="p">));</span>

	<span class="cm">/* if we were passed a type rather than a register, figure</span>
<span class="cm">	 * out the register and store it</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">limit_match</span> <span class="o">&gt;</span> <span class="n">PLL_MAX</span><span class="p">)</span>
		<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">reg</span> <span class="o">=</span> <span class="n">limit_match</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">reg</span> <span class="o">=</span> <span class="n">get_pll_register</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">limit_match</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">reg</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pll_lim_ver</span> <span class="o">==</span> <span class="mh">0x10</span> <span class="o">||</span> <span class="n">pll_lim_ver</span> <span class="o">==</span> <span class="mh">0x11</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">pll_rec</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">pll_limit_tbl_ptr</span> <span class="o">+</span> <span class="n">headerlen</span> <span class="o">+</span> <span class="n">recordlen</span> <span class="o">*</span> <span class="n">pllindex</span><span class="p">];</span>

		<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco1</span><span class="p">.</span><span class="n">minfreq</span> <span class="o">=</span> <span class="n">ROM32</span><span class="p">(</span><span class="n">pll_rec</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco1</span><span class="p">.</span><span class="n">maxfreq</span> <span class="o">=</span> <span class="n">ROM32</span><span class="p">(</span><span class="n">pll_rec</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span>
		<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco2</span><span class="p">.</span><span class="n">minfreq</span> <span class="o">=</span> <span class="n">ROM32</span><span class="p">(</span><span class="n">pll_rec</span><span class="p">[</span><span class="mi">8</span><span class="p">]);</span>
		<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco2</span><span class="p">.</span><span class="n">maxfreq</span> <span class="o">=</span> <span class="n">ROM32</span><span class="p">(</span><span class="n">pll_rec</span><span class="p">[</span><span class="mi">12</span><span class="p">]);</span>
		<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco1</span><span class="p">.</span><span class="n">min_inputfreq</span> <span class="o">=</span> <span class="n">ROM32</span><span class="p">(</span><span class="n">pll_rec</span><span class="p">[</span><span class="mi">16</span><span class="p">]);</span>
		<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco2</span><span class="p">.</span><span class="n">min_inputfreq</span> <span class="o">=</span> <span class="n">ROM32</span><span class="p">(</span><span class="n">pll_rec</span><span class="p">[</span><span class="mi">20</span><span class="p">]);</span>
		<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco1</span><span class="p">.</span><span class="n">max_inputfreq</span> <span class="o">=</span> <span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco2</span><span class="p">.</span><span class="n">max_inputfreq</span> <span class="o">=</span> <span class="n">INT_MAX</span><span class="p">;</span>

		<span class="cm">/* these values taken from nv30/31/36 */</span>
		<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco1</span><span class="p">.</span><span class="n">min_n</span> <span class="o">=</span> <span class="mh">0x1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cv</span> <span class="o">==</span> <span class="mh">0x36</span><span class="p">)</span>
			<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco1</span><span class="p">.</span><span class="n">min_n</span> <span class="o">=</span> <span class="mh">0x5</span><span class="p">;</span>
		<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco1</span><span class="p">.</span><span class="n">max_n</span> <span class="o">=</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco1</span><span class="p">.</span><span class="n">min_m</span> <span class="o">=</span> <span class="mh">0x1</span><span class="p">;</span>
		<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco1</span><span class="p">.</span><span class="n">max_m</span> <span class="o">=</span> <span class="mh">0xd</span><span class="p">;</span>
		<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco2</span><span class="p">.</span><span class="n">min_n</span> <span class="o">=</span> <span class="mh">0x4</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * On nv30, 31, 36 (i.e. all cards with two stage PLLs with this</span>
<span class="cm">		 * table version (apart from nv35)), N2 is compared to</span>
<span class="cm">		 * maxN2 (0x46) and 10 * maxM2 (0x4), so set maxN2 to 0x28 and</span>
<span class="cm">		 * save a comparison</span>
<span class="cm">		 */</span>
		<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco2</span><span class="p">.</span><span class="n">max_n</span> <span class="o">=</span> <span class="mh">0x28</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cv</span> <span class="o">==</span> <span class="mh">0x30</span> <span class="o">||</span> <span class="n">cv</span> <span class="o">==</span> <span class="mh">0x35</span><span class="p">)</span>
			<span class="cm">/* only 5 bits available for N2 on nv30/35 */</span>
			<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco2</span><span class="p">.</span><span class="n">max_n</span> <span class="o">=</span> <span class="mh">0x1f</span><span class="p">;</span>
		<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco2</span><span class="p">.</span><span class="n">min_m</span> <span class="o">=</span> <span class="mh">0x1</span><span class="p">;</span>
		<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco2</span><span class="p">.</span><span class="n">max_m</span> <span class="o">=</span> <span class="mh">0x4</span><span class="p">;</span>
		<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">max_log2p</span> <span class="o">=</span> <span class="mh">0x7</span><span class="p">;</span>
		<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">max_usable_log2p</span> <span class="o">=</span> <span class="mh">0x6</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pll_lim_ver</span> <span class="o">==</span> <span class="mh">0x20</span> <span class="o">||</span> <span class="n">pll_lim_ver</span> <span class="o">==</span> <span class="mh">0x21</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">uint16_t</span> <span class="n">plloffs</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">pll_limit_tbl_ptr</span> <span class="o">+</span> <span class="n">headerlen</span><span class="p">;</span>
		<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">pll_rec</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * First entry is default match, if nothing better. warn if</span>
<span class="cm">		 * reg field nonzero</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ROM32</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">plloffs</span><span class="p">]))</span>
			<span class="n">NV_WARN</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Default PLL limit entry has non-zero &quot;</span>
				       <span class="s">&quot;register field</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">entries</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ROM32</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">plloffs</span> <span class="o">+</span> <span class="n">recordlen</span> <span class="o">*</span> <span class="n">i</span><span class="p">])</span> <span class="o">==</span> <span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">reg</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pllindex</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">card_type</span> <span class="o">&gt;=</span> <span class="n">NV_50</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">pllindex</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">NV_ERROR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Register 0x%08x not found in PLL &quot;</span>
				 <span class="s">&quot;limits table&quot;</span><span class="p">,</span> <span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">reg</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">pll_rec</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">plloffs</span> <span class="o">+</span> <span class="n">recordlen</span> <span class="o">*</span> <span class="n">pllindex</span><span class="p">];</span>

		<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;Loading PLL limits for reg 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">pllindex</span> <span class="o">?</span> <span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">reg</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Frequencies are stored in tables in MHz, kHz are more</span>
<span class="cm">		 * useful, so we convert.</span>
<span class="cm">		 */</span>

		<span class="cm">/* What output frequencies can each VCO generate? */</span>
		<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco1</span><span class="p">.</span><span class="n">minfreq</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">pll_rec</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">;</span>
		<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco1</span><span class="p">.</span><span class="n">maxfreq</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">pll_rec</span><span class="p">[</span><span class="mi">6</span><span class="p">])</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">;</span>
		<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco2</span><span class="p">.</span><span class="n">minfreq</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">pll_rec</span><span class="p">[</span><span class="mi">8</span><span class="p">])</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">;</span>
		<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco2</span><span class="p">.</span><span class="n">maxfreq</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">pll_rec</span><span class="p">[</span><span class="mi">10</span><span class="p">])</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">;</span>

		<span class="cm">/* What input frequencies they accept (past the m-divider)? */</span>
		<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco1</span><span class="p">.</span><span class="n">min_inputfreq</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">pll_rec</span><span class="p">[</span><span class="mi">12</span><span class="p">])</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">;</span>
		<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco2</span><span class="p">.</span><span class="n">min_inputfreq</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">pll_rec</span><span class="p">[</span><span class="mi">14</span><span class="p">])</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">;</span>
		<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco1</span><span class="p">.</span><span class="n">max_inputfreq</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">pll_rec</span><span class="p">[</span><span class="mi">16</span><span class="p">])</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">;</span>
		<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco2</span><span class="p">.</span><span class="n">max_inputfreq</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">pll_rec</span><span class="p">[</span><span class="mi">18</span><span class="p">])</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">;</span>

		<span class="cm">/* What values are accepted as multiplier and divider? */</span>
		<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco1</span><span class="p">.</span><span class="n">min_n</span> <span class="o">=</span> <span class="n">pll_rec</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>
		<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco1</span><span class="p">.</span><span class="n">max_n</span> <span class="o">=</span> <span class="n">pll_rec</span><span class="p">[</span><span class="mi">21</span><span class="p">];</span>
		<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco1</span><span class="p">.</span><span class="n">min_m</span> <span class="o">=</span> <span class="n">pll_rec</span><span class="p">[</span><span class="mi">22</span><span class="p">];</span>
		<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco1</span><span class="p">.</span><span class="n">max_m</span> <span class="o">=</span> <span class="n">pll_rec</span><span class="p">[</span><span class="mi">23</span><span class="p">];</span>
		<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco2</span><span class="p">.</span><span class="n">min_n</span> <span class="o">=</span> <span class="n">pll_rec</span><span class="p">[</span><span class="mi">24</span><span class="p">];</span>
		<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco2</span><span class="p">.</span><span class="n">max_n</span> <span class="o">=</span> <span class="n">pll_rec</span><span class="p">[</span><span class="mi">25</span><span class="p">];</span>
		<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco2</span><span class="p">.</span><span class="n">min_m</span> <span class="o">=</span> <span class="n">pll_rec</span><span class="p">[</span><span class="mi">26</span><span class="p">];</span>
		<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco2</span><span class="p">.</span><span class="n">max_m</span> <span class="o">=</span> <span class="n">pll_rec</span><span class="p">[</span><span class="mi">27</span><span class="p">];</span>

		<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">max_usable_log2p</span> <span class="o">=</span> <span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">max_log2p</span> <span class="o">=</span> <span class="n">pll_rec</span><span class="p">[</span><span class="mi">29</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">max_log2p</span> <span class="o">&gt;</span> <span class="mh">0x7</span><span class="p">)</span>
			<span class="cm">/* pll decoding in nv_hw.c assumes never &gt; 7 */</span>
			<span class="n">NV_WARN</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Max log2 P value greater than 7 (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">max_log2p</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cv</span> <span class="o">&lt;</span> <span class="mh">0x60</span><span class="p">)</span>
			<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">max_usable_log2p</span> <span class="o">=</span> <span class="mh">0x6</span><span class="p">;</span>
		<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">log2p_bias</span> <span class="o">=</span> <span class="n">pll_rec</span><span class="p">[</span><span class="mi">30</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">recordlen</span> <span class="o">&gt;</span> <span class="mh">0x22</span><span class="p">)</span>
			<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">refclk</span> <span class="o">=</span> <span class="n">ROM32</span><span class="p">(</span><span class="n">pll_rec</span><span class="p">[</span><span class="mi">31</span><span class="p">]);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">recordlen</span> <span class="o">&gt;</span> <span class="mh">0x23</span> <span class="o">&amp;&amp;</span> <span class="n">pll_rec</span><span class="p">[</span><span class="mi">35</span><span class="p">])</span>
			<span class="n">NV_WARN</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;Bits set in PLL configuration byte (%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">pll_rec</span><span class="p">[</span><span class="mi">35</span><span class="p">]);</span>

		<span class="cm">/* C51 special not seen elsewhere */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cv</span> <span class="o">==</span> <span class="mh">0x51</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">refclk</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">uint32_t</span> <span class="n">sel_clk</span> <span class="o">=</span> <span class="n">bios_rd32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">NV_PRAMDAC_SEL_CLK</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">((</span><span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">reg</span> <span class="o">==</span> <span class="n">NV_PRAMDAC_VPLL_COEFF</span> <span class="o">&amp;&amp;</span> <span class="n">sel_clk</span> <span class="o">&amp;</span> <span class="mh">0x20</span><span class="p">)</span> <span class="o">||</span>
			    <span class="p">(</span><span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">reg</span> <span class="o">==</span> <span class="n">NV_RAMDAC_VPLL2</span> <span class="o">&amp;&amp;</span> <span class="n">sel_clk</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">bios_idxprt_rd</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">NV_CIO_CRX__COLOR</span><span class="p">,</span> <span class="n">NV_CIO_CRE_CHIP_ID_INDEX</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mh">0xa3</span><span class="p">)</span>
					<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">refclk</span> <span class="o">=</span> <span class="mi">200000</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">refclk</span> <span class="o">=</span> <span class="mi">25000</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pll_lim_ver</span> <span class="o">==</span> <span class="mh">0x30</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ver 0x30 */</span>
		<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">entry</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">pll_limit_tbl_ptr</span> <span class="o">+</span> <span class="n">headerlen</span><span class="p">];</span>
		<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">record</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

		<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;Loading PLL limits for register 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">reg</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">entries</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">entry</span> <span class="o">+=</span> <span class="n">recordlen</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ROM32</span><span class="p">(</span><span class="n">entry</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="o">==</span> <span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">reg</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">record</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">ROM16</span><span class="p">(</span><span class="n">entry</span><span class="p">[</span><span class="mi">1</span><span class="p">])];</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">record</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">NV_ERROR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Register 0x%08x not found in PLL &quot;</span>
				 <span class="s">&quot;limits table&quot;</span><span class="p">,</span> <span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">reg</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco1</span><span class="p">.</span><span class="n">minfreq</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">record</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">;</span>
		<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco1</span><span class="p">.</span><span class="n">maxfreq</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">record</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">;</span>
		<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco2</span><span class="p">.</span><span class="n">minfreq</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">record</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">;</span>
		<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco2</span><span class="p">.</span><span class="n">maxfreq</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">record</span><span class="p">[</span><span class="mi">6</span><span class="p">])</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">;</span>
		<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco1</span><span class="p">.</span><span class="n">min_inputfreq</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">record</span><span class="p">[</span><span class="mi">8</span><span class="p">])</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">;</span>
		<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco2</span><span class="p">.</span><span class="n">min_inputfreq</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">record</span><span class="p">[</span><span class="mi">10</span><span class="p">])</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">;</span>
		<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco1</span><span class="p">.</span><span class="n">max_inputfreq</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">record</span><span class="p">[</span><span class="mi">12</span><span class="p">])</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">;</span>
		<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco2</span><span class="p">.</span><span class="n">max_inputfreq</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">record</span><span class="p">[</span><span class="mi">14</span><span class="p">])</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">;</span>
		<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco1</span><span class="p">.</span><span class="n">min_n</span> <span class="o">=</span> <span class="n">record</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
		<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco1</span><span class="p">.</span><span class="n">max_n</span> <span class="o">=</span> <span class="n">record</span><span class="p">[</span><span class="mi">17</span><span class="p">];</span>
		<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco1</span><span class="p">.</span><span class="n">min_m</span> <span class="o">=</span> <span class="n">record</span><span class="p">[</span><span class="mi">18</span><span class="p">];</span>
		<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco1</span><span class="p">.</span><span class="n">max_m</span> <span class="o">=</span> <span class="n">record</span><span class="p">[</span><span class="mi">19</span><span class="p">];</span>
		<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco2</span><span class="p">.</span><span class="n">min_n</span> <span class="o">=</span> <span class="n">record</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>
		<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco2</span><span class="p">.</span><span class="n">max_n</span> <span class="o">=</span> <span class="n">record</span><span class="p">[</span><span class="mi">21</span><span class="p">];</span>
		<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco2</span><span class="p">.</span><span class="n">min_m</span> <span class="o">=</span> <span class="n">record</span><span class="p">[</span><span class="mi">22</span><span class="p">];</span>
		<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco2</span><span class="p">.</span><span class="n">max_m</span> <span class="o">=</span> <span class="n">record</span><span class="p">[</span><span class="mi">23</span><span class="p">];</span>
		<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">max_usable_log2p</span> <span class="o">=</span> <span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">max_log2p</span> <span class="o">=</span> <span class="n">record</span><span class="p">[</span><span class="mi">25</span><span class="p">];</span>
		<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">log2p_bias</span> <span class="o">=</span> <span class="n">record</span><span class="p">[</span><span class="mi">27</span><span class="p">];</span>
		<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">refclk</span> <span class="o">=</span> <span class="n">ROM32</span><span class="p">(</span><span class="n">record</span><span class="p">[</span><span class="mi">28</span><span class="p">]);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pll_lim_ver</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ver 0x40 */</span>
		<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">entry</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">pll_limit_tbl_ptr</span> <span class="o">+</span> <span class="n">headerlen</span><span class="p">];</span>
		<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">record</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

		<span class="n">BIOSLOG</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="s">&quot;Loading PLL limits for register 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">reg</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">entries</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">entry</span> <span class="o">+=</span> <span class="n">recordlen</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ROM32</span><span class="p">(</span><span class="n">entry</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="o">==</span> <span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">reg</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">record</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">ROM16</span><span class="p">(</span><span class="n">entry</span><span class="p">[</span><span class="mi">1</span><span class="p">])];</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">record</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">NV_ERROR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Register 0x%08x not found in PLL &quot;</span>
				 <span class="s">&quot;limits table&quot;</span><span class="p">,</span> <span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">reg</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco1</span><span class="p">.</span><span class="n">minfreq</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">record</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">;</span>
		<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco1</span><span class="p">.</span><span class="n">maxfreq</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">record</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">;</span>
		<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco1</span><span class="p">.</span><span class="n">min_inputfreq</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">record</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">;</span>
		<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco1</span><span class="p">.</span><span class="n">max_inputfreq</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">record</span><span class="p">[</span><span class="mi">6</span><span class="p">])</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">;</span>
		<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco1</span><span class="p">.</span><span class="n">min_m</span> <span class="o">=</span> <span class="n">record</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
		<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco1</span><span class="p">.</span><span class="n">max_m</span> <span class="o">=</span> <span class="n">record</span><span class="p">[</span><span class="mi">9</span><span class="p">];</span>
		<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco1</span><span class="p">.</span><span class="n">min_n</span> <span class="o">=</span> <span class="n">record</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
		<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco1</span><span class="p">.</span><span class="n">max_n</span> <span class="o">=</span> <span class="n">record</span><span class="p">[</span><span class="mi">11</span><span class="p">];</span>
		<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">min_p</span> <span class="o">=</span> <span class="n">record</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>
		<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">max_p</span> <span class="o">=</span> <span class="n">record</span><span class="p">[</span><span class="mi">13</span><span class="p">];</span>
		<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">refclk</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">entry</span><span class="p">[</span><span class="mi">9</span><span class="p">])</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * By now any valid limit table ought to have set a max frequency for</span>
<span class="cm">	 * vco1, so if it&#39;s zero it&#39;s either a pre limit table bios, or one</span>
<span class="cm">	 * with an empty limit table (seen on nv18)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco1</span><span class="p">.</span><span class="n">maxfreq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco1</span><span class="p">.</span><span class="n">minfreq</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">fminvco</span><span class="p">;</span>
		<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco1</span><span class="p">.</span><span class="n">maxfreq</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">fmaxvco</span><span class="p">;</span>
		<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco1</span><span class="p">.</span><span class="n">min_inputfreq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco1</span><span class="p">.</span><span class="n">max_inputfreq</span> <span class="o">=</span> <span class="n">INT_MAX</span><span class="p">;</span>
		<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco1</span><span class="p">.</span><span class="n">min_n</span> <span class="o">=</span> <span class="mh">0x1</span><span class="p">;</span>
		<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco1</span><span class="p">.</span><span class="n">max_n</span> <span class="o">=</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco1</span><span class="p">.</span><span class="n">min_m</span> <span class="o">=</span> <span class="mh">0x1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">crystal_straps</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* nv05 does this, nv11 doesn&#39;t, nv10 unknown */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cv</span> <span class="o">&lt;</span> <span class="mh">0x11</span><span class="p">)</span>
				<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco1</span><span class="p">.</span><span class="n">min_m</span> <span class="o">=</span> <span class="mh">0x7</span><span class="p">;</span>
			<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco1</span><span class="p">.</span><span class="n">max_m</span> <span class="o">=</span> <span class="mh">0xd</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cv</span> <span class="o">&lt;</span> <span class="mh">0x11</span><span class="p">)</span>
				<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco1</span><span class="p">.</span><span class="n">min_m</span> <span class="o">=</span> <span class="mh">0x8</span><span class="p">;</span>
			<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco1</span><span class="p">.</span><span class="n">max_m</span> <span class="o">=</span> <span class="mh">0xe</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cv</span> <span class="o">&lt;</span> <span class="mh">0x17</span> <span class="o">||</span> <span class="n">cv</span> <span class="o">==</span> <span class="mh">0x1a</span> <span class="o">||</span> <span class="n">cv</span> <span class="o">==</span> <span class="mh">0x20</span><span class="p">)</span>
			<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">max_log2p</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">max_log2p</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
		<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">max_usable_log2p</span> <span class="o">=</span> <span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">max_log2p</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">refclk</span><span class="p">)</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">crystal_straps</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">0</span>:
			<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">refclk</span> <span class="o">=</span> <span class="mi">13500</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">)</span>:
			<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">refclk</span> <span class="o">=</span> <span class="mi">14318</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">22</span><span class="p">)</span>:
			<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">refclk</span> <span class="o">=</span> <span class="mi">27000</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">22</span> <span class="o">|</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">)</span>:
			<span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">refclk</span> <span class="o">=</span> <span class="mi">25000</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="n">NV_DEBUG</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;pll.vco1.minfreq: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco1</span><span class="p">.</span><span class="n">minfreq</span><span class="p">);</span>
	<span class="n">NV_DEBUG</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;pll.vco1.maxfreq: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco1</span><span class="p">.</span><span class="n">maxfreq</span><span class="p">);</span>
	<span class="n">NV_DEBUG</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;pll.vco1.min_inputfreq: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco1</span><span class="p">.</span><span class="n">min_inputfreq</span><span class="p">);</span>
	<span class="n">NV_DEBUG</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;pll.vco1.max_inputfreq: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco1</span><span class="p">.</span><span class="n">max_inputfreq</span><span class="p">);</span>
	<span class="n">NV_DEBUG</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;pll.vco1.min_n: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco1</span><span class="p">.</span><span class="n">min_n</span><span class="p">);</span>
	<span class="n">NV_DEBUG</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;pll.vco1.max_n: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco1</span><span class="p">.</span><span class="n">max_n</span><span class="p">);</span>
	<span class="n">NV_DEBUG</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;pll.vco1.min_m: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco1</span><span class="p">.</span><span class="n">min_m</span><span class="p">);</span>
	<span class="n">NV_DEBUG</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;pll.vco1.max_m: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco1</span><span class="p">.</span><span class="n">max_m</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco2</span><span class="p">.</span><span class="n">maxfreq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">NV_DEBUG</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;pll.vco2.minfreq: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco2</span><span class="p">.</span><span class="n">minfreq</span><span class="p">);</span>
		<span class="n">NV_DEBUG</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;pll.vco2.maxfreq: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco2</span><span class="p">.</span><span class="n">maxfreq</span><span class="p">);</span>
		<span class="n">NV_DEBUG</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;pll.vco2.min_inputfreq: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco2</span><span class="p">.</span><span class="n">min_inputfreq</span><span class="p">);</span>
		<span class="n">NV_DEBUG</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;pll.vco2.max_inputfreq: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco2</span><span class="p">.</span><span class="n">max_inputfreq</span><span class="p">);</span>
		<span class="n">NV_DEBUG</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;pll.vco2.min_n: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco2</span><span class="p">.</span><span class="n">min_n</span><span class="p">);</span>
		<span class="n">NV_DEBUG</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;pll.vco2.max_n: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco2</span><span class="p">.</span><span class="n">max_n</span><span class="p">);</span>
		<span class="n">NV_DEBUG</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;pll.vco2.min_m: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco2</span><span class="p">.</span><span class="n">min_m</span><span class="p">);</span>
		<span class="n">NV_DEBUG</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;pll.vco2.max_m: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">vco2</span><span class="p">.</span><span class="n">max_m</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">max_p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">NV_DEBUG</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;pll.max_log2p: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">max_log2p</span><span class="p">);</span>
		<span class="n">NV_DEBUG</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;pll.log2p_bias: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">log2p_bias</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">NV_DEBUG</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;pll.min_p: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">min_p</span><span class="p">);</span>
		<span class="n">NV_DEBUG</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;pll.max_p: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">max_p</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">NV_DEBUG</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;pll.refclk: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pll_lim</span><span class="o">-&gt;</span><span class="n">refclk</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">parse_bios_version</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * offset + 0  (8 bits): Micro version</span>
<span class="cm">	 * offset + 1  (8 bits): Minor version</span>
<span class="cm">	 * offset + 2  (8 bits): Chip version</span>
<span class="cm">	 * offset + 3  (8 bits): Major version</span>
<span class="cm">	 */</span>

	<span class="n">bios</span><span class="o">-&gt;</span><span class="n">major_version</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">3</span><span class="p">];</span>
	<span class="n">bios</span><span class="o">-&gt;</span><span class="n">chip_version</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">2</span><span class="p">];</span>
	<span class="n">NV_TRACE</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Bios version %02x.%02x.%02x.%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">3</span><span class="p">],</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">2</span><span class="p">],</span>
		 <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">parse_script_table_pointers</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Parses the init table segment for pointers used in script execution.</span>
<span class="cm">	 *</span>
<span class="cm">	 * offset + 0  (16 bits): init script tables pointer</span>
<span class="cm">	 * offset + 2  (16 bits): macro index table pointer</span>
<span class="cm">	 * offset + 4  (16 bits): macro table pointer</span>
<span class="cm">	 * offset + 6  (16 bits): condition table pointer</span>
<span class="cm">	 * offset + 8  (16 bits): io condition table pointer</span>
<span class="cm">	 * offset + 10 (16 bits): io flag condition table pointer</span>
<span class="cm">	 * offset + 12 (16 bits): init function table pointer</span>
<span class="cm">	 */</span>

	<span class="n">bios</span><span class="o">-&gt;</span><span class="n">init_script_tbls_ptr</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span><span class="p">]);</span>
	<span class="n">bios</span><span class="o">-&gt;</span><span class="n">macro_index_tbl_ptr</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]);</span>
	<span class="n">bios</span><span class="o">-&gt;</span><span class="n">macro_tbl_ptr</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">4</span><span class="p">]);</span>
	<span class="n">bios</span><span class="o">-&gt;</span><span class="n">condition_tbl_ptr</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">6</span><span class="p">]);</span>
	<span class="n">bios</span><span class="o">-&gt;</span><span class="n">io_condition_tbl_ptr</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]);</span>
	<span class="n">bios</span><span class="o">-&gt;</span><span class="n">io_flag_condition_tbl_ptr</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">10</span><span class="p">]);</span>
	<span class="n">bios</span><span class="o">-&gt;</span><span class="n">init_function_tbl_ptr</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">12</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">parse_bit_A_tbl_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bit_entry</span> <span class="o">*</span><span class="n">bitentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Parses the load detect values for g80 cards.</span>
<span class="cm">	 *</span>
<span class="cm">	 * offset + 0 (16 bits): loadval table pointer</span>
<span class="cm">	 */</span>

	<span class="kt">uint16_t</span> <span class="n">load_table_ptr</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">version</span><span class="p">,</span> <span class="n">headerlen</span><span class="p">,</span> <span class="n">entrylen</span><span class="p">,</span> <span class="n">num_entries</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bitentry</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">NV_ERROR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Do not understand BIT A table</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">load_table_ptr</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">bitentry</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">load_table_ptr</span> <span class="o">==</span> <span class="mh">0x0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">NV_DEBUG</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Pointer to BIT loadval table invalid</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">version</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">load_table_ptr</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">version</span> <span class="o">!=</span> <span class="mh">0x10</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">NV_ERROR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;BIT loadval table version %d.%d not supported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">version</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">,</span> <span class="n">version</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">headerlen</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">load_table_ptr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="n">entrylen</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">load_table_ptr</span> <span class="o">+</span> <span class="mi">2</span><span class="p">];</span>
	<span class="n">num_entries</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">load_table_ptr</span> <span class="o">+</span> <span class="mi">3</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">headerlen</span> <span class="o">!=</span> <span class="mi">4</span> <span class="o">||</span> <span class="n">entrylen</span> <span class="o">!=</span> <span class="mi">4</span> <span class="o">||</span> <span class="n">num_entries</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">NV_ERROR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Do not understand BIT loadval table</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* First entry is normal dac, 2nd tv-out perhaps? */</span>
	<span class="n">bios</span><span class="o">-&gt;</span><span class="n">dactestval</span> <span class="o">=</span> <span class="n">ROM32</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">load_table_ptr</span> <span class="o">+</span> <span class="n">headerlen</span><span class="p">])</span> <span class="o">&amp;</span> <span class="mh">0x3ff</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">parse_bit_C_tbl_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bit_entry</span> <span class="o">*</span><span class="n">bitentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * offset + 8  (16 bits): PLL limits table pointer</span>
<span class="cm">	 *</span>
<span class="cm">	 * There&#39;s more in here, but that&#39;s unknown.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bitentry</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">NV_ERROR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Do not understand BIT C table</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">bios</span><span class="o">-&gt;</span><span class="n">pll_limit_tbl_ptr</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">bitentry</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">parse_bit_display_tbl_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bit_entry</span> <span class="o">*</span><span class="n">bitentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Parses the flat panel table segment that the bit entry points to.</span>
<span class="cm">	 * Starting at bitentry-&gt;offset:</span>
<span class="cm">	 *</span>
<span class="cm">	 * offset + 0  (16 bits): ??? table pointer - seems to have 18 byte</span>
<span class="cm">	 * records beginning with a freq.</span>
<span class="cm">	 * offset + 2  (16 bits): mode table pointer</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bitentry</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">NV_ERROR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Do not understand BIT display table</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">bios</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">.</span><span class="n">fptablepointer</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">bitentry</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">parse_bit_init_tbl_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bit_entry</span> <span class="o">*</span><span class="n">bitentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Parses the init table segment that the bit entry points to.</span>
<span class="cm">	 *</span>
<span class="cm">	 * See parse_script_table_pointers for layout</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bitentry</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">&lt;</span> <span class="mi">14</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">NV_ERROR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Do not understand init table</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">parse_script_table_pointers</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">bitentry</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bitentry</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">&gt;=</span> <span class="mi">16</span><span class="p">)</span>
		<span class="n">bios</span><span class="o">-&gt;</span><span class="n">some_script_ptr</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">bitentry</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">14</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bitentry</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">&gt;=</span> <span class="mi">18</span><span class="p">)</span>
		<span class="n">bios</span><span class="o">-&gt;</span><span class="n">init96_tbl_ptr</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">bitentry</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">parse_bit_i_tbl_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bit_entry</span> <span class="o">*</span><span class="n">bitentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * BIT &#39;i&#39; (info?) table</span>
<span class="cm">	 *</span>
<span class="cm">	 * offset + 0  (32 bits): BIOS version dword (as in B table)</span>
<span class="cm">	 * offset + 5  (8  bits): BIOS feature byte (same as for BMP?)</span>
<span class="cm">	 * offset + 13 (16 bits): pointer to table containing DAC load</span>
<span class="cm">	 * detection comparison values</span>
<span class="cm">	 *</span>
<span class="cm">	 * There&#39;s other things in the table, purpose unknown</span>
<span class="cm">	 */</span>

	<span class="kt">uint16_t</span> <span class="n">daccmpoffset</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">dacver</span><span class="p">,</span> <span class="n">dacheaderlen</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bitentry</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">NV_ERROR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;BIT i table too short for needed information</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">parse_bios_version</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">bios</span><span class="p">,</span> <span class="n">bitentry</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * bit 4 seems to indicate a mobile bios (doesn&#39;t suffer from BMP&#39;s</span>
<span class="cm">	 * Quadro identity crisis), other bits possibly as for BMP feature byte</span>
<span class="cm">	 */</span>
	<span class="n">bios</span><span class="o">-&gt;</span><span class="n">feature_byte</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">bitentry</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">5</span><span class="p">];</span>
	<span class="n">bios</span><span class="o">-&gt;</span><span class="n">is_mobile</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">feature_byte</span> <span class="o">&amp;</span> <span class="n">FEATURE_MOBILE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bitentry</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">&lt;</span> <span class="mi">15</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">NV_WARN</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;BIT i table not long enough for DAC load &quot;</span>
			       <span class="s">&quot;detection comparison table</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">daccmpoffset</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">bitentry</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">13</span><span class="p">]);</span>

	<span class="cm">/* doesn&#39;t exist on g80 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">daccmpoffset</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The first value in the table, following the header, is the</span>
<span class="cm">	 * comparison value, the second entry is a comparison value for</span>
<span class="cm">	 * TV load detection.</span>
<span class="cm">	 */</span>

	<span class="n">dacver</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">daccmpoffset</span><span class="p">];</span>
	<span class="n">dacheaderlen</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">daccmpoffset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dacver</span> <span class="o">!=</span> <span class="mh">0x00</span> <span class="o">&amp;&amp;</span> <span class="n">dacver</span> <span class="o">!=</span> <span class="mh">0x10</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">NV_WARN</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;DAC load detection comparison table version &quot;</span>
			       <span class="s">&quot;%d.%d not known</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dacver</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">,</span> <span class="n">dacver</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">bios</span><span class="o">-&gt;</span><span class="n">dactestval</span> <span class="o">=</span> <span class="n">ROM32</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">daccmpoffset</span> <span class="o">+</span> <span class="n">dacheaderlen</span><span class="p">]);</span>
	<span class="n">bios</span><span class="o">-&gt;</span><span class="n">tvdactestval</span> <span class="o">=</span> <span class="n">ROM32</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">daccmpoffset</span> <span class="o">+</span> <span class="n">dacheaderlen</span> <span class="o">+</span> <span class="mi">4</span><span class="p">]);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">parse_bit_lvds_tbl_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bit_entry</span> <span class="o">*</span><span class="n">bitentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Parses the LVDS table segment that the bit entry points to.</span>
<span class="cm">	 * Starting at bitentry-&gt;offset:</span>
<span class="cm">	 *</span>
<span class="cm">	 * offset + 0  (16 bits): LVDS strap xlate table pointer</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bitentry</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">NV_ERROR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Do not understand BIT LVDS table</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * No idea if it&#39;s still called the LVDS manufacturer table, but</span>
<span class="cm">	 * the concept&#39;s close enough.</span>
<span class="cm">	 */</span>
	<span class="n">bios</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">.</span><span class="n">lvdsmanufacturerpointer</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">bitentry</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">]);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">parse_bit_M_tbl_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">bit_entry</span> <span class="o">*</span><span class="n">bitentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * offset + 2  (8  bits): number of options in an</span>
<span class="cm">	 * 	INIT_RAM_RESTRICT_ZM_REG_GROUP opcode option set</span>
<span class="cm">	 * offset + 3  (16 bits): pointer to strap xlate table for RAM</span>
<span class="cm">	 * 	restrict option selection</span>
<span class="cm">	 *</span>
<span class="cm">	 * There&#39;s a bunch of bits in this table other than the RAM restrict</span>
<span class="cm">	 * stuff that we don&#39;t use - their use currently unknown</span>
<span class="cm">	 */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Older bios versions don&#39;t have a sufficiently long table for</span>
<span class="cm">	 * what we want</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bitentry</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">&lt;</span> <span class="mh">0x5</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bitentry</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bios</span><span class="o">-&gt;</span><span class="n">ram_restrict_group_count</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">bitentry</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">2</span><span class="p">];</span>
		<span class="n">bios</span><span class="o">-&gt;</span><span class="n">ram_restrict_tbl_ptr</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">bitentry</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">3</span><span class="p">]);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">bios</span><span class="o">-&gt;</span><span class="n">ram_restrict_group_count</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">bitentry</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">0</span><span class="p">];</span>
		<span class="n">bios</span><span class="o">-&gt;</span><span class="n">ram_restrict_tbl_ptr</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">bitentry</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">parse_bit_tmds_tbl_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bit_entry</span> <span class="o">*</span><span class="n">bitentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Parses the pointer to the TMDS table</span>
<span class="cm">	 *</span>
<span class="cm">	 * Starting at bitentry-&gt;offset:</span>
<span class="cm">	 *</span>
<span class="cm">	 * offset + 0  (16 bits): TMDS table pointer</span>
<span class="cm">	 *</span>
<span class="cm">	 * The TMDS table is typically found just before the DCB table, with a</span>
<span class="cm">	 * characteristic signature of 0x11,0x13 (1.1 being version, 0x13 being</span>
<span class="cm">	 * length?)</span>
<span class="cm">	 *</span>
<span class="cm">	 * At offset +7 is a pointer to a script, which I don&#39;t know how to</span>
<span class="cm">	 * run yet.</span>
<span class="cm">	 * At offset +9 is a pointer to another script, likewise</span>
<span class="cm">	 * Offset +11 has a pointer to a table where the first word is a pxclk</span>
<span class="cm">	 * frequency and the second word a pointer to a script, which should be</span>
<span class="cm">	 * run if the comparison pxclk frequency is less than the pxclk desired.</span>
<span class="cm">	 * This repeats for decreasing comparison frequencies</span>
<span class="cm">	 * Offset +13 has a pointer to a similar table</span>
<span class="cm">	 * The selection of table (and possibly +7/+9 script) is dictated by</span>
<span class="cm">	 * &quot;or&quot; from the DCB.</span>
<span class="cm">	 */</span>

	<span class="kt">uint16_t</span> <span class="n">tmdstableptr</span><span class="p">,</span> <span class="n">script1</span><span class="p">,</span> <span class="n">script2</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bitentry</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">NV_ERROR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Do not understand BIT TMDS table</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tmdstableptr</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">bitentry</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tmdstableptr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">NV_ERROR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Pointer to TMDS table invalid</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">NV_INFO</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;TMDS table version %d.%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">tmdstableptr</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">,</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">tmdstableptr</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">);</span>

	<span class="cm">/* nv50+ has v2.0, but we don&#39;t parse it atm */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">tmdstableptr</span><span class="p">]</span> <span class="o">!=</span> <span class="mh">0x11</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * These two scripts are odd: they don&#39;t seem to get run even when</span>
<span class="cm">	 * they are not stubbed.</span>
<span class="cm">	 */</span>
	<span class="n">script1</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">tmdstableptr</span> <span class="o">+</span> <span class="mi">7</span><span class="p">]);</span>
	<span class="n">script2</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">tmdstableptr</span> <span class="o">+</span> <span class="mi">9</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">script1</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;q&#39;</span> <span class="o">||</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">script2</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;q&#39;</span><span class="p">)</span>
		<span class="n">NV_WARN</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;TMDS table script pointers not stubbed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">bios</span><span class="o">-&gt;</span><span class="n">tmds</span><span class="p">.</span><span class="n">output0_script_ptr</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">tmdstableptr</span> <span class="o">+</span> <span class="mi">11</span><span class="p">]);</span>
	<span class="n">bios</span><span class="o">-&gt;</span><span class="n">tmds</span><span class="p">.</span><span class="n">output1_script_ptr</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">tmdstableptr</span> <span class="o">+</span> <span class="mi">13</span><span class="p">]);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">parse_bit_U_tbl_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">bit_entry</span> <span class="o">*</span><span class="n">bitentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Parses the pointer to the G80 output script tables</span>
<span class="cm">	 *</span>
<span class="cm">	 * Starting at bitentry-&gt;offset:</span>
<span class="cm">	 *</span>
<span class="cm">	 * offset + 0  (16 bits): output script table pointer</span>
<span class="cm">	 */</span>

	<span class="kt">uint16_t</span> <span class="n">outputscripttableptr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bitentry</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">NV_ERROR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Do not understand BIT U table</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">outputscripttableptr</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">bitentry</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">]);</span>
	<span class="n">bios</span><span class="o">-&gt;</span><span class="n">display</span><span class="p">.</span><span class="n">script_table_ptr</span> <span class="o">=</span> <span class="n">outputscripttableptr</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">bit_table</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="n">id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span> <span class="k">const</span> <span class="n">parse_fn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bit_entry</span> <span class="o">*</span><span class="p">);</span>
<span class="p">};</span>

<span class="cp">#define BIT_TABLE(id, funcid) ((struct bit_table){ id, parse_bit_##funcid##_tbl_entry })</span>

<span class="kt">int</span>
<span class="nf">bit_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u8</span> <span class="n">id</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bit_entry</span> <span class="o">*</span><span class="n">bit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_nouveau_private</span> <span class="o">*</span><span class="n">dev_priv</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">vbios</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">entries</span><span class="p">,</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">NVBIOS_BIT</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">entries</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">10</span><span class="p">];</span>
	<span class="n">entry</span>   <span class="o">=</span> <span class="o">&amp;</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">12</span><span class="p">];</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">entries</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">id</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">bit</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">=</span> <span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
			<span class="n">bit</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">=</span> <span class="n">entry</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
			<span class="n">bit</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">entry</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
			<span class="n">bit</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">entry</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span>
			<span class="n">bit</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">ROMPTR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">entry</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">entry</span> <span class="o">+=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">9</span><span class="p">];</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">parse_bit_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint16_t</span> <span class="n">bitoffset</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">bit_table</span> <span class="o">*</span><span class="n">table</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bit_entry</span> <span class="n">bitentry</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bit_table</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bitentry</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">parse_fn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">bios</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bitentry</span><span class="p">);</span>

	<span class="n">NV_INFO</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;BIT table &#39;%c&#39; not found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">parse_bit_structure</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint16_t</span> <span class="n">bitoffset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The only restriction on parsing order currently is having &#39;i&#39; first</span>
<span class="cm">	 * for use of bios-&gt;*_version or bios-&gt;feature_byte while parsing;</span>
<span class="cm">	 * functions shouldn&#39;t be actually *doing* anything apart from pulling</span>
<span class="cm">	 * data from the image into the bios struct, thus no interdependencies</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">parse_bit_table</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">bitoffset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">BIT_TABLE</span><span class="p">(</span><span class="sc">&#39;i&#39;</span><span class="p">,</span> <span class="n">i</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="cm">/* info? */</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">major_version</span> <span class="o">&gt;=</span> <span class="mh">0x60</span><span class="p">)</span> <span class="cm">/* g80+ */</span>
		<span class="n">parse_bit_table</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">bitoffset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">BIT_TABLE</span><span class="p">(</span><span class="sc">&#39;A&#39;</span><span class="p">,</span> <span class="n">A</span><span class="p">));</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">parse_bit_table</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">bitoffset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">BIT_TABLE</span><span class="p">(</span><span class="sc">&#39;C&#39;</span><span class="p">,</span> <span class="n">C</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">parse_bit_table</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">bitoffset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">BIT_TABLE</span><span class="p">(</span><span class="sc">&#39;D&#39;</span><span class="p">,</span> <span class="n">display</span><span class="p">));</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">parse_bit_table</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">bitoffset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">BIT_TABLE</span><span class="p">(</span><span class="sc">&#39;I&#39;</span><span class="p">,</span> <span class="n">init</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">parse_bit_table</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">bitoffset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">BIT_TABLE</span><span class="p">(</span><span class="sc">&#39;M&#39;</span><span class="p">,</span> <span class="n">M</span><span class="p">));</span> <span class="cm">/* memory? */</span>
	<span class="n">parse_bit_table</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">bitoffset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">BIT_TABLE</span><span class="p">(</span><span class="sc">&#39;L&#39;</span><span class="p">,</span> <span class="n">lvds</span><span class="p">));</span>
	<span class="n">parse_bit_table</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">bitoffset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">BIT_TABLE</span><span class="p">(</span><span class="sc">&#39;T&#39;</span><span class="p">,</span> <span class="n">tmds</span><span class="p">));</span>
	<span class="n">parse_bit_table</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">bitoffset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">BIT_TABLE</span><span class="p">(</span><span class="sc">&#39;U&#39;</span><span class="p">,</span> <span class="n">U</span><span class="p">));</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">parse_bmp_structure</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Parses the BMP structure for useful things, but does not act on them</span>
<span class="cm">	 *</span>
<span class="cm">	 * offset +   5: BMP major version</span>
<span class="cm">	 * offset +   6: BMP minor version</span>
<span class="cm">	 * offset +   9: BMP feature byte</span>
<span class="cm">	 * offset +  10: BCD encoded BIOS version</span>
<span class="cm">	 *</span>
<span class="cm">	 * offset +  18: init script table pointer (for bios versions &lt; 5.10h)</span>
<span class="cm">	 * offset +  20: extra init script table pointer (for bios</span>
<span class="cm">	 * versions &lt; 5.10h)</span>
<span class="cm">	 *</span>
<span class="cm">	 * offset +  24: memory init table pointer (used on early bios versions)</span>
<span class="cm">	 * offset +  26: SDR memory sequencing setup data table</span>
<span class="cm">	 * offset +  28: DDR memory sequencing setup data table</span>
<span class="cm">	 *</span>
<span class="cm">	 * offset +  54: index of I2C CRTC pair to use for CRT output</span>
<span class="cm">	 * offset +  55: index of I2C CRTC pair to use for TV output</span>
<span class="cm">	 * offset +  56: index of I2C CRTC pair to use for flat panel output</span>
<span class="cm">	 * offset +  58: write CRTC index for I2C pair 0</span>
<span class="cm">	 * offset +  59: read CRTC index for I2C pair 0</span>
<span class="cm">	 * offset +  60: write CRTC index for I2C pair 1</span>
<span class="cm">	 * offset +  61: read CRTC index for I2C pair 1</span>
<span class="cm">	 *</span>
<span class="cm">	 * offset +  67: maximum internal PLL frequency (single stage PLL)</span>
<span class="cm">	 * offset +  71: minimum internal PLL frequency (single stage PLL)</span>
<span class="cm">	 *</span>
<span class="cm">	 * offset +  75: script table pointers, as described in</span>
<span class="cm">	 * parse_script_table_pointers</span>
<span class="cm">	 *</span>
<span class="cm">	 * offset +  89: TMDS single link output A table pointer</span>
<span class="cm">	 * offset +  91: TMDS single link output B table pointer</span>
<span class="cm">	 * offset +  95: LVDS single link output A table pointer</span>
<span class="cm">	 * offset + 105: flat panel timings table pointer</span>
<span class="cm">	 * offset + 107: flat panel strapping translation table pointer</span>
<span class="cm">	 * offset + 117: LVDS manufacturer panel config table pointer</span>
<span class="cm">	 * offset + 119: LVDS manufacturer strapping translation table pointer</span>
<span class="cm">	 *</span>
<span class="cm">	 * offset + 142: PLL limits table pointer</span>
<span class="cm">	 *</span>
<span class="cm">	 * offset + 156: minimum pixel clock for LVDS dual link</span>
<span class="cm">	 */</span>

	<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">bmp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span><span class="p">],</span> <span class="n">bmp_version_major</span><span class="p">,</span> <span class="n">bmp_version_minor</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">bmplength</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">legacy_scripts_offset</span><span class="p">,</span> <span class="n">legacy_i2c_offset</span><span class="p">;</span>

	<span class="cm">/* load needed defaults in case we can&#39;t parse this info */</span>
	<span class="n">bios</span><span class="o">-&gt;</span><span class="n">digital_min_front_porch</span> <span class="o">=</span> <span class="mh">0x4b</span><span class="p">;</span>
	<span class="n">bios</span><span class="o">-&gt;</span><span class="n">fmaxvco</span> <span class="o">=</span> <span class="mi">256000</span><span class="p">;</span>
	<span class="n">bios</span><span class="o">-&gt;</span><span class="n">fminvco</span> <span class="o">=</span> <span class="mi">128000</span><span class="p">;</span>
	<span class="n">bios</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">.</span><span class="n">duallink_transition_clk</span> <span class="o">=</span> <span class="mi">90000</span><span class="p">;</span>

	<span class="n">bmp_version_major</span> <span class="o">=</span> <span class="n">bmp</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
	<span class="n">bmp_version_minor</span> <span class="o">=</span> <span class="n">bmp</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>

	<span class="n">NV_TRACE</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;BMP version %d.%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">bmp_version_major</span><span class="p">,</span> <span class="n">bmp_version_minor</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Make sure that 0x36 is blank and can&#39;t be mistaken for a DCB</span>
<span class="cm">	 * pointer on early versions</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bmp_version_major</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">)</span>
		<span class="o">*</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mh">0x36</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Seems that the minor version was 1 for all major versions prior</span>
<span class="cm">	 * to 5. Version 6 could theoretically exist, but I suspect BIT</span>
<span class="cm">	 * happened instead.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">bmp_version_major</span> <span class="o">&lt;</span> <span class="mi">5</span> <span class="o">&amp;&amp;</span> <span class="n">bmp_version_minor</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">||</span> <span class="n">bmp_version_major</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">NV_ERROR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;You have an unsupported BMP version. &quot;</span>
				<span class="s">&quot;Please send in your bios</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bmp_version_major</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="cm">/* nothing that&#39;s currently useful in this version */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bmp_version_major</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">bmplength</span> <span class="o">=</span> <span class="mi">44</span><span class="p">;</span> <span class="cm">/* exact for 1.01 */</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bmp_version_major</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">bmplength</span> <span class="o">=</span> <span class="mi">48</span><span class="p">;</span> <span class="cm">/* exact for 2.01 */</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bmp_version_major</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>
		<span class="n">bmplength</span> <span class="o">=</span> <span class="mi">54</span><span class="p">;</span>
		<span class="cm">/* guessed - mem init tables added in this version */</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bmp_version_major</span> <span class="o">==</span> <span class="mi">4</span> <span class="o">||</span> <span class="n">bmp_version_minor</span> <span class="o">&lt;</span> <span class="mh">0x1</span><span class="p">)</span>
		<span class="cm">/* don&#39;t know if 5.0 exists... */</span>
		<span class="n">bmplength</span> <span class="o">=</span> <span class="mi">62</span><span class="p">;</span>
		<span class="cm">/* guessed - BMP I2C indices added in version 4*/</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bmp_version_minor</span> <span class="o">&lt;</span> <span class="mh">0x6</span><span class="p">)</span>
		<span class="n">bmplength</span> <span class="o">=</span> <span class="mi">67</span><span class="p">;</span> <span class="cm">/* exact for 5.01 */</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bmp_version_minor</span> <span class="o">&lt;</span> <span class="mh">0x10</span><span class="p">)</span>
		<span class="n">bmplength</span> <span class="o">=</span> <span class="mi">75</span><span class="p">;</span> <span class="cm">/* exact for 5.06 */</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bmp_version_minor</span> <span class="o">==</span> <span class="mh">0x10</span><span class="p">)</span>
		<span class="n">bmplength</span> <span class="o">=</span> <span class="mi">89</span><span class="p">;</span> <span class="cm">/* exact for 5.10h */</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bmp_version_minor</span> <span class="o">&lt;</span> <span class="mh">0x14</span><span class="p">)</span>
		<span class="n">bmplength</span> <span class="o">=</span> <span class="mi">118</span><span class="p">;</span> <span class="cm">/* exact for 5.11h */</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bmp_version_minor</span> <span class="o">&lt;</span> <span class="mh">0x24</span><span class="p">)</span>
		<span class="cm">/*</span>
<span class="cm">		 * Not sure of version where pll limits came in;</span>
<span class="cm">		 * certainly exist by 0x24 though.</span>
<span class="cm">		 */</span>
		<span class="cm">/* length not exact: this is long enough to get lvds members */</span>
		<span class="n">bmplength</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bmp_version_minor</span> <span class="o">&lt;</span> <span class="mh">0x27</span><span class="p">)</span>
		<span class="cm">/*</span>
<span class="cm">		 * Length not exact: this is long enough to get pll limit</span>
<span class="cm">		 * member</span>
<span class="cm">		 */</span>
		<span class="n">bmplength</span> <span class="o">=</span> <span class="mi">144</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="cm">/*</span>
<span class="cm">		 * Length not exact: this is long enough to get dual link</span>
<span class="cm">		 * transition clock.</span>
<span class="cm">		 */</span>
		<span class="n">bmplength</span> <span class="o">=</span> <span class="mi">158</span><span class="p">;</span>

	<span class="cm">/* checksum */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nv_cksum</span><span class="p">(</span><span class="n">bmp</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">NV_ERROR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Bad BMP checksum</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Bit 4 seems to indicate either a mobile bios or a quadro card --</span>
<span class="cm">	 * mobile behaviour consistent (nv11+), quadro only seen nv18gl-nv36gl</span>
<span class="cm">	 * (not nv10gl), bit 5 that the flat panel tables are present, and</span>
<span class="cm">	 * bit 6 a tv bios.</span>
<span class="cm">	 */</span>
	<span class="n">bios</span><span class="o">-&gt;</span><span class="n">feature_byte</span> <span class="o">=</span> <span class="n">bmp</span><span class="p">[</span><span class="mi">9</span><span class="p">];</span>

	<span class="n">parse_bios_version</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">bios</span><span class="p">,</span> <span class="n">offset</span> <span class="o">+</span> <span class="mi">10</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bmp_version_major</span> <span class="o">&lt;</span> <span class="mi">5</span> <span class="o">||</span> <span class="n">bmp_version_minor</span> <span class="o">&lt;</span> <span class="mh">0x10</span><span class="p">)</span>
		<span class="n">bios</span><span class="o">-&gt;</span><span class="n">old_style_init</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">legacy_scripts_offset</span> <span class="o">=</span> <span class="mi">18</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bmp_version_major</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">legacy_scripts_offset</span> <span class="o">-=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="n">bios</span><span class="o">-&gt;</span><span class="n">init_script_tbls_ptr</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">bmp</span><span class="p">[</span><span class="n">legacy_scripts_offset</span><span class="p">]);</span>
	<span class="n">bios</span><span class="o">-&gt;</span><span class="n">extra_init_script_tbl_ptr</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">bmp</span><span class="p">[</span><span class="n">legacy_scripts_offset</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bmp_version_major</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* appears in BMP 3 */</span>
		<span class="n">bios</span><span class="o">-&gt;</span><span class="n">legacy</span><span class="p">.</span><span class="n">mem_init_tbl_ptr</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">bmp</span><span class="p">[</span><span class="mi">24</span><span class="p">]);</span>
		<span class="n">bios</span><span class="o">-&gt;</span><span class="n">legacy</span><span class="p">.</span><span class="n">sdr_seq_tbl_ptr</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">bmp</span><span class="p">[</span><span class="mi">26</span><span class="p">]);</span>
		<span class="n">bios</span><span class="o">-&gt;</span><span class="n">legacy</span><span class="p">.</span><span class="n">ddr_seq_tbl_ptr</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">bmp</span><span class="p">[</span><span class="mi">28</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="n">legacy_i2c_offset</span> <span class="o">=</span> <span class="mh">0x48</span><span class="p">;</span>	<span class="cm">/* BMP version 2 &amp; 3 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bmplength</span> <span class="o">&gt;</span> <span class="mi">61</span><span class="p">)</span>
		<span class="n">legacy_i2c_offset</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="mi">54</span><span class="p">;</span>
	<span class="n">bios</span><span class="o">-&gt;</span><span class="n">legacy</span><span class="p">.</span><span class="n">i2c_indices</span><span class="p">.</span><span class="n">crt</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">legacy_i2c_offset</span><span class="p">];</span>
	<span class="n">bios</span><span class="o">-&gt;</span><span class="n">legacy</span><span class="p">.</span><span class="n">i2c_indices</span><span class="p">.</span><span class="n">tv</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">legacy_i2c_offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="n">bios</span><span class="o">-&gt;</span><span class="n">legacy</span><span class="p">.</span><span class="n">i2c_indices</span><span class="p">.</span><span class="n">panel</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">legacy_i2c_offset</span> <span class="o">+</span> <span class="mi">2</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bmplength</span> <span class="o">&gt;</span> <span class="mi">74</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bios</span><span class="o">-&gt;</span><span class="n">fmaxvco</span> <span class="o">=</span> <span class="n">ROM32</span><span class="p">(</span><span class="n">bmp</span><span class="p">[</span><span class="mi">67</span><span class="p">]);</span>
		<span class="n">bios</span><span class="o">-&gt;</span><span class="n">fminvco</span> <span class="o">=</span> <span class="n">ROM32</span><span class="p">(</span><span class="n">bmp</span><span class="p">[</span><span class="mi">71</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bmplength</span> <span class="o">&gt;</span> <span class="mi">88</span><span class="p">)</span>
		<span class="n">parse_script_table_pointers</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">offset</span> <span class="o">+</span> <span class="mi">75</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bmplength</span> <span class="o">&gt;</span> <span class="mi">94</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bios</span><span class="o">-&gt;</span><span class="n">tmds</span><span class="p">.</span><span class="n">output0_script_ptr</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">bmp</span><span class="p">[</span><span class="mi">89</span><span class="p">]);</span>
		<span class="n">bios</span><span class="o">-&gt;</span><span class="n">tmds</span><span class="p">.</span><span class="n">output1_script_ptr</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">bmp</span><span class="p">[</span><span class="mi">91</span><span class="p">]);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Never observed in use with lvds scripts, but is reused for</span>
<span class="cm">		 * 18/24 bit panel interface default for EDID equipped panels</span>
<span class="cm">		 * (if_is_24bit not set directly to avoid any oscillation).</span>
<span class="cm">		 */</span>
		<span class="n">bios</span><span class="o">-&gt;</span><span class="n">legacy</span><span class="p">.</span><span class="n">lvds_single_a_script_ptr</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">bmp</span><span class="p">[</span><span class="mi">95</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bmplength</span> <span class="o">&gt;</span> <span class="mi">108</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bios</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">.</span><span class="n">fptablepointer</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">bmp</span><span class="p">[</span><span class="mi">105</span><span class="p">]);</span>
		<span class="n">bios</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">.</span><span class="n">fpxlatetableptr</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">bmp</span><span class="p">[</span><span class="mi">107</span><span class="p">]);</span>
		<span class="n">bios</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">.</span><span class="n">xlatwidth</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bmplength</span> <span class="o">&gt;</span> <span class="mi">120</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bios</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">.</span><span class="n">lvdsmanufacturerpointer</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">bmp</span><span class="p">[</span><span class="mi">117</span><span class="p">]);</span>
		<span class="n">bios</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">.</span><span class="n">fpxlatemanufacturertableptr</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">bmp</span><span class="p">[</span><span class="mi">119</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bmplength</span> <span class="o">&gt;</span> <span class="mi">143</span><span class="p">)</span>
		<span class="n">bios</span><span class="o">-&gt;</span><span class="n">pll_limit_tbl_ptr</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">bmp</span><span class="p">[</span><span class="mi">142</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bmplength</span> <span class="o">&gt;</span> <span class="mi">157</span><span class="p">)</span>
		<span class="n">bios</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">.</span><span class="n">duallink_transition_clk</span> <span class="o">=</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">bmp</span><span class="p">[</span><span class="mi">156</span><span class="p">])</span> <span class="o">*</span> <span class="mi">10</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">uint16_t</span> <span class="nf">findstr</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">len</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="n">str</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">len</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span>
<span class="nf">dcb_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_nouveau_private</span> <span class="o">*</span><span class="n">dev_priv</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_private</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">dcb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">card_type</span> <span class="o">&gt;</span> <span class="n">NV_04</span><span class="p">)</span>
		<span class="n">dcb</span> <span class="o">=</span> <span class="n">ROMPTR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">vbios</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="mh">0x36</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dcb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">NV_WARNONCE</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;No DCB data found in VBIOS</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dcb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mh">0x41</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">NV_WARNONCE</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;DCB version 0x%02x unknown</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dcb</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dcb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mh">0x30</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ROM32</span><span class="p">(</span><span class="n">dcb</span><span class="p">[</span><span class="mi">6</span><span class="p">])</span> <span class="o">==</span> <span class="mh">0x4edcbdcb</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">dcb</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dcb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mh">0x20</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ROM32</span><span class="p">(</span><span class="n">dcb</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span> <span class="o">==</span> <span class="mh">0x4edcbdcb</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">dcb</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dcb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mh">0x15</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dcb</span><span class="p">[</span><span class="o">-</span><span class="mi">7</span><span class="p">],</span> <span class="s">&quot;DEV_REC&quot;</span><span class="p">,</span> <span class="mi">7</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">dcb</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * v1.4 (some NV15/16, NV11+) seems the same as v1.5, but</span>
<span class="cm">		 * always has the same single (crt) entry, even when tv-out</span>
<span class="cm">		 * present, so the conclusion is this version cannot really</span>
<span class="cm">		 * be used.</span>
<span class="cm">		 *</span>
<span class="cm">		 * v1.2 tables (some NV6/10, and NV15+) normally have the</span>
<span class="cm">		 * same 5 entries, which are not specific to the card and so</span>
<span class="cm">		 * no use.</span>
<span class="cm">		 *</span>
<span class="cm">		 * v1.2 does have an I2C table that read_dcb_i2c_table can</span>
<span class="cm">		 * handle, but cards exist (nv11 in #14821) with a bad i2c</span>
<span class="cm">		 * table pointer, so use the indices parsed in</span>
<span class="cm">		 * parse_bmp_structure.</span>
<span class="cm">		 *</span>
<span class="cm">		 * v1.1 (NV5+, maybe some NV4) is entirely unhelpful</span>
<span class="cm">		 */</span>
		<span class="n">NV_WARNONCE</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;No useful DCB data in VBIOS</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">NV_WARNONCE</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;DCB header validation failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span>
<span class="nf">dcb_outp</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u8</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">dcb</span> <span class="o">=</span> <span class="n">dcb_table</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dcb</span> <span class="o">&amp;&amp;</span> <span class="n">dcb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mh">0x30</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="n">dcb</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
			<span class="k">return</span> <span class="n">dcb</span> <span class="o">+</span> <span class="n">dcb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">idx</span> <span class="o">*</span> <span class="n">dcb</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
	<span class="p">}</span> <span class="k">else</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dcb</span> <span class="o">&amp;&amp;</span> <span class="n">dcb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mh">0x20</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u8</span> <span class="o">*</span><span class="n">i2c</span> <span class="o">=</span> <span class="n">ROMPTR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">dcb</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
		<span class="n">u8</span> <span class="o">*</span><span class="n">ent</span> <span class="o">=</span> <span class="n">dcb</span> <span class="o">+</span> <span class="mi">8</span> <span class="o">+</span> <span class="p">(</span><span class="n">idx</span> <span class="o">*</span> <span class="mi">8</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i2c</span> <span class="o">&amp;&amp;</span> <span class="n">ent</span> <span class="o">&lt;</span> <span class="n">i2c</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ent</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dcb</span> <span class="o">&amp;&amp;</span> <span class="n">dcb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mh">0x15</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u8</span> <span class="o">*</span><span class="n">i2c</span> <span class="o">=</span> <span class="n">ROMPTR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">dcb</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
		<span class="n">u8</span> <span class="o">*</span><span class="n">ent</span> <span class="o">=</span> <span class="n">dcb</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">+</span> <span class="p">(</span><span class="n">idx</span> <span class="o">*</span> <span class="mi">10</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i2c</span> <span class="o">&amp;&amp;</span> <span class="n">ent</span> <span class="o">&lt;</span> <span class="n">i2c</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ent</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">dcb_outp_foreach</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
		 <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">exec</span><span class="p">)(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">outp</span><span class="p">))</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">idx</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">outp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">outp</span> <span class="o">=</span> <span class="n">dcb_outp</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">++</span><span class="n">idx</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ROM32</span><span class="p">(</span><span class="n">outp</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mh">0x00000000</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span> <span class="cm">/* seen on an NV11 with DCB v1.5 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ROM32</span><span class="p">(</span><span class="n">outp</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mh">0xffffffff</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span> <span class="cm">/* seen on an NV17 with DCB v2.0 */</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">outp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">)</span> <span class="o">==</span> <span class="n">OUTPUT_UNUSED</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">outp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">)</span> <span class="o">==</span> <span class="n">OUTPUT_EOL</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">exec</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">outp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">u8</span> <span class="o">*</span>
<span class="nf">dcb_conntab</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">dcb</span> <span class="o">=</span> <span class="n">dcb_table</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dcb</span> <span class="o">&amp;&amp;</span> <span class="n">dcb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mh">0x30</span> <span class="o">&amp;&amp;</span> <span class="n">dcb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mh">0x16</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u8</span> <span class="o">*</span><span class="n">conntab</span> <span class="o">=</span> <span class="n">ROMPTR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">dcb</span><span class="p">[</span><span class="mh">0x14</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">conntab</span> <span class="o">&amp;&amp;</span> <span class="n">conntab</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mh">0x30</span> <span class="o">&amp;&amp;</span> <span class="n">conntab</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mh">0x40</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">conntab</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">u8</span> <span class="o">*</span>
<span class="nf">dcb_conn</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u8</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">conntab</span> <span class="o">=</span> <span class="n">dcb_conntab</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">conntab</span> <span class="o">&amp;&amp;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">conntab</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
		<span class="k">return</span> <span class="n">conntab</span> <span class="o">+</span> <span class="n">conntab</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">idx</span> <span class="o">*</span> <span class="n">conntab</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dcb_entry</span> <span class="o">*</span><span class="nf">new_dcb_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">dcb_table</span> <span class="o">*</span><span class="n">dcb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dcb_entry</span> <span class="o">*</span><span class="n">entry</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dcb</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">[</span><span class="n">dcb</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">];</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dcb_entry</span><span class="p">));</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">dcb</span><span class="o">-&gt;</span><span class="n">entries</span><span class="o">++</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">entry</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fabricate_dcb_output</span><span class="p">(</span><span class="k">struct</span> <span class="n">dcb_table</span> <span class="o">*</span><span class="n">dcb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i2c</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="n">heads</span><span class="p">,</span> <span class="kt">int</span> <span class="n">or</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dcb_entry</span> <span class="o">*</span><span class="n">entry</span> <span class="o">=</span> <span class="n">new_dcb_entry</span><span class="p">(</span><span class="n">dcb</span><span class="p">);</span>

	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">i2c_index</span> <span class="o">=</span> <span class="n">i2c</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">heads</span> <span class="o">=</span> <span class="n">heads</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">!=</span> <span class="n">OUTPUT_ANALOG</span><span class="p">)</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">location</span> <span class="o">=</span> <span class="o">!</span><span class="n">DCB_LOC_ON_CHIP</span><span class="p">;</span> <span class="cm">/* ie OFF CHIP */</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">or</span> <span class="o">=</span> <span class="n">or</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span>
<span class="nf">parse_dcb20_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dcb_table</span> <span class="o">*</span><span class="n">dcb</span><span class="p">,</span>
		  <span class="kt">uint32_t</span> <span class="n">conn</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">conf</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dcb_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">conn</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">i2c_index</span> <span class="o">=</span> <span class="p">(</span><span class="n">conn</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">heads</span> <span class="o">=</span> <span class="p">(</span><span class="n">conn</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">connector</span> <span class="o">=</span> <span class="p">(</span><span class="n">conn</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">bus</span> <span class="o">=</span> <span class="p">(</span><span class="n">conn</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">location</span> <span class="o">=</span> <span class="p">(</span><span class="n">conn</span> <span class="o">&gt;&gt;</span> <span class="mi">20</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">or</span> <span class="o">=</span> <span class="p">(</span><span class="n">conn</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">OUTPUT_ANALOG</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Although the rest of a CRT conf dword is usually</span>
<span class="cm">		 * zeros, mac biosen have stuff there so we must mask</span>
<span class="cm">		 */</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">crtconf</span><span class="p">.</span><span class="n">maxfreq</span> <span class="o">=</span> <span class="p">(</span><span class="n">dcb</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">&lt;</span> <span class="mh">0x30</span><span class="p">)</span> <span class="o">?</span>
					 <span class="p">(</span><span class="n">conf</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">)</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">:</span>
					 <span class="p">(</span><span class="n">conf</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">*</span> <span class="mi">10000</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">OUTPUT_LVDS</span>:
		<span class="p">{</span>
		<span class="kt">uint32_t</span> <span class="n">mask</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">conf</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span>
			<span class="n">entry</span><span class="o">-&gt;</span><span class="n">lvdsconf</span><span class="p">.</span><span class="n">use_straps_for_mode</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dcb</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">&lt;</span> <span class="mh">0x22</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="mh">0xd</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * The laptop in bug 14567 lies and claims to not use</span>
<span class="cm">			 * straps when it does, so assume all DCB 2.0 laptops</span>
<span class="cm">			 * use straps, until a broken EDID using one is produced</span>
<span class="cm">			 */</span>
			<span class="n">entry</span><span class="o">-&gt;</span><span class="n">lvdsconf</span><span class="p">.</span><span class="n">use_straps_for_mode</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * Both 0x4 and 0x8 show up in v2.0 tables; assume they</span>
<span class="cm">			 * mean the same thing (probably wrong, but might work)</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">conf</span> <span class="o">&amp;</span> <span class="mh">0x4</span> <span class="o">||</span> <span class="n">conf</span> <span class="o">&amp;</span> <span class="mh">0x8</span><span class="p">)</span>
				<span class="n">entry</span><span class="o">-&gt;</span><span class="n">lvdsconf</span><span class="p">.</span><span class="n">use_power_scripts</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="mh">0x7</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">conf</span> <span class="o">&amp;</span> <span class="mh">0x2</span><span class="p">)</span>
				<span class="n">entry</span><span class="o">-&gt;</span><span class="n">lvdsconf</span><span class="p">.</span><span class="n">use_acpi_for_edid</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">conf</span> <span class="o">&amp;</span> <span class="mh">0x4</span><span class="p">)</span>
				<span class="n">entry</span><span class="o">-&gt;</span><span class="n">lvdsconf</span><span class="p">.</span><span class="n">use_power_scripts</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="n">entry</span><span class="o">-&gt;</span><span class="n">lvdsconf</span><span class="p">.</span><span class="n">sor</span><span class="p">.</span><span class="n">link</span> <span class="o">=</span> <span class="p">(</span><span class="n">conf</span> <span class="o">&amp;</span> <span class="mh">0x00000030</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">conf</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Until we even try to use these on G8x, it&#39;s</span>
<span class="cm">			 * useless reporting unknown bits.  They all are.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dcb</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">&gt;=</span> <span class="mh">0x40</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="n">NV_ERROR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Unknown LVDS configuration bits, &quot;</span>
				      <span class="s">&quot;please report</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="k">case</span> <span class="n">OUTPUT_TV</span>:
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dcb</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">&gt;=</span> <span class="mh">0x30</span><span class="p">)</span>
			<span class="n">entry</span><span class="o">-&gt;</span><span class="n">tvconf</span><span class="p">.</span><span class="n">has_component_output</span> <span class="o">=</span> <span class="n">conf</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mh">0x8</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">entry</span><span class="o">-&gt;</span><span class="n">tvconf</span><span class="p">.</span><span class="n">has_component_output</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">OUTPUT_DP</span>:
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">dpconf</span><span class="p">.</span><span class="n">sor</span><span class="p">.</span><span class="n">link</span> <span class="o">=</span> <span class="p">(</span><span class="n">conf</span> <span class="o">&amp;</span> <span class="mh">0x00000030</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">;</span>
		<span class="k">switch</span> <span class="p">((</span><span class="n">conf</span> <span class="o">&amp;</span> <span class="mh">0x00e00000</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">21</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">0</span>:
			<span class="n">entry</span><span class="o">-&gt;</span><span class="n">dpconf</span><span class="p">.</span><span class="n">link_bw</span> <span class="o">=</span> <span class="mi">162000</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">entry</span><span class="o">-&gt;</span><span class="n">dpconf</span><span class="p">.</span><span class="n">link_bw</span> <span class="o">=</span> <span class="mi">270000</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">switch</span> <span class="p">((</span><span class="n">conf</span> <span class="o">&amp;</span> <span class="mh">0x0f000000</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mh">0xf</span>:
			<span class="n">entry</span><span class="o">-&gt;</span><span class="n">dpconf</span><span class="p">.</span><span class="n">link_nr</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mh">0x3</span>:
			<span class="n">entry</span><span class="o">-&gt;</span><span class="n">dpconf</span><span class="p">.</span><span class="n">link_nr</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">entry</span><span class="o">-&gt;</span><span class="n">dpconf</span><span class="p">.</span><span class="n">link_nr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">OUTPUT_TMDS</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">dcb</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">&gt;=</span> <span class="mh">0x40</span><span class="p">)</span>
			<span class="n">entry</span><span class="o">-&gt;</span><span class="n">tmdsconf</span><span class="p">.</span><span class="n">sor</span><span class="p">.</span><span class="n">link</span> <span class="o">=</span> <span class="p">(</span><span class="n">conf</span> <span class="o">&amp;</span> <span class="mh">0x00000030</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dcb</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">&gt;=</span> <span class="mh">0x30</span><span class="p">)</span>
			<span class="n">entry</span><span class="o">-&gt;</span><span class="n">tmdsconf</span><span class="p">.</span><span class="n">slave_addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">conf</span> <span class="o">&amp;</span> <span class="mh">0x00000700</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dcb</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">&gt;=</span> <span class="mh">0x22</span><span class="p">)</span>
			<span class="n">entry</span><span class="o">-&gt;</span><span class="n">tmdsconf</span><span class="p">.</span><span class="n">slave_addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">conf</span> <span class="o">&amp;</span> <span class="mh">0x00000070</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">;</span>

		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">OUTPUT_EOL</span>:
		<span class="cm">/* weird g80 mobile type that &quot;nv&quot; treats as a terminator */</span>
		<span class="n">dcb</span><span class="o">-&gt;</span><span class="n">entries</span><span class="o">--</span><span class="p">;</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dcb</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">&lt;</span> <span class="mh">0x40</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Normal entries consist of a single bit, but dual link has</span>
<span class="cm">		 * the next most significant bit set too</span>
<span class="cm">		 */</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">duallink_possible</span> <span class="o">=</span>
			<span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ffs</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">or</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">==</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">or</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">duallink_possible</span> <span class="o">=</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">sorconf</span><span class="p">.</span><span class="n">link</span> <span class="o">==</span> <span class="mi">3</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* unsure what DCB version introduces this, 3.0? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">conf</span> <span class="o">&amp;</span> <span class="mh">0x100000</span><span class="p">)</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">i2c_upper_default</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span>
<span class="nf">parse_dcb15_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dcb_table</span> <span class="o">*</span><span class="n">dcb</span><span class="p">,</span>
		  <span class="kt">uint32_t</span> <span class="n">conn</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">conf</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dcb_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">conn</span> <span class="o">&amp;</span> <span class="mh">0x0000000f</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">OUTPUT_ANALOG</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">OUTPUT_TV</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>:
	<span class="k">case</span> <span class="mi">4</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">conn</span> <span class="o">&amp;</span> <span class="mh">0x10</span><span class="p">)</span>
			<span class="n">entry</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">OUTPUT_LVDS</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">entry</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">OUTPUT_TMDS</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">3</span>:
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">OUTPUT_LVDS</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">NV_ERROR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Unknown DCB type %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">conn</span> <span class="o">&amp;</span> <span class="mh">0x0000000f</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">i2c_index</span> <span class="o">=</span> <span class="p">(</span><span class="n">conn</span> <span class="o">&amp;</span> <span class="mh">0x0003c000</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">14</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">heads</span> <span class="o">=</span> <span class="p">((</span><span class="n">conn</span> <span class="o">&amp;</span> <span class="mh">0x001c0000</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">18</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">or</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">heads</span><span class="p">;</span> <span class="cm">/* same as heads, hopefully safe enough */</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">location</span> <span class="o">=</span> <span class="p">(</span><span class="n">conn</span> <span class="o">&amp;</span> <span class="mh">0x01e00000</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">21</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">bus</span> <span class="o">=</span> <span class="p">(</span><span class="n">conn</span> <span class="o">&amp;</span> <span class="mh">0x0e000000</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">25</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">duallink_possible</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">OUTPUT_ANALOG</span>:
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">crtconf</span><span class="p">.</span><span class="n">maxfreq</span> <span class="o">=</span> <span class="p">(</span><span class="n">conf</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">)</span> <span class="o">*</span> <span class="mi">10</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">OUTPUT_TV</span>:
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">tvconf</span><span class="p">.</span><span class="n">has_component_output</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">OUTPUT_LVDS</span>:
		<span class="k">if</span> <span class="p">((</span><span class="n">conn</span> <span class="o">&amp;</span> <span class="mh">0x00003f00</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span> <span class="o">!=</span> <span class="mh">0x10</span><span class="p">)</span>
			<span class="n">entry</span><span class="o">-&gt;</span><span class="n">lvdsconf</span><span class="p">.</span><span class="n">use_straps_for_mode</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">lvdsconf</span><span class="p">.</span><span class="n">use_power_scripts</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span>
<span class="kt">void</span> <span class="nf">merge_like_dcb_entries</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dcb_table</span> <span class="o">*</span><span class="n">dcb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * DCB v2.0 lists each output combination separately.</span>
<span class="cm">	 * Here we merge compatible entries to have fewer outputs, with</span>
<span class="cm">	 * more options</span>
<span class="cm">	 */</span>

	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">newentries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dcb</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">dcb_entry</span> <span class="o">*</span><span class="n">ient</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dcb</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="kt">int</span> <span class="n">j</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">dcb</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">dcb_entry</span> <span class="o">*</span><span class="n">jent</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dcb</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">jent</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="mi">100</span><span class="p">)</span> <span class="cm">/* already merged entry */</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="cm">/* merge heads field when all other fields the same */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">jent</span><span class="o">-&gt;</span><span class="n">i2c_index</span> <span class="o">==</span> <span class="n">ient</span><span class="o">-&gt;</span><span class="n">i2c_index</span> <span class="o">&amp;&amp;</span>
			    <span class="n">jent</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">ient</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">&amp;&amp;</span>
			    <span class="n">jent</span><span class="o">-&gt;</span><span class="n">location</span> <span class="o">==</span> <span class="n">ient</span><span class="o">-&gt;</span><span class="n">location</span> <span class="o">&amp;&amp;</span>
			    <span class="n">jent</span><span class="o">-&gt;</span><span class="n">or</span> <span class="o">==</span> <span class="n">ient</span><span class="o">-&gt;</span><span class="n">or</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">NV_TRACE</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Merging DCB entries %d and %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					 <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
				<span class="n">ient</span><span class="o">-&gt;</span><span class="n">heads</span> <span class="o">|=</span> <span class="n">jent</span><span class="o">-&gt;</span><span class="n">heads</span><span class="p">;</span>
				<span class="n">jent</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span> <span class="cm">/* dummy value */</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Compact entries merged into others out of dcb */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dcb</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dcb</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">type</span> <span class="o">==</span> <span class="mi">100</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">newentries</span> <span class="o">!=</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dcb</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">[</span><span class="n">newentries</span><span class="p">]</span> <span class="o">=</span> <span class="n">dcb</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">dcb</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">[</span><span class="n">newentries</span><span class="p">].</span><span class="n">index</span> <span class="o">=</span> <span class="n">newentries</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">newentries</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dcb</span><span class="o">-&gt;</span><span class="n">entries</span> <span class="o">=</span> <span class="n">newentries</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span>
<span class="nf">apply_dcb_encoder_quirks</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">conn</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">conf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_nouveau_private</span> <span class="o">*</span><span class="n">dev_priv</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dcb_table</span> <span class="o">*</span><span class="n">dcb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">vbios</span><span class="p">.</span><span class="n">dcb</span><span class="p">;</span>

	<span class="cm">/* Dell Precision M6300</span>
<span class="cm">	 *   DCB entry 2: 02025312 00000010</span>
<span class="cm">	 *   DCB entry 3: 02026312 00000020</span>
<span class="cm">	 *</span>
<span class="cm">	 * Identical, except apparently a different connector on a</span>
<span class="cm">	 * different SOR link.  Not a clue how we&#39;re supposed to know</span>
<span class="cm">	 * which one is in use if it even shares an i2c line...</span>
<span class="cm">	 *</span>
<span class="cm">	 * Ignore the connector on the second SOR link to prevent</span>
<span class="cm">	 * nasty problems until this is sorted (assuming it&#39;s not a</span>
<span class="cm">	 * VBIOS bug).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nv_match_device</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x040d</span><span class="p">,</span> <span class="mh">0x1028</span><span class="p">,</span> <span class="mh">0x019b</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">conn</span> <span class="o">==</span> <span class="mh">0x02026312</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">conf</span> <span class="o">==</span> <span class="mh">0x00000020</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* GeForce3 Ti 200</span>
<span class="cm">	 *</span>
<span class="cm">	 * DCB reports an LVDS output that should be TMDS:</span>
<span class="cm">	 *   DCB entry 1: f2005014 ffffffff</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nv_match_device</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x0201</span><span class="p">,</span> <span class="mh">0x1462</span><span class="p">,</span> <span class="mh">0x8851</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">conn</span> <span class="o">==</span> <span class="mh">0xf2005014</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">conf</span> <span class="o">==</span> <span class="mh">0xffffffff</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">fabricate_dcb_output</span><span class="p">(</span><span class="n">dcb</span><span class="p">,</span> <span class="n">OUTPUT_TMDS</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* XFX GT-240X-YA</span>
<span class="cm">	 *</span>
<span class="cm">	 * So many things wrong here, replace the entire encoder table..</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nv_match_device</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x0ca3</span><span class="p">,</span> <span class="mh">0x1682</span><span class="p">,</span> <span class="mh">0x3003</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">conn</span> <span class="o">=</span> <span class="mh">0x02001300</span><span class="p">;</span> <span class="cm">/* VGA, connector 1 */</span>
			<span class="o">*</span><span class="n">conf</span> <span class="o">=</span> <span class="mh">0x00000028</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">conn</span> <span class="o">=</span> <span class="mh">0x01010312</span><span class="p">;</span> <span class="cm">/* DVI, connector 0 */</span>
			<span class="o">*</span><span class="n">conf</span> <span class="o">=</span> <span class="mh">0x00020030</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">conn</span> <span class="o">=</span> <span class="mh">0x01010310</span><span class="p">;</span> <span class="cm">/* VGA, connector 0 */</span>
			<span class="o">*</span><span class="n">conf</span> <span class="o">=</span> <span class="mh">0x00000028</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">conn</span> <span class="o">=</span> <span class="mh">0x02022362</span><span class="p">;</span> <span class="cm">/* HDMI, connector 2 */</span>
			<span class="o">*</span><span class="n">conf</span> <span class="o">=</span> <span class="mh">0x00020010</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">conn</span> <span class="o">=</span> <span class="mh">0x0000000e</span><span class="p">;</span> <span class="cm">/* EOL */</span>
			<span class="o">*</span><span class="n">conf</span> <span class="o">=</span> <span class="mh">0x00000000</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Some other twisted XFX board (rhbz#694914)</span>
<span class="cm">	 *</span>
<span class="cm">	 * The DVI/VGA encoder combo that&#39;s supposed to represent the</span>
<span class="cm">	 * DVI-I connector actually point at two different ones, and</span>
<span class="cm">	 * the HDMI connector ends up paired with the VGA instead.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Connector table is missing anything for VGA at all, pointing it</span>
<span class="cm">	 * an invalid conntab entry 2 so we figure it out ourself.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nv_match_device</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x0615</span><span class="p">,</span> <span class="mh">0x1682</span><span class="p">,</span> <span class="mh">0x2605</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">conn</span> <span class="o">=</span> <span class="mh">0x02002300</span><span class="p">;</span> <span class="cm">/* VGA, connector 2 */</span>
			<span class="o">*</span><span class="n">conf</span> <span class="o">=</span> <span class="mh">0x00000028</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">conn</span> <span class="o">=</span> <span class="mh">0x01010312</span><span class="p">;</span> <span class="cm">/* DVI, connector 0 */</span>
			<span class="o">*</span><span class="n">conf</span> <span class="o">=</span> <span class="mh">0x00020030</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">conn</span> <span class="o">=</span> <span class="mh">0x04020310</span><span class="p">;</span> <span class="cm">/* VGA, connector 0 */</span>
			<span class="o">*</span><span class="n">conf</span> <span class="o">=</span> <span class="mh">0x00000028</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">conn</span> <span class="o">=</span> <span class="mh">0x02021322</span><span class="p">;</span> <span class="cm">/* HDMI, connector 1 */</span>
			<span class="o">*</span><span class="n">conf</span> <span class="o">=</span> <span class="mh">0x00020010</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">conn</span> <span class="o">=</span> <span class="mh">0x0000000e</span><span class="p">;</span> <span class="cm">/* EOL */</span>
			<span class="o">*</span><span class="n">conf</span> <span class="o">=</span> <span class="mh">0x00000000</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">fabricate_dcb_encoder_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dcb_table</span> <span class="o">*</span><span class="n">dcb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">dcb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">all_heads</span> <span class="o">=</span> <span class="p">(</span><span class="n">nv_two_heads</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">?</span> <span class="mi">3</span> <span class="o">:</span> <span class="mi">1</span><span class="p">);</span>

<span class="cp">#ifdef __powerpc__</span>
	<span class="cm">/* Apple iMac G4 NV17 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">of_machine_is_compatible</span><span class="p">(</span><span class="s">&quot;PowerMac4,5&quot;</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">fabricate_dcb_output</span><span class="p">(</span><span class="n">dcb</span><span class="p">,</span> <span class="n">OUTPUT_TMDS</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">all_heads</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">fabricate_dcb_output</span><span class="p">(</span><span class="n">dcb</span><span class="p">,</span> <span class="n">OUTPUT_ANALOG</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">all_heads</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="cm">/* Make up some sane defaults */</span>
	<span class="n">fabricate_dcb_output</span><span class="p">(</span><span class="n">dcb</span><span class="p">,</span> <span class="n">OUTPUT_ANALOG</span><span class="p">,</span>
			     <span class="n">bios</span><span class="o">-&gt;</span><span class="n">legacy</span><span class="p">.</span><span class="n">i2c_indices</span><span class="p">.</span><span class="n">crt</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nv04_tv_identify</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">legacy</span><span class="p">.</span><span class="n">i2c_indices</span><span class="p">.</span><span class="n">tv</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">fabricate_dcb_output</span><span class="p">(</span><span class="n">dcb</span><span class="p">,</span> <span class="n">OUTPUT_TV</span><span class="p">,</span>
				     <span class="n">bios</span><span class="o">-&gt;</span><span class="n">legacy</span><span class="p">.</span><span class="n">i2c_indices</span><span class="p">.</span><span class="n">tv</span><span class="p">,</span>
				     <span class="n">all_heads</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">tmds</span><span class="p">.</span><span class="n">output0_script_ptr</span> <span class="o">||</span>
		 <span class="n">bios</span><span class="o">-&gt;</span><span class="n">tmds</span><span class="p">.</span><span class="n">output1_script_ptr</span><span class="p">)</span>
		<span class="n">fabricate_dcb_output</span><span class="p">(</span><span class="n">dcb</span><span class="p">,</span> <span class="n">OUTPUT_TMDS</span><span class="p">,</span>
				     <span class="n">bios</span><span class="o">-&gt;</span><span class="n">legacy</span><span class="p">.</span><span class="n">i2c_indices</span><span class="p">.</span><span class="n">panel</span><span class="p">,</span>
				     <span class="n">all_heads</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">parse_dcb_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">outp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_nouveau_private</span> <span class="o">*</span><span class="n">dev_priv</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dcb_table</span> <span class="o">*</span><span class="n">dcb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">vbios</span><span class="p">.</span><span class="n">dcb</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">conf</span> <span class="o">=</span> <span class="p">(</span><span class="n">dcb</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">&gt;=</span> <span class="mh">0x20</span><span class="p">)</span> <span class="o">?</span> <span class="n">ROM32</span><span class="p">(</span><span class="n">outp</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span> <span class="o">:</span> <span class="n">ROM32</span><span class="p">(</span><span class="n">outp</span><span class="p">[</span><span class="mi">6</span><span class="p">]);</span>
	<span class="n">u32</span> <span class="n">conn</span> <span class="o">=</span> <span class="n">ROM32</span><span class="p">(</span><span class="n">outp</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">bool</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">apply_dcb_encoder_quirks</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">conn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">conf</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">dcb_entry</span> <span class="o">*</span><span class="n">entry</span> <span class="o">=</span> <span class="n">new_dcb_entry</span><span class="p">(</span><span class="n">dcb</span><span class="p">);</span>

		<span class="n">NV_TRACEWARN</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;DCB outp %02d: %08x %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">conn</span><span class="p">,</span> <span class="n">conf</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">dcb</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">&gt;=</span> <span class="mh">0x20</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">parse_dcb20_entry</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">dcb</span><span class="p">,</span> <span class="n">conn</span><span class="p">,</span> <span class="n">conf</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">parse_dcb15_entry</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">dcb</span><span class="p">,</span> <span class="n">conn</span><span class="p">,</span> <span class="n">conf</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* stop parsing */</span>

		<span class="cm">/* Ignore the I2C index for on-chip TV-out, as there</span>
<span class="cm">		 * are cards with bogus values (nv31m in bug 23212),</span>
<span class="cm">		 * and it&#39;s otherwise useless.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">OUTPUT_TV</span> <span class="o">&amp;&amp;</span>
		    <span class="n">entry</span><span class="o">-&gt;</span><span class="n">location</span> <span class="o">==</span> <span class="n">DCB_LOC_ON_CHIP</span><span class="p">)</span>
			<span class="n">entry</span><span class="o">-&gt;</span><span class="n">i2c_index</span> <span class="o">=</span> <span class="mh">0x0f</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">dcb_fake_connectors</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dcb_table</span> <span class="o">*</span><span class="n">dcbt</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">dcb</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">map</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">};</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* heuristic: if we ever get a non-zero connector field, assume</span>
<span class="cm">	 * that all the indices are valid and we don&#39;t need fake them.</span>
<span class="cm">	 *</span>
<span class="cm">	 * and, as usual, a blacklist of boards with bad bios data..</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nv_match_device</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x0392</span><span class="p">,</span> <span class="mh">0x107d</span><span class="p">,</span> <span class="mh">0x20a2</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dcbt</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dcbt</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">connector</span><span class="p">)</span>
				<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* no useful connector info available, we need to make it up</span>
<span class="cm">	 * ourselves.  the rule here is: anything on the same i2c bus</span>
<span class="cm">	 * is considered to be on the same connector.  any output</span>
<span class="cm">	 * without an associated i2c bus is assigned its own unique</span>
<span class="cm">	 * connector index.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dcbt</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u8</span> <span class="n">i2c</span> <span class="o">=</span> <span class="n">dcbt</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">i2c_index</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i2c</span> <span class="o">==</span> <span class="mh">0x0f</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dcbt</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">connector</span> <span class="o">=</span> <span class="n">idx</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">map</span><span class="p">[</span><span class="n">i2c</span><span class="p">])</span>
				<span class="n">map</span><span class="p">[</span><span class="n">i2c</span><span class="p">]</span> <span class="o">=</span> <span class="o">++</span><span class="n">idx</span><span class="p">;</span>
			<span class="n">dcbt</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">connector</span> <span class="o">=</span> <span class="n">map</span><span class="p">[</span><span class="n">i2c</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* if we created more than one connector, destroy the connector</span>
<span class="cm">	 * table - just in case it has random, rather than stub, entries.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u8</span> <span class="o">*</span><span class="n">conntab</span> <span class="o">=</span> <span class="n">dcb_conntab</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">conntab</span><span class="p">)</span>
			<span class="n">conntab</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">parse_dcb_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dcb_table</span> <span class="o">*</span><span class="n">dcb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">dcb</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">dcbt</span><span class="p">,</span> <span class="o">*</span><span class="n">conn</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">idx</span><span class="p">;</span>

	<span class="n">dcbt</span> <span class="o">=</span> <span class="n">dcb_table</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dcbt</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* handle pre-DCB boards */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">NVBIOS_BMP</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">fabricate_dcb_encoder_table</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">bios</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">NV_TRACE</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;DCB version %d.%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dcbt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">,</span> <span class="n">dcbt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">);</span>

	<span class="n">dcb</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">=</span> <span class="n">dcbt</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">dcb_outp_foreach</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">parse_dcb_entry</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * apart for v2.1+ not being known for requiring merging, this</span>
<span class="cm">	 * guarantees dcbent-&gt;index is the index of the entry in the rom image</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dcb</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">&lt;</span> <span class="mh">0x21</span><span class="p">)</span>
		<span class="n">merge_like_dcb_entries</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">dcb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dcb</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>

	<span class="cm">/* dump connector table entries to log, if any exist */</span>
	<span class="n">idx</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">conn</span> <span class="o">=</span> <span class="n">dcb_conn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">++</span><span class="n">idx</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">conn</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mh">0xff</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">NV_TRACE</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;DCB conn %02d: &quot;</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dcb_conntab</span><span class="p">(</span><span class="n">dev</span><span class="p">)[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">)</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ROM16</span><span class="p">(</span><span class="n">conn</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
			<span class="k">else</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ROM32</span><span class="p">(</span><span class="n">conn</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">dcb_fake_connectors</span><span class="p">(</span><span class="n">bios</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">load_nv17_hwsq_ucode_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">hwsq_offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">entry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * The header following the &quot;HWSQ&quot; signature has the number of entries,</span>
<span class="cm">	 * and the entry size</span>
<span class="cm">	 *</span>
<span class="cm">	 * An entry consists of a dword to write to the sequencer control reg</span>
<span class="cm">	 * (0x00001304), followed by the ucode bytes, written sequentially,</span>
<span class="cm">	 * starting at reg 0x00001400</span>
<span class="cm">	 */</span>

	<span class="kt">uint8_t</span> <span class="n">bytes_to_write</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">hwsq_entry_offset</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">hwsq_offset</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">NV_ERROR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Too few entries in HW sequencer table for &quot;</span>
				<span class="s">&quot;requested entry</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">bytes_to_write</span> <span class="o">=</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">hwsq_offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bytes_to_write</span> <span class="o">!=</span> <span class="mi">36</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">NV_ERROR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Unknown HW sequencer entry size</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">NV_TRACE</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Loading NV17 power sequencing microcode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">hwsq_entry_offset</span> <span class="o">=</span> <span class="n">hwsq_offset</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">entry</span> <span class="o">*</span> <span class="n">bytes_to_write</span><span class="p">;</span>

	<span class="cm">/* set sequencer control */</span>
	<span class="n">bios_wr32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="mh">0x00001304</span><span class="p">,</span> <span class="n">ROM32</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">hwsq_entry_offset</span><span class="p">]));</span>
	<span class="n">bytes_to_write</span> <span class="o">-=</span> <span class="mi">4</span><span class="p">;</span>

	<span class="cm">/* write ucode */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">bytes_to_write</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">)</span>
		<span class="n">bios_wr32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="mh">0x00001400</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">ROM32</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">hwsq_entry_offset</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">4</span><span class="p">]));</span>

	<span class="cm">/* twiddle NV_PBUS_DEBUG_4 */</span>
	<span class="n">bios_wr32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">NV_PBUS_DEBUG_4</span><span class="p">,</span> <span class="n">bios_rd32</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">NV_PBUS_DEBUG_4</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x18</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">load_nv17_hw_sequencer_ucode</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * BMP based cards, from NV17, need a microcode loading to correctly</span>
<span class="cm">	 * control the GPIO etc for LVDS panels</span>
<span class="cm">	 *</span>
<span class="cm">	 * BIT based cards seem to do this directly in the init scripts</span>
<span class="cm">	 *</span>
<span class="cm">	 * The microcode entries are found by the &quot;HWSQ&quot; signature.</span>
<span class="cm">	 */</span>

	<span class="k">const</span> <span class="kt">uint8_t</span> <span class="n">hwsq_signature</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="sc">&#39;H&#39;</span><span class="p">,</span> <span class="sc">&#39;W&#39;</span><span class="p">,</span> <span class="sc">&#39;S&#39;</span><span class="p">,</span> <span class="sc">&#39;Q&#39;</span> <span class="p">};</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">sz</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">hwsq_signature</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">hwsq_offset</span><span class="p">;</span>

	<span class="n">hwsq_offset</span> <span class="o">=</span> <span class="n">findstr</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span> <span class="n">hwsq_signature</span><span class="p">,</span> <span class="n">sz</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hwsq_offset</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* always use entry 0? */</span>
	<span class="k">return</span> <span class="n">load_nv17_hwsq_ucode_entry</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">bios</span><span class="p">,</span> <span class="n">hwsq_offset</span> <span class="o">+</span> <span class="n">sz</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">uint8_t</span> <span class="o">*</span><span class="nf">nouveau_bios_embedded_edid</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_nouveau_private</span> <span class="o">*</span><span class="n">dev_priv</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">vbios</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">uint8_t</span> <span class="n">edid_sig</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
			<span class="mh">0x00</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="mh">0x00</span> <span class="p">};</span>
	<span class="kt">uint16_t</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">newoffset</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">searchlen</span> <span class="o">=</span> <span class="n">NV_PROM_SIZE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">.</span><span class="n">edid</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">.</span><span class="n">edid</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">searchlen</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">newoffset</span> <span class="o">=</span> <span class="n">findstr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span><span class="p">],</span> <span class="n">searchlen</span><span class="p">,</span>
								<span class="n">edid_sig</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">newoffset</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">offset</span> <span class="o">+=</span> <span class="n">newoffset</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nv_cksum</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span><span class="p">],</span> <span class="n">EDID1_LEN</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">searchlen</span> <span class="o">-=</span> <span class="n">offset</span><span class="p">;</span>
		<span class="n">offset</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">NV_TRACE</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Found EDID in BIOS</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">.</span><span class="n">edid</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">offset</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">nouveau_bios_run_init_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">table</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">dcb_entry</span> <span class="o">*</span><span class="n">dcbent</span><span class="p">,</span> <span class="kt">int</span> <span class="n">crtc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_nouveau_private</span> <span class="o">*</span><span class="n">dev_priv</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">vbios</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">init_exec</span> <span class="n">iexec</span> <span class="o">=</span> <span class="p">{</span> <span class="nb">true</span><span class="p">,</span> <span class="nb">false</span> <span class="p">};</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">bios</span><span class="o">-&gt;</span><span class="n">display</span><span class="p">.</span><span class="n">output</span> <span class="o">=</span> <span class="n">dcbent</span><span class="p">;</span>
	<span class="n">bios</span><span class="o">-&gt;</span><span class="n">display</span><span class="p">.</span><span class="n">crtc</span> <span class="o">=</span> <span class="n">crtc</span><span class="p">;</span>
	<span class="n">parse_init_table</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">table</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iexec</span><span class="p">);</span>
	<span class="n">bios</span><span class="o">-&gt;</span><span class="n">display</span><span class="p">.</span><span class="n">output</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">nouveau_bios_init_exec</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">table</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_nouveau_private</span> <span class="o">*</span><span class="n">dev_priv</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">vbios</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">init_exec</span> <span class="n">iexec</span> <span class="o">=</span> <span class="p">{</span> <span class="nb">true</span><span class="p">,</span> <span class="nb">false</span> <span class="p">};</span>

	<span class="n">parse_init_table</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">table</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iexec</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">NVInitVBIOS</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_nouveau_private</span> <span class="o">*</span><span class="n">dev_priv</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">vbios</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvbios</span><span class="p">));</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">bios</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">bios_shadow</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nouveau_parse_vbios_struct</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_nouveau_private</span> <span class="o">*</span><span class="n">dev_priv</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">vbios</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">uint8_t</span> <span class="n">bit_signature</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0xff</span><span class="p">,</span> <span class="mh">0xb8</span><span class="p">,</span> <span class="sc">&#39;B&#39;</span><span class="p">,</span> <span class="sc">&#39;I&#39;</span><span class="p">,</span> <span class="sc">&#39;T&#39;</span> <span class="p">};</span>
	<span class="k">const</span> <span class="kt">uint8_t</span> <span class="n">bmp_signature</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0xff</span><span class="p">,</span> <span class="mh">0x7f</span><span class="p">,</span> <span class="sc">&#39;N&#39;</span><span class="p">,</span> <span class="sc">&#39;V&#39;</span><span class="p">,</span> <span class="mh">0x0</span> <span class="p">};</span>
	<span class="kt">int</span> <span class="n">offset</span><span class="p">;</span>

	<span class="n">offset</span> <span class="o">=</span> <span class="n">findstr</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span>
					<span class="n">bit_signature</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">bit_signature</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">NV_TRACE</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;BIT BIOS found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">bios</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">NVBIOS_BIT</span><span class="p">;</span>
		<span class="n">bios</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">parse_bit_structure</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">offset</span> <span class="o">+</span> <span class="mi">6</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">offset</span> <span class="o">=</span> <span class="n">findstr</span><span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span>
					<span class="n">bmp_signature</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">bmp_signature</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">NV_TRACE</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;BMP BIOS found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">bios</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">NVBIOS_BMP</span><span class="p">;</span>
		<span class="n">bios</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">parse_bmp_structure</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">bios</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">NV_ERROR</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;No known BIOS signature found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">nouveau_run_vbios_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_nouveau_private</span> <span class="o">*</span><span class="n">dev_priv</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">vbios</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Reset the BIOS head to 0. */</span>
	<span class="n">bios</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">.</span><span class="n">crtchead</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">major_version</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">)</span>	<span class="cm">/* BMP only */</span>
		<span class="n">load_nv17_hw_sequencer_ucode</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">bios</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bios</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">.</span><span class="n">last_script_invoc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">bios</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">.</span><span class="n">lvds_init_run</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">parse_init_tables</span><span class="p">(</span><span class="n">bios</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Runs some additional script seen on G8x VBIOSen.  The VBIOS&#39;</span>
<span class="cm">	 * parser will run this right after the init tables, the binary</span>
<span class="cm">	 * driver appears to run it at some point later.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">some_script_ptr</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">init_exec</span> <span class="n">iexec</span> <span class="o">=</span> <span class="p">{</span><span class="nb">true</span><span class="p">,</span> <span class="nb">false</span><span class="p">};</span>

		<span class="n">NV_INFO</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Parsing VBIOS init table at offset 0x%04X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">bios</span><span class="o">-&gt;</span><span class="n">some_script_ptr</span><span class="p">);</span>
		<span class="n">parse_init_table</span><span class="p">(</span><span class="n">bios</span><span class="p">,</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">some_script_ptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iexec</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">card_type</span> <span class="o">&gt;=</span> <span class="n">NV_50</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">dcb</span><span class="p">.</span><span class="n">entries</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">nouveau_bios_run_display_table</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
						       <span class="o">&amp;</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">dcb</span><span class="p">.</span><span class="n">entry</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span>
<span class="nf">nouveau_bios_posted</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_nouveau_private</span> <span class="o">*</span><span class="n">dev_priv</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_private</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">htotal</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">card_type</span> <span class="o">&gt;=</span> <span class="n">NV_50</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">NVReadVgaCrtc</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
		    <span class="n">NVReadVgaCrtc</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x1a</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">htotal</span>  <span class="o">=</span> <span class="n">NVReadVgaCrtc</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x06</span><span class="p">);</span>
	<span class="n">htotal</span> <span class="o">|=</span> <span class="p">(</span><span class="n">NVReadVgaCrtc</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x07</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">htotal</span> <span class="o">|=</span> <span class="p">(</span><span class="n">NVReadVgaCrtc</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x07</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x20</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">;</span>
	<span class="n">htotal</span> <span class="o">|=</span> <span class="p">(</span><span class="n">NVReadVgaCrtc</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x25</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">;</span>
	<span class="n">htotal</span> <span class="o">|=</span> <span class="p">(</span><span class="n">NVReadVgaCrtc</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x41</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">11</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">htotal</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">nouveau_bios_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_nouveau_private</span> <span class="o">*</span><span class="n">dev_priv</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nvbios</span> <span class="o">*</span><span class="n">bios</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">vbios</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">NVInitVBIOS</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">nouveau_parse_vbios_struct</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">nouveau_i2c_init</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">nouveau_mxm_init</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">parse_dcb_table</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">bios</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">major_version</span><span class="p">)</span>	<span class="cm">/* we don&#39;t run version 0 bios */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* init script execution disabled */</span>
	<span class="n">bios</span><span class="o">-&gt;</span><span class="n">execute</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* ... unless card isn&#39;t POSTed already */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nouveau_bios_posted</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">NV_INFO</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Adaptor not initialised, &quot;</span>
			<span class="s">&quot;running VBIOS init tables.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">bios</span><span class="o">-&gt;</span><span class="n">execute</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nouveau_force_post</span><span class="p">)</span>
		<span class="n">bios</span><span class="o">-&gt;</span><span class="n">execute</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">nouveau_run_vbios_init</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* feature_byte on BMP is poor, but init always sets CR4B */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">major_version</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">)</span>
		<span class="n">bios</span><span class="o">-&gt;</span><span class="n">is_mobile</span> <span class="o">=</span> <span class="n">NVReadVgaCrtc</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">NV_CIO_CRE_4B</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x40</span><span class="p">;</span>

	<span class="cm">/* all BIT systems need p_f_m_t for digital_min_front_porch */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bios</span><span class="o">-&gt;</span><span class="n">is_mobile</span> <span class="o">||</span> <span class="n">bios</span><span class="o">-&gt;</span><span class="n">major_version</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">parse_fp_mode_table</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">bios</span><span class="p">);</span>

	<span class="cm">/* allow subsequent scripts to execute */</span>
	<span class="n">bios</span><span class="o">-&gt;</span><span class="n">execute</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">nouveau_bios_takedown</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_nouveau_private</span> <span class="o">*</span><span class="n">dev_priv</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_private</span><span class="p">;</span>

	<span class="n">nouveau_mxm_fini</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">nouveau_i2c_fini</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">vbios</span><span class="p">.</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
