<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › gpu › drm › drm_modes.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>drm_modes.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright © 1997-2003 by The XFree86 Project, Inc.</span>
<span class="cm"> * Copyright © 2007 Dave Airlie</span>
<span class="cm"> * Copyright © 2007-2008 Intel Corporation</span>
<span class="cm"> *   Jesse Barnes &lt;jesse.barnes@intel.com&gt;</span>
<span class="cm"> * Copyright 2005-2006 Luc Verhaegen</span>
<span class="cm"> * Copyright (c) 2001, Andy Ritger  aritger@nvidia.com</span>
<span class="cm"> *</span>
<span class="cm"> * Permission is hereby granted, free of charge, to any person obtaining a</span>
<span class="cm"> * copy of this software and associated documentation files (the &quot;Software&quot;),</span>
<span class="cm"> * to deal in the Software without restriction, including without limitation</span>
<span class="cm"> * the rights to use, copy, modify, merge, publish, distribute, sublicense,</span>
<span class="cm"> * and/or sell copies of the Software, and to permit persons to whom the</span>
<span class="cm"> * Software is furnished to do so, subject to the following conditions:</span>
<span class="cm"> *</span>
<span class="cm"> * The above copyright notice and this permission notice shall be included in</span>
<span class="cm"> * all copies or substantial portions of the Software.</span>
<span class="cm"> *</span>
<span class="cm"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span>
<span class="cm"> * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL</span>
<span class="cm"> * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR</span>
<span class="cm"> * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,</span>
<span class="cm"> * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR</span>
<span class="cm"> * OTHER DEALINGS IN THE SOFTWARE.</span>
<span class="cm"> *</span>
<span class="cm"> * Except as contained in this notice, the name of the copyright holder(s)</span>
<span class="cm"> * and author(s) shall not be used in advertising or otherwise to promote</span>
<span class="cm"> * the sale, use or other dealings in this Software without prior written</span>
<span class="cm"> * authorization from the copyright holder(s) and author(s).</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/list_sort.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &quot;drmP.h&quot;</span>
<span class="cp">#include &quot;drm.h&quot;</span>
<span class="cp">#include &quot;drm_crtc.h&quot;</span>

<span class="cm">/**</span>
<span class="cm"> * drm_mode_debug_printmodeline - debug print a mode</span>
<span class="cm"> * @dev: DRM device</span>
<span class="cm"> * @mode: mode to print</span>
<span class="cm"> *</span>
<span class="cm"> * LOCKING:</span>
<span class="cm"> * None.</span>
<span class="cm"> *</span>
<span class="cm"> * Describe @mode using DRM_DEBUG.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">drm_mode_debug_printmodeline</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DRM_DEBUG_KMS</span><span class="p">(</span><span class="s">&quot;Modeline %d:</span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;</span><span class="s"> %d %d %d %d %d %d %d %d %d %d &quot;</span>
			<span class="s">&quot;0x%x 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">mode</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="n">mode</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">mode</span><span class="o">-&gt;</span><span class="n">vrefresh</span><span class="p">,</span> <span class="n">mode</span><span class="o">-&gt;</span><span class="n">clock</span><span class="p">,</span>
		<span class="n">mode</span><span class="o">-&gt;</span><span class="n">hdisplay</span><span class="p">,</span> <span class="n">mode</span><span class="o">-&gt;</span><span class="n">hsync_start</span><span class="p">,</span>
		<span class="n">mode</span><span class="o">-&gt;</span><span class="n">hsync_end</span><span class="p">,</span> <span class="n">mode</span><span class="o">-&gt;</span><span class="n">htotal</span><span class="p">,</span>
		<span class="n">mode</span><span class="o">-&gt;</span><span class="n">vdisplay</span><span class="p">,</span> <span class="n">mode</span><span class="o">-&gt;</span><span class="n">vsync_start</span><span class="p">,</span>
		<span class="n">mode</span><span class="o">-&gt;</span><span class="n">vsync_end</span><span class="p">,</span> <span class="n">mode</span><span class="o">-&gt;</span><span class="n">vtotal</span><span class="p">,</span> <span class="n">mode</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span> <span class="n">mode</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">drm_mode_debug_printmodeline</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * drm_cvt_mode -create a modeline based on CVT algorithm</span>
<span class="cm"> * @dev: DRM device</span>
<span class="cm"> * @hdisplay: hdisplay size</span>
<span class="cm"> * @vdisplay: vdisplay size</span>
<span class="cm"> * @vrefresh  : vrefresh rate</span>
<span class="cm"> * @reduced : Whether the GTF calculation is simplified</span>
<span class="cm"> * @interlaced:Whether the interlace is supported</span>
<span class="cm"> *</span>
<span class="cm"> * LOCKING:</span>
<span class="cm"> * none.</span>
<span class="cm"> *</span>
<span class="cm"> * return the modeline based on CVT algorithm</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called to generate the modeline based on CVT algorithm</span>
<span class="cm"> * according to the hdisplay, vdisplay, vrefresh.</span>
<span class="cm"> * It is based from the VESA(TM) Coordinated Video Timing Generator by</span>
<span class="cm"> * Graham Loveridge April 9, 2003 available at</span>
<span class="cm"> * http://www.elo.utfsm.cl/~elo212/docs/CVTd6r1.xls </span>
<span class="cm"> *</span>
<span class="cm"> * And it is copied from xf86CVTmode in xserver/hw/xfree86/modes/xf86cvt.c.</span>
<span class="cm"> * What I have done is to translate it by using integer calculation.</span>
<span class="cm"> */</span>
<span class="cp">#define HV_FACTOR			1000</span>
<span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="nf">drm_cvt_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">hdisplay</span><span class="p">,</span>
				      <span class="kt">int</span> <span class="n">vdisplay</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vrefresh</span><span class="p">,</span>
				      <span class="n">bool</span> <span class="n">reduced</span><span class="p">,</span> <span class="n">bool</span> <span class="n">interlaced</span><span class="p">,</span> <span class="n">bool</span> <span class="n">margins</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* 1) top/bottom margin size (% of height) - default: 1.8, */</span>
<span class="cp">#define	CVT_MARGIN_PERCENTAGE		18</span>
	<span class="cm">/* 2) character cell horizontal granularity (pixels) - default 8 */</span>
<span class="cp">#define	CVT_H_GRANULARITY		8</span>
	<span class="cm">/* 3) Minimum vertical porch (lines) - default 3 */</span>
<span class="cp">#define	CVT_MIN_V_PORCH			3</span>
	<span class="cm">/* 4) Minimum number of vertical back porch lines - default 6 */</span>
<span class="cp">#define	CVT_MIN_V_BPORCH		6</span>
	<span class="cm">/* Pixel Clock step (kHz) */</span>
<span class="cp">#define CVT_CLOCK_STEP			250</span>
	<span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="n">drm_mode</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">vfieldrate</span><span class="p">,</span> <span class="n">hperiod</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">hdisplay_rnd</span><span class="p">,</span> <span class="n">hmargin</span><span class="p">,</span> <span class="n">vdisplay_rnd</span><span class="p">,</span> <span class="n">vmargin</span><span class="p">,</span> <span class="n">vsync</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">interlace</span><span class="p">;</span>

	<span class="cm">/* allocate the drm_display_mode structure. If failure, we will</span>
<span class="cm">	 * return directly</span>
<span class="cm">	 */</span>
	<span class="n">drm_mode</span> <span class="o">=</span> <span class="n">drm_mode_create</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">drm_mode</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* the CVT default refresh rate is 60Hz */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vrefresh</span><span class="p">)</span>
		<span class="n">vrefresh</span> <span class="o">=</span> <span class="mi">60</span><span class="p">;</span>

	<span class="cm">/* the required field fresh rate */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">interlaced</span><span class="p">)</span>
		<span class="n">vfieldrate</span> <span class="o">=</span> <span class="n">vrefresh</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">vfieldrate</span> <span class="o">=</span> <span class="n">vrefresh</span><span class="p">;</span>

	<span class="cm">/* horizontal pixels */</span>
	<span class="n">hdisplay_rnd</span> <span class="o">=</span> <span class="n">hdisplay</span> <span class="o">-</span> <span class="p">(</span><span class="n">hdisplay</span> <span class="o">%</span> <span class="n">CVT_H_GRANULARITY</span><span class="p">);</span>

	<span class="cm">/* determine the left&amp;right borders */</span>
	<span class="n">hmargin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">margins</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hmargin</span> <span class="o">=</span> <span class="n">hdisplay_rnd</span> <span class="o">*</span> <span class="n">CVT_MARGIN_PERCENTAGE</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">;</span>
		<span class="n">hmargin</span> <span class="o">-=</span> <span class="n">hmargin</span> <span class="o">%</span> <span class="n">CVT_H_GRANULARITY</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* find the total active pixels */</span>
	<span class="n">drm_mode</span><span class="o">-&gt;</span><span class="n">hdisplay</span> <span class="o">=</span> <span class="n">hdisplay_rnd</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">hmargin</span><span class="p">;</span>

	<span class="cm">/* find the number of lines per field */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">interlaced</span><span class="p">)</span>
		<span class="n">vdisplay_rnd</span> <span class="o">=</span> <span class="n">vdisplay</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">vdisplay_rnd</span> <span class="o">=</span> <span class="n">vdisplay</span><span class="p">;</span>

	<span class="cm">/* find the top &amp; bottom borders */</span>
	<span class="n">vmargin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">margins</span><span class="p">)</span>
		<span class="n">vmargin</span> <span class="o">=</span> <span class="n">vdisplay_rnd</span> <span class="o">*</span> <span class="n">CVT_MARGIN_PERCENTAGE</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">;</span>

	<span class="n">drm_mode</span><span class="o">-&gt;</span><span class="n">vdisplay</span> <span class="o">=</span> <span class="n">vdisplay</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">vmargin</span><span class="p">;</span>

	<span class="cm">/* Interlaced */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">interlaced</span><span class="p">)</span>
		<span class="n">interlace</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">interlace</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Determine VSync Width from aspect ratio */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vdisplay</span> <span class="o">%</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">vdisplay</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="n">hdisplay</span><span class="p">))</span>
		<span class="n">vsync</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vdisplay</span> <span class="o">%</span> <span class="mi">9</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">vdisplay</span> <span class="o">*</span> <span class="mi">16</span> <span class="o">/</span> <span class="mi">9</span><span class="p">)</span> <span class="o">==</span> <span class="n">hdisplay</span><span class="p">))</span>
		<span class="n">vsync</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vdisplay</span> <span class="o">%</span> <span class="mi">10</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">vdisplay</span> <span class="o">*</span> <span class="mi">16</span> <span class="o">/</span> <span class="mi">10</span><span class="p">)</span> <span class="o">==</span> <span class="n">hdisplay</span><span class="p">))</span>
		<span class="n">vsync</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vdisplay</span> <span class="o">%</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">vdisplay</span> <span class="o">*</span> <span class="mi">5</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span> <span class="o">==</span> <span class="n">hdisplay</span><span class="p">))</span>
		<span class="n">vsync</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vdisplay</span> <span class="o">%</span> <span class="mi">9</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">vdisplay</span> <span class="o">*</span> <span class="mi">15</span> <span class="o">/</span> <span class="mi">9</span><span class="p">)</span> <span class="o">==</span> <span class="n">hdisplay</span><span class="p">))</span>
		<span class="n">vsync</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
	<span class="k">else</span> <span class="cm">/* custom */</span>
		<span class="n">vsync</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">reduced</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* simplify the GTF calculation */</span>
		<span class="cm">/* 4) Minimum time of vertical sync + back porch interval (µs)</span>
<span class="cm">		 * default 550.0</span>
<span class="cm">		 */</span>
		<span class="kt">int</span> <span class="n">tmp1</span><span class="p">,</span> <span class="n">tmp2</span><span class="p">;</span>
<span class="cp">#define CVT_MIN_VSYNC_BP	550</span>
		<span class="cm">/* 3) Nominal HSync width (% of line period) - default 8 */</span>
<span class="cp">#define CVT_HSYNC_PERCENTAGE	8</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hblank_percentage</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">vsyncandback_porch</span><span class="p">,</span> <span class="n">vback_porch</span><span class="p">,</span> <span class="n">hblank</span><span class="p">;</span>

		<span class="cm">/* estimated the horizontal period */</span>
		<span class="n">tmp1</span> <span class="o">=</span> <span class="n">HV_FACTOR</span> <span class="o">*</span> <span class="mi">1000000</span>  <span class="o">-</span>
				<span class="n">CVT_MIN_VSYNC_BP</span> <span class="o">*</span> <span class="n">HV_FACTOR</span> <span class="o">*</span> <span class="n">vfieldrate</span><span class="p">;</span>
		<span class="n">tmp2</span> <span class="o">=</span> <span class="p">(</span><span class="n">vdisplay_rnd</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">vmargin</span> <span class="o">+</span> <span class="n">CVT_MIN_V_PORCH</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span>
				<span class="n">interlace</span><span class="p">;</span>
		<span class="n">hperiod</span> <span class="o">=</span> <span class="n">tmp1</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="n">tmp2</span> <span class="o">*</span> <span class="n">vfieldrate</span><span class="p">);</span>

		<span class="n">tmp1</span> <span class="o">=</span> <span class="n">CVT_MIN_VSYNC_BP</span> <span class="o">*</span> <span class="n">HV_FACTOR</span> <span class="o">/</span> <span class="n">hperiod</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* 9. Find number of lines in sync + backporch */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmp1</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">vsync</span> <span class="o">+</span> <span class="n">CVT_MIN_V_PORCH</span><span class="p">))</span>
			<span class="n">vsyncandback_porch</span> <span class="o">=</span> <span class="n">vsync</span> <span class="o">+</span> <span class="n">CVT_MIN_V_PORCH</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">vsyncandback_porch</span> <span class="o">=</span> <span class="n">tmp1</span><span class="p">;</span>
		<span class="cm">/* 10. Find number of lines in back porch */</span>
		<span class="n">vback_porch</span> <span class="o">=</span> <span class="n">vsyncandback_porch</span> <span class="o">-</span> <span class="n">vsync</span><span class="p">;</span>
		<span class="n">drm_mode</span><span class="o">-&gt;</span><span class="n">vtotal</span> <span class="o">=</span> <span class="n">vdisplay_rnd</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">vmargin</span> <span class="o">+</span>
				<span class="n">vsyncandback_porch</span> <span class="o">+</span> <span class="n">CVT_MIN_V_PORCH</span><span class="p">;</span>
		<span class="cm">/* 5) Definition of Horizontal blanking time limitation */</span>
		<span class="cm">/* Gradient (%/kHz) - default 600 */</span>
<span class="cp">#define CVT_M_FACTOR	600</span>
		<span class="cm">/* Offset (%) - default 40 */</span>
<span class="cp">#define CVT_C_FACTOR	40</span>
		<span class="cm">/* Blanking time scaling factor - default 128 */</span>
<span class="cp">#define CVT_K_FACTOR	128</span>
		<span class="cm">/* Scaling factor weighting - default 20 */</span>
<span class="cp">#define CVT_J_FACTOR	20</span>
<span class="cp">#define CVT_M_PRIME	(CVT_M_FACTOR * CVT_K_FACTOR / 256)</span>
<span class="cp">#define CVT_C_PRIME	((CVT_C_FACTOR - CVT_J_FACTOR) * CVT_K_FACTOR / 256 + \</span>
<span class="cp">			 CVT_J_FACTOR)</span>
		<span class="cm">/* 12. Find ideal blanking duty cycle from formula */</span>
		<span class="n">hblank_percentage</span> <span class="o">=</span> <span class="n">CVT_C_PRIME</span> <span class="o">*</span> <span class="n">HV_FACTOR</span> <span class="o">-</span> <span class="n">CVT_M_PRIME</span> <span class="o">*</span>
					<span class="n">hperiod</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">;</span>
		<span class="cm">/* 13. Blanking time */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hblank_percentage</span> <span class="o">&lt;</span> <span class="mi">20</span> <span class="o">*</span> <span class="n">HV_FACTOR</span><span class="p">)</span>
			<span class="n">hblank_percentage</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">*</span> <span class="n">HV_FACTOR</span><span class="p">;</span>
		<span class="n">hblank</span> <span class="o">=</span> <span class="n">drm_mode</span><span class="o">-&gt;</span><span class="n">hdisplay</span> <span class="o">*</span> <span class="n">hblank_percentage</span> <span class="o">/</span>
			 <span class="p">(</span><span class="mi">100</span> <span class="o">*</span> <span class="n">HV_FACTOR</span> <span class="o">-</span> <span class="n">hblank_percentage</span><span class="p">);</span>
		<span class="n">hblank</span> <span class="o">-=</span> <span class="n">hblank</span> <span class="o">%</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">CVT_H_GRANULARITY</span><span class="p">);</span>
		<span class="cm">/* 14. find the total pixes per line */</span>
		<span class="n">drm_mode</span><span class="o">-&gt;</span><span class="n">htotal</span> <span class="o">=</span> <span class="n">drm_mode</span><span class="o">-&gt;</span><span class="n">hdisplay</span> <span class="o">+</span> <span class="n">hblank</span><span class="p">;</span>
		<span class="n">drm_mode</span><span class="o">-&gt;</span><span class="n">hsync_end</span> <span class="o">=</span> <span class="n">drm_mode</span><span class="o">-&gt;</span><span class="n">hdisplay</span> <span class="o">+</span> <span class="n">hblank</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">drm_mode</span><span class="o">-&gt;</span><span class="n">hsync_start</span> <span class="o">=</span> <span class="n">drm_mode</span><span class="o">-&gt;</span><span class="n">hsync_end</span> <span class="o">-</span>
			<span class="p">(</span><span class="n">drm_mode</span><span class="o">-&gt;</span><span class="n">htotal</span> <span class="o">*</span> <span class="n">CVT_HSYNC_PERCENTAGE</span><span class="p">)</span> <span class="o">/</span> <span class="mi">100</span><span class="p">;</span>
		<span class="n">drm_mode</span><span class="o">-&gt;</span><span class="n">hsync_start</span> <span class="o">+=</span> <span class="n">CVT_H_GRANULARITY</span> <span class="o">-</span>
			<span class="n">drm_mode</span><span class="o">-&gt;</span><span class="n">hsync_start</span> <span class="o">%</span> <span class="n">CVT_H_GRANULARITY</span><span class="p">;</span>
		<span class="cm">/* fill the Vsync values */</span>
		<span class="n">drm_mode</span><span class="o">-&gt;</span><span class="n">vsync_start</span> <span class="o">=</span> <span class="n">drm_mode</span><span class="o">-&gt;</span><span class="n">vdisplay</span> <span class="o">+</span> <span class="n">CVT_MIN_V_PORCH</span><span class="p">;</span>
		<span class="n">drm_mode</span><span class="o">-&gt;</span><span class="n">vsync_end</span> <span class="o">=</span> <span class="n">drm_mode</span><span class="o">-&gt;</span><span class="n">vsync_start</span> <span class="o">+</span> <span class="n">vsync</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Reduced blanking */</span>
		<span class="cm">/* Minimum vertical blanking interval time (µs)- default 460 */</span>
<span class="cp">#define CVT_RB_MIN_VBLANK	460</span>
		<span class="cm">/* Fixed number of clocks for horizontal sync */</span>
<span class="cp">#define CVT_RB_H_SYNC		32</span>
		<span class="cm">/* Fixed number of clocks for horizontal blanking */</span>
<span class="cp">#define CVT_RB_H_BLANK		160</span>
		<span class="cm">/* Fixed number of lines for vertical front porch - default 3*/</span>
<span class="cp">#define CVT_RB_VFPORCH		3</span>
		<span class="kt">int</span> <span class="n">vbilines</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">tmp1</span><span class="p">,</span> <span class="n">tmp2</span><span class="p">;</span>
		<span class="cm">/* 8. Estimate Horizontal period. */</span>
		<span class="n">tmp1</span> <span class="o">=</span> <span class="n">HV_FACTOR</span> <span class="o">*</span> <span class="mi">1000000</span> <span class="o">-</span>
			<span class="n">CVT_RB_MIN_VBLANK</span> <span class="o">*</span> <span class="n">HV_FACTOR</span> <span class="o">*</span> <span class="n">vfieldrate</span><span class="p">;</span>
		<span class="n">tmp2</span> <span class="o">=</span> <span class="n">vdisplay_rnd</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">vmargin</span><span class="p">;</span>
		<span class="n">hperiod</span> <span class="o">=</span> <span class="n">tmp1</span> <span class="o">/</span> <span class="p">(</span><span class="n">tmp2</span> <span class="o">*</span> <span class="n">vfieldrate</span><span class="p">);</span>
		<span class="cm">/* 9. Find number of lines in vertical blanking */</span>
		<span class="n">vbilines</span> <span class="o">=</span> <span class="n">CVT_RB_MIN_VBLANK</span> <span class="o">*</span> <span class="n">HV_FACTOR</span> <span class="o">/</span> <span class="n">hperiod</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* 10. Check if vertical blanking is sufficient */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vbilines</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">CVT_RB_VFPORCH</span> <span class="o">+</span> <span class="n">vsync</span> <span class="o">+</span> <span class="n">CVT_MIN_V_BPORCH</span><span class="p">))</span>
			<span class="n">vbilines</span> <span class="o">=</span> <span class="n">CVT_RB_VFPORCH</span> <span class="o">+</span> <span class="n">vsync</span> <span class="o">+</span> <span class="n">CVT_MIN_V_BPORCH</span><span class="p">;</span>
		<span class="cm">/* 11. Find total number of lines in vertical field */</span>
		<span class="n">drm_mode</span><span class="o">-&gt;</span><span class="n">vtotal</span> <span class="o">=</span> <span class="n">vdisplay_rnd</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">vmargin</span> <span class="o">+</span> <span class="n">vbilines</span><span class="p">;</span>
		<span class="cm">/* 12. Find total number of pixels in a line */</span>
		<span class="n">drm_mode</span><span class="o">-&gt;</span><span class="n">htotal</span> <span class="o">=</span> <span class="n">drm_mode</span><span class="o">-&gt;</span><span class="n">hdisplay</span> <span class="o">+</span> <span class="n">CVT_RB_H_BLANK</span><span class="p">;</span>
		<span class="cm">/* Fill in HSync values */</span>
		<span class="n">drm_mode</span><span class="o">-&gt;</span><span class="n">hsync_end</span> <span class="o">=</span> <span class="n">drm_mode</span><span class="o">-&gt;</span><span class="n">hdisplay</span> <span class="o">+</span> <span class="n">CVT_RB_H_BLANK</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">drm_mode</span><span class="o">-&gt;</span><span class="n">hsync_start</span> <span class="o">=</span> <span class="n">drm_mode</span><span class="o">-&gt;</span><span class="n">hsync_end</span> <span class="o">-</span> <span class="n">CVT_RB_H_SYNC</span><span class="p">;</span>
		<span class="cm">/* Fill in VSync values */</span>
		<span class="n">drm_mode</span><span class="o">-&gt;</span><span class="n">vsync_start</span> <span class="o">=</span> <span class="n">drm_mode</span><span class="o">-&gt;</span><span class="n">vdisplay</span> <span class="o">+</span> <span class="n">CVT_RB_VFPORCH</span><span class="p">;</span>
		<span class="n">drm_mode</span><span class="o">-&gt;</span><span class="n">vsync_end</span> <span class="o">=</span> <span class="n">drm_mode</span><span class="o">-&gt;</span><span class="n">vsync_start</span> <span class="o">+</span> <span class="n">vsync</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* 15/13. Find pixel clock frequency (kHz for xf86) */</span>
	<span class="n">drm_mode</span><span class="o">-&gt;</span><span class="n">clock</span> <span class="o">=</span> <span class="n">drm_mode</span><span class="o">-&gt;</span><span class="n">htotal</span> <span class="o">*</span> <span class="n">HV_FACTOR</span> <span class="o">*</span> <span class="mi">1000</span> <span class="o">/</span> <span class="n">hperiod</span><span class="p">;</span>
	<span class="n">drm_mode</span><span class="o">-&gt;</span><span class="n">clock</span> <span class="o">-=</span> <span class="n">drm_mode</span><span class="o">-&gt;</span><span class="n">clock</span> <span class="o">%</span> <span class="n">CVT_CLOCK_STEP</span><span class="p">;</span>
	<span class="cm">/* 18/16. Find actual vertical frame frequency */</span>
	<span class="cm">/* ignore - just set the mode flag for interlaced */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">interlaced</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">drm_mode</span><span class="o">-&gt;</span><span class="n">vtotal</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">drm_mode</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">DRM_MODE_FLAG_INTERLACE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Fill the mode line name */</span>
	<span class="n">drm_mode_set_name</span><span class="p">(</span><span class="n">drm_mode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reduced</span><span class="p">)</span>
		<span class="n">drm_mode</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="p">(</span><span class="n">DRM_MODE_FLAG_PHSYNC</span> <span class="o">|</span>
					<span class="n">DRM_MODE_FLAG_NVSYNC</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">drm_mode</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="p">(</span><span class="n">DRM_MODE_FLAG_PVSYNC</span> <span class="o">|</span>
					<span class="n">DRM_MODE_FLAG_NHSYNC</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">drm_mode</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">drm_cvt_mode</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * drm_gtf_mode_complex - create the modeline based on full GTF algorithm</span>
<span class="cm"> *</span>
<span class="cm"> * @dev		:drm device</span>
<span class="cm"> * @hdisplay	:hdisplay size</span>
<span class="cm"> * @vdisplay	:vdisplay size</span>
<span class="cm"> * @vrefresh	:vrefresh rate.</span>
<span class="cm"> * @interlaced	:whether the interlace is supported</span>
<span class="cm"> * @margins	:desired margin size</span>
<span class="cm"> * @GTF_[MCKJ]  :extended GTF formula parameters</span>
<span class="cm"> *</span>
<span class="cm"> * LOCKING.</span>
<span class="cm"> * none.</span>
<span class="cm"> *</span>
<span class="cm"> * return the modeline based on full GTF algorithm.</span>
<span class="cm"> *</span>
<span class="cm"> * GTF feature blocks specify C and J in multiples of 0.5, so we pass them</span>
<span class="cm"> * in here multiplied by two.  For a C of 40, pass in 80.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span>
<span class="nf">drm_gtf_mode_complex</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">hdisplay</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vdisplay</span><span class="p">,</span>
		     <span class="kt">int</span> <span class="n">vrefresh</span><span class="p">,</span> <span class="n">bool</span> <span class="n">interlaced</span><span class="p">,</span> <span class="kt">int</span> <span class="n">margins</span><span class="p">,</span>
		     <span class="kt">int</span> <span class="n">GTF_M</span><span class="p">,</span> <span class="kt">int</span> <span class="n">GTF_2C</span><span class="p">,</span> <span class="kt">int</span> <span class="n">GTF_K</span><span class="p">,</span> <span class="kt">int</span> <span class="n">GTF_2J</span><span class="p">)</span>
<span class="p">{</span>	<span class="cm">/* 1) top/bottom margin size (% of height) - default: 1.8, */</span>
<span class="cp">#define	GTF_MARGIN_PERCENTAGE		18</span>
	<span class="cm">/* 2) character cell horizontal granularity (pixels) - default 8 */</span>
<span class="cp">#define	GTF_CELL_GRAN			8</span>
	<span class="cm">/* 3) Minimum vertical porch (lines) - default 3 */</span>
<span class="cp">#define	GTF_MIN_V_PORCH			1</span>
	<span class="cm">/* width of vsync in lines */</span>
<span class="cp">#define V_SYNC_RQD			3</span>
	<span class="cm">/* width of hsync as % of total line */</span>
<span class="cp">#define H_SYNC_PERCENT			8</span>
	<span class="cm">/* min time of vsync + back porch (microsec) */</span>
<span class="cp">#define MIN_VSYNC_PLUS_BP		550</span>
	<span class="cm">/* C&#39; and M&#39; are part of the Blanking Duty Cycle computation */</span>
<span class="cp">#define GTF_C_PRIME	((((GTF_2C - GTF_2J) * GTF_K / 256) + GTF_2J) / 2)</span>
<span class="cp">#define GTF_M_PRIME	(GTF_K * GTF_M / 256)</span>
	<span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="n">drm_mode</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hdisplay_rnd</span><span class="p">,</span> <span class="n">vdisplay_rnd</span><span class="p">,</span> <span class="n">vfieldrate_rqd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">top_margin</span><span class="p">,</span> <span class="n">bottom_margin</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">interlace</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hfreq_est</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">vsync_plus_bp</span><span class="p">,</span> <span class="n">vback_porch</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">vtotal_lines</span><span class="p">,</span> <span class="n">vfieldrate_est</span><span class="p">,</span> <span class="n">hperiod</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">vfield_rate</span><span class="p">,</span> <span class="n">vframe_rate</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">left_margin</span><span class="p">,</span> <span class="n">right_margin</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">total_active_pixels</span><span class="p">,</span> <span class="n">ideal_duty_cycle</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hblank</span><span class="p">,</span> <span class="n">total_pixels</span><span class="p">,</span> <span class="n">pixel_freq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">hsync</span><span class="p">,</span> <span class="n">hfront_porch</span><span class="p">,</span> <span class="n">vodd_front_porch_lines</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tmp1</span><span class="p">,</span> <span class="n">tmp2</span><span class="p">;</span>

	<span class="n">drm_mode</span> <span class="o">=</span> <span class="n">drm_mode_create</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">drm_mode</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* 1. In order to give correct results, the number of horizontal</span>
<span class="cm">	 * pixels requested is first processed to ensure that it is divisible</span>
<span class="cm">	 * by the character size, by rounding it to the nearest character</span>
<span class="cm">	 * cell boundary:</span>
<span class="cm">	 */</span>
	<span class="n">hdisplay_rnd</span> <span class="o">=</span> <span class="p">(</span><span class="n">hdisplay</span> <span class="o">+</span> <span class="n">GTF_CELL_GRAN</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">GTF_CELL_GRAN</span><span class="p">;</span>
	<span class="n">hdisplay_rnd</span> <span class="o">=</span> <span class="n">hdisplay_rnd</span> <span class="o">*</span> <span class="n">GTF_CELL_GRAN</span><span class="p">;</span>

	<span class="cm">/* 2. If interlace is requested, the number of vertical lines assumed</span>
<span class="cm">	 * by the calculation must be halved, as the computation calculates</span>
<span class="cm">	 * the number of vertical lines per field.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">interlaced</span><span class="p">)</span>
		<span class="n">vdisplay_rnd</span> <span class="o">=</span> <span class="n">vdisplay</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">vdisplay_rnd</span> <span class="o">=</span> <span class="n">vdisplay</span><span class="p">;</span>

	<span class="cm">/* 3. Find the frame rate required: */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">interlaced</span><span class="p">)</span>
		<span class="n">vfieldrate_rqd</span> <span class="o">=</span> <span class="n">vrefresh</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">vfieldrate_rqd</span> <span class="o">=</span> <span class="n">vrefresh</span><span class="p">;</span>

	<span class="cm">/* 4. Find number of lines in Top margin: */</span>
	<span class="n">top_margin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">margins</span><span class="p">)</span>
		<span class="n">top_margin</span> <span class="o">=</span> <span class="p">(</span><span class="n">vdisplay_rnd</span> <span class="o">*</span> <span class="n">GTF_MARGIN_PERCENTAGE</span> <span class="o">+</span> <span class="mi">500</span><span class="p">)</span> <span class="o">/</span>
				<span class="mi">1000</span><span class="p">;</span>
	<span class="cm">/* 5. Find number of lines in bottom margin: */</span>
	<span class="n">bottom_margin</span> <span class="o">=</span> <span class="n">top_margin</span><span class="p">;</span>

	<span class="cm">/* 6. If interlace is required, then set variable interlace: */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">interlaced</span><span class="p">)</span>
		<span class="n">interlace</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">interlace</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* 7. Estimate the Horizontal frequency */</span>
	<span class="p">{</span>
		<span class="n">tmp1</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1000000</span>  <span class="o">-</span> <span class="n">MIN_VSYNC_PLUS_BP</span> <span class="o">*</span> <span class="n">vfieldrate_rqd</span><span class="p">)</span> <span class="o">/</span> <span class="mi">500</span><span class="p">;</span>
		<span class="n">tmp2</span> <span class="o">=</span> <span class="p">(</span><span class="n">vdisplay_rnd</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">top_margin</span> <span class="o">+</span> <span class="n">GTF_MIN_V_PORCH</span><span class="p">)</span> <span class="o">*</span>
				<span class="mi">2</span> <span class="o">+</span> <span class="n">interlace</span><span class="p">;</span>
		<span class="n">hfreq_est</span> <span class="o">=</span> <span class="p">(</span><span class="n">tmp2</span> <span class="o">*</span> <span class="mi">1000</span> <span class="o">*</span> <span class="n">vfieldrate_rqd</span><span class="p">)</span> <span class="o">/</span> <span class="n">tmp1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* 8. Find the number of lines in V sync + back porch */</span>
	<span class="cm">/* [V SYNC+BP] = RINT(([MIN VSYNC+BP] * hfreq_est / 1000000)) */</span>
	<span class="n">vsync_plus_bp</span> <span class="o">=</span> <span class="n">MIN_VSYNC_PLUS_BP</span> <span class="o">*</span> <span class="n">hfreq_est</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">;</span>
	<span class="n">vsync_plus_bp</span> <span class="o">=</span> <span class="p">(</span><span class="n">vsync_plus_bp</span> <span class="o">+</span> <span class="mi">500</span><span class="p">)</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">;</span>
	<span class="cm">/*  9. Find the number of lines in V back porch alone: */</span>
	<span class="n">vback_porch</span> <span class="o">=</span> <span class="n">vsync_plus_bp</span> <span class="o">-</span> <span class="n">V_SYNC_RQD</span><span class="p">;</span>
	<span class="cm">/*  10. Find the total number of lines in Vertical field period: */</span>
	<span class="n">vtotal_lines</span> <span class="o">=</span> <span class="n">vdisplay_rnd</span> <span class="o">+</span> <span class="n">top_margin</span> <span class="o">+</span> <span class="n">bottom_margin</span> <span class="o">+</span>
			<span class="n">vsync_plus_bp</span> <span class="o">+</span> <span class="n">GTF_MIN_V_PORCH</span><span class="p">;</span>
	<span class="cm">/*  11. Estimate the Vertical field frequency: */</span>
	<span class="n">vfieldrate_est</span> <span class="o">=</span> <span class="n">hfreq_est</span> <span class="o">/</span> <span class="n">vtotal_lines</span><span class="p">;</span>
	<span class="cm">/*  12. Find the actual horizontal period: */</span>
	<span class="n">hperiod</span> <span class="o">=</span> <span class="mi">1000000</span> <span class="o">/</span> <span class="p">(</span><span class="n">vfieldrate_rqd</span> <span class="o">*</span> <span class="n">vtotal_lines</span><span class="p">);</span>

	<span class="cm">/*  13. Find the actual Vertical field frequency: */</span>
	<span class="n">vfield_rate</span> <span class="o">=</span> <span class="n">hfreq_est</span> <span class="o">/</span> <span class="n">vtotal_lines</span><span class="p">;</span>
	<span class="cm">/*  14. Find the Vertical frame frequency: */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">interlaced</span><span class="p">)</span>
		<span class="n">vframe_rate</span> <span class="o">=</span> <span class="n">vfield_rate</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">vframe_rate</span> <span class="o">=</span> <span class="n">vfield_rate</span><span class="p">;</span>
	<span class="cm">/*  15. Find number of pixels in left margin: */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">margins</span><span class="p">)</span>
		<span class="n">left_margin</span> <span class="o">=</span> <span class="p">(</span><span class="n">hdisplay_rnd</span> <span class="o">*</span> <span class="n">GTF_MARGIN_PERCENTAGE</span> <span class="o">+</span> <span class="mi">500</span><span class="p">)</span> <span class="o">/</span>
				<span class="mi">1000</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">left_margin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* 16.Find number of pixels in right margin: */</span>
	<span class="n">right_margin</span> <span class="o">=</span> <span class="n">left_margin</span><span class="p">;</span>
	<span class="cm">/* 17.Find total number of active pixels in image and left and right */</span>
	<span class="n">total_active_pixels</span> <span class="o">=</span> <span class="n">hdisplay_rnd</span> <span class="o">+</span> <span class="n">left_margin</span> <span class="o">+</span> <span class="n">right_margin</span><span class="p">;</span>
	<span class="cm">/* 18.Find the ideal blanking duty cycle from blanking duty cycle */</span>
	<span class="n">ideal_duty_cycle</span> <span class="o">=</span> <span class="n">GTF_C_PRIME</span> <span class="o">*</span> <span class="mi">1000</span> <span class="o">-</span>
				<span class="p">(</span><span class="n">GTF_M_PRIME</span> <span class="o">*</span> <span class="mi">1000000</span> <span class="o">/</span> <span class="n">hfreq_est</span><span class="p">);</span>
	<span class="cm">/* 19.Find the number of pixels in the blanking time to the nearest</span>
<span class="cm">	 * double character cell: */</span>
	<span class="n">hblank</span> <span class="o">=</span> <span class="n">total_active_pixels</span> <span class="o">*</span> <span class="n">ideal_duty_cycle</span> <span class="o">/</span>
			<span class="p">(</span><span class="mi">100000</span> <span class="o">-</span> <span class="n">ideal_duty_cycle</span><span class="p">);</span>
	<span class="n">hblank</span> <span class="o">=</span> <span class="p">(</span><span class="n">hblank</span> <span class="o">+</span> <span class="n">GTF_CELL_GRAN</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">GTF_CELL_GRAN</span><span class="p">);</span>
	<span class="n">hblank</span> <span class="o">=</span> <span class="n">hblank</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">GTF_CELL_GRAN</span><span class="p">;</span>
	<span class="cm">/* 20.Find total number of pixels: */</span>
	<span class="n">total_pixels</span> <span class="o">=</span> <span class="n">total_active_pixels</span> <span class="o">+</span> <span class="n">hblank</span><span class="p">;</span>
	<span class="cm">/* 21.Find pixel clock frequency: */</span>
	<span class="n">pixel_freq</span> <span class="o">=</span> <span class="n">total_pixels</span> <span class="o">*</span> <span class="n">hfreq_est</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">;</span>
	<span class="cm">/* Stage 1 computations are now complete; I should really pass</span>
<span class="cm">	 * the results to another function and do the Stage 2 computations,</span>
<span class="cm">	 * but I only need a few more values so I&#39;ll just append the</span>
<span class="cm">	 * computations here for now */</span>
	<span class="cm">/* 17. Find the number of pixels in the horizontal sync period: */</span>
	<span class="n">hsync</span> <span class="o">=</span> <span class="n">H_SYNC_PERCENT</span> <span class="o">*</span> <span class="n">total_pixels</span> <span class="o">/</span> <span class="mi">100</span><span class="p">;</span>
	<span class="n">hsync</span> <span class="o">=</span> <span class="p">(</span><span class="n">hsync</span> <span class="o">+</span> <span class="n">GTF_CELL_GRAN</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">GTF_CELL_GRAN</span><span class="p">;</span>
	<span class="n">hsync</span> <span class="o">=</span> <span class="n">hsync</span> <span class="o">*</span> <span class="n">GTF_CELL_GRAN</span><span class="p">;</span>
	<span class="cm">/* 18. Find the number of pixels in horizontal front porch period */</span>
	<span class="n">hfront_porch</span> <span class="o">=</span> <span class="n">hblank</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">hsync</span><span class="p">;</span>
	<span class="cm">/*  36. Find the number of lines in the odd front porch period: */</span>
	<span class="n">vodd_front_porch_lines</span> <span class="o">=</span> <span class="n">GTF_MIN_V_PORCH</span> <span class="p">;</span>

	<span class="cm">/* finally, pack the results in the mode struct */</span>
	<span class="n">drm_mode</span><span class="o">-&gt;</span><span class="n">hdisplay</span> <span class="o">=</span> <span class="n">hdisplay_rnd</span><span class="p">;</span>
	<span class="n">drm_mode</span><span class="o">-&gt;</span><span class="n">hsync_start</span> <span class="o">=</span> <span class="n">hdisplay_rnd</span> <span class="o">+</span> <span class="n">hfront_porch</span><span class="p">;</span>
	<span class="n">drm_mode</span><span class="o">-&gt;</span><span class="n">hsync_end</span> <span class="o">=</span> <span class="n">drm_mode</span><span class="o">-&gt;</span><span class="n">hsync_start</span> <span class="o">+</span> <span class="n">hsync</span><span class="p">;</span>
	<span class="n">drm_mode</span><span class="o">-&gt;</span><span class="n">htotal</span> <span class="o">=</span> <span class="n">total_pixels</span><span class="p">;</span>
	<span class="n">drm_mode</span><span class="o">-&gt;</span><span class="n">vdisplay</span> <span class="o">=</span> <span class="n">vdisplay_rnd</span><span class="p">;</span>
	<span class="n">drm_mode</span><span class="o">-&gt;</span><span class="n">vsync_start</span> <span class="o">=</span> <span class="n">vdisplay_rnd</span> <span class="o">+</span> <span class="n">vodd_front_porch_lines</span><span class="p">;</span>
	<span class="n">drm_mode</span><span class="o">-&gt;</span><span class="n">vsync_end</span> <span class="o">=</span> <span class="n">drm_mode</span><span class="o">-&gt;</span><span class="n">vsync_start</span> <span class="o">+</span> <span class="n">V_SYNC_RQD</span><span class="p">;</span>
	<span class="n">drm_mode</span><span class="o">-&gt;</span><span class="n">vtotal</span> <span class="o">=</span> <span class="n">vtotal_lines</span><span class="p">;</span>

	<span class="n">drm_mode</span><span class="o">-&gt;</span><span class="n">clock</span> <span class="o">=</span> <span class="n">pixel_freq</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">interlaced</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">drm_mode</span><span class="o">-&gt;</span><span class="n">vtotal</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">drm_mode</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">DRM_MODE_FLAG_INTERLACE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">drm_mode_set_name</span><span class="p">(</span><span class="n">drm_mode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">GTF_M</span> <span class="o">==</span> <span class="mi">600</span> <span class="o">&amp;&amp;</span> <span class="n">GTF_2C</span> <span class="o">==</span> <span class="mi">80</span> <span class="o">&amp;&amp;</span> <span class="n">GTF_K</span> <span class="o">==</span> <span class="mi">128</span> <span class="o">&amp;&amp;</span> <span class="n">GTF_2J</span> <span class="o">==</span> <span class="mi">40</span><span class="p">)</span>
		<span class="n">drm_mode</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">DRM_MODE_FLAG_NHSYNC</span> <span class="o">|</span> <span class="n">DRM_MODE_FLAG_PVSYNC</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">drm_mode</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">DRM_MODE_FLAG_PHSYNC</span> <span class="o">|</span> <span class="n">DRM_MODE_FLAG_NVSYNC</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">drm_mode</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">drm_gtf_mode_complex</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * drm_gtf_mode - create the modeline based on GTF algorithm</span>
<span class="cm"> *</span>
<span class="cm"> * @dev		:drm device</span>
<span class="cm"> * @hdisplay	:hdisplay size</span>
<span class="cm"> * @vdisplay	:vdisplay size</span>
<span class="cm"> * @vrefresh	:vrefresh rate.</span>
<span class="cm"> * @interlaced	:whether the interlace is supported</span>
<span class="cm"> * @margins	:whether the margin is supported</span>
<span class="cm"> *</span>
<span class="cm"> * LOCKING.</span>
<span class="cm"> * none.</span>
<span class="cm"> *</span>
<span class="cm"> * return the modeline based on GTF algorithm</span>
<span class="cm"> *</span>
<span class="cm"> * This function is to create the modeline based on the GTF algorithm.</span>
<span class="cm"> * Generalized Timing Formula is derived from:</span>
<span class="cm"> *	GTF Spreadsheet by Andy Morrish (1/5/97)</span>
<span class="cm"> *	available at http://www.vesa.org</span>
<span class="cm"> *</span>
<span class="cm"> * And it is copied from the file of xserver/hw/xfree86/modes/xf86gtf.c.</span>
<span class="cm"> * What I have done is to translate it by using integer calculation.</span>
<span class="cm"> * I also refer to the function of fb_get_mode in the file of</span>
<span class="cm"> * drivers/video/fbmon.c</span>
<span class="cm"> *</span>
<span class="cm"> * Standard GTF parameters:</span>
<span class="cm"> * M = 600</span>
<span class="cm"> * C = 40</span>
<span class="cm"> * K = 128</span>
<span class="cm"> * J = 20</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span>
<span class="nf">drm_gtf_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">hdisplay</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vdisplay</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vrefresh</span><span class="p">,</span>
	     <span class="n">bool</span> <span class="n">lace</span><span class="p">,</span> <span class="kt">int</span> <span class="n">margins</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">drm_gtf_mode_complex</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">hdisplay</span><span class="p">,</span> <span class="n">vdisplay</span><span class="p">,</span> <span class="n">vrefresh</span><span class="p">,</span> <span class="n">lace</span><span class="p">,</span>
				    <span class="n">margins</span><span class="p">,</span> <span class="mi">600</span><span class="p">,</span> <span class="mi">40</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">20</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">drm_gtf_mode</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * drm_mode_set_name - set the name on a mode</span>
<span class="cm"> * @mode: name will be set in this mode</span>
<span class="cm"> *</span>
<span class="cm"> * LOCKING:</span>
<span class="cm"> * None.</span>
<span class="cm"> *</span>
<span class="cm"> * Set the name of @mode to a standard format.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">drm_mode_set_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">interlaced</span> <span class="o">=</span> <span class="o">!!</span><span class="p">(</span><span class="n">mode</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DRM_MODE_FLAG_INTERLACE</span><span class="p">);</span>

	<span class="n">snprintf</span><span class="p">(</span><span class="n">mode</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">DRM_DISPLAY_MODE_LEN</span><span class="p">,</span> <span class="s">&quot;%dx%d%s&quot;</span><span class="p">,</span>
		 <span class="n">mode</span><span class="o">-&gt;</span><span class="n">hdisplay</span><span class="p">,</span> <span class="n">mode</span><span class="o">-&gt;</span><span class="n">vdisplay</span><span class="p">,</span>
		 <span class="n">interlaced</span> <span class="o">?</span> <span class="s">&quot;i&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">drm_mode_set_name</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * drm_mode_list_concat - move modes from one list to another</span>
<span class="cm"> * @head: source list</span>
<span class="cm"> * @new: dst list</span>
<span class="cm"> *</span>
<span class="cm"> * LOCKING:</span>
<span class="cm"> * Caller must ensure both lists are locked.</span>
<span class="cm"> *</span>
<span class="cm"> * Move all the modes from @head to @new.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">drm_mode_list_concat</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">new</span><span class="p">)</span>
<span class="p">{</span>

	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="n">list_for_each_safe</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_move_tail</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">new</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">drm_mode_list_concat</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * drm_mode_width - get the width of a mode</span>
<span class="cm"> * @mode: mode</span>
<span class="cm"> *</span>
<span class="cm"> * LOCKING:</span>
<span class="cm"> * None.</span>
<span class="cm"> *</span>
<span class="cm"> * Return @mode&#39;s width (hdisplay) value.</span>
<span class="cm"> *</span>
<span class="cm"> * FIXME: is this needed?</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * @mode-&gt;hdisplay</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">drm_mode_width</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">mode</span><span class="o">-&gt;</span><span class="n">hdisplay</span><span class="p">;</span>

<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">drm_mode_width</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * drm_mode_height - get the height of a mode</span>
<span class="cm"> * @mode: mode</span>
<span class="cm"> *</span>
<span class="cm"> * LOCKING:</span>
<span class="cm"> * None.</span>
<span class="cm"> *</span>
<span class="cm"> * Return @mode&#39;s height (vdisplay) value.</span>
<span class="cm"> *</span>
<span class="cm"> * FIXME: is this needed?</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * @mode-&gt;vdisplay</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">drm_mode_height</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">mode</span><span class="o">-&gt;</span><span class="n">vdisplay</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">drm_mode_height</span><span class="p">);</span>

<span class="cm">/** drm_mode_hsync - get the hsync of a mode</span>
<span class="cm"> * @mode: mode</span>
<span class="cm"> *</span>
<span class="cm"> * LOCKING:</span>
<span class="cm"> * None.</span>
<span class="cm"> *</span>
<span class="cm"> * Return @modes&#39;s hsync rate in kHz, rounded to the nearest int.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">drm_mode_hsync</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">calc_val</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mode</span><span class="o">-&gt;</span><span class="n">hsync</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">mode</span><span class="o">-&gt;</span><span class="n">hsync</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mode</span><span class="o">-&gt;</span><span class="n">htotal</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">calc_val</span> <span class="o">=</span> <span class="p">(</span><span class="n">mode</span><span class="o">-&gt;</span><span class="n">clock</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">)</span> <span class="o">/</span> <span class="n">mode</span><span class="o">-&gt;</span><span class="n">htotal</span><span class="p">;</span> <span class="cm">/* hsync in Hz */</span>
	<span class="n">calc_val</span> <span class="o">+=</span> <span class="mi">500</span><span class="p">;</span>				<span class="cm">/* round to 1000Hz */</span>
	<span class="n">calc_val</span> <span class="o">/=</span> <span class="mi">1000</span><span class="p">;</span>				<span class="cm">/* truncate to kHz */</span>

	<span class="k">return</span> <span class="n">calc_val</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">drm_mode_hsync</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * drm_mode_vrefresh - get the vrefresh of a mode</span>
<span class="cm"> * @mode: mode</span>
<span class="cm"> *</span>
<span class="cm"> * LOCKING:</span>
<span class="cm"> * None.</span>
<span class="cm"> *</span>
<span class="cm"> * Return @mode&#39;s vrefresh rate in Hz or calculate it if necessary.</span>
<span class="cm"> *</span>
<span class="cm"> * FIXME: why is this needed?  shouldn&#39;t vrefresh be set already?</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * Vertical refresh rate. It will be the result of actual value plus 0.5.</span>
<span class="cm"> * If it is 70.288, it will return 70Hz.</span>
<span class="cm"> * If it is 59.6, it will return 60Hz.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">drm_mode_vrefresh</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">refresh</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">calc_val</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mode</span><span class="o">-&gt;</span><span class="n">vrefresh</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">refresh</span> <span class="o">=</span> <span class="n">mode</span><span class="o">-&gt;</span><span class="n">vrefresh</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">mode</span><span class="o">-&gt;</span><span class="n">htotal</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">mode</span><span class="o">-&gt;</span><span class="n">vtotal</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">vtotal</span><span class="p">;</span>
		<span class="n">vtotal</span> <span class="o">=</span> <span class="n">mode</span><span class="o">-&gt;</span><span class="n">vtotal</span><span class="p">;</span>
		<span class="cm">/* work out vrefresh the value will be x1000 */</span>
		<span class="n">calc_val</span> <span class="o">=</span> <span class="p">(</span><span class="n">mode</span><span class="o">-&gt;</span><span class="n">clock</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">);</span>
		<span class="n">calc_val</span> <span class="o">/=</span> <span class="n">mode</span><span class="o">-&gt;</span><span class="n">htotal</span><span class="p">;</span>
		<span class="n">refresh</span> <span class="o">=</span> <span class="p">(</span><span class="n">calc_val</span> <span class="o">+</span> <span class="n">vtotal</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">vtotal</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">mode</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DRM_MODE_FLAG_INTERLACE</span><span class="p">)</span>
			<span class="n">refresh</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mode</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DRM_MODE_FLAG_DBLSCAN</span><span class="p">)</span>
			<span class="n">refresh</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mode</span><span class="o">-&gt;</span><span class="n">vscan</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">refresh</span> <span class="o">/=</span> <span class="n">mode</span><span class="o">-&gt;</span><span class="n">vscan</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">refresh</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">drm_mode_vrefresh</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * drm_mode_set_crtcinfo - set CRTC modesetting parameters</span>
<span class="cm"> * @p: mode</span>
<span class="cm"> * @adjust_flags: unused? (FIXME)</span>
<span class="cm"> *</span>
<span class="cm"> * LOCKING:</span>
<span class="cm"> * None.</span>
<span class="cm"> *</span>
<span class="cm"> * Setup the CRTC modesetting parameters for @p, adjusting if necessary.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">drm_mode_set_crtcinfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">adjust_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">p</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">||</span> <span class="p">((</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">DRM_MODE_TYPE_CRTC_C</span><span class="p">)</span> <span class="o">==</span> <span class="n">DRM_MODE_TYPE_BUILTIN</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">p</span><span class="o">-&gt;</span><span class="n">crtc_hdisplay</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">hdisplay</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">crtc_hsync_start</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">hsync_start</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">crtc_hsync_end</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">hsync_end</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">crtc_htotal</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">htotal</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">crtc_hskew</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">hskew</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">crtc_vdisplay</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">vdisplay</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">crtc_vsync_start</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">vsync_start</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">crtc_vsync_end</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">vsync_end</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">crtc_vtotal</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">vtotal</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DRM_MODE_FLAG_INTERLACE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">adjust_flags</span> <span class="o">&amp;</span> <span class="n">CRTC_INTERLACE_HALVE_V</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">p</span><span class="o">-&gt;</span><span class="n">crtc_vdisplay</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">;</span>
			<span class="n">p</span><span class="o">-&gt;</span><span class="n">crtc_vsync_start</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">;</span>
			<span class="n">p</span><span class="o">-&gt;</span><span class="n">crtc_vsync_end</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">;</span>
			<span class="n">p</span><span class="o">-&gt;</span><span class="n">crtc_vtotal</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DRM_MODE_FLAG_DBLSCAN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">crtc_vdisplay</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">crtc_vsync_start</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">crtc_vsync_end</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">crtc_vtotal</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">vscan</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">crtc_vdisplay</span> <span class="o">*=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">vscan</span><span class="p">;</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">crtc_vsync_start</span> <span class="o">*=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">vscan</span><span class="p">;</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">crtc_vsync_end</span> <span class="o">*=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">vscan</span><span class="p">;</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">crtc_vtotal</span> <span class="o">*=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">vscan</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">p</span><span class="o">-&gt;</span><span class="n">crtc_vblank_start</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">crtc_vsync_start</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">crtc_vdisplay</span><span class="p">);</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">crtc_vblank_end</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">crtc_vsync_end</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">crtc_vtotal</span><span class="p">);</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">crtc_hblank_start</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">crtc_hsync_start</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">crtc_hdisplay</span><span class="p">);</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">crtc_hblank_end</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">crtc_hsync_end</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">crtc_htotal</span><span class="p">);</span>

	<span class="n">p</span><span class="o">-&gt;</span><span class="n">crtc_hadjusted</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">crtc_vadjusted</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">drm_mode_set_crtcinfo</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> * drm_mode_copy - copy the mode</span>
<span class="cm"> * @dst: mode to overwrite</span>
<span class="cm"> * @src: mode to copy</span>
<span class="cm"> *</span>
<span class="cm"> * LOCKING:</span>
<span class="cm"> * None.</span>
<span class="cm"> *</span>
<span class="cm"> * Copy an existing mode into another mode, preserving the object id</span>
<span class="cm"> * of the destination mode.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">drm_mode_copy</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="n">src</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="n">dst</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">id</span><span class="p">;</span>

	<span class="o">*</span><span class="n">dst</span> <span class="o">=</span> <span class="o">*</span><span class="n">src</span><span class="p">;</span>
	<span class="n">dst</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dst</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">drm_mode_copy</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * drm_mode_duplicate - allocate and duplicate an existing mode</span>
<span class="cm"> * @m: mode to duplicate</span>
<span class="cm"> *</span>
<span class="cm"> * LOCKING:</span>
<span class="cm"> * None.</span>
<span class="cm"> *</span>
<span class="cm"> * Just allocate a new mode, copy the existing mode into it, and return</span>
<span class="cm"> * a pointer to it.  Used to create new instances of established modes.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="nf">drm_mode_duplicate</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					    <span class="k">const</span> <span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="n">nmode</span><span class="p">;</span>

	<span class="n">nmode</span> <span class="o">=</span> <span class="n">drm_mode_create</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nmode</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">drm_mode_copy</span><span class="p">(</span><span class="n">nmode</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">nmode</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">drm_mode_duplicate</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * drm_mode_equal - test modes for equality</span>
<span class="cm"> * @mode1: first mode</span>
<span class="cm"> * @mode2: second mode</span>
<span class="cm"> *</span>
<span class="cm"> * LOCKING:</span>
<span class="cm"> * None.</span>
<span class="cm"> *</span>
<span class="cm"> * Check to see if @mode1 and @mode2 are equivalent.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * True if the modes are equal, false otherwise.</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="nf">drm_mode_equal</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="n">mode1</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="n">mode2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* do clock check convert to PICOS so fb modes get matched</span>
<span class="cm">	 * the same */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mode1</span><span class="o">-&gt;</span><span class="n">clock</span> <span class="o">&amp;&amp;</span> <span class="n">mode2</span><span class="o">-&gt;</span><span class="n">clock</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">KHZ2PICOS</span><span class="p">(</span><span class="n">mode1</span><span class="o">-&gt;</span><span class="n">clock</span><span class="p">)</span> <span class="o">!=</span> <span class="n">KHZ2PICOS</span><span class="p">(</span><span class="n">mode2</span><span class="o">-&gt;</span><span class="n">clock</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">mode1</span><span class="o">-&gt;</span><span class="n">clock</span> <span class="o">!=</span> <span class="n">mode2</span><span class="o">-&gt;</span><span class="n">clock</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mode1</span><span class="o">-&gt;</span><span class="n">hdisplay</span> <span class="o">==</span> <span class="n">mode2</span><span class="o">-&gt;</span><span class="n">hdisplay</span> <span class="o">&amp;&amp;</span>
	    <span class="n">mode1</span><span class="o">-&gt;</span><span class="n">hsync_start</span> <span class="o">==</span> <span class="n">mode2</span><span class="o">-&gt;</span><span class="n">hsync_start</span> <span class="o">&amp;&amp;</span>
	    <span class="n">mode1</span><span class="o">-&gt;</span><span class="n">hsync_end</span> <span class="o">==</span> <span class="n">mode2</span><span class="o">-&gt;</span><span class="n">hsync_end</span> <span class="o">&amp;&amp;</span>
	    <span class="n">mode1</span><span class="o">-&gt;</span><span class="n">htotal</span> <span class="o">==</span> <span class="n">mode2</span><span class="o">-&gt;</span><span class="n">htotal</span> <span class="o">&amp;&amp;</span>
	    <span class="n">mode1</span><span class="o">-&gt;</span><span class="n">hskew</span> <span class="o">==</span> <span class="n">mode2</span><span class="o">-&gt;</span><span class="n">hskew</span> <span class="o">&amp;&amp;</span>
	    <span class="n">mode1</span><span class="o">-&gt;</span><span class="n">vdisplay</span> <span class="o">==</span> <span class="n">mode2</span><span class="o">-&gt;</span><span class="n">vdisplay</span> <span class="o">&amp;&amp;</span>
	    <span class="n">mode1</span><span class="o">-&gt;</span><span class="n">vsync_start</span> <span class="o">==</span> <span class="n">mode2</span><span class="o">-&gt;</span><span class="n">vsync_start</span> <span class="o">&amp;&amp;</span>
	    <span class="n">mode1</span><span class="o">-&gt;</span><span class="n">vsync_end</span> <span class="o">==</span> <span class="n">mode2</span><span class="o">-&gt;</span><span class="n">vsync_end</span> <span class="o">&amp;&amp;</span>
	    <span class="n">mode1</span><span class="o">-&gt;</span><span class="n">vtotal</span> <span class="o">==</span> <span class="n">mode2</span><span class="o">-&gt;</span><span class="n">vtotal</span> <span class="o">&amp;&amp;</span>
	    <span class="n">mode1</span><span class="o">-&gt;</span><span class="n">vscan</span> <span class="o">==</span> <span class="n">mode2</span><span class="o">-&gt;</span><span class="n">vscan</span> <span class="o">&amp;&amp;</span>
	    <span class="n">mode1</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">==</span> <span class="n">mode2</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">drm_mode_equal</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * drm_mode_validate_size - make sure modes adhere to size constraints</span>
<span class="cm"> * @dev: DRM device</span>
<span class="cm"> * @mode_list: list of modes to check</span>
<span class="cm"> * @maxX: maximum width</span>
<span class="cm"> * @maxY: maximum height</span>
<span class="cm"> * @maxPitch: max pitch</span>
<span class="cm"> *</span>
<span class="cm"> * LOCKING:</span>
<span class="cm"> * Caller must hold a lock protecting @mode_list.</span>
<span class="cm"> *</span>
<span class="cm"> * The DRM device (@dev) has size and pitch limits.  Here we validate the</span>
<span class="cm"> * modes we probed for @dev against those limits and set their status as</span>
<span class="cm"> * necessary.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">drm_mode_validate_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">mode_list</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">maxX</span><span class="p">,</span> <span class="kt">int</span> <span class="n">maxY</span><span class="p">,</span> <span class="kt">int</span> <span class="n">maxPitch</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="n">mode</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">mode_list</span><span class="p">,</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">maxPitch</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">mode</span><span class="o">-&gt;</span><span class="n">hdisplay</span> <span class="o">&gt;</span> <span class="n">maxPitch</span><span class="p">)</span>
			<span class="n">mode</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">MODE_BAD_WIDTH</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">maxX</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">mode</span><span class="o">-&gt;</span><span class="n">hdisplay</span> <span class="o">&gt;</span> <span class="n">maxX</span><span class="p">)</span>
			<span class="n">mode</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">MODE_VIRTUAL_X</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">maxY</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">mode</span><span class="o">-&gt;</span><span class="n">vdisplay</span> <span class="o">&gt;</span> <span class="n">maxY</span><span class="p">)</span>
			<span class="n">mode</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">MODE_VIRTUAL_Y</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">drm_mode_validate_size</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * drm_mode_validate_clocks - validate modes against clock limits</span>
<span class="cm"> * @dev: DRM device</span>
<span class="cm"> * @mode_list: list of modes to check</span>
<span class="cm"> * @min: minimum clock rate array</span>
<span class="cm"> * @max: maximum clock rate array</span>
<span class="cm"> * @n_ranges: number of clock ranges (size of arrays)</span>
<span class="cm"> *</span>
<span class="cm"> * LOCKING:</span>
<span class="cm"> * Caller must hold a lock protecting @mode_list.</span>
<span class="cm"> *</span>
<span class="cm"> * Some code may need to check a mode list against the clock limits of the</span>
<span class="cm"> * device in question.  This function walks the mode list, testing to make</span>
<span class="cm"> * sure each mode falls within a given range (defined by @min and @max</span>
<span class="cm"> * arrays) and sets @mode-&gt;status as needed.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">drm_mode_validate_clocks</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">mode_list</span><span class="p">,</span>
			      <span class="kt">int</span> <span class="o">*</span><span class="n">min</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">max</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n_ranges</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="n">mode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">mode_list</span><span class="p">,</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bool</span> <span class="n">good</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n_ranges</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mode</span><span class="o">-&gt;</span><span class="n">clock</span> <span class="o">&gt;=</span> <span class="n">min</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">mode</span><span class="o">-&gt;</span><span class="n">clock</span> <span class="o">&lt;=</span> <span class="n">max</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
				<span class="n">good</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">good</span><span class="p">)</span>
			<span class="n">mode</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">MODE_CLOCK_RANGE</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">drm_mode_validate_clocks</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * drm_mode_prune_invalid - remove invalid modes from mode list</span>
<span class="cm"> * @dev: DRM device</span>
<span class="cm"> * @mode_list: list of modes to check</span>
<span class="cm"> * @verbose: be verbose about it</span>
<span class="cm"> *</span>
<span class="cm"> * LOCKING:</span>
<span class="cm"> * Caller must hold a lock protecting @mode_list.</span>
<span class="cm"> *</span>
<span class="cm"> * Once mode list generation is complete, a caller can use this routine to</span>
<span class="cm"> * remove invalid modes from a mode list.  If any of the modes have a</span>
<span class="cm"> * status other than %MODE_OK, they are removed from @mode_list and freed.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">drm_mode_prune_invalid</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">mode_list</span><span class="p">,</span> <span class="n">bool</span> <span class="n">verbose</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="n">mode</span><span class="p">,</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">mode_list</span><span class="p">,</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mode</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">!=</span> <span class="n">MODE_OK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mode</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">verbose</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">drm_mode_debug_printmodeline</span><span class="p">(</span><span class="n">mode</span><span class="p">);</span>
				<span class="n">DRM_DEBUG_KMS</span><span class="p">(</span><span class="s">&quot;Not using %s mode %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">mode</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">mode</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">drm_mode_destroy</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">drm_mode_prune_invalid</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * drm_mode_compare - compare modes for favorability</span>
<span class="cm"> * @priv: unused</span>
<span class="cm"> * @lh_a: list_head for first mode</span>
<span class="cm"> * @lh_b: list_head for second mode</span>
<span class="cm"> *</span>
<span class="cm"> * LOCKING:</span>
<span class="cm"> * None.</span>
<span class="cm"> *</span>
<span class="cm"> * Compare two modes, given by @lh_a and @lh_b, returning a value indicating</span>
<span class="cm"> * which is better.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * Negative if @lh_a is better than @lh_b, zero if they&#39;re equivalent, or</span>
<span class="cm"> * positive if @lh_b is better than @lh_a.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">drm_mode_compare</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">lh_a</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">lh_b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">lh_a</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_display_mode</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">lh_b</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_display_mode</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">diff</span><span class="p">;</span>

	<span class="n">diff</span> <span class="o">=</span> <span class="p">((</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">DRM_MODE_TYPE_PREFERRED</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-</span>
		<span class="p">((</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">DRM_MODE_TYPE_PREFERRED</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">diff</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">diff</span><span class="p">;</span>
	<span class="n">diff</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">hdisplay</span> <span class="o">*</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">vdisplay</span> <span class="o">-</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">hdisplay</span> <span class="o">*</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">vdisplay</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">diff</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">diff</span><span class="p">;</span>
	<span class="n">diff</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">clock</span> <span class="o">-</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">clock</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">diff</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * drm_mode_sort - sort mode list</span>
<span class="cm"> * @mode_list: list to sort</span>
<span class="cm"> *</span>
<span class="cm"> * LOCKING:</span>
<span class="cm"> * Caller must hold a lock protecting @mode_list.</span>
<span class="cm"> *</span>
<span class="cm"> * Sort @mode_list by favorability, putting good modes first.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">drm_mode_sort</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">mode_list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">list_sort</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">mode_list</span><span class="p">,</span> <span class="n">drm_mode_compare</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">drm_mode_sort</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * drm_mode_connector_list_update - update the mode list for the connector</span>
<span class="cm"> * @connector: the connector to update</span>
<span class="cm"> *</span>
<span class="cm"> * LOCKING:</span>
<span class="cm"> * Caller must hold a lock protecting @mode_list.</span>
<span class="cm"> *</span>
<span class="cm"> * This moves the modes from the @connector probed_modes list</span>
<span class="cm"> * to the actual mode list. It compares the probed mode against the current</span>
<span class="cm"> * list and only adds different modes. All modes unverified after this point</span>
<span class="cm"> * will be removed by the prune invalid modes.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">drm_mode_connector_list_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_connector</span> <span class="o">*</span><span class="n">connector</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="n">mode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="n">pmode</span><span class="p">,</span> <span class="o">*</span><span class="n">pt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">found_it</span><span class="p">;</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">pmode</span><span class="p">,</span> <span class="n">pt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">connector</span><span class="o">-&gt;</span><span class="n">probed_modes</span><span class="p">,</span>
				 <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">found_it</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="cm">/* go through current modes checking for the new probed mode */</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">connector</span><span class="o">-&gt;</span><span class="n">modes</span><span class="p">,</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">drm_mode_equal</span><span class="p">(</span><span class="n">pmode</span><span class="p">,</span> <span class="n">mode</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">found_it</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="cm">/* if equal delete the probed mode */</span>
				<span class="n">mode</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">pmode</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">;</span>
				<span class="cm">/* Merge type bits together */</span>
				<span class="n">mode</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">|=</span> <span class="n">pmode</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
				<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pmode</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">);</span>
				<span class="n">drm_mode_destroy</span><span class="p">(</span><span class="n">connector</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">pmode</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">found_it</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pmode</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">connector</span><span class="o">-&gt;</span><span class="n">modes</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">drm_mode_connector_list_update</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * drm_mode_parse_command_line_for_connector - parse command line for connector</span>
<span class="cm"> * @mode_option - per connector mode option</span>
<span class="cm"> * @connector - connector to parse line for</span>
<span class="cm"> *</span>
<span class="cm"> * This parses the connector specific then generic command lines for</span>
<span class="cm"> * modes and options to configure the connector.</span>
<span class="cm"> *</span>
<span class="cm"> * This uses the same parameters as the fb modedb.c, except for extra</span>
<span class="cm"> *	&lt;xres&gt;x&lt;yres&gt;[M][R][-&lt;bpp&gt;][@&lt;refresh&gt;][i][m][eDd]</span>
<span class="cm"> *</span>
<span class="cm"> * enable/enable Digital/disable bit at the end</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="nf">drm_mode_parse_command_line_for_connector</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">mode_option</span><span class="p">,</span>
					       <span class="k">struct</span> <span class="n">drm_connector</span> <span class="o">*</span><span class="n">connector</span><span class="p">,</span>
					       <span class="k">struct</span> <span class="n">drm_cmdline_mode</span> <span class="o">*</span><span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">namelen</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">res_specified</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span> <span class="n">bpp_specified</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span> <span class="n">refresh_specified</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">xres</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">yres</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bpp</span> <span class="o">=</span> <span class="mi">32</span><span class="p">,</span> <span class="n">refresh</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">yres_specified</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span> <span class="n">cvt</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span> <span class="n">rb</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">interlace</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span> <span class="n">margins</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span> <span class="n">was_digit</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">drm_connector_force</span> <span class="n">force</span> <span class="o">=</span> <span class="n">DRM_FORCE_UNSPECIFIED</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_FB</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mode_option</span><span class="p">)</span>
		<span class="n">mode_option</span> <span class="o">=</span> <span class="n">fb_mode_option</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mode_option</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mode</span><span class="o">-&gt;</span><span class="n">specified</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">name</span> <span class="o">=</span> <span class="n">mode_option</span><span class="p">;</span>
	<span class="n">namelen</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">namelen</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">name</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
		<span class="k">case</span> <span class="sc">&#39;@&#39;</span>:
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">refresh_specified</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">bpp_specified</span> <span class="o">&amp;&amp;</span>
			    <span class="o">!</span><span class="n">yres_specified</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cvt</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">rb</span> <span class="o">&amp;&amp;</span> <span class="n">was_digit</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">refresh</span> <span class="o">=</span> <span class="n">simple_strtol</span><span class="p">(</span><span class="o">&amp;</span><span class="n">name</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
				<span class="n">refresh_specified</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
				<span class="n">was_digit</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">&#39;-&#39;</span>:
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bpp_specified</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">yres_specified</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cvt</span> <span class="o">&amp;&amp;</span>
			    <span class="o">!</span><span class="n">rb</span> <span class="o">&amp;&amp;</span> <span class="n">was_digit</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">bpp</span> <span class="o">=</span> <span class="n">simple_strtol</span><span class="p">(</span><span class="o">&amp;</span><span class="n">name</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
				<span class="n">bpp_specified</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
				<span class="n">was_digit</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">&#39;x&#39;</span>:
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">yres_specified</span> <span class="o">&amp;&amp;</span> <span class="n">was_digit</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">yres</span> <span class="o">=</span> <span class="n">simple_strtol</span><span class="p">(</span><span class="o">&amp;</span><span class="n">name</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
				<span class="n">yres_specified</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
				<span class="n">was_digit</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">&#39;0&#39;</span> <span class="p">...</span> <span class="sc">&#39;9&#39;</span>:
			<span class="n">was_digit</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">&#39;M&#39;</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">yres_specified</span> <span class="o">||</span> <span class="n">cvt</span> <span class="o">||</span> <span class="n">was_digit</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
			<span class="n">cvt</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">&#39;R&#39;</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">yres_specified</span> <span class="o">||</span> <span class="n">cvt</span> <span class="o">||</span> <span class="n">rb</span> <span class="o">||</span> <span class="n">was_digit</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
			<span class="n">rb</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">&#39;m&#39;</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">cvt</span> <span class="o">||</span> <span class="n">yres_specified</span> <span class="o">||</span> <span class="n">was_digit</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
			<span class="n">margins</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">&#39;i&#39;</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">cvt</span> <span class="o">||</span> <span class="n">yres_specified</span> <span class="o">||</span> <span class="n">was_digit</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
			<span class="n">interlace</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">&#39;e&#39;</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">yres_specified</span> <span class="o">||</span> <span class="n">bpp_specified</span> <span class="o">||</span> <span class="n">refresh_specified</span> <span class="o">||</span>
			    <span class="n">was_digit</span> <span class="o">||</span> <span class="p">(</span><span class="n">force</span> <span class="o">!=</span> <span class="n">DRM_FORCE_UNSPECIFIED</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

			<span class="n">force</span> <span class="o">=</span> <span class="n">DRM_FORCE_ON</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">&#39;D&#39;</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">yres_specified</span> <span class="o">||</span> <span class="n">bpp_specified</span> <span class="o">||</span> <span class="n">refresh_specified</span> <span class="o">||</span>
			    <span class="n">was_digit</span> <span class="o">||</span> <span class="p">(</span><span class="n">force</span> <span class="o">!=</span> <span class="n">DRM_FORCE_UNSPECIFIED</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">((</span><span class="n">connector</span><span class="o">-&gt;</span><span class="n">connector_type</span> <span class="o">!=</span> <span class="n">DRM_MODE_CONNECTOR_DVII</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="n">connector</span><span class="o">-&gt;</span><span class="n">connector_type</span> <span class="o">!=</span> <span class="n">DRM_MODE_CONNECTOR_HDMIB</span><span class="p">))</span>
				<span class="n">force</span> <span class="o">=</span> <span class="n">DRM_FORCE_ON</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">force</span> <span class="o">=</span> <span class="n">DRM_FORCE_ON_DIGITAL</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">&#39;d&#39;</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">yres_specified</span> <span class="o">||</span> <span class="n">bpp_specified</span> <span class="o">||</span> <span class="n">refresh_specified</span> <span class="o">||</span>
			    <span class="n">was_digit</span> <span class="o">||</span> <span class="p">(</span><span class="n">force</span> <span class="o">!=</span> <span class="n">DRM_FORCE_UNSPECIFIED</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

			<span class="n">force</span> <span class="o">=</span> <span class="n">DRM_FORCE_OFF</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">yres_specified</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">ch</span><span class="p">;</span>
		<span class="n">xres</span> <span class="o">=</span> <span class="n">simple_strtol</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ch</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">*</span><span class="n">ch</span> <span class="o">==</span> <span class="sc">&#39;x&#39;</span><span class="p">))</span>
			<span class="n">res_specified</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">i</span> <span class="o">=</span> <span class="n">ch</span> <span class="o">-</span> <span class="n">name</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">yres_specified</span> <span class="o">&amp;&amp;</span> <span class="n">was_digit</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* catch mode that begins with digits but has no &#39;x&#39; */</span>
		<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">done:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
			<span class="s">&quot;parse error at position %i in video mode &#39;%s&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">i</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
		<span class="n">mode</span><span class="o">-&gt;</span><span class="n">specified</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">res_specified</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mode</span><span class="o">-&gt;</span><span class="n">specified</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">mode</span><span class="o">-&gt;</span><span class="n">xres</span> <span class="o">=</span> <span class="n">xres</span><span class="p">;</span>
		<span class="n">mode</span><span class="o">-&gt;</span><span class="n">yres</span> <span class="o">=</span> <span class="n">yres</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">refresh_specified</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mode</span><span class="o">-&gt;</span><span class="n">refresh_specified</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">mode</span><span class="o">-&gt;</span><span class="n">refresh</span> <span class="o">=</span> <span class="n">refresh</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bpp_specified</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mode</span><span class="o">-&gt;</span><span class="n">bpp_specified</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">mode</span><span class="o">-&gt;</span><span class="n">bpp</span> <span class="o">=</span> <span class="n">bpp</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mode</span><span class="o">-&gt;</span><span class="n">rb</span> <span class="o">=</span> <span class="n">rb</span><span class="p">;</span>
	<span class="n">mode</span><span class="o">-&gt;</span><span class="n">cvt</span> <span class="o">=</span> <span class="n">cvt</span><span class="p">;</span>
	<span class="n">mode</span><span class="o">-&gt;</span><span class="n">interlace</span> <span class="o">=</span> <span class="n">interlace</span><span class="p">;</span>
	<span class="n">mode</span><span class="o">-&gt;</span><span class="n">margins</span> <span class="o">=</span> <span class="n">margins</span><span class="p">;</span>
	<span class="n">mode</span><span class="o">-&gt;</span><span class="n">force</span> <span class="o">=</span> <span class="n">force</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">drm_mode_parse_command_line_for_connector</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span>
<span class="nf">drm_mode_create_from_cmdline_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">drm_cmdline_mode</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="n">mode</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cvt</span><span class="p">)</span>
		<span class="n">mode</span> <span class="o">=</span> <span class="n">drm_cvt_mode</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
				    <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">xres</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">yres</span><span class="p">,</span>
				    <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">refresh_specified</span> <span class="o">?</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">refresh</span> <span class="o">:</span> <span class="mi">60</span><span class="p">,</span>
				    <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">interlace</span><span class="p">,</span>
				    <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">margins</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">mode</span> <span class="o">=</span> <span class="n">drm_gtf_mode</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
				    <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">xres</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">yres</span><span class="p">,</span>
				    <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">refresh_specified</span> <span class="o">?</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">refresh</span> <span class="o">:</span> <span class="mi">60</span><span class="p">,</span>
				    <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">interlace</span><span class="p">,</span>
				    <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">margins</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mode</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">drm_mode_set_crtcinfo</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">CRTC_INTERLACE_HALVE_V</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">mode</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">drm_mode_create_from_cmdline_mode</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
