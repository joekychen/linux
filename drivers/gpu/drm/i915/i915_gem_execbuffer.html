<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › gpu › drm › i915 › i915_gem_execbuffer.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>i915_gem_execbuffer.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright © 2008,2010 Intel Corporation</span>
<span class="cm"> *</span>
<span class="cm"> * Permission is hereby granted, free of charge, to any person obtaining a</span>
<span class="cm"> * copy of this software and associated documentation files (the &quot;Software&quot;),</span>
<span class="cm"> * to deal in the Software without restriction, including without limitation</span>
<span class="cm"> * the rights to use, copy, modify, merge, publish, distribute, sublicense,</span>
<span class="cm"> * and/or sell copies of the Software, and to permit persons to whom the</span>
<span class="cm"> * Software is furnished to do so, subject to the following conditions:</span>
<span class="cm"> *</span>
<span class="cm"> * The above copyright notice and this permission notice (including the next</span>
<span class="cm"> * paragraph) shall be included in all copies or substantial portions of the</span>
<span class="cm"> * Software.</span>
<span class="cm"> *</span>
<span class="cm"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span>
<span class="cm"> * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL</span>
<span class="cm"> * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span>
<span class="cm"> * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING</span>
<span class="cm"> * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS</span>
<span class="cm"> * IN THE SOFTWARE.</span>
<span class="cm"> *</span>
<span class="cm"> * Authors:</span>
<span class="cm"> *    Eric Anholt &lt;eric@anholt.net&gt;</span>
<span class="cm"> *    Chris Wilson &lt;chris@chris-wilson.co.uk&gt;</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &quot;drmP.h&quot;</span>
<span class="cp">#include &quot;drm.h&quot;</span>
<span class="cp">#include &quot;i915_drm.h&quot;</span>
<span class="cp">#include &quot;i915_drv.h&quot;</span>
<span class="cp">#include &quot;i915_trace.h&quot;</span>
<span class="cp">#include &quot;intel_drv.h&quot;</span>
<span class="cp">#include &lt;linux/dma_remapping.h&gt;</span>

<span class="k">struct</span> <span class="n">change_domains</span> <span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">invalidate_domains</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">flush_domains</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">flush_rings</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">flips</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Set the next domain for the specified object. This</span>
<span class="cm"> * may not actually perform the necessary flushing/invaliding though,</span>
<span class="cm"> * as that may want to be batched with other set_domain operations</span>
<span class="cm"> *</span>
<span class="cm"> * This is (we hope) the only really tricky part of gem. The goal</span>
<span class="cm"> * is fairly simple -- track which caches hold bits of the object</span>
<span class="cm"> * and make sure they remain coherent. A few concrete examples may</span>
<span class="cm"> * help to explain how it works. For shorthand, we use the notation</span>
<span class="cm"> * (read_domains, write_domain), e.g. (CPU, CPU) to indicate the</span>
<span class="cm"> * a pair of read and write domain masks.</span>
<span class="cm"> *</span>
<span class="cm"> * Case 1: the batch buffer</span>
<span class="cm"> *</span>
<span class="cm"> *	1. Allocated</span>
<span class="cm"> *	2. Written by CPU</span>
<span class="cm"> *	3. Mapped to GTT</span>
<span class="cm"> *	4. Read by GPU</span>
<span class="cm"> *	5. Unmapped from GTT</span>
<span class="cm"> *	6. Freed</span>
<span class="cm"> *</span>
<span class="cm"> *	Let&#39;s take these a step at a time</span>
<span class="cm"> *</span>
<span class="cm"> *	1. Allocated</span>
<span class="cm"> *		Pages allocated from the kernel may still have</span>
<span class="cm"> *		cache contents, so we set them to (CPU, CPU) always.</span>
<span class="cm"> *	2. Written by CPU (using pwrite)</span>
<span class="cm"> *		The pwrite function calls set_domain (CPU, CPU) and</span>
<span class="cm"> *		this function does nothing (as nothing changes)</span>
<span class="cm"> *	3. Mapped by GTT</span>
<span class="cm"> *		This function asserts that the object is not</span>
<span class="cm"> *		currently in any GPU-based read or write domains</span>
<span class="cm"> *	4. Read by GPU</span>
<span class="cm"> *		i915_gem_execbuffer calls set_domain (COMMAND, 0).</span>
<span class="cm"> *		As write_domain is zero, this function adds in the</span>
<span class="cm"> *		current read domains (CPU+COMMAND, 0).</span>
<span class="cm"> *		flush_domains is set to CPU.</span>
<span class="cm"> *		invalidate_domains is set to COMMAND</span>
<span class="cm"> *		clflush is run to get data out of the CPU caches</span>
<span class="cm"> *		then i915_dev_set_domain calls i915_gem_flush to</span>
<span class="cm"> *		emit an MI_FLUSH and drm_agp_chipset_flush</span>
<span class="cm"> *	5. Unmapped from GTT</span>
<span class="cm"> *		i915_gem_object_unbind calls set_domain (CPU, CPU)</span>
<span class="cm"> *		flush_domains and invalidate_domains end up both zero</span>
<span class="cm"> *		so no flushing/invalidating happens</span>
<span class="cm"> *	6. Freed</span>
<span class="cm"> *		yay, done</span>
<span class="cm"> *</span>
<span class="cm"> * Case 2: The shared render buffer</span>
<span class="cm"> *</span>
<span class="cm"> *	1. Allocated</span>
<span class="cm"> *	2. Mapped to GTT</span>
<span class="cm"> *	3. Read/written by GPU</span>
<span class="cm"> *	4. set_domain to (CPU,CPU)</span>
<span class="cm"> *	5. Read/written by CPU</span>
<span class="cm"> *	6. Read/written by GPU</span>
<span class="cm"> *</span>
<span class="cm"> *	1. Allocated</span>
<span class="cm"> *		Same as last example, (CPU, CPU)</span>
<span class="cm"> *	2. Mapped to GTT</span>
<span class="cm"> *		Nothing changes (assertions find that it is not in the GPU)</span>
<span class="cm"> *	3. Read/written by GPU</span>
<span class="cm"> *		execbuffer calls set_domain (RENDER, RENDER)</span>
<span class="cm"> *		flush_domains gets CPU</span>
<span class="cm"> *		invalidate_domains gets GPU</span>
<span class="cm"> *		clflush (obj)</span>
<span class="cm"> *		MI_FLUSH and drm_agp_chipset_flush</span>
<span class="cm"> *	4. set_domain (CPU, CPU)</span>
<span class="cm"> *		flush_domains gets GPU</span>
<span class="cm"> *		invalidate_domains gets CPU</span>
<span class="cm"> *		wait_rendering (obj) to make sure all drawing is complete.</span>
<span class="cm"> *		This will include an MI_FLUSH to get the data from GPU</span>
<span class="cm"> *		to memory</span>
<span class="cm"> *		clflush (obj) to invalidate the CPU cache</span>
<span class="cm"> *		Another MI_FLUSH in i915_gem_flush (eliminate this somehow?)</span>
<span class="cm"> *	5. Read/written by CPU</span>
<span class="cm"> *		cache lines are loaded and dirtied</span>
<span class="cm"> *	6. Read written by GPU</span>
<span class="cm"> *		Same as last GPU access</span>
<span class="cm"> *</span>
<span class="cm"> * Case 3: The constant buffer</span>
<span class="cm"> *</span>
<span class="cm"> *	1. Allocated</span>
<span class="cm"> *	2. Written by CPU</span>
<span class="cm"> *	3. Read by GPU</span>
<span class="cm"> *	4. Updated (written) by CPU again</span>
<span class="cm"> *	5. Read by GPU</span>
<span class="cm"> *</span>
<span class="cm"> *	1. Allocated</span>
<span class="cm"> *		(CPU, CPU)</span>
<span class="cm"> *	2. Written by CPU</span>
<span class="cm"> *		(CPU, CPU)</span>
<span class="cm"> *	3. Read by GPU</span>
<span class="cm"> *		(CPU+RENDER, 0)</span>
<span class="cm"> *		flush_domains = CPU</span>
<span class="cm"> *		invalidate_domains = RENDER</span>
<span class="cm"> *		clflush (obj)</span>
<span class="cm"> *		MI_FLUSH</span>
<span class="cm"> *		drm_agp_chipset_flush</span>
<span class="cm"> *	4. Updated (written) by CPU again</span>
<span class="cm"> *		(CPU, CPU)</span>
<span class="cm"> *		flush_domains = 0 (no previous write domain)</span>
<span class="cm"> *		invalidate_domains = 0 (no new read domains)</span>
<span class="cm"> *	5. Read by GPU</span>
<span class="cm"> *		(CPU+RENDER, 0)</span>
<span class="cm"> *		flush_domains = CPU</span>
<span class="cm"> *		invalidate_domains = RENDER</span>
<span class="cm"> *		clflush (obj)</span>
<span class="cm"> *		MI_FLUSH</span>
<span class="cm"> *		drm_agp_chipset_flush</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">i915_gem_object_set_to_gpu_domain</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_i915_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">intel_ring_buffer</span> <span class="o">*</span><span class="n">ring</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">change_domains</span> <span class="o">*</span><span class="n">cd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">invalidate_domains</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">flush_domains</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the object isn&#39;t moving to a new write domain,</span>
<span class="cm">	 * let the object stay in multiple read domains</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">pending_write_domain</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">obj</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">pending_read_domains</span> <span class="o">|=</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">read_domains</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Flush the current write domain if</span>
<span class="cm">	 * the new read domains don&#39;t match. Invalidate</span>
<span class="cm">	 * any read domains which differ from the old</span>
<span class="cm">	 * write domain</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">write_domain</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(((</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">write_domain</span> <span class="o">!=</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">pending_read_domains</span> <span class="o">||</span>
	       <span class="n">obj</span><span class="o">-&gt;</span><span class="n">ring</span> <span class="o">!=</span> <span class="n">ring</span><span class="p">))</span> <span class="o">||</span>
	     <span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">fenced_gpu_access</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">pending_fenced_gpu_access</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">flush_domains</span> <span class="o">|=</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">write_domain</span><span class="p">;</span>
		<span class="n">invalidate_domains</span> <span class="o">|=</span>
			<span class="n">obj</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">pending_read_domains</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">write_domain</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Invalidate any read caches which may have</span>
<span class="cm">	 * stale data. That is, any new read domains.</span>
<span class="cm">	 */</span>
	<span class="n">invalidate_domains</span> <span class="o">|=</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">pending_read_domains</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">read_domains</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">flush_domains</span> <span class="o">|</span> <span class="n">invalidate_domains</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">I915_GEM_DOMAIN_CPU</span><span class="p">)</span>
		<span class="n">i915_gem_clflush_object</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">pending_write_domain</span><span class="p">)</span>
		<span class="n">cd</span><span class="o">-&gt;</span><span class="n">flips</span> <span class="o">|=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">pending_flip</span><span class="p">);</span>

	<span class="cm">/* The actual obj-&gt;write_domain will be updated with</span>
<span class="cm">	 * pending_write_domain after we emit the accumulated flush for all</span>
<span class="cm">	 * of our domain changes in execbuffers (which clears objects&#39;</span>
<span class="cm">	 * write_domains).  So if we have a current write domain that we</span>
<span class="cm">	 * aren&#39;t changing, set pending_write_domain to that.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flush_domains</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">pending_write_domain</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">obj</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">pending_write_domain</span> <span class="o">=</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">write_domain</span><span class="p">;</span>

	<span class="n">cd</span><span class="o">-&gt;</span><span class="n">invalidate_domains</span> <span class="o">|=</span> <span class="n">invalidate_domains</span><span class="p">;</span>
	<span class="n">cd</span><span class="o">-&gt;</span><span class="n">flush_domains</span> <span class="o">|=</span> <span class="n">flush_domains</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flush_domains</span> <span class="o">&amp;</span> <span class="n">I915_GEM_GPU_DOMAINS</span><span class="p">)</span>
		<span class="n">cd</span><span class="o">-&gt;</span><span class="n">flush_rings</span> <span class="o">|=</span> <span class="n">intel_ring_flag</span><span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">ring</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">invalidate_domains</span> <span class="o">&amp;</span> <span class="n">I915_GEM_GPU_DOMAINS</span><span class="p">)</span>
		<span class="n">cd</span><span class="o">-&gt;</span><span class="n">flush_rings</span> <span class="o">|=</span> <span class="n">intel_ring_flag</span><span class="p">(</span><span class="n">ring</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">eb_objects</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">and</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="n">buckets</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">eb_objects</span> <span class="o">*</span>
<span class="nf">eb_create</span><span class="p">(</span><span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">eb_objects</span> <span class="o">*</span><span class="n">eb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hlist_head</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">size</span><span class="p">)</span>
		<span class="n">count</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">eb</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">count</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hlist_head</span><span class="p">)</span> <span class="o">+</span>
		     <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">eb_objects</span><span class="p">),</span>
		     <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">eb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">eb</span><span class="p">;</span>

	<span class="n">eb</span><span class="o">-&gt;</span><span class="n">and</span> <span class="o">=</span> <span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">eb</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">eb_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">eb_objects</span> <span class="o">*</span><span class="n">eb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">eb</span><span class="o">-&gt;</span><span class="n">buckets</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">eb</span><span class="o">-&gt;</span><span class="n">and</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hlist_head</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">eb_add_object</span><span class="p">(</span><span class="k">struct</span> <span class="n">eb_objects</span> <span class="o">*</span><span class="n">eb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_i915_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hlist_add_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">exec_node</span><span class="p">,</span>
		       <span class="o">&amp;</span><span class="n">eb</span><span class="o">-&gt;</span><span class="n">buckets</span><span class="p">[</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">exec_handle</span> <span class="o">&amp;</span> <span class="n">eb</span><span class="o">-&gt;</span><span class="n">and</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">drm_i915_gem_object</span> <span class="o">*</span>
<span class="nf">eb_get_object</span><span class="p">(</span><span class="k">struct</span> <span class="n">eb_objects</span> <span class="o">*</span><span class="n">eb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">handle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_i915_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">;</span>

	<span class="n">head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">eb</span><span class="o">-&gt;</span><span class="n">buckets</span><span class="p">[</span><span class="n">handle</span> <span class="o">&amp;</span> <span class="n">eb</span><span class="o">-&gt;</span><span class="n">and</span><span class="p">];</span>
	<span class="n">hlist_for_each</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">obj</span> <span class="o">=</span> <span class="n">hlist_entry</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="k">struct</span> <span class="n">drm_i915_gem_object</span><span class="p">,</span> <span class="n">exec_node</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">exec_handle</span> <span class="o">==</span> <span class="n">handle</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">obj</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">eb_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">eb_objects</span> <span class="o">*</span><span class="n">eb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">eb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">use_cpu_reloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_i915_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">write_domain</span> <span class="o">==</span> <span class="n">I915_GEM_DOMAIN_CPU</span> <span class="o">||</span>
		<span class="n">obj</span><span class="o">-&gt;</span><span class="n">cache_level</span> <span class="o">!=</span> <span class="n">I915_CACHE_NONE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">i915_gem_execbuffer_relocate_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_i915_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">eb_objects</span> <span class="o">*</span><span class="n">eb</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">drm_i915_gem_relocation_entry</span> <span class="o">*</span><span class="n">reloc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_gem_object</span> <span class="o">*</span><span class="n">target_obj</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_i915_gem_object</span> <span class="o">*</span><span class="n">target_i915_obj</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">target_offset</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* we&#39;ve already hold a reference to all valid objects */</span>
	<span class="n">target_obj</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">eb_get_object</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="n">reloc</span><span class="o">-&gt;</span><span class="n">target_handle</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">target_obj</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>

	<span class="n">target_i915_obj</span> <span class="o">=</span> <span class="n">to_intel_bo</span><span class="p">(</span><span class="n">target_obj</span><span class="p">);</span>
	<span class="n">target_offset</span> <span class="o">=</span> <span class="n">target_i915_obj</span><span class="o">-&gt;</span><span class="n">gtt_offset</span><span class="p">;</span>

	<span class="cm">/* The target buffer should have appeared before us in the</span>
<span class="cm">	 * exec_object list, so it should have a GTT space bound by now.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">target_offset</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">DRM_DEBUG</span><span class="p">(</span><span class="s">&quot;No GTT space found for object %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">reloc</span><span class="o">-&gt;</span><span class="n">target_handle</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Validate that the target is in a valid r/w GPU domain */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">reloc</span><span class="o">-&gt;</span><span class="n">write_domain</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">reloc</span><span class="o">-&gt;</span><span class="n">write_domain</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">DRM_DEBUG</span><span class="p">(</span><span class="s">&quot;reloc with multiple write domains: &quot;</span>
			  <span class="s">&quot;obj %p target %d offset %d &quot;</span>
			  <span class="s">&quot;read %08x write %08x&quot;</span><span class="p">,</span>
			  <span class="n">obj</span><span class="p">,</span> <span class="n">reloc</span><span class="o">-&gt;</span><span class="n">target_handle</span><span class="p">,</span>
			  <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">reloc</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">,</span>
			  <span class="n">reloc</span><span class="o">-&gt;</span><span class="n">read_domains</span><span class="p">,</span>
			  <span class="n">reloc</span><span class="o">-&gt;</span><span class="n">write_domain</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">((</span><span class="n">reloc</span><span class="o">-&gt;</span><span class="n">write_domain</span> <span class="o">|</span> <span class="n">reloc</span><span class="o">-&gt;</span><span class="n">read_domains</span><span class="p">)</span>
		     <span class="o">&amp;</span> <span class="o">~</span><span class="n">I915_GEM_GPU_DOMAINS</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">DRM_DEBUG</span><span class="p">(</span><span class="s">&quot;reloc with read/write non-GPU domains: &quot;</span>
			  <span class="s">&quot;obj %p target %d offset %d &quot;</span>
			  <span class="s">&quot;read %08x write %08x&quot;</span><span class="p">,</span>
			  <span class="n">obj</span><span class="p">,</span> <span class="n">reloc</span><span class="o">-&gt;</span><span class="n">target_handle</span><span class="p">,</span>
			  <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">reloc</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">,</span>
			  <span class="n">reloc</span><span class="o">-&gt;</span><span class="n">read_domains</span><span class="p">,</span>
			  <span class="n">reloc</span><span class="o">-&gt;</span><span class="n">write_domain</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">reloc</span><span class="o">-&gt;</span><span class="n">write_domain</span> <span class="o">&amp;&amp;</span> <span class="n">target_obj</span><span class="o">-&gt;</span><span class="n">pending_write_domain</span> <span class="o">&amp;&amp;</span>
		     <span class="n">reloc</span><span class="o">-&gt;</span><span class="n">write_domain</span> <span class="o">!=</span> <span class="n">target_obj</span><span class="o">-&gt;</span><span class="n">pending_write_domain</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">DRM_DEBUG</span><span class="p">(</span><span class="s">&quot;Write domain conflict: &quot;</span>
			  <span class="s">&quot;obj %p target %d offset %d &quot;</span>
			  <span class="s">&quot;new %08x old %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">obj</span><span class="p">,</span> <span class="n">reloc</span><span class="o">-&gt;</span><span class="n">target_handle</span><span class="p">,</span>
			  <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">reloc</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">,</span>
			  <span class="n">reloc</span><span class="o">-&gt;</span><span class="n">write_domain</span><span class="p">,</span>
			  <span class="n">target_obj</span><span class="o">-&gt;</span><span class="n">pending_write_domain</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">target_obj</span><span class="o">-&gt;</span><span class="n">pending_read_domains</span> <span class="o">|=</span> <span class="n">reloc</span><span class="o">-&gt;</span><span class="n">read_domains</span><span class="p">;</span>
	<span class="n">target_obj</span><span class="o">-&gt;</span><span class="n">pending_write_domain</span> <span class="o">|=</span> <span class="n">reloc</span><span class="o">-&gt;</span><span class="n">write_domain</span><span class="p">;</span>

	<span class="cm">/* If the relocation already has the right value in it, no</span>
<span class="cm">	 * more work needs to be done.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">target_offset</span> <span class="o">==</span> <span class="n">reloc</span><span class="o">-&gt;</span><span class="n">presumed_offset</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Check that the relocation address is valid... */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">reloc</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">&gt;</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">4</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">DRM_DEBUG</span><span class="p">(</span><span class="s">&quot;Relocation beyond object bounds: &quot;</span>
			  <span class="s">&quot;obj %p target %d offset %d size %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">obj</span><span class="p">,</span> <span class="n">reloc</span><span class="o">-&gt;</span><span class="n">target_handle</span><span class="p">,</span>
			  <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">reloc</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">,</span>
			  <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">reloc</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">DRM_DEBUG</span><span class="p">(</span><span class="s">&quot;Relocation not 4-byte aligned: &quot;</span>
			  <span class="s">&quot;obj %p target %d offset %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">obj</span><span class="p">,</span> <span class="n">reloc</span><span class="o">-&gt;</span><span class="n">target_handle</span><span class="p">,</span>
			  <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">reloc</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* We can&#39;t wait for rendering with pagefaults disabled */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">active</span> <span class="o">&amp;&amp;</span> <span class="n">in_atomic</span><span class="p">())</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">reloc</span><span class="o">-&gt;</span><span class="n">delta</span> <span class="o">+=</span> <span class="n">target_offset</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">use_cpu_reloc</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">uint32_t</span> <span class="n">page_offset</span> <span class="o">=</span> <span class="n">reloc</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">;</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">vaddr</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">i915_gem_object_set_to_cpu_domain</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

		<span class="n">vaddr</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">reloc</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">]);</span>
		<span class="o">*</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)(</span><span class="n">vaddr</span> <span class="o">+</span> <span class="n">page_offset</span><span class="p">)</span> <span class="o">=</span> <span class="n">reloc</span><span class="o">-&gt;</span><span class="n">delta</span><span class="p">;</span>
		<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">vaddr</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">drm_i915_private</span> <span class="o">*</span><span class="n">dev_priv</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_private</span><span class="p">;</span>
		<span class="kt">uint32_t</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">reloc_entry</span><span class="p">;</span>
		<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">reloc_page</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">i915_gem_object_set_to_gtt_domain</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">i915_gem_object_put_fence</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

		<span class="cm">/* Map the page containing the relocation we&#39;re going to perform.  */</span>
		<span class="n">reloc</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">+=</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">gtt_offset</span><span class="p">;</span>
		<span class="n">reloc_page</span> <span class="o">=</span> <span class="n">io_mapping_map_atomic_wc</span><span class="p">(</span><span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">.</span><span class="n">gtt_mapping</span><span class="p">,</span>
						      <span class="n">reloc</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">);</span>
		<span class="n">reloc_entry</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span>
			<span class="p">(</span><span class="n">reloc_page</span> <span class="o">+</span> <span class="p">(</span><span class="n">reloc</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">));</span>
		<span class="n">iowrite32</span><span class="p">(</span><span class="n">reloc</span><span class="o">-&gt;</span><span class="n">delta</span><span class="p">,</span> <span class="n">reloc_entry</span><span class="p">);</span>
		<span class="n">io_mapping_unmap_atomic</span><span class="p">(</span><span class="n">reloc_page</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Sandybridge PPGTT errata: We need a global gtt mapping for MI and</span>
<span class="cm">	 * pipe_control writes because the gpu doesn&#39;t properly redirect them</span>
<span class="cm">	 * through the ppgtt for non_secure batchbuffers. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">IS_GEN6</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">reloc</span><span class="o">-&gt;</span><span class="n">write_domain</span> <span class="o">==</span> <span class="n">I915_GEM_DOMAIN_INSTRUCTION</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">target_i915_obj</span><span class="o">-&gt;</span><span class="n">has_global_gtt_mapping</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">i915_gem_gtt_bind_object</span><span class="p">(</span><span class="n">target_i915_obj</span><span class="p">,</span>
					 <span class="n">target_i915_obj</span><span class="o">-&gt;</span><span class="n">cache_level</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* and update the user&#39;s relocation entry */</span>
	<span class="n">reloc</span><span class="o">-&gt;</span><span class="n">presumed_offset</span> <span class="o">=</span> <span class="n">target_offset</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">i915_gem_execbuffer_relocate_object</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_i915_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">eb_objects</span> <span class="o">*</span><span class="n">eb</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#define N_RELOC(x) ((x) / sizeof(struct drm_i915_gem_relocation_entry))</span>
	<span class="k">struct</span> <span class="n">drm_i915_gem_relocation_entry</span> <span class="n">stack_reloc</span><span class="p">[</span><span class="n">N_RELOC</span><span class="p">(</span><span class="mi">512</span><span class="p">)];</span>
	<span class="k">struct</span> <span class="n">drm_i915_gem_relocation_entry</span> <span class="n">__user</span> <span class="o">*</span><span class="n">user_relocs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_i915_gem_exec_object2</span> <span class="o">*</span><span class="n">entry</span> <span class="o">=</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">exec_entry</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">remain</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">user_relocs</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">relocs_ptr</span><span class="p">;</span>

	<span class="n">remain</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">relocation_count</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">remain</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">drm_i915_gem_relocation_entry</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="n">stack_reloc</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">remain</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">stack_reloc</span><span class="p">))</span>
			<span class="n">count</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">stack_reloc</span><span class="p">);</span>
		<span class="n">remain</span> <span class="o">-=</span> <span class="n">count</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">__copy_from_user_inatomic</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">user_relocs</span><span class="p">,</span> <span class="n">count</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

		<span class="k">do</span> <span class="p">{</span>
			<span class="n">u64</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">presumed_offset</span><span class="p">;</span>

			<span class="n">ret</span> <span class="o">=</span> <span class="n">i915_gem_execbuffer_relocate_entry</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">eb</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">presumed_offset</span> <span class="o">!=</span> <span class="n">offset</span> <span class="o">&amp;&amp;</span>
			    <span class="n">__copy_to_user_inatomic</span><span class="p">(</span><span class="o">&amp;</span><span class="n">user_relocs</span><span class="o">-&gt;</span><span class="n">presumed_offset</span><span class="p">,</span>
						    <span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">presumed_offset</span><span class="p">,</span>
						    <span class="k">sizeof</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">presumed_offset</span><span class="p">)))</span> <span class="p">{</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">user_relocs</span><span class="o">++</span><span class="p">;</span>
			<span class="n">r</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">count</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#undef N_RELOC</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">i915_gem_execbuffer_relocate_object_slow</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_i915_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">eb_objects</span> <span class="o">*</span><span class="n">eb</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">drm_i915_gem_relocation_entry</span> <span class="o">*</span><span class="n">relocs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">drm_i915_gem_exec_object2</span> <span class="o">*</span><span class="n">entry</span> <span class="o">=</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">exec_entry</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">relocation_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">i915_gem_execbuffer_relocate_entry</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">eb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">relocs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">i915_gem_execbuffer_relocate</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">eb_objects</span> <span class="o">*</span><span class="n">eb</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">objects</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_i915_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* This is the fast path and we cannot handle a pagefault whilst</span>
<span class="cm">	 * holding the struct mutex lest the user pass in the relocations</span>
<span class="cm">	 * contained within a mmaped bo. For in such a case we, the page</span>
<span class="cm">	 * fault handler would call i915_gem_fault() and we would try to</span>
<span class="cm">	 * acquire the struct mutex again. Obviously this is bad and so</span>
<span class="cm">	 * lockdep complains vehemently.</span>
<span class="cm">	 */</span>
	<span class="n">pagefault_disable</span><span class="p">();</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">objects</span><span class="p">,</span> <span class="n">exec_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">i915_gem_execbuffer_relocate_object</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">eb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pagefault_enable</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define  __EXEC_OBJECT_HAS_FENCE (1&lt;&lt;31)</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">need_reloc_mappable</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_i915_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_i915_gem_exec_object2</span> <span class="o">*</span><span class="n">entry</span> <span class="o">=</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">exec_entry</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">relocation_count</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">use_cpu_reloc</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">pin_and_fence_object</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_i915_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">intel_ring_buffer</span> <span class="o">*</span><span class="n">ring</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_i915_gem_exec_object2</span> <span class="o">*</span><span class="n">entry</span> <span class="o">=</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">exec_entry</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">has_fenced_gpu_access</span> <span class="o">=</span> <span class="n">INTEL_INFO</span><span class="p">(</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gen</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">need_fence</span><span class="p">,</span> <span class="n">need_mappable</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">need_fence</span> <span class="o">=</span>
		<span class="n">has_fenced_gpu_access</span> <span class="o">&amp;&amp;</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EXEC_OBJECT_NEEDS_FENCE</span> <span class="o">&amp;&amp;</span>
		<span class="n">obj</span><span class="o">-&gt;</span><span class="n">tiling_mode</span> <span class="o">!=</span> <span class="n">I915_TILING_NONE</span><span class="p">;</span>
	<span class="n">need_mappable</span> <span class="o">=</span> <span class="n">need_fence</span> <span class="o">||</span> <span class="n">need_reloc_mappable</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">i915_gem_object_pin</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">alignment</span><span class="p">,</span> <span class="n">need_mappable</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">has_fenced_gpu_access</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EXEC_OBJECT_NEEDS_FENCE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">i915_gem_object_get_fence</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">err_unpin</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">i915_gem_object_pin_fence</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span>
				<span class="n">entry</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">__EXEC_OBJECT_HAS_FENCE</span><span class="p">;</span>

			<span class="n">obj</span><span class="o">-&gt;</span><span class="n">pending_fenced_gpu_access</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">gtt_offset</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_unpin:</span>
	<span class="n">i915_gem_object_unpin</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">i915_gem_execbuffer_reserve</span><span class="p">(</span><span class="k">struct</span> <span class="n">intel_ring_buffer</span> <span class="o">*</span><span class="n">ring</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">objects</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">drm_i915_private_t</span> <span class="o">*</span><span class="n">dev_priv</span> <span class="o">=</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_i915_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">retry</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">has_fenced_gpu_access</span> <span class="o">=</span> <span class="n">INTEL_INFO</span><span class="p">(</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gen</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">ordered_objects</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ordered_objects</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="n">objects</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">drm_i915_gem_exec_object2</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
		<span class="n">bool</span> <span class="n">need_fence</span><span class="p">,</span> <span class="n">need_mappable</span><span class="p">;</span>

		<span class="n">obj</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="n">objects</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">drm_i915_gem_object</span><span class="p">,</span>
				       <span class="n">exec_list</span><span class="p">);</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">exec_entry</span><span class="p">;</span>

		<span class="n">need_fence</span> <span class="o">=</span>
			<span class="n">has_fenced_gpu_access</span> <span class="o">&amp;&amp;</span>
			<span class="n">entry</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EXEC_OBJECT_NEEDS_FENCE</span> <span class="o">&amp;&amp;</span>
			<span class="n">obj</span><span class="o">-&gt;</span><span class="n">tiling_mode</span> <span class="o">!=</span> <span class="n">I915_TILING_NONE</span><span class="p">;</span>
		<span class="n">need_mappable</span> <span class="o">=</span> <span class="n">need_fence</span> <span class="o">||</span> <span class="n">need_reloc_mappable</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">need_mappable</span><span class="p">)</span>
			<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">exec_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ordered_objects</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">exec_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ordered_objects</span><span class="p">);</span>

		<span class="n">obj</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">pending_read_domains</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">obj</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">pending_write_domain</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">list_splice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ordered_objects</span><span class="p">,</span> <span class="n">objects</span><span class="p">);</span>

	<span class="cm">/* Attempt to pin all of the buffers into the GTT.</span>
<span class="cm">	 * This is done in 3 phases:</span>
<span class="cm">	 *</span>
<span class="cm">	 * 1a. Unbind all objects that do not match the GTT constraints for</span>
<span class="cm">	 *     the execbuffer (fenceable, mappable, alignment etc).</span>
<span class="cm">	 * 1b. Increment pin count for already bound objects.</span>
<span class="cm">	 * 2.  Bind new objects.</span>
<span class="cm">	 * 3.  Decrement pin count.</span>
<span class="cm">	 *</span>
<span class="cm">	 * This avoid unnecessary unbinding of later objects in order to makr</span>
<span class="cm">	 * room for the earlier objects *unless* we need to defragment.</span>
<span class="cm">	 */</span>
	<span class="n">retry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* Unbind any ill-fitting objects or pin. */</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">objects</span><span class="p">,</span> <span class="n">exec_list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">drm_i915_gem_exec_object2</span> <span class="o">*</span><span class="n">entry</span> <span class="o">=</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">exec_entry</span><span class="p">;</span>
			<span class="n">bool</span> <span class="n">need_fence</span><span class="p">,</span> <span class="n">need_mappable</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">gtt_space</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="n">need_fence</span> <span class="o">=</span>
				<span class="n">has_fenced_gpu_access</span> <span class="o">&amp;&amp;</span>
				<span class="n">entry</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EXEC_OBJECT_NEEDS_FENCE</span> <span class="o">&amp;&amp;</span>
				<span class="n">obj</span><span class="o">-&gt;</span><span class="n">tiling_mode</span> <span class="o">!=</span> <span class="n">I915_TILING_NONE</span><span class="p">;</span>
			<span class="n">need_mappable</span> <span class="o">=</span> <span class="n">need_fence</span> <span class="o">||</span> <span class="n">need_reloc_mappable</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">((</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">alignment</span> <span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">gtt_offset</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">alignment</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">||</span>
			    <span class="p">(</span><span class="n">need_mappable</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">map_and_fenceable</span><span class="p">))</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">i915_gem_object_unbind</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">pin_and_fence_object</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">ring</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Bind fresh objects */</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">objects</span><span class="p">,</span> <span class="n">exec_list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">gtt_space</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="n">ret</span> <span class="o">=</span> <span class="n">pin_and_fence_object</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">ring</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
				<span class="kt">int</span> <span class="n">ret_ignore</span><span class="p">;</span>

				<span class="cm">/* This can potentially raise a harmless</span>
<span class="cm">				 * -EINVAL if we failed to bind in the above</span>
<span class="cm">				 * call. It cannot raise -EINTR since we know</span>
<span class="cm">				 * that the bo is freshly bound and so will</span>
<span class="cm">				 * not need to be flushed or waited upon.</span>
<span class="cm">				 */</span>
				<span class="n">ret_ignore</span> <span class="o">=</span> <span class="n">i915_gem_object_unbind</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
				<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">ret_ignore</span><span class="p">;</span>
				<span class="n">WARN_ON</span><span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">gtt_space</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* Decrement pin count for bound objects */</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">objects</span><span class="p">,</span> <span class="n">exec_list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">drm_i915_gem_exec_object2</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">gtt_space</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="n">entry</span> <span class="o">=</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">exec_entry</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">__EXEC_OBJECT_HAS_FENCE</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">i915_gem_object_unpin_fence</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
				<span class="n">entry</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">__EXEC_OBJECT_HAS_FENCE</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">i915_gem_object_unpin</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>

			<span class="cm">/* ... and ensure ppgtt mapping exist if needed. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">.</span><span class="n">aliasing_ppgtt</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">has_aliasing_ppgtt_mapping</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">i915_ppgtt_bind_object</span><span class="p">(</span><span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">.</span><span class="n">aliasing_ppgtt</span><span class="p">,</span>
						       <span class="n">obj</span><span class="p">,</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">cache_level</span><span class="p">);</span>

				<span class="n">obj</span><span class="o">-&gt;</span><span class="n">has_aliasing_ppgtt_mapping</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOSPC</span> <span class="o">||</span> <span class="n">retry</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

		<span class="cm">/* First attempt, just clear anything that is purgeable.</span>
<span class="cm">		 * Second attempt, clear the entire GTT.</span>
<span class="cm">		 */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">i915_gem_evict_everything</span><span class="p">(</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">retry</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

		<span class="n">retry</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>

<span class="nl">err:</span>
	<span class="n">list_for_each_entry_continue_reverse</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">objects</span><span class="p">,</span> <span class="n">exec_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">drm_i915_gem_exec_object2</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">gtt_space</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">entry</span> <span class="o">=</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">exec_entry</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">__EXEC_OBJECT_HAS_FENCE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">i915_gem_object_unpin_fence</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
			<span class="n">entry</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">__EXEC_OBJECT_HAS_FENCE</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">i915_gem_object_unpin</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">i915_gem_execbuffer_relocate_slow</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">intel_ring_buffer</span> <span class="o">*</span><span class="n">ring</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">objects</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">eb_objects</span> <span class="o">*</span><span class="n">eb</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">drm_i915_gem_exec_object2</span> <span class="o">*</span><span class="n">exec</span><span class="p">,</span>
				  <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_i915_gem_relocation_entry</span> <span class="o">*</span><span class="n">reloc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_i915_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">;</span>
	<span class="kt">int</span> <span class="o">*</span><span class="n">reloc_offset</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">total</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* We may process another execbuffer during the unlock... */</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="n">objects</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">obj</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="n">objects</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">drm_i915_gem_object</span><span class="p">,</span>
				       <span class="n">exec_list</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">exec_list</span><span class="p">);</span>
		<span class="n">drm_gem_object_unreference</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">struct_mutex</span><span class="p">);</span>

	<span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">total</span> <span class="o">+=</span> <span class="n">exec</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">relocation_count</span><span class="p">;</span>

	<span class="n">reloc_offset</span> <span class="o">=</span> <span class="n">drm_malloc_ab</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">reloc_offset</span><span class="p">));</span>
	<span class="n">reloc</span> <span class="o">=</span> <span class="n">drm_malloc_ab</span><span class="p">(</span><span class="n">total</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">reloc</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reloc</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">reloc_offset</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">drm_free_large</span><span class="p">(</span><span class="n">reloc</span><span class="p">);</span>
		<span class="n">drm_free_large</span><span class="p">(</span><span class="n">reloc_offset</span><span class="p">);</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">struct_mutex</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">drm_i915_gem_relocation_entry</span> <span class="n">__user</span> <span class="o">*</span><span class="n">user_relocs</span><span class="p">;</span>

		<span class="n">user_relocs</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">exec</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">relocs_ptr</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">reloc</span><span class="o">+</span><span class="n">total</span><span class="p">,</span> <span class="n">user_relocs</span><span class="p">,</span>
				   <span class="n">exec</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">relocation_count</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">reloc</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">struct_mutex</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">reloc_offset</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">total</span><span class="p">;</span>
		<span class="n">total</span> <span class="o">+=</span> <span class="n">exec</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">relocation_count</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">i915_mutex_lock_interruptible</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">struct_mutex</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* reacquire the objects */</span>
	<span class="n">eb_reset</span><span class="p">(</span><span class="n">eb</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">obj</span> <span class="o">=</span> <span class="n">to_intel_bo</span><span class="p">(</span><span class="n">drm_gem_object_lookup</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span>
							<span class="n">exec</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">handle</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DRM_DEBUG</span><span class="p">(</span><span class="s">&quot;Invalid object handle %d at index %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">exec</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">handle</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">exec_list</span><span class="p">,</span> <span class="n">objects</span><span class="p">);</span>
		<span class="n">obj</span><span class="o">-&gt;</span><span class="n">exec_handle</span> <span class="o">=</span> <span class="n">exec</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">handle</span><span class="p">;</span>
		<span class="n">obj</span><span class="o">-&gt;</span><span class="n">exec_entry</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">exec</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">eb_add_object</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="n">obj</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">i915_gem_execbuffer_reserve</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">objects</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">objects</span><span class="p">,</span> <span class="n">exec_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">exec_entry</span> <span class="o">-</span> <span class="n">exec</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">i915_gem_execbuffer_relocate_object_slow</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">eb</span><span class="p">,</span>
							       <span class="n">reloc</span> <span class="o">+</span> <span class="n">reloc_offset</span><span class="p">[</span><span class="n">offset</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Leave the user relocations as are, this is the painfully slow path,</span>
<span class="cm">	 * and we want to avoid the complication of dropping the lock whilst</span>
<span class="cm">	 * having buffers reserved in the aperture and so causing spurious</span>
<span class="cm">	 * ENOSPC for random operations.</span>
<span class="cm">	 */</span>

<span class="nl">err:</span>
	<span class="n">drm_free_large</span><span class="p">(</span><span class="n">reloc</span><span class="p">);</span>
	<span class="n">drm_free_large</span><span class="p">(</span><span class="n">reloc_offset</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">i915_gem_execbuffer_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			  <span class="kt">uint32_t</span> <span class="n">invalidate_domains</span><span class="p">,</span>
			  <span class="kt">uint32_t</span> <span class="n">flush_domains</span><span class="p">,</span>
			  <span class="kt">uint32_t</span> <span class="n">flush_rings</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">drm_i915_private_t</span> <span class="o">*</span><span class="n">dev_priv</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_private</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flush_domains</span> <span class="o">&amp;</span> <span class="n">I915_GEM_DOMAIN_CPU</span><span class="p">)</span>
		<span class="n">intel_gtt_chipset_flush</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flush_domains</span> <span class="o">&amp;</span> <span class="n">I915_GEM_DOMAIN_GTT</span><span class="p">)</span>
		<span class="n">wmb</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">flush_domains</span> <span class="o">|</span> <span class="n">invalidate_domains</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">I915_GEM_GPU_DOMAINS</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">I915_NUM_RINGS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">flush_rings</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">i915_gem_flush_ring</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">ring</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
							  <span class="n">invalidate_domains</span><span class="p">,</span>
							  <span class="n">flush_domains</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
					<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
			<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">i915_gem_execbuffer_wait_for_flips</span><span class="p">(</span><span class="k">struct</span> <span class="n">intel_ring_buffer</span> <span class="o">*</span><span class="n">ring</span><span class="p">,</span> <span class="n">u32</span> <span class="n">flips</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">plane</span><span class="p">,</span> <span class="n">flip_mask</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* Check for any pending flips. As we only maintain a flip queue depth</span>
<span class="cm">	 * of 1, we can simply insert a WAIT for the next display flip prior</span>
<span class="cm">	 * to executing the batch and avoid stalling the CPU.</span>
<span class="cm">	 */</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">plane</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">flips</span> <span class="o">&gt;&gt;</span> <span class="n">plane</span><span class="p">;</span> <span class="n">plane</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(((</span><span class="n">flips</span> <span class="o">&gt;&gt;</span> <span class="n">plane</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">plane</span><span class="p">)</span>
			<span class="n">flip_mask</span> <span class="o">=</span> <span class="n">MI_WAIT_FOR_PLANE_B_FLIP</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">flip_mask</span> <span class="o">=</span> <span class="n">MI_WAIT_FOR_PLANE_A_FLIP</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">intel_ring_begin</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

		<span class="n">intel_ring_emit</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">MI_WAIT_FOR_EVENT</span> <span class="o">|</span> <span class="n">flip_mask</span><span class="p">);</span>
		<span class="n">intel_ring_emit</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">MI_NOOP</span><span class="p">);</span>
		<span class="n">intel_ring_advance</span><span class="p">(</span><span class="n">ring</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span>
<span class="nf">i915_gem_execbuffer_move_to_gpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">intel_ring_buffer</span> <span class="o">*</span><span class="n">ring</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">objects</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_i915_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">change_domains</span> <span class="n">cd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cd</span><span class="p">));</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">objects</span><span class="p">,</span> <span class="n">exec_list</span><span class="p">)</span>
		<span class="n">i915_gem_object_set_to_gpu_domain</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">ring</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cd</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cd</span><span class="p">.</span><span class="n">invalidate_domains</span> <span class="o">|</span> <span class="n">cd</span><span class="p">.</span><span class="n">flush_domains</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">i915_gem_execbuffer_flush</span><span class="p">(</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
						<span class="n">cd</span><span class="p">.</span><span class="n">invalidate_domains</span><span class="p">,</span>
						<span class="n">cd</span><span class="p">.</span><span class="n">flush_domains</span><span class="p">,</span>
						<span class="n">cd</span><span class="p">.</span><span class="n">flush_rings</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cd</span><span class="p">.</span><span class="n">flips</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">i915_gem_execbuffer_wait_for_flips</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">cd</span><span class="p">.</span><span class="n">flips</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">objects</span><span class="p">,</span> <span class="n">exec_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">i915_gem_object_sync</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">ring</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span>
<span class="nf">i915_gem_check_execbuffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_i915_gem_execbuffer2</span> <span class="o">*</span><span class="n">exec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">((</span><span class="n">exec</span><span class="o">-&gt;</span><span class="n">batch_start_offset</span> <span class="o">|</span> <span class="n">exec</span><span class="o">-&gt;</span><span class="n">batch_len</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x7</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">validate_exec_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_i915_gem_exec_object2</span> <span class="o">*</span><span class="n">exec</span><span class="p">,</span>
		   <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">exec</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">relocs_ptr</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">length</span><span class="p">;</span> <span class="cm">/* limited by fault_in_pages_readable() */</span>

		<span class="cm">/* First check for malicious input causing overflow */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">exec</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">relocation_count</span> <span class="o">&gt;</span>
		    <span class="n">INT_MAX</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_i915_gem_relocation_entry</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="n">length</span> <span class="o">=</span> <span class="n">exec</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">relocation_count</span> <span class="o">*</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_i915_gem_relocation_entry</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">access_ok</span><span class="p">(</span><span class="n">VERIFY_READ</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">length</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

		<span class="cm">/* we may also need to update the presumed offsets */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">access_ok</span><span class="p">(</span><span class="n">VERIFY_WRITE</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">length</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">fault_in_multipages_readable</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">length</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">i915_gem_execbuffer_move_to_active</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">objects</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">intel_ring_buffer</span> <span class="o">*</span><span class="n">ring</span><span class="p">,</span>
				   <span class="n">u32</span> <span class="n">seqno</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_i915_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">objects</span><span class="p">,</span> <span class="n">exec_list</span><span class="p">)</span> <span class="p">{</span>
		  <span class="n">u32</span> <span class="n">old_read</span> <span class="o">=</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">read_domains</span><span class="p">;</span>
		  <span class="n">u32</span> <span class="n">old_write</span> <span class="o">=</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">write_domain</span><span class="p">;</span>


		<span class="n">obj</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">read_domains</span> <span class="o">=</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">pending_read_domains</span><span class="p">;</span>
		<span class="n">obj</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">write_domain</span> <span class="o">=</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">pending_write_domain</span><span class="p">;</span>
		<span class="n">obj</span><span class="o">-&gt;</span><span class="n">fenced_gpu_access</span> <span class="o">=</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">pending_fenced_gpu_access</span><span class="p">;</span>

		<span class="n">i915_gem_object_move_to_active</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">ring</span><span class="p">,</span> <span class="n">seqno</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">write_domain</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">obj</span><span class="o">-&gt;</span><span class="n">dirty</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">obj</span><span class="o">-&gt;</span><span class="n">pending_gpu_write</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">gpu_write_list</span><span class="p">,</span>
				       <span class="o">&amp;</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">gpu_write_list</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">pin_count</span><span class="p">)</span> <span class="cm">/* check for potential scanout */</span>
				<span class="n">intel_mark_busy</span><span class="p">(</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">obj</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">trace_i915_gem_object_change_domain</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">old_read</span><span class="p">,</span> <span class="n">old_write</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">intel_mark_busy</span><span class="p">(</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">i915_gem_execbuffer_retire_commands</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">intel_ring_buffer</span> <span class="o">*</span><span class="n">ring</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_i915_gem_request</span> <span class="o">*</span><span class="n">request</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">invalidate</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Ensure that the commands in the batch buffer are</span>
<span class="cm">	 * finished before the interrupt fires.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The sampler always gets flushed on i965 (sigh).</span>
<span class="cm">	 */</span>
	<span class="n">invalidate</span> <span class="o">=</span> <span class="n">I915_GEM_DOMAIN_COMMAND</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">INTEL_INFO</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gen</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">)</span>
		<span class="n">invalidate</span> <span class="o">|=</span> <span class="n">I915_GEM_DOMAIN_SAMPLER</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">flush</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">invalidate</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">i915_gem_next_request_seqno</span><span class="p">(</span><span class="n">ring</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Add a breadcrumb for the completion of the batch buffer */</span>
	<span class="n">request</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">request</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">request</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">i915_add_request</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">request</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">i915_gem_next_request_seqno</span><span class="p">(</span><span class="n">ring</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">request</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">i915_reset_gen7_sol_offsets</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">intel_ring_buffer</span> <span class="o">*</span><span class="n">ring</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">drm_i915_private_t</span> <span class="o">*</span><span class="n">dev_priv</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_private</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_GEN7</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">||</span> <span class="n">ring</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">ring</span><span class="p">[</span><span class="n">RCS</span><span class="p">])</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">intel_ring_begin</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="mi">4</span> <span class="o">*</span> <span class="mi">3</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">intel_ring_emit</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">MI_LOAD_REGISTER_IMM</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
		<span class="n">intel_ring_emit</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">GEN7_SO_WRITE_OFFSET</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
		<span class="n">intel_ring_emit</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">intel_ring_advance</span><span class="p">(</span><span class="n">ring</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">i915_gem_do_execbuffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">drm_i915_gem_execbuffer2</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">drm_i915_gem_exec_object2</span> <span class="o">*</span><span class="n">exec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">drm_i915_private_t</span> <span class="o">*</span><span class="n">dev_priv</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">objects</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">eb_objects</span> <span class="o">*</span><span class="n">eb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_i915_gem_object</span> <span class="o">*</span><span class="n">batch_obj</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_clip_rect</span> <span class="o">*</span><span class="n">cliprects</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">intel_ring_buffer</span> <span class="o">*</span><span class="n">ring</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">exec_start</span><span class="p">,</span> <span class="n">exec_len</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">seqno</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mask</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i915_gem_check_execbuffer</span><span class="p">(</span><span class="n">args</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">DRM_DEBUG</span><span class="p">(</span><span class="s">&quot;execbuf with invalid offset/length</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">validate_exec_list</span><span class="p">(</span><span class="n">exec</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">buffer_count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">I915_EXEC_RING_MASK</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">I915_EXEC_DEFAULT</span>:
	<span class="k">case</span> <span class="n">I915_EXEC_RENDER</span>:
		<span class="n">ring</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">ring</span><span class="p">[</span><span class="n">RCS</span><span class="p">];</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">I915_EXEC_BSD</span>:
		<span class="n">ring</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">ring</span><span class="p">[</span><span class="n">VCS</span><span class="p">];</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">I915_EXEC_BLT</span>:
		<span class="n">ring</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">ring</span><span class="p">[</span><span class="n">BCS</span><span class="p">];</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">DRM_DEBUG</span><span class="p">(</span><span class="s">&quot;execbuf with unknown ring: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">I915_EXEC_RING_MASK</span><span class="p">));</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">intel_ring_initialized</span><span class="p">(</span><span class="n">ring</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">DRM_DEBUG</span><span class="p">(</span><span class="s">&quot;execbuf with invalid ring: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">I915_EXEC_RING_MASK</span><span class="p">));</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mode</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">I915_EXEC_CONSTANTS_MASK</span><span class="p">;</span>
	<span class="n">mask</span> <span class="o">=</span> <span class="n">I915_EXEC_CONSTANTS_MASK</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">I915_EXEC_CONSTANTS_REL_GENERAL</span>:
	<span class="k">case</span> <span class="n">I915_EXEC_CONSTANTS_ABSOLUTE</span>:
	<span class="k">case</span> <span class="n">I915_EXEC_CONSTANTS_REL_SURFACE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">ring</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">ring</span><span class="p">[</span><span class="n">RCS</span><span class="p">]</span> <span class="o">&amp;&amp;</span>
		    <span class="n">mode</span> <span class="o">!=</span> <span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">relative_constants_mode</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">INTEL_INFO</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gen</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">INTEL_INFO</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gen</span> <span class="o">&gt;</span> <span class="mi">5</span> <span class="o">&amp;&amp;</span>
			    <span class="n">mode</span> <span class="o">==</span> <span class="n">I915_EXEC_CONSTANTS_REL_SURFACE</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

			<span class="cm">/* The HW changed the meaning on this bit on gen6 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">INTEL_INFO</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gen</span> <span class="o">&gt;=</span> <span class="mi">6</span><span class="p">)</span>
				<span class="n">mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">I915_EXEC_CONSTANTS_REL_SURFACE</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">DRM_DEBUG</span><span class="p">(</span><span class="s">&quot;execbuf with unknown constants: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">buffer_count</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DRM_DEBUG</span><span class="p">(</span><span class="s">&quot;execbuf with %d buffers</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">buffer_count</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">num_cliprects</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ring</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">ring</span><span class="p">[</span><span class="n">RCS</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">DRM_DEBUG</span><span class="p">(</span><span class="s">&quot;clip rectangles are only valid with the render ring</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">INTEL_INFO</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gen</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DRM_DEBUG</span><span class="p">(</span><span class="s">&quot;clip rectangles are only valid on pre-gen5</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">num_cliprects</span> <span class="o">&gt;</span> <span class="n">UINT_MAX</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">cliprects</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">DRM_DEBUG</span><span class="p">(</span><span class="s">&quot;execbuf with %u cliprects</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">args</span><span class="o">-&gt;</span><span class="n">num_cliprects</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">cliprects</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">num_cliprects</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">cliprects</span><span class="p">),</span>
				    <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cliprects</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">pre_mutex_err</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">cliprects</span><span class="p">,</span>
				     <span class="p">(</span><span class="k">struct</span> <span class="n">drm_clip_rect</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)(</span><span class="kt">uintptr_t</span><span class="p">)</span>
				     <span class="n">args</span><span class="o">-&gt;</span><span class="n">cliprects_ptr</span><span class="p">,</span>
				     <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">cliprects</span><span class="p">)</span><span class="o">*</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">num_cliprects</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">pre_mutex_err</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">i915_mutex_lock_interruptible</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">pre_mutex_err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">.</span><span class="n">suspended</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">struct_mutex</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">pre_mutex_err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">eb</span> <span class="o">=</span> <span class="n">eb_create</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">buffer_count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">eb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">struct_mutex</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">pre_mutex_err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Look up object handles */</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">objects</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">buffer_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">drm_i915_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">;</span>

		<span class="n">obj</span> <span class="o">=</span> <span class="n">to_intel_bo</span><span class="p">(</span><span class="n">drm_gem_object_lookup</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span>
							<span class="n">exec</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">handle</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DRM_DEBUG</span><span class="p">(</span><span class="s">&quot;Invalid object handle %d at index %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">exec</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">handle</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="cm">/* prevent error path from reading uninitialized data */</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">exec_list</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">DRM_DEBUG</span><span class="p">(</span><span class="s">&quot;Object %p [handle %d, index %d] appears more than once in object list</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">obj</span><span class="p">,</span> <span class="n">exec</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">handle</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">exec_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">objects</span><span class="p">);</span>
		<span class="n">obj</span><span class="o">-&gt;</span><span class="n">exec_handle</span> <span class="o">=</span> <span class="n">exec</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">handle</span><span class="p">;</span>
		<span class="n">obj</span><span class="o">-&gt;</span><span class="n">exec_entry</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">exec</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">eb_add_object</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="n">obj</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* take note of the batch buffer before we might reorder the lists */</span>
	<span class="n">batch_obj</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">objects</span><span class="p">.</span><span class="n">prev</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">drm_i915_gem_object</span><span class="p">,</span>
			       <span class="n">exec_list</span><span class="p">);</span>

	<span class="cm">/* Move the objects en-masse into the GTT, evicting if necessary. */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">i915_gem_execbuffer_reserve</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">objects</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* The objects are in their final locations, apply the relocations. */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">i915_gem_execbuffer_relocate</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">eb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">objects</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">i915_gem_execbuffer_relocate_slow</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">ring</span><span class="p">,</span>
								<span class="o">&amp;</span><span class="n">objects</span><span class="p">,</span> <span class="n">eb</span><span class="p">,</span>
								<span class="n">exec</span><span class="p">,</span>
								<span class="n">args</span><span class="o">-&gt;</span><span class="n">buffer_count</span><span class="p">);</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">mutex_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">struct_mutex</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Set the pending read domains for the batch buffer to COMMAND */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">batch_obj</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">pending_write_domain</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DRM_DEBUG</span><span class="p">(</span><span class="s">&quot;Attempting to use self-modifying batch buffer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">batch_obj</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">pending_read_domains</span> <span class="o">|=</span> <span class="n">I915_GEM_DOMAIN_COMMAND</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">i915_gem_execbuffer_move_to_gpu</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">objects</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">seqno</span> <span class="o">=</span> <span class="n">i915_gem_next_request_seqno</span><span class="p">(</span><span class="n">ring</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">sync_seqno</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">seqno</span> <span class="o">&lt;</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">sync_seqno</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="cm">/* The GPU can not handle its semaphore value wrapping,</span>
<span class="cm">			 * so every billion or so execbuffers, we need to stall</span>
<span class="cm">			 * the GPU in order to reset the counters.</span>
<span class="cm">			 */</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">i915_gpu_idle</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
			<span class="n">i915_gem_retire_requests</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">sync_seqno</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ring</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">ring</span><span class="p">[</span><span class="n">RCS</span><span class="p">]</span> <span class="o">&amp;&amp;</span>
	    <span class="n">mode</span> <span class="o">!=</span> <span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">relative_constants_mode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">intel_ring_begin</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

		<span class="n">intel_ring_emit</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">MI_NOOP</span><span class="p">);</span>
		<span class="n">intel_ring_emit</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">MI_LOAD_REGISTER_IMM</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
		<span class="n">intel_ring_emit</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">INSTPM</span><span class="p">);</span>
		<span class="n">intel_ring_emit</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">mask</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span> <span class="o">|</span> <span class="n">mode</span><span class="p">);</span>
		<span class="n">intel_ring_advance</span><span class="p">(</span><span class="n">ring</span><span class="p">);</span>

		<span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">relative_constants_mode</span> <span class="o">=</span> <span class="n">mode</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">I915_EXEC_GEN7_SOL_RESET</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">i915_reset_gen7_sol_offsets</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ring</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">trace_i915_gem_ring_dispatch</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">seqno</span><span class="p">);</span>

	<span class="n">exec_start</span> <span class="o">=</span> <span class="n">batch_obj</span><span class="o">-&gt;</span><span class="n">gtt_offset</span> <span class="o">+</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">batch_start_offset</span><span class="p">;</span>
	<span class="n">exec_len</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">batch_len</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cliprects</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">num_cliprects</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">i915_emit_box</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cliprects</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
					    <span class="n">args</span><span class="o">-&gt;</span><span class="n">DR1</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">DR4</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

			<span class="n">ret</span> <span class="o">=</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">dispatch_execbuffer</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span>
							<span class="n">exec_start</span><span class="p">,</span> <span class="n">exec_len</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">dispatch_execbuffer</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">exec_start</span><span class="p">,</span> <span class="n">exec_len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">i915_gem_execbuffer_move_to_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">objects</span><span class="p">,</span> <span class="n">ring</span><span class="p">,</span> <span class="n">seqno</span><span class="p">);</span>
	<span class="n">i915_gem_execbuffer_retire_commands</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">ring</span><span class="p">);</span>

<span class="nl">err:</span>
	<span class="n">eb_destroy</span><span class="p">(</span><span class="n">eb</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">objects</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">drm_i915_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">;</span>

		<span class="n">obj</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">objects</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">drm_i915_gem_object</span><span class="p">,</span>
				       <span class="n">exec_list</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">exec_list</span><span class="p">);</span>
		<span class="n">drm_gem_object_unreference</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">struct_mutex</span><span class="p">);</span>

<span class="nl">pre_mutex_err:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">cliprects</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Legacy execbuffer just creates an exec2 list from the original exec object</span>
<span class="cm"> * list array and passes it to the real function.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">i915_gem_execbuffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_i915_gem_execbuffer</span> <span class="o">*</span><span class="n">args</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_i915_gem_execbuffer2</span> <span class="n">exec2</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_i915_gem_exec_object</span> <span class="o">*</span><span class="n">exec_list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_i915_gem_exec_object2</span> <span class="o">*</span><span class="n">exec2_list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">buffer_count</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DRM_DEBUG</span><span class="p">(</span><span class="s">&quot;execbuf with %d buffers</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">buffer_count</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Copy in the exec list from userland */</span>
	<span class="n">exec_list</span> <span class="o">=</span> <span class="n">drm_malloc_ab</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">exec_list</span><span class="p">),</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">buffer_count</span><span class="p">);</span>
	<span class="n">exec2_list</span> <span class="o">=</span> <span class="n">drm_malloc_ab</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">exec2_list</span><span class="p">),</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">buffer_count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">exec_list</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">exec2_list</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DRM_DEBUG</span><span class="p">(</span><span class="s">&quot;Failed to allocate exec list for %d buffers</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">args</span><span class="o">-&gt;</span><span class="n">buffer_count</span><span class="p">);</span>
		<span class="n">drm_free_large</span><span class="p">(</span><span class="n">exec_list</span><span class="p">);</span>
		<span class="n">drm_free_large</span><span class="p">(</span><span class="n">exec2_list</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">copy_from_user</span><span class="p">(</span><span class="n">exec_list</span><span class="p">,</span>
			     <span class="p">(</span><span class="k">struct</span> <span class="n">drm_i915_relocation_entry</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span>
			     <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">buffers_ptr</span><span class="p">,</span>
			     <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">exec_list</span><span class="p">)</span> <span class="o">*</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">buffer_count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DRM_DEBUG</span><span class="p">(</span><span class="s">&quot;copy %d exec entries failed %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">args</span><span class="o">-&gt;</span><span class="n">buffer_count</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="n">drm_free_large</span><span class="p">(</span><span class="n">exec_list</span><span class="p">);</span>
		<span class="n">drm_free_large</span><span class="p">(</span><span class="n">exec2_list</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">buffer_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">exec2_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">handle</span> <span class="o">=</span> <span class="n">exec_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">handle</span><span class="p">;</span>
		<span class="n">exec2_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">relocation_count</span> <span class="o">=</span> <span class="n">exec_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">relocation_count</span><span class="p">;</span>
		<span class="n">exec2_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">relocs_ptr</span> <span class="o">=</span> <span class="n">exec_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">relocs_ptr</span><span class="p">;</span>
		<span class="n">exec2_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">alignment</span> <span class="o">=</span> <span class="n">exec_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">alignment</span><span class="p">;</span>
		<span class="n">exec2_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">offset</span> <span class="o">=</span> <span class="n">exec_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">offset</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">INTEL_INFO</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gen</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">)</span>
			<span class="n">exec2_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">flags</span> <span class="o">=</span> <span class="n">EXEC_OBJECT_NEEDS_FENCE</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">exec2_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">exec2</span><span class="p">.</span><span class="n">buffers_ptr</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">buffers_ptr</span><span class="p">;</span>
	<span class="n">exec2</span><span class="p">.</span><span class="n">buffer_count</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">buffer_count</span><span class="p">;</span>
	<span class="n">exec2</span><span class="p">.</span><span class="n">batch_start_offset</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">batch_start_offset</span><span class="p">;</span>
	<span class="n">exec2</span><span class="p">.</span><span class="n">batch_len</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">batch_len</span><span class="p">;</span>
	<span class="n">exec2</span><span class="p">.</span><span class="n">DR1</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">DR1</span><span class="p">;</span>
	<span class="n">exec2</span><span class="p">.</span><span class="n">DR4</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">DR4</span><span class="p">;</span>
	<span class="n">exec2</span><span class="p">.</span><span class="n">num_cliprects</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">num_cliprects</span><span class="p">;</span>
	<span class="n">exec2</span><span class="p">.</span><span class="n">cliprects_ptr</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">cliprects_ptr</span><span class="p">;</span>
	<span class="n">exec2</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">I915_EXEC_RENDER</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">i915_gem_do_execbuffer</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">exec2</span><span class="p">,</span> <span class="n">exec2_list</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Copy the new buffer offsets back to the user&#39;s exec list. */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">buffer_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">exec_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">offset</span> <span class="o">=</span> <span class="n">exec2_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">offset</span><span class="p">;</span>
		<span class="cm">/* ... and back out to userspace */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">copy_to_user</span><span class="p">((</span><span class="k">struct</span> <span class="n">drm_i915_relocation_entry</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span>
				   <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">buffers_ptr</span><span class="p">,</span>
				   <span class="n">exec_list</span><span class="p">,</span>
				   <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">exec_list</span><span class="p">)</span> <span class="o">*</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">buffer_count</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="n">DRM_DEBUG</span><span class="p">(</span><span class="s">&quot;failed to copy %d exec entries &quot;</span>
				  <span class="s">&quot;back to user (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">args</span><span class="o">-&gt;</span><span class="n">buffer_count</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">drm_free_large</span><span class="p">(</span><span class="n">exec_list</span><span class="p">);</span>
	<span class="n">drm_free_large</span><span class="p">(</span><span class="n">exec2_list</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">i915_gem_execbuffer2</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_i915_gem_execbuffer2</span> <span class="o">*</span><span class="n">args</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_i915_gem_exec_object2</span> <span class="o">*</span><span class="n">exec2_list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">buffer_count</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">||</span>
	    <span class="n">args</span><span class="o">-&gt;</span><span class="n">buffer_count</span> <span class="o">&gt;</span> <span class="n">UINT_MAX</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">exec2_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">DRM_DEBUG</span><span class="p">(</span><span class="s">&quot;execbuf2 with %d buffers</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">buffer_count</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">exec2_list</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">exec2_list</span><span class="p">)</span><span class="o">*</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">buffer_count</span><span class="p">,</span>
			     <span class="n">GFP_KERNEL</span> <span class="o">|</span> <span class="n">__GFP_NOWARN</span> <span class="o">|</span> <span class="n">__GFP_NORETRY</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">exec2_list</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">exec2_list</span> <span class="o">=</span> <span class="n">drm_malloc_ab</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">exec2_list</span><span class="p">),</span>
					   <span class="n">args</span><span class="o">-&gt;</span><span class="n">buffer_count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">exec2_list</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DRM_DEBUG</span><span class="p">(</span><span class="s">&quot;Failed to allocate exec list for %d buffers</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">args</span><span class="o">-&gt;</span><span class="n">buffer_count</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">copy_from_user</span><span class="p">(</span><span class="n">exec2_list</span><span class="p">,</span>
			     <span class="p">(</span><span class="k">struct</span> <span class="n">drm_i915_relocation_entry</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span>
			     <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">buffers_ptr</span><span class="p">,</span>
			     <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">exec2_list</span><span class="p">)</span> <span class="o">*</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">buffer_count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DRM_DEBUG</span><span class="p">(</span><span class="s">&quot;copy %d exec entries failed %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">args</span><span class="o">-&gt;</span><span class="n">buffer_count</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="n">drm_free_large</span><span class="p">(</span><span class="n">exec2_list</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">i915_gem_do_execbuffer</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">exec2_list</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Copy the new buffer offsets back to the user&#39;s exec list. */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">copy_to_user</span><span class="p">((</span><span class="k">struct</span> <span class="n">drm_i915_relocation_entry</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span>
				   <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">buffers_ptr</span><span class="p">,</span>
				   <span class="n">exec2_list</span><span class="p">,</span>
				   <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">exec2_list</span><span class="p">)</span> <span class="o">*</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">buffer_count</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="n">DRM_DEBUG</span><span class="p">(</span><span class="s">&quot;failed to copy %d exec entries &quot;</span>
				  <span class="s">&quot;back to user (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">args</span><span class="o">-&gt;</span><span class="n">buffer_count</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">drm_free_large</span><span class="p">(</span><span class="n">exec2_list</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
