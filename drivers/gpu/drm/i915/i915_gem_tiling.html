<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › gpu › drm › i915 › i915_gem_tiling.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>i915_gem_tiling.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright © 2008 Intel Corporation</span>
<span class="cm"> *</span>
<span class="cm"> * Permission is hereby granted, free of charge, to any person obtaining a</span>
<span class="cm"> * copy of this software and associated documentation files (the &quot;Software&quot;),</span>
<span class="cm"> * to deal in the Software without restriction, including without limitation</span>
<span class="cm"> * the rights to use, copy, modify, merge, publish, distribute, sublicense,</span>
<span class="cm"> * and/or sell copies of the Software, and to permit persons to whom the</span>
<span class="cm"> * Software is furnished to do so, subject to the following conditions:</span>
<span class="cm"> *</span>
<span class="cm"> * The above copyright notice and this permission notice (including the next</span>
<span class="cm"> * paragraph) shall be included in all copies or substantial portions of the</span>
<span class="cm"> * Software.</span>
<span class="cm"> *</span>
<span class="cm"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span>
<span class="cm"> * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL</span>
<span class="cm"> * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span>
<span class="cm"> * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING</span>
<span class="cm"> * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS</span>
<span class="cm"> * IN THE SOFTWARE.</span>
<span class="cm"> *</span>
<span class="cm"> * Authors:</span>
<span class="cm"> *    Eric Anholt &lt;eric@anholt.net&gt;</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &quot;linux/string.h&quot;</span>
<span class="cp">#include &quot;linux/bitops.h&quot;</span>
<span class="cp">#include &quot;drmP.h&quot;</span>
<span class="cp">#include &quot;drm.h&quot;</span>
<span class="cp">#include &quot;i915_drm.h&quot;</span>
<span class="cp">#include &quot;i915_drv.h&quot;</span>

<span class="cm">/** @file i915_gem_tiling.c</span>
<span class="cm"> *</span>
<span class="cm"> * Support for managing tiling state of buffer objects.</span>
<span class="cm"> *</span>
<span class="cm"> * The idea behind tiling is to increase cache hit rates by rearranging</span>
<span class="cm"> * pixel data so that a group of pixel accesses are in the same cacheline.</span>
<span class="cm"> * Performance improvement from doing this on the back/depth buffer are on</span>
<span class="cm"> * the order of 30%.</span>
<span class="cm"> *</span>
<span class="cm"> * Intel architectures make this somewhat more complicated, though, by</span>
<span class="cm"> * adjustments made to addressing of data when the memory is in interleaved</span>
<span class="cm"> * mode (matched pairs of DIMMS) to improve memory bandwidth.</span>
<span class="cm"> * For interleaved memory, the CPU sends every sequential 64 bytes</span>
<span class="cm"> * to an alternate memory channel so it can get the bandwidth from both.</span>
<span class="cm"> *</span>
<span class="cm"> * The GPU also rearranges its accesses for increased bandwidth to interleaved</span>
<span class="cm"> * memory, and it matches what the CPU does for non-tiled.  However, when tiled</span>
<span class="cm"> * it does it a little differently, since one walks addresses not just in the</span>
<span class="cm"> * X direction but also Y.  So, along with alternating channels when bit</span>
<span class="cm"> * 6 of the address flips, it also alternates when other bits flip --  Bits 9</span>
<span class="cm"> * (every 512 bytes, an X tile scanline) and 10 (every two X tile scanlines)</span>
<span class="cm"> * are common to both the 915 and 965-class hardware.</span>
<span class="cm"> *</span>
<span class="cm"> * The CPU also sometimes XORs in higher bits as well, to improve</span>
<span class="cm"> * bandwidth doing strided access like we do so frequently in graphics.  This</span>
<span class="cm"> * is called &quot;Channel XOR Randomization&quot; in the MCH documentation.  The result</span>
<span class="cm"> * is that the CPU is XORing in either bit 11 or bit 17 to bit 6 of its address</span>
<span class="cm"> * decode.</span>
<span class="cm"> *</span>
<span class="cm"> * All of this bit 6 XORing has an effect on our memory management,</span>
<span class="cm"> * as we need to make sure that the 3d driver can correctly address object</span>
<span class="cm"> * contents.</span>
<span class="cm"> *</span>
<span class="cm"> * If we don&#39;t have interleaved memory, all tiling is safe and no swizzling is</span>
<span class="cm"> * required.</span>
<span class="cm"> *</span>
<span class="cm"> * When bit 17 is XORed in, we simply refuse to tile at all.  Bit</span>
<span class="cm"> * 17 is not just a page offset, so as we page an objet out and back in,</span>
<span class="cm"> * individual pages in it will have different bit 17 addresses, resulting in</span>
<span class="cm"> * each 64 bytes being swapped with its neighbor!</span>
<span class="cm"> *</span>
<span class="cm"> * Otherwise, if interleaved, we have to tell the 3d driver what the address</span>
<span class="cm"> * swizzling it needs to do is, since it&#39;s writing with the CPU to the pages</span>
<span class="cm"> * (bit 6 and potentially bit 11 XORed in), and the GPU is reading from the</span>
<span class="cm"> * pages (bit 6, 9, and 10 XORed in), resulting in a cumulative bit swizzling</span>
<span class="cm"> * required by the CPU of XORing in bit 6, 9, 10, and potentially 11, in order</span>
<span class="cm"> * to match what the GPU expects.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * Detects bit 6 swizzling of address lookup between IGD access and CPU</span>
<span class="cm"> * access through main memory.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">i915_gem_detect_bit_6_swizzle</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">drm_i915_private_t</span> <span class="o">*</span><span class="n">dev_priv</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_private</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">swizzle_x</span> <span class="o">=</span> <span class="n">I915_BIT_6_SWIZZLE_UNKNOWN</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">swizzle_y</span> <span class="o">=</span> <span class="n">I915_BIT_6_SWIZZLE_UNKNOWN</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">INTEL_INFO</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gen</span> <span class="o">&gt;=</span> <span class="mi">6</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">uint32_t</span> <span class="n">dimm_c0</span><span class="p">,</span> <span class="n">dimm_c1</span><span class="p">;</span>
		<span class="n">dimm_c0</span> <span class="o">=</span> <span class="n">I915_READ</span><span class="p">(</span><span class="n">MAD_DIMM_C0</span><span class="p">);</span>
		<span class="n">dimm_c1</span> <span class="o">=</span> <span class="n">I915_READ</span><span class="p">(</span><span class="n">MAD_DIMM_C1</span><span class="p">);</span>
		<span class="n">dimm_c0</span> <span class="o">&amp;=</span> <span class="n">MAD_DIMM_A_SIZE_MASK</span> <span class="o">|</span> <span class="n">MAD_DIMM_B_SIZE_MASK</span><span class="p">;</span>
		<span class="n">dimm_c1</span> <span class="o">&amp;=</span> <span class="n">MAD_DIMM_A_SIZE_MASK</span> <span class="o">|</span> <span class="n">MAD_DIMM_B_SIZE_MASK</span><span class="p">;</span>
		<span class="cm">/* Enable swizzling when the channels are populated with</span>
<span class="cm">		 * identically sized dimms. We don&#39;t need to check the 3rd</span>
<span class="cm">		 * channel because no cpu with gpu attached ships in that</span>
<span class="cm">		 * configuration. Also, swizzling only makes sense for 2</span>
<span class="cm">		 * channels anyway. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dimm_c0</span> <span class="o">==</span> <span class="n">dimm_c1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">swizzle_x</span> <span class="o">=</span> <span class="n">I915_BIT_6_SWIZZLE_9_10</span><span class="p">;</span>
			<span class="n">swizzle_y</span> <span class="o">=</span> <span class="n">I915_BIT_6_SWIZZLE_9</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">swizzle_x</span> <span class="o">=</span> <span class="n">I915_BIT_6_SWIZZLE_NONE</span><span class="p">;</span>
			<span class="n">swizzle_y</span> <span class="o">=</span> <span class="n">I915_BIT_6_SWIZZLE_NONE</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">IS_GEN5</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* On Ironlake whatever DRAM config, GPU always do</span>
<span class="cm">		 * same swizzling setup.</span>
<span class="cm">		 */</span>
		<span class="n">swizzle_x</span> <span class="o">=</span> <span class="n">I915_BIT_6_SWIZZLE_9_10</span><span class="p">;</span>
		<span class="n">swizzle_y</span> <span class="o">=</span> <span class="n">I915_BIT_6_SWIZZLE_9</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">IS_GEN2</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* As far as we know, the 865 doesn&#39;t have these bit 6</span>
<span class="cm">		 * swizzling issues.</span>
<span class="cm">		 */</span>
		<span class="n">swizzle_x</span> <span class="o">=</span> <span class="n">I915_BIT_6_SWIZZLE_NONE</span><span class="p">;</span>
		<span class="n">swizzle_y</span> <span class="o">=</span> <span class="n">I915_BIT_6_SWIZZLE_NONE</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">IS_MOBILE</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">IS_GEN3</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">IS_G33</span><span class="p">(</span><span class="n">dev</span><span class="p">)))</span> <span class="p">{</span>
		<span class="kt">uint32_t</span> <span class="n">dcc</span><span class="p">;</span>

		<span class="cm">/* On 9xx chipsets, channel interleave by the CPU is</span>
<span class="cm">		 * determined by DCC.  For single-channel, neither the CPU</span>
<span class="cm">		 * nor the GPU do swizzling.  For dual channel interleaved,</span>
<span class="cm">		 * the GPU&#39;s interleave is bit 9 and 10 for X tiled, and bit</span>
<span class="cm">		 * 9 for Y tiled.  The CPU&#39;s interleave is independent, and</span>
<span class="cm">		 * can be based on either bit 11 (haven&#39;t seen this yet) or</span>
<span class="cm">		 * bit 17 (common).</span>
<span class="cm">		 */</span>
		<span class="n">dcc</span> <span class="o">=</span> <span class="n">I915_READ</span><span class="p">(</span><span class="n">DCC</span><span class="p">);</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">dcc</span> <span class="o">&amp;</span> <span class="n">DCC_ADDRESSING_MODE_MASK</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">DCC_ADDRESSING_MODE_SINGLE_CHANNEL</span>:
		<span class="k">case</span> <span class="n">DCC_ADDRESSING_MODE_DUAL_CHANNEL_ASYMMETRIC</span>:
			<span class="n">swizzle_x</span> <span class="o">=</span> <span class="n">I915_BIT_6_SWIZZLE_NONE</span><span class="p">;</span>
			<span class="n">swizzle_y</span> <span class="o">=</span> <span class="n">I915_BIT_6_SWIZZLE_NONE</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">DCC_ADDRESSING_MODE_DUAL_CHANNEL_INTERLEAVED</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">dcc</span> <span class="o">&amp;</span> <span class="n">DCC_CHANNEL_XOR_DISABLE</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* This is the base swizzling by the GPU for</span>
<span class="cm">				 * tiled buffers.</span>
<span class="cm">				 */</span>
				<span class="n">swizzle_x</span> <span class="o">=</span> <span class="n">I915_BIT_6_SWIZZLE_9_10</span><span class="p">;</span>
				<span class="n">swizzle_y</span> <span class="o">=</span> <span class="n">I915_BIT_6_SWIZZLE_9</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">dcc</span> <span class="o">&amp;</span> <span class="n">DCC_CHANNEL_XOR_BIT_17</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Bit 11 swizzling by the CPU in addition. */</span>
				<span class="n">swizzle_x</span> <span class="o">=</span> <span class="n">I915_BIT_6_SWIZZLE_9_10_11</span><span class="p">;</span>
				<span class="n">swizzle_y</span> <span class="o">=</span> <span class="n">I915_BIT_6_SWIZZLE_9_11</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* Bit 17 swizzling by the CPU in addition. */</span>
				<span class="n">swizzle_x</span> <span class="o">=</span> <span class="n">I915_BIT_6_SWIZZLE_9_10_17</span><span class="p">;</span>
				<span class="n">swizzle_y</span> <span class="o">=</span> <span class="n">I915_BIT_6_SWIZZLE_9_17</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dcc</span> <span class="o">==</span> <span class="mh">0xffffffff</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DRM_ERROR</span><span class="p">(</span><span class="s">&quot;Couldn&#39;t read from MCHBAR.  &quot;</span>
				  <span class="s">&quot;Disabling tiling.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">swizzle_x</span> <span class="o">=</span> <span class="n">I915_BIT_6_SWIZZLE_UNKNOWN</span><span class="p">;</span>
			<span class="n">swizzle_y</span> <span class="o">=</span> <span class="n">I915_BIT_6_SWIZZLE_UNKNOWN</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* The 965, G33, and newer, have a very flexible memory</span>
<span class="cm">		 * configuration.  It will enable dual-channel mode</span>
<span class="cm">		 * (interleaving) on as much memory as it can, and the GPU</span>
<span class="cm">		 * will additionally sometimes enable different bit 6</span>
<span class="cm">		 * swizzling for tiled objects from the CPU.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Here&#39;s what I found on the G965:</span>
<span class="cm">		 *    slot fill         memory size  swizzling</span>
<span class="cm">		 * 0A   0B   1A   1B    1-ch   2-ch</span>
<span class="cm">		 * 512  0    0    0     512    0     O</span>
<span class="cm">		 * 512  0    512  0     16     1008  X</span>
<span class="cm">		 * 512  0    0    512   16     1008  X</span>
<span class="cm">		 * 0    512  0    512   16     1008  X</span>
<span class="cm">		 * 1024 1024 1024 0     2048   1024  O</span>
<span class="cm">		 *</span>
<span class="cm">		 * We could probably detect this based on either the DRB</span>
<span class="cm">		 * matching, which was the case for the swizzling required in</span>
<span class="cm">		 * the table above, or from the 1-ch value being less than</span>
<span class="cm">		 * the minimum size of a rank.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">I915_READ16</span><span class="p">(</span><span class="n">C0DRB3</span><span class="p">)</span> <span class="o">!=</span> <span class="n">I915_READ16</span><span class="p">(</span><span class="n">C1DRB3</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">swizzle_x</span> <span class="o">=</span> <span class="n">I915_BIT_6_SWIZZLE_NONE</span><span class="p">;</span>
			<span class="n">swizzle_y</span> <span class="o">=</span> <span class="n">I915_BIT_6_SWIZZLE_NONE</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">swizzle_x</span> <span class="o">=</span> <span class="n">I915_BIT_6_SWIZZLE_9_10</span><span class="p">;</span>
			<span class="n">swizzle_y</span> <span class="o">=</span> <span class="n">I915_BIT_6_SWIZZLE_9</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">.</span><span class="n">bit_6_swizzle_x</span> <span class="o">=</span> <span class="n">swizzle_x</span><span class="p">;</span>
	<span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">.</span><span class="n">bit_6_swizzle_y</span> <span class="o">=</span> <span class="n">swizzle_y</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Check pitch constriants for all chips &amp; tiling formats */</span>
<span class="k">static</span> <span class="n">bool</span>
<span class="nf">i915_tiling_ok</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">stride</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tiling_mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">tile_width</span><span class="p">;</span>

	<span class="cm">/* Linear is always fine */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tiling_mode</span> <span class="o">==</span> <span class="n">I915_TILING_NONE</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_GEN2</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">tiling_mode</span> <span class="o">==</span> <span class="n">I915_TILING_Y</span> <span class="o">&amp;&amp;</span> <span class="n">HAS_128_BYTE_Y_TILING</span><span class="p">(</span><span class="n">dev</span><span class="p">)))</span>
		<span class="n">tile_width</span> <span class="o">=</span> <span class="mi">128</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">tile_width</span> <span class="o">=</span> <span class="mi">512</span><span class="p">;</span>

	<span class="cm">/* check maximum stride &amp; object size */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">INTEL_INFO</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gen</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* i965 stores the end address of the gtt mapping in the fence</span>
<span class="cm">		 * reg, so dont bother to check the size */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">stride</span> <span class="o">/</span> <span class="mi">128</span> <span class="o">&gt;</span> <span class="n">I965_FENCE_MAX_PITCH_VAL</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">stride</span> <span class="o">&gt;</span> <span class="mi">8192</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">IS_GEN3</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">I830_FENCE_MAX_SIZE_VAL</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">)</span>
				<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">I830_FENCE_MAX_SIZE_VAL</span> <span class="o">&lt;&lt;</span> <span class="mi">19</span><span class="p">)</span>
				<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* 965+ just needs multiples of tile width */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">INTEL_INFO</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gen</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">stride</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">tile_width</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Pre-965 needs power of two tile widths */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">stride</span> <span class="o">&lt;</span> <span class="n">tile_width</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">stride</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">stride</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Is the current GTT allocation valid for the change in tiling? */</span>
<span class="k">static</span> <span class="n">bool</span>
<span class="nf">i915_gem_object_fence_ok</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_i915_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tiling_mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">size</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tiling_mode</span> <span class="o">==</span> <span class="n">I915_TILING_NONE</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">INTEL_INFO</span><span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">dev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gen</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">INTEL_INFO</span><span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">dev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gen</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">gtt_offset</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">I915_FENCE_START_MASK</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">gtt_offset</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">I830_FENCE_START_MASK</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Previous chips need to be aligned to the size of the smallest</span>
<span class="cm">	 * fence register that can contain the object.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">INTEL_INFO</span><span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">dev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gen</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>
		<span class="n">size</span> <span class="o">=</span> <span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">size</span> <span class="o">=</span> <span class="mi">512</span><span class="o">*</span><span class="mi">1024</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">size</span><span class="p">)</span>
		<span class="n">size</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">gtt_space</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">!=</span> <span class="n">size</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">gtt_offset</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Sets the tiling mode of an object, returning the required swizzling of</span>
<span class="cm"> * bit 6 of addresses in the object.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">i915_gem_set_tiling</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
		   <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_i915_gem_set_tiling</span> <span class="o">*</span><span class="n">args</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">drm_i915_private_t</span> <span class="o">*</span><span class="n">dev_priv</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_i915_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">obj</span> <span class="o">=</span> <span class="n">to_intel_bo</span><span class="p">(</span><span class="n">drm_gem_object_lookup</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i915_tiling_ok</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
			    <span class="n">args</span><span class="o">-&gt;</span><span class="n">stride</span><span class="p">,</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">size</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">tiling_mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">drm_gem_object_unreference_unlocked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">pin_count</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">drm_gem_object_unreference_unlocked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">tiling_mode</span> <span class="o">==</span> <span class="n">I915_TILING_NONE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">args</span><span class="o">-&gt;</span><span class="n">swizzle_mode</span> <span class="o">=</span> <span class="n">I915_BIT_6_SWIZZLE_NONE</span><span class="p">;</span>
		<span class="n">args</span><span class="o">-&gt;</span><span class="n">stride</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">tiling_mode</span> <span class="o">==</span> <span class="n">I915_TILING_X</span><span class="p">)</span>
			<span class="n">args</span><span class="o">-&gt;</span><span class="n">swizzle_mode</span> <span class="o">=</span> <span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">.</span><span class="n">bit_6_swizzle_x</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">args</span><span class="o">-&gt;</span><span class="n">swizzle_mode</span> <span class="o">=</span> <span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">.</span><span class="n">bit_6_swizzle_y</span><span class="p">;</span>

		<span class="cm">/* Hide bit 17 swizzling from the user.  This prevents old Mesa</span>
<span class="cm">		 * from aborting the application on sw fallbacks to bit 17,</span>
<span class="cm">		 * and we use the pread/pwrite bit17 paths to swizzle for it.</span>
<span class="cm">		 * If there was a user that was relying on the swizzle</span>
<span class="cm">		 * information for drm_intel_bo_map()ed reads/writes this would</span>
<span class="cm">		 * break it, but we don&#39;t have any of those.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">swizzle_mode</span> <span class="o">==</span> <span class="n">I915_BIT_6_SWIZZLE_9_17</span><span class="p">)</span>
			<span class="n">args</span><span class="o">-&gt;</span><span class="n">swizzle_mode</span> <span class="o">=</span> <span class="n">I915_BIT_6_SWIZZLE_9</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">swizzle_mode</span> <span class="o">==</span> <span class="n">I915_BIT_6_SWIZZLE_9_10_17</span><span class="p">)</span>
			<span class="n">args</span><span class="o">-&gt;</span><span class="n">swizzle_mode</span> <span class="o">=</span> <span class="n">I915_BIT_6_SWIZZLE_9_10</span><span class="p">;</span>

		<span class="cm">/* If we can&#39;t handle the swizzling, make it untiled. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">swizzle_mode</span> <span class="o">==</span> <span class="n">I915_BIT_6_SWIZZLE_UNKNOWN</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">args</span><span class="o">-&gt;</span><span class="n">tiling_mode</span> <span class="o">=</span> <span class="n">I915_TILING_NONE</span><span class="p">;</span>
			<span class="n">args</span><span class="o">-&gt;</span><span class="n">swizzle_mode</span> <span class="o">=</span> <span class="n">I915_BIT_6_SWIZZLE_NONE</span><span class="p">;</span>
			<span class="n">args</span><span class="o">-&gt;</span><span class="n">stride</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">struct_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">tiling_mode</span> <span class="o">!=</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">tiling_mode</span> <span class="o">||</span>
	    <span class="n">args</span><span class="o">-&gt;</span><span class="n">stride</span> <span class="o">!=</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">stride</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* We need to rebind the object if its current allocation</span>
<span class="cm">		 * no longer meets the alignment restrictions for its new</span>
<span class="cm">		 * tiling mode. Otherwise we can just leave it alone, but</span>
<span class="cm">		 * need to ensure that any fence register is updated before</span>
<span class="cm">		 * the next fenced (either through the GTT or by the BLT unit</span>
<span class="cm">		 * on older GPUs) access.</span>
<span class="cm">		 *</span>
<span class="cm">		 * After updating the tiling parameters, we then flag whether</span>
<span class="cm">		 * we need to update an associated fence register. Note this</span>
<span class="cm">		 * has to also include the unfenced register the GPU uses</span>
<span class="cm">		 * whilst executing a fenced command for an untiled object.</span>
<span class="cm">		 */</span>

		<span class="n">obj</span><span class="o">-&gt;</span><span class="n">map_and_fenceable</span> <span class="o">=</span>
			<span class="n">obj</span><span class="o">-&gt;</span><span class="n">gtt_space</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span>
			<span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">gtt_offset</span> <span class="o">+</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">.</span><span class="n">gtt_mappable_end</span> <span class="o">&amp;&amp;</span>
			 <span class="n">i915_gem_object_fence_ok</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">tiling_mode</span><span class="p">));</span>

		<span class="cm">/* Rebind if we need a change of alignment */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">map_and_fenceable</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u32</span> <span class="n">unfenced_alignment</span> <span class="o">=</span>
				<span class="n">i915_gem_get_unfenced_gtt_alignment</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
								    <span class="n">obj</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">size</span><span class="p">,</span>
								    <span class="n">args</span><span class="o">-&gt;</span><span class="n">tiling_mode</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">gtt_offset</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">unfenced_alignment</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">i915_gem_object_unbind</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">obj</span><span class="o">-&gt;</span><span class="n">fence_dirty</span> <span class="o">=</span>
				<span class="n">obj</span><span class="o">-&gt;</span><span class="n">fenced_gpu_access</span> <span class="o">||</span>
				<span class="n">obj</span><span class="o">-&gt;</span><span class="n">fence_reg</span> <span class="o">!=</span> <span class="n">I915_FENCE_REG_NONE</span><span class="p">;</span>

			<span class="n">obj</span><span class="o">-&gt;</span><span class="n">tiling_mode</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">tiling_mode</span><span class="p">;</span>
			<span class="n">obj</span><span class="o">-&gt;</span><span class="n">stride</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">stride</span><span class="p">;</span>

			<span class="cm">/* Force the fence to be reacquired for GTT access */</span>
			<span class="n">i915_gem_release_mmap</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* we have to maintain this existing ABI... */</span>
	<span class="n">args</span><span class="o">-&gt;</span><span class="n">stride</span> <span class="o">=</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">stride</span><span class="p">;</span>
	<span class="n">args</span><span class="o">-&gt;</span><span class="n">tiling_mode</span> <span class="o">=</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">tiling_mode</span><span class="p">;</span>
	<span class="n">drm_gem_object_unreference</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">struct_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Returns the current tiling mode and required bit 6 swizzling for the object.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">i915_gem_get_tiling</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
		   <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_i915_gem_get_tiling</span> <span class="o">*</span><span class="n">args</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">drm_i915_private_t</span> <span class="o">*</span><span class="n">dev_priv</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_i915_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">;</span>

	<span class="n">obj</span> <span class="o">=</span> <span class="n">to_intel_bo</span><span class="p">(</span><span class="n">drm_gem_object_lookup</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">struct_mutex</span><span class="p">);</span>

	<span class="n">args</span><span class="o">-&gt;</span><span class="n">tiling_mode</span> <span class="o">=</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">tiling_mode</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">tiling_mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">I915_TILING_X</span>:
		<span class="n">args</span><span class="o">-&gt;</span><span class="n">swizzle_mode</span> <span class="o">=</span> <span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">.</span><span class="n">bit_6_swizzle_x</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">I915_TILING_Y</span>:
		<span class="n">args</span><span class="o">-&gt;</span><span class="n">swizzle_mode</span> <span class="o">=</span> <span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">.</span><span class="n">bit_6_swizzle_y</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">I915_TILING_NONE</span>:
		<span class="n">args</span><span class="o">-&gt;</span><span class="n">swizzle_mode</span> <span class="o">=</span> <span class="n">I915_BIT_6_SWIZZLE_NONE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">DRM_ERROR</span><span class="p">(</span><span class="s">&quot;unknown tiling mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Hide bit 17 from the user -- see comment in i915_gem_set_tiling */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">swizzle_mode</span> <span class="o">==</span> <span class="n">I915_BIT_6_SWIZZLE_9_17</span><span class="p">)</span>
		<span class="n">args</span><span class="o">-&gt;</span><span class="n">swizzle_mode</span> <span class="o">=</span> <span class="n">I915_BIT_6_SWIZZLE_9</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">swizzle_mode</span> <span class="o">==</span> <span class="n">I915_BIT_6_SWIZZLE_9_10_17</span><span class="p">)</span>
		<span class="n">args</span><span class="o">-&gt;</span><span class="n">swizzle_mode</span> <span class="o">=</span> <span class="n">I915_BIT_6_SWIZZLE_9_10</span><span class="p">;</span>

	<span class="n">drm_gem_object_unreference</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">struct_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Swap every 64 bytes of this page around, to account for it having a new</span>
<span class="cm"> * bit 17 of its physical address and therefore being interpreted differently</span>
<span class="cm"> * by the GPU.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">i915_gem_swizzle_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">temp</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">vaddr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">vaddr</span> <span class="o">=</span> <span class="n">kmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PAGE_SIZE</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">128</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vaddr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">64</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vaddr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">vaddr</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">64</span><span class="p">],</span> <span class="mi">64</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vaddr</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">64</span><span class="p">],</span> <span class="n">temp</span><span class="p">,</span> <span class="mi">64</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">kunmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">i915_gem_object_do_bit_17_swizzle</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_i915_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">page_count</span> <span class="o">=</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">bit_17</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">page_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="n">new_bit_17</span> <span class="o">=</span> <span class="n">page_to_phys</span><span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&gt;&gt;</span> <span class="mi">17</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">new_bit_17</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span> <span class="o">!=</span>
		    <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">bit_17</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">i915_gem_swizzle_page</span><span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">set_page_dirty</span><span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">i915_gem_object_save_bit_17_swizzle</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_i915_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">page_count</span> <span class="o">=</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">bit_17</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">obj</span><span class="o">-&gt;</span><span class="n">bit_17</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">BITS_TO_LONGS</span><span class="p">(</span><span class="n">page_count</span><span class="p">)</span> <span class="o">*</span>
					   <span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">bit_17</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DRM_ERROR</span><span class="p">(</span><span class="s">&quot;Failed to allocate memory for bit 17 &quot;</span>
				  <span class="s">&quot;record</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">page_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page_to_phys</span><span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">17</span><span class="p">))</span>
			<span class="n">__set_bit</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">bit_17</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">__clear_bit</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">bit_17</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
