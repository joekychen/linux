<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › gpu › drm › drm_irq.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>drm_irq.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/**</span>
<span class="cm"> * \file drm_irq.c</span>
<span class="cm"> * IRQ support</span>
<span class="cm"> *</span>
<span class="cm"> * \author Rickard E. (Rik) Faith &lt;faith@valinux.com&gt;</span>
<span class="cm"> * \author Gareth Hughes &lt;gareth@valinux.com&gt;</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Created: Fri Mar 19 14:30:16 1999 by faith@valinux.com</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright 1999, 2000 Precision Insight, Inc., Cedar Park, Texas.</span>
<span class="cm"> * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.</span>
<span class="cm"> * All Rights Reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * Permission is hereby granted, free of charge, to any person obtaining a</span>
<span class="cm"> * copy of this software and associated documentation files (the &quot;Software&quot;),</span>
<span class="cm"> * to deal in the Software without restriction, including without limitation</span>
<span class="cm"> * the rights to use, copy, modify, merge, publish, distribute, sublicense,</span>
<span class="cm"> * and/or sell copies of the Software, and to permit persons to whom the</span>
<span class="cm"> * Software is furnished to do so, subject to the following conditions:</span>
<span class="cm"> *</span>
<span class="cm"> * The above copyright notice and this permission notice (including the next</span>
<span class="cm"> * paragraph) shall be included in all copies or substantial portions of the</span>
<span class="cm"> * Software.</span>
<span class="cm"> *</span>
<span class="cm"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span>
<span class="cm"> * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL</span>
<span class="cm"> * VA LINUX SYSTEMS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR</span>
<span class="cm"> * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,</span>
<span class="cm"> * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR</span>
<span class="cm"> * OTHER DEALINGS IN THE SOFTWARE.</span>
<span class="cm"> */</span>

<span class="cp">#include &quot;drmP.h&quot;</span>
<span class="cp">#include &quot;drm_trace.h&quot;</span>

<span class="cp">#include &lt;linux/interrupt.h&gt;	</span><span class="cm">/* For task queue support */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>

<span class="cp">#include &lt;linux/vgaarb.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>

<span class="cm">/* Access macro for slots in vblank timestamp ringbuffer. */</span>
<span class="cp">#define vblanktimestamp(dev, crtc, count) ( \</span>
<span class="cp">	(dev)-&gt;_vblank_time[(crtc) * DRM_VBLANKTIME_RBSIZE + \</span>
<span class="cp">	((count) % DRM_VBLANKTIME_RBSIZE)])</span>

<span class="cm">/* Retry timestamp calculation up to 3 times to satisfy</span>
<span class="cm"> * drm_timestamp_precision before giving up.</span>
<span class="cm"> */</span>
<span class="cp">#define DRM_TIMESTAMP_MAXRETRIES 3</span>

<span class="cm">/* Threshold in nanoseconds for detection of redundant</span>
<span class="cm"> * vblank irq in drm_handle_vblank(). 1 msec should be ok.</span>
<span class="cm"> */</span>
<span class="cp">#define DRM_REDUNDANT_VBLIRQ_THRESH_NS 1000000</span>

<span class="cm">/**</span>
<span class="cm"> * Get interrupt from bus id.</span>
<span class="cm"> *</span>
<span class="cm"> * \param inode device inode.</span>
<span class="cm"> * \param file_priv DRM file private.</span>
<span class="cm"> * \param cmd command.</span>
<span class="cm"> * \param arg user argument, pointing to a drm_irq_busid structure.</span>
<span class="cm"> * \return zero on success or a negative number on failure.</span>
<span class="cm"> *</span>
<span class="cm"> * Finds the PCI device with the specified bus id and gets its IRQ number.</span>
<span class="cm"> * This IOCTL is deprecated, and will now return EINVAL for any busid not equal</span>
<span class="cm"> * to that of the device that this DRM instance attached to.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">drm_irq_by_busid</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_irq_busid</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">irq_by_busid</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">drm_core_check_feature</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DRIVER_HAVE_IRQ</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">irq_by_busid</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Clear vblank timestamp buffer for a crtc.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">clear_vblank_timestamps</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">crtc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">_vblank_time</span><span class="p">[</span><span class="n">crtc</span> <span class="o">*</span> <span class="n">DRM_VBLANKTIME_RBSIZE</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span>
		<span class="n">DRM_VBLANKTIME_RBSIZE</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">timeval</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Disable vblank irq&#39;s on crtc, make sure that last vblank count</span>
<span class="cm"> * of hardware and corresponding consistent software vblank counter</span>
<span class="cm"> * are preserved, even if there are any spurious vblank irq&#39;s after</span>
<span class="cm"> * disable.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">vblank_disable_and_save</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">crtc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irqflags</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">vblcount</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">diff_ns</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">vblrc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timeval</span> <span class="n">tvblank</span><span class="p">;</span>

	<span class="cm">/* Prevent vblank irq processing while disabling vblank irqs,</span>
<span class="cm">	 * so no updates of timestamps or count can happen after we&#39;ve</span>
<span class="cm">	 * disabled. Needed to prevent races in case of delayed irq&#39;s.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vblank_time_lock</span><span class="p">,</span> <span class="n">irqflags</span><span class="p">);</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">disable_vblank</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">crtc</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">vblank_enabled</span><span class="p">[</span><span class="n">crtc</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* No further vblank irq&#39;s will be processed after</span>
<span class="cm">	 * this point. Get current hardware vblank count and</span>
<span class="cm">	 * vblank timestamp, repeat until they are consistent.</span>
<span class="cm">	 *</span>
<span class="cm">	 * FIXME: There is still a race condition here and in</span>
<span class="cm">	 * drm_update_vblank_count() which can cause off-by-one</span>
<span class="cm">	 * reinitialization of software vblank counter. If gpu</span>
<span class="cm">	 * vblank counter doesn&#39;t increment exactly at the leading</span>
<span class="cm">	 * edge of a vblank interval, then we can lose 1 count if</span>
<span class="cm">	 * we happen to execute between start of vblank and the</span>
<span class="cm">	 * delayed gpu counter increment.</span>
<span class="cm">	 */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">last_vblank</span><span class="p">[</span><span class="n">crtc</span><span class="p">]</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">get_vblank_counter</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">crtc</span><span class="p">);</span>
		<span class="n">vblrc</span> <span class="o">=</span> <span class="n">drm_get_last_vbltimestamp</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">crtc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tvblank</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">last_vblank</span><span class="p">[</span><span class="n">crtc</span><span class="p">]</span> <span class="o">!=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">get_vblank_counter</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">crtc</span><span class="p">));</span>

	<span class="cm">/* Compute time difference to stored timestamp of last vblank</span>
<span class="cm">	 * as updated by last invocation of drm_handle_vblank() in vblank irq.</span>
<span class="cm">	 */</span>
	<span class="n">vblcount</span> <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">_vblank_count</span><span class="p">[</span><span class="n">crtc</span><span class="p">]);</span>
	<span class="n">diff_ns</span> <span class="o">=</span> <span class="n">timeval_to_ns</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tvblank</span><span class="p">)</span> <span class="o">-</span>
		  <span class="n">timeval_to_ns</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vblanktimestamp</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">crtc</span><span class="p">,</span> <span class="n">vblcount</span><span class="p">));</span>

	<span class="cm">/* If there is at least 1 msec difference between the last stored</span>
<span class="cm">	 * timestamp and tvblank, then we are currently executing our</span>
<span class="cm">	 * disable inside a new vblank interval, the tvblank timestamp</span>
<span class="cm">	 * corresponds to this new vblank interval and the irq handler</span>
<span class="cm">	 * for this vblank didn&#39;t run yet and won&#39;t run due to our disable.</span>
<span class="cm">	 * Therefore we need to do the job of drm_handle_vblank() and</span>
<span class="cm">	 * increment the vblank counter by one to account for this vblank.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Skip this step if there isn&#39;t any high precision timestamp</span>
<span class="cm">	 * available. In that case we can&#39;t account for this and just</span>
<span class="cm">	 * hope for the best.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">vblrc</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">abs64</span><span class="p">(</span><span class="n">diff_ns</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1000000</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">_vblank_count</span><span class="p">[</span><span class="n">crtc</span><span class="p">]);</span>
		<span class="n">smp_mb__after_atomic_inc</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="cm">/* Invalidate all timestamps while vblank irq&#39;s are off. */</span>
	<span class="n">clear_vblank_timestamps</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">crtc</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vblank_time_lock</span><span class="p">,</span> <span class="n">irqflags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vblank_disable_fn</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irqflags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vblank_disable_allowed</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">num_crtcs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vbl_lock</span><span class="p">,</span> <span class="n">irqflags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vblank_refcount</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
		    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">vblank_enabled</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">DRM_DEBUG</span><span class="p">(</span><span class="s">&quot;disabling vblank on crtc %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">vblank_disable_and_save</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vbl_lock</span><span class="p">,</span> <span class="n">irqflags</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">drm_vblank_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Bail if the driver didn&#39;t call drm_vblank_init() */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">num_crtcs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vblank_disable_timer</span><span class="p">);</span>

	<span class="n">vblank_disable_fn</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vbl_queue</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">_vblank_count</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vblank_refcount</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vblank_enabled</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">last_vblank</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">last_vblank_wait</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vblank_inmodeset</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">_vblank_time</span><span class="p">);</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">num_crtcs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">drm_vblank_cleanup</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">drm_vblank_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num_crtcs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">setup_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vblank_disable_timer</span><span class="p">,</span> <span class="n">vblank_disable_fn</span><span class="p">,</span>
		    <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vbl_lock</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vblank_time_lock</span><span class="p">);</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">num_crtcs</span> <span class="o">=</span> <span class="n">num_crtcs</span><span class="p">;</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">vbl_queue</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">wait_queue_head_t</span><span class="p">)</span> <span class="o">*</span> <span class="n">num_crtcs</span><span class="p">,</span>
				 <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vbl_queue</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">_vblank_count</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">atomic_t</span><span class="p">)</span> <span class="o">*</span> <span class="n">num_crtcs</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">_vblank_count</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">vblank_refcount</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">atomic_t</span><span class="p">)</span> <span class="o">*</span> <span class="n">num_crtcs</span><span class="p">,</span>
				       <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vblank_refcount</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">vblank_enabled</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">num_crtcs</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vblank_enabled</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">last_vblank</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">num_crtcs</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">last_vblank</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">last_vblank_wait</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">num_crtcs</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">last_vblank_wait</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">vblank_inmodeset</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">num_crtcs</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vblank_inmodeset</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">_vblank_time</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">num_crtcs</span> <span class="o">*</span> <span class="n">DRM_VBLANKTIME_RBSIZE</span><span class="p">,</span>
				    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">timeval</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">_vblank_time</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">DRM_INFO</span><span class="p">(</span><span class="s">&quot;Supports vblank timestamp caching Rev 1 (10.10.2010).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Driver specific high-precision vblank timestamping supported? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">get_vblank_timestamp</span><span class="p">)</span>
		<span class="n">DRM_INFO</span><span class="p">(</span><span class="s">&quot;Driver supports precise vblank timestamp query.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">DRM_INFO</span><span class="p">(</span><span class="s">&quot;No driver support for vblank timestamp query.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Zero per-crtc vblank stuff */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_crtcs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vbl_queue</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">_vblank_count</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vblank_refcount</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">vblank_disable_allowed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err:</span>
	<span class="n">drm_vblank_cleanup</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">drm_vblank_init</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">drm_irq_vgaarb_nokms</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">cookie</span><span class="p">,</span> <span class="n">bool</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">cookie</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">vgaarb_irq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">vgaarb_irq</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq_enabled</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">irq_uninstall</span><span class="p">)</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">irq_uninstall</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">irq_preinstall</span><span class="p">)</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">irq_preinstall</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">irq_postinstall</span><span class="p">)</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">irq_postinstall</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Install IRQ handler.</span>
<span class="cm"> *</span>
<span class="cm"> * \param dev DRM device.</span>
<span class="cm"> *</span>
<span class="cm"> * Initializes the IRQ related data. Installs the handler, calling the driver</span>
<span class="cm"> * \c irq_preinstall() and \c irq_postinstall() functions</span>
<span class="cm"> * before and after the installation.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">drm_irq_install</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sh_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">irqname</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">drm_core_check_feature</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DRIVER_HAVE_IRQ</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">drm_dev_to_irq</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">struct_mutex</span><span class="p">);</span>

	<span class="cm">/* Driver must have been initialized */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_private</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">struct_mutex</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq_enabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">struct_mutex</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq_enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">struct_mutex</span><span class="p">);</span>

	<span class="n">DRM_DEBUG</span><span class="p">(</span><span class="s">&quot;irq=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">drm_dev_to_irq</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>

	<span class="cm">/* Before installing handler */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">irq_preinstall</span><span class="p">)</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">irq_preinstall</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* Install handler */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">drm_core_check_feature</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DRIVER_IRQ_SHARED</span><span class="p">))</span>
		<span class="n">sh_flags</span> <span class="o">=</span> <span class="n">IRQF_SHARED</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devname</span><span class="p">)</span>
		<span class="n">irqname</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">devname</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">irqname</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">drm_dev_to_irq</span><span class="p">(</span><span class="n">dev</span><span class="p">),</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">irq_handler</span><span class="p">,</span>
			  <span class="n">sh_flags</span><span class="p">,</span> <span class="n">irqname</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">struct_mutex</span><span class="p">);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">struct_mutex</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">drm_core_check_feature</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DRIVER_MODESET</span><span class="p">))</span>
		<span class="n">vga_client_register</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">dev</span><span class="p">,</span> <span class="n">drm_irq_vgaarb_nokms</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="cm">/* After installing handler */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">irq_postinstall</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">irq_postinstall</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">struct_mutex</span><span class="p">);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">struct_mutex</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">drm_core_check_feature</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DRIVER_MODESET</span><span class="p">))</span>
			<span class="n">vga_client_register</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">drm_dev_to_irq</span><span class="p">(</span><span class="n">dev</span><span class="p">),</span> <span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">drm_irq_install</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Uninstall the IRQ handler.</span>
<span class="cm"> *</span>
<span class="cm"> * \param dev DRM device.</span>
<span class="cm"> *</span>
<span class="cm"> * Calls the driver&#39;s \c irq_uninstall() function, and stops the irq.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">drm_irq_uninstall</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irqflags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">irq_enabled</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">drm_core_check_feature</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DRIVER_HAVE_IRQ</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">struct_mutex</span><span class="p">);</span>
	<span class="n">irq_enabled</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq_enabled</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">struct_mutex</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Wake up any waiters so they don&#39;t hang.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">num_crtcs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vbl_lock</span><span class="p">,</span> <span class="n">irqflags</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">num_crtcs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DRM_WAKEUP</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vbl_queue</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">vblank_enabled</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">last_vblank</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">get_vblank_counter</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vbl_lock</span><span class="p">,</span> <span class="n">irqflags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">irq_enabled</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">DRM_DEBUG</span><span class="p">(</span><span class="s">&quot;irq=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">drm_dev_to_irq</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">drm_core_check_feature</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DRIVER_MODESET</span><span class="p">))</span>
		<span class="n">vga_client_register</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">irq_uninstall</span><span class="p">)</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">irq_uninstall</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">free_irq</span><span class="p">(</span><span class="n">drm_dev_to_irq</span><span class="p">(</span><span class="n">dev</span><span class="p">),</span> <span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">drm_irq_uninstall</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * IRQ control ioctl.</span>
<span class="cm"> *</span>
<span class="cm"> * \param inode device inode.</span>
<span class="cm"> * \param file_priv DRM file private.</span>
<span class="cm"> * \param cmd command.</span>
<span class="cm"> * \param arg user argument, pointing to a drm_control structure.</span>
<span class="cm"> * \return zero on success or a negative number on failure.</span>
<span class="cm"> *</span>
<span class="cm"> * Calls irq_install() or irq_uninstall() according to \p arg.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">drm_control</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_control</span> <span class="o">*</span><span class="n">ctl</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

	<span class="cm">/* if we haven&#39;t irq we fallback for compatibility reasons -</span>
<span class="cm">	 * this used to be a separate function in drm_dma.h</span>
<span class="cm">	 */</span>


	<span class="k">switch</span> <span class="p">(</span><span class="n">ctl</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">DRM_INST_HANDLER</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">drm_core_check_feature</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DRIVER_HAVE_IRQ</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">drm_core_check_feature</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DRIVER_MODESET</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">if_version</span> <span class="o">&lt;</span> <span class="n">DRM_IF_VERSION</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">ctl</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">!=</span> <span class="n">drm_dev_to_irq</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">drm_irq_install</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">DRM_UNINST_HANDLER</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">drm_core_check_feature</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DRIVER_HAVE_IRQ</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">drm_core_check_feature</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DRIVER_MODESET</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">drm_irq_uninstall</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * drm_calc_timestamping_constants - Calculate and</span>
<span class="cm"> * store various constants which are later needed by</span>
<span class="cm"> * vblank and swap-completion timestamping, e.g, by</span>
<span class="cm"> * drm_calc_vbltimestamp_from_scanoutpos().</span>
<span class="cm"> * They are derived from crtc&#39;s true scanout timing,</span>
<span class="cm"> * so they take things like panel scaling or other</span>
<span class="cm"> * adjustments into account.</span>
<span class="cm"> *</span>
<span class="cm"> * @crtc drm_crtc whose timestamp constants should be updated.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">drm_calc_timestamping_constants</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_crtc</span> <span class="o">*</span><span class="n">crtc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s64</span> <span class="n">linedur_ns</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pixeldur_ns</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">framedur_ns</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">dotclock</span><span class="p">;</span>

	<span class="cm">/* Dot clock in Hz: */</span>
	<span class="n">dotclock</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="n">crtc</span><span class="o">-&gt;</span><span class="n">hwmode</span><span class="p">.</span><span class="n">clock</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">;</span>

	<span class="cm">/* Fields of interlaced scanout modes are only halve a frame duration.</span>
<span class="cm">	 * Double the dotclock to get halve the frame-/line-/pixelduration.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">crtc</span><span class="o">-&gt;</span><span class="n">hwmode</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DRM_MODE_FLAG_INTERLACE</span><span class="p">)</span>
		<span class="n">dotclock</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>

	<span class="cm">/* Valid dotclock? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dotclock</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Convert scanline length in pixels and video dot clock to</span>
<span class="cm">		 * line duration, frame duration and pixel duration in</span>
<span class="cm">		 * nanoseconds:</span>
<span class="cm">		 */</span>
		<span class="n">pixeldur_ns</span> <span class="o">=</span> <span class="p">(</span><span class="n">s64</span><span class="p">)</span> <span class="n">div64_u64</span><span class="p">(</span><span class="mi">1000000000</span><span class="p">,</span> <span class="n">dotclock</span><span class="p">);</span>
		<span class="n">linedur_ns</span>  <span class="o">=</span> <span class="p">(</span><span class="n">s64</span><span class="p">)</span> <span class="n">div64_u64</span><span class="p">(((</span><span class="n">u64</span><span class="p">)</span> <span class="n">crtc</span><span class="o">-&gt;</span><span class="n">hwmode</span><span class="p">.</span><span class="n">crtc_htotal</span> <span class="o">*</span>
					      <span class="mi">1000000000</span><span class="p">),</span> <span class="n">dotclock</span><span class="p">);</span>
		<span class="n">framedur_ns</span> <span class="o">=</span> <span class="p">(</span><span class="n">s64</span><span class="p">)</span> <span class="n">crtc</span><span class="o">-&gt;</span><span class="n">hwmode</span><span class="p">.</span><span class="n">crtc_vtotal</span> <span class="o">*</span> <span class="n">linedur_ns</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">DRM_ERROR</span><span class="p">(</span><span class="s">&quot;crtc %d: Can&#39;t calculate constants, dotclock = 0!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">crtc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">id</span><span class="p">);</span>

	<span class="n">crtc</span><span class="o">-&gt;</span><span class="n">pixeldur_ns</span> <span class="o">=</span> <span class="n">pixeldur_ns</span><span class="p">;</span>
	<span class="n">crtc</span><span class="o">-&gt;</span><span class="n">linedur_ns</span>  <span class="o">=</span> <span class="n">linedur_ns</span><span class="p">;</span>
	<span class="n">crtc</span><span class="o">-&gt;</span><span class="n">framedur_ns</span> <span class="o">=</span> <span class="n">framedur_ns</span><span class="p">;</span>

	<span class="n">DRM_DEBUG</span><span class="p">(</span><span class="s">&quot;crtc %d: hwmode: htotal %d, vtotal %d, vdisplay %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">crtc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="n">crtc</span><span class="o">-&gt;</span><span class="n">hwmode</span><span class="p">.</span><span class="n">crtc_htotal</span><span class="p">,</span>
		  <span class="n">crtc</span><span class="o">-&gt;</span><span class="n">hwmode</span><span class="p">.</span><span class="n">crtc_vtotal</span><span class="p">,</span> <span class="n">crtc</span><span class="o">-&gt;</span><span class="n">hwmode</span><span class="p">.</span><span class="n">crtc_vdisplay</span><span class="p">);</span>
	<span class="n">DRM_DEBUG</span><span class="p">(</span><span class="s">&quot;crtc %d: clock %d kHz framedur %d linedur %d, pixeldur %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">crtc</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">dotclock</span><span class="o">/</span><span class="mi">1000</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">framedur_ns</span><span class="p">,</span>
		  <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">linedur_ns</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">pixeldur_ns</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">drm_calc_timestamping_constants</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * drm_calc_vbltimestamp_from_scanoutpos - helper routine for kms</span>
<span class="cm"> * drivers. Implements calculation of exact vblank timestamps from</span>
<span class="cm"> * given drm_display_mode timings and current video scanout position</span>
<span class="cm"> * of a crtc. This can be called from within get_vblank_timestamp()</span>
<span class="cm"> * implementation of a kms driver to implement the actual timestamping.</span>
<span class="cm"> *</span>
<span class="cm"> * Should return timestamps conforming to the OML_sync_control OpenML</span>
<span class="cm"> * extension specification. The timestamp corresponds to the end of</span>
<span class="cm"> * the vblank interval, aka start of scanout of topmost-leftmost display</span>
<span class="cm"> * pixel in the following video frame.</span>
<span class="cm"> *</span>
<span class="cm"> * Requires support for optional dev-&gt;driver-&gt;get_scanout_position()</span>
<span class="cm"> * in kms driver, plus a bit of setup code to provide a drm_display_mode</span>
<span class="cm"> * that corresponds to the true scanout timing.</span>
<span class="cm"> *</span>
<span class="cm"> * The current implementation only handles standard video modes. It</span>
<span class="cm"> * returns as no operation if a doublescan or interlaced video mode is</span>
<span class="cm"> * active. Higher level code is expected to handle this.</span>
<span class="cm"> *</span>
<span class="cm"> * @dev: DRM device.</span>
<span class="cm"> * @crtc: Which crtc&#39;s vblank timestamp to retrieve.</span>
<span class="cm"> * @max_error: Desired maximum allowable error in timestamps (nanosecs).</span>
<span class="cm"> *             On return contains true maximum error of timestamp.</span>
<span class="cm"> * @vblank_time: Pointer to struct timeval which should receive the timestamp.</span>
<span class="cm"> * @flags: Flags to pass to driver:</span>
<span class="cm"> *         0 = Default.</span>
<span class="cm"> *         DRM_CALLED_FROM_VBLIRQ = If function is called from vbl irq handler.</span>
<span class="cm"> * @refcrtc: drm_crtc* of crtc which defines scanout timing.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns negative value on error, failure or if not supported in current</span>
<span class="cm"> * video mode:</span>
<span class="cm"> *</span>
<span class="cm"> * -EINVAL   - Invalid crtc.</span>
<span class="cm"> * -EAGAIN   - Temporary unavailable, e.g., called before initial modeset.</span>
<span class="cm"> * -ENOTSUPP - Function not supported in current display mode.</span>
<span class="cm"> * -EIO      - Failed, e.g., due to failed scanout position query.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns or&#39;ed positive status flags on success:</span>
<span class="cm"> *</span>
<span class="cm"> * DRM_VBLANKTIME_SCANOUTPOS_METHOD - Signal this method used for timestamping.</span>
<span class="cm"> * DRM_VBLANKTIME_INVBL - Timestamp taken while scanout was in vblank interval.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">drm_calc_vbltimestamp_from_scanoutpos</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">crtc</span><span class="p">,</span>
					  <span class="kt">int</span> <span class="o">*</span><span class="n">max_error</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">timeval</span> <span class="o">*</span><span class="n">vblank_time</span><span class="p">,</span>
					  <span class="kt">unsigned</span> <span class="n">flags</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">drm_crtc</span> <span class="o">*</span><span class="n">refcrtc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">timeval</span> <span class="n">stime</span><span class="p">,</span> <span class="n">raw_time</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="n">mode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">vbl_status</span><span class="p">,</span> <span class="n">vtotal</span><span class="p">,</span> <span class="n">vdisplay</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">vpos</span><span class="p">,</span> <span class="n">hpos</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">framedur_ns</span><span class="p">,</span> <span class="n">linedur_ns</span><span class="p">,</span> <span class="n">pixeldur_ns</span><span class="p">,</span> <span class="n">delta_ns</span><span class="p">,</span> <span class="n">duration_ns</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">invbl</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">crtc</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">crtc</span> <span class="o">&gt;=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">num_crtcs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DRM_ERROR</span><span class="p">(</span><span class="s">&quot;Invalid crtc %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">crtc</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Scanout position query not supported? Should not happen. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">get_scanout_position</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DRM_ERROR</span><span class="p">(</span><span class="s">&quot;Called from driver w/o get_scanout_position()!?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mode</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">refcrtc</span><span class="o">-&gt;</span><span class="n">hwmode</span><span class="p">;</span>
	<span class="n">vtotal</span> <span class="o">=</span> <span class="n">mode</span><span class="o">-&gt;</span><span class="n">crtc_vtotal</span><span class="p">;</span>
	<span class="n">vdisplay</span> <span class="o">=</span> <span class="n">mode</span><span class="o">-&gt;</span><span class="n">crtc_vdisplay</span><span class="p">;</span>

	<span class="cm">/* Durations of frames, lines, pixels in nanoseconds. */</span>
	<span class="n">framedur_ns</span> <span class="o">=</span> <span class="n">refcrtc</span><span class="o">-&gt;</span><span class="n">framedur_ns</span><span class="p">;</span>
	<span class="n">linedur_ns</span>  <span class="o">=</span> <span class="n">refcrtc</span><span class="o">-&gt;</span><span class="n">linedur_ns</span><span class="p">;</span>
	<span class="n">pixeldur_ns</span> <span class="o">=</span> <span class="n">refcrtc</span><span class="o">-&gt;</span><span class="n">pixeldur_ns</span><span class="p">;</span>

	<span class="cm">/* If mode timing undefined, just return as no-op:</span>
<span class="cm">	 * Happens during initial modesetting of a crtc.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vtotal</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">vdisplay</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">framedur_ns</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DRM_DEBUG</span><span class="p">(</span><span class="s">&quot;crtc %d: Noop due to uninitialized mode.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">crtc</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Get current scanout position with system timestamp.</span>
<span class="cm">	 * Repeat query up to DRM_TIMESTAMP_MAXRETRIES times</span>
<span class="cm">	 * if single query takes longer than max_error nanoseconds.</span>
<span class="cm">	 *</span>
<span class="cm">	 * This guarantees a tight bound on maximum error if</span>
<span class="cm">	 * code gets preempted or delayed for some reason.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">DRM_TIMESTAMP_MAXRETRIES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Disable preemption to make it very likely to</span>
<span class="cm">		 * succeed in the first iteration even on PREEMPT_RT kernel.</span>
<span class="cm">		 */</span>
		<span class="n">preempt_disable</span><span class="p">();</span>

		<span class="cm">/* Get system timestamp before query. */</span>
		<span class="n">do_gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stime</span><span class="p">);</span>

		<span class="cm">/* Get vertical and horizontal scanout pos. vpos, hpos. */</span>
		<span class="n">vbl_status</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">get_scanout_position</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">crtc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vpos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hpos</span><span class="p">);</span>

		<span class="cm">/* Get system timestamp after query. */</span>
		<span class="n">do_gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">raw_time</span><span class="p">);</span>

		<span class="n">preempt_enable</span><span class="p">();</span>

		<span class="cm">/* Return as no-op if scanout query unsupported or failed. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vbl_status</span> <span class="o">&amp;</span> <span class="n">DRM_SCANOUTPOS_VALID</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">DRM_DEBUG</span><span class="p">(</span><span class="s">&quot;crtc %d : scanoutpos query failed [%d].</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">crtc</span><span class="p">,</span> <span class="n">vbl_status</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">duration_ns</span> <span class="o">=</span> <span class="n">timeval_to_ns</span><span class="p">(</span><span class="o">&amp;</span><span class="n">raw_time</span><span class="p">)</span> <span class="o">-</span> <span class="n">timeval_to_ns</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stime</span><span class="p">);</span>

		<span class="cm">/* Accept result with &lt;  max_error nsecs timing uncertainty. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">duration_ns</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">s64</span><span class="p">)</span> <span class="o">*</span><span class="n">max_error</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Noisy system timing? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">DRM_TIMESTAMP_MAXRETRIES</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DRM_DEBUG</span><span class="p">(</span><span class="s">&quot;crtc %d: Noisy timestamp %d us &gt; %d us [%d reps].</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">crtc</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">duration_ns</span><span class="o">/</span><span class="mi">1000</span><span class="p">,</span> <span class="o">*</span><span class="n">max_error</span><span class="o">/</span><span class="mi">1000</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Return upper bound of timestamp precision error. */</span>
	<span class="o">*</span><span class="n">max_error</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">duration_ns</span><span class="p">;</span>

	<span class="cm">/* Check if in vblank area:</span>
<span class="cm">	 * vpos is &gt;=0 in video scanout area, but negative</span>
<span class="cm">	 * within vblank area, counting down the number of lines until</span>
<span class="cm">	 * start of scanout.</span>
<span class="cm">	 */</span>
	<span class="n">invbl</span> <span class="o">=</span> <span class="n">vbl_status</span> <span class="o">&amp;</span> <span class="n">DRM_SCANOUTPOS_INVBL</span><span class="p">;</span>

	<span class="cm">/* Convert scanout position into elapsed time at raw_time query</span>
<span class="cm">	 * since start of scanout at first display scanline. delta_ns</span>
<span class="cm">	 * can be negative if start of scanout hasn&#39;t happened yet.</span>
<span class="cm">	 */</span>
	<span class="n">delta_ns</span> <span class="o">=</span> <span class="p">(</span><span class="n">s64</span><span class="p">)</span> <span class="n">vpos</span> <span class="o">*</span> <span class="n">linedur_ns</span> <span class="o">+</span> <span class="p">(</span><span class="n">s64</span><span class="p">)</span> <span class="n">hpos</span> <span class="o">*</span> <span class="n">pixeldur_ns</span><span class="p">;</span>

	<span class="cm">/* Is vpos outside nominal vblank area, but less than</span>
<span class="cm">	 * 1/100 of a frame height away from start of vblank?</span>
<span class="cm">	 * If so, assume this isn&#39;t a massively delayed vblank</span>
<span class="cm">	 * interrupt, but a vblank interrupt that fired a few</span>
<span class="cm">	 * microseconds before true start of vblank. Compensate</span>
<span class="cm">	 * by adding a full frame duration to the final timestamp.</span>
<span class="cm">	 * Happens, e.g., on ATI R500, R600.</span>
<span class="cm">	 *</span>
<span class="cm">	 * We only do this if DRM_CALLED_FROM_VBLIRQ.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DRM_CALLED_FROM_VBLIRQ</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">invbl</span> <span class="o">&amp;&amp;</span>
	    <span class="p">((</span><span class="n">vdisplay</span> <span class="o">-</span> <span class="n">vpos</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">vtotal</span> <span class="o">/</span> <span class="mi">100</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">delta_ns</span> <span class="o">=</span> <span class="n">delta_ns</span> <span class="o">-</span> <span class="n">framedur_ns</span><span class="p">;</span>

		<span class="cm">/* Signal this correction as &quot;applied&quot;. */</span>
		<span class="n">vbl_status</span> <span class="o">|=</span> <span class="mh">0x8</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Subtract time delta from raw timestamp to get final</span>
<span class="cm">	 * vblank_time timestamp for end of vblank.</span>
<span class="cm">	 */</span>
	<span class="o">*</span><span class="n">vblank_time</span> <span class="o">=</span> <span class="n">ns_to_timeval</span><span class="p">(</span><span class="n">timeval_to_ns</span><span class="p">(</span><span class="o">&amp;</span><span class="n">raw_time</span><span class="p">)</span> <span class="o">-</span> <span class="n">delta_ns</span><span class="p">);</span>

	<span class="n">DRM_DEBUG</span><span class="p">(</span><span class="s">&quot;crtc %d : v %d p(%d,%d)@ %ld.%ld -&gt; %ld.%ld [e %d us, %d rep]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">crtc</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">vbl_status</span><span class="p">,</span> <span class="n">hpos</span><span class="p">,</span> <span class="n">vpos</span><span class="p">,</span>
		  <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">raw_time</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">raw_time</span><span class="p">.</span><span class="n">tv_usec</span><span class="p">,</span>
		  <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">vblank_time</span><span class="o">-&gt;</span><span class="n">tv_sec</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">vblank_time</span><span class="o">-&gt;</span><span class="n">tv_usec</span><span class="p">,</span>
		  <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">duration_ns</span><span class="o">/</span><span class="mi">1000</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

	<span class="n">vbl_status</span> <span class="o">=</span> <span class="n">DRM_VBLANKTIME_SCANOUTPOS_METHOD</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">invbl</span><span class="p">)</span>
		<span class="n">vbl_status</span> <span class="o">|=</span> <span class="n">DRM_VBLANKTIME_INVBL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">vbl_status</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">drm_calc_vbltimestamp_from_scanoutpos</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * drm_get_last_vbltimestamp - retrieve raw timestamp for the most recent</span>
<span class="cm"> * vblank interval.</span>
<span class="cm"> *</span>
<span class="cm"> * @dev: DRM device</span>
<span class="cm"> * @crtc: which crtc&#39;s vblank timestamp to retrieve</span>
<span class="cm"> * @tvblank: Pointer to target struct timeval which should receive the timestamp</span>
<span class="cm"> * @flags: Flags to pass to driver:</span>
<span class="cm"> *         0 = Default.</span>
<span class="cm"> *         DRM_CALLED_FROM_VBLIRQ = If function is called from vbl irq handler.</span>
<span class="cm"> *</span>
<span class="cm"> * Fetches the system timestamp corresponding to the time of the most recent</span>
<span class="cm"> * vblank interval on specified crtc. May call into kms-driver to</span>
<span class="cm"> * compute the timestamp with a high-precision GPU specific method.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns zero if timestamp originates from uncorrected do_gettimeofday()</span>
<span class="cm"> * call, i.e., it isn&#39;t very precisely locked to the true vblank.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns non-zero if timestamp is considered to be very precise.</span>
<span class="cm"> */</span>
<span class="n">u32</span> <span class="nf">drm_get_last_vbltimestamp</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">crtc</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">timeval</span> <span class="o">*</span><span class="n">tvblank</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* Define requested maximum error on timestamps (nanoseconds). */</span>
	<span class="kt">int</span> <span class="n">max_error</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">drm_timestamp_precision</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">;</span>

	<span class="cm">/* Query driver if possible and precision timestamping enabled. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">get_vblank_timestamp</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">max_error</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">get_vblank_timestamp</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">crtc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">max_error</span><span class="p">,</span>
							<span class="n">tvblank</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* GPU high precision timestamp query unsupported or failed.</span>
<span class="cm">	 * Return gettimeofday timestamp as best estimate.</span>
<span class="cm">	 */</span>
	<span class="n">do_gettimeofday</span><span class="p">(</span><span class="n">tvblank</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">drm_get_last_vbltimestamp</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * drm_vblank_count - retrieve &quot;cooked&quot; vblank counter value</span>
<span class="cm"> * @dev: DRM device</span>
<span class="cm"> * @crtc: which counter to retrieve</span>
<span class="cm"> *</span>
<span class="cm"> * Fetches the &quot;cooked&quot; vblank count value that represents the number of</span>
<span class="cm"> * vblank events since the system was booted, including lost events due to</span>
<span class="cm"> * modesetting activity.</span>
<span class="cm"> */</span>
<span class="n">u32</span> <span class="nf">drm_vblank_count</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">crtc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">_vblank_count</span><span class="p">[</span><span class="n">crtc</span><span class="p">]);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">drm_vblank_count</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * drm_vblank_count_and_time - retrieve &quot;cooked&quot; vblank counter value</span>
<span class="cm"> * and the system timestamp corresponding to that vblank counter value.</span>
<span class="cm"> *</span>
<span class="cm"> * @dev: DRM device</span>
<span class="cm"> * @crtc: which counter to retrieve</span>
<span class="cm"> * @vblanktime: Pointer to struct timeval to receive the vblank timestamp.</span>
<span class="cm"> *</span>
<span class="cm"> * Fetches the &quot;cooked&quot; vblank count value that represents the number of</span>
<span class="cm"> * vblank events since the system was booted, including lost events due to</span>
<span class="cm"> * modesetting activity. Returns corresponding system timestamp of the time</span>
<span class="cm"> * of the vblank interval that corresponds to the current value vblank counter</span>
<span class="cm"> * value.</span>
<span class="cm"> */</span>
<span class="n">u32</span> <span class="nf">drm_vblank_count_and_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">crtc</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">timeval</span> <span class="o">*</span><span class="n">vblanktime</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">cur_vblank</span><span class="p">;</span>

	<span class="cm">/* Read timestamp from slot of _vblank_time ringbuffer</span>
<span class="cm">	 * that corresponds to current vblank count. Retry if</span>
<span class="cm">	 * count has incremented during readout. This works like</span>
<span class="cm">	 * a seqlock.</span>
<span class="cm">	 */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">cur_vblank</span> <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">_vblank_count</span><span class="p">[</span><span class="n">crtc</span><span class="p">]);</span>
		<span class="o">*</span><span class="n">vblanktime</span> <span class="o">=</span> <span class="n">vblanktimestamp</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">crtc</span><span class="p">,</span> <span class="n">cur_vblank</span><span class="p">);</span>
		<span class="n">smp_rmb</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">cur_vblank</span> <span class="o">!=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">_vblank_count</span><span class="p">[</span><span class="n">crtc</span><span class="p">]));</span>

	<span class="k">return</span> <span class="n">cur_vblank</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">drm_vblank_count_and_time</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * drm_update_vblank_count - update the master vblank counter</span>
<span class="cm"> * @dev: DRM device</span>
<span class="cm"> * @crtc: counter to update</span>
<span class="cm"> *</span>
<span class="cm"> * Call back into the driver to update the appropriate vblank counter</span>
<span class="cm"> * (specified by @crtc).  Deal with wraparound, if it occurred, and</span>
<span class="cm"> * update the last read value so we can deal with wraparound on the next</span>
<span class="cm"> * call if necessary.</span>
<span class="cm"> *</span>
<span class="cm"> * Only necessary when going from off-&gt;on, to account for frames we</span>
<span class="cm"> * didn&#39;t get an interrupt for.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: caller must hold dev-&gt;vbl_lock since this reads &amp; writes</span>
<span class="cm"> * device vblank fields.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">drm_update_vblank_count</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">crtc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">cur_vblank</span><span class="p">,</span> <span class="n">diff</span><span class="p">,</span> <span class="n">tslot</span><span class="p">,</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timeval</span> <span class="n">t_vblank</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Interrupts were disabled prior to this call, so deal with counter</span>
<span class="cm">	 * wrap if needed.</span>
<span class="cm">	 * NOTE!  It&#39;s possible we lost a full dev-&gt;max_vblank_count events</span>
<span class="cm">	 * here if the register is small or we had vblank interrupts off for</span>
<span class="cm">	 * a long time.</span>
<span class="cm">	 *</span>
<span class="cm">	 * We repeat the hardware vblank counter &amp; timestamp query until</span>
<span class="cm">	 * we get consistent results. This to prevent races between gpu</span>
<span class="cm">	 * updating its hardware counter while we are retrieving the</span>
<span class="cm">	 * corresponding vblank timestamp.</span>
<span class="cm">	 */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">cur_vblank</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">get_vblank_counter</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">crtc</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">drm_get_last_vbltimestamp</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">crtc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">t_vblank</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">cur_vblank</span> <span class="o">!=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">get_vblank_counter</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">crtc</span><span class="p">));</span>

	<span class="cm">/* Deal with counter wrap */</span>
	<span class="n">diff</span> <span class="o">=</span> <span class="n">cur_vblank</span> <span class="o">-</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">last_vblank</span><span class="p">[</span><span class="n">crtc</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cur_vblank</span> <span class="o">&lt;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">last_vblank</span><span class="p">[</span><span class="n">crtc</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">diff</span> <span class="o">+=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">max_vblank_count</span><span class="p">;</span>

		<span class="n">DRM_DEBUG</span><span class="p">(</span><span class="s">&quot;last_vblank[%d]=0x%x, cur_vblank=0x%x =&gt; diff=0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">crtc</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">last_vblank</span><span class="p">[</span><span class="n">crtc</span><span class="p">],</span> <span class="n">cur_vblank</span><span class="p">,</span> <span class="n">diff</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">DRM_DEBUG</span><span class="p">(</span><span class="s">&quot;enabling vblank interrupts on crtc %d, missed %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">crtc</span><span class="p">,</span> <span class="n">diff</span><span class="p">);</span>

	<span class="cm">/* Reinitialize corresponding vblank timestamp if high-precision query</span>
<span class="cm">	 * available. Skip this step if query unsupported or failed. Will</span>
<span class="cm">	 * reinitialize delayed at next vblank interrupt in that case.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tslot</span> <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">_vblank_count</span><span class="p">[</span><span class="n">crtc</span><span class="p">])</span> <span class="o">+</span> <span class="n">diff</span><span class="p">;</span>
		<span class="n">vblanktimestamp</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">crtc</span><span class="p">,</span> <span class="n">tslot</span><span class="p">)</span> <span class="o">=</span> <span class="n">t_vblank</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">smp_mb__before_atomic_inc</span><span class="p">();</span>
	<span class="n">atomic_add</span><span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">_vblank_count</span><span class="p">[</span><span class="n">crtc</span><span class="p">]);</span>
	<span class="n">smp_mb__after_atomic_inc</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * drm_vblank_get - get a reference count on vblank events</span>
<span class="cm"> * @dev: DRM device</span>
<span class="cm"> * @crtc: which CRTC to own</span>
<span class="cm"> *</span>
<span class="cm"> * Acquire a reference count on vblank events to avoid having them disabled</span>
<span class="cm"> * while in use.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS</span>
<span class="cm"> * Zero on success, nonzero on failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">drm_vblank_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">crtc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irqflags</span><span class="p">,</span> <span class="n">irqflags2</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vbl_lock</span><span class="p">,</span> <span class="n">irqflags</span><span class="p">);</span>
	<span class="cm">/* Going from 0-&gt;1 means we have to enable interrupts again */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_add_return</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vblank_refcount</span><span class="p">[</span><span class="n">crtc</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vblank_time_lock</span><span class="p">,</span> <span class="n">irqflags2</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vblank_enabled</span><span class="p">[</span><span class="n">crtc</span><span class="p">])</span> <span class="p">{</span>
			<span class="cm">/* Enable vblank irqs under vblank_time_lock protection.</span>
<span class="cm">			 * All vblank count &amp; timestamp updates are held off</span>
<span class="cm">			 * until we are done reinitializing master counter and</span>
<span class="cm">			 * timestamps. Filtercode in drm_handle_vblank() will</span>
<span class="cm">			 * prevent double-accounting of same vblank interval.</span>
<span class="cm">			 */</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">enable_vblank</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">crtc</span><span class="p">);</span>
			<span class="n">DRM_DEBUG</span><span class="p">(</span><span class="s">&quot;enabling vblank on crtc %d, ret: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">crtc</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
				<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vblank_refcount</span><span class="p">[</span><span class="n">crtc</span><span class="p">]);</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">vblank_enabled</span><span class="p">[</span><span class="n">crtc</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">drm_update_vblank_count</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">crtc</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vblank_time_lock</span><span class="p">,</span> <span class="n">irqflags2</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vblank_enabled</span><span class="p">[</span><span class="n">crtc</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vblank_refcount</span><span class="p">[</span><span class="n">crtc</span><span class="p">]);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vbl_lock</span><span class="p">,</span> <span class="n">irqflags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">drm_vblank_get</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * drm_vblank_put - give up ownership of vblank events</span>
<span class="cm"> * @dev: DRM device</span>
<span class="cm"> * @crtc: which counter to give up</span>
<span class="cm"> *</span>
<span class="cm"> * Release ownership of a given vblank counter, turning off interrupts</span>
<span class="cm"> * if possible. Disable interrupts after drm_vblank_offdelay milliseconds.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">drm_vblank_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">crtc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vblank_refcount</span><span class="p">[</span><span class="n">crtc</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Last user schedules interrupt disable */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vblank_refcount</span><span class="p">[</span><span class="n">crtc</span><span class="p">])</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">drm_vblank_offdelay</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vblank_disable_timer</span><span class="p">,</span>
			  <span class="n">jiffies</span> <span class="o">+</span> <span class="p">((</span><span class="n">drm_vblank_offdelay</span> <span class="o">*</span> <span class="n">DRM_HZ</span><span class="p">)</span><span class="o">/</span><span class="mi">1000</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">drm_vblank_put</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">drm_vblank_off</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">crtc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_pending_vblank_event</span> <span class="o">*</span><span class="n">e</span><span class="p">,</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timeval</span> <span class="n">now</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irqflags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">seq</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vbl_lock</span><span class="p">,</span> <span class="n">irqflags</span><span class="p">);</span>
	<span class="n">vblank_disable_and_save</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">crtc</span><span class="p">);</span>
	<span class="n">DRM_WAKEUP</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vbl_queue</span><span class="p">[</span><span class="n">crtc</span><span class="p">]);</span>

	<span class="cm">/* Send any queued vblank events, lest the natives grow disquiet */</span>
	<span class="n">seq</span> <span class="o">=</span> <span class="n">drm_vblank_count_and_time</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">crtc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">now</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vblank_event_list</span><span class="p">,</span> <span class="n">base</span><span class="p">.</span><span class="n">link</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">pipe</span> <span class="o">!=</span> <span class="n">crtc</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">DRM_DEBUG</span><span class="p">(</span><span class="s">&quot;Sending premature vblank event on disable: \</span>
<span class="s">			  wanted %d, current %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">e</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">.</span><span class="n">sequence</span><span class="p">,</span> <span class="n">seq</span><span class="p">);</span>

		<span class="n">e</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">.</span><span class="n">sequence</span> <span class="o">=</span> <span class="n">seq</span><span class="p">;</span>
		<span class="n">e</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">now</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">;</span>
		<span class="n">e</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">=</span> <span class="n">now</span><span class="p">.</span><span class="n">tv_usec</span><span class="p">;</span>
		<span class="n">drm_vblank_put</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">);</span>
		<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">link</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">file_priv</span><span class="o">-&gt;</span><span class="n">event_list</span><span class="p">);</span>
		<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">file_priv</span><span class="o">-&gt;</span><span class="n">event_wait</span><span class="p">);</span>
		<span class="n">trace_drm_vblank_event_delivered</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">pid</span><span class="p">,</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">,</span>
						 <span class="n">e</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">.</span><span class="n">sequence</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vbl_lock</span><span class="p">,</span> <span class="n">irqflags</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">drm_vblank_off</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * drm_vblank_pre_modeset - account for vblanks across mode sets</span>
<span class="cm"> * @dev: DRM device</span>
<span class="cm"> * @crtc: CRTC in question</span>
<span class="cm"> * @post: post or pre mode set?</span>
<span class="cm"> *</span>
<span class="cm"> * Account for vblank events across mode setting events, which will likely</span>
<span class="cm"> * reset the hardware frame counter.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">drm_vblank_pre_modeset</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">crtc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* vblank is not initialized (IRQ not installed ?) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">num_crtcs</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * To avoid all the problems that might happen if interrupts</span>
<span class="cm">	 * were enabled/disabled around or between these calls, we just</span>
<span class="cm">	 * have the kernel take a reference on the CRTC (just once though</span>
<span class="cm">	 * to avoid corrupting the count if multiple, mismatch calls occur),</span>
<span class="cm">	 * so that interrupts remain enabled in the interim.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vblank_inmodeset</span><span class="p">[</span><span class="n">crtc</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">vblank_inmodeset</span><span class="p">[</span><span class="n">crtc</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">drm_vblank_get</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">crtc</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">vblank_inmodeset</span><span class="p">[</span><span class="n">crtc</span><span class="p">]</span> <span class="o">|=</span> <span class="mh">0x2</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">drm_vblank_pre_modeset</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">drm_vblank_post_modeset</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">crtc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irqflags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vblank_inmodeset</span><span class="p">[</span><span class="n">crtc</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vbl_lock</span><span class="p">,</span> <span class="n">irqflags</span><span class="p">);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">vblank_disable_allowed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vbl_lock</span><span class="p">,</span> <span class="n">irqflags</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vblank_inmodeset</span><span class="p">[</span><span class="n">crtc</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x2</span><span class="p">)</span>
			<span class="n">drm_vblank_put</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">crtc</span><span class="p">);</span>

		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">vblank_inmodeset</span><span class="p">[</span><span class="n">crtc</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">drm_vblank_post_modeset</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * drm_modeset_ctl - handle vblank event counter changes across mode switch</span>
<span class="cm"> * @DRM_IOCTL_ARGS: standard ioctl arguments</span>
<span class="cm"> *</span>
<span class="cm"> * Applications should call the %_DRM_PRE_MODESET and %_DRM_POST_MODESET</span>
<span class="cm"> * ioctls around modesetting so that any lost vblank events are accounted for.</span>
<span class="cm"> *</span>
<span class="cm"> * Generally the counter will reset across mode sets.  If interrupts are</span>
<span class="cm"> * enabled around this call, we don&#39;t have to do anything since the counter</span>
<span class="cm"> * will have already been incremented.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">drm_modeset_ctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_modeset_ctl</span> <span class="o">*</span><span class="n">modeset</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">crtc</span><span class="p">;</span>

	<span class="cm">/* If drm_vblank_init() hasn&#39;t been called yet, just no-op */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">num_crtcs</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">crtc</span> <span class="o">=</span> <span class="n">modeset</span><span class="o">-&gt;</span><span class="n">crtc</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">crtc</span> <span class="o">&gt;=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">num_crtcs</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">modeset</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">_DRM_PRE_MODESET</span>:
		<span class="n">drm_vblank_pre_modeset</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">crtc</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">_DRM_POST_MODESET</span>:
		<span class="n">drm_vblank_post_modeset</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">crtc</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">drm_queue_vblank_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pipe</span><span class="p">,</span>
				  <span class="k">union</span> <span class="n">drm_wait_vblank</span> <span class="o">*</span><span class="n">vblwait</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_pending_vblank_event</span> <span class="o">*</span><span class="n">e</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timeval</span> <span class="n">now</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">seq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">e</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span> <span class="o">*</span><span class="n">e</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">e</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_put</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">e</span><span class="o">-&gt;</span><span class="n">pipe</span> <span class="o">=</span> <span class="n">pipe</span><span class="p">;</span>
	<span class="n">e</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">pid</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">;</span>
	<span class="n">e</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">.</span><span class="n">base</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">DRM_EVENT_VBLANK</span><span class="p">;</span>
	<span class="n">e</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">.</span><span class="n">base</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="k">sizeof</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">;</span>
	<span class="n">e</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">.</span><span class="n">user_data</span> <span class="o">=</span> <span class="n">vblwait</span><span class="o">-&gt;</span><span class="n">request</span><span class="p">.</span><span class="n">signal</span><span class="p">;</span>
	<span class="n">e</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">event</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">.</span><span class="n">base</span><span class="p">;</span>
	<span class="n">e</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">file_priv</span> <span class="o">=</span> <span class="n">file_priv</span><span class="p">;</span>
	<span class="n">e</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">destroy</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">drm_pending_event</span> <span class="o">*</span><span class="p">))</span> <span class="n">kfree</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">event_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">file_priv</span><span class="o">-&gt;</span><span class="n">event_space</span> <span class="o">&lt;</span> <span class="k">sizeof</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">file_priv</span><span class="o">-&gt;</span><span class="n">event_space</span> <span class="o">-=</span> <span class="k">sizeof</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">;</span>
	<span class="n">seq</span> <span class="o">=</span> <span class="n">drm_vblank_count_and_time</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pipe</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">now</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">vblwait</span><span class="o">-&gt;</span><span class="n">request</span><span class="p">.</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">_DRM_VBLANK_NEXTONMISS</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">seq</span> <span class="o">-</span> <span class="n">vblwait</span><span class="o">-&gt;</span><span class="n">request</span><span class="p">.</span><span class="n">sequence</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">23</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">vblwait</span><span class="o">-&gt;</span><span class="n">request</span><span class="p">.</span><span class="n">sequence</span> <span class="o">=</span> <span class="n">seq</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">vblwait</span><span class="o">-&gt;</span><span class="n">reply</span><span class="p">.</span><span class="n">sequence</span> <span class="o">=</span> <span class="n">vblwait</span><span class="o">-&gt;</span><span class="n">request</span><span class="p">.</span><span class="n">sequence</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">DRM_DEBUG</span><span class="p">(</span><span class="s">&quot;event on vblank count %d, current %d, crtc %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">vblwait</span><span class="o">-&gt;</span><span class="n">request</span><span class="p">.</span><span class="n">sequence</span><span class="p">,</span> <span class="n">seq</span><span class="p">,</span> <span class="n">pipe</span><span class="p">);</span>

	<span class="n">trace_drm_vblank_event_queued</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">pipe</span><span class="p">,</span>
				      <span class="n">vblwait</span><span class="o">-&gt;</span><span class="n">request</span><span class="p">.</span><span class="n">sequence</span><span class="p">);</span>

	<span class="n">e</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">.</span><span class="n">sequence</span> <span class="o">=</span> <span class="n">vblwait</span><span class="o">-&gt;</span><span class="n">request</span><span class="p">.</span><span class="n">sequence</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">seq</span> <span class="o">-</span> <span class="n">vblwait</span><span class="o">-&gt;</span><span class="n">request</span><span class="p">.</span><span class="n">sequence</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">23</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">e</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">.</span><span class="n">sequence</span> <span class="o">=</span> <span class="n">seq</span><span class="p">;</span>
		<span class="n">e</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">now</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">;</span>
		<span class="n">e</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">=</span> <span class="n">now</span><span class="p">.</span><span class="n">tv_usec</span><span class="p">;</span>
		<span class="n">drm_vblank_put</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pipe</span><span class="p">);</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">link</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">file_priv</span><span class="o">-&gt;</span><span class="n">event_list</span><span class="p">);</span>
		<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">file_priv</span><span class="o">-&gt;</span><span class="n">event_wait</span><span class="p">);</span>
		<span class="n">vblwait</span><span class="o">-&gt;</span><span class="n">reply</span><span class="p">.</span><span class="n">sequence</span> <span class="o">=</span> <span class="n">seq</span><span class="p">;</span>
		<span class="n">trace_drm_vblank_event_delivered</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">pipe</span><span class="p">,</span>
						 <span class="n">vblwait</span><span class="o">-&gt;</span><span class="n">request</span><span class="p">.</span><span class="n">sequence</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* drm_handle_vblank_events will call drm_vblank_put */</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">link</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vblank_event_list</span><span class="p">);</span>
		<span class="n">vblwait</span><span class="o">-&gt;</span><span class="n">reply</span><span class="p">.</span><span class="n">sequence</span> <span class="o">=</span> <span class="n">vblwait</span><span class="o">-&gt;</span><span class="n">request</span><span class="p">.</span><span class="n">sequence</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">event_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_unlock:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">event_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
<span class="nl">err_put:</span>
	<span class="n">drm_vblank_put</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pipe</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Wait for VBLANK.</span>
<span class="cm"> *</span>
<span class="cm"> * \param inode device inode.</span>
<span class="cm"> * \param file_priv DRM file private.</span>
<span class="cm"> * \param cmd command.</span>
<span class="cm"> * \param data user argument, pointing to a drm_wait_vblank structure.</span>
<span class="cm"> * \return zero on success or a negative number on failure.</span>
<span class="cm"> *</span>
<span class="cm"> * This function enables the vblank interrupt on the pipe requested, then</span>
<span class="cm"> * sleeps waiting for the requested sequence number to occur, and drops</span>
<span class="cm"> * the vblank interrupt refcount afterwards. (vblank irq disable follows that</span>
<span class="cm"> * after a timeout with no further vblank waits scheduled).</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">drm_wait_vblank</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">drm_wait_vblank</span> <span class="o">*</span><span class="n">vblwait</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="n">seq</span><span class="p">,</span> <span class="n">crtc</span><span class="p">,</span> <span class="n">high_crtc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">drm_dev_to_irq</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq_enabled</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vblwait</span><span class="o">-&gt;</span><span class="n">request</span><span class="p">.</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">_DRM_VBLANK_SIGNAL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vblwait</span><span class="o">-&gt;</span><span class="n">request</span><span class="p">.</span><span class="n">type</span> <span class="o">&amp;</span>
	    <span class="o">~</span><span class="p">(</span><span class="n">_DRM_VBLANK_TYPES_MASK</span> <span class="o">|</span> <span class="n">_DRM_VBLANK_FLAGS_MASK</span> <span class="o">|</span>
	      <span class="n">_DRM_VBLANK_HIGH_CRTC_MASK</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">DRM_ERROR</span><span class="p">(</span><span class="s">&quot;Unsupported type value 0x%x, supported mask 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">vblwait</span><span class="o">-&gt;</span><span class="n">request</span><span class="p">.</span><span class="n">type</span><span class="p">,</span>
			  <span class="p">(</span><span class="n">_DRM_VBLANK_TYPES_MASK</span> <span class="o">|</span> <span class="n">_DRM_VBLANK_FLAGS_MASK</span> <span class="o">|</span>
			   <span class="n">_DRM_VBLANK_HIGH_CRTC_MASK</span><span class="p">));</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">flags</span> <span class="o">=</span> <span class="n">vblwait</span><span class="o">-&gt;</span><span class="n">request</span><span class="p">.</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">_DRM_VBLANK_FLAGS_MASK</span><span class="p">;</span>
	<span class="n">high_crtc</span> <span class="o">=</span> <span class="p">(</span><span class="n">vblwait</span><span class="o">-&gt;</span><span class="n">request</span><span class="p">.</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">_DRM_VBLANK_HIGH_CRTC_MASK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">high_crtc</span><span class="p">)</span>
		<span class="n">crtc</span> <span class="o">=</span> <span class="n">high_crtc</span> <span class="o">&gt;&gt;</span> <span class="n">_DRM_VBLANK_HIGH_CRTC_SHIFT</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">crtc</span> <span class="o">=</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">_DRM_VBLANK_SECONDARY</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">crtc</span> <span class="o">&gt;=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">num_crtcs</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">drm_vblank_get</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">crtc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DRM_DEBUG</span><span class="p">(</span><span class="s">&quot;failed to acquire vblank counter, %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">seq</span> <span class="o">=</span> <span class="n">drm_vblank_count</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">crtc</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">vblwait</span><span class="o">-&gt;</span><span class="n">request</span><span class="p">.</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">_DRM_VBLANK_TYPES_MASK</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">_DRM_VBLANK_RELATIVE</span>:
		<span class="n">vblwait</span><span class="o">-&gt;</span><span class="n">request</span><span class="p">.</span><span class="n">sequence</span> <span class="o">+=</span> <span class="n">seq</span><span class="p">;</span>
		<span class="n">vblwait</span><span class="o">-&gt;</span><span class="n">request</span><span class="p">.</span><span class="n">type</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">_DRM_VBLANK_RELATIVE</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">_DRM_VBLANK_ABSOLUTE</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">_DRM_VBLANK_EVENT</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* must hold on to the vblank ref until the event fires</span>
<span class="cm">		 * drm_vblank_put will be called asynchronously</span>
<span class="cm">		 */</span>
		<span class="k">return</span> <span class="n">drm_queue_vblank_event</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">crtc</span><span class="p">,</span> <span class="n">vblwait</span><span class="p">,</span> <span class="n">file_priv</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">_DRM_VBLANK_NEXTONMISS</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">seq</span> <span class="o">-</span> <span class="n">vblwait</span><span class="o">-&gt;</span><span class="n">request</span><span class="p">.</span><span class="n">sequence</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">23</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">vblwait</span><span class="o">-&gt;</span><span class="n">request</span><span class="p">.</span><span class="n">sequence</span> <span class="o">=</span> <span class="n">seq</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">DRM_DEBUG</span><span class="p">(</span><span class="s">&quot;waiting on vblank count %d, crtc %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">vblwait</span><span class="o">-&gt;</span><span class="n">request</span><span class="p">.</span><span class="n">sequence</span><span class="p">,</span> <span class="n">crtc</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">last_vblank_wait</span><span class="p">[</span><span class="n">crtc</span><span class="p">]</span> <span class="o">=</span> <span class="n">vblwait</span><span class="o">-&gt;</span><span class="n">request</span><span class="p">.</span><span class="n">sequence</span><span class="p">;</span>
	<span class="n">DRM_WAIT_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">vbl_queue</span><span class="p">[</span><span class="n">crtc</span><span class="p">],</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">DRM_HZ</span><span class="p">,</span>
		    <span class="p">(((</span><span class="n">drm_vblank_count</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">crtc</span><span class="p">)</span> <span class="o">-</span>
		       <span class="n">vblwait</span><span class="o">-&gt;</span><span class="n">request</span><span class="p">.</span><span class="n">sequence</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">23</span><span class="p">))</span> <span class="o">||</span>
		     <span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq_enabled</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">timeval</span> <span class="n">now</span><span class="p">;</span>

		<span class="n">vblwait</span><span class="o">-&gt;</span><span class="n">reply</span><span class="p">.</span><span class="n">sequence</span> <span class="o">=</span> <span class="n">drm_vblank_count_and_time</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">crtc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">now</span><span class="p">);</span>
		<span class="n">vblwait</span><span class="o">-&gt;</span><span class="n">reply</span><span class="p">.</span><span class="n">tval_sec</span> <span class="o">=</span> <span class="n">now</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">;</span>
		<span class="n">vblwait</span><span class="o">-&gt;</span><span class="n">reply</span><span class="p">.</span><span class="n">tval_usec</span> <span class="o">=</span> <span class="n">now</span><span class="p">.</span><span class="n">tv_usec</span><span class="p">;</span>

		<span class="n">DRM_DEBUG</span><span class="p">(</span><span class="s">&quot;returning %d to client</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">vblwait</span><span class="o">-&gt;</span><span class="n">reply</span><span class="p">.</span><span class="n">sequence</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">DRM_DEBUG</span><span class="p">(</span><span class="s">&quot;vblank wait interrupted by signal</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">done:</span>
	<span class="n">drm_vblank_put</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">crtc</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">drm_handle_vblank_events</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">crtc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_pending_vblank_event</span> <span class="o">*</span><span class="n">e</span><span class="p">,</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timeval</span> <span class="n">now</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">seq</span><span class="p">;</span>

	<span class="n">seq</span> <span class="o">=</span> <span class="n">drm_vblank_count_and_time</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">crtc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">now</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">event_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vblank_event_list</span><span class="p">,</span> <span class="n">base</span><span class="p">.</span><span class="n">link</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">pipe</span> <span class="o">!=</span> <span class="n">crtc</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">seq</span> <span class="o">-</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">.</span><span class="n">sequence</span><span class="p">)</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">23</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">DRM_DEBUG</span><span class="p">(</span><span class="s">&quot;vblank event on %d, current %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">e</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">.</span><span class="n">sequence</span><span class="p">,</span> <span class="n">seq</span><span class="p">);</span>

		<span class="n">e</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">.</span><span class="n">sequence</span> <span class="o">=</span> <span class="n">seq</span><span class="p">;</span>
		<span class="n">e</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">now</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">;</span>
		<span class="n">e</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">=</span> <span class="n">now</span><span class="p">.</span><span class="n">tv_usec</span><span class="p">;</span>
		<span class="n">drm_vblank_put</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">);</span>
		<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">link</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">file_priv</span><span class="o">-&gt;</span><span class="n">event_list</span><span class="p">);</span>
		<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">file_priv</span><span class="o">-&gt;</span><span class="n">event_wait</span><span class="p">);</span>
		<span class="n">trace_drm_vblank_event_delivered</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">pid</span><span class="p">,</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">,</span>
						 <span class="n">e</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">.</span><span class="n">sequence</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">event_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">trace_drm_vblank_event</span><span class="p">(</span><span class="n">crtc</span><span class="p">,</span> <span class="n">seq</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * drm_handle_vblank - handle a vblank event</span>
<span class="cm"> * @dev: DRM device</span>
<span class="cm"> * @crtc: where this event occurred</span>
<span class="cm"> *</span>
<span class="cm"> * Drivers should call this routine in their vblank interrupt handlers to</span>
<span class="cm"> * update the vblank counter and send any signals that may be pending.</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="nf">drm_handle_vblank</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">crtc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">vblcount</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">diff_ns</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timeval</span> <span class="n">tvblank</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irqflags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">num_crtcs</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* Need timestamp lock to prevent concurrent execution with</span>
<span class="cm">	 * vblank enable/disable, as this would cause inconsistent</span>
<span class="cm">	 * or corrupted timestamps and vblank counts.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vblank_time_lock</span><span class="p">,</span> <span class="n">irqflags</span><span class="p">);</span>

	<span class="cm">/* Vblank irq handling disabled. Nothing to do. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vblank_enabled</span><span class="p">[</span><span class="n">crtc</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vblank_time_lock</span><span class="p">,</span> <span class="n">irqflags</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Fetch corresponding timestamp for this vblank interval from</span>
<span class="cm">	 * driver and store it in proper slot of timestamp ringbuffer.</span>
<span class="cm">	 */</span>

	<span class="cm">/* Get current timestamp and count. */</span>
	<span class="n">vblcount</span> <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">_vblank_count</span><span class="p">[</span><span class="n">crtc</span><span class="p">]);</span>
	<span class="n">drm_get_last_vbltimestamp</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">crtc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tvblank</span><span class="p">,</span> <span class="n">DRM_CALLED_FROM_VBLIRQ</span><span class="p">);</span>

	<span class="cm">/* Compute time difference to timestamp of last vblank */</span>
	<span class="n">diff_ns</span> <span class="o">=</span> <span class="n">timeval_to_ns</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tvblank</span><span class="p">)</span> <span class="o">-</span>
		  <span class="n">timeval_to_ns</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vblanktimestamp</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">crtc</span><span class="p">,</span> <span class="n">vblcount</span><span class="p">));</span>

	<span class="cm">/* Update vblank timestamp and count if at least</span>
<span class="cm">	 * DRM_REDUNDANT_VBLIRQ_THRESH_NS nanoseconds</span>
<span class="cm">	 * difference between last stored timestamp and current</span>
<span class="cm">	 * timestamp. A smaller difference means basically</span>
<span class="cm">	 * identical timestamps. Happens if this vblank has</span>
<span class="cm">	 * been already processed and this is a redundant call,</span>
<span class="cm">	 * e.g., due to spurious vblank interrupts. We need to</span>
<span class="cm">	 * ignore those for accounting.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">abs64</span><span class="p">(</span><span class="n">diff_ns</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">DRM_REDUNDANT_VBLIRQ_THRESH_NS</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Store new timestamp in ringbuffer. */</span>
		<span class="n">vblanktimestamp</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">crtc</span><span class="p">,</span> <span class="n">vblcount</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">tvblank</span><span class="p">;</span>

		<span class="cm">/* Increment cooked vblank count. This also atomically commits</span>
<span class="cm">		 * the timestamp computed above.</span>
<span class="cm">		 */</span>
		<span class="n">smp_mb__before_atomic_inc</span><span class="p">();</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">_vblank_count</span><span class="p">[</span><span class="n">crtc</span><span class="p">]);</span>
		<span class="n">smp_mb__after_atomic_inc</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">DRM_DEBUG</span><span class="p">(</span><span class="s">&quot;crtc %d: Redundant vblirq ignored. diff_ns = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">crtc</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">diff_ns</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">DRM_WAKEUP</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vbl_queue</span><span class="p">[</span><span class="n">crtc</span><span class="p">]);</span>
	<span class="n">drm_handle_vblank_events</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">crtc</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vblank_time_lock</span><span class="p">,</span> <span class="n">irqflags</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">drm_handle_vblank</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
