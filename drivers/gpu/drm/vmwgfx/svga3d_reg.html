<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › gpu › drm › vmwgfx › svga3d_reg.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>svga3d_reg.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/**********************************************************</span>
<span class="cm"> * Copyright 1998-2009 VMware, Inc.  All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * Permission is hereby granted, free of charge, to any person</span>
<span class="cm"> * obtaining a copy of this software and associated documentation</span>
<span class="cm"> * files (the &quot;Software&quot;), to deal in the Software without</span>
<span class="cm"> * restriction, including without limitation the rights to use, copy,</span>
<span class="cm"> * modify, merge, publish, distribute, sublicense, and/or sell copies</span>
<span class="cm"> * of the Software, and to permit persons to whom the Software is</span>
<span class="cm"> * furnished to do so, subject to the following conditions:</span>
<span class="cm"> *</span>
<span class="cm"> * The above copyright notice and this permission notice shall be</span>
<span class="cm"> * included in all copies or substantial portions of the Software.</span>
<span class="cm"> *</span>
<span class="cm"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,</span>
<span class="cm"> * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span>
<span class="cm"> * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND</span>
<span class="cm"> * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS</span>
<span class="cm"> * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN</span>
<span class="cm"> * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN</span>
<span class="cm"> * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE</span>
<span class="cm"> * SOFTWARE.</span>
<span class="cm"> *</span>
<span class="cm"> **********************************************************/</span>

<span class="cm">/*</span>
<span class="cm"> * svga3d_reg.h --</span>
<span class="cm"> *</span>
<span class="cm"> *       SVGA 3D hardware definitions</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _SVGA3D_REG_H_</span>
<span class="cp">#define _SVGA3D_REG_H_</span>

<span class="cp">#include &quot;svga_reg.h&quot;</span>


<span class="cm">/*</span>
<span class="cm"> * 3D Hardware Version</span>
<span class="cm"> *</span>
<span class="cm"> *   The hardware version is stored in the SVGA_FIFO_3D_HWVERSION fifo</span>
<span class="cm"> *   register.   Is set by the host and read by the guest.  This lets</span>
<span class="cm"> *   us make new guest drivers which are backwards-compatible with old</span>
<span class="cm"> *   SVGA hardware revisions.  It does not let us support old guest</span>
<span class="cm"> *   drivers.  Good enough for now.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#define SVGA3D_MAKE_HWVERSION(major, minor)      (((major) &lt;&lt; 16) | ((minor) &amp; 0xFF))</span>
<span class="cp">#define SVGA3D_MAJOR_HWVERSION(version)          ((version) &gt;&gt; 16)</span>
<span class="cp">#define SVGA3D_MINOR_HWVERSION(version)          ((version) &amp; 0xFF)</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
   <span class="n">SVGA3D_HWVERSION_WS5_RC1</span>   <span class="o">=</span> <span class="n">SVGA3D_MAKE_HWVERSION</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
   <span class="n">SVGA3D_HWVERSION_WS5_RC2</span>   <span class="o">=</span> <span class="n">SVGA3D_MAKE_HWVERSION</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
   <span class="n">SVGA3D_HWVERSION_WS51_RC1</span>  <span class="o">=</span> <span class="n">SVGA3D_MAKE_HWVERSION</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
   <span class="n">SVGA3D_HWVERSION_WS6_B1</span>    <span class="o">=</span> <span class="n">SVGA3D_MAKE_HWVERSION</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
   <span class="n">SVGA3D_HWVERSION_FUSION_11</span> <span class="o">=</span> <span class="n">SVGA3D_MAKE_HWVERSION</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
   <span class="n">SVGA3D_HWVERSION_WS65_B1</span>   <span class="o">=</span> <span class="n">SVGA3D_MAKE_HWVERSION</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
   <span class="n">SVGA3D_HWVERSION_WS8_B1</span>    <span class="o">=</span> <span class="n">SVGA3D_MAKE_HWVERSION</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
   <span class="n">SVGA3D_HWVERSION_CURRENT</span>   <span class="o">=</span> <span class="n">SVGA3D_HWVERSION_WS8_B1</span><span class="p">,</span>
<span class="p">}</span> <span class="n">SVGA3dHardwareVersion</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Generic Types</span>
<span class="cm"> */</span>

<span class="k">typedef</span> <span class="n">uint32</span> <span class="n">SVGA3dBool</span><span class="p">;</span> <span class="cm">/* 32-bit Bool definition */</span>
<span class="cp">#define SVGA3D_NUM_CLIPPLANES                   6</span>
<span class="cp">#define SVGA3D_MAX_SIMULTANEOUS_RENDER_TARGETS  8</span>
<span class="cp">#define SVGA3D_MAX_CONTEXT_IDS                  256</span>
<span class="cp">#define SVGA3D_MAX_SURFACE_IDS                  (32 * 1024)</span>

<span class="cm">/*</span>
<span class="cm"> * Surface formats.</span>
<span class="cm"> *</span>
<span class="cm"> * If you modify this list, be sure to keep GLUtil.c in sync. It</span>
<span class="cm"> * includes the internal format definition of each surface in</span>
<span class="cm"> * GLUtil_ConvertSurfaceFormat, and it contains a table of</span>
<span class="cm"> * human-readable names in GLUtil_GetFormatName.</span>
<span class="cm"> */</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="n">SVGA3dSurfaceFormat</span> <span class="p">{</span>
   <span class="n">SVGA3D_FORMAT_INVALID</span>               <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>

   <span class="n">SVGA3D_X8R8G8B8</span>                     <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
   <span class="n">SVGA3D_A8R8G8B8</span>                     <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>

   <span class="n">SVGA3D_R5G6B5</span>                       <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
   <span class="n">SVGA3D_X1R5G5B5</span>                     <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
   <span class="n">SVGA3D_A1R5G5B5</span>                     <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
   <span class="n">SVGA3D_A4R4G4B4</span>                     <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>

   <span class="n">SVGA3D_Z_D32</span>                        <span class="o">=</span> <span class="mi">7</span><span class="p">,</span>
   <span class="n">SVGA3D_Z_D16</span>                        <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
   <span class="n">SVGA3D_Z_D24S8</span>                      <span class="o">=</span> <span class="mi">9</span><span class="p">,</span>
   <span class="n">SVGA3D_Z_D15S1</span>                      <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>

   <span class="n">SVGA3D_LUMINANCE8</span>                   <span class="o">=</span> <span class="mi">11</span><span class="p">,</span>
   <span class="n">SVGA3D_LUMINANCE4_ALPHA4</span>            <span class="o">=</span> <span class="mi">12</span><span class="p">,</span>
   <span class="n">SVGA3D_LUMINANCE16</span>                  <span class="o">=</span> <span class="mi">13</span><span class="p">,</span>
   <span class="n">SVGA3D_LUMINANCE8_ALPHA8</span>            <span class="o">=</span> <span class="mi">14</span><span class="p">,</span>

   <span class="n">SVGA3D_DXT1</span>                         <span class="o">=</span> <span class="mi">15</span><span class="p">,</span>
   <span class="n">SVGA3D_DXT2</span>                         <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>
   <span class="n">SVGA3D_DXT3</span>                         <span class="o">=</span> <span class="mi">17</span><span class="p">,</span>
   <span class="n">SVGA3D_DXT4</span>                         <span class="o">=</span> <span class="mi">18</span><span class="p">,</span>
   <span class="n">SVGA3D_DXT5</span>                         <span class="o">=</span> <span class="mi">19</span><span class="p">,</span>

   <span class="n">SVGA3D_BUMPU8V8</span>                     <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
   <span class="n">SVGA3D_BUMPL6V5U5</span>                   <span class="o">=</span> <span class="mi">21</span><span class="p">,</span>
   <span class="n">SVGA3D_BUMPX8L8V8U8</span>                 <span class="o">=</span> <span class="mi">22</span><span class="p">,</span>
   <span class="n">SVGA3D_BUMPL8V8U8</span>                   <span class="o">=</span> <span class="mi">23</span><span class="p">,</span>

   <span class="n">SVGA3D_ARGB_S10E5</span>                   <span class="o">=</span> <span class="mi">24</span><span class="p">,</span>   <span class="cm">/* 16-bit floating-point ARGB */</span>
   <span class="n">SVGA3D_ARGB_S23E8</span>                   <span class="o">=</span> <span class="mi">25</span><span class="p">,</span>   <span class="cm">/* 32-bit floating-point ARGB */</span>

   <span class="n">SVGA3D_A2R10G10B10</span>                  <span class="o">=</span> <span class="mi">26</span><span class="p">,</span>

   <span class="cm">/* signed formats */</span>
   <span class="n">SVGA3D_V8U8</span>                         <span class="o">=</span> <span class="mi">27</span><span class="p">,</span>
   <span class="n">SVGA3D_Q8W8V8U8</span>                     <span class="o">=</span> <span class="mi">28</span><span class="p">,</span>
   <span class="n">SVGA3D_CxV8U8</span>                       <span class="o">=</span> <span class="mi">29</span><span class="p">,</span>

   <span class="cm">/* mixed formats */</span>
   <span class="n">SVGA3D_X8L8V8U8</span>                     <span class="o">=</span> <span class="mi">30</span><span class="p">,</span>
   <span class="n">SVGA3D_A2W10V10U10</span>                  <span class="o">=</span> <span class="mi">31</span><span class="p">,</span>

   <span class="n">SVGA3D_ALPHA8</span>                       <span class="o">=</span> <span class="mi">32</span><span class="p">,</span>

   <span class="cm">/* Single- and dual-component floating point formats */</span>
   <span class="n">SVGA3D_R_S10E5</span>                      <span class="o">=</span> <span class="mi">33</span><span class="p">,</span>
   <span class="n">SVGA3D_R_S23E8</span>                      <span class="o">=</span> <span class="mi">34</span><span class="p">,</span>
   <span class="n">SVGA3D_RG_S10E5</span>                     <span class="o">=</span> <span class="mi">35</span><span class="p">,</span>
   <span class="n">SVGA3D_RG_S23E8</span>                     <span class="o">=</span> <span class="mi">36</span><span class="p">,</span>

   <span class="cm">/*</span>
<span class="cm">    * Any surface can be used as a buffer object, but SVGA3D_BUFFER is</span>
<span class="cm">    * the most efficient format to use when creating new surfaces</span>
<span class="cm">    * expressly for index or vertex data.</span>
<span class="cm">    */</span>

   <span class="n">SVGA3D_BUFFER</span>                       <span class="o">=</span> <span class="mi">37</span><span class="p">,</span>

   <span class="n">SVGA3D_Z_D24X8</span>                      <span class="o">=</span> <span class="mi">38</span><span class="p">,</span>

   <span class="n">SVGA3D_V16U16</span>                       <span class="o">=</span> <span class="mi">39</span><span class="p">,</span>

   <span class="n">SVGA3D_G16R16</span>                       <span class="o">=</span> <span class="mi">40</span><span class="p">,</span>
   <span class="n">SVGA3D_A16B16G16R16</span>                 <span class="o">=</span> <span class="mi">41</span><span class="p">,</span>

   <span class="cm">/* Packed Video formats */</span>
   <span class="n">SVGA3D_UYVY</span>                         <span class="o">=</span> <span class="mi">42</span><span class="p">,</span>
   <span class="n">SVGA3D_YUY2</span>                         <span class="o">=</span> <span class="mi">43</span><span class="p">,</span>

   <span class="cm">/* Planar video formats */</span>
   <span class="n">SVGA3D_NV12</span>                         <span class="o">=</span> <span class="mi">44</span><span class="p">,</span>

   <span class="cm">/* Video format with alpha */</span>
   <span class="n">SVGA3D_AYUV</span>                         <span class="o">=</span> <span class="mi">45</span><span class="p">,</span>

   <span class="n">SVGA3D_BC4_UNORM</span>                    <span class="o">=</span> <span class="mi">108</span><span class="p">,</span>
   <span class="n">SVGA3D_BC5_UNORM</span>                    <span class="o">=</span> <span class="mi">111</span><span class="p">,</span>

   <span class="cm">/* Advanced D3D9 depth formats. */</span>
   <span class="n">SVGA3D_Z_DF16</span>                       <span class="o">=</span> <span class="mi">118</span><span class="p">,</span>
   <span class="n">SVGA3D_Z_DF24</span>                       <span class="o">=</span> <span class="mi">119</span><span class="p">,</span>
   <span class="n">SVGA3D_Z_D24S8_INT</span>                  <span class="o">=</span> <span class="mi">120</span><span class="p">,</span>

   <span class="n">SVGA3D_FORMAT_MAX</span>
<span class="p">}</span> <span class="n">SVGA3dSurfaceFormat</span><span class="p">;</span>

<span class="k">typedef</span> <span class="n">uint32</span> <span class="n">SVGA3dColor</span><span class="p">;</span> <span class="cm">/* a, r, g, b */</span>

<span class="cm">/*</span>
<span class="cm"> * These match the D3DFORMAT_OP definitions used by Direct3D. We need</span>
<span class="cm"> * them so that we can query the host for what the supported surface</span>
<span class="cm"> * operations are (when we&#39;re using the D3D backend, in particular),</span>
<span class="cm"> * and so we can send those operations to the guest.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
   <span class="n">SVGA3DFORMAT_OP_TEXTURE</span>                               <span class="o">=</span> <span class="mh">0x00000001</span><span class="p">,</span>
   <span class="n">SVGA3DFORMAT_OP_VOLUMETEXTURE</span>                         <span class="o">=</span> <span class="mh">0x00000002</span><span class="p">,</span>
   <span class="n">SVGA3DFORMAT_OP_CUBETEXTURE</span>                           <span class="o">=</span> <span class="mh">0x00000004</span><span class="p">,</span>
   <span class="n">SVGA3DFORMAT_OP_OFFSCREEN_RENDERTARGET</span>                <span class="o">=</span> <span class="mh">0x00000008</span><span class="p">,</span>
   <span class="n">SVGA3DFORMAT_OP_SAME_FORMAT_RENDERTARGET</span>              <span class="o">=</span> <span class="mh">0x00000010</span><span class="p">,</span>
   <span class="n">SVGA3DFORMAT_OP_ZSTENCIL</span>                              <span class="o">=</span> <span class="mh">0x00000040</span><span class="p">,</span>
   <span class="n">SVGA3DFORMAT_OP_ZSTENCIL_WITH_ARBITRARY_COLOR_DEPTH</span>   <span class="o">=</span> <span class="mh">0x00000080</span><span class="p">,</span>

<span class="cm">/*</span>
<span class="cm"> * This format can be used as a render target if the current display mode</span>
<span class="cm"> * is the same depth if the alpha channel is ignored. e.g. if the device</span>
<span class="cm"> * can render to A8R8G8B8 when the display mode is X8R8G8B8, then the</span>
<span class="cm"> * format op list entry for A8R8G8B8 should have this cap.</span>
<span class="cm"> */</span>
   <span class="n">SVGA3DFORMAT_OP_SAME_FORMAT_UP_TO_ALPHA_RENDERTARGET</span>  <span class="o">=</span> <span class="mh">0x00000100</span><span class="p">,</span>

<span class="cm">/*</span>
<span class="cm"> * This format contains DirectDraw support (including Flip).  This flag</span>
<span class="cm"> * should not to be set on alpha formats.</span>
<span class="cm"> */</span>
   <span class="n">SVGA3DFORMAT_OP_DISPLAYMODE</span>                           <span class="o">=</span> <span class="mh">0x00000400</span><span class="p">,</span>

<span class="cm">/*</span>
<span class="cm"> * The rasterizer can support some level of Direct3D support in this format</span>
<span class="cm"> * and implies that the driver can create a Context in this mode (for some</span>
<span class="cm"> * render target format).  When this flag is set, the SVGA3DFORMAT_OP_DISPLAYMODE</span>
<span class="cm"> * flag must also be set.</span>
<span class="cm"> */</span>
   <span class="n">SVGA3DFORMAT_OP_3DACCELERATION</span>                        <span class="o">=</span> <span class="mh">0x00000800</span><span class="p">,</span>

<span class="cm">/*</span>
<span class="cm"> * This is set for a private format when the driver has put the bpp in</span>
<span class="cm"> * the structure.</span>
<span class="cm"> */</span>
   <span class="n">SVGA3DFORMAT_OP_PIXELSIZE</span>                             <span class="o">=</span> <span class="mh">0x00001000</span><span class="p">,</span>

<span class="cm">/*</span>
<span class="cm"> * Indicates that this format can be converted to any RGB format for which</span>
<span class="cm"> * SVGA3DFORMAT_OP_MEMBEROFGROUP_ARGB is specified</span>
<span class="cm"> */</span>
   <span class="n">SVGA3DFORMAT_OP_CONVERT_TO_ARGB</span>                       <span class="o">=</span> <span class="mh">0x00002000</span><span class="p">,</span>

<span class="cm">/*</span>
<span class="cm"> * Indicates that this format can be used to create offscreen plain surfaces.</span>
<span class="cm"> */</span>
   <span class="n">SVGA3DFORMAT_OP_OFFSCREENPLAIN</span>                        <span class="o">=</span> <span class="mh">0x00004000</span><span class="p">,</span>

<span class="cm">/*</span>
<span class="cm"> * Indicated that this format can be read as an SRGB texture (meaning that the</span>
<span class="cm"> * sampler will linearize the looked up data)</span>
<span class="cm"> */</span>
   <span class="n">SVGA3DFORMAT_OP_SRGBREAD</span>                              <span class="o">=</span> <span class="mh">0x00008000</span><span class="p">,</span>

<span class="cm">/*</span>
<span class="cm"> * Indicates that this format can be used in the bumpmap instructions</span>
<span class="cm"> */</span>
   <span class="n">SVGA3DFORMAT_OP_BUMPMAP</span>                               <span class="o">=</span> <span class="mh">0x00010000</span><span class="p">,</span>

<span class="cm">/*</span>
<span class="cm"> * Indicates that this format can be sampled by the displacement map sampler</span>
<span class="cm"> */</span>
   <span class="n">SVGA3DFORMAT_OP_DMAP</span>                                  <span class="o">=</span> <span class="mh">0x00020000</span><span class="p">,</span>

<span class="cm">/*</span>
<span class="cm"> * Indicates that this format cannot be used with texture filtering</span>
<span class="cm"> */</span>
   <span class="n">SVGA3DFORMAT_OP_NOFILTER</span>                              <span class="o">=</span> <span class="mh">0x00040000</span><span class="p">,</span>

<span class="cm">/*</span>
<span class="cm"> * Indicates that format conversions are supported to this RGB format if</span>
<span class="cm"> * SVGA3DFORMAT_OP_CONVERT_TO_ARGB is specified in the source format.</span>
<span class="cm"> */</span>
   <span class="n">SVGA3DFORMAT_OP_MEMBEROFGROUP_ARGB</span>                    <span class="o">=</span> <span class="mh">0x00080000</span><span class="p">,</span>

<span class="cm">/*</span>
<span class="cm"> * Indicated that this format can be written as an SRGB target (meaning that the</span>
<span class="cm"> * pixel pipe will DE-linearize data on output to format)</span>
<span class="cm"> */</span>
   <span class="n">SVGA3DFORMAT_OP_SRGBWRITE</span>                             <span class="o">=</span> <span class="mh">0x00100000</span><span class="p">,</span>

<span class="cm">/*</span>
<span class="cm"> * Indicates that this format cannot be used with alpha blending</span>
<span class="cm"> */</span>
   <span class="n">SVGA3DFORMAT_OP_NOALPHABLEND</span>                          <span class="o">=</span> <span class="mh">0x00200000</span><span class="p">,</span>

<span class="cm">/*</span>
<span class="cm"> * Indicates that the device can auto-generated sublevels for resources</span>
<span class="cm"> * of this format</span>
<span class="cm"> */</span>
   <span class="n">SVGA3DFORMAT_OP_AUTOGENMIPMAP</span>                         <span class="o">=</span> <span class="mh">0x00400000</span><span class="p">,</span>

<span class="cm">/*</span>
<span class="cm"> * Indicates that this format can be used by vertex texture sampler</span>
<span class="cm"> */</span>
   <span class="n">SVGA3DFORMAT_OP_VERTEXTEXTURE</span>                         <span class="o">=</span> <span class="mh">0x00800000</span><span class="p">,</span>

<span class="cm">/*</span>
<span class="cm"> * Indicates that this format supports neither texture coordinate wrap</span>
<span class="cm"> * modes, nor mipmapping</span>
<span class="cm"> */</span>
   <span class="n">SVGA3DFORMAT_OP_NOTEXCOORDWRAPNORMIP</span>                  <span class="o">=</span> <span class="mh">0x01000000</span>
<span class="p">}</span> <span class="n">SVGA3dFormatOp</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * This structure is a conversion of SVGA3DFORMAT_OP_*.</span>
<span class="cm"> * Entries must be located at the same position.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">union</span> <span class="p">{</span>
   <span class="n">uint32</span> <span class="n">value</span><span class="p">;</span>
   <span class="k">struct</span> <span class="p">{</span>
      <span class="n">uint32</span> <span class="n">texture</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">uint32</span> <span class="n">volumeTexture</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">uint32</span> <span class="n">cubeTexture</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">uint32</span> <span class="n">offscreenRenderTarget</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">uint32</span> <span class="n">sameFormatRenderTarget</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">uint32</span> <span class="n">unknown1</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">uint32</span> <span class="n">zStencil</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">uint32</span> <span class="n">zStencilArbitraryDepth</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">uint32</span> <span class="n">sameFormatUpToAlpha</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">uint32</span> <span class="n">unknown2</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">uint32</span> <span class="n">displayMode</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">uint32</span> <span class="n">acceleration3d</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">uint32</span> <span class="n">pixelSize</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">uint32</span> <span class="n">convertToARGB</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">uint32</span> <span class="n">offscreenPlain</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">uint32</span> <span class="n">sRGBRead</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">uint32</span> <span class="n">bumpMap</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">uint32</span> <span class="n">dmap</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">uint32</span> <span class="n">noFilter</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">uint32</span> <span class="n">memberOfGroupARGB</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">uint32</span> <span class="n">sRGBWrite</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">uint32</span> <span class="n">noAlphaBlend</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">uint32</span> <span class="n">autoGenMipMap</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">uint32</span> <span class="n">vertexTexture</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">uint32</span> <span class="n">noTexCoordWrapNorMip</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
   <span class="p">};</span>
<span class="p">}</span> <span class="n">SVGA3dSurfaceFormatCaps</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * SVGA_3D_CMD_SETRENDERSTATE Types.  All value types</span>
<span class="cm"> * must fit in a uint32.</span>
<span class="cm"> */</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
   <span class="n">SVGA3D_RS_INVALID</span>                   <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
   <span class="n">SVGA3D_RS_ZENABLE</span>                   <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>     <span class="cm">/* SVGA3dBool */</span>
   <span class="n">SVGA3D_RS_ZWRITEENABLE</span>              <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>     <span class="cm">/* SVGA3dBool */</span>
   <span class="n">SVGA3D_RS_ALPHATESTENABLE</span>           <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>     <span class="cm">/* SVGA3dBool */</span>
   <span class="n">SVGA3D_RS_DITHERENABLE</span>              <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>     <span class="cm">/* SVGA3dBool */</span>
   <span class="n">SVGA3D_RS_BLENDENABLE</span>               <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>     <span class="cm">/* SVGA3dBool */</span>
   <span class="n">SVGA3D_RS_FOGENABLE</span>                 <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>     <span class="cm">/* SVGA3dBool */</span>
   <span class="n">SVGA3D_RS_SPECULARENABLE</span>            <span class="o">=</span> <span class="mi">7</span><span class="p">,</span>     <span class="cm">/* SVGA3dBool */</span>
   <span class="n">SVGA3D_RS_STENCILENABLE</span>             <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>     <span class="cm">/* SVGA3dBool */</span>
   <span class="n">SVGA3D_RS_LIGHTINGENABLE</span>            <span class="o">=</span> <span class="mi">9</span><span class="p">,</span>     <span class="cm">/* SVGA3dBool */</span>
   <span class="n">SVGA3D_RS_NORMALIZENORMALS</span>          <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>    <span class="cm">/* SVGA3dBool */</span>
   <span class="n">SVGA3D_RS_POINTSPRITEENABLE</span>         <span class="o">=</span> <span class="mi">11</span><span class="p">,</span>    <span class="cm">/* SVGA3dBool */</span>
   <span class="n">SVGA3D_RS_POINTSCALEENABLE</span>          <span class="o">=</span> <span class="mi">12</span><span class="p">,</span>    <span class="cm">/* SVGA3dBool */</span>
   <span class="n">SVGA3D_RS_STENCILREF</span>                <span class="o">=</span> <span class="mi">13</span><span class="p">,</span>    <span class="cm">/* uint32 */</span>
   <span class="n">SVGA3D_RS_STENCILMASK</span>               <span class="o">=</span> <span class="mi">14</span><span class="p">,</span>    <span class="cm">/* uint32 */</span>
   <span class="n">SVGA3D_RS_STENCILWRITEMASK</span>          <span class="o">=</span> <span class="mi">15</span><span class="p">,</span>    <span class="cm">/* uint32 */</span>
   <span class="n">SVGA3D_RS_FOGSTART</span>                  <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>    <span class="cm">/* float */</span>
   <span class="n">SVGA3D_RS_FOGEND</span>                    <span class="o">=</span> <span class="mi">17</span><span class="p">,</span>    <span class="cm">/* float */</span>
   <span class="n">SVGA3D_RS_FOGDENSITY</span>                <span class="o">=</span> <span class="mi">18</span><span class="p">,</span>    <span class="cm">/* float */</span>
   <span class="n">SVGA3D_RS_POINTSIZE</span>                 <span class="o">=</span> <span class="mi">19</span><span class="p">,</span>    <span class="cm">/* float */</span>
   <span class="n">SVGA3D_RS_POINTSIZEMIN</span>              <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>    <span class="cm">/* float */</span>
   <span class="n">SVGA3D_RS_POINTSIZEMAX</span>              <span class="o">=</span> <span class="mi">21</span><span class="p">,</span>    <span class="cm">/* float */</span>
   <span class="n">SVGA3D_RS_POINTSCALE_A</span>              <span class="o">=</span> <span class="mi">22</span><span class="p">,</span>    <span class="cm">/* float */</span>
   <span class="n">SVGA3D_RS_POINTSCALE_B</span>              <span class="o">=</span> <span class="mi">23</span><span class="p">,</span>    <span class="cm">/* float */</span>
   <span class="n">SVGA3D_RS_POINTSCALE_C</span>              <span class="o">=</span> <span class="mi">24</span><span class="p">,</span>    <span class="cm">/* float */</span>
   <span class="n">SVGA3D_RS_FOGCOLOR</span>                  <span class="o">=</span> <span class="mi">25</span><span class="p">,</span>    <span class="cm">/* SVGA3dColor */</span>
   <span class="n">SVGA3D_RS_AMBIENT</span>                   <span class="o">=</span> <span class="mi">26</span><span class="p">,</span>    <span class="cm">/* SVGA3dColor */</span>
   <span class="n">SVGA3D_RS_CLIPPLANEENABLE</span>           <span class="o">=</span> <span class="mi">27</span><span class="p">,</span>    <span class="cm">/* SVGA3dClipPlanes */</span>
   <span class="n">SVGA3D_RS_FOGMODE</span>                   <span class="o">=</span> <span class="mi">28</span><span class="p">,</span>    <span class="cm">/* SVGA3dFogMode */</span>
   <span class="n">SVGA3D_RS_FILLMODE</span>                  <span class="o">=</span> <span class="mi">29</span><span class="p">,</span>    <span class="cm">/* SVGA3dFillMode */</span>
   <span class="n">SVGA3D_RS_SHADEMODE</span>                 <span class="o">=</span> <span class="mi">30</span><span class="p">,</span>    <span class="cm">/* SVGA3dShadeMode */</span>
   <span class="n">SVGA3D_RS_LINEPATTERN</span>               <span class="o">=</span> <span class="mi">31</span><span class="p">,</span>    <span class="cm">/* SVGA3dLinePattern */</span>
   <span class="n">SVGA3D_RS_SRCBLEND</span>                  <span class="o">=</span> <span class="mi">32</span><span class="p">,</span>    <span class="cm">/* SVGA3dBlendOp */</span>
   <span class="n">SVGA3D_RS_DSTBLEND</span>                  <span class="o">=</span> <span class="mi">33</span><span class="p">,</span>    <span class="cm">/* SVGA3dBlendOp */</span>
   <span class="n">SVGA3D_RS_BLENDEQUATION</span>             <span class="o">=</span> <span class="mi">34</span><span class="p">,</span>    <span class="cm">/* SVGA3dBlendEquation */</span>
   <span class="n">SVGA3D_RS_CULLMODE</span>                  <span class="o">=</span> <span class="mi">35</span><span class="p">,</span>    <span class="cm">/* SVGA3dFace */</span>
   <span class="n">SVGA3D_RS_ZFUNC</span>                     <span class="o">=</span> <span class="mi">36</span><span class="p">,</span>    <span class="cm">/* SVGA3dCmpFunc */</span>
   <span class="n">SVGA3D_RS_ALPHAFUNC</span>                 <span class="o">=</span> <span class="mi">37</span><span class="p">,</span>    <span class="cm">/* SVGA3dCmpFunc */</span>
   <span class="n">SVGA3D_RS_STENCILFUNC</span>               <span class="o">=</span> <span class="mi">38</span><span class="p">,</span>    <span class="cm">/* SVGA3dCmpFunc */</span>
   <span class="n">SVGA3D_RS_STENCILFAIL</span>               <span class="o">=</span> <span class="mi">39</span><span class="p">,</span>    <span class="cm">/* SVGA3dStencilOp */</span>
   <span class="n">SVGA3D_RS_STENCILZFAIL</span>              <span class="o">=</span> <span class="mi">40</span><span class="p">,</span>    <span class="cm">/* SVGA3dStencilOp */</span>
   <span class="n">SVGA3D_RS_STENCILPASS</span>               <span class="o">=</span> <span class="mi">41</span><span class="p">,</span>    <span class="cm">/* SVGA3dStencilOp */</span>
   <span class="n">SVGA3D_RS_ALPHAREF</span>                  <span class="o">=</span> <span class="mi">42</span><span class="p">,</span>    <span class="cm">/* float (0.0 .. 1.0) */</span>
   <span class="n">SVGA3D_RS_FRONTWINDING</span>              <span class="o">=</span> <span class="mi">43</span><span class="p">,</span>    <span class="cm">/* SVGA3dFrontWinding */</span>
   <span class="n">SVGA3D_RS_COORDINATETYPE</span>            <span class="o">=</span> <span class="mi">44</span><span class="p">,</span>    <span class="cm">/* SVGA3dCoordinateType */</span>
   <span class="n">SVGA3D_RS_ZBIAS</span>                     <span class="o">=</span> <span class="mi">45</span><span class="p">,</span>    <span class="cm">/* float */</span>
   <span class="n">SVGA3D_RS_RANGEFOGENABLE</span>            <span class="o">=</span> <span class="mi">46</span><span class="p">,</span>    <span class="cm">/* SVGA3dBool */</span>
   <span class="n">SVGA3D_RS_COLORWRITEENABLE</span>          <span class="o">=</span> <span class="mi">47</span><span class="p">,</span>    <span class="cm">/* SVGA3dColorMask */</span>
   <span class="n">SVGA3D_RS_VERTEXMATERIALENABLE</span>      <span class="o">=</span> <span class="mi">48</span><span class="p">,</span>    <span class="cm">/* SVGA3dBool */</span>
   <span class="n">SVGA3D_RS_DIFFUSEMATERIALSOURCE</span>     <span class="o">=</span> <span class="mi">49</span><span class="p">,</span>    <span class="cm">/* SVGA3dVertexMaterial */</span>
   <span class="n">SVGA3D_RS_SPECULARMATERIALSOURCE</span>    <span class="o">=</span> <span class="mi">50</span><span class="p">,</span>    <span class="cm">/* SVGA3dVertexMaterial */</span>
   <span class="n">SVGA3D_RS_AMBIENTMATERIALSOURCE</span>     <span class="o">=</span> <span class="mi">51</span><span class="p">,</span>    <span class="cm">/* SVGA3dVertexMaterial */</span>
   <span class="n">SVGA3D_RS_EMISSIVEMATERIALSOURCE</span>    <span class="o">=</span> <span class="mi">52</span><span class="p">,</span>    <span class="cm">/* SVGA3dVertexMaterial */</span>
   <span class="n">SVGA3D_RS_TEXTUREFACTOR</span>             <span class="o">=</span> <span class="mi">53</span><span class="p">,</span>    <span class="cm">/* SVGA3dColor */</span>
   <span class="n">SVGA3D_RS_LOCALVIEWER</span>               <span class="o">=</span> <span class="mi">54</span><span class="p">,</span>    <span class="cm">/* SVGA3dBool */</span>
   <span class="n">SVGA3D_RS_SCISSORTESTENABLE</span>         <span class="o">=</span> <span class="mi">55</span><span class="p">,</span>    <span class="cm">/* SVGA3dBool */</span>
   <span class="n">SVGA3D_RS_BLENDCOLOR</span>                <span class="o">=</span> <span class="mi">56</span><span class="p">,</span>    <span class="cm">/* SVGA3dColor */</span>
   <span class="n">SVGA3D_RS_STENCILENABLE2SIDED</span>       <span class="o">=</span> <span class="mi">57</span><span class="p">,</span>    <span class="cm">/* SVGA3dBool */</span>
   <span class="n">SVGA3D_RS_CCWSTENCILFUNC</span>            <span class="o">=</span> <span class="mi">58</span><span class="p">,</span>    <span class="cm">/* SVGA3dCmpFunc */</span>
   <span class="n">SVGA3D_RS_CCWSTENCILFAIL</span>            <span class="o">=</span> <span class="mi">59</span><span class="p">,</span>    <span class="cm">/* SVGA3dStencilOp */</span>
   <span class="n">SVGA3D_RS_CCWSTENCILZFAIL</span>           <span class="o">=</span> <span class="mi">60</span><span class="p">,</span>    <span class="cm">/* SVGA3dStencilOp */</span>
   <span class="n">SVGA3D_RS_CCWSTENCILPASS</span>            <span class="o">=</span> <span class="mi">61</span><span class="p">,</span>    <span class="cm">/* SVGA3dStencilOp */</span>
   <span class="n">SVGA3D_RS_VERTEXBLEND</span>               <span class="o">=</span> <span class="mi">62</span><span class="p">,</span>    <span class="cm">/* SVGA3dVertexBlendFlags */</span>
   <span class="n">SVGA3D_RS_SLOPESCALEDEPTHBIAS</span>       <span class="o">=</span> <span class="mi">63</span><span class="p">,</span>    <span class="cm">/* float */</span>
   <span class="n">SVGA3D_RS_DEPTHBIAS</span>                 <span class="o">=</span> <span class="mi">64</span><span class="p">,</span>    <span class="cm">/* float */</span>


   <span class="cm">/*</span>
<span class="cm">    * Output Gamma Level</span>
<span class="cm">    *</span>
<span class="cm">    * Output gamma effects the gamma curve of colors that are output from the</span>
<span class="cm">    * rendering pipeline.  A value of 1.0 specifies a linear color space. If the</span>
<span class="cm">    * value is &lt;= 0.0, gamma correction is ignored and linear color space is</span>
<span class="cm">    * used.</span>
<span class="cm">    */</span>

   <span class="n">SVGA3D_RS_OUTPUTGAMMA</span>               <span class="o">=</span> <span class="mi">65</span><span class="p">,</span>    <span class="cm">/* float */</span>
   <span class="n">SVGA3D_RS_ZVISIBLE</span>                  <span class="o">=</span> <span class="mi">66</span><span class="p">,</span>    <span class="cm">/* SVGA3dBool */</span>
   <span class="n">SVGA3D_RS_LASTPIXEL</span>                 <span class="o">=</span> <span class="mi">67</span><span class="p">,</span>    <span class="cm">/* SVGA3dBool */</span>
   <span class="n">SVGA3D_RS_CLIPPING</span>                  <span class="o">=</span> <span class="mi">68</span><span class="p">,</span>    <span class="cm">/* SVGA3dBool */</span>
   <span class="n">SVGA3D_RS_WRAP0</span>                     <span class="o">=</span> <span class="mi">69</span><span class="p">,</span>    <span class="cm">/* SVGA3dWrapFlags */</span>
   <span class="n">SVGA3D_RS_WRAP1</span>                     <span class="o">=</span> <span class="mi">70</span><span class="p">,</span>    <span class="cm">/* SVGA3dWrapFlags */</span>
   <span class="n">SVGA3D_RS_WRAP2</span>                     <span class="o">=</span> <span class="mi">71</span><span class="p">,</span>    <span class="cm">/* SVGA3dWrapFlags */</span>
   <span class="n">SVGA3D_RS_WRAP3</span>                     <span class="o">=</span> <span class="mi">72</span><span class="p">,</span>    <span class="cm">/* SVGA3dWrapFlags */</span>
   <span class="n">SVGA3D_RS_WRAP4</span>                     <span class="o">=</span> <span class="mi">73</span><span class="p">,</span>    <span class="cm">/* SVGA3dWrapFlags */</span>
   <span class="n">SVGA3D_RS_WRAP5</span>                     <span class="o">=</span> <span class="mi">74</span><span class="p">,</span>    <span class="cm">/* SVGA3dWrapFlags */</span>
   <span class="n">SVGA3D_RS_WRAP6</span>                     <span class="o">=</span> <span class="mi">75</span><span class="p">,</span>    <span class="cm">/* SVGA3dWrapFlags */</span>
   <span class="n">SVGA3D_RS_WRAP7</span>                     <span class="o">=</span> <span class="mi">76</span><span class="p">,</span>    <span class="cm">/* SVGA3dWrapFlags */</span>
   <span class="n">SVGA3D_RS_WRAP8</span>                     <span class="o">=</span> <span class="mi">77</span><span class="p">,</span>    <span class="cm">/* SVGA3dWrapFlags */</span>
   <span class="n">SVGA3D_RS_WRAP9</span>                     <span class="o">=</span> <span class="mi">78</span><span class="p">,</span>    <span class="cm">/* SVGA3dWrapFlags */</span>
   <span class="n">SVGA3D_RS_WRAP10</span>                    <span class="o">=</span> <span class="mi">79</span><span class="p">,</span>    <span class="cm">/* SVGA3dWrapFlags */</span>
   <span class="n">SVGA3D_RS_WRAP11</span>                    <span class="o">=</span> <span class="mi">80</span><span class="p">,</span>    <span class="cm">/* SVGA3dWrapFlags */</span>
   <span class="n">SVGA3D_RS_WRAP12</span>                    <span class="o">=</span> <span class="mi">81</span><span class="p">,</span>    <span class="cm">/* SVGA3dWrapFlags */</span>
   <span class="n">SVGA3D_RS_WRAP13</span>                    <span class="o">=</span> <span class="mi">82</span><span class="p">,</span>    <span class="cm">/* SVGA3dWrapFlags */</span>
   <span class="n">SVGA3D_RS_WRAP14</span>                    <span class="o">=</span> <span class="mi">83</span><span class="p">,</span>    <span class="cm">/* SVGA3dWrapFlags */</span>
   <span class="n">SVGA3D_RS_WRAP15</span>                    <span class="o">=</span> <span class="mi">84</span><span class="p">,</span>    <span class="cm">/* SVGA3dWrapFlags */</span>
   <span class="n">SVGA3D_RS_MULTISAMPLEANTIALIAS</span>      <span class="o">=</span> <span class="mi">85</span><span class="p">,</span>    <span class="cm">/* SVGA3dBool */</span>
   <span class="n">SVGA3D_RS_MULTISAMPLEMASK</span>           <span class="o">=</span> <span class="mi">86</span><span class="p">,</span>    <span class="cm">/* uint32 */</span>
   <span class="n">SVGA3D_RS_INDEXEDVERTEXBLENDENABLE</span>  <span class="o">=</span> <span class="mi">87</span><span class="p">,</span>    <span class="cm">/* SVGA3dBool */</span>
   <span class="n">SVGA3D_RS_TWEENFACTOR</span>               <span class="o">=</span> <span class="mi">88</span><span class="p">,</span>    <span class="cm">/* float */</span>
   <span class="n">SVGA3D_RS_ANTIALIASEDLINEENABLE</span>     <span class="o">=</span> <span class="mi">89</span><span class="p">,</span>    <span class="cm">/* SVGA3dBool */</span>
   <span class="n">SVGA3D_RS_COLORWRITEENABLE1</span>         <span class="o">=</span> <span class="mi">90</span><span class="p">,</span>    <span class="cm">/* SVGA3dColorMask */</span>
   <span class="n">SVGA3D_RS_COLORWRITEENABLE2</span>         <span class="o">=</span> <span class="mi">91</span><span class="p">,</span>    <span class="cm">/* SVGA3dColorMask */</span>
   <span class="n">SVGA3D_RS_COLORWRITEENABLE3</span>         <span class="o">=</span> <span class="mi">92</span><span class="p">,</span>    <span class="cm">/* SVGA3dColorMask */</span>
   <span class="n">SVGA3D_RS_SEPARATEALPHABLENDENABLE</span>  <span class="o">=</span> <span class="mi">93</span><span class="p">,</span>    <span class="cm">/* SVGA3dBool */</span>
   <span class="n">SVGA3D_RS_SRCBLENDALPHA</span>             <span class="o">=</span> <span class="mi">94</span><span class="p">,</span>    <span class="cm">/* SVGA3dBlendOp */</span>
   <span class="n">SVGA3D_RS_DSTBLENDALPHA</span>             <span class="o">=</span> <span class="mi">95</span><span class="p">,</span>    <span class="cm">/* SVGA3dBlendOp */</span>
   <span class="n">SVGA3D_RS_BLENDEQUATIONALPHA</span>        <span class="o">=</span> <span class="mi">96</span><span class="p">,</span>    <span class="cm">/* SVGA3dBlendEquation */</span>
   <span class="n">SVGA3D_RS_TRANSPARENCYANTIALIAS</span>     <span class="o">=</span> <span class="mi">97</span><span class="p">,</span>    <span class="cm">/* SVGA3dTransparencyAntialiasType */</span>
   <span class="n">SVGA3D_RS_LINEAA</span>                    <span class="o">=</span> <span class="mi">98</span><span class="p">,</span>    <span class="cm">/* SVGA3dBool */</span>
   <span class="n">SVGA3D_RS_LINEWIDTH</span>                 <span class="o">=</span> <span class="mi">99</span><span class="p">,</span>    <span class="cm">/* float */</span>
   <span class="n">SVGA3D_RS_MAX</span>
<span class="p">}</span> <span class="n">SVGA3dRenderStateName</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
   <span class="n">SVGA3D_TRANSPARENCYANTIALIAS_NORMAL</span>            <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
   <span class="n">SVGA3D_TRANSPARENCYANTIALIAS_ALPHATOCOVERAGE</span>   <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
   <span class="n">SVGA3D_TRANSPARENCYANTIALIAS_SUPERSAMPLE</span>       <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
   <span class="n">SVGA3D_TRANSPARENCYANTIALIAS_MAX</span>
<span class="p">}</span> <span class="n">SVGA3dTransparencyAntialiasType</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
   <span class="n">SVGA3D_VERTEXMATERIAL_NONE</span>     <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>    <span class="cm">/* Use the value in the current material */</span>
   <span class="n">SVGA3D_VERTEXMATERIAL_DIFFUSE</span>  <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>    <span class="cm">/* Use the value in the diffuse component */</span>
   <span class="n">SVGA3D_VERTEXMATERIAL_SPECULAR</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>    <span class="cm">/* Use the value in the specular component */</span>
<span class="p">}</span> <span class="n">SVGA3dVertexMaterial</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
   <span class="n">SVGA3D_FILLMODE_INVALID</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
   <span class="n">SVGA3D_FILLMODE_POINT</span>   <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
   <span class="n">SVGA3D_FILLMODE_LINE</span>    <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
   <span class="n">SVGA3D_FILLMODE_FILL</span>    <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
   <span class="n">SVGA3D_FILLMODE_MAX</span>
<span class="p">}</span> <span class="n">SVGA3dFillModeType</span><span class="p">;</span>


<span class="k">typedef</span>
<span class="k">union</span> <span class="p">{</span>
   <span class="k">struct</span> <span class="p">{</span>
      <span class="n">uint16</span>   <span class="n">mode</span><span class="p">;</span>       <span class="cm">/* SVGA3dFillModeType */</span>
      <span class="n">uint16</span>   <span class="n">face</span><span class="p">;</span>       <span class="cm">/* SVGA3dFace */</span>
   <span class="p">};</span>
   <span class="n">uint32</span> <span class="n">uintValue</span><span class="p">;</span>
<span class="p">}</span> <span class="n">SVGA3dFillMode</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
   <span class="n">SVGA3D_SHADEMODE_INVALID</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
   <span class="n">SVGA3D_SHADEMODE_FLAT</span>    <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
   <span class="n">SVGA3D_SHADEMODE_SMOOTH</span>  <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
   <span class="n">SVGA3D_SHADEMODE_PHONG</span>   <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>     <span class="cm">/* Not supported */</span>
   <span class="n">SVGA3D_SHADEMODE_MAX</span>
<span class="p">}</span> <span class="n">SVGA3dShadeMode</span><span class="p">;</span>

<span class="k">typedef</span>
<span class="k">union</span> <span class="p">{</span>
   <span class="k">struct</span> <span class="p">{</span>
      <span class="n">uint16</span> <span class="n">repeat</span><span class="p">;</span>
      <span class="n">uint16</span> <span class="n">pattern</span><span class="p">;</span>
   <span class="p">};</span>
   <span class="n">uint32</span> <span class="n">uintValue</span><span class="p">;</span>
<span class="p">}</span> <span class="n">SVGA3dLinePattern</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
   <span class="n">SVGA3D_BLENDOP_INVALID</span>            <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
   <span class="n">SVGA3D_BLENDOP_ZERO</span>               <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
   <span class="n">SVGA3D_BLENDOP_ONE</span>                <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
   <span class="n">SVGA3D_BLENDOP_SRCCOLOR</span>           <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
   <span class="n">SVGA3D_BLENDOP_INVSRCCOLOR</span>        <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
   <span class="n">SVGA3D_BLENDOP_SRCALPHA</span>           <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
   <span class="n">SVGA3D_BLENDOP_INVSRCALPHA</span>        <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
   <span class="n">SVGA3D_BLENDOP_DESTALPHA</span>          <span class="o">=</span> <span class="mi">7</span><span class="p">,</span>
   <span class="n">SVGA3D_BLENDOP_INVDESTALPHA</span>       <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
   <span class="n">SVGA3D_BLENDOP_DESTCOLOR</span>          <span class="o">=</span> <span class="mi">9</span><span class="p">,</span>
   <span class="n">SVGA3D_BLENDOP_INVDESTCOLOR</span>       <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
   <span class="n">SVGA3D_BLENDOP_SRCALPHASAT</span>        <span class="o">=</span> <span class="mi">11</span><span class="p">,</span>
   <span class="n">SVGA3D_BLENDOP_BLENDFACTOR</span>        <span class="o">=</span> <span class="mi">12</span><span class="p">,</span>
   <span class="n">SVGA3D_BLENDOP_INVBLENDFACTOR</span>     <span class="o">=</span> <span class="mi">13</span><span class="p">,</span>
   <span class="n">SVGA3D_BLENDOP_MAX</span>
<span class="p">}</span> <span class="n">SVGA3dBlendOp</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
   <span class="n">SVGA3D_BLENDEQ_INVALID</span>            <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
   <span class="n">SVGA3D_BLENDEQ_ADD</span>                <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
   <span class="n">SVGA3D_BLENDEQ_SUBTRACT</span>           <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
   <span class="n">SVGA3D_BLENDEQ_REVSUBTRACT</span>        <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
   <span class="n">SVGA3D_BLENDEQ_MINIMUM</span>            <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
   <span class="n">SVGA3D_BLENDEQ_MAXIMUM</span>            <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
   <span class="n">SVGA3D_BLENDEQ_MAX</span>
<span class="p">}</span> <span class="n">SVGA3dBlendEquation</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
   <span class="n">SVGA3D_FRONTWINDING_INVALID</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
   <span class="n">SVGA3D_FRONTWINDING_CW</span>      <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
   <span class="n">SVGA3D_FRONTWINDING_CCW</span>     <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
   <span class="n">SVGA3D_FRONTWINDING_MAX</span>
<span class="p">}</span> <span class="n">SVGA3dFrontWinding</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
   <span class="n">SVGA3D_FACE_INVALID</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
   <span class="n">SVGA3D_FACE_NONE</span>     <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
   <span class="n">SVGA3D_FACE_FRONT</span>    <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
   <span class="n">SVGA3D_FACE_BACK</span>     <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
   <span class="n">SVGA3D_FACE_FRONT_BACK</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
   <span class="n">SVGA3D_FACE_MAX</span>
<span class="p">}</span> <span class="n">SVGA3dFace</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * The order and the values should not be changed</span>
<span class="cm"> */</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
   <span class="n">SVGA3D_CMP_INVALID</span>              <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
   <span class="n">SVGA3D_CMP_NEVER</span>                <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
   <span class="n">SVGA3D_CMP_LESS</span>                 <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
   <span class="n">SVGA3D_CMP_EQUAL</span>                <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
   <span class="n">SVGA3D_CMP_LESSEQUAL</span>            <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
   <span class="n">SVGA3D_CMP_GREATER</span>              <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
   <span class="n">SVGA3D_CMP_NOTEQUAL</span>             <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
   <span class="n">SVGA3D_CMP_GREATEREQUAL</span>         <span class="o">=</span> <span class="mi">7</span><span class="p">,</span>
   <span class="n">SVGA3D_CMP_ALWAYS</span>               <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
   <span class="n">SVGA3D_CMP_MAX</span>
<span class="p">}</span> <span class="n">SVGA3dCmpFunc</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * SVGA3D_FOGFUNC_* specifies the fog equation, or PER_VERTEX which allows</span>
<span class="cm"> * the fog factor to be specified in the alpha component of the specular</span>
<span class="cm"> * (a.k.a. secondary) vertex color.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
   <span class="n">SVGA3D_FOGFUNC_INVALID</span>          <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
   <span class="n">SVGA3D_FOGFUNC_EXP</span>              <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
   <span class="n">SVGA3D_FOGFUNC_EXP2</span>             <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
   <span class="n">SVGA3D_FOGFUNC_LINEAR</span>           <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
   <span class="n">SVGA3D_FOGFUNC_PER_VERTEX</span>       <span class="o">=</span> <span class="mi">4</span>
<span class="p">}</span> <span class="n">SVGA3dFogFunction</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * SVGA3D_FOGTYPE_* specifies if fog factors are computed on a per-vertex</span>
<span class="cm"> * or per-pixel basis.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
   <span class="n">SVGA3D_FOGTYPE_INVALID</span>          <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
   <span class="n">SVGA3D_FOGTYPE_VERTEX</span>           <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
   <span class="n">SVGA3D_FOGTYPE_PIXEL</span>            <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
   <span class="n">SVGA3D_FOGTYPE_MAX</span>              <span class="o">=</span> <span class="mi">3</span>
<span class="p">}</span> <span class="n">SVGA3dFogType</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * SVGA3D_FOGBASE_* selects depth or range-based fog. Depth-based fog is</span>
<span class="cm"> * computed using the eye Z value of each pixel (or vertex), whereas range-</span>
<span class="cm"> * based fog is computed using the actual distance (range) to the eye.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
   <span class="n">SVGA3D_FOGBASE_INVALID</span>          <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
   <span class="n">SVGA3D_FOGBASE_DEPTHBASED</span>       <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
   <span class="n">SVGA3D_FOGBASE_RANGEBASED</span>       <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
   <span class="n">SVGA3D_FOGBASE_MAX</span>              <span class="o">=</span> <span class="mi">3</span>
<span class="p">}</span> <span class="n">SVGA3dFogBase</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
   <span class="n">SVGA3D_STENCILOP_INVALID</span>        <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
   <span class="n">SVGA3D_STENCILOP_KEEP</span>           <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
   <span class="n">SVGA3D_STENCILOP_ZERO</span>           <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
   <span class="n">SVGA3D_STENCILOP_REPLACE</span>        <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
   <span class="n">SVGA3D_STENCILOP_INCRSAT</span>        <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
   <span class="n">SVGA3D_STENCILOP_DECRSAT</span>        <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
   <span class="n">SVGA3D_STENCILOP_INVERT</span>         <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
   <span class="n">SVGA3D_STENCILOP_INCR</span>           <span class="o">=</span> <span class="mi">7</span><span class="p">,</span>
   <span class="n">SVGA3D_STENCILOP_DECR</span>           <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
   <span class="n">SVGA3D_STENCILOP_MAX</span>
<span class="p">}</span> <span class="n">SVGA3dStencilOp</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
   <span class="n">SVGA3D_CLIPPLANE_0</span>              <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">),</span>
   <span class="n">SVGA3D_CLIPPLANE_1</span>              <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span>
   <span class="n">SVGA3D_CLIPPLANE_2</span>              <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">),</span>
   <span class="n">SVGA3D_CLIPPLANE_3</span>              <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">),</span>
   <span class="n">SVGA3D_CLIPPLANE_4</span>              <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">),</span>
   <span class="n">SVGA3D_CLIPPLANE_5</span>              <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">),</span>
<span class="p">}</span> <span class="n">SVGA3dClipPlanes</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
   <span class="n">SVGA3D_CLEAR_COLOR</span>              <span class="o">=</span> <span class="mh">0x1</span><span class="p">,</span>
   <span class="n">SVGA3D_CLEAR_DEPTH</span>              <span class="o">=</span> <span class="mh">0x2</span><span class="p">,</span>
   <span class="n">SVGA3D_CLEAR_STENCIL</span>            <span class="o">=</span> <span class="mh">0x4</span>
<span class="p">}</span> <span class="n">SVGA3dClearFlag</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
   <span class="n">SVGA3D_RT_DEPTH</span>                 <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
   <span class="n">SVGA3D_RT_STENCIL</span>               <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
   <span class="n">SVGA3D_RT_COLOR0</span>                <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
   <span class="n">SVGA3D_RT_COLOR1</span>                <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
   <span class="n">SVGA3D_RT_COLOR2</span>                <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
   <span class="n">SVGA3D_RT_COLOR3</span>                <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
   <span class="n">SVGA3D_RT_COLOR4</span>                <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
   <span class="n">SVGA3D_RT_COLOR5</span>                <span class="o">=</span> <span class="mi">7</span><span class="p">,</span>
   <span class="n">SVGA3D_RT_COLOR6</span>                <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
   <span class="n">SVGA3D_RT_COLOR7</span>                <span class="o">=</span> <span class="mi">9</span><span class="p">,</span>
   <span class="n">SVGA3D_RT_MAX</span><span class="p">,</span>
   <span class="n">SVGA3D_RT_INVALID</span>               <span class="o">=</span> <span class="p">((</span><span class="n">uint32</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span>
<span class="p">}</span> <span class="n">SVGA3dRenderTargetType</span><span class="p">;</span>

<span class="cp">#define SVGA3D_MAX_RT_COLOR (SVGA3D_RT_COLOR7 - SVGA3D_RT_COLOR0 + 1)</span>

<span class="k">typedef</span>
<span class="k">union</span> <span class="p">{</span>
   <span class="k">struct</span> <span class="p">{</span>
      <span class="n">uint32</span>  <span class="n">red</span>   <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">uint32</span>  <span class="n">green</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">uint32</span>  <span class="n">blue</span>  <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">uint32</span>  <span class="n">alpha</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
   <span class="p">};</span>
   <span class="n">uint32</span> <span class="n">uintValue</span><span class="p">;</span>
<span class="p">}</span> <span class="n">SVGA3dColorMask</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
   <span class="n">SVGA3D_VBLEND_DISABLE</span>            <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
   <span class="n">SVGA3D_VBLEND_1WEIGHT</span>            <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
   <span class="n">SVGA3D_VBLEND_2WEIGHT</span>            <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
   <span class="n">SVGA3D_VBLEND_3WEIGHT</span>            <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
<span class="p">}</span> <span class="n">SVGA3dVertexBlendFlags</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
   <span class="n">SVGA3D_WRAPCOORD_0</span>   <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">,</span>
   <span class="n">SVGA3D_WRAPCOORD_1</span>   <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span>
   <span class="n">SVGA3D_WRAPCOORD_2</span>   <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">,</span>
   <span class="n">SVGA3D_WRAPCOORD_3</span>   <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">,</span>
   <span class="n">SVGA3D_WRAPCOORD_ALL</span> <span class="o">=</span> <span class="mh">0xF</span><span class="p">,</span>
<span class="p">}</span> <span class="n">SVGA3dWrapFlags</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * SVGA_3D_CMD_TEXTURESTATE Types.  All value types</span>
<span class="cm"> * must fit in a uint32.</span>
<span class="cm"> */</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
   <span class="n">SVGA3D_TS_INVALID</span>                    <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
   <span class="n">SVGA3D_TS_BIND_TEXTURE</span>               <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>    <span class="cm">/* SVGA3dSurfaceId */</span>
   <span class="n">SVGA3D_TS_COLOROP</span>                    <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>    <span class="cm">/* SVGA3dTextureCombiner */</span>
   <span class="n">SVGA3D_TS_COLORARG1</span>                  <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>    <span class="cm">/* SVGA3dTextureArgData */</span>
   <span class="n">SVGA3D_TS_COLORARG2</span>                  <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>    <span class="cm">/* SVGA3dTextureArgData */</span>
   <span class="n">SVGA3D_TS_ALPHAOP</span>                    <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>    <span class="cm">/* SVGA3dTextureCombiner */</span>
   <span class="n">SVGA3D_TS_ALPHAARG1</span>                  <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>    <span class="cm">/* SVGA3dTextureArgData */</span>
   <span class="n">SVGA3D_TS_ALPHAARG2</span>                  <span class="o">=</span> <span class="mi">7</span><span class="p">,</span>    <span class="cm">/* SVGA3dTextureArgData */</span>
   <span class="n">SVGA3D_TS_ADDRESSU</span>                   <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>    <span class="cm">/* SVGA3dTextureAddress */</span>
   <span class="n">SVGA3D_TS_ADDRESSV</span>                   <span class="o">=</span> <span class="mi">9</span><span class="p">,</span>    <span class="cm">/* SVGA3dTextureAddress */</span>
   <span class="n">SVGA3D_TS_MIPFILTER</span>                  <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>   <span class="cm">/* SVGA3dTextureFilter */</span>
   <span class="n">SVGA3D_TS_MAGFILTER</span>                  <span class="o">=</span> <span class="mi">11</span><span class="p">,</span>   <span class="cm">/* SVGA3dTextureFilter */</span>
   <span class="n">SVGA3D_TS_MINFILTER</span>                  <span class="o">=</span> <span class="mi">12</span><span class="p">,</span>   <span class="cm">/* SVGA3dTextureFilter */</span>
   <span class="n">SVGA3D_TS_BORDERCOLOR</span>                <span class="o">=</span> <span class="mi">13</span><span class="p">,</span>   <span class="cm">/* SVGA3dColor */</span>
   <span class="n">SVGA3D_TS_TEXCOORDINDEX</span>              <span class="o">=</span> <span class="mi">14</span><span class="p">,</span>   <span class="cm">/* uint32 */</span>
   <span class="n">SVGA3D_TS_TEXTURETRANSFORMFLAGS</span>      <span class="o">=</span> <span class="mi">15</span><span class="p">,</span>   <span class="cm">/* SVGA3dTexTransformFlags */</span>
   <span class="n">SVGA3D_TS_TEXCOORDGEN</span>                <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>   <span class="cm">/* SVGA3dTextureCoordGen */</span>
   <span class="n">SVGA3D_TS_BUMPENVMAT00</span>               <span class="o">=</span> <span class="mi">17</span><span class="p">,</span>   <span class="cm">/* float */</span>
   <span class="n">SVGA3D_TS_BUMPENVMAT01</span>               <span class="o">=</span> <span class="mi">18</span><span class="p">,</span>   <span class="cm">/* float */</span>
   <span class="n">SVGA3D_TS_BUMPENVMAT10</span>               <span class="o">=</span> <span class="mi">19</span><span class="p">,</span>   <span class="cm">/* float */</span>
   <span class="n">SVGA3D_TS_BUMPENVMAT11</span>               <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>   <span class="cm">/* float */</span>
   <span class="n">SVGA3D_TS_TEXTURE_MIPMAP_LEVEL</span>       <span class="o">=</span> <span class="mi">21</span><span class="p">,</span>   <span class="cm">/* uint32 */</span>
   <span class="n">SVGA3D_TS_TEXTURE_LOD_BIAS</span>           <span class="o">=</span> <span class="mi">22</span><span class="p">,</span>   <span class="cm">/* float */</span>
   <span class="n">SVGA3D_TS_TEXTURE_ANISOTROPIC_LEVEL</span>  <span class="o">=</span> <span class="mi">23</span><span class="p">,</span>   <span class="cm">/* uint32 */</span>
   <span class="n">SVGA3D_TS_ADDRESSW</span>                   <span class="o">=</span> <span class="mi">24</span><span class="p">,</span>   <span class="cm">/* SVGA3dTextureAddress */</span>


   <span class="cm">/*</span>
<span class="cm">    * Sampler Gamma Level</span>
<span class="cm">    *</span>
<span class="cm">    * Sampler gamma effects the color of samples taken from the sampler.  A</span>
<span class="cm">    * value of 1.0 will produce linear samples.  If the value is &lt;= 0.0 the</span>
<span class="cm">    * gamma value is ignored and a linear space is used.</span>
<span class="cm">    */</span>

   <span class="n">SVGA3D_TS_GAMMA</span>                      <span class="o">=</span> <span class="mi">25</span><span class="p">,</span>   <span class="cm">/* float */</span>
   <span class="n">SVGA3D_TS_BUMPENVLSCALE</span>              <span class="o">=</span> <span class="mi">26</span><span class="p">,</span>   <span class="cm">/* float */</span>
   <span class="n">SVGA3D_TS_BUMPENVLOFFSET</span>             <span class="o">=</span> <span class="mi">27</span><span class="p">,</span>   <span class="cm">/* float */</span>
   <span class="n">SVGA3D_TS_COLORARG0</span>                  <span class="o">=</span> <span class="mi">28</span><span class="p">,</span>   <span class="cm">/* SVGA3dTextureArgData */</span>
   <span class="n">SVGA3D_TS_ALPHAARG0</span>                  <span class="o">=</span> <span class="mi">29</span><span class="p">,</span>   <span class="cm">/* SVGA3dTextureArgData */</span>
   <span class="n">SVGA3D_TS_MAX</span>
<span class="p">}</span> <span class="n">SVGA3dTextureStateName</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
   <span class="n">SVGA3D_TC_INVALID</span>                   <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
   <span class="n">SVGA3D_TC_DISABLE</span>                   <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
   <span class="n">SVGA3D_TC_SELECTARG1</span>                <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
   <span class="n">SVGA3D_TC_SELECTARG2</span>                <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
   <span class="n">SVGA3D_TC_MODULATE</span>                  <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
   <span class="n">SVGA3D_TC_ADD</span>                       <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
   <span class="n">SVGA3D_TC_ADDSIGNED</span>                 <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
   <span class="n">SVGA3D_TC_SUBTRACT</span>                  <span class="o">=</span> <span class="mi">7</span><span class="p">,</span>
   <span class="n">SVGA3D_TC_BLENDTEXTUREALPHA</span>         <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
   <span class="n">SVGA3D_TC_BLENDDIFFUSEALPHA</span>         <span class="o">=</span> <span class="mi">9</span><span class="p">,</span>
   <span class="n">SVGA3D_TC_BLENDCURRENTALPHA</span>         <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
   <span class="n">SVGA3D_TC_BLENDFACTORALPHA</span>          <span class="o">=</span> <span class="mi">11</span><span class="p">,</span>
   <span class="n">SVGA3D_TC_MODULATE2X</span>                <span class="o">=</span> <span class="mi">12</span><span class="p">,</span>
   <span class="n">SVGA3D_TC_MODULATE4X</span>                <span class="o">=</span> <span class="mi">13</span><span class="p">,</span>
   <span class="n">SVGA3D_TC_DSDT</span>                      <span class="o">=</span> <span class="mi">14</span><span class="p">,</span>
   <span class="n">SVGA3D_TC_DOTPRODUCT3</span>               <span class="o">=</span> <span class="mi">15</span><span class="p">,</span>
   <span class="n">SVGA3D_TC_BLENDTEXTUREALPHAPM</span>       <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>
   <span class="n">SVGA3D_TC_ADDSIGNED2X</span>               <span class="o">=</span> <span class="mi">17</span><span class="p">,</span>
   <span class="n">SVGA3D_TC_ADDSMOOTH</span>                 <span class="o">=</span> <span class="mi">18</span><span class="p">,</span>
   <span class="n">SVGA3D_TC_PREMODULATE</span>               <span class="o">=</span> <span class="mi">19</span><span class="p">,</span>
   <span class="n">SVGA3D_TC_MODULATEALPHA_ADDCOLOR</span>    <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
   <span class="n">SVGA3D_TC_MODULATECOLOR_ADDALPHA</span>    <span class="o">=</span> <span class="mi">21</span><span class="p">,</span>
   <span class="n">SVGA3D_TC_MODULATEINVALPHA_ADDCOLOR</span> <span class="o">=</span> <span class="mi">22</span><span class="p">,</span>
   <span class="n">SVGA3D_TC_MODULATEINVCOLOR_ADDALPHA</span> <span class="o">=</span> <span class="mi">23</span><span class="p">,</span>
   <span class="n">SVGA3D_TC_BUMPENVMAPLUMINANCE</span>       <span class="o">=</span> <span class="mi">24</span><span class="p">,</span>
   <span class="n">SVGA3D_TC_MULTIPLYADD</span>               <span class="o">=</span> <span class="mi">25</span><span class="p">,</span>
   <span class="n">SVGA3D_TC_LERP</span>                      <span class="o">=</span> <span class="mi">26</span><span class="p">,</span>
   <span class="n">SVGA3D_TC_MAX</span>
<span class="p">}</span> <span class="n">SVGA3dTextureCombiner</span><span class="p">;</span>

<span class="cp">#define SVGA3D_TC_CAP_BIT(svga3d_tc_op) (svga3d_tc_op ? (1 &lt;&lt; (svga3d_tc_op - 1)) : 0)</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
   <span class="n">SVGA3D_TEX_ADDRESS_INVALID</span>    <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
   <span class="n">SVGA3D_TEX_ADDRESS_WRAP</span>       <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
   <span class="n">SVGA3D_TEX_ADDRESS_MIRROR</span>     <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
   <span class="n">SVGA3D_TEX_ADDRESS_CLAMP</span>      <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
   <span class="n">SVGA3D_TEX_ADDRESS_BORDER</span>     <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
   <span class="n">SVGA3D_TEX_ADDRESS_MIRRORONCE</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
   <span class="n">SVGA3D_TEX_ADDRESS_EDGE</span>       <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
   <span class="n">SVGA3D_TEX_ADDRESS_MAX</span>
<span class="p">}</span> <span class="n">SVGA3dTextureAddress</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * SVGA3D_TEX_FILTER_NONE as the minification filter means mipmapping is</span>
<span class="cm"> * disabled, and the rasterizer should use the magnification filter instead.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
   <span class="n">SVGA3D_TEX_FILTER_NONE</span>           <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
   <span class="n">SVGA3D_TEX_FILTER_NEAREST</span>        <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
   <span class="n">SVGA3D_TEX_FILTER_LINEAR</span>         <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
   <span class="n">SVGA3D_TEX_FILTER_ANISOTROPIC</span>    <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
   <span class="n">SVGA3D_TEX_FILTER_FLATCUBIC</span>      <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="cm">/* Deprecated, not implemented */</span>
   <span class="n">SVGA3D_TEX_FILTER_GAUSSIANCUBIC</span>  <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="cm">/* Deprecated, not implemented */</span>
   <span class="n">SVGA3D_TEX_FILTER_PYRAMIDALQUAD</span>  <span class="o">=</span> <span class="mi">6</span><span class="p">,</span> <span class="cm">/* Not currently implemented */</span>
   <span class="n">SVGA3D_TEX_FILTER_GAUSSIANQUAD</span>   <span class="o">=</span> <span class="mi">7</span><span class="p">,</span> <span class="cm">/* Not currently implemented */</span>
   <span class="n">SVGA3D_TEX_FILTER_MAX</span>
<span class="p">}</span> <span class="n">SVGA3dTextureFilter</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
   <span class="n">SVGA3D_TEX_TRANSFORM_OFF</span>    <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
   <span class="n">SVGA3D_TEX_TRANSFORM_S</span>      <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">),</span>
   <span class="n">SVGA3D_TEX_TRANSFORM_T</span>      <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span>
   <span class="n">SVGA3D_TEX_TRANSFORM_R</span>      <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">),</span>
   <span class="n">SVGA3D_TEX_TRANSFORM_Q</span>      <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">),</span>
   <span class="n">SVGA3D_TEX_PROJECTED</span>        <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">15</span><span class="p">),</span>
<span class="p">}</span> <span class="n">SVGA3dTexTransformFlags</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
   <span class="n">SVGA3D_TEXCOORD_GEN_OFF</span>              <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
   <span class="n">SVGA3D_TEXCOORD_GEN_EYE_POSITION</span>     <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
   <span class="n">SVGA3D_TEXCOORD_GEN_EYE_NORMAL</span>       <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
   <span class="n">SVGA3D_TEXCOORD_GEN_REFLECTIONVECTOR</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
   <span class="n">SVGA3D_TEXCOORD_GEN_SPHERE</span>           <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
   <span class="n">SVGA3D_TEXCOORD_GEN_MAX</span>
<span class="p">}</span> <span class="n">SVGA3dTextureCoordGen</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Texture argument constants for texture combiner</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
   <span class="n">SVGA3D_TA_INVALID</span>    <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
   <span class="n">SVGA3D_TA_CONSTANT</span>   <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
   <span class="n">SVGA3D_TA_PREVIOUS</span>   <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
   <span class="n">SVGA3D_TA_DIFFUSE</span>    <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
   <span class="n">SVGA3D_TA_TEXTURE</span>    <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
   <span class="n">SVGA3D_TA_SPECULAR</span>   <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
   <span class="n">SVGA3D_TA_MAX</span>
<span class="p">}</span> <span class="n">SVGA3dTextureArgData</span><span class="p">;</span>

<span class="cp">#define SVGA3D_TM_MASK_LEN 4</span>

<span class="cm">/* Modifiers for texture argument constants defined above. */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
   <span class="n">SVGA3D_TM_NONE</span>       <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
   <span class="n">SVGA3D_TM_ALPHA</span>      <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">SVGA3D_TM_MASK_LEN</span><span class="p">),</span>
   <span class="n">SVGA3D_TM_ONE_MINUS</span>  <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="n">SVGA3D_TM_MASK_LEN</span><span class="p">),</span>
<span class="p">}</span> <span class="n">SVGA3dTextureArgModifier</span><span class="p">;</span>

<span class="cp">#define SVGA3D_INVALID_ID         ((uint32)-1)</span>
<span class="cp">#define SVGA3D_MAX_CLIP_PLANES    6</span>

<span class="cm">/*</span>
<span class="cm"> * This is the limit to the number of fixed-function texture</span>
<span class="cm"> * transforms and texture coordinates we can support. It does *not*</span>
<span class="cm"> * correspond to the number of texture image units (samplers) we</span>
<span class="cm"> * support!</span>
<span class="cm"> */</span>
<span class="cp">#define SVGA3D_MAX_TEXTURE_COORDS 8</span>

<span class="cm">/*</span>
<span class="cm"> * Vertex declarations</span>
<span class="cm"> *</span>
<span class="cm"> * Notes:</span>
<span class="cm"> *</span>
<span class="cm"> * SVGA3D_DECLUSAGE_POSITIONT is for pre-transformed vertices. If you</span>
<span class="cm"> * draw with any POSITIONT vertex arrays, the programmable vertex</span>
<span class="cm"> * pipeline will be implicitly disabled. Drawing will take place as if</span>
<span class="cm"> * no vertex shader was bound.</span>
<span class="cm"> */</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
   <span class="n">SVGA3D_DECLUSAGE_POSITION</span>     <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
   <span class="n">SVGA3D_DECLUSAGE_BLENDWEIGHT</span><span class="p">,</span>       <span class="cm">/*  1 */</span>
   <span class="n">SVGA3D_DECLUSAGE_BLENDINDICES</span><span class="p">,</span>      <span class="cm">/*  2 */</span>
   <span class="n">SVGA3D_DECLUSAGE_NORMAL</span><span class="p">,</span>            <span class="cm">/*  3 */</span>
   <span class="n">SVGA3D_DECLUSAGE_PSIZE</span><span class="p">,</span>             <span class="cm">/*  4 */</span>
   <span class="n">SVGA3D_DECLUSAGE_TEXCOORD</span><span class="p">,</span>          <span class="cm">/*  5 */</span>
   <span class="n">SVGA3D_DECLUSAGE_TANGENT</span><span class="p">,</span>           <span class="cm">/*  6 */</span>
   <span class="n">SVGA3D_DECLUSAGE_BINORMAL</span><span class="p">,</span>          <span class="cm">/*  7 */</span>
   <span class="n">SVGA3D_DECLUSAGE_TESSFACTOR</span><span class="p">,</span>        <span class="cm">/*  8 */</span>
   <span class="n">SVGA3D_DECLUSAGE_POSITIONT</span><span class="p">,</span>         <span class="cm">/*  9 */</span>
   <span class="n">SVGA3D_DECLUSAGE_COLOR</span><span class="p">,</span>             <span class="cm">/* 10 */</span>
   <span class="n">SVGA3D_DECLUSAGE_FOG</span><span class="p">,</span>               <span class="cm">/* 11 */</span>
   <span class="n">SVGA3D_DECLUSAGE_DEPTH</span><span class="p">,</span>             <span class="cm">/* 12 */</span>
   <span class="n">SVGA3D_DECLUSAGE_SAMPLE</span><span class="p">,</span>            <span class="cm">/* 13 */</span>
   <span class="n">SVGA3D_DECLUSAGE_MAX</span>
<span class="p">}</span> <span class="n">SVGA3dDeclUsage</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
   <span class="n">SVGA3D_DECLMETHOD_DEFAULT</span>     <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
   <span class="n">SVGA3D_DECLMETHOD_PARTIALU</span><span class="p">,</span>
   <span class="n">SVGA3D_DECLMETHOD_PARTIALV</span><span class="p">,</span>
   <span class="n">SVGA3D_DECLMETHOD_CROSSUV</span><span class="p">,</span>          <span class="cm">/* Normal */</span>
   <span class="n">SVGA3D_DECLMETHOD_UV</span><span class="p">,</span>
   <span class="n">SVGA3D_DECLMETHOD_LOOKUP</span><span class="p">,</span>           <span class="cm">/* Lookup a displacement map */</span>
   <span class="n">SVGA3D_DECLMETHOD_LOOKUPPRESAMPLED</span><span class="p">,</span> <span class="cm">/* Lookup a pre-sampled displacement map */</span>
<span class="p">}</span> <span class="n">SVGA3dDeclMethod</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
   <span class="n">SVGA3D_DECLTYPE_FLOAT1</span>        <span class="o">=</span>  <span class="mi">0</span><span class="p">,</span>
   <span class="n">SVGA3D_DECLTYPE_FLOAT2</span>        <span class="o">=</span>  <span class="mi">1</span><span class="p">,</span>
   <span class="n">SVGA3D_DECLTYPE_FLOAT3</span>        <span class="o">=</span>  <span class="mi">2</span><span class="p">,</span>
   <span class="n">SVGA3D_DECLTYPE_FLOAT4</span>        <span class="o">=</span>  <span class="mi">3</span><span class="p">,</span>
   <span class="n">SVGA3D_DECLTYPE_D3DCOLOR</span>      <span class="o">=</span>  <span class="mi">4</span><span class="p">,</span>
   <span class="n">SVGA3D_DECLTYPE_UBYTE4</span>        <span class="o">=</span>  <span class="mi">5</span><span class="p">,</span>
   <span class="n">SVGA3D_DECLTYPE_SHORT2</span>        <span class="o">=</span>  <span class="mi">6</span><span class="p">,</span>
   <span class="n">SVGA3D_DECLTYPE_SHORT4</span>        <span class="o">=</span>  <span class="mi">7</span><span class="p">,</span>
   <span class="n">SVGA3D_DECLTYPE_UBYTE4N</span>       <span class="o">=</span>  <span class="mi">8</span><span class="p">,</span>
   <span class="n">SVGA3D_DECLTYPE_SHORT2N</span>       <span class="o">=</span>  <span class="mi">9</span><span class="p">,</span>
   <span class="n">SVGA3D_DECLTYPE_SHORT4N</span>       <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
   <span class="n">SVGA3D_DECLTYPE_USHORT2N</span>      <span class="o">=</span> <span class="mi">11</span><span class="p">,</span>
   <span class="n">SVGA3D_DECLTYPE_USHORT4N</span>      <span class="o">=</span> <span class="mi">12</span><span class="p">,</span>
   <span class="n">SVGA3D_DECLTYPE_UDEC3</span>         <span class="o">=</span> <span class="mi">13</span><span class="p">,</span>
   <span class="n">SVGA3D_DECLTYPE_DEC3N</span>         <span class="o">=</span> <span class="mi">14</span><span class="p">,</span>
   <span class="n">SVGA3D_DECLTYPE_FLOAT16_2</span>     <span class="o">=</span> <span class="mi">15</span><span class="p">,</span>
   <span class="n">SVGA3D_DECLTYPE_FLOAT16_4</span>     <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>
   <span class="n">SVGA3D_DECLTYPE_MAX</span><span class="p">,</span>
<span class="p">}</span> <span class="n">SVGA3dDeclType</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * This structure is used for the divisor for geometry instancing;</span>
<span class="cm"> * it&#39;s a direct translation of the Direct3D equivalent.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">union</span> <span class="p">{</span>
   <span class="k">struct</span> <span class="p">{</span>
      <span class="cm">/*</span>
<span class="cm">       * For index data, this number represents the number of instances to draw.</span>
<span class="cm">       * For instance data, this number represents the number of</span>
<span class="cm">       * instances/vertex in this stream</span>
<span class="cm">       */</span>
      <span class="n">uint32</span> <span class="n">count</span> <span class="o">:</span> <span class="mi">30</span><span class="p">;</span>

      <span class="cm">/*</span>
<span class="cm">       * This is 1 if this is supposed to be the data that is repeated for</span>
<span class="cm">       * every instance.</span>
<span class="cm">       */</span>
      <span class="n">uint32</span> <span class="n">indexedData</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>

      <span class="cm">/*</span>
<span class="cm">       * This is 1 if this is supposed to be the per-instance data.</span>
<span class="cm">       */</span>
      <span class="n">uint32</span> <span class="n">instanceData</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
   <span class="p">};</span>

   <span class="n">uint32</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span> <span class="n">SVGA3dVertexDivisor</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
   <span class="n">SVGA3D_PRIMITIVE_INVALID</span>                     <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
   <span class="n">SVGA3D_PRIMITIVE_TRIANGLELIST</span>                <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
   <span class="n">SVGA3D_PRIMITIVE_POINTLIST</span>                   <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
   <span class="n">SVGA3D_PRIMITIVE_LINELIST</span>                    <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
   <span class="n">SVGA3D_PRIMITIVE_LINESTRIP</span>                   <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
   <span class="n">SVGA3D_PRIMITIVE_TRIANGLESTRIP</span>               <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
   <span class="n">SVGA3D_PRIMITIVE_TRIANGLEFAN</span>                 <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
   <span class="n">SVGA3D_PRIMITIVE_MAX</span>
<span class="p">}</span> <span class="n">SVGA3dPrimitiveType</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
   <span class="n">SVGA3D_COORDINATE_INVALID</span>                   <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
   <span class="n">SVGA3D_COORDINATE_LEFTHANDED</span>                <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
   <span class="n">SVGA3D_COORDINATE_RIGHTHANDED</span>               <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
   <span class="n">SVGA3D_COORDINATE_MAX</span>
<span class="p">}</span> <span class="n">SVGA3dCoordinateType</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
   <span class="n">SVGA3D_TRANSFORM_INVALID</span>                     <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
   <span class="n">SVGA3D_TRANSFORM_WORLD</span>                       <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
   <span class="n">SVGA3D_TRANSFORM_VIEW</span>                        <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
   <span class="n">SVGA3D_TRANSFORM_PROJECTION</span>                  <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
   <span class="n">SVGA3D_TRANSFORM_TEXTURE0</span>                    <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
   <span class="n">SVGA3D_TRANSFORM_TEXTURE1</span>                    <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
   <span class="n">SVGA3D_TRANSFORM_TEXTURE2</span>                    <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
   <span class="n">SVGA3D_TRANSFORM_TEXTURE3</span>                    <span class="o">=</span> <span class="mi">7</span><span class="p">,</span>
   <span class="n">SVGA3D_TRANSFORM_TEXTURE4</span>                    <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
   <span class="n">SVGA3D_TRANSFORM_TEXTURE5</span>                    <span class="o">=</span> <span class="mi">9</span><span class="p">,</span>
   <span class="n">SVGA3D_TRANSFORM_TEXTURE6</span>                    <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
   <span class="n">SVGA3D_TRANSFORM_TEXTURE7</span>                    <span class="o">=</span> <span class="mi">11</span><span class="p">,</span>
   <span class="n">SVGA3D_TRANSFORM_WORLD1</span>                      <span class="o">=</span> <span class="mi">12</span><span class="p">,</span>
   <span class="n">SVGA3D_TRANSFORM_WORLD2</span>                      <span class="o">=</span> <span class="mi">13</span><span class="p">,</span>
   <span class="n">SVGA3D_TRANSFORM_WORLD3</span>                      <span class="o">=</span> <span class="mi">14</span><span class="p">,</span>
   <span class="n">SVGA3D_TRANSFORM_MAX</span>
<span class="p">}</span> <span class="n">SVGA3dTransformType</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
   <span class="n">SVGA3D_LIGHTTYPE_INVALID</span>                     <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
   <span class="n">SVGA3D_LIGHTTYPE_POINT</span>                       <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
   <span class="n">SVGA3D_LIGHTTYPE_SPOT1</span>                       <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="cm">/* 1-cone, in degrees */</span>
   <span class="n">SVGA3D_LIGHTTYPE_SPOT2</span>                       <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="cm">/* 2-cone, in radians */</span>
   <span class="n">SVGA3D_LIGHTTYPE_DIRECTIONAL</span>                 <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
   <span class="n">SVGA3D_LIGHTTYPE_MAX</span>
<span class="p">}</span> <span class="n">SVGA3dLightType</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
   <span class="n">SVGA3D_CUBEFACE_POSX</span>                         <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
   <span class="n">SVGA3D_CUBEFACE_NEGX</span>                         <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
   <span class="n">SVGA3D_CUBEFACE_POSY</span>                         <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
   <span class="n">SVGA3D_CUBEFACE_NEGY</span>                         <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
   <span class="n">SVGA3D_CUBEFACE_POSZ</span>                         <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
   <span class="n">SVGA3D_CUBEFACE_NEGZ</span>                         <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
<span class="p">}</span> <span class="n">SVGA3dCubeFace</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
   <span class="n">SVGA3D_SHADERTYPE_VS</span>                         <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
   <span class="n">SVGA3D_SHADERTYPE_PS</span>                         <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
   <span class="n">SVGA3D_SHADERTYPE_MAX</span>
<span class="p">}</span> <span class="n">SVGA3dShaderType</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
   <span class="n">SVGA3D_CONST_TYPE_FLOAT</span>                      <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
   <span class="n">SVGA3D_CONST_TYPE_INT</span>                        <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
   <span class="n">SVGA3D_CONST_TYPE_BOOL</span>                       <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
<span class="p">}</span> <span class="n">SVGA3dShaderConstType</span><span class="p">;</span>

<span class="cp">#define SVGA3D_MAX_SURFACE_FACES                6</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
   <span class="n">SVGA3D_STRETCH_BLT_POINT</span>                     <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
   <span class="n">SVGA3D_STRETCH_BLT_LINEAR</span>                    <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
   <span class="n">SVGA3D_STRETCH_BLT_MAX</span>
<span class="p">}</span> <span class="n">SVGA3dStretchBltMode</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
   <span class="n">SVGA3D_QUERYTYPE_OCCLUSION</span>                   <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
   <span class="n">SVGA3D_QUERYTYPE_MAX</span>
<span class="p">}</span> <span class="n">SVGA3dQueryType</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
   <span class="n">SVGA3D_QUERYSTATE_PENDING</span>     <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>      <span class="cm">/* Waiting on the host (set by guest) */</span>
   <span class="n">SVGA3D_QUERYSTATE_SUCCEEDED</span>   <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>      <span class="cm">/* Completed successfully (set by host) */</span>
   <span class="n">SVGA3D_QUERYSTATE_FAILED</span>      <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>      <span class="cm">/* Completed unsuccessfully (set by host) */</span>
   <span class="n">SVGA3D_QUERYSTATE_NEW</span>         <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>      <span class="cm">/* Never submitted (For guest use only) */</span>
<span class="p">}</span> <span class="n">SVGA3dQueryState</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
   <span class="n">SVGA3D_WRITE_HOST_VRAM</span>        <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
   <span class="n">SVGA3D_READ_HOST_VRAM</span>         <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
<span class="p">}</span> <span class="n">SVGA3dTransferType</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * The maximum number of vertex arrays we&#39;re guaranteed to support in</span>
<span class="cm"> * SVGA_3D_CMD_DRAWPRIMITIVES.</span>
<span class="cm"> */</span>
<span class="cp">#define SVGA3D_MAX_VERTEX_ARRAYS   32</span>

<span class="cm">/*</span>
<span class="cm"> * The maximum number of primitive ranges we&#39;re guaranteed to support</span>
<span class="cm"> * in SVGA_3D_CMD_DRAWPRIMITIVES.</span>
<span class="cm"> */</span>
<span class="cp">#define SVGA3D_MAX_DRAW_PRIMITIVE_RANGES 32</span>

<span class="cm">/*</span>
<span class="cm"> * Identifiers for commands in the command FIFO.</span>
<span class="cm"> *</span>
<span class="cm"> * IDs between 1000 and 1039 (inclusive) were used by obsolete versions of</span>
<span class="cm"> * the SVGA3D protocol and remain reserved; they should not be used in the</span>
<span class="cm"> * future.</span>
<span class="cm"> *</span>
<span class="cm"> * IDs between 1040 and 1999 (inclusive) are available for use by the</span>
<span class="cm"> * current SVGA3D protocol.</span>
<span class="cm"> *</span>
<span class="cm"> * FIFO clients other than SVGA3D should stay below 1000, or at 2000</span>
<span class="cm"> * and up.</span>
<span class="cm"> */</span>

<span class="cp">#define SVGA_3D_CMD_LEGACY_BASE            1000</span>
<span class="cp">#define SVGA_3D_CMD_BASE                   1040</span>

<span class="cp">#define SVGA_3D_CMD_SURFACE_DEFINE         SVGA_3D_CMD_BASE + 0     </span><span class="cm">/* Deprecated */</span><span class="cp"></span>
<span class="cp">#define SVGA_3D_CMD_SURFACE_DESTROY        SVGA_3D_CMD_BASE + 1</span>
<span class="cp">#define SVGA_3D_CMD_SURFACE_COPY           SVGA_3D_CMD_BASE + 2</span>
<span class="cp">#define SVGA_3D_CMD_SURFACE_STRETCHBLT     SVGA_3D_CMD_BASE + 3</span>
<span class="cp">#define SVGA_3D_CMD_SURFACE_DMA            SVGA_3D_CMD_BASE + 4</span>
<span class="cp">#define SVGA_3D_CMD_CONTEXT_DEFINE         SVGA_3D_CMD_BASE + 5</span>
<span class="cp">#define SVGA_3D_CMD_CONTEXT_DESTROY        SVGA_3D_CMD_BASE + 6</span>
<span class="cp">#define SVGA_3D_CMD_SETTRANSFORM           SVGA_3D_CMD_BASE + 7</span>
<span class="cp">#define SVGA_3D_CMD_SETZRANGE              SVGA_3D_CMD_BASE + 8</span>
<span class="cp">#define SVGA_3D_CMD_SETRENDERSTATE         SVGA_3D_CMD_BASE + 9</span>
<span class="cp">#define SVGA_3D_CMD_SETRENDERTARGET        SVGA_3D_CMD_BASE + 10</span>
<span class="cp">#define SVGA_3D_CMD_SETTEXTURESTATE        SVGA_3D_CMD_BASE + 11</span>
<span class="cp">#define SVGA_3D_CMD_SETMATERIAL            SVGA_3D_CMD_BASE + 12</span>
<span class="cp">#define SVGA_3D_CMD_SETLIGHTDATA           SVGA_3D_CMD_BASE + 13</span>
<span class="cp">#define SVGA_3D_CMD_SETLIGHTENABLED        SVGA_3D_CMD_BASE + 14</span>
<span class="cp">#define SVGA_3D_CMD_SETVIEWPORT            SVGA_3D_CMD_BASE + 15</span>
<span class="cp">#define SVGA_3D_CMD_SETCLIPPLANE           SVGA_3D_CMD_BASE + 16</span>
<span class="cp">#define SVGA_3D_CMD_CLEAR                  SVGA_3D_CMD_BASE + 17</span>
<span class="cp">#define SVGA_3D_CMD_PRESENT                SVGA_3D_CMD_BASE + 18    </span><span class="cm">/* Deprecated */</span><span class="cp"></span>
<span class="cp">#define SVGA_3D_CMD_SHADER_DEFINE          SVGA_3D_CMD_BASE + 19</span>
<span class="cp">#define SVGA_3D_CMD_SHADER_DESTROY         SVGA_3D_CMD_BASE + 20</span>
<span class="cp">#define SVGA_3D_CMD_SET_SHADER             SVGA_3D_CMD_BASE + 21</span>
<span class="cp">#define SVGA_3D_CMD_SET_SHADER_CONST       SVGA_3D_CMD_BASE + 22</span>
<span class="cp">#define SVGA_3D_CMD_DRAW_PRIMITIVES        SVGA_3D_CMD_BASE + 23</span>
<span class="cp">#define SVGA_3D_CMD_SETSCISSORRECT         SVGA_3D_CMD_BASE + 24</span>
<span class="cp">#define SVGA_3D_CMD_BEGIN_QUERY            SVGA_3D_CMD_BASE + 25</span>
<span class="cp">#define SVGA_3D_CMD_END_QUERY              SVGA_3D_CMD_BASE + 26</span>
<span class="cp">#define SVGA_3D_CMD_WAIT_FOR_QUERY         SVGA_3D_CMD_BASE + 27</span>
<span class="cp">#define SVGA_3D_CMD_PRESENT_READBACK       SVGA_3D_CMD_BASE + 28    </span><span class="cm">/* Deprecated */</span><span class="cp"></span>
<span class="cp">#define SVGA_3D_CMD_BLIT_SURFACE_TO_SCREEN SVGA_3D_CMD_BASE + 29</span>
<span class="cp">#define SVGA_3D_CMD_SURFACE_DEFINE_V2      SVGA_3D_CMD_BASE + 30</span>
<span class="cp">#define SVGA_3D_CMD_GENERATE_MIPMAPS       SVGA_3D_CMD_BASE + 31</span>
<span class="cp">#define SVGA_3D_CMD_ACTIVATE_SURFACE       SVGA_3D_CMD_BASE + 40</span>
<span class="cp">#define SVGA_3D_CMD_DEACTIVATE_SURFACE     SVGA_3D_CMD_BASE + 41</span>
<span class="cp">#define SVGA_3D_CMD_MAX                    SVGA_3D_CMD_BASE + 42</span>

<span class="cp">#define SVGA_3D_CMD_FUTURE_MAX             2000</span>

<span class="cm">/*</span>
<span class="cm"> * Common substructures used in multiple FIFO commands:</span>
<span class="cm"> */</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
   <span class="k">union</span> <span class="p">{</span>
      <span class="k">struct</span> <span class="p">{</span>
         <span class="n">uint16</span>  <span class="n">function</span><span class="p">;</span>       <span class="cm">/* SVGA3dFogFunction */</span>
         <span class="n">uint8</span>   <span class="n">type</span><span class="p">;</span>           <span class="cm">/* SVGA3dFogType */</span>
         <span class="n">uint8</span>   <span class="n">base</span><span class="p">;</span>           <span class="cm">/* SVGA3dFogBase */</span>
      <span class="p">};</span>
      <span class="n">uint32</span>     <span class="n">uintValue</span><span class="p">;</span>
   <span class="p">};</span>
<span class="p">}</span> <span class="n">SVGA3dFogMode</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Uniquely identify one image (a 1D/2D/3D array) from a surface. This</span>
<span class="cm"> * is a surface ID as well as face/mipmap indices.</span>
<span class="cm"> */</span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="n">SVGA3dSurfaceImageId</span> <span class="p">{</span>
   <span class="n">uint32</span>               <span class="n">sid</span><span class="p">;</span>
   <span class="n">uint32</span>               <span class="n">face</span><span class="p">;</span>
   <span class="n">uint32</span>               <span class="n">mipmap</span><span class="p">;</span>
<span class="p">}</span> <span class="n">SVGA3dSurfaceImageId</span><span class="p">;</span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="n">SVGA3dGuestImage</span> <span class="p">{</span>
   <span class="n">SVGAGuestPtr</span>         <span class="n">ptr</span><span class="p">;</span>

   <span class="cm">/*</span>
<span class="cm">    * A note on interpretation of pitch: This value of pitch is the</span>
<span class="cm">    * number of bytes between vertically adjacent image</span>
<span class="cm">    * blocks. Normally this is the number of bytes between the first</span>
<span class="cm">    * pixel of two adjacent scanlines. With compressed textures,</span>
<span class="cm">    * however, this may represent the number of bytes between</span>
<span class="cm">    * compression blocks rather than between rows of pixels.</span>
<span class="cm">    *</span>
<span class="cm">    * XXX: Compressed textures currently must be tightly packed in guest memory.</span>
<span class="cm">    *</span>
<span class="cm">    * If the image is 1-dimensional, pitch is ignored.</span>
<span class="cm">    *</span>
<span class="cm">    * If &#39;pitch&#39; is zero, the SVGA3D device calculates a pitch value</span>
<span class="cm">    * assuming each row of blocks is tightly packed.</span>
<span class="cm">    */</span>
   <span class="n">uint32</span> <span class="n">pitch</span><span class="p">;</span>
<span class="p">}</span> <span class="n">SVGA3dGuestImage</span><span class="p">;</span>


<span class="cm">/*</span>
<span class="cm"> * FIFO command format definitions:</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * The data size header following cmdNum for every 3d command</span>
<span class="cm"> */</span>
<span class="k">typedef</span>
<span class="k">struct</span> <span class="p">{</span>
   <span class="n">uint32</span>               <span class="n">id</span><span class="p">;</span>
   <span class="n">uint32</span>               <span class="n">size</span><span class="p">;</span>
<span class="p">}</span> <span class="n">SVGA3dCmdHeader</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * A surface is a hierarchy of host VRAM surfaces: 1D, 2D, or 3D, with</span>
<span class="cm"> * optional mipmaps and cube faces.</span>
<span class="cm"> */</span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="p">{</span>
   <span class="n">uint32</span>               <span class="n">width</span><span class="p">;</span>
   <span class="n">uint32</span>               <span class="n">height</span><span class="p">;</span>
   <span class="n">uint32</span>               <span class="n">depth</span><span class="p">;</span>
<span class="p">}</span> <span class="n">SVGA3dSize</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
   <span class="n">SVGA3D_SURFACE_CUBEMAP</span>              <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">),</span>
   <span class="n">SVGA3D_SURFACE_HINT_STATIC</span>          <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span>
   <span class="n">SVGA3D_SURFACE_HINT_DYNAMIC</span>         <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">),</span>
   <span class="n">SVGA3D_SURFACE_HINT_INDEXBUFFER</span>     <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">),</span>
   <span class="n">SVGA3D_SURFACE_HINT_VERTEXBUFFER</span>    <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">),</span>
   <span class="n">SVGA3D_SURFACE_HINT_TEXTURE</span>         <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">),</span>
   <span class="n">SVGA3D_SURFACE_HINT_RENDERTARGET</span>    <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">),</span>
   <span class="n">SVGA3D_SURFACE_HINT_DEPTHSTENCIL</span>    <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">),</span>
   <span class="n">SVGA3D_SURFACE_HINT_WRITEONLY</span>       <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">),</span>
   <span class="n">SVGA3D_SURFACE_MASKABLE_ANTIALIAS</span>   <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">9</span><span class="p">),</span>
   <span class="n">SVGA3D_SURFACE_AUTOGENMIPMAPS</span>       <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">),</span>
<span class="p">}</span> <span class="n">SVGA3dSurfaceFlags</span><span class="p">;</span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="p">{</span>
   <span class="n">uint32</span>               <span class="n">numMipLevels</span><span class="p">;</span>
<span class="p">}</span> <span class="n">SVGA3dSurfaceFace</span><span class="p">;</span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="p">{</span>
   <span class="n">uint32</span>                      <span class="n">sid</span><span class="p">;</span>
   <span class="n">SVGA3dSurfaceFlags</span>          <span class="n">surfaceFlags</span><span class="p">;</span>
   <span class="n">SVGA3dSurfaceFormat</span>         <span class="n">format</span><span class="p">;</span>
   <span class="cm">/*</span>
<span class="cm">    * If surfaceFlags has SVGA3D_SURFACE_CUBEMAP bit set, all SVGA3dSurfaceFace</span>
<span class="cm">    * structures must have the same value of numMipLevels field.</span>
<span class="cm">    * Otherwise, all but the first SVGA3dSurfaceFace structures must have the</span>
<span class="cm">    * numMipLevels set to 0.</span>
<span class="cm">    */</span>
   <span class="n">SVGA3dSurfaceFace</span>           <span class="n">face</span><span class="p">[</span><span class="n">SVGA3D_MAX_SURFACE_FACES</span><span class="p">];</span>
   <span class="cm">/*</span>
<span class="cm">    * Followed by an SVGA3dSize structure for each mip level in each face.</span>
<span class="cm">    *</span>
<span class="cm">    * A note on surface sizes: Sizes are always specified in pixels,</span>
<span class="cm">    * even if the true surface size is not a multiple of the minimum</span>
<span class="cm">    * block size of the surface&#39;s format. For example, a 3x3x1 DXT1</span>
<span class="cm">    * compressed texture would actually be stored as a 4x4x1 image in</span>
<span class="cm">    * memory.</span>
<span class="cm">    */</span>
<span class="p">}</span> <span class="n">SVGA3dCmdDefineSurface</span><span class="p">;</span>       <span class="cm">/* SVGA_3D_CMD_SURFACE_DEFINE */</span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="p">{</span>
   <span class="n">uint32</span>                      <span class="n">sid</span><span class="p">;</span>
   <span class="n">SVGA3dSurfaceFlags</span>          <span class="n">surfaceFlags</span><span class="p">;</span>
   <span class="n">SVGA3dSurfaceFormat</span>         <span class="n">format</span><span class="p">;</span>
   <span class="cm">/*</span>
<span class="cm">    * If surfaceFlags has SVGA3D_SURFACE_CUBEMAP bit set, all SVGA3dSurfaceFace</span>
<span class="cm">    * structures must have the same value of numMipLevels field.</span>
<span class="cm">    * Otherwise, all but the first SVGA3dSurfaceFace structures must have the</span>
<span class="cm">    * numMipLevels set to 0.</span>
<span class="cm">    */</span>
   <span class="n">SVGA3dSurfaceFace</span>           <span class="n">face</span><span class="p">[</span><span class="n">SVGA3D_MAX_SURFACE_FACES</span><span class="p">];</span>
   <span class="n">uint32</span>                      <span class="n">multisampleCount</span><span class="p">;</span>
   <span class="n">SVGA3dTextureFilter</span>         <span class="n">autogenFilter</span><span class="p">;</span>
   <span class="cm">/*</span>
<span class="cm">    * Followed by an SVGA3dSize structure for each mip level in each face.</span>
<span class="cm">    *</span>
<span class="cm">    * A note on surface sizes: Sizes are always specified in pixels,</span>
<span class="cm">    * even if the true surface size is not a multiple of the minimum</span>
<span class="cm">    * block size of the surface&#39;s format. For example, a 3x3x1 DXT1</span>
<span class="cm">    * compressed texture would actually be stored as a 4x4x1 image in</span>
<span class="cm">    * memory.</span>
<span class="cm">    */</span>
<span class="p">}</span> <span class="n">SVGA3dCmdDefineSurface_v2</span><span class="p">;</span>     <span class="cm">/* SVGA_3D_CMD_SURFACE_DEFINE_V2 */</span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="p">{</span>
   <span class="n">uint32</span>               <span class="n">sid</span><span class="p">;</span>
<span class="p">}</span> <span class="n">SVGA3dCmdDestroySurface</span><span class="p">;</span>      <span class="cm">/* SVGA_3D_CMD_SURFACE_DESTROY */</span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="p">{</span>
   <span class="n">uint32</span>               <span class="n">cid</span><span class="p">;</span>
<span class="p">}</span> <span class="n">SVGA3dCmdDefineContext</span><span class="p">;</span>       <span class="cm">/* SVGA_3D_CMD_CONTEXT_DEFINE */</span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="p">{</span>
   <span class="n">uint32</span>               <span class="n">cid</span><span class="p">;</span>
<span class="p">}</span> <span class="n">SVGA3dCmdDestroyContext</span><span class="p">;</span>      <span class="cm">/* SVGA_3D_CMD_CONTEXT_DESTROY */</span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="p">{</span>
   <span class="n">uint32</span>               <span class="n">cid</span><span class="p">;</span>
   <span class="n">SVGA3dClearFlag</span>      <span class="n">clearFlag</span><span class="p">;</span>
   <span class="n">uint32</span>               <span class="n">color</span><span class="p">;</span>
   <span class="kt">float</span>                <span class="n">depth</span><span class="p">;</span>
   <span class="n">uint32</span>               <span class="n">stencil</span><span class="p">;</span>
   <span class="cm">/* Followed by variable number of SVGA3dRect structures */</span>
<span class="p">}</span> <span class="n">SVGA3dCmdClear</span><span class="p">;</span>               <span class="cm">/* SVGA_3D_CMD_CLEAR */</span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="n">SVGA3dCopyRect</span> <span class="p">{</span>
   <span class="n">uint32</span>               <span class="n">x</span><span class="p">;</span>
   <span class="n">uint32</span>               <span class="n">y</span><span class="p">;</span>
   <span class="n">uint32</span>               <span class="n">w</span><span class="p">;</span>
   <span class="n">uint32</span>               <span class="n">h</span><span class="p">;</span>
   <span class="n">uint32</span>               <span class="n">srcx</span><span class="p">;</span>
   <span class="n">uint32</span>               <span class="n">srcy</span><span class="p">;</span>
<span class="p">}</span> <span class="n">SVGA3dCopyRect</span><span class="p">;</span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="n">SVGA3dCopyBox</span> <span class="p">{</span>
   <span class="n">uint32</span>               <span class="n">x</span><span class="p">;</span>
   <span class="n">uint32</span>               <span class="n">y</span><span class="p">;</span>
   <span class="n">uint32</span>               <span class="n">z</span><span class="p">;</span>
   <span class="n">uint32</span>               <span class="n">w</span><span class="p">;</span>
   <span class="n">uint32</span>               <span class="n">h</span><span class="p">;</span>
   <span class="n">uint32</span>               <span class="n">d</span><span class="p">;</span>
   <span class="n">uint32</span>               <span class="n">srcx</span><span class="p">;</span>
   <span class="n">uint32</span>               <span class="n">srcy</span><span class="p">;</span>
   <span class="n">uint32</span>               <span class="n">srcz</span><span class="p">;</span>
<span class="p">}</span> <span class="n">SVGA3dCopyBox</span><span class="p">;</span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="p">{</span>
   <span class="n">uint32</span>               <span class="n">x</span><span class="p">;</span>
   <span class="n">uint32</span>               <span class="n">y</span><span class="p">;</span>
   <span class="n">uint32</span>               <span class="n">w</span><span class="p">;</span>
   <span class="n">uint32</span>               <span class="n">h</span><span class="p">;</span>
<span class="p">}</span> <span class="n">SVGA3dRect</span><span class="p">;</span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="p">{</span>
   <span class="n">uint32</span>               <span class="n">x</span><span class="p">;</span>
   <span class="n">uint32</span>               <span class="n">y</span><span class="p">;</span>
   <span class="n">uint32</span>               <span class="n">z</span><span class="p">;</span>
   <span class="n">uint32</span>               <span class="n">w</span><span class="p">;</span>
   <span class="n">uint32</span>               <span class="n">h</span><span class="p">;</span>
   <span class="n">uint32</span>               <span class="n">d</span><span class="p">;</span>
<span class="p">}</span> <span class="n">SVGA3dBox</span><span class="p">;</span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="p">{</span>
   <span class="n">uint32</span>               <span class="n">x</span><span class="p">;</span>
   <span class="n">uint32</span>               <span class="n">y</span><span class="p">;</span>
   <span class="n">uint32</span>               <span class="n">z</span><span class="p">;</span>
<span class="p">}</span> <span class="n">SVGA3dPoint</span><span class="p">;</span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="p">{</span>
   <span class="n">SVGA3dLightType</span>      <span class="n">type</span><span class="p">;</span>
   <span class="n">SVGA3dBool</span>           <span class="n">inWorldSpace</span><span class="p">;</span>
   <span class="kt">float</span>                <span class="n">diffuse</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
   <span class="kt">float</span>                <span class="n">specular</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
   <span class="kt">float</span>                <span class="n">ambient</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
   <span class="kt">float</span>                <span class="n">position</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
   <span class="kt">float</span>                <span class="n">direction</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
   <span class="kt">float</span>                <span class="n">range</span><span class="p">;</span>
   <span class="kt">float</span>                <span class="n">falloff</span><span class="p">;</span>
   <span class="kt">float</span>                <span class="n">attenuation0</span><span class="p">;</span>
   <span class="kt">float</span>                <span class="n">attenuation1</span><span class="p">;</span>
   <span class="kt">float</span>                <span class="n">attenuation2</span><span class="p">;</span>
   <span class="kt">float</span>                <span class="n">theta</span><span class="p">;</span>
   <span class="kt">float</span>                <span class="n">phi</span><span class="p">;</span>
<span class="p">}</span> <span class="n">SVGA3dLightData</span><span class="p">;</span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="p">{</span>
   <span class="n">uint32</span>               <span class="n">sid</span><span class="p">;</span>
   <span class="cm">/* Followed by variable number of SVGA3dCopyRect structures */</span>
<span class="p">}</span> <span class="n">SVGA3dCmdPresent</span><span class="p">;</span>             <span class="cm">/* SVGA_3D_CMD_PRESENT */</span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="p">{</span>
   <span class="n">SVGA3dRenderStateName</span>   <span class="n">state</span><span class="p">;</span>
   <span class="k">union</span> <span class="p">{</span>
      <span class="n">uint32</span>               <span class="n">uintValue</span><span class="p">;</span>
      <span class="kt">float</span>                <span class="n">floatValue</span><span class="p">;</span>
   <span class="p">};</span>
<span class="p">}</span> <span class="n">SVGA3dRenderState</span><span class="p">;</span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="p">{</span>
   <span class="n">uint32</span>               <span class="n">cid</span><span class="p">;</span>
   <span class="cm">/* Followed by variable number of SVGA3dRenderState structures */</span>
<span class="p">}</span> <span class="n">SVGA3dCmdSetRenderState</span><span class="p">;</span>      <span class="cm">/* SVGA_3D_CMD_SETRENDERSTATE */</span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="p">{</span>
   <span class="n">uint32</span>                 <span class="n">cid</span><span class="p">;</span>
   <span class="n">SVGA3dRenderTargetType</span> <span class="n">type</span><span class="p">;</span>
   <span class="n">SVGA3dSurfaceImageId</span>   <span class="n">target</span><span class="p">;</span>
<span class="p">}</span> <span class="n">SVGA3dCmdSetRenderTarget</span><span class="p">;</span>     <span class="cm">/* SVGA_3D_CMD_SETRENDERTARGET */</span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="p">{</span>
   <span class="n">SVGA3dSurfaceImageId</span>  <span class="n">src</span><span class="p">;</span>
   <span class="n">SVGA3dSurfaceImageId</span>  <span class="n">dest</span><span class="p">;</span>
   <span class="cm">/* Followed by variable number of SVGA3dCopyBox structures */</span>
<span class="p">}</span> <span class="n">SVGA3dCmdSurfaceCopy</span><span class="p">;</span>               <span class="cm">/* SVGA_3D_CMD_SURFACE_COPY */</span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="p">{</span>
   <span class="n">SVGA3dSurfaceImageId</span>  <span class="n">src</span><span class="p">;</span>
   <span class="n">SVGA3dSurfaceImageId</span>  <span class="n">dest</span><span class="p">;</span>
   <span class="n">SVGA3dBox</span>             <span class="n">boxSrc</span><span class="p">;</span>
   <span class="n">SVGA3dBox</span>             <span class="n">boxDest</span><span class="p">;</span>
   <span class="n">SVGA3dStretchBltMode</span>  <span class="n">mode</span><span class="p">;</span>
<span class="p">}</span> <span class="n">SVGA3dCmdSurfaceStretchBlt</span><span class="p">;</span>         <span class="cm">/* SVGA_3D_CMD_SURFACE_STRETCHBLT */</span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="p">{</span>
   <span class="cm">/*</span>
<span class="cm">    * If the discard flag is present in a surface DMA operation, the host may</span>
<span class="cm">    * discard the contents of the current mipmap level and face of the target</span>
<span class="cm">    * surface before applying the surface DMA contents.</span>
<span class="cm">    */</span>
   <span class="n">uint32</span> <span class="n">discard</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>

   <span class="cm">/*</span>
<span class="cm">    * If the unsynchronized flag is present, the host may perform this upload</span>
<span class="cm">    * without syncing to pending reads on this surface.</span>
<span class="cm">    */</span>
   <span class="n">uint32</span> <span class="n">unsynchronized</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>

   <span class="cm">/*</span>
<span class="cm">    * Guests *MUST* set the reserved bits to 0 before submitting the command</span>
<span class="cm">    * suffix as future flags may occupy these bits.</span>
<span class="cm">    */</span>
   <span class="n">uint32</span> <span class="n">reserved</span> <span class="o">:</span> <span class="mi">30</span><span class="p">;</span>
<span class="p">}</span> <span class="n">SVGA3dSurfaceDMAFlags</span><span class="p">;</span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="p">{</span>
   <span class="n">SVGA3dGuestImage</span>      <span class="n">guest</span><span class="p">;</span>
   <span class="n">SVGA3dSurfaceImageId</span>  <span class="n">host</span><span class="p">;</span>
   <span class="n">SVGA3dTransferType</span>    <span class="n">transfer</span><span class="p">;</span>
   <span class="cm">/*</span>
<span class="cm">    * Followed by variable number of SVGA3dCopyBox structures. For consistency</span>
<span class="cm">    * in all clipping logic and coordinate translation, we define the</span>
<span class="cm">    * &quot;source&quot; in each copyBox as the guest image and the</span>
<span class="cm">    * &quot;destination&quot; as the host image, regardless of transfer</span>
<span class="cm">    * direction.</span>
<span class="cm">    *</span>
<span class="cm">    * For efficiency, the SVGA3D device is free to copy more data than</span>
<span class="cm">    * specified. For example, it may round copy boxes outwards such</span>
<span class="cm">    * that they lie on particular alignment boundaries.</span>
<span class="cm">    */</span>
<span class="p">}</span> <span class="n">SVGA3dCmdSurfaceDMA</span><span class="p">;</span>                <span class="cm">/* SVGA_3D_CMD_SURFACE_DMA */</span>

<span class="cm">/*</span>
<span class="cm"> * SVGA3dCmdSurfaceDMASuffix --</span>
<span class="cm"> *</span>
<span class="cm"> *    This is a command suffix that will appear after a SurfaceDMA command in</span>
<span class="cm"> *    the FIFO.  It contains some extra information that hosts may use to</span>
<span class="cm"> *    optimize performance or protect the guest.  This suffix exists to preserve</span>
<span class="cm"> *    backwards compatibility while also allowing for new functionality to be</span>
<span class="cm"> *    implemented.</span>
<span class="cm"> */</span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="p">{</span>
   <span class="n">uint32</span> <span class="n">suffixSize</span><span class="p">;</span>

   <span class="cm">/*</span>
<span class="cm">    * The maximum offset is used to determine the maximum offset from the</span>
<span class="cm">    * guestPtr base address that will be accessed or written to during this</span>
<span class="cm">    * surfaceDMA.  If the suffix is supported, the host will respect this</span>
<span class="cm">    * boundary while performing surface DMAs.</span>
<span class="cm">    *</span>
<span class="cm">    * Defaults to MAX_UINT32</span>
<span class="cm">    */</span>
   <span class="n">uint32</span> <span class="n">maximumOffset</span><span class="p">;</span>

   <span class="cm">/*</span>
<span class="cm">    * A set of flags that describes optimizations that the host may perform</span>
<span class="cm">    * while performing this surface DMA operation.  The guest should never rely</span>
<span class="cm">    * on behaviour that is different when these flags are set for correctness.</span>
<span class="cm">    *</span>
<span class="cm">    * Defaults to 0</span>
<span class="cm">    */</span>
   <span class="n">SVGA3dSurfaceDMAFlags</span> <span class="n">flags</span><span class="p">;</span>
<span class="p">}</span> <span class="n">SVGA3dCmdSurfaceDMASuffix</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * SVGA_3D_CMD_DRAW_PRIMITIVES --</span>
<span class="cm"> *</span>
<span class="cm"> *   This command is the SVGA3D device&#39;s generic drawing entry point.</span>
<span class="cm"> *   It can draw multiple ranges of primitives, optionally using an</span>
<span class="cm"> *   index buffer, using an arbitrary collection of vertex buffers.</span>
<span class="cm"> *</span>
<span class="cm"> *   Each SVGA3dVertexDecl defines a distinct vertex array to bind</span>
<span class="cm"> *   during this draw call. The declarations specify which surface</span>
<span class="cm"> *   the vertex data lives in, what that vertex data is used for,</span>
<span class="cm"> *   and how to interpret it.</span>
<span class="cm"> *</span>
<span class="cm"> *   Each SVGA3dPrimitiveRange defines a collection of primitives</span>
<span class="cm"> *   to render using the same vertex arrays. An index buffer is</span>
<span class="cm"> *   optional.</span>
<span class="cm"> */</span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="p">{</span>
   <span class="cm">/*</span>
<span class="cm">    * A range hint is an optional specification for the range of indices</span>
<span class="cm">    * in an SVGA3dArray that will be used. If &#39;last&#39; is zero, it is assumed</span>
<span class="cm">    * that the entire array will be used.</span>
<span class="cm">    *</span>
<span class="cm">    * These are only hints. The SVGA3D device may use them for</span>
<span class="cm">    * performance optimization if possible, but it&#39;s also allowed to</span>
<span class="cm">    * ignore these values.</span>
<span class="cm">    */</span>
   <span class="n">uint32</span>               <span class="n">first</span><span class="p">;</span>
   <span class="n">uint32</span>               <span class="n">last</span><span class="p">;</span>
<span class="p">}</span> <span class="n">SVGA3dArrayRangeHint</span><span class="p">;</span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="p">{</span>
   <span class="cm">/*</span>
<span class="cm">    * Define the origin and shape of a vertex or index array. Both</span>
<span class="cm">    * &#39;offset&#39; and &#39;stride&#39; are in bytes. The provided surface will be</span>
<span class="cm">    * reinterpreted as a flat array of bytes in the same format used</span>
<span class="cm">    * by surface DMA operations. To avoid unnecessary conversions, the</span>
<span class="cm">    * surface should be created with the SVGA3D_BUFFER format.</span>
<span class="cm">    *</span>
<span class="cm">    * Index 0 in the array starts &#39;offset&#39; bytes into the surface.</span>
<span class="cm">    * Index 1 begins at byte &#39;offset + stride&#39;, etc. Array indices may</span>
<span class="cm">    * not be negative.</span>
<span class="cm">    */</span>
   <span class="n">uint32</span>               <span class="n">surfaceId</span><span class="p">;</span>
   <span class="n">uint32</span>               <span class="n">offset</span><span class="p">;</span>
   <span class="n">uint32</span>               <span class="n">stride</span><span class="p">;</span>
<span class="p">}</span> <span class="n">SVGA3dArray</span><span class="p">;</span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="p">{</span>
   <span class="cm">/*</span>
<span class="cm">    * Describe a vertex array&#39;s data type, and define how it is to be</span>
<span class="cm">    * used by the fixed function pipeline or the vertex shader. It</span>
<span class="cm">    * isn&#39;t useful to have two VertexDecls with the same</span>
<span class="cm">    * VertexArrayIdentity in one draw call.</span>
<span class="cm">    */</span>
   <span class="n">SVGA3dDeclType</span>       <span class="n">type</span><span class="p">;</span>
   <span class="n">SVGA3dDeclMethod</span>     <span class="n">method</span><span class="p">;</span>
   <span class="n">SVGA3dDeclUsage</span>      <span class="n">usage</span><span class="p">;</span>
   <span class="n">uint32</span>               <span class="n">usageIndex</span><span class="p">;</span>
<span class="p">}</span> <span class="n">SVGA3dVertexArrayIdentity</span><span class="p">;</span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="p">{</span>
   <span class="n">SVGA3dVertexArrayIdentity</span>  <span class="n">identity</span><span class="p">;</span>
   <span class="n">SVGA3dArray</span>                <span class="n">array</span><span class="p">;</span>
   <span class="n">SVGA3dArrayRangeHint</span>       <span class="n">rangeHint</span><span class="p">;</span>
<span class="p">}</span> <span class="n">SVGA3dVertexDecl</span><span class="p">;</span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="p">{</span>
   <span class="cm">/*</span>
<span class="cm">    * Define a group of primitives to render, from sequential indices.</span>
<span class="cm">    *</span>
<span class="cm">    * The value of &#39;primitiveType&#39; and &#39;primitiveCount&#39; imply the</span>
<span class="cm">    * total number of vertices that will be rendered.</span>
<span class="cm">    */</span>
   <span class="n">SVGA3dPrimitiveType</span>  <span class="n">primType</span><span class="p">;</span>
   <span class="n">uint32</span>               <span class="n">primitiveCount</span><span class="p">;</span>

   <span class="cm">/*</span>
<span class="cm">    * Optional index buffer. If indexArray.surfaceId is</span>
<span class="cm">    * SVGA3D_INVALID_ID, we render without an index buffer. Rendering</span>
<span class="cm">    * without an index buffer is identical to rendering with an index</span>
<span class="cm">    * buffer containing the sequence [0, 1, 2, 3, ...].</span>
<span class="cm">    *</span>
<span class="cm">    * If an index buffer is in use, indexWidth specifies the width in</span>
<span class="cm">    * bytes of each index value. It must be less than or equal to</span>
<span class="cm">    * indexArray.stride.</span>
<span class="cm">    *</span>
<span class="cm">    * (Currently, the SVGA3D device requires index buffers to be tightly</span>
<span class="cm">    * packed. In other words, indexWidth == indexArray.stride)</span>
<span class="cm">    */</span>
   <span class="n">SVGA3dArray</span>          <span class="n">indexArray</span><span class="p">;</span>
   <span class="n">uint32</span>               <span class="n">indexWidth</span><span class="p">;</span>

   <span class="cm">/*</span>
<span class="cm">    * Optional index bias. This number is added to all indices from</span>
<span class="cm">    * indexArray before they are used as vertex array indices. This</span>
<span class="cm">    * can be used in multiple ways:</span>
<span class="cm">    *</span>
<span class="cm">    *  - When not using an indexArray, this bias can be used to</span>
<span class="cm">    *    specify where in the vertex arrays to begin rendering.</span>
<span class="cm">    *</span>
<span class="cm">    *  - A positive number here is equivalent to increasing the</span>
<span class="cm">    *    offset in each vertex array.</span>
<span class="cm">    *</span>
<span class="cm">    *  - A negative number can be used to render using a small</span>
<span class="cm">    *    vertex array and an index buffer that contains large</span>
<span class="cm">    *    values. This may be used by some applications that</span>
<span class="cm">    *    crop a vertex buffer without modifying their index</span>
<span class="cm">    *    buffer.</span>
<span class="cm">    *</span>
<span class="cm">    * Note that rendering with a negative bias value may be slower and</span>
<span class="cm">    * use more memory than rendering with a positive or zero bias.</span>
<span class="cm">    */</span>
   <span class="n">int32</span>                <span class="n">indexBias</span><span class="p">;</span>
<span class="p">}</span> <span class="n">SVGA3dPrimitiveRange</span><span class="p">;</span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="p">{</span>
   <span class="n">uint32</span>               <span class="n">cid</span><span class="p">;</span>
   <span class="n">uint32</span>               <span class="n">numVertexDecls</span><span class="p">;</span>
   <span class="n">uint32</span>               <span class="n">numRanges</span><span class="p">;</span>

   <span class="cm">/*</span>
<span class="cm">    * There are two variable size arrays after the</span>
<span class="cm">    * SVGA3dCmdDrawPrimitives structure. In order,</span>
<span class="cm">    * they are:</span>
<span class="cm">    *</span>
<span class="cm">    * 1. SVGA3dVertexDecl, quantity &#39;numVertexDecls&#39;, but no more than</span>
<span class="cm">    *    SVGA3D_MAX_VERTEX_ARRAYS;</span>
<span class="cm">    * 2. SVGA3dPrimitiveRange, quantity &#39;numRanges&#39;, but no more than</span>
<span class="cm">    *    SVGA3D_MAX_DRAW_PRIMITIVE_RANGES;</span>
<span class="cm">    * 3. Optionally, SVGA3dVertexDivisor, quantity &#39;numVertexDecls&#39; (contains</span>
<span class="cm">    *    the frequency divisor for the corresponding vertex decl).</span>
<span class="cm">    */</span>
<span class="p">}</span> <span class="n">SVGA3dCmdDrawPrimitives</span><span class="p">;</span>      <span class="cm">/* SVGA_3D_CMD_DRAWPRIMITIVES */</span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="p">{</span>
   <span class="n">uint32</span>                   <span class="n">stage</span><span class="p">;</span>
   <span class="n">SVGA3dTextureStateName</span>   <span class="n">name</span><span class="p">;</span>
   <span class="k">union</span> <span class="p">{</span>
      <span class="n">uint32</span>                <span class="n">value</span><span class="p">;</span>
      <span class="kt">float</span>                 <span class="n">floatValue</span><span class="p">;</span>
   <span class="p">};</span>
<span class="p">}</span> <span class="n">SVGA3dTextureState</span><span class="p">;</span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="p">{</span>
   <span class="n">uint32</span>               <span class="n">cid</span><span class="p">;</span>
   <span class="cm">/* Followed by variable number of SVGA3dTextureState structures */</span>
<span class="p">}</span> <span class="n">SVGA3dCmdSetTextureState</span><span class="p">;</span>      <span class="cm">/* SVGA_3D_CMD_SETTEXTURESTATE */</span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="p">{</span>
   <span class="n">uint32</span>                   <span class="n">cid</span><span class="p">;</span>
   <span class="n">SVGA3dTransformType</span>      <span class="n">type</span><span class="p">;</span>
   <span class="kt">float</span>                    <span class="n">matrix</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
<span class="p">}</span> <span class="n">SVGA3dCmdSetTransform</span><span class="p">;</span>          <span class="cm">/* SVGA_3D_CMD_SETTRANSFORM */</span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="p">{</span>
   <span class="kt">float</span>                <span class="n">min</span><span class="p">;</span>
   <span class="kt">float</span>                <span class="n">max</span><span class="p">;</span>
<span class="p">}</span> <span class="n">SVGA3dZRange</span><span class="p">;</span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="p">{</span>
   <span class="n">uint32</span>               <span class="n">cid</span><span class="p">;</span>
   <span class="n">SVGA3dZRange</span>         <span class="n">zRange</span><span class="p">;</span>
<span class="p">}</span> <span class="n">SVGA3dCmdSetZRange</span><span class="p">;</span>             <span class="cm">/* SVGA_3D_CMD_SETZRANGE */</span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="p">{</span>
   <span class="kt">float</span>                <span class="n">diffuse</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
   <span class="kt">float</span>                <span class="n">ambient</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
   <span class="kt">float</span>                <span class="n">specular</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
   <span class="kt">float</span>                <span class="n">emissive</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
   <span class="kt">float</span>                <span class="n">shininess</span><span class="p">;</span>
<span class="p">}</span> <span class="n">SVGA3dMaterial</span><span class="p">;</span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="p">{</span>
   <span class="n">uint32</span>               <span class="n">cid</span><span class="p">;</span>
   <span class="n">SVGA3dFace</span>           <span class="n">face</span><span class="p">;</span>
   <span class="n">SVGA3dMaterial</span>       <span class="n">material</span><span class="p">;</span>
<span class="p">}</span> <span class="n">SVGA3dCmdSetMaterial</span><span class="p">;</span>           <span class="cm">/* SVGA_3D_CMD_SETMATERIAL */</span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="p">{</span>
   <span class="n">uint32</span>               <span class="n">cid</span><span class="p">;</span>
   <span class="n">uint32</span>               <span class="n">index</span><span class="p">;</span>
   <span class="n">SVGA3dLightData</span>      <span class="n">data</span><span class="p">;</span>
<span class="p">}</span> <span class="n">SVGA3dCmdSetLightData</span><span class="p">;</span>           <span class="cm">/* SVGA_3D_CMD_SETLIGHTDATA */</span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="p">{</span>
   <span class="n">uint32</span>               <span class="n">cid</span><span class="p">;</span>
   <span class="n">uint32</span>               <span class="n">index</span><span class="p">;</span>
   <span class="n">uint32</span>               <span class="n">enabled</span><span class="p">;</span>
<span class="p">}</span> <span class="n">SVGA3dCmdSetLightEnabled</span><span class="p">;</span>      <span class="cm">/* SVGA_3D_CMD_SETLIGHTENABLED */</span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="p">{</span>
   <span class="n">uint32</span>               <span class="n">cid</span><span class="p">;</span>
   <span class="n">SVGA3dRect</span>           <span class="n">rect</span><span class="p">;</span>
<span class="p">}</span> <span class="n">SVGA3dCmdSetViewport</span><span class="p">;</span>           <span class="cm">/* SVGA_3D_CMD_SETVIEWPORT */</span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="p">{</span>
   <span class="n">uint32</span>               <span class="n">cid</span><span class="p">;</span>
   <span class="n">SVGA3dRect</span>           <span class="n">rect</span><span class="p">;</span>
<span class="p">}</span> <span class="n">SVGA3dCmdSetScissorRect</span><span class="p">;</span>         <span class="cm">/* SVGA_3D_CMD_SETSCISSORRECT */</span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="p">{</span>
   <span class="n">uint32</span>               <span class="n">cid</span><span class="p">;</span>
   <span class="n">uint32</span>               <span class="n">index</span><span class="p">;</span>
   <span class="kt">float</span>                <span class="n">plane</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="p">}</span> <span class="n">SVGA3dCmdSetClipPlane</span><span class="p">;</span>           <span class="cm">/* SVGA_3D_CMD_SETCLIPPLANE */</span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="p">{</span>
   <span class="n">uint32</span>               <span class="n">cid</span><span class="p">;</span>
   <span class="n">uint32</span>               <span class="n">shid</span><span class="p">;</span>
   <span class="n">SVGA3dShaderType</span>     <span class="n">type</span><span class="p">;</span>
   <span class="cm">/* Followed by variable number of DWORDs for shader bycode */</span>
<span class="p">}</span> <span class="n">SVGA3dCmdDefineShader</span><span class="p">;</span>           <span class="cm">/* SVGA_3D_CMD_SHADER_DEFINE */</span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="p">{</span>
   <span class="n">uint32</span>               <span class="n">cid</span><span class="p">;</span>
   <span class="n">uint32</span>               <span class="n">shid</span><span class="p">;</span>
   <span class="n">SVGA3dShaderType</span>     <span class="n">type</span><span class="p">;</span>
<span class="p">}</span> <span class="n">SVGA3dCmdDestroyShader</span><span class="p">;</span>         <span class="cm">/* SVGA_3D_CMD_SHADER_DESTROY */</span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="p">{</span>
   <span class="n">uint32</span>                  <span class="n">cid</span><span class="p">;</span>
   <span class="n">uint32</span>                  <span class="n">reg</span><span class="p">;</span>     <span class="cm">/* register number */</span>
   <span class="n">SVGA3dShaderType</span>        <span class="n">type</span><span class="p">;</span>
   <span class="n">SVGA3dShaderConstType</span>   <span class="n">ctype</span><span class="p">;</span>
   <span class="n">uint32</span>                  <span class="n">values</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="p">}</span> <span class="n">SVGA3dCmdSetShaderConst</span><span class="p">;</span>        <span class="cm">/* SVGA_3D_CMD_SET_SHADER_CONST */</span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="p">{</span>
   <span class="n">uint32</span>               <span class="n">cid</span><span class="p">;</span>
   <span class="n">SVGA3dShaderType</span>     <span class="n">type</span><span class="p">;</span>
   <span class="n">uint32</span>               <span class="n">shid</span><span class="p">;</span>
<span class="p">}</span> <span class="n">SVGA3dCmdSetShader</span><span class="p">;</span>             <span class="cm">/* SVGA_3D_CMD_SET_SHADER */</span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="p">{</span>
   <span class="n">uint32</span>               <span class="n">cid</span><span class="p">;</span>
   <span class="n">SVGA3dQueryType</span>      <span class="n">type</span><span class="p">;</span>
<span class="p">}</span> <span class="n">SVGA3dCmdBeginQuery</span><span class="p">;</span>           <span class="cm">/* SVGA_3D_CMD_BEGIN_QUERY */</span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="p">{</span>
   <span class="n">uint32</span>               <span class="n">cid</span><span class="p">;</span>
   <span class="n">SVGA3dQueryType</span>      <span class="n">type</span><span class="p">;</span>
   <span class="n">SVGAGuestPtr</span>         <span class="n">guestResult</span><span class="p">;</span>  <span class="cm">/* Points to an SVGA3dQueryResult structure */</span>
<span class="p">}</span> <span class="n">SVGA3dCmdEndQuery</span><span class="p">;</span>                  <span class="cm">/* SVGA_3D_CMD_END_QUERY */</span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="p">{</span>
   <span class="n">uint32</span>               <span class="n">cid</span><span class="p">;</span>          <span class="cm">/* Same parameters passed to END_QUERY */</span>
   <span class="n">SVGA3dQueryType</span>      <span class="n">type</span><span class="p">;</span>
   <span class="n">SVGAGuestPtr</span>         <span class="n">guestResult</span><span class="p">;</span>
<span class="p">}</span> <span class="n">SVGA3dCmdWaitForQuery</span><span class="p">;</span>              <span class="cm">/* SVGA_3D_CMD_WAIT_FOR_QUERY */</span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="p">{</span>
   <span class="n">uint32</span>               <span class="n">totalSize</span><span class="p">;</span>    <span class="cm">/* Set by guest before query is ended. */</span>
   <span class="n">SVGA3dQueryState</span>     <span class="n">state</span><span class="p">;</span>        <span class="cm">/* Set by host or guest. See SVGA3dQueryState. */</span>
   <span class="k">union</span> <span class="p">{</span>                            <span class="cm">/* Set by host on exit from PENDING state */</span>
      <span class="n">uint32</span>            <span class="n">result32</span><span class="p">;</span>
   <span class="p">};</span>
<span class="p">}</span> <span class="n">SVGA3dQueryResult</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * SVGA_3D_CMD_BLIT_SURFACE_TO_SCREEN --</span>
<span class="cm"> *</span>
<span class="cm"> *    This is a blit from an SVGA3D surface to a Screen Object. Just</span>
<span class="cm"> *    like GMR-to-screen blits, this blit may be directed at a</span>
<span class="cm"> *    specific screen or to the virtual coordinate space.</span>
<span class="cm"> *</span>
<span class="cm"> *    The blit copies from a rectangular region of an SVGA3D surface</span>
<span class="cm"> *    image to a rectangular region of a screen or screens.</span>
<span class="cm"> *</span>
<span class="cm"> *    This command takes an optional variable-length list of clipping</span>
<span class="cm"> *    rectangles after the body of the command. If no rectangles are</span>
<span class="cm"> *    specified, there is no clipping region. The entire destRect is</span>
<span class="cm"> *    drawn to. If one or more rectangles are included, they describe</span>
<span class="cm"> *    a clipping region. The clip rectangle coordinates are measured</span>
<span class="cm"> *    relative to the top-left corner of destRect.</span>
<span class="cm"> *</span>
<span class="cm"> *    This clipping region serves multiple purposes:</span>
<span class="cm"> *</span>
<span class="cm"> *      - It can be used to perform an irregularly shaped blit more</span>
<span class="cm"> *        efficiently than by issuing many separate blit commands.</span>
<span class="cm"> *</span>
<span class="cm"> *      - It is equivalent to allowing blits with non-integer</span>
<span class="cm"> *        source coordinates. You could blit just one half-pixel</span>
<span class="cm"> *        of a source, for example, by specifying a larger</span>
<span class="cm"> *        destination rectangle than you need, then removing</span>
<span class="cm"> *        part of it using a clip rectangle.</span>
<span class="cm"> *</span>
<span class="cm"> * Availability:</span>
<span class="cm"> *    SVGA_FIFO_CAP_SCREEN_OBJECT</span>
<span class="cm"> *</span>
<span class="cm"> * Limitations:</span>
<span class="cm"> *</span>
<span class="cm"> *    - Currently, no backend supports blits from a mipmap or face</span>
<span class="cm"> *      other than the first one.</span>
<span class="cm"> */</span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="p">{</span>
   <span class="n">SVGA3dSurfaceImageId</span> <span class="n">srcImage</span><span class="p">;</span>
   <span class="n">SVGASignedRect</span>       <span class="n">srcRect</span><span class="p">;</span>
   <span class="n">uint32</span>               <span class="n">destScreenId</span><span class="p">;</span> <span class="cm">/* Screen ID or SVGA_ID_INVALID for virt. coords */</span>
   <span class="n">SVGASignedRect</span>       <span class="n">destRect</span><span class="p">;</span>     <span class="cm">/* Supports scaling if src/rest different size */</span>
   <span class="cm">/* Clipping: zero or more SVGASignedRects follow */</span>
<span class="p">}</span> <span class="n">SVGA3dCmdBlitSurfaceToScreen</span><span class="p">;</span>         <span class="cm">/* SVGA_3D_CMD_BLIT_SURFACE_TO_SCREEN */</span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="p">{</span>
   <span class="n">uint32</span>               <span class="n">sid</span><span class="p">;</span>
   <span class="n">SVGA3dTextureFilter</span>  <span class="n">filter</span><span class="p">;</span>
<span class="p">}</span> <span class="n">SVGA3dCmdGenerateMipmaps</span><span class="p">;</span>             <span class="cm">/* SVGA_3D_CMD_GENERATE_MIPMAPS */</span>


<span class="cm">/*</span>
<span class="cm"> * Capability query index.</span>
<span class="cm"> *</span>
<span class="cm"> * Notes:</span>
<span class="cm"> *</span>
<span class="cm"> *   1. SVGA3D_DEVCAP_MAX_TEXTURES reflects the maximum number of</span>
<span class="cm"> *      fixed-function texture units available. Each of these units</span>
<span class="cm"> *      work in both FFP and Shader modes, and they support texture</span>
<span class="cm"> *      transforms and texture coordinates. The host may have additional</span>
<span class="cm"> *      texture image units that are only usable with shaders.</span>
<span class="cm"> *</span>
<span class="cm"> *   2. The BUFFER_FORMAT capabilities are deprecated, and they always</span>
<span class="cm"> *      return TRUE. Even on physical hardware that does not support</span>
<span class="cm"> *      these formats natively, the SVGA3D device will provide an emulation</span>
<span class="cm"> *      which should be invisible to the guest OS.</span>
<span class="cm"> *</span>
<span class="cm"> *      In general, the SVGA3D device should support any operation on</span>
<span class="cm"> *      any surface format, it just may perform some of these</span>
<span class="cm"> *      operations in software depending on the capabilities of the</span>
<span class="cm"> *      available physical hardware.</span>
<span class="cm"> *</span>
<span class="cm"> *      XXX: In the future, we will add capabilities that describe in</span>
<span class="cm"> *      detail what formats are supported in hardware for what kinds</span>
<span class="cm"> *      of operations.</span>
<span class="cm"> */</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
   <span class="n">SVGA3D_DEVCAP_3D</span>                                <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
   <span class="n">SVGA3D_DEVCAP_MAX_LIGHTS</span>                        <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
   <span class="n">SVGA3D_DEVCAP_MAX_TEXTURES</span>                      <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>  <span class="cm">/* See note (1) */</span>
   <span class="n">SVGA3D_DEVCAP_MAX_CLIP_PLANES</span>                   <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
   <span class="n">SVGA3D_DEVCAP_VERTEX_SHADER_VERSION</span>             <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
   <span class="n">SVGA3D_DEVCAP_VERTEX_SHADER</span>                     <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
   <span class="n">SVGA3D_DEVCAP_FRAGMENT_SHADER_VERSION</span>           <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
   <span class="n">SVGA3D_DEVCAP_FRAGMENT_SHADER</span>                   <span class="o">=</span> <span class="mi">7</span><span class="p">,</span>
   <span class="n">SVGA3D_DEVCAP_MAX_RENDER_TARGETS</span>                <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
   <span class="n">SVGA3D_DEVCAP_S23E8_TEXTURES</span>                    <span class="o">=</span> <span class="mi">9</span><span class="p">,</span>
   <span class="n">SVGA3D_DEVCAP_S10E5_TEXTURES</span>                    <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
   <span class="n">SVGA3D_DEVCAP_MAX_FIXED_VERTEXBLEND</span>             <span class="o">=</span> <span class="mi">11</span><span class="p">,</span>
   <span class="n">SVGA3D_DEVCAP_D16_BUFFER_FORMAT</span>                 <span class="o">=</span> <span class="mi">12</span><span class="p">,</span> <span class="cm">/* See note (2) */</span>
   <span class="n">SVGA3D_DEVCAP_D24S8_BUFFER_FORMAT</span>               <span class="o">=</span> <span class="mi">13</span><span class="p">,</span> <span class="cm">/* See note (2) */</span>
   <span class="n">SVGA3D_DEVCAP_D24X8_BUFFER_FORMAT</span>               <span class="o">=</span> <span class="mi">14</span><span class="p">,</span> <span class="cm">/* See note (2) */</span>
   <span class="n">SVGA3D_DEVCAP_QUERY_TYPES</span>                       <span class="o">=</span> <span class="mi">15</span><span class="p">,</span>
   <span class="n">SVGA3D_DEVCAP_TEXTURE_GRADIENT_SAMPLING</span>         <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>
   <span class="n">SVGA3D_DEVCAP_MAX_POINT_SIZE</span>                    <span class="o">=</span> <span class="mi">17</span><span class="p">,</span>
   <span class="n">SVGA3D_DEVCAP_MAX_SHADER_TEXTURES</span>               <span class="o">=</span> <span class="mi">18</span><span class="p">,</span>
   <span class="n">SVGA3D_DEVCAP_MAX_TEXTURE_WIDTH</span>                 <span class="o">=</span> <span class="mi">19</span><span class="p">,</span>
   <span class="n">SVGA3D_DEVCAP_MAX_TEXTURE_HEIGHT</span>                <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
   <span class="n">SVGA3D_DEVCAP_MAX_VOLUME_EXTENT</span>                 <span class="o">=</span> <span class="mi">21</span><span class="p">,</span>
   <span class="n">SVGA3D_DEVCAP_MAX_TEXTURE_REPEAT</span>                <span class="o">=</span> <span class="mi">22</span><span class="p">,</span>
   <span class="n">SVGA3D_DEVCAP_MAX_TEXTURE_ASPECT_RATIO</span>          <span class="o">=</span> <span class="mi">23</span><span class="p">,</span>
   <span class="n">SVGA3D_DEVCAP_MAX_TEXTURE_ANISOTROPY</span>            <span class="o">=</span> <span class="mi">24</span><span class="p">,</span>
   <span class="n">SVGA3D_DEVCAP_MAX_PRIMITIVE_COUNT</span>               <span class="o">=</span> <span class="mi">25</span><span class="p">,</span>
   <span class="n">SVGA3D_DEVCAP_MAX_VERTEX_INDEX</span>                  <span class="o">=</span> <span class="mi">26</span><span class="p">,</span>
   <span class="n">SVGA3D_DEVCAP_MAX_VERTEX_SHADER_INSTRUCTIONS</span>    <span class="o">=</span> <span class="mi">27</span><span class="p">,</span>
   <span class="n">SVGA3D_DEVCAP_MAX_FRAGMENT_SHADER_INSTRUCTIONS</span>  <span class="o">=</span> <span class="mi">28</span><span class="p">,</span>
   <span class="n">SVGA3D_DEVCAP_MAX_VERTEX_SHADER_TEMPS</span>           <span class="o">=</span> <span class="mi">29</span><span class="p">,</span>
   <span class="n">SVGA3D_DEVCAP_MAX_FRAGMENT_SHADER_TEMPS</span>         <span class="o">=</span> <span class="mi">30</span><span class="p">,</span>
   <span class="n">SVGA3D_DEVCAP_TEXTURE_OPS</span>                       <span class="o">=</span> <span class="mi">31</span><span class="p">,</span>
   <span class="n">SVGA3D_DEVCAP_SURFACEFMT_X8R8G8B8</span>               <span class="o">=</span> <span class="mi">32</span><span class="p">,</span>
   <span class="n">SVGA3D_DEVCAP_SURFACEFMT_A8R8G8B8</span>               <span class="o">=</span> <span class="mi">33</span><span class="p">,</span>
   <span class="n">SVGA3D_DEVCAP_SURFACEFMT_A2R10G10B10</span>            <span class="o">=</span> <span class="mi">34</span><span class="p">,</span>
   <span class="n">SVGA3D_DEVCAP_SURFACEFMT_X1R5G5B5</span>               <span class="o">=</span> <span class="mi">35</span><span class="p">,</span>
   <span class="n">SVGA3D_DEVCAP_SURFACEFMT_A1R5G5B5</span>               <span class="o">=</span> <span class="mi">36</span><span class="p">,</span>
   <span class="n">SVGA3D_DEVCAP_SURFACEFMT_A4R4G4B4</span>               <span class="o">=</span> <span class="mi">37</span><span class="p">,</span>
   <span class="n">SVGA3D_DEVCAP_SURFACEFMT_R5G6B5</span>                 <span class="o">=</span> <span class="mi">38</span><span class="p">,</span>
   <span class="n">SVGA3D_DEVCAP_SURFACEFMT_LUMINANCE16</span>            <span class="o">=</span> <span class="mi">39</span><span class="p">,</span>
   <span class="n">SVGA3D_DEVCAP_SURFACEFMT_LUMINANCE8_ALPHA8</span>      <span class="o">=</span> <span class="mi">40</span><span class="p">,</span>
   <span class="n">SVGA3D_DEVCAP_SURFACEFMT_ALPHA8</span>                 <span class="o">=</span> <span class="mi">41</span><span class="p">,</span>
   <span class="n">SVGA3D_DEVCAP_SURFACEFMT_LUMINANCE8</span>             <span class="o">=</span> <span class="mi">42</span><span class="p">,</span>
   <span class="n">SVGA3D_DEVCAP_SURFACEFMT_Z_D16</span>                  <span class="o">=</span> <span class="mi">43</span><span class="p">,</span>
   <span class="n">SVGA3D_DEVCAP_SURFACEFMT_Z_D24S8</span>                <span class="o">=</span> <span class="mi">44</span><span class="p">,</span>
   <span class="n">SVGA3D_DEVCAP_SURFACEFMT_Z_D24X8</span>                <span class="o">=</span> <span class="mi">45</span><span class="p">,</span>
   <span class="n">SVGA3D_DEVCAP_SURFACEFMT_DXT1</span>                   <span class="o">=</span> <span class="mi">46</span><span class="p">,</span>
   <span class="n">SVGA3D_DEVCAP_SURFACEFMT_DXT2</span>                   <span class="o">=</span> <span class="mi">47</span><span class="p">,</span>
   <span class="n">SVGA3D_DEVCAP_SURFACEFMT_DXT3</span>                   <span class="o">=</span> <span class="mi">48</span><span class="p">,</span>
   <span class="n">SVGA3D_DEVCAP_SURFACEFMT_DXT4</span>                   <span class="o">=</span> <span class="mi">49</span><span class="p">,</span>
   <span class="n">SVGA3D_DEVCAP_SURFACEFMT_DXT5</span>                   <span class="o">=</span> <span class="mi">50</span><span class="p">,</span>
   <span class="n">SVGA3D_DEVCAP_SURFACEFMT_BUMPX8L8V8U8</span>           <span class="o">=</span> <span class="mi">51</span><span class="p">,</span>
   <span class="n">SVGA3D_DEVCAP_SURFACEFMT_A2W10V10U10</span>            <span class="o">=</span> <span class="mi">52</span><span class="p">,</span>
   <span class="n">SVGA3D_DEVCAP_SURFACEFMT_BUMPU8V8</span>               <span class="o">=</span> <span class="mi">53</span><span class="p">,</span>
   <span class="n">SVGA3D_DEVCAP_SURFACEFMT_Q8W8V8U8</span>               <span class="o">=</span> <span class="mi">54</span><span class="p">,</span>
   <span class="n">SVGA3D_DEVCAP_SURFACEFMT_CxV8U8</span>                 <span class="o">=</span> <span class="mi">55</span><span class="p">,</span>
   <span class="n">SVGA3D_DEVCAP_SURFACEFMT_R_S10E5</span>                <span class="o">=</span> <span class="mi">56</span><span class="p">,</span>
   <span class="n">SVGA3D_DEVCAP_SURFACEFMT_R_S23E8</span>                <span class="o">=</span> <span class="mi">57</span><span class="p">,</span>
   <span class="n">SVGA3D_DEVCAP_SURFACEFMT_RG_S10E5</span>               <span class="o">=</span> <span class="mi">58</span><span class="p">,</span>
   <span class="n">SVGA3D_DEVCAP_SURFACEFMT_RG_S23E8</span>               <span class="o">=</span> <span class="mi">59</span><span class="p">,</span>
   <span class="n">SVGA3D_DEVCAP_SURFACEFMT_ARGB_S10E5</span>             <span class="o">=</span> <span class="mi">60</span><span class="p">,</span>
   <span class="n">SVGA3D_DEVCAP_SURFACEFMT_ARGB_S23E8</span>             <span class="o">=</span> <span class="mi">61</span><span class="p">,</span>
   <span class="n">SVGA3D_DEVCAP_MAX_VERTEX_SHADER_TEXTURES</span>        <span class="o">=</span> <span class="mi">63</span><span class="p">,</span>

   <span class="cm">/*</span>
<span class="cm">    * Note that MAX_SIMULTANEOUS_RENDER_TARGETS is a maximum count of color</span>
<span class="cm">    * render targets.  This does no include the depth or stencil targets.</span>
<span class="cm">    */</span>
   <span class="n">SVGA3D_DEVCAP_MAX_SIMULTANEOUS_RENDER_TARGETS</span>   <span class="o">=</span> <span class="mi">64</span><span class="p">,</span>

   <span class="n">SVGA3D_DEVCAP_SURFACEFMT_V16U16</span>                 <span class="o">=</span> <span class="mi">65</span><span class="p">,</span>
   <span class="n">SVGA3D_DEVCAP_SURFACEFMT_G16R16</span>                 <span class="o">=</span> <span class="mi">66</span><span class="p">,</span>
   <span class="n">SVGA3D_DEVCAP_SURFACEFMT_A16B16G16R16</span>           <span class="o">=</span> <span class="mi">67</span><span class="p">,</span>
   <span class="n">SVGA3D_DEVCAP_SURFACEFMT_UYVY</span>                   <span class="o">=</span> <span class="mi">68</span><span class="p">,</span>
   <span class="n">SVGA3D_DEVCAP_SURFACEFMT_YUY2</span>                   <span class="o">=</span> <span class="mi">69</span><span class="p">,</span>
   <span class="n">SVGA3D_DEVCAP_MULTISAMPLE_NONMASKABLESAMPLES</span>    <span class="o">=</span> <span class="mi">70</span><span class="p">,</span>
   <span class="n">SVGA3D_DEVCAP_MULTISAMPLE_MASKABLESAMPLES</span>       <span class="o">=</span> <span class="mi">71</span><span class="p">,</span>
   <span class="n">SVGA3D_DEVCAP_ALPHATOCOVERAGE</span>                   <span class="o">=</span> <span class="mi">72</span><span class="p">,</span>
   <span class="n">SVGA3D_DEVCAP_SUPERSAMPLE</span>                       <span class="o">=</span> <span class="mi">73</span><span class="p">,</span>
   <span class="n">SVGA3D_DEVCAP_AUTOGENMIPMAPS</span>                    <span class="o">=</span> <span class="mi">74</span><span class="p">,</span>
   <span class="n">SVGA3D_DEVCAP_SURFACEFMT_NV12</span>                   <span class="o">=</span> <span class="mi">75</span><span class="p">,</span>
   <span class="n">SVGA3D_DEVCAP_SURFACEFMT_AYUV</span>                   <span class="o">=</span> <span class="mi">76</span><span class="p">,</span>

   <span class="cm">/*</span>
<span class="cm">    * This is the maximum number of SVGA context IDs that the guest</span>
<span class="cm">    * can define using SVGA_3D_CMD_CONTEXT_DEFINE.</span>
<span class="cm">    */</span>
   <span class="n">SVGA3D_DEVCAP_MAX_CONTEXT_IDS</span>                   <span class="o">=</span> <span class="mi">77</span><span class="p">,</span>

   <span class="cm">/*</span>
<span class="cm">    * This is the maximum number of SVGA surface IDs that the guest</span>
<span class="cm">    * can define using SVGA_3D_CMD_SURFACE_DEFINE*.</span>
<span class="cm">    */</span>
   <span class="n">SVGA3D_DEVCAP_MAX_SURFACE_IDS</span>                   <span class="o">=</span> <span class="mi">78</span><span class="p">,</span>

   <span class="n">SVGA3D_DEVCAP_SURFACEFMT_Z_DF16</span>                 <span class="o">=</span> <span class="mi">79</span><span class="p">,</span>
   <span class="n">SVGA3D_DEVCAP_SURFACEFMT_Z_DF24</span>                 <span class="o">=</span> <span class="mi">80</span><span class="p">,</span>
   <span class="n">SVGA3D_DEVCAP_SURFACEFMT_Z_D24S8_INT</span>            <span class="o">=</span> <span class="mi">81</span><span class="p">,</span>

   <span class="n">SVGA3D_DEVCAP_SURFACEFMT_BC4_UNORM</span>              <span class="o">=</span> <span class="mi">82</span><span class="p">,</span>
   <span class="n">SVGA3D_DEVCAP_SURFACEFMT_BC5_UNORM</span>              <span class="o">=</span> <span class="mi">83</span><span class="p">,</span>

   <span class="cm">/*</span>
<span class="cm">    * Don&#39;t add new caps into the previous section; the values in this</span>
<span class="cm">    * enumeration must not change. You can put new values right before</span>
<span class="cm">    * SVGA3D_DEVCAP_MAX.</span>
<span class="cm">    */</span>
   <span class="n">SVGA3D_DEVCAP_MAX</span>                                  <span class="cm">/* This must be the last index. */</span>
<span class="p">}</span> <span class="n">SVGA3dDevCapIndex</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="p">{</span>
   <span class="n">Bool</span>   <span class="n">b</span><span class="p">;</span>
   <span class="n">uint32</span> <span class="n">u</span><span class="p">;</span>
   <span class="n">int32</span>  <span class="n">i</span><span class="p">;</span>
   <span class="kt">float</span>  <span class="n">f</span><span class="p">;</span>
<span class="p">}</span> <span class="n">SVGA3dDevCapResult</span><span class="p">;</span>

<span class="cp">#endif </span><span class="cm">/* _SVGA3D_REG_H_ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
