<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › gpu › drm › vmwgfx › vmwgfx_fence.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>vmwgfx_fence.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/**************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright © 2011 VMware, Inc., Palo Alto, CA., USA</span>
<span class="cm"> * All Rights Reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * Permission is hereby granted, free of charge, to any person obtaining a</span>
<span class="cm"> * copy of this software and associated documentation files (the</span>
<span class="cm"> * &quot;Software&quot;), to deal in the Software without restriction, including</span>
<span class="cm"> * without limitation the rights to use, copy, modify, merge, publish,</span>
<span class="cm"> * distribute, sub license, and/or sell copies of the Software, and to</span>
<span class="cm"> * permit persons to whom the Software is furnished to do so, subject to</span>
<span class="cm"> * the following conditions:</span>
<span class="cm"> *</span>
<span class="cm"> * The above copyright notice and this permission notice (including the</span>
<span class="cm"> * next paragraph) shall be included in all copies or substantial portions</span>
<span class="cm"> * of the Software.</span>
<span class="cm"> *</span>
<span class="cm"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span>
<span class="cm"> * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL</span>
<span class="cm"> * THE COPYRIGHT HOLDERS, AUTHORS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM,</span>
<span class="cm"> * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR</span>
<span class="cm"> * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE</span>
<span class="cm"> * USE OR OTHER DEALINGS IN THE SOFTWARE.</span>
<span class="cm"> *</span>
<span class="cm"> **************************************************************************/</span>

<span class="cp">#include &quot;drmP.h&quot;</span>
<span class="cp">#include &quot;vmwgfx_drv.h&quot;</span>

<span class="cp">#define VMW_FENCE_WRAP (1 &lt;&lt; 31)</span>

<span class="k">struct</span> <span class="n">vmw_fence_manager</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">num_fence_objects</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vmw_private</span> <span class="o">*</span><span class="n">dev_priv</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">fence_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">work</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">user_fence_size</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">fence_size</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">event_fence_action_size</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">fifo_down</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">cleanup_list</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">pending_actions</span><span class="p">[</span><span class="n">VMW_ACTION_MAX</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">goal_irq_mutex</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">goal_irq_on</span><span class="p">;</span> <span class="cm">/* Protected by @goal_irq_mutex */</span>
	<span class="n">bool</span> <span class="n">seqno_valid</span><span class="p">;</span> <span class="cm">/* Protected by @lock, and may not be set to true</span>
<span class="cm">			     without the @goal_irq_mutex held. */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">vmw_user_fence</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ttm_base_object</span> <span class="n">base</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vmw_fence_obj</span> <span class="n">fence</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct vmw_event_fence_action - fence action that delivers a drm event.</span>
<span class="cm"> *</span>
<span class="cm"> * @e: A struct drm_pending_event that controls the event delivery.</span>
<span class="cm"> * @action: A struct vmw_fence_action to hook up to a fence.</span>
<span class="cm"> * @fence: A referenced pointer to the fence to keep it alive while @action</span>
<span class="cm"> * hangs on it.</span>
<span class="cm"> * @dev: Pointer to a struct drm_device so we can access the event stuff.</span>
<span class="cm"> * @kref: Both @e and @action has destructors, so we need to refcount.</span>
<span class="cm"> * @size: Size accounted for this object.</span>
<span class="cm"> * @tv_sec: If non-null, the variable pointed to will be assigned</span>
<span class="cm"> * current time tv_sec val when the fence signals.</span>
<span class="cm"> * @tv_usec: Must be set if @tv_sec is set, and the variable pointed to will</span>
<span class="cm"> * be assigned the current time tv_usec val when the fence signals.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">vmw_event_fence_action</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">vmw_fence_action</span> <span class="n">action</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">fpriv_head</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">drm_pending_event</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vmw_fence_obj</span> <span class="o">*</span><span class="n">fence</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

	<span class="kt">uint32_t</span> <span class="o">*</span><span class="n">tv_sec</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="o">*</span><span class="n">tv_usec</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * Note on fencing subsystem usage of irqs:</span>
<span class="cm"> * Typically the vmw_fences_update function is called</span>
<span class="cm"> *</span>
<span class="cm"> * a) When a new fence seqno has been submitted by the fifo code.</span>
<span class="cm"> * b) On-demand when we have waiters. Sleeping waiters will switch on the</span>
<span class="cm"> * ANY_FENCE irq and call vmw_fences_update function each time an ANY_FENCE</span>
<span class="cm"> * irq is received. When the last fence waiter is gone, that IRQ is masked</span>
<span class="cm"> * away.</span>
<span class="cm"> *</span>
<span class="cm"> * In situations where there are no waiters and we don&#39;t submit any new fences,</span>
<span class="cm"> * fence objects may not be signaled. This is perfectly OK, since there are</span>
<span class="cm"> * no consumers of the signaled data, but that is NOT ok when there are fence</span>
<span class="cm"> * actions attached to a fence. The fencing subsystem then makes use of the</span>
<span class="cm"> * FENCE_GOAL irq and sets the fence goal seqno to that of the next fence</span>
<span class="cm"> * which has an action attached, and each time vmw_fences_update is called,</span>
<span class="cm"> * the subsystem makes sure the fence goal seqno is updated.</span>
<span class="cm"> *</span>
<span class="cm"> * The fence goal seqno irq is on as long as there are unsignaled fence</span>
<span class="cm"> * objects with actions attached to them.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vmw_fence_obj_destroy_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">kref</span> <span class="o">*</span><span class="n">kref</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vmw_fence_obj</span> <span class="o">*</span><span class="n">fence</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">kref</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vmw_fence_obj</span><span class="p">,</span> <span class="n">kref</span><span class="p">);</span>

	<span class="k">struct</span> <span class="n">vmw_fence_manager</span> <span class="o">*</span><span class="n">fman</span> <span class="o">=</span> <span class="n">fence</span><span class="o">-&gt;</span><span class="n">fman</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_fences</span><span class="p">;</span>

	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fence</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">);</span>
	<span class="n">num_fences</span> <span class="o">=</span> <span class="o">--</span><span class="n">fman</span><span class="o">-&gt;</span><span class="n">num_fence_objects</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fman</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fence</span><span class="o">-&gt;</span><span class="n">destroy</span><span class="p">)</span>
		<span class="n">fence</span><span class="o">-&gt;</span><span class="n">destroy</span><span class="p">(</span><span class="n">fence</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">fence</span><span class="p">);</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fman</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * Execute signal actions on fences recently signaled.</span>
<span class="cm"> * This is done from a workqueue so we don&#39;t have to execute</span>
<span class="cm"> * signal actions from atomic context.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vmw_fence_work_func</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vmw_fence_manager</span> <span class="o">*</span><span class="n">fman</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vmw_fence_manager</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vmw_fence_action</span> <span class="o">*</span><span class="n">action</span><span class="p">,</span> <span class="o">*</span><span class="n">next_action</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">seqno_valid</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fman</span><span class="o">-&gt;</span><span class="n">goal_irq_mutex</span><span class="p">);</span>

		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fman</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fman</span><span class="o">-&gt;</span><span class="n">cleanup_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">seqno_valid</span> <span class="o">=</span> <span class="n">fman</span><span class="o">-&gt;</span><span class="n">seqno_valid</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fman</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">seqno_valid</span> <span class="o">&amp;&amp;</span> <span class="n">fman</span><span class="o">-&gt;</span><span class="n">goal_irq_on</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">fman</span><span class="o">-&gt;</span><span class="n">goal_irq_on</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
			<span class="n">vmw_goal_waiter_remove</span><span class="p">(</span><span class="n">fman</span><span class="o">-&gt;</span><span class="n">dev_priv</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fman</span><span class="o">-&gt;</span><span class="n">goal_irq_mutex</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">list</span><span class="p">))</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * At this point, only we should be able to manipulate the</span>
<span class="cm">		 * list heads of the actions we have on the private list.</span>
<span class="cm">		 * hence fman::lock not held.</span>
<span class="cm">		 */</span>

		<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">action</span><span class="p">,</span> <span class="n">next_action</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">list</span><span class="p">,</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">action</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">action</span><span class="o">-&gt;</span><span class="n">cleanup</span><span class="p">)</span>
				<span class="n">action</span><span class="o">-&gt;</span><span class="n">cleanup</span><span class="p">(</span><span class="n">action</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">vmw_fence_manager</span> <span class="o">*</span><span class="nf">vmw_fence_manager_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmw_private</span> <span class="o">*</span><span class="n">dev_priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vmw_fence_manager</span> <span class="o">*</span><span class="n">fman</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">fman</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">fman</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">fman</span><span class="o">-&gt;</span><span class="n">dev_priv</span> <span class="o">=</span> <span class="n">dev_priv</span><span class="p">;</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fman</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fman</span><span class="o">-&gt;</span><span class="n">fence_list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fman</span><span class="o">-&gt;</span><span class="n">cleanup_list</span><span class="p">);</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fman</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vmw_fence_work_func</span><span class="p">);</span>
	<span class="n">fman</span><span class="o">-&gt;</span><span class="n">fifo_down</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">fman</span><span class="o">-&gt;</span><span class="n">user_fence_size</span> <span class="o">=</span> <span class="n">ttm_round_pot</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmw_user_fence</span><span class="p">));</span>
	<span class="n">fman</span><span class="o">-&gt;</span><span class="n">fence_size</span> <span class="o">=</span> <span class="n">ttm_round_pot</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmw_fence_obj</span><span class="p">));</span>
	<span class="n">fman</span><span class="o">-&gt;</span><span class="n">event_fence_action_size</span> <span class="o">=</span>
		<span class="n">ttm_round_pot</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmw_event_fence_action</span><span class="p">));</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fman</span><span class="o">-&gt;</span><span class="n">goal_irq_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">fman</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">vmw_fence_manager_takedown</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmw_fence_manager</span> <span class="o">*</span><span class="n">fman</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irq_flags</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">lists_empty</span><span class="p">;</span>

	<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">cancel_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fman</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fman</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">irq_flags</span><span class="p">);</span>
	<span class="n">lists_empty</span> <span class="o">=</span> <span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fman</span><span class="o">-&gt;</span><span class="n">fence_list</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fman</span><span class="o">-&gt;</span><span class="n">cleanup_list</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fman</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">irq_flags</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">lists_empty</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">fman</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vmw_fence_obj_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmw_fence_manager</span> <span class="o">*</span><span class="n">fman</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">vmw_fence_obj</span> <span class="o">*</span><span class="n">fence</span><span class="p">,</span>
			      <span class="n">u32</span> <span class="n">seqno</span><span class="p">,</span>
			      <span class="kt">uint32_t</span> <span class="n">mask</span><span class="p">,</span>
			      <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">destroy</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">vmw_fence_obj</span> <span class="o">*</span><span class="n">fence</span><span class="p">))</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irq_flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_fences</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">fence</span><span class="o">-&gt;</span><span class="n">seqno</span> <span class="o">=</span> <span class="n">seqno</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fence</span><span class="o">-&gt;</span><span class="n">seq_passed_actions</span><span class="p">);</span>
	<span class="n">fence</span><span class="o">-&gt;</span><span class="n">fman</span> <span class="o">=</span> <span class="n">fman</span><span class="p">;</span>
	<span class="n">fence</span><span class="o">-&gt;</span><span class="n">signaled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">fence</span><span class="o">-&gt;</span><span class="n">signal_mask</span> <span class="o">=</span> <span class="n">mask</span><span class="p">;</span>
	<span class="n">kref_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fence</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">);</span>
	<span class="n">fence</span><span class="o">-&gt;</span><span class="n">destroy</span> <span class="o">=</span> <span class="n">destroy</span><span class="p">;</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fence</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fman</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">irq_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">fman</span><span class="o">-&gt;</span><span class="n">fifo_down</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fence</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fman</span><span class="o">-&gt;</span><span class="n">fence_list</span><span class="p">);</span>
	<span class="n">num_fences</span> <span class="o">=</span> <span class="o">++</span><span class="n">fman</span><span class="o">-&gt;</span><span class="n">num_fence_objects</span><span class="p">;</span>

<span class="nl">out_unlock:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fman</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">irq_flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

<span class="p">}</span>

<span class="k">struct</span> <span class="n">vmw_fence_obj</span> <span class="o">*</span><span class="nf">vmw_fence_obj_reference</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmw_fence_obj</span> <span class="o">*</span><span class="n">fence</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">fence</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">kref_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fence</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">fence</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * vmw_fence_obj_unreference</span>
<span class="cm"> *</span>
<span class="cm"> * Note that this function may not be entered with disabled irqs since</span>
<span class="cm"> * it may re-enable them in the destroy function.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">vmw_fence_obj_unreference</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmw_fence_obj</span> <span class="o">**</span><span class="n">fence_p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vmw_fence_obj</span> <span class="o">*</span><span class="n">fence</span> <span class="o">=</span> <span class="o">*</span><span class="n">fence_p</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vmw_fence_manager</span> <span class="o">*</span><span class="n">fman</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">fence</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">fman</span> <span class="o">=</span> <span class="n">fence</span><span class="o">-&gt;</span><span class="n">fman</span><span class="p">;</span>
	<span class="o">*</span><span class="n">fence_p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fman</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fence</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">.</span><span class="n">refcount</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fence</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">,</span> <span class="n">vmw_fence_obj_destroy_locked</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fman</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">vmw_fences_perform_actions</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmw_fence_manager</span> <span class="o">*</span><span class="n">fman</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vmw_fence_action</span> <span class="o">*</span><span class="n">action</span><span class="p">,</span> <span class="o">*</span><span class="n">next_action</span><span class="p">;</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">action</span><span class="p">,</span> <span class="n">next_action</span><span class="p">,</span> <span class="n">list</span><span class="p">,</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">action</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">);</span>
		<span class="n">fman</span><span class="o">-&gt;</span><span class="n">pending_actions</span><span class="p">[</span><span class="n">action</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">action</span><span class="o">-&gt;</span><span class="n">seq_passed</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">action</span><span class="o">-&gt;</span><span class="n">seq_passed</span><span class="p">(</span><span class="n">action</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Add the cleanup action to the cleanup list so that</span>
<span class="cm">		 * it will be performed by a worker task.</span>
<span class="cm">		 */</span>

		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">action</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fman</span><span class="o">-&gt;</span><span class="n">cleanup_list</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * vmw_fence_goal_new_locked - Figure out a new device fence goal</span>
<span class="cm"> * seqno if needed.</span>
<span class="cm"> *</span>
<span class="cm"> * @fman: Pointer to a fence manager.</span>
<span class="cm"> * @passed_seqno: The seqno the device currently signals as passed.</span>
<span class="cm"> *</span>
<span class="cm"> * This function should be called with the fence manager lock held.</span>
<span class="cm"> * It is typically called when we have a new passed_seqno, and</span>
<span class="cm"> * we might need to update the fence goal. It checks to see whether</span>
<span class="cm"> * the current fence goal has already passed, and, in that case,</span>
<span class="cm"> * scans through all unsignaled fences to get the next fence object with an</span>
<span class="cm"> * action attached, and sets the seqno of that fence as a new fence goal.</span>
<span class="cm"> *</span>
<span class="cm"> * returns true if the device goal seqno was updated. False otherwise.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">vmw_fence_goal_new_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmw_fence_manager</span> <span class="o">*</span><span class="n">fman</span><span class="p">,</span>
				      <span class="n">u32</span> <span class="n">passed_seqno</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">goal_seqno</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">fifo_mem</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vmw_fence_obj</span> <span class="o">*</span><span class="n">fence</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">fman</span><span class="o">-&gt;</span><span class="n">seqno_valid</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">fifo_mem</span> <span class="o">=</span> <span class="n">fman</span><span class="o">-&gt;</span><span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">mmio_virt</span><span class="p">;</span>
	<span class="n">goal_seqno</span> <span class="o">=</span> <span class="n">ioread32</span><span class="p">(</span><span class="n">fifo_mem</span> <span class="o">+</span> <span class="n">SVGA_FIFO_FENCE_GOAL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">passed_seqno</span> <span class="o">-</span> <span class="n">goal_seqno</span> <span class="o">&gt;=</span> <span class="n">VMW_FENCE_WRAP</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">fman</span><span class="o">-&gt;</span><span class="n">seqno_valid</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">fence</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fman</span><span class="o">-&gt;</span><span class="n">fence_list</span><span class="p">,</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fence</span><span class="o">-&gt;</span><span class="n">seq_passed_actions</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">fman</span><span class="o">-&gt;</span><span class="n">seqno_valid</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="n">iowrite32</span><span class="p">(</span><span class="n">fence</span><span class="o">-&gt;</span><span class="n">seqno</span><span class="p">,</span>
				  <span class="n">fifo_mem</span> <span class="o">+</span> <span class="n">SVGA_FIFO_FENCE_GOAL</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * vmw_fence_goal_check_locked - Replace the device fence goal seqno if</span>
<span class="cm"> * needed.</span>
<span class="cm"> *</span>
<span class="cm"> * @fence: Pointer to a struct vmw_fence_obj the seqno of which should be</span>
<span class="cm"> * considered as a device fence goal.</span>
<span class="cm"> *</span>
<span class="cm"> * This function should be called with the fence manager lock held.</span>
<span class="cm"> * It is typically called when an action has been attached to a fence to</span>
<span class="cm"> * check whether the seqno of that fence should be used for a fence</span>
<span class="cm"> * goal interrupt. This is typically needed if the current fence goal is</span>
<span class="cm"> * invalid, or has a higher seqno than that of the current fence object.</span>
<span class="cm"> *</span>
<span class="cm"> * returns true if the device goal seqno was updated. False otherwise.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">vmw_fence_goal_check_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmw_fence_obj</span> <span class="o">*</span><span class="n">fence</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">goal_seqno</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">fifo_mem</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fence</span><span class="o">-&gt;</span><span class="n">signaled</span> <span class="o">&amp;</span> <span class="n">DRM_VMW_FENCE_FLAG_EXEC</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">fifo_mem</span> <span class="o">=</span> <span class="n">fence</span><span class="o">-&gt;</span><span class="n">fman</span><span class="o">-&gt;</span><span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">mmio_virt</span><span class="p">;</span>
	<span class="n">goal_seqno</span> <span class="o">=</span> <span class="n">ioread32</span><span class="p">(</span><span class="n">fifo_mem</span> <span class="o">+</span> <span class="n">SVGA_FIFO_FENCE_GOAL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">fence</span><span class="o">-&gt;</span><span class="n">fman</span><span class="o">-&gt;</span><span class="n">seqno_valid</span> <span class="o">&amp;&amp;</span>
		   <span class="n">goal_seqno</span> <span class="o">-</span> <span class="n">fence</span><span class="o">-&gt;</span><span class="n">seqno</span> <span class="o">&lt;</span> <span class="n">VMW_FENCE_WRAP</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">iowrite32</span><span class="p">(</span><span class="n">fence</span><span class="o">-&gt;</span><span class="n">seqno</span><span class="p">,</span> <span class="n">fifo_mem</span> <span class="o">+</span> <span class="n">SVGA_FIFO_FENCE_GOAL</span><span class="p">);</span>
	<span class="n">fence</span><span class="o">-&gt;</span><span class="n">fman</span><span class="o">-&gt;</span><span class="n">seqno_valid</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">vmw_fences_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmw_fence_manager</span> <span class="o">*</span><span class="n">fman</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vmw_fence_obj</span> <span class="o">*</span><span class="n">fence</span><span class="p">,</span> <span class="o">*</span><span class="n">next_fence</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">action_list</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">needs_rerun</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">seqno</span><span class="p">,</span> <span class="n">new_seqno</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">fifo_mem</span> <span class="o">=</span> <span class="n">fman</span><span class="o">-&gt;</span><span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">mmio_virt</span><span class="p">;</span>

	<span class="n">seqno</span> <span class="o">=</span> <span class="n">ioread32</span><span class="p">(</span><span class="n">fifo_mem</span> <span class="o">+</span> <span class="n">SVGA_FIFO_FENCE</span><span class="p">);</span>
<span class="nl">rerun:</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fman</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">fence</span><span class="p">,</span> <span class="n">next_fence</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fman</span><span class="o">-&gt;</span><span class="n">fence_list</span><span class="p">,</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">seqno</span> <span class="o">-</span> <span class="n">fence</span><span class="o">-&gt;</span><span class="n">seqno</span> <span class="o">&lt;</span> <span class="n">VMW_FENCE_WRAP</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fence</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">);</span>
			<span class="n">fence</span><span class="o">-&gt;</span><span class="n">signaled</span> <span class="o">|=</span> <span class="n">DRM_VMW_FENCE_FLAG_EXEC</span><span class="p">;</span>
			<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">action_list</span><span class="p">);</span>
			<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fence</span><span class="o">-&gt;</span><span class="n">seq_passed_actions</span><span class="p">,</span>
					 <span class="o">&amp;</span><span class="n">action_list</span><span class="p">);</span>
			<span class="n">vmw_fences_perform_actions</span><span class="p">(</span><span class="n">fman</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">action_list</span><span class="p">);</span>
			<span class="n">wake_up_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fence</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">needs_rerun</span> <span class="o">=</span> <span class="n">vmw_fence_goal_new_locked</span><span class="p">(</span><span class="n">fman</span><span class="p">,</span> <span class="n">seqno</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fman</span><span class="o">-&gt;</span><span class="n">cleanup_list</span><span class="p">))</span>
		<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fman</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fman</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Rerun if the fence goal seqno was updated, and the</span>
<span class="cm">	 * hardware might have raced with that update, so that</span>
<span class="cm">	 * we missed a fence_goal irq.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">needs_rerun</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">new_seqno</span> <span class="o">=</span> <span class="n">ioread32</span><span class="p">(</span><span class="n">fifo_mem</span> <span class="o">+</span> <span class="n">SVGA_FIFO_FENCE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new_seqno</span> <span class="o">!=</span> <span class="n">seqno</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">seqno</span> <span class="o">=</span> <span class="n">new_seqno</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">rerun</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="n">bool</span> <span class="nf">vmw_fence_obj_signaled</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmw_fence_obj</span> <span class="o">*</span><span class="n">fence</span><span class="p">,</span>
			    <span class="kt">uint32_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vmw_fence_manager</span> <span class="o">*</span><span class="n">fman</span> <span class="o">=</span> <span class="n">fence</span><span class="o">-&gt;</span><span class="n">fman</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irq_flags</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">signaled</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fman</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">irq_flags</span><span class="p">);</span>
	<span class="n">signaled</span> <span class="o">=</span> <span class="n">fence</span><span class="o">-&gt;</span><span class="n">signaled</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fman</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">irq_flags</span><span class="p">);</span>

	<span class="n">flags</span> <span class="o">&amp;=</span> <span class="n">fence</span><span class="o">-&gt;</span><span class="n">signal_mask</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">signaled</span> <span class="o">&amp;</span> <span class="n">flags</span><span class="p">)</span> <span class="o">==</span> <span class="n">flags</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">signaled</span> <span class="o">&amp;</span> <span class="n">DRM_VMW_FENCE_FLAG_EXEC</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">vmw_fences_update</span><span class="p">(</span><span class="n">fman</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fman</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">irq_flags</span><span class="p">);</span>
	<span class="n">signaled</span> <span class="o">=</span> <span class="n">fence</span><span class="o">-&gt;</span><span class="n">signaled</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fman</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">irq_flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">((</span><span class="n">signaled</span> <span class="o">&amp;</span> <span class="n">flags</span><span class="p">)</span> <span class="o">==</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">vmw_fence_obj_wait</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmw_fence_obj</span> <span class="o">*</span><span class="n">fence</span><span class="p">,</span>
		       <span class="kt">uint32_t</span> <span class="n">flags</span><span class="p">,</span> <span class="n">bool</span> <span class="n">lazy</span><span class="p">,</span>
		       <span class="n">bool</span> <span class="n">interruptible</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vmw_private</span> <span class="o">*</span><span class="n">dev_priv</span> <span class="o">=</span> <span class="n">fence</span><span class="o">-&gt;</span><span class="n">fman</span><span class="o">-&gt;</span><span class="n">dev_priv</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">vmw_fence_obj_signaled</span><span class="p">(</span><span class="n">fence</span><span class="p">,</span> <span class="n">flags</span><span class="p">)))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">vmw_fifo_ping_host</span><span class="p">(</span><span class="n">dev_priv</span><span class="p">,</span> <span class="n">SVGA_SYNC_GENERIC</span><span class="p">);</span>
	<span class="n">vmw_seqno_waiter_add</span><span class="p">(</span><span class="n">dev_priv</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">interruptible</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">wait_event_interruptible_timeout</span>
			<span class="p">(</span><span class="n">fence</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span>
			 <span class="n">vmw_fence_obj_signaled</span><span class="p">(</span><span class="n">fence</span><span class="p">,</span> <span class="n">flags</span><span class="p">),</span>
			 <span class="n">timeout</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">wait_event_timeout</span>
			<span class="p">(</span><span class="n">fence</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span>
			 <span class="n">vmw_fence_obj_signaled</span><span class="p">(</span><span class="n">fence</span><span class="p">,</span> <span class="n">flags</span><span class="p">),</span>
			 <span class="n">timeout</span><span class="p">);</span>

	<span class="n">vmw_seqno_waiter_remove</span><span class="p">(</span><span class="n">dev_priv</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">vmw_fence_obj_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmw_fence_obj</span> <span class="o">*</span><span class="n">fence</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vmw_private</span> <span class="o">*</span><span class="n">dev_priv</span> <span class="o">=</span> <span class="n">fence</span><span class="o">-&gt;</span><span class="n">fman</span><span class="o">-&gt;</span><span class="n">dev_priv</span><span class="p">;</span>

	<span class="n">vmw_fifo_ping_host</span><span class="p">(</span><span class="n">dev_priv</span><span class="p">,</span> <span class="n">SVGA_SYNC_GENERIC</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vmw_fence_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmw_fence_obj</span> <span class="o">*</span><span class="n">fence</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vmw_fence_manager</span> <span class="o">*</span><span class="n">fman</span> <span class="o">=</span> <span class="n">fence</span><span class="o">-&gt;</span><span class="n">fman</span><span class="p">;</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">fence</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Free kernel space accounting.</span>
<span class="cm">	 */</span>
	<span class="n">ttm_mem_global_free</span><span class="p">(</span><span class="n">vmw_mem_glob</span><span class="p">(</span><span class="n">fman</span><span class="o">-&gt;</span><span class="n">dev_priv</span><span class="p">),</span>
			    <span class="n">fman</span><span class="o">-&gt;</span><span class="n">fence_size</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">vmw_fence_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmw_fence_manager</span> <span class="o">*</span><span class="n">fman</span><span class="p">,</span>
		     <span class="kt">uint32_t</span> <span class="n">seqno</span><span class="p">,</span>
		     <span class="kt">uint32_t</span> <span class="n">mask</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">vmw_fence_obj</span> <span class="o">**</span><span class="n">p_fence</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ttm_mem_global</span> <span class="o">*</span><span class="n">mem_glob</span> <span class="o">=</span> <span class="n">vmw_mem_glob</span><span class="p">(</span><span class="n">fman</span><span class="o">-&gt;</span><span class="n">dev_priv</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">vmw_fence_obj</span> <span class="o">*</span><span class="n">fence</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">ttm_mem_global_alloc</span><span class="p">(</span><span class="n">mem_glob</span><span class="p">,</span> <span class="n">fman</span><span class="o">-&gt;</span><span class="n">fence_size</span><span class="p">,</span>
				   <span class="nb">false</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">fence</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">fence</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">fence</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_no_object</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">vmw_fence_obj_init</span><span class="p">(</span><span class="n">fman</span><span class="p">,</span> <span class="n">fence</span><span class="p">,</span> <span class="n">seqno</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span>
				 <span class="n">vmw_fence_destroy</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_err_init</span><span class="p">;</span>

	<span class="o">*</span><span class="n">p_fence</span> <span class="o">=</span> <span class="n">fence</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_err_init:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">fence</span><span class="p">);</span>
<span class="nl">out_no_object:</span>
	<span class="n">ttm_mem_global_free</span><span class="p">(</span><span class="n">mem_glob</span><span class="p">,</span> <span class="n">fman</span><span class="o">-&gt;</span><span class="n">fence_size</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">vmw_user_fence_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmw_fence_obj</span> <span class="o">*</span><span class="n">fence</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vmw_user_fence</span> <span class="o">*</span><span class="n">ufence</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">fence</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vmw_user_fence</span><span class="p">,</span> <span class="n">fence</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">vmw_fence_manager</span> <span class="o">*</span><span class="n">fman</span> <span class="o">=</span> <span class="n">fence</span><span class="o">-&gt;</span><span class="n">fman</span><span class="p">;</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">ufence</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Free kernel space accounting.</span>
<span class="cm">	 */</span>
	<span class="n">ttm_mem_global_free</span><span class="p">(</span><span class="n">vmw_mem_glob</span><span class="p">(</span><span class="n">fman</span><span class="o">-&gt;</span><span class="n">dev_priv</span><span class="p">),</span>
			    <span class="n">fman</span><span class="o">-&gt;</span><span class="n">user_fence_size</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vmw_user_fence_base_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">ttm_base_object</span> <span class="o">**</span><span class="n">p_base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ttm_base_object</span> <span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="o">*</span><span class="n">p_base</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vmw_user_fence</span> <span class="o">*</span><span class="n">ufence</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vmw_user_fence</span><span class="p">,</span> <span class="n">base</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">vmw_fence_obj</span> <span class="o">*</span><span class="n">fence</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ufence</span><span class="o">-&gt;</span><span class="n">fence</span><span class="p">;</span>

	<span class="o">*</span><span class="n">p_base</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">vmw_fence_obj_unreference</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fence</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">vmw_user_fence_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">vmw_fence_manager</span> <span class="o">*</span><span class="n">fman</span><span class="p">,</span>
			  <span class="kt">uint32_t</span> <span class="n">seqno</span><span class="p">,</span>
			  <span class="kt">uint32_t</span> <span class="n">mask</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">vmw_fence_obj</span> <span class="o">**</span><span class="n">p_fence</span><span class="p">,</span>
			  <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">p_handle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ttm_object_file</span> <span class="o">*</span><span class="n">tfile</span> <span class="o">=</span> <span class="n">vmw_fpriv</span><span class="p">(</span><span class="n">file_priv</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tfile</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vmw_user_fence</span> <span class="o">*</span><span class="n">ufence</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vmw_fence_obj</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ttm_mem_global</span> <span class="o">*</span><span class="n">mem_glob</span> <span class="o">=</span> <span class="n">vmw_mem_glob</span><span class="p">(</span><span class="n">fman</span><span class="o">-&gt;</span><span class="n">dev_priv</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Kernel memory space accounting, since this object may</span>
<span class="cm">	 * be created by a user-space request.</span>
<span class="cm">	 */</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">ttm_mem_global_alloc</span><span class="p">(</span><span class="n">mem_glob</span><span class="p">,</span> <span class="n">fman</span><span class="o">-&gt;</span><span class="n">user_fence_size</span><span class="p">,</span>
				   <span class="nb">false</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ufence</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ufence</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ufence</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_no_object</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">vmw_fence_obj_init</span><span class="p">(</span><span class="n">fman</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ufence</span><span class="o">-&gt;</span><span class="n">fence</span><span class="p">,</span> <span class="n">seqno</span><span class="p">,</span>
				 <span class="n">mask</span><span class="p">,</span> <span class="n">vmw_user_fence_destroy</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">ufence</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_no_object</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * The base object holds a reference which is freed in</span>
<span class="cm">	 * vmw_user_fence_base_release.</span>
<span class="cm">	 */</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">vmw_fence_obj_reference</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ufence</span><span class="o">-&gt;</span><span class="n">fence</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">ttm_base_object_init</span><span class="p">(</span><span class="n">tfile</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ufence</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span>
				   <span class="n">VMW_RES_FENCE</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="n">vmw_user_fence_base_release</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>


	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Free the base object&#39;s reference</span>
<span class="cm">		 */</span>
		<span class="n">vmw_fence_obj_unreference</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">p_fence</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ufence</span><span class="o">-&gt;</span><span class="n">fence</span><span class="p">;</span>
	<span class="o">*</span><span class="n">p_handle</span> <span class="o">=</span> <span class="n">ufence</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">hash</span><span class="p">.</span><span class="n">key</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out_err:</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ufence</span><span class="o">-&gt;</span><span class="n">fence</span><span class="p">;</span>
	<span class="n">vmw_fence_obj_unreference</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>
<span class="nl">out_no_object:</span>
	<span class="n">ttm_mem_global_free</span><span class="p">(</span><span class="n">mem_glob</span><span class="p">,</span> <span class="n">fman</span><span class="o">-&gt;</span><span class="n">user_fence_size</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * vmw_fence_fifo_down - signal all unsignaled fence objects.</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">vmw_fence_fifo_down</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmw_fence_manager</span> <span class="o">*</span><span class="n">fman</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irq_flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">action_list</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The list may be altered while we traverse it, so always</span>
<span class="cm">	 * restart when we&#39;ve released the fman-&gt;lock.</span>
<span class="cm">	 */</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fman</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">irq_flags</span><span class="p">);</span>
	<span class="n">fman</span><span class="o">-&gt;</span><span class="n">fifo_down</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fman</span><span class="o">-&gt;</span><span class="n">fence_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">vmw_fence_obj</span> <span class="o">*</span><span class="n">fence</span> <span class="o">=</span>
			<span class="n">list_entry</span><span class="p">(</span><span class="n">fman</span><span class="o">-&gt;</span><span class="n">fence_list</span><span class="p">.</span><span class="n">prev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vmw_fence_obj</span><span class="p">,</span>
				   <span class="n">head</span><span class="p">);</span>
		<span class="n">kref_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fence</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">);</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fman</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">vmw_fence_obj_wait</span><span class="p">(</span><span class="n">fence</span><span class="p">,</span> <span class="n">fence</span><span class="o">-&gt;</span><span class="n">signal_mask</span><span class="p">,</span>
					 <span class="nb">false</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span>
					 <span class="n">VMW_FENCE_WAIT_TIMEOUT</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fence</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">);</span>
			<span class="n">fence</span><span class="o">-&gt;</span><span class="n">signaled</span> <span class="o">|=</span> <span class="n">DRM_VMW_FENCE_FLAG_EXEC</span><span class="p">;</span>
			<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">action_list</span><span class="p">);</span>
			<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fence</span><span class="o">-&gt;</span><span class="n">seq_passed_actions</span><span class="p">,</span>
					 <span class="o">&amp;</span><span class="n">action_list</span><span class="p">);</span>
			<span class="n">vmw_fences_perform_actions</span><span class="p">(</span><span class="n">fman</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">action_list</span><span class="p">);</span>
			<span class="n">wake_up_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fence</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fman</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fence</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">));</span>
		<span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fence</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">,</span> <span class="n">vmw_fence_obj_destroy_locked</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fman</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">irq_flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">vmw_fence_fifo_up</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmw_fence_manager</span> <span class="o">*</span><span class="n">fman</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irq_flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fman</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">irq_flags</span><span class="p">);</span>
	<span class="n">fman</span><span class="o">-&gt;</span><span class="n">fifo_down</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fman</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">irq_flags</span><span class="p">);</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">vmw_fence_obj_wait_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_vmw_fence_wait_arg</span> <span class="o">*</span><span class="n">arg</span> <span class="o">=</span>
	    <span class="p">(</span><span class="k">struct</span> <span class="n">drm_vmw_fence_wait_arg</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ttm_base_object</span> <span class="o">*</span><span class="n">base</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vmw_fence_obj</span> <span class="o">*</span><span class="n">fence</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ttm_object_file</span> <span class="o">*</span><span class="n">tfile</span> <span class="o">=</span> <span class="n">vmw_fpriv</span><span class="p">(</span><span class="n">file_priv</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tfile</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">uint64_t</span> <span class="n">wait_timeout</span> <span class="o">=</span> <span class="p">((</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">arg</span><span class="o">-&gt;</span><span class="n">timeout_us</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * 64-bit division not present on 32-bit systems, so do an</span>
<span class="cm">	 * approximation. (Divide by 1000000).</span>
<span class="cm">	 */</span>

	<span class="n">wait_timeout</span> <span class="o">=</span> <span class="p">(</span><span class="n">wait_timeout</span> <span class="o">&gt;&gt;</span> <span class="mi">20</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">wait_timeout</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">-</span>
	  <span class="p">(</span><span class="n">wait_timeout</span> <span class="o">&gt;&gt;</span> <span class="mi">26</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">arg</span><span class="o">-&gt;</span><span class="n">cookie_valid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">arg</span><span class="o">-&gt;</span><span class="n">cookie_valid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">arg</span><span class="o">-&gt;</span><span class="n">kernel_cookie</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">wait_timeout</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">base</span> <span class="o">=</span> <span class="n">ttm_base_object_lookup</span><span class="p">(</span><span class="n">tfile</span><span class="p">,</span> <span class="n">arg</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">base</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Wait invalid fence object handle &quot;</span>
		       <span class="s">&quot;0x%08lx.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">arg</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">fence</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">container_of</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vmw_user_fence</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">fence</span><span class="p">);</span>

	<span class="n">timeout</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">time_after_eq</span><span class="p">(</span><span class="n">timeout</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">arg</span><span class="o">-&gt;</span><span class="n">kernel_cookie</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="p">((</span><span class="n">vmw_fence_obj_signaled</span><span class="p">(</span><span class="n">fence</span><span class="p">,</span> <span class="n">arg</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="o">?</span>
		       <span class="mi">0</span> <span class="o">:</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">timeout</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">arg</span><span class="o">-&gt;</span><span class="n">kernel_cookie</span> <span class="o">-</span> <span class="n">timeout</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">vmw_fence_obj_wait</span><span class="p">(</span><span class="n">fence</span><span class="p">,</span> <span class="n">arg</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span> <span class="n">arg</span><span class="o">-&gt;</span><span class="n">lazy</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">ttm_base_object_unref</span><span class="p">(</span><span class="o">&amp;</span><span class="n">base</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Optionally unref the fence object.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">arg</span><span class="o">-&gt;</span><span class="n">wait_options</span> <span class="o">&amp;</span> <span class="n">DRM_VMW_WAIT_OPTION_UNREF</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ttm_ref_object_base_unref</span><span class="p">(</span><span class="n">tfile</span><span class="p">,</span> <span class="n">arg</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">,</span>
						 <span class="n">TTM_REF_USAGE</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">vmw_fence_obj_signaled_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_vmw_fence_signaled_arg</span> <span class="o">*</span><span class="n">arg</span> <span class="o">=</span>
		<span class="p">(</span><span class="k">struct</span> <span class="n">drm_vmw_fence_signaled_arg</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ttm_base_object</span> <span class="o">*</span><span class="n">base</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vmw_fence_obj</span> <span class="o">*</span><span class="n">fence</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vmw_fence_manager</span> <span class="o">*</span><span class="n">fman</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ttm_object_file</span> <span class="o">*</span><span class="n">tfile</span> <span class="o">=</span> <span class="n">vmw_fpriv</span><span class="p">(</span><span class="n">file_priv</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tfile</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vmw_private</span> <span class="o">*</span><span class="n">dev_priv</span> <span class="o">=</span> <span class="n">vmw_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">base</span> <span class="o">=</span> <span class="n">ttm_base_object_lookup</span><span class="p">(</span><span class="n">tfile</span><span class="p">,</span> <span class="n">arg</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">base</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Fence signaled invalid fence object handle &quot;</span>
		       <span class="s">&quot;0x%08lx.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">arg</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">fence</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">container_of</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vmw_user_fence</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">fence</span><span class="p">);</span>
	<span class="n">fman</span> <span class="o">=</span> <span class="n">fence</span><span class="o">-&gt;</span><span class="n">fman</span><span class="p">;</span>

	<span class="n">arg</span><span class="o">-&gt;</span><span class="n">signaled</span> <span class="o">=</span> <span class="n">vmw_fence_obj_signaled</span><span class="p">(</span><span class="n">fence</span><span class="p">,</span> <span class="n">arg</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fman</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">arg</span><span class="o">-&gt;</span><span class="n">signaled_flags</span> <span class="o">=</span> <span class="n">fence</span><span class="o">-&gt;</span><span class="n">signaled</span><span class="p">;</span>
	<span class="n">arg</span><span class="o">-&gt;</span><span class="n">passed_seqno</span> <span class="o">=</span> <span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">last_read_seqno</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fman</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">ttm_base_object_unref</span><span class="p">(</span><span class="o">&amp;</span><span class="n">base</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">vmw_fence_obj_unref_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_vmw_fence_arg</span> <span class="o">*</span><span class="n">arg</span> <span class="o">=</span>
		<span class="p">(</span><span class="k">struct</span> <span class="n">drm_vmw_fence_arg</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ttm_ref_object_base_unref</span><span class="p">(</span><span class="n">vmw_fpriv</span><span class="p">(</span><span class="n">file_priv</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tfile</span><span class="p">,</span>
					 <span class="n">arg</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">,</span>
					 <span class="n">TTM_REF_USAGE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * vmw_event_fence_fpriv_gone - Remove references to struct drm_file objects</span>
<span class="cm"> *</span>
<span class="cm"> * @fman: Pointer to a struct vmw_fence_manager</span>
<span class="cm"> * @event_list: Pointer to linked list of struct vmw_event_fence_action objects</span>
<span class="cm"> * with pointers to a struct drm_file object about to be closed.</span>
<span class="cm"> *</span>
<span class="cm"> * This function removes all pending fence events with references to a</span>
<span class="cm"> * specific struct drm_file object about to be closed. The caller is required</span>
<span class="cm"> * to pass a list of all struct vmw_event_fence_action objects with such</span>
<span class="cm"> * events attached. This function is typically called before the</span>
<span class="cm"> * struct drm_file object&#39;s event management is taken down.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">vmw_event_fence_fpriv_gone</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmw_fence_manager</span> <span class="o">*</span><span class="n">fman</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">event_list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vmw_event_fence_action</span> <span class="o">*</span><span class="n">eaction</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_pending_event</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irq_flags</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fman</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">irq_flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="n">event_list</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
		<span class="n">eaction</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="n">event_list</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">vmw_event_fence_action</span><span class="p">,</span>
					   <span class="n">fpriv_head</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">eaction</span><span class="o">-&gt;</span><span class="n">fpriv_head</span><span class="p">);</span>
		<span class="n">event</span> <span class="o">=</span> <span class="n">eaction</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">;</span>
		<span class="n">eaction</span><span class="o">-&gt;</span><span class="n">event</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fman</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">irq_flags</span><span class="p">);</span>
		<span class="n">event</span><span class="o">-&gt;</span><span class="n">destroy</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">out_unlock:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fman</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">irq_flags</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * vmw_event_fence_action_seq_passed</span>
<span class="cm"> *</span>
<span class="cm"> * @action: The struct vmw_fence_action embedded in a struct</span>
<span class="cm"> * vmw_event_fence_action.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called when the seqno of the fence where @action is</span>
<span class="cm"> * attached has passed. It queues the event on the submitter&#39;s event list.</span>
<span class="cm"> * This function is always called from atomic context, and may be called</span>
<span class="cm"> * from irq context.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">vmw_event_fence_action_seq_passed</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmw_fence_action</span> <span class="o">*</span><span class="n">action</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vmw_event_fence_action</span> <span class="o">*</span><span class="n">eaction</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">action</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vmw_event_fence_action</span><span class="p">,</span> <span class="n">action</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">eaction</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_pending_event</span> <span class="o">*</span><span class="n">event</span> <span class="o">=</span> <span class="n">eaction</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irq_flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">event</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">file_priv</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">file_priv</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">event_lock</span><span class="p">,</span> <span class="n">irq_flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">eaction</span><span class="o">-&gt;</span><span class="n">tv_sec</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">timeval</span> <span class="n">tv</span><span class="p">;</span>

		<span class="n">do_gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tv</span><span class="p">);</span>
		<span class="o">*</span><span class="n">eaction</span><span class="o">-&gt;</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">tv</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">;</span>
		<span class="o">*</span><span class="n">eaction</span><span class="o">-&gt;</span><span class="n">tv_usec</span> <span class="o">=</span> <span class="n">tv</span><span class="p">.</span><span class="n">tv_usec</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">eaction</span><span class="o">-&gt;</span><span class="n">fpriv_head</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">eaction</span><span class="o">-&gt;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">file_priv</span><span class="o">-&gt;</span><span class="n">event_list</span><span class="p">);</span>
	<span class="n">eaction</span><span class="o">-&gt;</span><span class="n">event</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">wake_up_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">file_priv</span><span class="o">-&gt;</span><span class="n">event_wait</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">event_lock</span><span class="p">,</span> <span class="n">irq_flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * vmw_event_fence_action_cleanup</span>
<span class="cm"> *</span>
<span class="cm"> * @action: The struct vmw_fence_action embedded in a struct</span>
<span class="cm"> * vmw_event_fence_action.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is the struct vmw_fence_action destructor. It&#39;s typically</span>
<span class="cm"> * called from a workqueue.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">vmw_event_fence_action_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmw_fence_action</span> <span class="o">*</span><span class="n">action</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vmw_event_fence_action</span> <span class="o">*</span><span class="n">eaction</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">action</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vmw_event_fence_action</span><span class="p">,</span> <span class="n">action</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">vmw_fence_manager</span> <span class="o">*</span><span class="n">fman</span> <span class="o">=</span> <span class="n">eaction</span><span class="o">-&gt;</span><span class="n">fence</span><span class="o">-&gt;</span><span class="n">fman</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irq_flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fman</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">irq_flags</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">eaction</span><span class="o">-&gt;</span><span class="n">fpriv_head</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fman</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">irq_flags</span><span class="p">);</span>

	<span class="n">vmw_fence_obj_unreference</span><span class="p">(</span><span class="o">&amp;</span><span class="n">eaction</span><span class="o">-&gt;</span><span class="n">fence</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">eaction</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * vmw_fence_obj_add_action - Add an action to a fence object.</span>
<span class="cm"> *</span>
<span class="cm"> * @fence - The fence object.</span>
<span class="cm"> * @action - The action to add.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that the action callbacks may be executed before this function</span>
<span class="cm"> * returns.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">vmw_fence_obj_add_action</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmw_fence_obj</span> <span class="o">*</span><span class="n">fence</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">vmw_fence_action</span> <span class="o">*</span><span class="n">action</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vmw_fence_manager</span> <span class="o">*</span><span class="n">fman</span> <span class="o">=</span> <span class="n">fence</span><span class="o">-&gt;</span><span class="n">fman</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irq_flags</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">run_update</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fman</span><span class="o">-&gt;</span><span class="n">goal_irq_mutex</span><span class="p">);</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fman</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">irq_flags</span><span class="p">);</span>

	<span class="n">fman</span><span class="o">-&gt;</span><span class="n">pending_actions</span><span class="p">[</span><span class="n">action</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fence</span><span class="o">-&gt;</span><span class="n">signaled</span> <span class="o">&amp;</span> <span class="n">DRM_VMW_FENCE_FLAG_EXEC</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">list_head</span> <span class="n">action_list</span><span class="p">;</span>

		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">action_list</span><span class="p">);</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">action</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">action_list</span><span class="p">);</span>
		<span class="n">vmw_fences_perform_actions</span><span class="p">(</span><span class="n">fman</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">action_list</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">action</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fence</span><span class="o">-&gt;</span><span class="n">seq_passed_actions</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * This function may set fman::seqno_valid, so it must</span>
<span class="cm">		 * be run with the goal_irq_mutex held.</span>
<span class="cm">		 */</span>
		<span class="n">run_update</span> <span class="o">=</span> <span class="n">vmw_fence_goal_check_locked</span><span class="p">(</span><span class="n">fence</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fman</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">irq_flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">run_update</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fman</span><span class="o">-&gt;</span><span class="n">goal_irq_on</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">fman</span><span class="o">-&gt;</span><span class="n">goal_irq_on</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="n">vmw_goal_waiter_add</span><span class="p">(</span><span class="n">fman</span><span class="o">-&gt;</span><span class="n">dev_priv</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">vmw_fences_update</span><span class="p">(</span><span class="n">fman</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fman</span><span class="o">-&gt;</span><span class="n">goal_irq_mutex</span><span class="p">);</span>

<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * vmw_event_fence_action_create - Post an event for sending when a fence</span>
<span class="cm"> * object seqno has passed.</span>
<span class="cm"> *</span>
<span class="cm"> * @file_priv: The file connection on which the event should be posted.</span>
<span class="cm"> * @fence: The fence object on which to post the event.</span>
<span class="cm"> * @event: Event to be posted. This event should&#39;ve been alloced</span>
<span class="cm"> * using k[mz]alloc, and should&#39;ve been completely initialized.</span>
<span class="cm"> * @interruptible: Interruptible waits if possible.</span>
<span class="cm"> *</span>
<span class="cm"> * As a side effect, the object pointed to by @event may have been</span>
<span class="cm"> * freed when this function returns. If this function returns with</span>
<span class="cm"> * an error code, the caller needs to free that object.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">vmw_event_fence_action_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">vmw_fence_obj</span> <span class="o">*</span><span class="n">fence</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">drm_pending_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span>
				 <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">tv_sec</span><span class="p">,</span>
				 <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">tv_usec</span><span class="p">,</span>
				 <span class="n">bool</span> <span class="n">interruptible</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vmw_event_fence_action</span> <span class="o">*</span><span class="n">eaction</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vmw_fence_manager</span> <span class="o">*</span><span class="n">fman</span> <span class="o">=</span> <span class="n">fence</span><span class="o">-&gt;</span><span class="n">fman</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vmw_fpriv</span> <span class="o">*</span><span class="n">vmw_fp</span> <span class="o">=</span> <span class="n">vmw_fpriv</span><span class="p">(</span><span class="n">file_priv</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irq_flags</span><span class="p">;</span>

	<span class="n">eaction</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">eaction</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">eaction</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">eaction</span><span class="o">-&gt;</span><span class="n">event</span> <span class="o">=</span> <span class="n">event</span><span class="p">;</span>

	<span class="n">eaction</span><span class="o">-&gt;</span><span class="n">action</span><span class="p">.</span><span class="n">seq_passed</span> <span class="o">=</span> <span class="n">vmw_event_fence_action_seq_passed</span><span class="p">;</span>
	<span class="n">eaction</span><span class="o">-&gt;</span><span class="n">action</span><span class="p">.</span><span class="n">cleanup</span> <span class="o">=</span> <span class="n">vmw_event_fence_action_cleanup</span><span class="p">;</span>
	<span class="n">eaction</span><span class="o">-&gt;</span><span class="n">action</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">VMW_ACTION_EVENT</span><span class="p">;</span>

	<span class="n">eaction</span><span class="o">-&gt;</span><span class="n">fence</span> <span class="o">=</span> <span class="n">vmw_fence_obj_reference</span><span class="p">(</span><span class="n">fence</span><span class="p">);</span>
	<span class="n">eaction</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">fman</span><span class="o">-&gt;</span><span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">eaction</span><span class="o">-&gt;</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">tv_sec</span><span class="p">;</span>
	<span class="n">eaction</span><span class="o">-&gt;</span><span class="n">tv_usec</span> <span class="o">=</span> <span class="n">tv_usec</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fman</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">irq_flags</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">eaction</span><span class="o">-&gt;</span><span class="n">fpriv_head</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vmw_fp</span><span class="o">-&gt;</span><span class="n">fence_events</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fman</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">irq_flags</span><span class="p">);</span>

	<span class="n">vmw_fence_obj_add_action</span><span class="p">(</span><span class="n">fence</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eaction</span><span class="o">-&gt;</span><span class="n">action</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">vmw_event_fence_pending</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_pending_event</span> <span class="n">base</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_vmw_event_fence</span> <span class="n">event</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">vmw_event_fence_action_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">vmw_fence_obj</span> <span class="o">*</span><span class="n">fence</span><span class="p">,</span>
				  <span class="kt">uint32_t</span> <span class="n">flags</span><span class="p">,</span>
				  <span class="kt">uint64_t</span> <span class="n">user_data</span><span class="p">,</span>
				  <span class="n">bool</span> <span class="n">interruptible</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vmw_event_fence_pending</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">fence</span><span class="o">-&gt;</span><span class="n">fman</span><span class="o">-&gt;</span><span class="n">dev_priv</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irq_flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">event_lock</span><span class="p">,</span> <span class="n">irq_flags</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="n">file_priv</span><span class="o">-&gt;</span><span class="n">event_space</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">))</span> <span class="o">?</span> <span class="o">-</span><span class="n">EBUSY</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">file_priv</span><span class="o">-&gt;</span><span class="n">event_space</span> <span class="o">-=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">event_lock</span><span class="p">,</span> <span class="n">irq_flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">DRM_ERROR</span><span class="p">(</span><span class="s">&quot;Failed to allocate event space for this file.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_no_space</span><span class="p">;</span>
	<span class="p">}</span>


	<span class="n">event</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">event</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">DRM_ERROR</span><span class="p">(</span><span class="s">&quot;Failed to allocate an event.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_no_event</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">event</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">.</span><span class="n">base</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">DRM_VMW_EVENT_FENCE_SIGNALED</span><span class="p">;</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">.</span><span class="n">base</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">event</span><span class="p">);</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">.</span><span class="n">user_data</span> <span class="o">=</span> <span class="n">user_data</span><span class="p">;</span>

	<span class="n">event</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">event</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">.</span><span class="n">base</span><span class="p">;</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">file_priv</span> <span class="o">=</span> <span class="n">file_priv</span><span class="p">;</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">destroy</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">drm_pending_event</span> <span class="o">*</span><span class="p">))</span> <span class="n">kfree</span><span class="p">;</span>


	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DRM_VMW_FE_FLAG_REQ_TIME</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">vmw_event_fence_action_queue</span><span class="p">(</span><span class="n">file_priv</span><span class="p">,</span> <span class="n">fence</span><span class="p">,</span>
						   <span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span>
						   <span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">,</span>
						   <span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">.</span><span class="n">tv_usec</span><span class="p">,</span>
						   <span class="n">interruptible</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">vmw_event_fence_action_queue</span><span class="p">(</span><span class="n">file_priv</span><span class="p">,</span> <span class="n">fence</span><span class="p">,</span>
						   <span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span>
						   <span class="nb">NULL</span><span class="p">,</span>
						   <span class="nb">NULL</span><span class="p">,</span>
						   <span class="n">interruptible</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_no_queue</span><span class="p">;</span>

<span class="nl">out_no_queue:</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>
<span class="nl">out_no_event:</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">event_lock</span><span class="p">,</span> <span class="n">irq_flags</span><span class="p">);</span>
	<span class="n">file_priv</span><span class="o">-&gt;</span><span class="n">event_space</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">event</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">event_lock</span><span class="p">,</span> <span class="n">irq_flags</span><span class="p">);</span>
<span class="nl">out_no_space:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">vmw_fence_event_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vmw_private</span> <span class="o">*</span><span class="n">dev_priv</span> <span class="o">=</span> <span class="n">vmw_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">drm_vmw_fence_event_arg</span> <span class="o">*</span><span class="n">arg</span> <span class="o">=</span>
		<span class="p">(</span><span class="k">struct</span> <span class="n">drm_vmw_fence_event_arg</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vmw_fence_obj</span> <span class="o">*</span><span class="n">fence</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vmw_fpriv</span> <span class="o">*</span><span class="n">vmw_fp</span> <span class="o">=</span> <span class="n">vmw_fpriv</span><span class="p">(</span><span class="n">file_priv</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">drm_vmw_fence_rep</span> <span class="n">__user</span> <span class="o">*</span><span class="n">user_fence_rep</span> <span class="o">=</span>
		<span class="p">(</span><span class="k">struct</span> <span class="n">drm_vmw_fence_rep</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span>
		<span class="n">arg</span><span class="o">-&gt;</span><span class="n">fence_rep</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">handle</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Look up an existing fence object,</span>
<span class="cm">	 * and if user-space wants a new reference,</span>
<span class="cm">	 * add one.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">arg</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ttm_base_object</span> <span class="o">*</span><span class="n">base</span> <span class="o">=</span>
			<span class="n">ttm_base_object_lookup</span><span class="p">(</span><span class="n">vmw_fp</span><span class="o">-&gt;</span><span class="n">tfile</span><span class="p">,</span> <span class="n">arg</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">base</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">DRM_ERROR</span><span class="p">(</span><span class="s">&quot;Fence event invalid fence object handle &quot;</span>
				  <span class="s">&quot;0x%08lx.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">arg</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">fence</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">container_of</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vmw_user_fence</span><span class="p">,</span>
				       <span class="n">base</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">fence</span><span class="p">);</span>
		<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">vmw_fence_obj_reference</span><span class="p">(</span><span class="n">fence</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">user_fence_rep</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">bool</span> <span class="n">existed</span><span class="p">;</span>

			<span class="n">ret</span> <span class="o">=</span> <span class="n">ttm_ref_object_add</span><span class="p">(</span><span class="n">vmw_fp</span><span class="o">-&gt;</span><span class="n">tfile</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span>
						 <span class="n">TTM_REF_USAGE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">existed</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">DRM_ERROR</span><span class="p">(</span><span class="s">&quot;Failed to reference a fence &quot;</span>
					  <span class="s">&quot;object.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out_no_ref_obj</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">handle</span> <span class="o">=</span> <span class="n">base</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">.</span><span class="n">key</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ttm_base_object_unref</span><span class="p">(</span><span class="o">&amp;</span><span class="n">base</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Create a new fence object.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fence</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">vmw_execbuf_fence_commands</span><span class="p">(</span><span class="n">file_priv</span><span class="p">,</span> <span class="n">dev_priv</span><span class="p">,</span>
						 <span class="o">&amp;</span><span class="n">fence</span><span class="p">,</span>
						 <span class="p">(</span><span class="n">user_fence_rep</span><span class="p">)</span> <span class="o">?</span>
						 <span class="o">&amp;</span><span class="n">handle</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">DRM_ERROR</span><span class="p">(</span><span class="s">&quot;Fence event failed to create fence.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">fence</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">arg</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DRM_VMW_FE_FLAG_REQ_TIME</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">vmw_event_fence_action_create</span><span class="p">(</span><span class="n">file_priv</span><span class="p">,</span> <span class="n">fence</span><span class="p">,</span>
						    <span class="n">arg</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span>
						    <span class="n">arg</span><span class="o">-&gt;</span><span class="n">user_data</span><span class="p">,</span>
						    <span class="nb">true</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">vmw_event_fence_action_create</span><span class="p">(</span><span class="n">file_priv</span><span class="p">,</span> <span class="n">fence</span><span class="p">,</span>
						    <span class="n">arg</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span>
						    <span class="n">arg</span><span class="o">-&gt;</span><span class="n">user_data</span><span class="p">,</span>
						    <span class="nb">true</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ERESTARTSYS</span><span class="p">)</span>
			<span class="n">DRM_ERROR</span><span class="p">(</span><span class="s">&quot;Failed to attach event to fence.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_no_create</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">vmw_execbuf_copy_fence_user</span><span class="p">(</span><span class="n">dev_priv</span><span class="p">,</span> <span class="n">vmw_fp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">user_fence_rep</span><span class="p">,</span> <span class="n">fence</span><span class="p">,</span>
				    <span class="n">handle</span><span class="p">);</span>
	<span class="n">vmw_fence_obj_unreference</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fence</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out_no_create:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">user_fence_rep</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">ttm_ref_object_base_unref</span><span class="p">(</span><span class="n">vmw_fpriv</span><span class="p">(</span><span class="n">file_priv</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tfile</span><span class="p">,</span>
					  <span class="n">handle</span><span class="p">,</span> <span class="n">TTM_REF_USAGE</span><span class="p">);</span>
<span class="nl">out_no_ref_obj:</span>
	<span class="n">vmw_fence_obj_unreference</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fence</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
