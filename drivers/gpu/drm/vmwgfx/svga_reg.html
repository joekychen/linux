<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › gpu › drm › vmwgfx › svga_reg.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>svga_reg.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/**********************************************************</span>
<span class="cm"> * Copyright 1998-2009 VMware, Inc.  All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * Permission is hereby granted, free of charge, to any person</span>
<span class="cm"> * obtaining a copy of this software and associated documentation</span>
<span class="cm"> * files (the &quot;Software&quot;), to deal in the Software without</span>
<span class="cm"> * restriction, including without limitation the rights to use, copy,</span>
<span class="cm"> * modify, merge, publish, distribute, sublicense, and/or sell copies</span>
<span class="cm"> * of the Software, and to permit persons to whom the Software is</span>
<span class="cm"> * furnished to do so, subject to the following conditions:</span>
<span class="cm"> *</span>
<span class="cm"> * The above copyright notice and this permission notice shall be</span>
<span class="cm"> * included in all copies or substantial portions of the Software.</span>
<span class="cm"> *</span>
<span class="cm"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,</span>
<span class="cm"> * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span>
<span class="cm"> * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND</span>
<span class="cm"> * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS</span>
<span class="cm"> * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN</span>
<span class="cm"> * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN</span>
<span class="cm"> * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE</span>
<span class="cm"> * SOFTWARE.</span>
<span class="cm"> *</span>
<span class="cm"> **********************************************************/</span>

<span class="cm">/*</span>
<span class="cm"> * svga_reg.h --</span>
<span class="cm"> *</span>
<span class="cm"> *    Virtual hardware definitions for the VMware SVGA II device.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _SVGA_REG_H_</span>
<span class="cp">#define _SVGA_REG_H_</span>

<span class="cm">/*</span>
<span class="cm"> * PCI device IDs.</span>
<span class="cm"> */</span>
<span class="cp">#define PCI_VENDOR_ID_VMWARE            0x15AD</span>
<span class="cp">#define PCI_DEVICE_ID_VMWARE_SVGA2      0x0405</span>

<span class="cm">/*</span>
<span class="cm"> * SVGA_REG_ENABLE bit definitions.</span>
<span class="cm"> */</span>
<span class="cp">#define SVGA_REG_ENABLE_DISABLE     0</span>
<span class="cp">#define SVGA_REG_ENABLE_ENABLE      1</span>
<span class="cp">#define SVGA_REG_ENABLE_HIDE        2</span>
<span class="cp">#define SVGA_REG_ENABLE_ENABLE_HIDE (SVGA_REG_ENABLE_ENABLE |\</span>
<span class="cp">				     SVGA_REG_ENABLE_HIDE)</span>

<span class="cm">/*</span>
<span class="cm"> * Legal values for the SVGA_REG_CURSOR_ON register in old-fashioned</span>
<span class="cm"> * cursor bypass mode. This is still supported, but no new guest</span>
<span class="cm"> * drivers should use it.</span>
<span class="cm"> */</span>
<span class="cp">#define SVGA_CURSOR_ON_HIDE            0x0   </span><span class="cm">/* Must be 0 to maintain backward compatibility */</span><span class="cp"></span>
<span class="cp">#define SVGA_CURSOR_ON_SHOW            0x1   </span><span class="cm">/* Must be 1 to maintain backward compatibility */</span><span class="cp"></span>
<span class="cp">#define SVGA_CURSOR_ON_REMOVE_FROM_FB  0x2   </span><span class="cm">/* Remove the cursor from the framebuffer because we need to see what&#39;s under it */</span><span class="cp"></span>
<span class="cp">#define SVGA_CURSOR_ON_RESTORE_TO_FB   0x3   </span><span class="cm">/* Put the cursor back in the framebuffer so the user can see it */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * The maximum framebuffer size that can traced for e.g. guests in VESA mode.</span>
<span class="cm"> * The changeMap in the monitor is proportional to this number. Therefore, we&#39;d</span>
<span class="cm"> * like to keep it as small as possible to reduce monitor overhead (using</span>
<span class="cm"> * SVGA_VRAM_MAX_SIZE for this increases the size of the shared area by over</span>
<span class="cm"> * 4k!).</span>
<span class="cm"> *</span>
<span class="cm"> * NB: For compatibility reasons, this value must be greater than 0xff0000.</span>
<span class="cm"> *     See bug 335072.</span>
<span class="cm"> */</span>
<span class="cp">#define SVGA_FB_MAX_TRACEABLE_SIZE      0x1000000</span>

<span class="cp">#define SVGA_MAX_PSEUDOCOLOR_DEPTH      8</span>
<span class="cp">#define SVGA_MAX_PSEUDOCOLORS           (1 &lt;&lt; SVGA_MAX_PSEUDOCOLOR_DEPTH)</span>
<span class="cp">#define SVGA_NUM_PALETTE_REGS           (3 * SVGA_MAX_PSEUDOCOLORS)</span>

<span class="cp">#define SVGA_MAGIC         0x900000UL</span>
<span class="cp">#define SVGA_MAKE_ID(ver)  (SVGA_MAGIC &lt;&lt; 8 | (ver))</span>

<span class="cm">/* Version 2 let the address of the frame buffer be unsigned on Win32 */</span>
<span class="cp">#define SVGA_VERSION_2     2</span>
<span class="cp">#define SVGA_ID_2          SVGA_MAKE_ID(SVGA_VERSION_2)</span>

<span class="cm">/* Version 1 has new registers starting with SVGA_REG_CAPABILITIES so</span>
<span class="cm">   PALETTE_BASE has moved */</span>
<span class="cp">#define SVGA_VERSION_1     1</span>
<span class="cp">#define SVGA_ID_1          SVGA_MAKE_ID(SVGA_VERSION_1)</span>

<span class="cm">/* Version 0 is the initial version */</span>
<span class="cp">#define SVGA_VERSION_0     0</span>
<span class="cp">#define SVGA_ID_0          SVGA_MAKE_ID(SVGA_VERSION_0)</span>

<span class="cm">/* &quot;Invalid&quot; value for all SVGA IDs. (Version ID, screen object ID, surface ID...) */</span>
<span class="cp">#define SVGA_ID_INVALID    0xFFFFFFFF</span>

<span class="cm">/* Port offsets, relative to BAR0 */</span>
<span class="cp">#define SVGA_INDEX_PORT         0x0</span>
<span class="cp">#define SVGA_VALUE_PORT         0x1</span>
<span class="cp">#define SVGA_BIOS_PORT          0x2</span>
<span class="cp">#define SVGA_IRQSTATUS_PORT     0x8</span>

<span class="cm">/*</span>
<span class="cm"> * Interrupt source flags for IRQSTATUS_PORT and IRQMASK.</span>
<span class="cm"> *</span>
<span class="cm"> * Interrupts are only supported when the</span>
<span class="cm"> * SVGA_CAP_IRQMASK capability is present.</span>
<span class="cm"> */</span>
<span class="cp">#define SVGA_IRQFLAG_ANY_FENCE            0x1    </span><span class="cm">/* Any fence was passed */</span><span class="cp"></span>
<span class="cp">#define SVGA_IRQFLAG_FIFO_PROGRESS        0x2    </span><span class="cm">/* Made forward progress in the FIFO */</span><span class="cp"></span>
<span class="cp">#define SVGA_IRQFLAG_FENCE_GOAL           0x4    </span><span class="cm">/* SVGA_FIFO_FENCE_GOAL reached */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Registers</span>
<span class="cm"> */</span>

<span class="k">enum</span> <span class="p">{</span>
   <span class="n">SVGA_REG_ID</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
   <span class="n">SVGA_REG_ENABLE</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
   <span class="n">SVGA_REG_WIDTH</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
   <span class="n">SVGA_REG_HEIGHT</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
   <span class="n">SVGA_REG_MAX_WIDTH</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
   <span class="n">SVGA_REG_MAX_HEIGHT</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
   <span class="n">SVGA_REG_DEPTH</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
   <span class="n">SVGA_REG_BITS_PER_PIXEL</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span>       <span class="cm">/* Current bpp in the guest */</span>
   <span class="n">SVGA_REG_PSEUDOCOLOR</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
   <span class="n">SVGA_REG_RED_MASK</span> <span class="o">=</span> <span class="mi">9</span><span class="p">,</span>
   <span class="n">SVGA_REG_GREEN_MASK</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
   <span class="n">SVGA_REG_BLUE_MASK</span> <span class="o">=</span> <span class="mi">11</span><span class="p">,</span>
   <span class="n">SVGA_REG_BYTES_PER_LINE</span> <span class="o">=</span> <span class="mi">12</span><span class="p">,</span>
   <span class="n">SVGA_REG_FB_START</span> <span class="o">=</span> <span class="mi">13</span><span class="p">,</span>            <span class="cm">/* (Deprecated) */</span>
   <span class="n">SVGA_REG_FB_OFFSET</span> <span class="o">=</span> <span class="mi">14</span><span class="p">,</span>
   <span class="n">SVGA_REG_VRAM_SIZE</span> <span class="o">=</span> <span class="mi">15</span><span class="p">,</span>
   <span class="n">SVGA_REG_FB_SIZE</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>

   <span class="cm">/* ID 0 implementation only had the above registers, then the palette */</span>

   <span class="n">SVGA_REG_CAPABILITIES</span> <span class="o">=</span> <span class="mi">17</span><span class="p">,</span>
   <span class="n">SVGA_REG_MEM_START</span> <span class="o">=</span> <span class="mi">18</span><span class="p">,</span>           <span class="cm">/* (Deprecated) */</span>
   <span class="n">SVGA_REG_MEM_SIZE</span> <span class="o">=</span> <span class="mi">19</span><span class="p">,</span>
   <span class="n">SVGA_REG_CONFIG_DONE</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>         <span class="cm">/* Set when memory area configured */</span>
   <span class="n">SVGA_REG_SYNC</span> <span class="o">=</span> <span class="mi">21</span><span class="p">,</span>                <span class="cm">/* See &quot;FIFO Synchronization Registers&quot; */</span>
   <span class="n">SVGA_REG_BUSY</span> <span class="o">=</span> <span class="mi">22</span><span class="p">,</span>                <span class="cm">/* See &quot;FIFO Synchronization Registers&quot; */</span>
   <span class="n">SVGA_REG_GUEST_ID</span> <span class="o">=</span> <span class="mi">23</span><span class="p">,</span>            <span class="cm">/* Set guest OS identifier */</span>
   <span class="n">SVGA_REG_CURSOR_ID</span> <span class="o">=</span> <span class="mi">24</span><span class="p">,</span>           <span class="cm">/* (Deprecated) */</span>
   <span class="n">SVGA_REG_CURSOR_X</span> <span class="o">=</span> <span class="mi">25</span><span class="p">,</span>            <span class="cm">/* (Deprecated) */</span>
   <span class="n">SVGA_REG_CURSOR_Y</span> <span class="o">=</span> <span class="mi">26</span><span class="p">,</span>            <span class="cm">/* (Deprecated) */</span>
   <span class="n">SVGA_REG_CURSOR_ON</span> <span class="o">=</span> <span class="mi">27</span><span class="p">,</span>           <span class="cm">/* (Deprecated) */</span>
   <span class="n">SVGA_REG_HOST_BITS_PER_PIXEL</span> <span class="o">=</span> <span class="mi">28</span><span class="p">,</span> <span class="cm">/* (Deprecated) */</span>
   <span class="n">SVGA_REG_SCRATCH_SIZE</span> <span class="o">=</span> <span class="mi">29</span><span class="p">,</span>        <span class="cm">/* Number of scratch registers */</span>
   <span class="n">SVGA_REG_MEM_REGS</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span>            <span class="cm">/* Number of FIFO registers */</span>
   <span class="n">SVGA_REG_NUM_DISPLAYS</span> <span class="o">=</span> <span class="mi">31</span><span class="p">,</span>        <span class="cm">/* (Deprecated) */</span>
   <span class="n">SVGA_REG_PITCHLOCK</span> <span class="o">=</span> <span class="mi">32</span><span class="p">,</span>           <span class="cm">/* Fixed pitch for all modes */</span>
   <span class="n">SVGA_REG_IRQMASK</span> <span class="o">=</span> <span class="mi">33</span><span class="p">,</span>             <span class="cm">/* Interrupt mask */</span>

   <span class="cm">/* Legacy multi-monitor support */</span>
   <span class="n">SVGA_REG_NUM_GUEST_DISPLAYS</span> <span class="o">=</span> <span class="mi">34</span><span class="p">,</span><span class="cm">/* Number of guest displays in X/Y direction */</span>
   <span class="n">SVGA_REG_DISPLAY_ID</span> <span class="o">=</span> <span class="mi">35</span><span class="p">,</span>        <span class="cm">/* Display ID for the following display attributes */</span>
   <span class="n">SVGA_REG_DISPLAY_IS_PRIMARY</span> <span class="o">=</span> <span class="mi">36</span><span class="p">,</span><span class="cm">/* Whether this is a primary display */</span>
   <span class="n">SVGA_REG_DISPLAY_POSITION_X</span> <span class="o">=</span> <span class="mi">37</span><span class="p">,</span><span class="cm">/* The display position x */</span>
   <span class="n">SVGA_REG_DISPLAY_POSITION_Y</span> <span class="o">=</span> <span class="mi">38</span><span class="p">,</span><span class="cm">/* The display position y */</span>
   <span class="n">SVGA_REG_DISPLAY_WIDTH</span> <span class="o">=</span> <span class="mi">39</span><span class="p">,</span>     <span class="cm">/* The display&#39;s width */</span>
   <span class="n">SVGA_REG_DISPLAY_HEIGHT</span> <span class="o">=</span> <span class="mi">40</span><span class="p">,</span>    <span class="cm">/* The display&#39;s height */</span>

   <span class="cm">/* See &quot;Guest memory regions&quot; below. */</span>
   <span class="n">SVGA_REG_GMR_ID</span> <span class="o">=</span> <span class="mi">41</span><span class="p">,</span>
   <span class="n">SVGA_REG_GMR_DESCRIPTOR</span> <span class="o">=</span> <span class="mi">42</span><span class="p">,</span>
   <span class="n">SVGA_REG_GMR_MAX_IDS</span> <span class="o">=</span> <span class="mi">43</span><span class="p">,</span>
   <span class="n">SVGA_REG_GMR_MAX_DESCRIPTOR_LENGTH</span> <span class="o">=</span> <span class="mi">44</span><span class="p">,</span>

   <span class="n">SVGA_REG_TRACES</span> <span class="o">=</span> <span class="mi">45</span><span class="p">,</span>            <span class="cm">/* Enable trace-based updates even when FIFO is on */</span>
   <span class="n">SVGA_REG_GMRS_MAX_PAGES</span> <span class="o">=</span> <span class="mi">46</span><span class="p">,</span>    <span class="cm">/* Maximum number of 4KB pages for all GMRs */</span>
   <span class="n">SVGA_REG_MEMORY_SIZE</span> <span class="o">=</span> <span class="mi">47</span><span class="p">,</span>       <span class="cm">/* Total dedicated device memory excluding FIFO */</span>
   <span class="n">SVGA_REG_TOP</span> <span class="o">=</span> <span class="mi">48</span><span class="p">,</span>               <span class="cm">/* Must be 1 more than the last register */</span>

   <span class="n">SVGA_PALETTE_BASE</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">,</span>        <span class="cm">/* Base of SVGA color map */</span>
   <span class="cm">/* Next 768 (== 256*3) registers exist for colormap */</span>

   <span class="n">SVGA_SCRATCH_BASE</span> <span class="o">=</span> <span class="n">SVGA_PALETTE_BASE</span> <span class="o">+</span> <span class="n">SVGA_NUM_PALETTE_REGS</span>
                                    <span class="cm">/* Base of scratch registers */</span>
   <span class="cm">/* Next reg[SVGA_REG_SCRATCH_SIZE] registers exist for scratch usage:</span>
<span class="cm">      First 4 are reserved for VESA BIOS Extension; any remaining are for</span>
<span class="cm">      the use of the current SVGA driver. */</span>
<span class="p">};</span>


<span class="cm">/*</span>
<span class="cm"> * Guest memory regions (GMRs):</span>
<span class="cm"> *</span>
<span class="cm"> * This is a new memory mapping feature available in SVGA devices</span>
<span class="cm"> * which have the SVGA_CAP_GMR bit set. Previously, there were two</span>
<span class="cm"> * fixed memory regions available with which to share data between the</span>
<span class="cm"> * device and the driver: the FIFO (&#39;MEM&#39;) and the framebuffer. GMRs</span>
<span class="cm"> * are our name for an extensible way of providing arbitrary DMA</span>
<span class="cm"> * buffers for use between the driver and the SVGA device. They are a</span>
<span class="cm"> * new alternative to framebuffer memory, usable for both 2D and 3D</span>
<span class="cm"> * graphics operations.</span>
<span class="cm"> *</span>
<span class="cm"> * Since GMR mapping must be done synchronously with guest CPU</span>
<span class="cm"> * execution, we use a new pair of SVGA registers:</span>
<span class="cm"> *</span>
<span class="cm"> *   SVGA_REG_GMR_ID --</span>
<span class="cm"> *</span>
<span class="cm"> *     Read/write.</span>
<span class="cm"> *     This register holds the 32-bit ID (a small positive integer)</span>
<span class="cm"> *     of a GMR to create, delete, or redefine. Writing this register</span>
<span class="cm"> *     has no side-effects.</span>
<span class="cm"> *</span>
<span class="cm"> *   SVGA_REG_GMR_DESCRIPTOR --</span>
<span class="cm"> *</span>
<span class="cm"> *     Write-only.</span>
<span class="cm"> *     Writing this register will create, delete, or redefine the GMR</span>
<span class="cm"> *     specified by the above ID register. If this register is zero,</span>
<span class="cm"> *     the GMR is deleted. Any pointers into this GMR (including those</span>
<span class="cm"> *     currently being processed by FIFO commands) will be</span>
<span class="cm"> *     synchronously invalidated.</span>
<span class="cm"> *</span>
<span class="cm"> *     If this register is nonzero, it must be the physical page</span>
<span class="cm"> *     number (PPN) of a data structure which describes the physical</span>
<span class="cm"> *     layout of the memory region this GMR should describe. The</span>
<span class="cm"> *     descriptor structure will be read synchronously by the SVGA</span>
<span class="cm"> *     device when this register is written. The descriptor need not</span>
<span class="cm"> *     remain allocated for the lifetime of the GMR.</span>
<span class="cm"> *</span>
<span class="cm"> *     The guest driver should write SVGA_REG_GMR_ID first, then</span>
<span class="cm"> *     SVGA_REG_GMR_DESCRIPTOR.</span>
<span class="cm"> *</span>
<span class="cm"> *   SVGA_REG_GMR_MAX_IDS --</span>
<span class="cm"> *</span>
<span class="cm"> *     Read-only.</span>
<span class="cm"> *     The SVGA device may choose to support a maximum number of</span>
<span class="cm"> *     user-defined GMR IDs. This register holds the number of supported</span>
<span class="cm"> *     IDs. (The maximum supported ID plus 1)</span>
<span class="cm"> *</span>
<span class="cm"> *   SVGA_REG_GMR_MAX_DESCRIPTOR_LENGTH --</span>
<span class="cm"> *</span>
<span class="cm"> *     Read-only.</span>
<span class="cm"> *     The SVGA device may choose to put a limit on the total number</span>
<span class="cm"> *     of SVGAGuestMemDescriptor structures it will read when defining</span>
<span class="cm"> *     a single GMR.</span>
<span class="cm"> *</span>
<span class="cm"> * The descriptor structure is an array of SVGAGuestMemDescriptor</span>
<span class="cm"> * structures. Each structure may do one of three things:</span>
<span class="cm"> *</span>
<span class="cm"> *   - Terminate the GMR descriptor list.</span>
<span class="cm"> *     (ppn==0, numPages==0)</span>
<span class="cm"> *</span>
<span class="cm"> *   - Add a PPN or range of PPNs to the GMR&#39;s virtual address space.</span>
<span class="cm"> *     (ppn != 0, numPages != 0)</span>
<span class="cm"> *</span>
<span class="cm"> *   - Provide the PPN of the next SVGAGuestMemDescriptor, in order to</span>
<span class="cm"> *     support multi-page GMR descriptor tables without forcing the</span>
<span class="cm"> *     driver to allocate physically contiguous memory.</span>
<span class="cm"> *     (ppn != 0, numPages == 0)</span>
<span class="cm"> *</span>
<span class="cm"> * Note that each physical page of SVGAGuestMemDescriptor structures</span>
<span class="cm"> * can describe at least 2MB of guest memory. If the driver needs to</span>
<span class="cm"> * use more than one page of descriptor structures, it must use one of</span>
<span class="cm"> * its SVGAGuestMemDescriptors to point to an additional page.  The</span>
<span class="cm"> * device will never automatically cross a page boundary.</span>
<span class="cm"> *</span>
<span class="cm"> * Once the driver has described a GMR, it is immediately available</span>
<span class="cm"> * for use via any FIFO command that uses an SVGAGuestPtr structure.</span>
<span class="cm"> * These pointers include a GMR identifier plus an offset into that</span>
<span class="cm"> * GMR.</span>
<span class="cm"> *</span>
<span class="cm"> * The driver must check the SVGA_CAP_GMR bit before using the GMR</span>
<span class="cm"> * registers.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Special GMR IDs, allowing SVGAGuestPtrs to point to framebuffer</span>
<span class="cm"> * memory as well.  In the future, these IDs could even be used to</span>
<span class="cm"> * allow legacy memory regions to be redefined by the guest as GMRs.</span>
<span class="cm"> *</span>
<span class="cm"> * Using the guest framebuffer (GFB) at BAR1 for general purpose DMA</span>
<span class="cm"> * is being phased out. Please try to use user-defined GMRs whenever</span>
<span class="cm"> * possible.</span>
<span class="cm"> */</span>
<span class="cp">#define SVGA_GMR_NULL         ((uint32) -1)</span>
<span class="cp">#define SVGA_GMR_FRAMEBUFFER  ((uint32) -2)  </span><span class="cm">/* Guest Framebuffer (GFB) */</span><span class="cp"></span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="n">SVGAGuestMemDescriptor</span> <span class="p">{</span>
   <span class="n">uint32</span> <span class="n">ppn</span><span class="p">;</span>
   <span class="n">uint32</span> <span class="n">numPages</span><span class="p">;</span>
<span class="p">}</span> <span class="n">SVGAGuestMemDescriptor</span><span class="p">;</span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="n">SVGAGuestPtr</span> <span class="p">{</span>
   <span class="n">uint32</span> <span class="n">gmrId</span><span class="p">;</span>
   <span class="n">uint32</span> <span class="n">offset</span><span class="p">;</span>
<span class="p">}</span> <span class="n">SVGAGuestPtr</span><span class="p">;</span>


<span class="cm">/*</span>
<span class="cm"> * SVGAGMRImageFormat --</span>
<span class="cm"> *</span>
<span class="cm"> *    This is a packed representation of the source 2D image format</span>
<span class="cm"> *    for a GMR-to-screen blit. Currently it is defined as an encoding</span>
<span class="cm"> *    of the screen&#39;s color depth and bits-per-pixel, however, 16 bits</span>
<span class="cm"> *    are reserved for future use to identify other encodings (such as</span>
<span class="cm"> *    RGBA or higher-precision images).</span>
<span class="cm"> *</span>
<span class="cm"> *    Currently supported formats:</span>
<span class="cm"> *</span>
<span class="cm"> *       bpp depth  Format Name</span>
<span class="cm"> *       --- -----  -----------</span>
<span class="cm"> *        32    24  32-bit BGRX</span>
<span class="cm"> *        24    24  24-bit BGR</span>
<span class="cm"> *        16    16  RGB 5-6-5</span>
<span class="cm"> *        16    15  RGB 5-5-5</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="n">SVGAGMRImageFormat</span> <span class="p">{</span>
   <span class="k">union</span> <span class="p">{</span>
      <span class="k">struct</span> <span class="p">{</span>
         <span class="n">uint32</span> <span class="n">bitsPerPixel</span> <span class="o">:</span> <span class="mi">8</span><span class="p">;</span>
         <span class="n">uint32</span> <span class="n">colorDepth</span>   <span class="o">:</span> <span class="mi">8</span><span class="p">;</span>
         <span class="n">uint32</span> <span class="n">reserved</span>     <span class="o">:</span> <span class="mi">16</span><span class="p">;</span>  <span class="cm">/* Must be zero */</span>
      <span class="p">};</span>

      <span class="n">uint32</span> <span class="n">value</span><span class="p">;</span>
   <span class="p">};</span>
<span class="p">}</span> <span class="n">SVGAGMRImageFormat</span><span class="p">;</span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="n">SVGAGuestImage</span> <span class="p">{</span>
   <span class="n">SVGAGuestPtr</span>         <span class="n">ptr</span><span class="p">;</span>

   <span class="cm">/*</span>
<span class="cm">    * A note on interpretation of pitch: This value of pitch is the</span>
<span class="cm">    * number of bytes between vertically adjacent image</span>
<span class="cm">    * blocks. Normally this is the number of bytes between the first</span>
<span class="cm">    * pixel of two adjacent scanlines. With compressed textures,</span>
<span class="cm">    * however, this may represent the number of bytes between</span>
<span class="cm">    * compression blocks rather than between rows of pixels.</span>
<span class="cm">    *</span>
<span class="cm">    * XXX: Compressed textures currently must be tightly packed in guest memory.</span>
<span class="cm">    *</span>
<span class="cm">    * If the image is 1-dimensional, pitch is ignored.</span>
<span class="cm">    *</span>
<span class="cm">    * If &#39;pitch&#39; is zero, the SVGA3D device calculates a pitch value</span>
<span class="cm">    * assuming each row of blocks is tightly packed.</span>
<span class="cm">    */</span>
   <span class="n">uint32</span> <span class="n">pitch</span><span class="p">;</span>
<span class="p">}</span> <span class="n">SVGAGuestImage</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * SVGAColorBGRX --</span>
<span class="cm"> *</span>
<span class="cm"> *    A 24-bit color format (BGRX), which does not depend on the</span>
<span class="cm"> *    format of the legacy guest framebuffer (GFB) or the current</span>
<span class="cm"> *    GMRFB state.</span>
<span class="cm"> */</span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="n">SVGAColorBGRX</span> <span class="p">{</span>
   <span class="k">union</span> <span class="p">{</span>
      <span class="k">struct</span> <span class="p">{</span>
         <span class="n">uint32</span> <span class="n">b</span> <span class="o">:</span> <span class="mi">8</span><span class="p">;</span>
         <span class="n">uint32</span> <span class="n">g</span> <span class="o">:</span> <span class="mi">8</span><span class="p">;</span>
         <span class="n">uint32</span> <span class="n">r</span> <span class="o">:</span> <span class="mi">8</span><span class="p">;</span>
         <span class="n">uint32</span> <span class="n">x</span> <span class="o">:</span> <span class="mi">8</span><span class="p">;</span>  <span class="cm">/* Unused */</span>
      <span class="p">};</span>

      <span class="n">uint32</span> <span class="n">value</span><span class="p">;</span>
   <span class="p">};</span>
<span class="p">}</span> <span class="n">SVGAColorBGRX</span><span class="p">;</span>


<span class="cm">/*</span>
<span class="cm"> * SVGASignedRect --</span>
<span class="cm"> * SVGASignedPoint --</span>
<span class="cm"> *</span>
<span class="cm"> *    Signed rectangle and point primitives. These are used by the new</span>
<span class="cm"> *    2D primitives for drawing to Screen Objects, which can occupy a</span>
<span class="cm"> *    signed virtual coordinate space.</span>
<span class="cm"> *</span>
<span class="cm"> *    SVGASignedRect specifies a half-open interval: the (left, top)</span>
<span class="cm"> *    pixel is part of the rectangle, but the (right, bottom) pixel is</span>
<span class="cm"> *    not.</span>
<span class="cm"> */</span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="n">SVGASignedRect</span> <span class="p">{</span>
   <span class="n">int32</span>  <span class="n">left</span><span class="p">;</span>
   <span class="n">int32</span>  <span class="n">top</span><span class="p">;</span>
   <span class="n">int32</span>  <span class="n">right</span><span class="p">;</span>
   <span class="n">int32</span>  <span class="n">bottom</span><span class="p">;</span>
<span class="p">}</span> <span class="n">SVGASignedRect</span><span class="p">;</span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="n">SVGASignedPoint</span> <span class="p">{</span>
   <span class="n">int32</span>  <span class="n">x</span><span class="p">;</span>
   <span class="n">int32</span>  <span class="n">y</span><span class="p">;</span>
<span class="p">}</span> <span class="n">SVGASignedPoint</span><span class="p">;</span>


<span class="cm">/*</span>
<span class="cm"> *  Capabilities</span>
<span class="cm"> *</span>
<span class="cm"> *  Note the holes in the bitfield. Missing bits have been deprecated,</span>
<span class="cm"> *  and must not be reused. Those capabilities will never be reported</span>
<span class="cm"> *  by new versions of the SVGA device.</span>
<span class="cm"> *</span>
<span class="cm"> * SVGA_CAP_GMR2 --</span>
<span class="cm"> *    Provides asynchronous commands to define and remap guest memory</span>
<span class="cm"> *    regions.  Adds device registers SVGA_REG_GMRS_MAX_PAGES and</span>
<span class="cm"> *    SVGA_REG_MEMORY_SIZE.</span>
<span class="cm"> *</span>
<span class="cm"> * SVGA_CAP_SCREEN_OBJECT_2 --</span>
<span class="cm"> *    Allow screen object support, and require backing stores from the</span>
<span class="cm"> *    guest for each screen object.</span>
<span class="cm"> */</span>

<span class="cp">#define SVGA_CAP_NONE               0x00000000</span>
<span class="cp">#define SVGA_CAP_RECT_COPY          0x00000002</span>
<span class="cp">#define SVGA_CAP_CURSOR             0x00000020</span>
<span class="cp">#define SVGA_CAP_CURSOR_BYPASS      0x00000040   </span><span class="cm">/* Legacy (Use Cursor Bypass 3 instead) */</span><span class="cp"></span>
<span class="cp">#define SVGA_CAP_CURSOR_BYPASS_2    0x00000080   </span><span class="cm">/* Legacy (Use Cursor Bypass 3 instead) */</span><span class="cp"></span>
<span class="cp">#define SVGA_CAP_8BIT_EMULATION     0x00000100</span>
<span class="cp">#define SVGA_CAP_ALPHA_CURSOR       0x00000200</span>
<span class="cp">#define SVGA_CAP_3D                 0x00004000</span>
<span class="cp">#define SVGA_CAP_EXTENDED_FIFO      0x00008000</span>
<span class="cp">#define SVGA_CAP_MULTIMON           0x00010000   </span><span class="cm">/* Legacy multi-monitor support */</span><span class="cp"></span>
<span class="cp">#define SVGA_CAP_PITCHLOCK          0x00020000</span>
<span class="cp">#define SVGA_CAP_IRQMASK            0x00040000</span>
<span class="cp">#define SVGA_CAP_DISPLAY_TOPOLOGY   0x00080000   </span><span class="cm">/* Legacy multi-monitor support */</span><span class="cp"></span>
<span class="cp">#define SVGA_CAP_GMR                0x00100000</span>
<span class="cp">#define SVGA_CAP_TRACES             0x00200000</span>
<span class="cp">#define SVGA_CAP_GMR2               0x00400000</span>
<span class="cp">#define SVGA_CAP_SCREEN_OBJECT_2    0x00800000</span>


<span class="cm">/*</span>
<span class="cm"> * FIFO register indices.</span>
<span class="cm"> *</span>
<span class="cm"> * The FIFO is a chunk of device memory mapped into guest physmem.  It</span>
<span class="cm"> * is always treated as 32-bit words.</span>
<span class="cm"> *</span>
<span class="cm"> * The guest driver gets to decide how to partition it between</span>
<span class="cm"> * - FIFO registers (there are always at least 4, specifying where the</span>
<span class="cm"> *   following data area is and how much data it contains; there may be</span>
<span class="cm"> *   more registers following these, depending on the FIFO protocol</span>
<span class="cm"> *   version in use)</span>
<span class="cm"> * - FIFO data, written by the guest and slurped out by the VMX.</span>
<span class="cm"> * These indices are 32-bit word offsets into the FIFO.</span>
<span class="cm"> */</span>

<span class="k">enum</span> <span class="p">{</span>
   <span class="cm">/*</span>
<span class="cm">    * Block 1 (basic registers): The originally defined FIFO registers.</span>
<span class="cm">    * These exist and are valid for all versions of the FIFO protocol.</span>
<span class="cm">    */</span>

   <span class="n">SVGA_FIFO_MIN</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
   <span class="n">SVGA_FIFO_MAX</span><span class="p">,</span>       <span class="cm">/* The distance from MIN to MAX must be at least 10K */</span>
   <span class="n">SVGA_FIFO_NEXT_CMD</span><span class="p">,</span>
   <span class="n">SVGA_FIFO_STOP</span><span class="p">,</span>

   <span class="cm">/*</span>
<span class="cm">    * Block 2 (extended registers): Mandatory registers for the extended</span>
<span class="cm">    * FIFO.  These exist if the SVGA caps register includes</span>
<span class="cm">    * SVGA_CAP_EXTENDED_FIFO; some of them are valid only if their</span>
<span class="cm">    * associated capability bit is enabled.</span>
<span class="cm">    *</span>
<span class="cm">    * Note that when originally defined, SVGA_CAP_EXTENDED_FIFO implied</span>
<span class="cm">    * support only for (FIFO registers) CAPABILITIES, FLAGS, and FENCE.</span>
<span class="cm">    * This means that the guest has to test individually (in most cases</span>
<span class="cm">    * using FIFO caps) for the presence of registers after this; the VMX</span>
<span class="cm">    * can define &quot;extended FIFO&quot; to mean whatever it wants, and currently</span>
<span class="cm">    * won&#39;t enable it unless there&#39;s room for that set and much more.</span>
<span class="cm">    */</span>

   <span class="n">SVGA_FIFO_CAPABILITIES</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
   <span class="n">SVGA_FIFO_FLAGS</span><span class="p">,</span>
   <span class="cm">/* Valid with SVGA_FIFO_CAP_FENCE: */</span>
   <span class="n">SVGA_FIFO_FENCE</span><span class="p">,</span>

   <span class="cm">/*</span>
<span class="cm">    * Block 3a (optional extended registers): Additional registers for the</span>
<span class="cm">    * extended FIFO, whose presence isn&#39;t actually implied by</span>
<span class="cm">    * SVGA_CAP_EXTENDED_FIFO; these exist if SVGA_FIFO_MIN is high enough to</span>
<span class="cm">    * leave room for them.</span>
<span class="cm">    *</span>
<span class="cm">    * These in block 3a, the VMX currently considers mandatory for the</span>
<span class="cm">    * extended FIFO.</span>
<span class="cm">    */</span>

   <span class="cm">/* Valid if exists (i.e. if extended FIFO enabled): */</span>
   <span class="n">SVGA_FIFO_3D_HWVERSION</span><span class="p">,</span>       <span class="cm">/* See SVGA3dHardwareVersion in svga3d_reg.h */</span>
   <span class="cm">/* Valid with SVGA_FIFO_CAP_PITCHLOCK: */</span>
   <span class="n">SVGA_FIFO_PITCHLOCK</span><span class="p">,</span>

   <span class="cm">/* Valid with SVGA_FIFO_CAP_CURSOR_BYPASS_3: */</span>
   <span class="n">SVGA_FIFO_CURSOR_ON</span><span class="p">,</span>          <span class="cm">/* Cursor bypass 3 show/hide register */</span>
   <span class="n">SVGA_FIFO_CURSOR_X</span><span class="p">,</span>           <span class="cm">/* Cursor bypass 3 x register */</span>
   <span class="n">SVGA_FIFO_CURSOR_Y</span><span class="p">,</span>           <span class="cm">/* Cursor bypass 3 y register */</span>
   <span class="n">SVGA_FIFO_CURSOR_COUNT</span><span class="p">,</span>       <span class="cm">/* Incremented when any of the other 3 change */</span>
   <span class="n">SVGA_FIFO_CURSOR_LAST_UPDATED</span><span class="p">,</span><span class="cm">/* Last time the host updated the cursor */</span>

   <span class="cm">/* Valid with SVGA_FIFO_CAP_RESERVE: */</span>
   <span class="n">SVGA_FIFO_RESERVED</span><span class="p">,</span>           <span class="cm">/* Bytes past NEXT_CMD with real contents */</span>

   <span class="cm">/*</span>
<span class="cm">    * Valid with SVGA_FIFO_CAP_SCREEN_OBJECT or SVGA_FIFO_CAP_SCREEN_OBJECT_2:</span>
<span class="cm">    *</span>
<span class="cm">    * By default this is SVGA_ID_INVALID, to indicate that the cursor</span>
<span class="cm">    * coordinates are specified relative to the virtual root. If this</span>
<span class="cm">    * is set to a specific screen ID, cursor position is reinterpreted</span>
<span class="cm">    * as a signed offset relative to that screen&#39;s origin.</span>
<span class="cm">    */</span>
   <span class="n">SVGA_FIFO_CURSOR_SCREEN_ID</span><span class="p">,</span>

   <span class="cm">/*</span>
<span class="cm">    * Valid with SVGA_FIFO_CAP_DEAD</span>
<span class="cm">    *</span>
<span class="cm">    * An arbitrary value written by the host, drivers should not use it.</span>
<span class="cm">    */</span>
   <span class="n">SVGA_FIFO_DEAD</span><span class="p">,</span>

   <span class="cm">/*</span>
<span class="cm">    * Valid with SVGA_FIFO_CAP_3D_HWVERSION_REVISED:</span>
<span class="cm">    *</span>
<span class="cm">    * Contains 3D HWVERSION (see SVGA3dHardwareVersion in svga3d_reg.h)</span>
<span class="cm">    * on platforms that can enforce graphics resource limits.</span>
<span class="cm">    */</span>
   <span class="n">SVGA_FIFO_3D_HWVERSION_REVISED</span><span class="p">,</span>

   <span class="cm">/*</span>
<span class="cm">    * XXX: The gap here, up until SVGA_FIFO_3D_CAPS, can be used for new</span>
<span class="cm">    * registers, but this must be done carefully and with judicious use of</span>
<span class="cm">    * capability bits, since comparisons based on SVGA_FIFO_MIN aren&#39;t</span>
<span class="cm">    * enough to tell you whether the register exists: we&#39;ve shipped drivers</span>
<span class="cm">    * and products that used SVGA_FIFO_3D_CAPS but didn&#39;t know about some of</span>
<span class="cm">    * the earlier ones.  The actual order of introduction was:</span>
<span class="cm">    * - PITCHLOCK</span>
<span class="cm">    * - 3D_CAPS</span>
<span class="cm">    * - CURSOR_* (cursor bypass 3)</span>
<span class="cm">    * - RESERVED</span>
<span class="cm">    * So, code that wants to know whether it can use any of the</span>
<span class="cm">    * aforementioned registers, or anything else added after PITCHLOCK and</span>
<span class="cm">    * before 3D_CAPS, needs to reason about something other than</span>
<span class="cm">    * SVGA_FIFO_MIN.</span>
<span class="cm">    */</span>

   <span class="cm">/*</span>
<span class="cm">    * 3D caps block space; valid with 3D hardware version &gt;=</span>
<span class="cm">    * SVGA3D_HWVERSION_WS6_B1.</span>
<span class="cm">    */</span>
   <span class="n">SVGA_FIFO_3D_CAPS</span>      <span class="o">=</span> <span class="mi">32</span><span class="p">,</span>
   <span class="n">SVGA_FIFO_3D_CAPS_LAST</span> <span class="o">=</span> <span class="mi">32</span> <span class="o">+</span> <span class="mi">255</span><span class="p">,</span>

   <span class="cm">/*</span>
<span class="cm">    * End of VMX&#39;s current definition of &quot;extended-FIFO registers&quot;.</span>
<span class="cm">    * Registers before here are always enabled/disabled as a block; either</span>
<span class="cm">    * the extended FIFO is enabled and includes all preceding registers, or</span>
<span class="cm">    * it&#39;s disabled entirely.</span>
<span class="cm">    *</span>
<span class="cm">    * Block 3b (truly optional extended registers): Additional registers for</span>
<span class="cm">    * the extended FIFO, which the VMX already knows how to enable and</span>
<span class="cm">    * disable with correct granularity.</span>
<span class="cm">    *</span>
<span class="cm">    * Registers after here exist if and only if the guest SVGA driver</span>
<span class="cm">    * sets SVGA_FIFO_MIN high enough to leave room for them.</span>
<span class="cm">    */</span>

   <span class="cm">/* Valid if register exists: */</span>
   <span class="n">SVGA_FIFO_GUEST_3D_HWVERSION</span><span class="p">,</span> <span class="cm">/* Guest driver&#39;s 3D version */</span>
   <span class="n">SVGA_FIFO_FENCE_GOAL</span><span class="p">,</span>         <span class="cm">/* Matching target for SVGA_IRQFLAG_FENCE_GOAL */</span>
   <span class="n">SVGA_FIFO_BUSY</span><span class="p">,</span>               <span class="cm">/* See &quot;FIFO Synchronization Registers&quot; */</span>

   <span class="cm">/*</span>
<span class="cm">    * Always keep this last.  This defines the maximum number of</span>
<span class="cm">    * registers we know about.  At power-on, this value is placed in</span>
<span class="cm">    * the SVGA_REG_MEM_REGS register, and we expect the guest driver</span>
<span class="cm">    * to allocate this much space in FIFO memory for registers.</span>
<span class="cm">    */</span>
    <span class="n">SVGA_FIFO_NUM_REGS</span>
<span class="p">};</span>


<span class="cm">/*</span>
<span class="cm"> * Definition of registers included in extended FIFO support.</span>
<span class="cm"> *</span>
<span class="cm"> * The guest SVGA driver gets to allocate the FIFO between registers</span>
<span class="cm"> * and data.  It must always allocate at least 4 registers, but old</span>
<span class="cm"> * drivers stopped there.</span>
<span class="cm"> *</span>
<span class="cm"> * The VMX will enable extended FIFO support if and only if the guest</span>
<span class="cm"> * left enough room for all registers defined as part of the mandatory</span>
<span class="cm"> * set for the extended FIFO.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that the guest drivers typically allocate the FIFO only at</span>
<span class="cm"> * initialization time, not at mode switches, so it&#39;s likely that the</span>
<span class="cm"> * number of FIFO registers won&#39;t change without a reboot.</span>
<span class="cm"> *</span>
<span class="cm"> * All registers less than this value are guaranteed to be present if</span>
<span class="cm"> * svgaUser-&gt;fifo.extended is set. Any later registers must be tested</span>
<span class="cm"> * individually for compatibility at each use (in the VMX).</span>
<span class="cm"> *</span>
<span class="cm"> * This value is used only by the VMX, so it can change without</span>
<span class="cm"> * affecting driver compatibility; keep it that way?</span>
<span class="cm"> */</span>
<span class="cp">#define SVGA_FIFO_EXTENDED_MANDATORY_REGS  (SVGA_FIFO_3D_CAPS_LAST + 1)</span>


<span class="cm">/*</span>
<span class="cm"> * FIFO Synchronization Registers</span>
<span class="cm"> *</span>
<span class="cm"> *  This explains the relationship between the various FIFO</span>
<span class="cm"> *  sync-related registers in IOSpace and in FIFO space.</span>
<span class="cm"> *</span>
<span class="cm"> *  SVGA_REG_SYNC --</span>
<span class="cm"> *</span>
<span class="cm"> *       The SYNC register can be used in two different ways by the guest:</span>
<span class="cm"> *</span>
<span class="cm"> *         1. If the guest wishes to fully sync (drain) the FIFO,</span>
<span class="cm"> *            it will write once to SYNC then poll on the BUSY</span>
<span class="cm"> *            register. The FIFO is sync&#39;ed once BUSY is zero.</span>
<span class="cm"> *</span>
<span class="cm"> *         2. If the guest wants to asynchronously wake up the host,</span>
<span class="cm"> *            it will write once to SYNC without polling on BUSY.</span>
<span class="cm"> *            Ideally it will do this after some new commands have</span>
<span class="cm"> *            been placed in the FIFO, and after reading a zero</span>
<span class="cm"> *            from SVGA_FIFO_BUSY.</span>
<span class="cm"> *</span>
<span class="cm"> *       (1) is the original behaviour that SYNC was designed to</span>
<span class="cm"> *       support.  Originally, a write to SYNC would implicitly</span>
<span class="cm"> *       trigger a read from BUSY. This causes us to synchronously</span>
<span class="cm"> *       process the FIFO.</span>
<span class="cm"> *</span>
<span class="cm"> *       This behaviour has since been changed so that writing SYNC</span>
<span class="cm"> *       will *not* implicitly cause a read from BUSY. Instead, it</span>
<span class="cm"> *       makes a channel call which asynchronously wakes up the MKS</span>
<span class="cm"> *       thread.</span>
<span class="cm"> *</span>
<span class="cm"> *       New guests can use this new behaviour to implement (2)</span>
<span class="cm"> *       efficiently. This lets guests get the host&#39;s attention</span>
<span class="cm"> *       without waiting for the MKS to poll, which gives us much</span>
<span class="cm"> *       better CPU utilization on SMP hosts and on UP hosts while</span>
<span class="cm"> *       we&#39;re blocked on the host GPU.</span>
<span class="cm"> *</span>
<span class="cm"> *       Old guests shouldn&#39;t notice the behaviour change. SYNC was</span>
<span class="cm"> *       never guaranteed to process the entire FIFO, since it was</span>
<span class="cm"> *       bounded to a particular number of CPU cycles. Old guests will</span>
<span class="cm"> *       still loop on the BUSY register until the FIFO is empty.</span>
<span class="cm"> *</span>
<span class="cm"> *       Writing to SYNC currently has the following side-effects:</span>
<span class="cm"> *</span>
<span class="cm"> *         - Sets SVGA_REG_BUSY to TRUE (in the monitor)</span>
<span class="cm"> *         - Asynchronously wakes up the MKS thread for FIFO processing</span>
<span class="cm"> *         - The value written to SYNC is recorded as a &quot;reason&quot;, for</span>
<span class="cm"> *           stats purposes.</span>
<span class="cm"> *</span>
<span class="cm"> *       If SVGA_FIFO_BUSY is available, drivers are advised to only</span>
<span class="cm"> *       write to SYNC if SVGA_FIFO_BUSY is FALSE. Drivers should set</span>
<span class="cm"> *       SVGA_FIFO_BUSY to TRUE after writing to SYNC. The MKS will</span>
<span class="cm"> *       eventually set SVGA_FIFO_BUSY on its own, but this approach</span>
<span class="cm"> *       lets the driver avoid sending multiple asynchronous wakeup</span>
<span class="cm"> *       messages to the MKS thread.</span>
<span class="cm"> *</span>
<span class="cm"> *  SVGA_REG_BUSY --</span>
<span class="cm"> *</span>
<span class="cm"> *       This register is set to TRUE when SVGA_REG_SYNC is written,</span>
<span class="cm"> *       and it reads as FALSE when the FIFO has been completely</span>
<span class="cm"> *       drained.</span>
<span class="cm"> *</span>
<span class="cm"> *       Every read from this register causes us to synchronously</span>
<span class="cm"> *       process FIFO commands. There is no guarantee as to how many</span>
<span class="cm"> *       commands each read will process.</span>
<span class="cm"> *</span>
<span class="cm"> *       CPU time spent processing FIFO commands will be billed to</span>
<span class="cm"> *       the guest.</span>
<span class="cm"> *</span>
<span class="cm"> *       New drivers should avoid using this register unless they</span>
<span class="cm"> *       need to guarantee that the FIFO is completely drained. It</span>
<span class="cm"> *       is overkill for performing a sync-to-fence. Older drivers</span>
<span class="cm"> *       will use this register for any type of synchronization.</span>
<span class="cm"> *</span>
<span class="cm"> *  SVGA_FIFO_BUSY --</span>
<span class="cm"> *</span>
<span class="cm"> *       This register is a fast way for the guest driver to check</span>
<span class="cm"> *       whether the FIFO is already being processed. It reads and</span>
<span class="cm"> *       writes at normal RAM speeds, with no monitor intervention.</span>
<span class="cm"> *</span>
<span class="cm"> *       If this register reads as TRUE, the host is guaranteeing that</span>
<span class="cm"> *       any new commands written into the FIFO will be noticed before</span>
<span class="cm"> *       the MKS goes back to sleep.</span>
<span class="cm"> *</span>
<span class="cm"> *       If this register reads as FALSE, no such guarantee can be</span>
<span class="cm"> *       made.</span>
<span class="cm"> *</span>
<span class="cm"> *       The guest should use this register to quickly determine</span>
<span class="cm"> *       whether or not it needs to wake up the host. If the guest</span>
<span class="cm"> *       just wrote a command or group of commands that it would like</span>
<span class="cm"> *       the host to begin processing, it should:</span>
<span class="cm"> *</span>
<span class="cm"> *         1. Read SVGA_FIFO_BUSY. If it reads as TRUE, no further</span>
<span class="cm"> *            action is necessary.</span>
<span class="cm"> *</span>
<span class="cm"> *         2. Write TRUE to SVGA_FIFO_BUSY. This informs future guest</span>
<span class="cm"> *            code that we&#39;ve already sent a SYNC to the host and we</span>
<span class="cm"> *            don&#39;t need to send a duplicate.</span>
<span class="cm"> *</span>
<span class="cm"> *         3. Write a reason to SVGA_REG_SYNC. This will send an</span>
<span class="cm"> *            asynchronous wakeup to the MKS thread.</span>
<span class="cm"> */</span>


<span class="cm">/*</span>
<span class="cm"> * FIFO Capabilities</span>
<span class="cm"> *</span>
<span class="cm"> *      Fence -- Fence register and command are supported</span>
<span class="cm"> *      Accel Front -- Front buffer only commands are supported</span>
<span class="cm"> *      Pitch Lock -- Pitch lock register is supported</span>
<span class="cm"> *      Video -- SVGA Video overlay units are supported</span>
<span class="cm"> *      Escape -- Escape command is supported</span>
<span class="cm"> *</span>
<span class="cm"> * XXX: Add longer descriptions for each capability, including a list</span>
<span class="cm"> *      of the new features that each capability provides.</span>
<span class="cm"> *</span>
<span class="cm"> * SVGA_FIFO_CAP_SCREEN_OBJECT --</span>
<span class="cm"> *</span>
<span class="cm"> *    Provides dynamic multi-screen rendering, for improved Unity and</span>
<span class="cm"> *    multi-monitor modes. With Screen Object, the guest can</span>
<span class="cm"> *    dynamically create and destroy &#39;screens&#39;, which can represent</span>
<span class="cm"> *    Unity windows or virtual monitors. Screen Object also provides</span>
<span class="cm"> *    strong guarantees that DMA operations happen only when</span>
<span class="cm"> *    guest-initiated. Screen Object deprecates the BAR1 guest</span>
<span class="cm"> *    framebuffer (GFB) and all commands that work only with the GFB.</span>
<span class="cm"> *</span>
<span class="cm"> *    New registers:</span>
<span class="cm"> *       FIFO_CURSOR_SCREEN_ID, VIDEO_DATA_GMRID, VIDEO_DST_SCREEN_ID</span>
<span class="cm"> *</span>
<span class="cm"> *    New 2D commands:</span>
<span class="cm"> *       DEFINE_SCREEN, DESTROY_SCREEN, DEFINE_GMRFB, BLIT_GMRFB_TO_SCREEN,</span>
<span class="cm"> *       BLIT_SCREEN_TO_GMRFB, ANNOTATION_FILL, ANNOTATION_COPY</span>
<span class="cm"> *</span>
<span class="cm"> *    New 3D commands:</span>
<span class="cm"> *       BLIT_SURFACE_TO_SCREEN</span>
<span class="cm"> *</span>
<span class="cm"> *    New guarantees:</span>
<span class="cm"> *</span>
<span class="cm"> *       - The host will not read or write guest memory, including the GFB,</span>
<span class="cm"> *         except when explicitly initiated by a DMA command.</span>
<span class="cm"> *</span>
<span class="cm"> *       - All DMA, including legacy DMA like UPDATE and PRESENT_READBACK,</span>
<span class="cm"> *         is guaranteed to complete before any subsequent FENCEs.</span>
<span class="cm"> *</span>
<span class="cm"> *       - All legacy commands which affect a Screen (UPDATE, PRESENT,</span>
<span class="cm"> *         PRESENT_READBACK) as well as new Screen blit commands will</span>
<span class="cm"> *         all behave consistently as blits, and memory will be read</span>
<span class="cm"> *         or written in FIFO order.</span>
<span class="cm"> *</span>
<span class="cm"> *         For example, if you PRESENT from one SVGA3D surface to multiple</span>
<span class="cm"> *         places on the screen, the data copied will always be from the</span>
<span class="cm"> *         SVGA3D surface at the time the PRESENT was issued in the FIFO.</span>
<span class="cm"> *         This was not necessarily true on devices without Screen Object.</span>
<span class="cm"> *</span>
<span class="cm"> *         This means that on devices that support Screen Object, the</span>
<span class="cm"> *         PRESENT_READBACK command should not be necessary unless you</span>
<span class="cm"> *         actually want to read back the results of 3D rendering into</span>
<span class="cm"> *         system memory. (And for that, the BLIT_SCREEN_TO_GMRFB</span>
<span class="cm"> *         command provides a strict superset of functionality.)</span>
<span class="cm"> *</span>
<span class="cm"> *       - When a screen is resized, either using Screen Object commands or</span>
<span class="cm"> *         legacy multimon registers, its contents are preserved.</span>
<span class="cm"> *</span>
<span class="cm"> * SVGA_FIFO_CAP_GMR2 --</span>
<span class="cm"> *</span>
<span class="cm"> *    Provides new commands to define and remap guest memory regions (GMR).</span>
<span class="cm"> *</span>
<span class="cm"> *    New 2D commands:</span>
<span class="cm"> *       DEFINE_GMR2, REMAP_GMR2.</span>
<span class="cm"> *</span>
<span class="cm"> * SVGA_FIFO_CAP_3D_HWVERSION_REVISED --</span>
<span class="cm"> *</span>
<span class="cm"> *    Indicates new register SVGA_FIFO_3D_HWVERSION_REVISED exists.</span>
<span class="cm"> *    This register may replace SVGA_FIFO_3D_HWVERSION on platforms</span>
<span class="cm"> *    that enforce graphics resource limits.  This allows the platform</span>
<span class="cm"> *    to clear SVGA_FIFO_3D_HWVERSION and disable 3D in legacy guest</span>
<span class="cm"> *    drivers that do not limit their resources.</span>
<span class="cm"> *</span>
<span class="cm"> *    Note this is an alias to SVGA_FIFO_CAP_GMR2 because these indicators</span>
<span class="cm"> *    are codependent (and thus we use a single capability bit).</span>
<span class="cm"> *</span>
<span class="cm"> * SVGA_FIFO_CAP_SCREEN_OBJECT_2 --</span>
<span class="cm"> *</span>
<span class="cm"> *    Modifies the DEFINE_SCREEN command to include a guest provided</span>
<span class="cm"> *    backing store in GMR memory and the bytesPerLine for the backing</span>
<span class="cm"> *    store.  This capability requires the use of a backing store when</span>
<span class="cm"> *    creating screen objects.  However if SVGA_FIFO_CAP_SCREEN_OBJECT</span>
<span class="cm"> *    is present then backing stores are optional.</span>
<span class="cm"> *</span>
<span class="cm"> * SVGA_FIFO_CAP_DEAD --</span>
<span class="cm"> *</span>
<span class="cm"> *    Drivers should not use this cap bit.  This cap bit can not be</span>
<span class="cm"> *    reused since some hosts already expose it.</span>
<span class="cm"> */</span>

<span class="cp">#define SVGA_FIFO_CAP_NONE                  0</span>
<span class="cp">#define SVGA_FIFO_CAP_FENCE             (1&lt;&lt;0)</span>
<span class="cp">#define SVGA_FIFO_CAP_ACCELFRONT        (1&lt;&lt;1)</span>
<span class="cp">#define SVGA_FIFO_CAP_PITCHLOCK         (1&lt;&lt;2)</span>
<span class="cp">#define SVGA_FIFO_CAP_VIDEO             (1&lt;&lt;3)</span>
<span class="cp">#define SVGA_FIFO_CAP_CURSOR_BYPASS_3   (1&lt;&lt;4)</span>
<span class="cp">#define SVGA_FIFO_CAP_ESCAPE            (1&lt;&lt;5)</span>
<span class="cp">#define SVGA_FIFO_CAP_RESERVE           (1&lt;&lt;6)</span>
<span class="cp">#define SVGA_FIFO_CAP_SCREEN_OBJECT     (1&lt;&lt;7)</span>
<span class="cp">#define SVGA_FIFO_CAP_GMR2              (1&lt;&lt;8)</span>
<span class="cp">#define SVGA_FIFO_CAP_3D_HWVERSION_REVISED  SVGA_FIFO_CAP_GMR2</span>
<span class="cp">#define SVGA_FIFO_CAP_SCREEN_OBJECT_2   (1&lt;&lt;9)</span>
<span class="cp">#define SVGA_FIFO_CAP_DEAD              (1&lt;&lt;10)</span>


<span class="cm">/*</span>
<span class="cm"> * FIFO Flags</span>
<span class="cm"> *</span>
<span class="cm"> *      Accel Front -- Driver should use front buffer only commands</span>
<span class="cm"> */</span>

<span class="cp">#define SVGA_FIFO_FLAG_NONE                 0</span>
<span class="cp">#define SVGA_FIFO_FLAG_ACCELFRONT       (1&lt;&lt;0)</span>
<span class="cp">#define SVGA_FIFO_FLAG_RESERVED        (1&lt;&lt;31) </span><span class="cm">/* Internal use only */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * FIFO reservation sentinel value</span>
<span class="cm"> */</span>

<span class="cp">#define SVGA_FIFO_RESERVED_UNKNOWN      0xffffffff</span>


<span class="cm">/*</span>
<span class="cm"> * Video overlay support</span>
<span class="cm"> */</span>

<span class="cp">#define SVGA_NUM_OVERLAY_UNITS 32</span>


<span class="cm">/*</span>
<span class="cm"> * Video capabilities that the guest is currently using</span>
<span class="cm"> */</span>

<span class="cp">#define SVGA_VIDEO_FLAG_COLORKEY        0x0001</span>


<span class="cm">/*</span>
<span class="cm"> * Offsets for the video overlay registers</span>
<span class="cm"> */</span>

<span class="k">enum</span> <span class="p">{</span>
   <span class="n">SVGA_VIDEO_ENABLED</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
   <span class="n">SVGA_VIDEO_FLAGS</span><span class="p">,</span>
   <span class="n">SVGA_VIDEO_DATA_OFFSET</span><span class="p">,</span>
   <span class="n">SVGA_VIDEO_FORMAT</span><span class="p">,</span>
   <span class="n">SVGA_VIDEO_COLORKEY</span><span class="p">,</span>
   <span class="n">SVGA_VIDEO_SIZE</span><span class="p">,</span>          <span class="cm">/* Deprecated */</span>
   <span class="n">SVGA_VIDEO_WIDTH</span><span class="p">,</span>
   <span class="n">SVGA_VIDEO_HEIGHT</span><span class="p">,</span>
   <span class="n">SVGA_VIDEO_SRC_X</span><span class="p">,</span>
   <span class="n">SVGA_VIDEO_SRC_Y</span><span class="p">,</span>
   <span class="n">SVGA_VIDEO_SRC_WIDTH</span><span class="p">,</span>
   <span class="n">SVGA_VIDEO_SRC_HEIGHT</span><span class="p">,</span>
   <span class="n">SVGA_VIDEO_DST_X</span><span class="p">,</span>         <span class="cm">/* Signed int32 */</span>
   <span class="n">SVGA_VIDEO_DST_Y</span><span class="p">,</span>         <span class="cm">/* Signed int32 */</span>
   <span class="n">SVGA_VIDEO_DST_WIDTH</span><span class="p">,</span>
   <span class="n">SVGA_VIDEO_DST_HEIGHT</span><span class="p">,</span>
   <span class="n">SVGA_VIDEO_PITCH_1</span><span class="p">,</span>
   <span class="n">SVGA_VIDEO_PITCH_2</span><span class="p">,</span>
   <span class="n">SVGA_VIDEO_PITCH_3</span><span class="p">,</span>
   <span class="n">SVGA_VIDEO_DATA_GMRID</span><span class="p">,</span>    <span class="cm">/* Optional, defaults to SVGA_GMR_FRAMEBUFFER */</span>
   <span class="n">SVGA_VIDEO_DST_SCREEN_ID</span><span class="p">,</span> <span class="cm">/* Optional, defaults to virtual coords (SVGA_ID_INVALID) */</span>
   <span class="n">SVGA_VIDEO_NUM_REGS</span>
<span class="p">};</span>


<span class="cm">/*</span>
<span class="cm"> * SVGA Overlay Units</span>
<span class="cm"> *</span>
<span class="cm"> *      width and height relate to the entire source video frame.</span>
<span class="cm"> *      srcX, srcY, srcWidth and srcHeight represent subset of the source</span>
<span class="cm"> *      video frame to be displayed.</span>
<span class="cm"> */</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">SVGAOverlayUnit</span> <span class="p">{</span>
   <span class="n">uint32</span> <span class="n">enabled</span><span class="p">;</span>
   <span class="n">uint32</span> <span class="n">flags</span><span class="p">;</span>
   <span class="n">uint32</span> <span class="n">dataOffset</span><span class="p">;</span>
   <span class="n">uint32</span> <span class="n">format</span><span class="p">;</span>
   <span class="n">uint32</span> <span class="n">colorKey</span><span class="p">;</span>
   <span class="n">uint32</span> <span class="n">size</span><span class="p">;</span>
   <span class="n">uint32</span> <span class="n">width</span><span class="p">;</span>
   <span class="n">uint32</span> <span class="n">height</span><span class="p">;</span>
   <span class="n">uint32</span> <span class="n">srcX</span><span class="p">;</span>
   <span class="n">uint32</span> <span class="n">srcY</span><span class="p">;</span>
   <span class="n">uint32</span> <span class="n">srcWidth</span><span class="p">;</span>
   <span class="n">uint32</span> <span class="n">srcHeight</span><span class="p">;</span>
   <span class="n">int32</span>  <span class="n">dstX</span><span class="p">;</span>
   <span class="n">int32</span>  <span class="n">dstY</span><span class="p">;</span>
   <span class="n">uint32</span> <span class="n">dstWidth</span><span class="p">;</span>
   <span class="n">uint32</span> <span class="n">dstHeight</span><span class="p">;</span>
   <span class="n">uint32</span> <span class="n">pitches</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
   <span class="n">uint32</span> <span class="n">dataGMRId</span><span class="p">;</span>
   <span class="n">uint32</span> <span class="n">dstScreenId</span><span class="p">;</span>
<span class="p">}</span> <span class="n">SVGAOverlayUnit</span><span class="p">;</span>


<span class="cm">/*</span>
<span class="cm"> * SVGAScreenObject --</span>
<span class="cm"> *</span>
<span class="cm"> *    This is a new way to represent a guest&#39;s multi-monitor screen or</span>
<span class="cm"> *    Unity window. Screen objects are only supported if the</span>
<span class="cm"> *    SVGA_FIFO_CAP_SCREEN_OBJECT capability bit is set.</span>
<span class="cm"> *</span>
<span class="cm"> *    If Screen Objects are supported, they can be used to fully</span>
<span class="cm"> *    replace the functionality provided by the framebuffer registers</span>
<span class="cm"> *    (SVGA_REG_WIDTH, HEIGHT, etc.) and by SVGA_CAP_DISPLAY_TOPOLOGY.</span>
<span class="cm"> *</span>
<span class="cm"> *    The screen object is a struct with guaranteed binary</span>
<span class="cm"> *    compatibility. New flags can be added, and the struct may grow,</span>
<span class="cm"> *    but existing fields must retain their meaning.</span>
<span class="cm"> *</span>
<span class="cm"> *    Added with SVGA_FIFO_CAP_SCREEN_OBJECT_2 are required fields of</span>
<span class="cm"> *    a SVGAGuestPtr that is used to back the screen contents.  This</span>
<span class="cm"> *    memory must come from the GFB.  The guest is not allowed to</span>
<span class="cm"> *    access the memory and doing so will have undefined results.  The</span>
<span class="cm"> *    backing store is required to be page aligned and the size is</span>
<span class="cm"> *    padded to the next page boundry.  The number of pages is:</span>
<span class="cm"> *       (bytesPerLine * size.width * 4 + PAGE_SIZE - 1) / PAGE_SIZE</span>
<span class="cm"> *</span>
<span class="cm"> *    The pitch in the backingStore is required to be at least large</span>
<span class="cm"> *    enough to hold a 32bbp scanline.  It is recommended that the</span>
<span class="cm"> *    driver pad bytesPerLine for a potential performance win.</span>
<span class="cm"> *</span>
<span class="cm"> *    The cloneCount field is treated as a hint from the guest that</span>
<span class="cm"> *    the user wants this display to be cloned, countCount times.  A</span>
<span class="cm"> *    value of zero means no cloning should happen.</span>
<span class="cm"> */</span>

<span class="cp">#define SVGA_SCREEN_MUST_BE_SET     (1 &lt;&lt; 0) </span><span class="cm">/* Must be set or results undefined */</span><span class="cp"></span>
<span class="cp">#define SVGA_SCREEN_HAS_ROOT SVGA_SCREEN_MUST_BE_SET </span><span class="cm">/* Deprecated */</span><span class="cp"></span>
<span class="cp">#define SVGA_SCREEN_IS_PRIMARY      (1 &lt;&lt; 1) </span><span class="cm">/* Guest considers this screen to be &#39;primary&#39; */</span><span class="cp"></span>
<span class="cp">#define SVGA_SCREEN_FULLSCREEN_HINT (1 &lt;&lt; 2) </span><span class="cm">/* Guest is running a fullscreen app here */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Added with SVGA_FIFO_CAP_SCREEN_OBJECT_2.  When the screen is</span>
<span class="cm"> * deactivated the base layer is defined to lose all contents and</span>
<span class="cm"> * become black.  When a screen is deactivated the backing store is</span>
<span class="cm"> * optional.  When set backingPtr and bytesPerLine will be ignored.</span>
<span class="cm"> */</span>
<span class="cp">#define SVGA_SCREEN_DEACTIVATE  (1 &lt;&lt; 3)</span>

<span class="cm">/*</span>
<span class="cm"> * Added with SVGA_FIFO_CAP_SCREEN_OBJECT_2.  When this flag is set</span>
<span class="cm"> * the screen contents will be outputted as all black to the user</span>
<span class="cm"> * though the base layer contents is preserved.  The screen base layer</span>
<span class="cm"> * can still be read and written to like normal though the no visible</span>
<span class="cm"> * effect will be seen by the user.  When the flag is changed the</span>
<span class="cm"> * screen will be blanked or redrawn to the current contents as needed</span>
<span class="cm"> * without any extra commands from the driver.  This flag only has an</span>
<span class="cm"> * effect when the screen is not deactivated.</span>
<span class="cm"> */</span>
<span class="cp">#define SVGA_SCREEN_BLANKING (1 &lt;&lt; 4)</span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="n">SVGAScreenObject</span> <span class="p">{</span>
   <span class="n">uint32</span> <span class="n">structSize</span><span class="p">;</span>   <span class="cm">/* sizeof(SVGAScreenObject) */</span>
   <span class="n">uint32</span> <span class="n">id</span><span class="p">;</span>
   <span class="n">uint32</span> <span class="n">flags</span><span class="p">;</span>
   <span class="k">struct</span> <span class="p">{</span>
      <span class="n">uint32</span> <span class="n">width</span><span class="p">;</span>
      <span class="n">uint32</span> <span class="n">height</span><span class="p">;</span>
   <span class="p">}</span> <span class="n">size</span><span class="p">;</span>
   <span class="k">struct</span> <span class="p">{</span>
      <span class="n">int32</span> <span class="n">x</span><span class="p">;</span>
      <span class="n">int32</span> <span class="n">y</span><span class="p">;</span>
   <span class="p">}</span> <span class="n">root</span><span class="p">;</span>

   <span class="cm">/*</span>
<span class="cm">    * Added and required by SVGA_FIFO_CAP_SCREEN_OBJECT_2, optional</span>
<span class="cm">    * with SVGA_FIFO_CAP_SCREEN_OBJECT.</span>
<span class="cm">    */</span>
   <span class="n">SVGAGuestImage</span> <span class="n">backingStore</span><span class="p">;</span>
   <span class="n">uint32</span> <span class="n">cloneCount</span><span class="p">;</span>
<span class="p">}</span> <span class="n">SVGAScreenObject</span><span class="p">;</span>


<span class="cm">/*</span>
<span class="cm"> *  Commands in the command FIFO:</span>
<span class="cm"> *</span>
<span class="cm"> *  Command IDs defined below are used for the traditional 2D FIFO</span>
<span class="cm"> *  communication (not all commands are available for all versions of the</span>
<span class="cm"> *  SVGA FIFO protocol).</span>
<span class="cm"> *</span>
<span class="cm"> *  Note the holes in the command ID numbers: These commands have been</span>
<span class="cm"> *  deprecated, and the old IDs must not be reused.</span>
<span class="cm"> *</span>
<span class="cm"> *  Command IDs from 1000 to 1999 are reserved for use by the SVGA3D</span>
<span class="cm"> *  protocol.</span>
<span class="cm"> *</span>
<span class="cm"> *  Each command&#39;s parameters are described by the comments and</span>
<span class="cm"> *  structs below.</span>
<span class="cm"> */</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
   <span class="n">SVGA_CMD_INVALID_CMD</span>           <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
   <span class="n">SVGA_CMD_UPDATE</span>                <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
   <span class="n">SVGA_CMD_RECT_COPY</span>             <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
   <span class="n">SVGA_CMD_DEFINE_CURSOR</span>         <span class="o">=</span> <span class="mi">19</span><span class="p">,</span>
   <span class="n">SVGA_CMD_DEFINE_ALPHA_CURSOR</span>   <span class="o">=</span> <span class="mi">22</span><span class="p">,</span>
   <span class="n">SVGA_CMD_UPDATE_VERBOSE</span>        <span class="o">=</span> <span class="mi">25</span><span class="p">,</span>
   <span class="n">SVGA_CMD_FRONT_ROP_FILL</span>        <span class="o">=</span> <span class="mi">29</span><span class="p">,</span>
   <span class="n">SVGA_CMD_FENCE</span>                 <span class="o">=</span> <span class="mi">30</span><span class="p">,</span>
   <span class="n">SVGA_CMD_ESCAPE</span>                <span class="o">=</span> <span class="mi">33</span><span class="p">,</span>
   <span class="n">SVGA_CMD_DEFINE_SCREEN</span>         <span class="o">=</span> <span class="mi">34</span><span class="p">,</span>
   <span class="n">SVGA_CMD_DESTROY_SCREEN</span>        <span class="o">=</span> <span class="mi">35</span><span class="p">,</span>
   <span class="n">SVGA_CMD_DEFINE_GMRFB</span>          <span class="o">=</span> <span class="mi">36</span><span class="p">,</span>
   <span class="n">SVGA_CMD_BLIT_GMRFB_TO_SCREEN</span>  <span class="o">=</span> <span class="mi">37</span><span class="p">,</span>
   <span class="n">SVGA_CMD_BLIT_SCREEN_TO_GMRFB</span>  <span class="o">=</span> <span class="mi">38</span><span class="p">,</span>
   <span class="n">SVGA_CMD_ANNOTATION_FILL</span>       <span class="o">=</span> <span class="mi">39</span><span class="p">,</span>
   <span class="n">SVGA_CMD_ANNOTATION_COPY</span>       <span class="o">=</span> <span class="mi">40</span><span class="p">,</span>
   <span class="n">SVGA_CMD_DEFINE_GMR2</span>           <span class="o">=</span> <span class="mi">41</span><span class="p">,</span>
   <span class="n">SVGA_CMD_REMAP_GMR2</span>            <span class="o">=</span> <span class="mi">42</span><span class="p">,</span>
   <span class="n">SVGA_CMD_MAX</span>
<span class="p">}</span> <span class="n">SVGAFifoCmdId</span><span class="p">;</span>

<span class="cp">#define SVGA_CMD_MAX_ARGS           64</span>


<span class="cm">/*</span>
<span class="cm"> * SVGA_CMD_UPDATE --</span>
<span class="cm"> *</span>
<span class="cm"> *    This is a DMA transfer which copies from the Guest Framebuffer</span>
<span class="cm"> *    (GFB) at BAR1 + SVGA_REG_FB_OFFSET to any screens which</span>
<span class="cm"> *    intersect with the provided virtual rectangle.</span>
<span class="cm"> *</span>
<span class="cm"> *    This command does not support using arbitrary guest memory as a</span>
<span class="cm"> *    data source- it only works with the pre-defined GFB memory.</span>
<span class="cm"> *    This command also does not support signed virtual coordinates.</span>
<span class="cm"> *    If you have defined screens (using SVGA_CMD_DEFINE_SCREEN) with</span>
<span class="cm"> *    negative root x/y coordinates, the negative portion of those</span>
<span class="cm"> *    screens will not be reachable by this command.</span>
<span class="cm"> *</span>
<span class="cm"> *    This command is not necessary when using framebuffer</span>
<span class="cm"> *    traces. Traces are automatically enabled if the SVGA FIFO is</span>
<span class="cm"> *    disabled, and you may explicitly enable/disable traces using</span>
<span class="cm"> *    SVGA_REG_TRACES. With traces enabled, any write to the GFB will</span>
<span class="cm"> *    automatically act as if a subsequent SVGA_CMD_UPDATE was issued.</span>
<span class="cm"> *</span>
<span class="cm"> *    Traces and SVGA_CMD_UPDATE are the only supported ways to render</span>
<span class="cm"> *    pseudocolor screen updates. The newer Screen Object commands</span>
<span class="cm"> *    only support true color formats.</span>
<span class="cm"> *</span>
<span class="cm"> * Availability:</span>
<span class="cm"> *    Always available.</span>
<span class="cm"> */</span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="n">SVGAFifoCmdUpdate</span> <span class="p">{</span>
   <span class="n">uint32</span> <span class="n">x</span><span class="p">;</span>
   <span class="n">uint32</span> <span class="n">y</span><span class="p">;</span>
   <span class="n">uint32</span> <span class="n">width</span><span class="p">;</span>
   <span class="n">uint32</span> <span class="n">height</span><span class="p">;</span>
<span class="p">}</span> <span class="n">SVGAFifoCmdUpdate</span><span class="p">;</span>


<span class="cm">/*</span>
<span class="cm"> * SVGA_CMD_RECT_COPY --</span>
<span class="cm"> *</span>
<span class="cm"> *    Perform a rectangular DMA transfer from one area of the GFB to</span>
<span class="cm"> *    another, and copy the result to any screens which intersect it.</span>
<span class="cm"> *</span>
<span class="cm"> * Availability:</span>
<span class="cm"> *    SVGA_CAP_RECT_COPY</span>
<span class="cm"> */</span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="n">SVGAFifoCmdRectCopy</span> <span class="p">{</span>
   <span class="n">uint32</span> <span class="n">srcX</span><span class="p">;</span>
   <span class="n">uint32</span> <span class="n">srcY</span><span class="p">;</span>
   <span class="n">uint32</span> <span class="n">destX</span><span class="p">;</span>
   <span class="n">uint32</span> <span class="n">destY</span><span class="p">;</span>
   <span class="n">uint32</span> <span class="n">width</span><span class="p">;</span>
   <span class="n">uint32</span> <span class="n">height</span><span class="p">;</span>
<span class="p">}</span> <span class="n">SVGAFifoCmdRectCopy</span><span class="p">;</span>


<span class="cm">/*</span>
<span class="cm"> * SVGA_CMD_DEFINE_CURSOR --</span>
<span class="cm"> *</span>
<span class="cm"> *    Provide a new cursor image, as an AND/XOR mask.</span>
<span class="cm"> *</span>
<span class="cm"> *    The recommended way to position the cursor overlay is by using</span>
<span class="cm"> *    the SVGA_FIFO_CURSOR_* registers, supported by the</span>
<span class="cm"> *    SVGA_FIFO_CAP_CURSOR_BYPASS_3 capability.</span>
<span class="cm"> *</span>
<span class="cm"> * Availability:</span>
<span class="cm"> *    SVGA_CAP_CURSOR</span>
<span class="cm"> */</span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="n">SVGAFifoCmdDefineCursor</span> <span class="p">{</span>
   <span class="n">uint32</span> <span class="n">id</span><span class="p">;</span>             <span class="cm">/* Reserved, must be zero. */</span>
   <span class="n">uint32</span> <span class="n">hotspotX</span><span class="p">;</span>
   <span class="n">uint32</span> <span class="n">hotspotY</span><span class="p">;</span>
   <span class="n">uint32</span> <span class="n">width</span><span class="p">;</span>
   <span class="n">uint32</span> <span class="n">height</span><span class="p">;</span>
   <span class="n">uint32</span> <span class="n">andMaskDepth</span><span class="p">;</span>   <span class="cm">/* Value must be 1 or equal to BITS_PER_PIXEL */</span>
   <span class="n">uint32</span> <span class="n">xorMaskDepth</span><span class="p">;</span>   <span class="cm">/* Value must be 1 or equal to BITS_PER_PIXEL */</span>
   <span class="cm">/*</span>
<span class="cm">    * Followed by scanline data for AND mask, then XOR mask.</span>
<span class="cm">    * Each scanline is padded to a 32-bit boundary.</span>
<span class="cm">   */</span>
<span class="p">}</span> <span class="n">SVGAFifoCmdDefineCursor</span><span class="p">;</span>


<span class="cm">/*</span>
<span class="cm"> * SVGA_CMD_DEFINE_ALPHA_CURSOR --</span>
<span class="cm"> *</span>
<span class="cm"> *    Provide a new cursor image, in 32-bit BGRA format.</span>
<span class="cm"> *</span>
<span class="cm"> *    The recommended way to position the cursor overlay is by using</span>
<span class="cm"> *    the SVGA_FIFO_CURSOR_* registers, supported by the</span>
<span class="cm"> *    SVGA_FIFO_CAP_CURSOR_BYPASS_3 capability.</span>
<span class="cm"> *</span>
<span class="cm"> * Availability:</span>
<span class="cm"> *    SVGA_CAP_ALPHA_CURSOR</span>
<span class="cm"> */</span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="n">SVGAFifoCmdDefineAlphaCursor</span> <span class="p">{</span>
   <span class="n">uint32</span> <span class="n">id</span><span class="p">;</span>             <span class="cm">/* Reserved, must be zero. */</span>
   <span class="n">uint32</span> <span class="n">hotspotX</span><span class="p">;</span>
   <span class="n">uint32</span> <span class="n">hotspotY</span><span class="p">;</span>
   <span class="n">uint32</span> <span class="n">width</span><span class="p">;</span>
   <span class="n">uint32</span> <span class="n">height</span><span class="p">;</span>
   <span class="cm">/* Followed by scanline data */</span>
<span class="p">}</span> <span class="n">SVGAFifoCmdDefineAlphaCursor</span><span class="p">;</span>


<span class="cm">/*</span>
<span class="cm"> * SVGA_CMD_UPDATE_VERBOSE --</span>
<span class="cm"> *</span>
<span class="cm"> *    Just like SVGA_CMD_UPDATE, but also provide a per-rectangle</span>
<span class="cm"> *    &#39;reason&#39; value, an opaque cookie which is used by internal</span>
<span class="cm"> *    debugging tools. Third party drivers should not use this</span>
<span class="cm"> *    command.</span>
<span class="cm"> *</span>
<span class="cm"> * Availability:</span>
<span class="cm"> *    SVGA_CAP_EXTENDED_FIFO</span>
<span class="cm"> */</span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="n">SVGAFifoCmdUpdateVerbose</span> <span class="p">{</span>
   <span class="n">uint32</span> <span class="n">x</span><span class="p">;</span>
   <span class="n">uint32</span> <span class="n">y</span><span class="p">;</span>
   <span class="n">uint32</span> <span class="n">width</span><span class="p">;</span>
   <span class="n">uint32</span> <span class="n">height</span><span class="p">;</span>
   <span class="n">uint32</span> <span class="n">reason</span><span class="p">;</span>
<span class="p">}</span> <span class="n">SVGAFifoCmdUpdateVerbose</span><span class="p">;</span>


<span class="cm">/*</span>
<span class="cm"> * SVGA_CMD_FRONT_ROP_FILL --</span>
<span class="cm"> *</span>
<span class="cm"> *    This is a hint which tells the SVGA device that the driver has</span>
<span class="cm"> *    just filled a rectangular region of the GFB with a solid</span>
<span class="cm"> *    color. Instead of reading these pixels from the GFB, the device</span>
<span class="cm"> *    can assume that they all equal &#39;color&#39;. This is primarily used</span>
<span class="cm"> *    for remote desktop protocols.</span>
<span class="cm"> *</span>
<span class="cm"> * Availability:</span>
<span class="cm"> *    SVGA_FIFO_CAP_ACCELFRONT</span>
<span class="cm"> */</span>

<span class="cp">#define  SVGA_ROP_COPY                    0x03</span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="n">SVGAFifoCmdFrontRopFill</span> <span class="p">{</span>
   <span class="n">uint32</span> <span class="n">color</span><span class="p">;</span>     <span class="cm">/* In the same format as the GFB */</span>
   <span class="n">uint32</span> <span class="n">x</span><span class="p">;</span>
   <span class="n">uint32</span> <span class="n">y</span><span class="p">;</span>
   <span class="n">uint32</span> <span class="n">width</span><span class="p">;</span>
   <span class="n">uint32</span> <span class="n">height</span><span class="p">;</span>
   <span class="n">uint32</span> <span class="n">rop</span><span class="p">;</span>       <span class="cm">/* Must be SVGA_ROP_COPY */</span>
<span class="p">}</span> <span class="n">SVGAFifoCmdFrontRopFill</span><span class="p">;</span>


<span class="cm">/*</span>
<span class="cm"> * SVGA_CMD_FENCE --</span>
<span class="cm"> *</span>
<span class="cm"> *    Insert a synchronization fence.  When the SVGA device reaches</span>
<span class="cm"> *    this command, it will copy the &#39;fence&#39; value into the</span>
<span class="cm"> *    SVGA_FIFO_FENCE register. It will also compare the fence against</span>
<span class="cm"> *    SVGA_FIFO_FENCE_GOAL. If the fence matches the goal and the</span>
<span class="cm"> *    SVGA_IRQFLAG_FENCE_GOAL interrupt is enabled, the device will</span>
<span class="cm"> *    raise this interrupt.</span>
<span class="cm"> *</span>
<span class="cm"> * Availability:</span>
<span class="cm"> *    SVGA_FIFO_FENCE for this command,</span>
<span class="cm"> *    SVGA_CAP_IRQMASK for SVGA_FIFO_FENCE_GOAL.</span>
<span class="cm"> */</span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="p">{</span>
   <span class="n">uint32</span> <span class="n">fence</span><span class="p">;</span>
<span class="p">}</span> <span class="n">SVGAFifoCmdFence</span><span class="p">;</span>


<span class="cm">/*</span>
<span class="cm"> * SVGA_CMD_ESCAPE --</span>
<span class="cm"> *</span>
<span class="cm"> *    Send an extended or vendor-specific variable length command.</span>
<span class="cm"> *    This is used for video overlay, third party plugins, and</span>
<span class="cm"> *    internal debugging tools. See svga_escape.h</span>
<span class="cm"> *</span>
<span class="cm"> * Availability:</span>
<span class="cm"> *    SVGA_FIFO_CAP_ESCAPE</span>
<span class="cm"> */</span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="n">SVGAFifoCmdEscape</span> <span class="p">{</span>
   <span class="n">uint32</span> <span class="n">nsid</span><span class="p">;</span>
   <span class="n">uint32</span> <span class="n">size</span><span class="p">;</span>
   <span class="cm">/* followed by &#39;size&#39; bytes of data */</span>
<span class="p">}</span> <span class="n">SVGAFifoCmdEscape</span><span class="p">;</span>


<span class="cm">/*</span>
<span class="cm"> * SVGA_CMD_DEFINE_SCREEN --</span>
<span class="cm"> *</span>
<span class="cm"> *    Define or redefine an SVGAScreenObject. See the description of</span>
<span class="cm"> *    SVGAScreenObject above.  The video driver is responsible for</span>
<span class="cm"> *    generating new screen IDs. They should be small positive</span>
<span class="cm"> *    integers. The virtual device will have an implementation</span>
<span class="cm"> *    specific upper limit on the number of screen IDs</span>
<span class="cm"> *    supported. Drivers are responsible for recycling IDs. The first</span>
<span class="cm"> *    valid ID is zero.</span>
<span class="cm"> *</span>
<span class="cm"> *    - Interaction with other registers:</span>
<span class="cm"> *</span>
<span class="cm"> *    For backwards compatibility, when the GFB mode registers (WIDTH,</span>
<span class="cm"> *    HEIGHT, PITCHLOCK, BITS_PER_PIXEL) are modified, the SVGA device</span>
<span class="cm"> *    deletes all screens other than screen #0, and redefines screen</span>
<span class="cm"> *    #0 according to the specified mode. Drivers that use</span>
<span class="cm"> *    SVGA_CMD_DEFINE_SCREEN should destroy or redefine screen #0.</span>
<span class="cm"> *</span>
<span class="cm"> *    If you use screen objects, do not use the legacy multi-mon</span>
<span class="cm"> *    registers (SVGA_REG_NUM_GUEST_DISPLAYS, SVGA_REG_DISPLAY_*).</span>
<span class="cm"> *</span>
<span class="cm"> * Availability:</span>
<span class="cm"> *    SVGA_FIFO_CAP_SCREEN_OBJECT or SVGA_FIFO_CAP_SCREEN_OBJECT_2</span>
<span class="cm"> */</span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="p">{</span>
   <span class="n">SVGAScreenObject</span> <span class="n">screen</span><span class="p">;</span>   <span class="cm">/* Variable-length according to version */</span>
<span class="p">}</span> <span class="n">SVGAFifoCmdDefineScreen</span><span class="p">;</span>


<span class="cm">/*</span>
<span class="cm"> * SVGA_CMD_DESTROY_SCREEN --</span>
<span class="cm"> *</span>
<span class="cm"> *    Destroy an SVGAScreenObject. Its ID is immediately available for</span>
<span class="cm"> *    re-use.</span>
<span class="cm"> *</span>
<span class="cm"> * Availability:</span>
<span class="cm"> *    SVGA_FIFO_CAP_SCREEN_OBJECT or SVGA_FIFO_CAP_SCREEN_OBJECT_2</span>
<span class="cm"> */</span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="p">{</span>
   <span class="n">uint32</span> <span class="n">screenId</span><span class="p">;</span>
<span class="p">}</span> <span class="n">SVGAFifoCmdDestroyScreen</span><span class="p">;</span>


<span class="cm">/*</span>
<span class="cm"> * SVGA_CMD_DEFINE_GMRFB --</span>
<span class="cm"> *</span>
<span class="cm"> *    This command sets a piece of SVGA device state called the</span>
<span class="cm"> *    Guest Memory Region Framebuffer, or GMRFB. The GMRFB is a</span>
<span class="cm"> *    piece of light-weight state which identifies the location and</span>
<span class="cm"> *    format of an image in guest memory or in BAR1. The GMRFB has</span>
<span class="cm"> *    an arbitrary size, and it doesn&#39;t need to match the geometry</span>
<span class="cm"> *    of the GFB or any screen object.</span>
<span class="cm"> *</span>
<span class="cm"> *    The GMRFB can be redefined as often as you like. You could</span>
<span class="cm"> *    always use the same GMRFB, you could redefine it before</span>
<span class="cm"> *    rendering from a different guest screen, or you could even</span>
<span class="cm"> *    redefine it before every blit.</span>
<span class="cm"> *</span>
<span class="cm"> *    There are multiple ways to use this command. The simplest way is</span>
<span class="cm"> *    to use it to move the framebuffer either to elsewhere in the GFB</span>
<span class="cm"> *    (BAR1) memory region, or to a user-defined GMR. This lets a</span>
<span class="cm"> *    driver use a framebuffer allocated entirely out of normal system</span>
<span class="cm"> *    memory, which we encourage.</span>
<span class="cm"> *</span>
<span class="cm"> *    Another way to use this command is to set up a ring buffer of</span>
<span class="cm"> *    updates in GFB memory. If a driver wants to ensure that no</span>
<span class="cm"> *    frames are skipped by the SVGA device, it is important that the</span>
<span class="cm"> *    driver not modify the source data for a blit until the device is</span>
<span class="cm"> *    done processing the command. One efficient way to accomplish</span>
<span class="cm"> *    this is to use a ring of small DMA buffers. Each buffer is used</span>
<span class="cm"> *    for one blit, then we move on to the next buffer in the</span>
<span class="cm"> *    ring. The FENCE mechanism is used to protect each buffer from</span>
<span class="cm"> *    re-use until the device is finished with that buffer&#39;s</span>
<span class="cm"> *    corresponding blit.</span>
<span class="cm"> *</span>
<span class="cm"> *    This command does not affect the meaning of SVGA_CMD_UPDATE.</span>
<span class="cm"> *    UPDATEs always occur from the legacy GFB memory area. This</span>
<span class="cm"> *    command has no support for pseudocolor GMRFBs. Currently only</span>
<span class="cm"> *    true-color 15, 16, and 24-bit depths are supported. Future</span>
<span class="cm"> *    devices may expose capabilities for additional framebuffer</span>
<span class="cm"> *    formats.</span>
<span class="cm"> *</span>
<span class="cm"> *    The default GMRFB value is undefined. Drivers must always send</span>
<span class="cm"> *    this command at least once before performing any blit from the</span>
<span class="cm"> *    GMRFB.</span>
<span class="cm"> *</span>
<span class="cm"> * Availability:</span>
<span class="cm"> *    SVGA_FIFO_CAP_SCREEN_OBJECT or SVGA_FIFO_CAP_SCREEN_OBJECT_2</span>
<span class="cm"> */</span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="p">{</span>
   <span class="n">SVGAGuestPtr</span>        <span class="n">ptr</span><span class="p">;</span>
   <span class="n">uint32</span>              <span class="n">bytesPerLine</span><span class="p">;</span>
   <span class="n">SVGAGMRImageFormat</span>  <span class="n">format</span><span class="p">;</span>
<span class="p">}</span> <span class="n">SVGAFifoCmdDefineGMRFB</span><span class="p">;</span>


<span class="cm">/*</span>
<span class="cm"> * SVGA_CMD_BLIT_GMRFB_TO_SCREEN --</span>
<span class="cm"> *</span>
<span class="cm"> *    This is a guest-to-host blit. It performs a DMA operation to</span>
<span class="cm"> *    copy a rectangular region of pixels from the current GMRFB to</span>
<span class="cm"> *    one or more Screen Objects.</span>
<span class="cm"> *</span>
<span class="cm"> *    The destination coordinate may be specified relative to a</span>
<span class="cm"> *    screen&#39;s origin (if a screen ID is specified) or relative to the</span>
<span class="cm"> *    virtual coordinate system&#39;s origin (if the screen ID is</span>
<span class="cm"> *    SVGA_ID_INVALID). The actual destination may span zero or more</span>
<span class="cm"> *    screens, in the case of a virtual destination rect or a rect</span>
<span class="cm"> *    which extends off the edge of the specified screen.</span>
<span class="cm"> *</span>
<span class="cm"> *    This command writes to the screen&#39;s &quot;base layer&quot;: the underlying</span>
<span class="cm"> *    framebuffer which exists below any cursor or video overlays. No</span>
<span class="cm"> *    action is necessary to explicitly hide or update any overlays</span>
<span class="cm"> *    which exist on top of the updated region.</span>
<span class="cm"> *</span>
<span class="cm"> *    The SVGA device is guaranteed to finish reading from the GMRFB</span>
<span class="cm"> *    by the time any subsequent FENCE commands are reached.</span>
<span class="cm"> *</span>
<span class="cm"> *    This command consumes an annotation. See the</span>
<span class="cm"> *    SVGA_CMD_ANNOTATION_* commands for details.</span>
<span class="cm"> *</span>
<span class="cm"> * Availability:</span>
<span class="cm"> *    SVGA_FIFO_CAP_SCREEN_OBJECT or SVGA_FIFO_CAP_SCREEN_OBJECT_2</span>
<span class="cm"> */</span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="p">{</span>
   <span class="n">SVGASignedPoint</span>  <span class="n">srcOrigin</span><span class="p">;</span>
   <span class="n">SVGASignedRect</span>   <span class="n">destRect</span><span class="p">;</span>
   <span class="n">uint32</span>           <span class="n">destScreenId</span><span class="p">;</span>
<span class="p">}</span> <span class="n">SVGAFifoCmdBlitGMRFBToScreen</span><span class="p">;</span>


<span class="cm">/*</span>
<span class="cm"> * SVGA_CMD_BLIT_SCREEN_TO_GMRFB --</span>
<span class="cm"> *</span>
<span class="cm"> *    This is a host-to-guest blit. It performs a DMA operation to</span>
<span class="cm"> *    copy a rectangular region of pixels from a single Screen Object</span>
<span class="cm"> *    back to the current GMRFB.</span>
<span class="cm"> *</span>
<span class="cm"> *    Usage note: This command should be used rarely. It will</span>
<span class="cm"> *    typically be inefficient, but it is necessary for some types of</span>
<span class="cm"> *    synchronization between 3D (GPU) and 2D (CPU) rendering into</span>
<span class="cm"> *    overlapping areas of a screen.</span>
<span class="cm"> *</span>
<span class="cm"> *    The source coordinate is specified relative to a screen&#39;s</span>
<span class="cm"> *    origin. The provided screen ID must be valid. If any parameters</span>
<span class="cm"> *    are invalid, the resulting pixel values are undefined.</span>
<span class="cm"> *</span>
<span class="cm"> *    This command reads the screen&#39;s &quot;base layer&quot;. Overlays like</span>
<span class="cm"> *    video and cursor are not included, but any data which was sent</span>
<span class="cm"> *    using a blit-to-screen primitive will be available, no matter</span>
<span class="cm"> *    whether the data&#39;s original source was the GMRFB or the 3D</span>
<span class="cm"> *    acceleration hardware.</span>
<span class="cm"> *</span>
<span class="cm"> *    Note that our guest-to-host blits and host-to-guest blits aren&#39;t</span>
<span class="cm"> *    symmetric in their current implementation. While the parameters</span>
<span class="cm"> *    are identical, host-to-guest blits are a lot less featureful.</span>
<span class="cm"> *    They do not support clipping: If the source parameters don&#39;t</span>
<span class="cm"> *    fully fit within a screen, the blit fails. They must originate</span>
<span class="cm"> *    from exactly one screen. Virtual coordinates are not directly</span>
<span class="cm"> *    supported.</span>
<span class="cm"> *</span>
<span class="cm"> *    Host-to-guest blits do support the same set of GMRFB formats</span>
<span class="cm"> *    offered by guest-to-host blits.</span>
<span class="cm"> *</span>
<span class="cm"> *    The SVGA device is guaranteed to finish writing to the GMRFB by</span>
<span class="cm"> *    the time any subsequent FENCE commands are reached.</span>
<span class="cm"> *</span>
<span class="cm"> * Availability:</span>
<span class="cm"> *    SVGA_FIFO_CAP_SCREEN_OBJECT or SVGA_FIFO_CAP_SCREEN_OBJECT_2</span>
<span class="cm"> */</span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="p">{</span>
   <span class="n">SVGASignedPoint</span>  <span class="n">destOrigin</span><span class="p">;</span>
   <span class="n">SVGASignedRect</span>   <span class="n">srcRect</span><span class="p">;</span>
   <span class="n">uint32</span>           <span class="n">srcScreenId</span><span class="p">;</span>
<span class="p">}</span> <span class="n">SVGAFifoCmdBlitScreenToGMRFB</span><span class="p">;</span>


<span class="cm">/*</span>
<span class="cm"> * SVGA_CMD_ANNOTATION_FILL --</span>
<span class="cm"> *</span>
<span class="cm"> *    This is a blit annotation. This command stores a small piece of</span>
<span class="cm"> *    device state which is consumed by the next blit-to-screen</span>
<span class="cm"> *    command. The state is only cleared by commands which are</span>
<span class="cm"> *    specifically documented as consuming an annotation. Other</span>
<span class="cm"> *    commands (such as ESCAPEs for debugging) may intervene between</span>
<span class="cm"> *    the annotation and its associated blit.</span>
<span class="cm"> *</span>
<span class="cm"> *    This annotation is a promise about the contents of the next</span>
<span class="cm"> *    blit: The video driver is guaranteeing that all pixels in that</span>
<span class="cm"> *    blit will have the same value, specified here as a color in</span>
<span class="cm"> *    SVGAColorBGRX format.</span>
<span class="cm"> *</span>
<span class="cm"> *    The SVGA device can still render the blit correctly even if it</span>
<span class="cm"> *    ignores this annotation, but the annotation may allow it to</span>
<span class="cm"> *    perform the blit more efficiently, for example by ignoring the</span>
<span class="cm"> *    source data and performing a fill in hardware.</span>
<span class="cm"> *</span>
<span class="cm"> *    This annotation is most important for performance when the</span>
<span class="cm"> *    user&#39;s display is being remoted over a network connection.</span>
<span class="cm"> *</span>
<span class="cm"> * Availability:</span>
<span class="cm"> *    SVGA_FIFO_CAP_SCREEN_OBJECT or SVGA_FIFO_CAP_SCREEN_OBJECT_2</span>
<span class="cm"> */</span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="p">{</span>
   <span class="n">SVGAColorBGRX</span>  <span class="n">color</span><span class="p">;</span>
<span class="p">}</span> <span class="n">SVGAFifoCmdAnnotationFill</span><span class="p">;</span>


<span class="cm">/*</span>
<span class="cm"> * SVGA_CMD_ANNOTATION_COPY --</span>
<span class="cm"> *</span>
<span class="cm"> *    This is a blit annotation. See SVGA_CMD_ANNOTATION_FILL for more</span>
<span class="cm"> *    information about annotations.</span>
<span class="cm"> *</span>
<span class="cm"> *    This annotation is a promise about the contents of the next</span>
<span class="cm"> *    blit: The video driver is guaranteeing that all pixels in that</span>
<span class="cm"> *    blit will have the same value as those which already exist at an</span>
<span class="cm"> *    identically-sized region on the same or a different screen.</span>
<span class="cm"> *</span>
<span class="cm"> *    Note that the source pixels for the COPY in this annotation are</span>
<span class="cm"> *    sampled before applying the anqnotation&#39;s associated blit. They</span>
<span class="cm"> *    are allowed to overlap with the blit&#39;s destination pixels.</span>
<span class="cm"> *</span>
<span class="cm"> *    The copy source rectangle is specified the same way as the blit</span>
<span class="cm"> *    destination: it can be a rectangle which spans zero or more</span>
<span class="cm"> *    screens, specified relative to either a screen or to the virtual</span>
<span class="cm"> *    coordinate system&#39;s origin. If the source rectangle includes</span>
<span class="cm"> *    pixels which are not from exactly one screen, the results are</span>
<span class="cm"> *    undefined.</span>
<span class="cm"> *</span>
<span class="cm"> * Availability:</span>
<span class="cm"> *    SVGA_FIFO_CAP_SCREEN_OBJECT or SVGA_FIFO_CAP_SCREEN_OBJECT_2</span>
<span class="cm"> */</span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="p">{</span>
   <span class="n">SVGASignedPoint</span>  <span class="n">srcOrigin</span><span class="p">;</span>
   <span class="n">uint32</span>           <span class="n">srcScreenId</span><span class="p">;</span>
<span class="p">}</span> <span class="n">SVGAFifoCmdAnnotationCopy</span><span class="p">;</span>


<span class="cm">/*</span>
<span class="cm"> * SVGA_CMD_DEFINE_GMR2 --</span>
<span class="cm"> *</span>
<span class="cm"> *    Define guest memory region v2.  See the description of GMRs above.</span>
<span class="cm"> *</span>
<span class="cm"> * Availability:</span>
<span class="cm"> *    SVGA_CAP_GMR2</span>
<span class="cm"> */</span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="p">{</span>
   <span class="n">uint32</span> <span class="n">gmrId</span><span class="p">;</span>
   <span class="n">uint32</span> <span class="n">numPages</span><span class="p">;</span>
<span class="p">}</span> <span class="n">SVGAFifoCmdDefineGMR2</span><span class="p">;</span>


<span class="cm">/*</span>
<span class="cm"> * SVGA_CMD_REMAP_GMR2 --</span>
<span class="cm"> *</span>
<span class="cm"> *    Remap guest memory region v2.  See the description of GMRs above.</span>
<span class="cm"> *</span>
<span class="cm"> *    This command allows guest to modify a portion of an existing GMR by</span>
<span class="cm"> *    invalidating it or reassigning it to different guest physical pages.</span>
<span class="cm"> *    The pages are identified by physical page number (PPN).  The pages</span>
<span class="cm"> *    are assumed to be pinned and valid for DMA operations.</span>
<span class="cm"> *</span>
<span class="cm"> *    Description of command flags:</span>
<span class="cm"> *</span>
<span class="cm"> *    SVGA_REMAP_GMR2_VIA_GMR: If enabled, references a PPN list in a GMR.</span>
<span class="cm"> *       The PPN list must not overlap with the remap region (this can be</span>
<span class="cm"> *       handled trivially by referencing a separate GMR).  If flag is</span>
<span class="cm"> *       disabled, PPN list is appended to SVGARemapGMR command.</span>
<span class="cm"> *</span>
<span class="cm"> *    SVGA_REMAP_GMR2_PPN64: If set, PPN list is in PPN64 format, otherwise</span>
<span class="cm"> *       it is in PPN32 format.</span>
<span class="cm"> *</span>
<span class="cm"> *    SVGA_REMAP_GMR2_SINGLE_PPN: If set, PPN list contains a single entry.</span>
<span class="cm"> *       A single PPN can be used to invalidate a portion of a GMR or</span>
<span class="cm"> *       map it to to a single guest scratch page.</span>
<span class="cm"> *</span>
<span class="cm"> * Availability:</span>
<span class="cm"> *    SVGA_CAP_GMR2</span>
<span class="cm"> */</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
   <span class="n">SVGA_REMAP_GMR2_PPN32</span>         <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
   <span class="n">SVGA_REMAP_GMR2_VIA_GMR</span>       <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">),</span>
   <span class="n">SVGA_REMAP_GMR2_PPN64</span>         <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span>
   <span class="n">SVGA_REMAP_GMR2_SINGLE_PPN</span>    <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">),</span>
<span class="p">}</span> <span class="n">SVGARemapGMR2Flags</span><span class="p">;</span>

<span class="k">typedef</span>
<span class="k">struct</span> <span class="p">{</span>
   <span class="n">uint32</span> <span class="n">gmrId</span><span class="p">;</span>
   <span class="n">SVGARemapGMR2Flags</span> <span class="n">flags</span><span class="p">;</span>
   <span class="n">uint32</span> <span class="n">offsetPages</span><span class="p">;</span> <span class="cm">/* offset in pages to begin remap */</span>
   <span class="n">uint32</span> <span class="n">numPages</span><span class="p">;</span> <span class="cm">/* number of pages to remap */</span>
   <span class="cm">/*</span>
<span class="cm">    * Followed by additional data depending on SVGARemapGMR2Flags.</span>
<span class="cm">    *</span>
<span class="cm">    * If flag SVGA_REMAP_GMR2_VIA_GMR is set, single SVGAGuestPtr follows.</span>
<span class="cm">    * Otherwise an array of page descriptors in PPN32 or PPN64 format</span>
<span class="cm">    * (according to flag SVGA_REMAP_GMR2_PPN64) follows.  If flag</span>
<span class="cm">    * SVGA_REMAP_GMR2_SINGLE_PPN is set, array contains a single entry.</span>
<span class="cm">    */</span>
<span class="p">}</span> <span class="n">SVGAFifoCmdRemapGMR2</span><span class="p">;</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
