<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › gpu › drm › drm_edid.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>drm_edid.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (c) 2006 Luc Verhaegen (quirks list)</span>
<span class="cm"> * Copyright (c) 2007-2008 Intel Corporation</span>
<span class="cm"> *   Jesse Barnes &lt;jesse.barnes@intel.com&gt;</span>
<span class="cm"> * Copyright 2010 Red Hat, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * DDC probing routines (drm_ddc_read &amp; drm_do_probe_ddc_edid) originally from</span>
<span class="cm"> * FB layer.</span>
<span class="cm"> *   Copyright (C) 2006 Dennis Munsie &lt;dmunsie@cecropia.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Permission is hereby granted, free of charge, to any person obtaining a</span>
<span class="cm"> * copy of this software and associated documentation files (the &quot;Software&quot;),</span>
<span class="cm"> * to deal in the Software without restriction, including without limitation</span>
<span class="cm"> * the rights to use, copy, modify, merge, publish, distribute, sub license,</span>
<span class="cm"> * and/or sell copies of the Software, and to permit persons to whom the</span>
<span class="cm"> * Software is furnished to do so, subject to the following conditions:</span>
<span class="cm"> *</span>
<span class="cm"> * The above copyright notice and this permission notice (including the</span>
<span class="cm"> * next paragraph) shall be included in all copies or substantial portions</span>
<span class="cm"> * of the Software.</span>
<span class="cm"> *</span>
<span class="cm"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span>
<span class="cm"> * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL</span>
<span class="cm"> * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span>
<span class="cm"> * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING</span>
<span class="cm"> * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER</span>
<span class="cm"> * DEALINGS IN THE SOFTWARE.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/i2c.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &quot;drmP.h&quot;</span>
<span class="cp">#include &quot;drm_edid.h&quot;</span>
<span class="cp">#include &quot;drm_edid_modes.h&quot;</span>

<span class="cp">#define version_greater(edid, maj, min) \</span>
<span class="cp">	(((edid)-&gt;version &gt; (maj)) || \</span>
<span class="cp">	 ((edid)-&gt;version == (maj) &amp;&amp; (edid)-&gt;revision &gt; (min)))</span>

<span class="cp">#define EDID_EST_TIMINGS 16</span>
<span class="cp">#define EDID_STD_TIMINGS 8</span>
<span class="cp">#define EDID_DETAILED_TIMINGS 4</span>

<span class="cm">/*</span>
<span class="cm"> * EDID blocks out in the wild have a variety of bugs, try to collect</span>
<span class="cm"> * them here (note that userspace may work around broken monitors first,</span>
<span class="cm"> * but fixes should make their way here so that the kernel &quot;just works&quot;</span>
<span class="cm"> * on as many displays as possible).</span>
<span class="cm"> */</span>

<span class="cm">/* First detailed mode wrong, use largest 60Hz mode */</span>
<span class="cp">#define EDID_QUIRK_PREFER_LARGE_60		(1 &lt;&lt; 0)</span>
<span class="cm">/* Reported 135MHz pixel clock is too high, needs adjustment */</span>
<span class="cp">#define EDID_QUIRK_135_CLOCK_TOO_HIGH		(1 &lt;&lt; 1)</span>
<span class="cm">/* Prefer the largest mode at 75 Hz */</span>
<span class="cp">#define EDID_QUIRK_PREFER_LARGE_75		(1 &lt;&lt; 2)</span>
<span class="cm">/* Detail timing is in cm not mm */</span>
<span class="cp">#define EDID_QUIRK_DETAILED_IN_CM		(1 &lt;&lt; 3)</span>
<span class="cm">/* Detailed timing descriptors have bogus size values, so just take the</span>
<span class="cm"> * maximum size and use that.</span>
<span class="cm"> */</span>
<span class="cp">#define EDID_QUIRK_DETAILED_USE_MAXIMUM_SIZE	(1 &lt;&lt; 4)</span>
<span class="cm">/* Monitor forgot to set the first detailed is preferred bit. */</span>
<span class="cp">#define EDID_QUIRK_FIRST_DETAILED_PREFERRED	(1 &lt;&lt; 5)</span>
<span class="cm">/* use +hsync +vsync for detailed mode */</span>
<span class="cp">#define EDID_QUIRK_DETAILED_SYNC_PP		(1 &lt;&lt; 6)</span>
<span class="cm">/* Force reduced-blanking timings for detailed modes */</span>
<span class="cp">#define EDID_QUIRK_FORCE_REDUCED_BLANKING	(1 &lt;&lt; 7)</span>

<span class="k">struct</span> <span class="n">detailed_mode_closure</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_connector</span> <span class="o">*</span><span class="n">connector</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">edid</span> <span class="o">*</span><span class="n">edid</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">preferred</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">quirks</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">modes</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define LEVEL_DMT	0</span>
<span class="cp">#define LEVEL_GTF	1</span>
<span class="cp">#define LEVEL_GTF2	2</span>
<span class="cp">#define LEVEL_CVT	3</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">edid_quirk</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="n">vendor</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">product_id</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">quirks</span><span class="p">;</span>
<span class="p">}</span> <span class="n">edid_quirk_list</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="cm">/* Acer AL1706 */</span>
	<span class="p">{</span> <span class="s">&quot;ACR&quot;</span><span class="p">,</span> <span class="mi">44358</span><span class="p">,</span> <span class="n">EDID_QUIRK_PREFER_LARGE_60</span> <span class="p">},</span>
	<span class="cm">/* Acer F51 */</span>
	<span class="p">{</span> <span class="s">&quot;API&quot;</span><span class="p">,</span> <span class="mh">0x7602</span><span class="p">,</span> <span class="n">EDID_QUIRK_PREFER_LARGE_60</span> <span class="p">},</span>
	<span class="cm">/* Unknown Acer */</span>
	<span class="p">{</span> <span class="s">&quot;ACR&quot;</span><span class="p">,</span> <span class="mi">2423</span><span class="p">,</span> <span class="n">EDID_QUIRK_FIRST_DETAILED_PREFERRED</span> <span class="p">},</span>

	<span class="cm">/* Belinea 10 15 55 */</span>
	<span class="p">{</span> <span class="s">&quot;MAX&quot;</span><span class="p">,</span> <span class="mi">1516</span><span class="p">,</span> <span class="n">EDID_QUIRK_PREFER_LARGE_60</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;MAX&quot;</span><span class="p">,</span> <span class="mh">0x77e</span><span class="p">,</span> <span class="n">EDID_QUIRK_PREFER_LARGE_60</span> <span class="p">},</span>

	<span class="cm">/* Envision Peripherals, Inc. EN-7100e */</span>
	<span class="p">{</span> <span class="s">&quot;EPI&quot;</span><span class="p">,</span> <span class="mi">59264</span><span class="p">,</span> <span class="n">EDID_QUIRK_135_CLOCK_TOO_HIGH</span> <span class="p">},</span>
	<span class="cm">/* Envision EN2028 */</span>
	<span class="p">{</span> <span class="s">&quot;EPI&quot;</span><span class="p">,</span> <span class="mi">8232</span><span class="p">,</span> <span class="n">EDID_QUIRK_PREFER_LARGE_60</span> <span class="p">},</span>

	<span class="cm">/* Funai Electronics PM36B */</span>
	<span class="p">{</span> <span class="s">&quot;FCM&quot;</span><span class="p">,</span> <span class="mi">13600</span><span class="p">,</span> <span class="n">EDID_QUIRK_PREFER_LARGE_75</span> <span class="o">|</span>
	  <span class="n">EDID_QUIRK_DETAILED_IN_CM</span> <span class="p">},</span>

	<span class="cm">/* LG Philips LCD LP154W01-A5 */</span>
	<span class="p">{</span> <span class="s">&quot;LPL&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">EDID_QUIRK_DETAILED_USE_MAXIMUM_SIZE</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;LPL&quot;</span><span class="p">,</span> <span class="mh">0x2a00</span><span class="p">,</span> <span class="n">EDID_QUIRK_DETAILED_USE_MAXIMUM_SIZE</span> <span class="p">},</span>

	<span class="cm">/* Philips 107p5 CRT */</span>
	<span class="p">{</span> <span class="s">&quot;PHL&quot;</span><span class="p">,</span> <span class="mi">57364</span><span class="p">,</span> <span class="n">EDID_QUIRK_FIRST_DETAILED_PREFERRED</span> <span class="p">},</span>

	<span class="cm">/* Proview AY765C */</span>
	<span class="p">{</span> <span class="s">&quot;PTS&quot;</span><span class="p">,</span> <span class="mi">765</span><span class="p">,</span> <span class="n">EDID_QUIRK_FIRST_DETAILED_PREFERRED</span> <span class="p">},</span>

	<span class="cm">/* Samsung SyncMaster 205BW.  Note: irony */</span>
	<span class="p">{</span> <span class="s">&quot;SAM&quot;</span><span class="p">,</span> <span class="mi">541</span><span class="p">,</span> <span class="n">EDID_QUIRK_DETAILED_SYNC_PP</span> <span class="p">},</span>
	<span class="cm">/* Samsung SyncMaster 22[5-6]BW */</span>
	<span class="p">{</span> <span class="s">&quot;SAM&quot;</span><span class="p">,</span> <span class="mi">596</span><span class="p">,</span> <span class="n">EDID_QUIRK_PREFER_LARGE_60</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;SAM&quot;</span><span class="p">,</span> <span class="mi">638</span><span class="p">,</span> <span class="n">EDID_QUIRK_PREFER_LARGE_60</span> <span class="p">},</span>

	<span class="cm">/* ViewSonic VA2026w */</span>
	<span class="p">{</span> <span class="s">&quot;VSC&quot;</span><span class="p">,</span> <span class="mi">5020</span><span class="p">,</span> <span class="n">EDID_QUIRK_FORCE_REDUCED_BLANKING</span> <span class="p">},</span>
<span class="p">};</span>

<span class="cm">/*** DDC fetch and block validation ***/</span>

<span class="k">static</span> <span class="k">const</span> <span class="n">u8</span> <span class="n">edid_header</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="mh">0x00</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="mh">0x00</span>
<span class="p">};</span>

 <span class="cm">/*</span>
<span class="cm"> * Sanity check the header of the base EDID block.  Return 8 if the header</span>
<span class="cm"> * is perfect, down to 0 if it&#39;s totally wrong.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">drm_edid_header_is_valid</span><span class="p">(</span><span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">raw_edid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">score</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">edid_header</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">raw_edid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">edid_header</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="n">score</span><span class="o">++</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">score</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">drm_edid_header_is_valid</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">edid_fixup</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
<span class="n">module_param_named</span><span class="p">(</span><span class="n">edid_fixup</span><span class="p">,</span> <span class="n">edid_fixup</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0400</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">edid_fixup</span><span class="p">,</span>
		 <span class="s">&quot;Minimum number of valid EDID header bytes (0-8, default 6)&quot;</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Sanity check the EDID block (base or extension).  Return 0 if the block</span>
<span class="cm"> * doesn&#39;t check out, or 1 if it&#39;s valid.</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="nf">drm_edid_block_valid</span><span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="n">raw_edid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">csum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">edid</span> <span class="o">*</span><span class="n">edid</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">edid</span> <span class="o">*</span><span class="p">)</span><span class="n">raw_edid</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">edid_fixup</span> <span class="o">&gt;</span> <span class="mi">8</span> <span class="o">||</span> <span class="n">edid_fixup</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">edid_fixup</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">block</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">score</span> <span class="o">=</span> <span class="n">drm_edid_header_is_valid</span><span class="p">(</span><span class="n">raw_edid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">score</span> <span class="o">==</span> <span class="mi">8</span><span class="p">)</span> <span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">score</span> <span class="o">&gt;=</span> <span class="n">edid_fixup</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DRM_DEBUG</span><span class="p">(</span><span class="s">&quot;Fixing EDID header, your hardware may be failing</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">raw_edid</span><span class="p">,</span> <span class="n">edid_header</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">edid_header</span><span class="p">));</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">EDID_LENGTH</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">csum</span> <span class="o">+=</span> <span class="n">raw_edid</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">csum</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DRM_ERROR</span><span class="p">(</span><span class="s">&quot;EDID checksum is invalid, remainder is %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">csum</span><span class="p">);</span>

		<span class="cm">/* allow CEA to slide through, switches mangle this */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">raw_edid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mh">0x02</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* per-block-type checks */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">raw_edid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>: <span class="cm">/* base */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">edid</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DRM_ERROR</span><span class="p">(</span><span class="s">&quot;EDID has major version %d, instead of 1</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">edid</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">edid</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">)</span>
			<span class="n">DRM_DEBUG</span><span class="p">(</span><span class="s">&quot;EDID minor &gt; 4, assuming backward compatibility</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

<span class="nl">bad:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">raw_edid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Raw EDID:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">print_hex_dump</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="s">&quot; </span><span class="se">\t</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">DUMP_PREFIX_NONE</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
			       <span class="n">raw_edid</span><span class="p">,</span> <span class="n">EDID_LENGTH</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">drm_edid_block_valid</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * drm_edid_is_valid - sanity check EDID data</span>
<span class="cm"> * @edid: EDID data</span>
<span class="cm"> *</span>
<span class="cm"> * Sanity-check an entire EDID record (including extensions)</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="nf">drm_edid_is_valid</span><span class="p">(</span><span class="k">struct</span> <span class="n">edid</span> <span class="o">*</span><span class="n">edid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">raw</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">edid</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">edid</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">edid</span><span class="o">-&gt;</span><span class="n">extensions</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">drm_edid_block_valid</span><span class="p">(</span><span class="n">raw</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">EDID_LENGTH</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">drm_edid_is_valid</span><span class="p">);</span>

<span class="cp">#define DDC_SEGMENT_ADDR 0x30</span>
<span class="cm">/**</span>
<span class="cm"> * Get EDID information via I2C.</span>
<span class="cm"> *</span>
<span class="cm"> * \param adapter : i2c device adaptor</span>
<span class="cm"> * \param buf     : EDID data buffer to be filled</span>
<span class="cm"> * \param len     : EDID data buffer length</span>
<span class="cm"> * \return 0 on success or -1 on failure.</span>
<span class="cm"> *</span>
<span class="cm"> * Try to fetch EDID information by calling i2c driver function.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">drm_do_probe_ddc_edid</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
		      <span class="kt">int</span> <span class="n">block</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">start</span> <span class="o">=</span> <span class="n">block</span> <span class="o">*</span> <span class="n">EDID_LENGTH</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">retries</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>

	<span class="cm">/* The core i2c driver will automatically retry the transfer if the</span>
<span class="cm">	 * adapter reports EAGAIN. However, we find that bit-banging transfers</span>
<span class="cm">	 * are susceptible to errors under a heavily loaded machine and</span>
<span class="cm">	 * generate spurious NAKs and timeouts. Retrying the transfer</span>
<span class="cm">	 * of the individual block a few times seems to overcome this.</span>
<span class="cm">	 */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">i2c_msg</span> <span class="n">msgs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
			<span class="p">{</span>
				<span class="p">.</span><span class="n">addr</span>	<span class="o">=</span> <span class="n">DDC_ADDR</span><span class="p">,</span>
				<span class="p">.</span><span class="n">flags</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
				<span class="p">.</span><span class="n">len</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
				<span class="p">.</span><span class="n">buf</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">start</span><span class="p">,</span>
			<span class="p">},</span> <span class="p">{</span>
				<span class="p">.</span><span class="n">addr</span>	<span class="o">=</span> <span class="n">DDC_ADDR</span><span class="p">,</span>
				<span class="p">.</span><span class="n">flags</span>	<span class="o">=</span> <span class="n">I2C_M_RD</span><span class="p">,</span>
				<span class="p">.</span><span class="n">len</span>	<span class="o">=</span> <span class="n">len</span><span class="p">,</span>
				<span class="p">.</span><span class="n">buf</span>	<span class="o">=</span> <span class="n">buf</span><span class="p">,</span>
			<span class="p">}</span>
		<span class="p">};</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">i2c_transfer</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">msgs</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DRM_DEBUG_KMS</span><span class="p">(</span><span class="s">&quot;drm: skipping non-existent adapter %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="o">--</span><span class="n">retries</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">drm_edid_is_zero</span><span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="n">in_edid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">raw_edid</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">in_edid</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">raw_edid</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u8</span> <span class="o">*</span>
<span class="nf">drm_do_get_edid</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_connector</span> <span class="o">*</span><span class="n">connector</span><span class="p">,</span> <span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">valid_extensions</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">block</span><span class="p">,</span> <span class="o">*</span><span class="n">new</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">block</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">EDID_LENGTH</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* base block fetch */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">drm_do_probe_ddc_edid</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">EDID_LENGTH</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">drm_edid_block_valid</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">drm_edid_is_zero</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">EDID_LENGTH</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">connector</span><span class="o">-&gt;</span><span class="n">null_edid_counter</span><span class="o">++</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">carp</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">carp</span><span class="p">;</span>

	<span class="cm">/* if there&#39;s no extensions, we&#39;re done */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">block</span><span class="p">[</span><span class="mh">0x7e</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">block</span><span class="p">;</span>

	<span class="n">new</span> <span class="o">=</span> <span class="n">krealloc</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="p">(</span><span class="n">block</span><span class="p">[</span><span class="mh">0x7e</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">EDID_LENGTH</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">block</span> <span class="o">=</span> <span class="n">new</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">block</span><span class="p">[</span><span class="mh">0x7e</span><span class="p">];</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">drm_do_probe_ddc_edid</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span>
				  <span class="n">block</span> <span class="o">+</span> <span class="p">(</span><span class="n">valid_extensions</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">EDID_LENGTH</span><span class="p">,</span>
				  <span class="n">j</span><span class="p">,</span> <span class="n">EDID_LENGTH</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">drm_edid_block_valid</span><span class="p">(</span><span class="n">block</span> <span class="o">+</span> <span class="p">(</span><span class="n">valid_extensions</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">EDID_LENGTH</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">valid_extensions</span><span class="o">++</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="n">connector</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			 <span class="s">&quot;%s: Ignoring invalid EDID block %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">drm_get_connector_name</span><span class="p">(</span><span class="n">connector</span><span class="p">),</span> <span class="n">j</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">valid_extensions</span> <span class="o">!=</span> <span class="n">block</span><span class="p">[</span><span class="mh">0x7e</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">block</span><span class="p">[</span><span class="n">EDID_LENGTH</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">block</span><span class="p">[</span><span class="mh">0x7e</span><span class="p">]</span> <span class="o">-</span> <span class="n">valid_extensions</span><span class="p">;</span>
		<span class="n">block</span><span class="p">[</span><span class="mh">0x7e</span><span class="p">]</span> <span class="o">=</span> <span class="n">valid_extensions</span><span class="p">;</span>
		<span class="n">new</span> <span class="o">=</span> <span class="n">krealloc</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="p">(</span><span class="n">valid_extensions</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">EDID_LENGTH</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">block</span> <span class="o">=</span> <span class="n">new</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">block</span><span class="p">;</span>

<span class="nl">carp:</span>
	<span class="n">dev_warn</span><span class="p">(</span><span class="n">connector</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: EDID block %d invalid.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">drm_get_connector_name</span><span class="p">(</span><span class="n">connector</span><span class="p">),</span> <span class="n">j</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">block</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Probe DDC presence.</span>
<span class="cm"> *</span>
<span class="cm"> * \param adapter : i2c device adaptor</span>
<span class="cm"> * \return 1 on success</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span>
<span class="nf">drm_probe_ddc</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">drm_do_probe_ddc_edid</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">out</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * drm_get_edid - get EDID data, if available</span>
<span class="cm"> * @connector: connector we&#39;re probing</span>
<span class="cm"> * @adapter: i2c adapter to use for DDC</span>
<span class="cm"> *</span>
<span class="cm"> * Poke the given i2c channel to grab EDID data if possible.  If found,</span>
<span class="cm"> * attach it to the connector.</span>
<span class="cm"> *</span>
<span class="cm"> * Return edid data or NULL if we couldn&#39;t find any.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">edid</span> <span class="o">*</span><span class="nf">drm_get_edid</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_connector</span> <span class="o">*</span><span class="n">connector</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">edid</span> <span class="o">*</span><span class="n">edid</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">drm_probe_ddc</span><span class="p">(</span><span class="n">adapter</span><span class="p">))</span>
		<span class="n">edid</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">edid</span> <span class="o">*</span><span class="p">)</span><span class="n">drm_do_get_edid</span><span class="p">(</span><span class="n">connector</span><span class="p">,</span> <span class="n">adapter</span><span class="p">);</span>

	<span class="n">connector</span><span class="o">-&gt;</span><span class="n">display_info</span><span class="p">.</span><span class="n">raw_edid</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">edid</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">edid</span><span class="p">;</span>

<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">drm_get_edid</span><span class="p">);</span>

<span class="cm">/*** EDID parsing ***/</span>

<span class="cm">/**</span>
<span class="cm"> * edid_vendor - match a string against EDID&#39;s obfuscated vendor field</span>
<span class="cm"> * @edid: EDID to match</span>
<span class="cm"> * @vendor: vendor string</span>
<span class="cm"> *</span>
<span class="cm"> * Returns true if @vendor is in @edid, false otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">edid_vendor</span><span class="p">(</span><span class="k">struct</span> <span class="n">edid</span> <span class="o">*</span><span class="n">edid</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">vendor</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">edid_vendor</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>

	<span class="n">edid_vendor</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">edid</span><span class="o">-&gt;</span><span class="n">mfg_id</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x7c</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="sc">&#39;@&#39;</span><span class="p">;</span>
	<span class="n">edid_vendor</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(((</span><span class="n">edid</span><span class="o">-&gt;</span><span class="n">mfg_id</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">|</span>
			  <span class="p">((</span><span class="n">edid</span><span class="o">-&gt;</span><span class="n">mfg_id</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xe0</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span><span class="p">))</span> <span class="o">+</span> <span class="sc">&#39;@&#39;</span><span class="p">;</span>
	<span class="n">edid_vendor</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">edid</span><span class="o">-&gt;</span><span class="n">mfg_id</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">)</span> <span class="o">+</span> <span class="sc">&#39;@&#39;</span><span class="p">;</span>

	<span class="k">return</span> <span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">edid_vendor</span><span class="p">,</span> <span class="n">vendor</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * edid_get_quirks - return quirk flags for a given EDID</span>
<span class="cm"> * @edid: EDID to process</span>
<span class="cm"> *</span>
<span class="cm"> * This tells subsequent routines what fixes they need to apply.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="nf">edid_get_quirks</span><span class="p">(</span><span class="k">struct</span> <span class="n">edid</span> <span class="o">*</span><span class="n">edid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">edid_quirk</span> <span class="o">*</span><span class="n">quirk</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">edid_quirk_list</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">quirk</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">edid_quirk_list</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">edid_vendor</span><span class="p">(</span><span class="n">edid</span><span class="p">,</span> <span class="n">quirk</span><span class="o">-&gt;</span><span class="n">vendor</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">EDID_PRODUCT_ID</span><span class="p">(</span><span class="n">edid</span><span class="p">)</span> <span class="o">==</span> <span class="n">quirk</span><span class="o">-&gt;</span><span class="n">product_id</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">quirk</span><span class="o">-&gt;</span><span class="n">quirks</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define MODE_SIZE(m) ((m)-&gt;hdisplay * (m)-&gt;vdisplay)</span>
<span class="cp">#define MODE_REFRESH_DIFF(m,r) (abs((m)-&gt;vrefresh - target_refresh))</span>

<span class="cm">/**</span>
<span class="cm"> * edid_fixup_preferred - set preferred modes based on quirk list</span>
<span class="cm"> * @connector: has mode list to fix up</span>
<span class="cm"> * @quirks: quirks list</span>
<span class="cm"> *</span>
<span class="cm"> * Walk the mode list for @connector, clearing the preferred status</span>
<span class="cm"> * on existing modes and setting it anew for the right mode ala @quirks.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">edid_fixup_preferred</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_connector</span> <span class="o">*</span><span class="n">connector</span><span class="p">,</span>
				 <span class="n">u32</span> <span class="n">quirks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="o">*</span><span class="n">cur_mode</span><span class="p">,</span> <span class="o">*</span><span class="n">preferred_mode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">target_refresh</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">connector</span><span class="o">-&gt;</span><span class="n">probed_modes</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">EDID_QUIRK_PREFER_LARGE_60</span><span class="p">)</span>
		<span class="n">target_refresh</span> <span class="o">=</span> <span class="mi">60</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">EDID_QUIRK_PREFER_LARGE_75</span><span class="p">)</span>
		<span class="n">target_refresh</span> <span class="o">=</span> <span class="mi">75</span><span class="p">;</span>

	<span class="n">preferred_mode</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">connector</span><span class="o">-&gt;</span><span class="n">probed_modes</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">drm_display_mode</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">cur_mode</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">connector</span><span class="o">-&gt;</span><span class="n">probed_modes</span><span class="p">,</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cur_mode</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DRM_MODE_TYPE_PREFERRED</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cur_mode</span> <span class="o">==</span> <span class="n">preferred_mode</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* Largest mode is preferred */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">MODE_SIZE</span><span class="p">(</span><span class="n">cur_mode</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">MODE_SIZE</span><span class="p">(</span><span class="n">preferred_mode</span><span class="p">))</span>
			<span class="n">preferred_mode</span> <span class="o">=</span> <span class="n">cur_mode</span><span class="p">;</span>

		<span class="cm">/* At a given size, try to get closest to target refresh */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">MODE_SIZE</span><span class="p">(</span><span class="n">cur_mode</span><span class="p">)</span> <span class="o">==</span> <span class="n">MODE_SIZE</span><span class="p">(</span><span class="n">preferred_mode</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
		    <span class="n">MODE_REFRESH_DIFF</span><span class="p">(</span><span class="n">cur_mode</span><span class="p">,</span> <span class="n">target_refresh</span><span class="p">)</span> <span class="o">&lt;</span>
		    <span class="n">MODE_REFRESH_DIFF</span><span class="p">(</span><span class="n">preferred_mode</span><span class="p">,</span> <span class="n">target_refresh</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">preferred_mode</span> <span class="o">=</span> <span class="n">cur_mode</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">preferred_mode</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">|=</span> <span class="n">DRM_MODE_TYPE_PREFERRED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span>
<span class="nf">mode_is_rb</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">mode</span><span class="o">-&gt;</span><span class="n">htotal</span> <span class="o">-</span> <span class="n">mode</span><span class="o">-&gt;</span><span class="n">hdisplay</span> <span class="o">==</span> <span class="mi">160</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	       <span class="p">(</span><span class="n">mode</span><span class="o">-&gt;</span><span class="n">hsync_end</span> <span class="o">-</span> <span class="n">mode</span><span class="o">-&gt;</span><span class="n">hdisplay</span> <span class="o">==</span> <span class="mi">80</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	       <span class="p">(</span><span class="n">mode</span><span class="o">-&gt;</span><span class="n">hsync_end</span> <span class="o">-</span> <span class="n">mode</span><span class="o">-&gt;</span><span class="n">hsync_start</span> <span class="o">==</span> <span class="mi">32</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	       <span class="p">(</span><span class="n">mode</span><span class="o">-&gt;</span><span class="n">vsync_start</span> <span class="o">-</span> <span class="n">mode</span><span class="o">-&gt;</span><span class="n">vdisplay</span> <span class="o">==</span> <span class="mi">3</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * drm_mode_find_dmt - Create a copy of a mode if present in DMT</span>
<span class="cm"> * @dev: Device to duplicate against</span>
<span class="cm"> * @hsize: Mode width</span>
<span class="cm"> * @vsize: Mode height</span>
<span class="cm"> * @fresh: Mode refresh rate</span>
<span class="cm"> * @rb: Mode reduced-blanking-ness</span>
<span class="cm"> *</span>
<span class="cm"> * Walk the DMT mode list looking for a match for the given parameters.</span>
<span class="cm"> * Return a newly allocated copy of the mode, or NULL if not found.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="nf">drm_mode_find_dmt</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					   <span class="kt">int</span> <span class="n">hsize</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vsize</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fresh</span><span class="p">,</span>
					   <span class="n">bool</span> <span class="n">rb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">drm_num_dmt_modes</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">drm_dmt_modes</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hsize</span> <span class="o">!=</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">hdisplay</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vsize</span> <span class="o">!=</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">vdisplay</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fresh</span> <span class="o">!=</span> <span class="n">drm_mode_vrefresh</span><span class="p">(</span><span class="n">ptr</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rb</span> <span class="o">!=</span> <span class="n">mode_is_rb</span><span class="p">(</span><span class="n">ptr</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">return</span> <span class="n">drm_mode_duplicate</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">drm_mode_find_dmt</span><span class="p">);</span>

<span class="k">typedef</span> <span class="kt">void</span> <span class="n">detailed_cb</span><span class="p">(</span><span class="k">struct</span> <span class="n">detailed_timing</span> <span class="o">*</span><span class="n">timing</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">closure</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">cea_for_each_detailed_block</span><span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="n">ext</span><span class="p">,</span> <span class="n">detailed_cb</span> <span class="o">*</span><span class="n">cb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">closure</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">d</span> <span class="o">=</span> <span class="n">ext</span><span class="p">[</span><span class="mh">0x02</span><span class="p">];</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">det_base</span> <span class="o">=</span> <span class="n">ext</span> <span class="o">+</span> <span class="n">d</span><span class="p">;</span>

	<span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="mi">127</span> <span class="o">-</span> <span class="n">d</span><span class="p">)</span> <span class="o">/</span> <span class="mi">18</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">cb</span><span class="p">((</span><span class="k">struct</span> <span class="n">detailed_timing</span> <span class="o">*</span><span class="p">)(</span><span class="n">det_base</span> <span class="o">+</span> <span class="mi">18</span> <span class="o">*</span> <span class="n">i</span><span class="p">),</span> <span class="n">closure</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">vtb_for_each_detailed_block</span><span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="n">ext</span><span class="p">,</span> <span class="n">detailed_cb</span> <span class="o">*</span><span class="n">cb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">closure</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">min</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">ext</span><span class="p">[</span><span class="mh">0x02</span><span class="p">],</span> <span class="mi">6</span><span class="p">);</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">det_base</span> <span class="o">=</span> <span class="n">ext</span> <span class="o">+</span> <span class="mi">5</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ext</span><span class="p">[</span><span class="mh">0x01</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span> <span class="cm">/* unknown version */</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">cb</span><span class="p">((</span><span class="k">struct</span> <span class="n">detailed_timing</span> <span class="o">*</span><span class="p">)(</span><span class="n">det_base</span> <span class="o">+</span> <span class="mi">18</span> <span class="o">*</span> <span class="n">i</span><span class="p">),</span> <span class="n">closure</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">drm_for_each_detailed_block</span><span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="n">raw_edid</span><span class="p">,</span> <span class="n">detailed_cb</span> <span class="o">*</span><span class="n">cb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">closure</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">edid</span> <span class="o">*</span><span class="n">edid</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">edid</span> <span class="o">*</span><span class="p">)</span><span class="n">raw_edid</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">edid</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">EDID_DETAILED_TIMINGS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">cb</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">edid</span><span class="o">-&gt;</span><span class="n">detailed_timings</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">closure</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">raw_edid</span><span class="p">[</span><span class="mh">0x7e</span><span class="p">];</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u8</span> <span class="o">*</span><span class="n">ext</span> <span class="o">=</span> <span class="n">raw_edid</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">EDID_LENGTH</span><span class="p">);</span>
		<span class="k">switch</span> <span class="p">(</span><span class="o">*</span><span class="n">ext</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">CEA_EXT</span>:
			<span class="n">cea_for_each_detailed_block</span><span class="p">(</span><span class="n">ext</span><span class="p">,</span> <span class="n">cb</span><span class="p">,</span> <span class="n">closure</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">VTB_EXT</span>:
			<span class="n">vtb_for_each_detailed_block</span><span class="p">(</span><span class="n">ext</span><span class="p">,</span> <span class="n">cb</span><span class="p">,</span> <span class="n">closure</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">is_rb</span><span class="p">(</span><span class="k">struct</span> <span class="n">detailed_timing</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">t</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="n">EDID_DETAIL_MONITOR_RANGE</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x10</span><span class="p">)</span>
			<span class="o">*</span><span class="p">(</span><span class="n">bool</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* EDID 1.4 defines this explicitly.  For EDID 1.3, we guess, badly. */</span>
<span class="k">static</span> <span class="n">bool</span>
<span class="nf">drm_monitor_supports_rb</span><span class="p">(</span><span class="k">struct</span> <span class="n">edid</span> <span class="o">*</span><span class="n">edid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">edid</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bool</span> <span class="n">ret</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">drm_for_each_detailed_block</span><span class="p">((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">edid</span><span class="p">,</span> <span class="n">is_rb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ret</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="p">((</span><span class="n">edid</span><span class="o">-&gt;</span><span class="n">input</span> <span class="o">&amp;</span> <span class="n">DRM_EDID_INPUT_DIGITAL</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">find_gtf2</span><span class="p">(</span><span class="k">struct</span> <span class="n">detailed_timing</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">t</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="n">EDID_DETAIL_MONITOR_RANGE</span> <span class="o">&amp;&amp;</span> <span class="n">r</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0x02</span><span class="p">)</span>
		<span class="o">*</span><span class="p">(</span><span class="n">u8</span> <span class="o">**</span><span class="p">)</span><span class="n">data</span> <span class="o">=</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Secondary GTF curve kicks in above some break frequency */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">drm_gtf2_hbreak</span><span class="p">(</span><span class="k">struct</span> <span class="n">edid</span> <span class="o">*</span><span class="n">edid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">drm_for_each_detailed_block</span><span class="p">((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">edid</span><span class="p">,</span> <span class="n">find_gtf2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">r</span> <span class="o">?</span> <span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">drm_gtf2_2c</span><span class="p">(</span><span class="k">struct</span> <span class="n">edid</span> <span class="o">*</span><span class="n">edid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">drm_for_each_detailed_block</span><span class="p">((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">edid</span><span class="p">,</span> <span class="n">find_gtf2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">r</span> <span class="o">?</span> <span class="n">r</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">drm_gtf2_m</span><span class="p">(</span><span class="k">struct</span> <span class="n">edid</span> <span class="o">*</span><span class="n">edid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">drm_for_each_detailed_block</span><span class="p">((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">edid</span><span class="p">,</span> <span class="n">find_gtf2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">r</span> <span class="o">?</span> <span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="n">r</span><span class="p">[</span><span class="mi">14</span><span class="p">]</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">drm_gtf2_k</span><span class="p">(</span><span class="k">struct</span> <span class="n">edid</span> <span class="o">*</span><span class="n">edid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">drm_for_each_detailed_block</span><span class="p">((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">edid</span><span class="p">,</span> <span class="n">find_gtf2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">r</span> <span class="o">?</span> <span class="n">r</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">drm_gtf2_2j</span><span class="p">(</span><span class="k">struct</span> <span class="n">edid</span> <span class="o">*</span><span class="n">edid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">drm_for_each_detailed_block</span><span class="p">((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">edid</span><span class="p">,</span> <span class="n">find_gtf2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">r</span> <span class="o">?</span> <span class="n">r</span><span class="p">[</span><span class="mi">17</span><span class="p">]</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * standard_timing_level - get std. timing level(CVT/GTF/DMT)</span>
<span class="cm"> * @edid: EDID block to scan</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">standard_timing_level</span><span class="p">(</span><span class="k">struct</span> <span class="n">edid</span> <span class="o">*</span><span class="n">edid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">edid</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">edid</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">&gt;=</span> <span class="mi">4</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">edid</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">DRM_EDID_FEATURE_DEFAULT_GTF</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">LEVEL_CVT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">drm_gtf2_hbreak</span><span class="p">(</span><span class="n">edid</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">LEVEL_GTF2</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">LEVEL_GTF</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">LEVEL_DMT</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 0 is reserved.  The spec says 0x01 fill for unused timings.  Some old</span>
<span class="cm"> * monitors fill with ascii space (0x20) instead.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">bad_std_timing</span><span class="p">(</span><span class="n">u8</span> <span class="n">a</span><span class="p">,</span> <span class="n">u8</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="mh">0x00</span> <span class="o">&amp;&amp;</span> <span class="n">b</span> <span class="o">==</span> <span class="mh">0x00</span><span class="p">)</span> <span class="o">||</span>
	       <span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="mh">0x01</span> <span class="o">&amp;&amp;</span> <span class="n">b</span> <span class="o">==</span> <span class="mh">0x01</span><span class="p">)</span> <span class="o">||</span>
	       <span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="mh">0x20</span> <span class="o">&amp;&amp;</span> <span class="n">b</span> <span class="o">==</span> <span class="mh">0x20</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * drm_mode_std - convert standard mode info (width, height, refresh) into mode</span>
<span class="cm"> * @t: standard timing params</span>
<span class="cm"> * @timing_level: standard timing level</span>
<span class="cm"> *</span>
<span class="cm"> * Take the standard timing params (in this case width, aspect, and refresh)</span>
<span class="cm"> * and convert them into a real mode using CVT/GTF/DMT.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span>
<span class="nf">drm_mode_std</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_connector</span> <span class="o">*</span><span class="n">connector</span><span class="p">,</span> <span class="k">struct</span> <span class="n">edid</span> <span class="o">*</span><span class="n">edid</span><span class="p">,</span>
	     <span class="k">struct</span> <span class="n">std_timing</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="kt">int</span> <span class="n">revision</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">connector</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="o">*</span><span class="n">mode</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">hsize</span><span class="p">,</span> <span class="n">vsize</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">vrefresh_rate</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">aspect_ratio</span> <span class="o">=</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">vfreq_aspect</span> <span class="o">&amp;</span> <span class="n">EDID_TIMING_ASPECT_MASK</span><span class="p">)</span>
		<span class="o">&gt;&gt;</span> <span class="n">EDID_TIMING_ASPECT_SHIFT</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">vfreq</span> <span class="o">=</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">vfreq_aspect</span> <span class="o">&amp;</span> <span class="n">EDID_TIMING_VFREQ_MASK</span><span class="p">)</span>
		<span class="o">&gt;&gt;</span> <span class="n">EDID_TIMING_VFREQ_SHIFT</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">timing_level</span> <span class="o">=</span> <span class="n">standard_timing_level</span><span class="p">(</span><span class="n">edid</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bad_std_timing</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">hsize</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">vfreq_aspect</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* According to the EDID spec, the hdisplay = hsize * 8 + 248 */</span>
	<span class="n">hsize</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">hsize</span> <span class="o">*</span> <span class="mi">8</span> <span class="o">+</span> <span class="mi">248</span><span class="p">;</span>
	<span class="cm">/* vrefresh_rate = vfreq + 60 */</span>
	<span class="n">vrefresh_rate</span> <span class="o">=</span> <span class="n">vfreq</span> <span class="o">+</span> <span class="mi">60</span><span class="p">;</span>
	<span class="cm">/* the vdisplay is calculated based on the aspect ratio */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">aspect_ratio</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">revision</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span>
			<span class="n">vsize</span> <span class="o">=</span> <span class="n">hsize</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">vsize</span> <span class="o">=</span> <span class="p">(</span><span class="n">hsize</span> <span class="o">*</span> <span class="mi">10</span><span class="p">)</span> <span class="o">/</span> <span class="mi">16</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">aspect_ratio</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">vsize</span> <span class="o">=</span> <span class="p">(</span><span class="n">hsize</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">aspect_ratio</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">vsize</span> <span class="o">=</span> <span class="p">(</span><span class="n">hsize</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)</span> <span class="o">/</span> <span class="mi">5</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">vsize</span> <span class="o">=</span> <span class="p">(</span><span class="n">hsize</span> <span class="o">*</span> <span class="mi">9</span><span class="p">)</span> <span class="o">/</span> <span class="mi">16</span><span class="p">;</span>

	<span class="cm">/* HDTV hack, part 1 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vrefresh_rate</span> <span class="o">==</span> <span class="mi">60</span> <span class="o">&amp;&amp;</span>
	    <span class="p">((</span><span class="n">hsize</span> <span class="o">==</span> <span class="mi">1360</span> <span class="o">&amp;&amp;</span> <span class="n">vsize</span> <span class="o">==</span> <span class="mi">765</span><span class="p">)</span> <span class="o">||</span>
	     <span class="p">(</span><span class="n">hsize</span> <span class="o">==</span> <span class="mi">1368</span> <span class="o">&amp;&amp;</span> <span class="n">vsize</span> <span class="o">==</span> <span class="mi">769</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">hsize</span> <span class="o">=</span> <span class="mi">1366</span><span class="p">;</span>
		<span class="n">vsize</span> <span class="o">=</span> <span class="mi">768</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If this connector already has a mode for this size and refresh</span>
<span class="cm">	 * rate (because it came from detailed or CVT info), use that</span>
<span class="cm">	 * instead.  This way we don&#39;t have to guess at interlace or</span>
<span class="cm">	 * reduced blanking.</span>
<span class="cm">	 */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">connector</span><span class="o">-&gt;</span><span class="n">probed_modes</span><span class="p">,</span> <span class="n">head</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">hdisplay</span> <span class="o">==</span> <span class="n">hsize</span> <span class="o">&amp;&amp;</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">vdisplay</span> <span class="o">==</span> <span class="n">vsize</span> <span class="o">&amp;&amp;</span>
		    <span class="n">drm_mode_vrefresh</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">==</span> <span class="n">vrefresh_rate</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* HDTV hack, part 2 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hsize</span> <span class="o">==</span> <span class="mi">1366</span> <span class="o">&amp;&amp;</span> <span class="n">vsize</span> <span class="o">==</span> <span class="mi">768</span> <span class="o">&amp;&amp;</span> <span class="n">vrefresh_rate</span> <span class="o">==</span> <span class="mi">60</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mode</span> <span class="o">=</span> <span class="n">drm_cvt_mode</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">1366</span><span class="p">,</span> <span class="mi">768</span><span class="p">,</span> <span class="n">vrefresh_rate</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				    <span class="nb">false</span><span class="p">);</span>
		<span class="n">mode</span><span class="o">-&gt;</span><span class="n">hdisplay</span> <span class="o">=</span> <span class="mi">1366</span><span class="p">;</span>
		<span class="n">mode</span><span class="o">-&gt;</span><span class="n">hsync_start</span> <span class="o">=</span> <span class="n">mode</span><span class="o">-&gt;</span><span class="n">hsync_start</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">mode</span><span class="o">-&gt;</span><span class="n">hsync_end</span> <span class="o">=</span> <span class="n">mode</span><span class="o">-&gt;</span><span class="n">hsync_end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">mode</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* check whether it can be found in default mode table */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">drm_monitor_supports_rb</span><span class="p">(</span><span class="n">edid</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mode</span> <span class="o">=</span> <span class="n">drm_mode_find_dmt</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">hsize</span><span class="p">,</span> <span class="n">vsize</span><span class="p">,</span> <span class="n">vrefresh_rate</span><span class="p">,</span>
					 <span class="nb">true</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mode</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">mode</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mode</span> <span class="o">=</span> <span class="n">drm_mode_find_dmt</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">hsize</span><span class="p">,</span> <span class="n">vsize</span><span class="p">,</span> <span class="n">vrefresh_rate</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mode</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">mode</span><span class="p">;</span>

	<span class="cm">/* okay, generate it */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">timing_level</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">LEVEL_DMT</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LEVEL_GTF</span>:
		<span class="n">mode</span> <span class="o">=</span> <span class="n">drm_gtf_mode</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">hsize</span><span class="p">,</span> <span class="n">vsize</span><span class="p">,</span> <span class="n">vrefresh_rate</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LEVEL_GTF2</span>:
		<span class="cm">/*</span>
<span class="cm">		 * This is potentially wrong if there&#39;s ever a monitor with</span>
<span class="cm">		 * more than one ranges section, each claiming a different</span>
<span class="cm">		 * secondary GTF curve.  Please don&#39;t do that.</span>
<span class="cm">		 */</span>
		<span class="n">mode</span> <span class="o">=</span> <span class="n">drm_gtf_mode</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">hsize</span><span class="p">,</span> <span class="n">vsize</span><span class="p">,</span> <span class="n">vrefresh_rate</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mode</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">drm_mode_hsync</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">drm_gtf2_hbreak</span><span class="p">(</span><span class="n">edid</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">drm_mode_destroy</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
			<span class="n">mode</span> <span class="o">=</span> <span class="n">drm_gtf_mode_complex</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">hsize</span><span class="p">,</span> <span class="n">vsize</span><span class="p">,</span>
						    <span class="n">vrefresh_rate</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
						    <span class="n">drm_gtf2_m</span><span class="p">(</span><span class="n">edid</span><span class="p">),</span>
						    <span class="n">drm_gtf2_2c</span><span class="p">(</span><span class="n">edid</span><span class="p">),</span>
						    <span class="n">drm_gtf2_k</span><span class="p">(</span><span class="n">edid</span><span class="p">),</span>
						    <span class="n">drm_gtf2_2j</span><span class="p">(</span><span class="n">edid</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LEVEL_CVT</span>:
		<span class="n">mode</span> <span class="o">=</span> <span class="n">drm_cvt_mode</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">hsize</span><span class="p">,</span> <span class="n">vsize</span><span class="p">,</span> <span class="n">vrefresh_rate</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				    <span class="nb">false</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">mode</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * EDID is delightfully ambiguous about how interlaced modes are to be</span>
<span class="cm"> * encoded.  Our internal representation is of frame height, but some</span>
<span class="cm"> * HDTV detailed timings are encoded as field height.</span>
<span class="cm"> *</span>
<span class="cm"> * The format list here is from CEA, in frame size.  Technically we</span>
<span class="cm"> * should be checking refresh rate too.  Whatever.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">drm_mode_do_interlace_quirk</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="n">mode</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">detailed_pixel_timing</span> <span class="o">*</span><span class="n">pt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">cea_interlaced</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">{</span> <span class="mi">1920</span><span class="p">,</span> <span class="mi">1080</span> <span class="p">},</span>
		<span class="p">{</span>  <span class="mi">720</span><span class="p">,</span>  <span class="mi">480</span> <span class="p">},</span>
		<span class="p">{</span> <span class="mi">1440</span><span class="p">,</span>  <span class="mi">480</span> <span class="p">},</span>
		<span class="p">{</span> <span class="mi">2880</span><span class="p">,</span>  <span class="mi">480</span> <span class="p">},</span>
		<span class="p">{</span>  <span class="mi">720</span><span class="p">,</span>  <span class="mi">576</span> <span class="p">},</span>
		<span class="p">{</span> <span class="mi">1440</span><span class="p">,</span>  <span class="mi">576</span> <span class="p">},</span>
		<span class="p">{</span> <span class="mi">2880</span><span class="p">,</span>  <span class="mi">576</span> <span class="p">},</span>
	<span class="p">};</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">pt</span><span class="o">-&gt;</span><span class="n">misc</span> <span class="o">&amp;</span> <span class="n">DRM_EDID_PT_INTERLACED</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">cea_interlaced</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">mode</span><span class="o">-&gt;</span><span class="n">hdisplay</span> <span class="o">==</span> <span class="n">cea_interlaced</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">w</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">mode</span><span class="o">-&gt;</span><span class="n">vdisplay</span> <span class="o">==</span> <span class="n">cea_interlaced</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">h</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">mode</span><span class="o">-&gt;</span><span class="n">vdisplay</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
			<span class="n">mode</span><span class="o">-&gt;</span><span class="n">vsync_start</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
			<span class="n">mode</span><span class="o">-&gt;</span><span class="n">vsync_end</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
			<span class="n">mode</span><span class="o">-&gt;</span><span class="n">vtotal</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
			<span class="n">mode</span><span class="o">-&gt;</span><span class="n">vtotal</span> <span class="o">|=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">mode</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">DRM_MODE_FLAG_INTERLACE</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * drm_mode_detailed - create a new mode from an EDID detailed timing section</span>
<span class="cm"> * @dev: DRM device (needed to create new mode)</span>
<span class="cm"> * @edid: EDID block</span>
<span class="cm"> * @timing: EDID detailed timing info</span>
<span class="cm"> * @quirks: quirks to apply</span>
<span class="cm"> *</span>
<span class="cm"> * An EDID detailed timing block contains enough info for us to create and</span>
<span class="cm"> * return a new struct drm_display_mode.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="nf">drm_mode_detailed</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
						  <span class="k">struct</span> <span class="n">edid</span> <span class="o">*</span><span class="n">edid</span><span class="p">,</span>
						  <span class="k">struct</span> <span class="n">detailed_timing</span> <span class="o">*</span><span class="n">timing</span><span class="p">,</span>
						  <span class="n">u32</span> <span class="n">quirks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="n">mode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">detailed_pixel_timing</span> <span class="o">*</span><span class="n">pt</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">timing</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">pixel_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">hactive</span> <span class="o">=</span> <span class="p">(</span><span class="n">pt</span><span class="o">-&gt;</span><span class="n">hactive_hblank_hi</span> <span class="o">&amp;</span> <span class="mh">0xf0</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span> <span class="o">|</span> <span class="n">pt</span><span class="o">-&gt;</span><span class="n">hactive_lo</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">vactive</span> <span class="o">=</span> <span class="p">(</span><span class="n">pt</span><span class="o">-&gt;</span><span class="n">vactive_vblank_hi</span> <span class="o">&amp;</span> <span class="mh">0xf0</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span> <span class="o">|</span> <span class="n">pt</span><span class="o">-&gt;</span><span class="n">vactive_lo</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">hblank</span> <span class="o">=</span> <span class="p">(</span><span class="n">pt</span><span class="o">-&gt;</span><span class="n">hactive_hblank_hi</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span> <span class="o">|</span> <span class="n">pt</span><span class="o">-&gt;</span><span class="n">hblank_lo</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">vblank</span> <span class="o">=</span> <span class="p">(</span><span class="n">pt</span><span class="o">-&gt;</span><span class="n">vactive_vblank_hi</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span> <span class="o">|</span> <span class="n">pt</span><span class="o">-&gt;</span><span class="n">vblank_lo</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">hsync_offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">pt</span><span class="o">-&gt;</span><span class="n">hsync_vsync_offset_pulse_width_hi</span> <span class="o">&amp;</span> <span class="mh">0xc0</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span> <span class="o">|</span> <span class="n">pt</span><span class="o">-&gt;</span><span class="n">hsync_offset_lo</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">hsync_pulse_width</span> <span class="o">=</span> <span class="p">(</span><span class="n">pt</span><span class="o">-&gt;</span><span class="n">hsync_vsync_offset_pulse_width_hi</span> <span class="o">&amp;</span> <span class="mh">0x30</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span> <span class="o">|</span> <span class="n">pt</span><span class="o">-&gt;</span><span class="n">hsync_pulse_width_lo</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">vsync_offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">pt</span><span class="o">-&gt;</span><span class="n">hsync_vsync_offset_pulse_width_hi</span> <span class="o">&amp;</span> <span class="mh">0xc</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span> <span class="o">|</span> <span class="n">pt</span><span class="o">-&gt;</span><span class="n">vsync_offset_pulse_width_lo</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">vsync_pulse_width</span> <span class="o">=</span> <span class="p">(</span><span class="n">pt</span><span class="o">-&gt;</span><span class="n">hsync_vsync_offset_pulse_width_hi</span> <span class="o">&amp;</span> <span class="mh">0x3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span> <span class="o">|</span> <span class="p">(</span><span class="n">pt</span><span class="o">-&gt;</span><span class="n">vsync_offset_pulse_width_lo</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">);</span>

	<span class="cm">/* ignore tiny modes */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hactive</span> <span class="o">&lt;</span> <span class="mi">64</span> <span class="o">||</span> <span class="n">vactive</span> <span class="o">&lt;</span> <span class="mi">64</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pt</span><span class="o">-&gt;</span><span class="n">misc</span> <span class="o">&amp;</span> <span class="n">DRM_EDID_PT_STEREO</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;stereo mode not supported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">pt</span><span class="o">-&gt;</span><span class="n">misc</span> <span class="o">&amp;</span> <span class="n">DRM_EDID_PT_SEPARATE_SYNC</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;composite sync not supported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* it is incorrect if hsync/vsync width is zero */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hsync_pulse_width</span> <span class="o">||</span> <span class="o">!</span><span class="n">vsync_pulse_width</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DRM_DEBUG_KMS</span><span class="p">(</span><span class="s">&quot;Incorrect Detailed timing. &quot;</span>
				<span class="s">&quot;Wrong Hsync/Vsync pulse width</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">EDID_QUIRK_FORCE_REDUCED_BLANKING</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mode</span> <span class="o">=</span> <span class="n">drm_cvt_mode</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">hactive</span><span class="p">,</span> <span class="n">vactive</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mode</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="k">goto</span> <span class="n">set_size</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mode</span> <span class="o">=</span> <span class="n">drm_mode_create</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mode</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">EDID_QUIRK_135_CLOCK_TOO_HIGH</span><span class="p">)</span>
		<span class="n">timing</span><span class="o">-&gt;</span><span class="n">pixel_clock</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mi">1088</span><span class="p">);</span>

	<span class="n">mode</span><span class="o">-&gt;</span><span class="n">clock</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">timing</span><span class="o">-&gt;</span><span class="n">pixel_clock</span><span class="p">)</span> <span class="o">*</span> <span class="mi">10</span><span class="p">;</span>

	<span class="n">mode</span><span class="o">-&gt;</span><span class="n">hdisplay</span> <span class="o">=</span> <span class="n">hactive</span><span class="p">;</span>
	<span class="n">mode</span><span class="o">-&gt;</span><span class="n">hsync_start</span> <span class="o">=</span> <span class="n">mode</span><span class="o">-&gt;</span><span class="n">hdisplay</span> <span class="o">+</span> <span class="n">hsync_offset</span><span class="p">;</span>
	<span class="n">mode</span><span class="o">-&gt;</span><span class="n">hsync_end</span> <span class="o">=</span> <span class="n">mode</span><span class="o">-&gt;</span><span class="n">hsync_start</span> <span class="o">+</span> <span class="n">hsync_pulse_width</span><span class="p">;</span>
	<span class="n">mode</span><span class="o">-&gt;</span><span class="n">htotal</span> <span class="o">=</span> <span class="n">mode</span><span class="o">-&gt;</span><span class="n">hdisplay</span> <span class="o">+</span> <span class="n">hblank</span><span class="p">;</span>

	<span class="n">mode</span><span class="o">-&gt;</span><span class="n">vdisplay</span> <span class="o">=</span> <span class="n">vactive</span><span class="p">;</span>
	<span class="n">mode</span><span class="o">-&gt;</span><span class="n">vsync_start</span> <span class="o">=</span> <span class="n">mode</span><span class="o">-&gt;</span><span class="n">vdisplay</span> <span class="o">+</span> <span class="n">vsync_offset</span><span class="p">;</span>
	<span class="n">mode</span><span class="o">-&gt;</span><span class="n">vsync_end</span> <span class="o">=</span> <span class="n">mode</span><span class="o">-&gt;</span><span class="n">vsync_start</span> <span class="o">+</span> <span class="n">vsync_pulse_width</span><span class="p">;</span>
	<span class="n">mode</span><span class="o">-&gt;</span><span class="n">vtotal</span> <span class="o">=</span> <span class="n">mode</span><span class="o">-&gt;</span><span class="n">vdisplay</span> <span class="o">+</span> <span class="n">vblank</span><span class="p">;</span>

	<span class="cm">/* Some EDIDs have bogus h/vtotal values */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mode</span><span class="o">-&gt;</span><span class="n">hsync_end</span> <span class="o">&gt;</span> <span class="n">mode</span><span class="o">-&gt;</span><span class="n">htotal</span><span class="p">)</span>
		<span class="n">mode</span><span class="o">-&gt;</span><span class="n">htotal</span> <span class="o">=</span> <span class="n">mode</span><span class="o">-&gt;</span><span class="n">hsync_end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mode</span><span class="o">-&gt;</span><span class="n">vsync_end</span> <span class="o">&gt;</span> <span class="n">mode</span><span class="o">-&gt;</span><span class="n">vtotal</span><span class="p">)</span>
		<span class="n">mode</span><span class="o">-&gt;</span><span class="n">vtotal</span> <span class="o">=</span> <span class="n">mode</span><span class="o">-&gt;</span><span class="n">vsync_end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">drm_mode_do_interlace_quirk</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">pt</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">EDID_QUIRK_DETAILED_SYNC_PP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pt</span><span class="o">-&gt;</span><span class="n">misc</span> <span class="o">|=</span> <span class="n">DRM_EDID_PT_HSYNC_POSITIVE</span> <span class="o">|</span> <span class="n">DRM_EDID_PT_VSYNC_POSITIVE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mode</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="p">(</span><span class="n">pt</span><span class="o">-&gt;</span><span class="n">misc</span> <span class="o">&amp;</span> <span class="n">DRM_EDID_PT_HSYNC_POSITIVE</span><span class="p">)</span> <span class="o">?</span>
		<span class="n">DRM_MODE_FLAG_PHSYNC</span> <span class="o">:</span> <span class="n">DRM_MODE_FLAG_NHSYNC</span><span class="p">;</span>
	<span class="n">mode</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="p">(</span><span class="n">pt</span><span class="o">-&gt;</span><span class="n">misc</span> <span class="o">&amp;</span> <span class="n">DRM_EDID_PT_VSYNC_POSITIVE</span><span class="p">)</span> <span class="o">?</span>
		<span class="n">DRM_MODE_FLAG_PVSYNC</span> <span class="o">:</span> <span class="n">DRM_MODE_FLAG_NVSYNC</span><span class="p">;</span>

<span class="nl">set_size:</span>
	<span class="n">mode</span><span class="o">-&gt;</span><span class="n">width_mm</span> <span class="o">=</span> <span class="n">pt</span><span class="o">-&gt;</span><span class="n">width_mm_lo</span> <span class="o">|</span> <span class="p">(</span><span class="n">pt</span><span class="o">-&gt;</span><span class="n">width_height_mm_hi</span> <span class="o">&amp;</span> <span class="mh">0xf0</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">;</span>
	<span class="n">mode</span><span class="o">-&gt;</span><span class="n">height_mm</span> <span class="o">=</span> <span class="n">pt</span><span class="o">-&gt;</span><span class="n">height_mm_lo</span> <span class="o">|</span> <span class="p">(</span><span class="n">pt</span><span class="o">-&gt;</span><span class="n">width_height_mm_hi</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">EDID_QUIRK_DETAILED_IN_CM</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mode</span><span class="o">-&gt;</span><span class="n">width_mm</span> <span class="o">*=</span> <span class="mi">10</span><span class="p">;</span>
		<span class="n">mode</span><span class="o">-&gt;</span><span class="n">height_mm</span> <span class="o">*=</span> <span class="mi">10</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">EDID_QUIRK_DETAILED_USE_MAXIMUM_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mode</span><span class="o">-&gt;</span><span class="n">width_mm</span> <span class="o">=</span> <span class="n">edid</span><span class="o">-&gt;</span><span class="n">width_cm</span> <span class="o">*</span> <span class="mi">10</span><span class="p">;</span>
		<span class="n">mode</span><span class="o">-&gt;</span><span class="n">height_mm</span> <span class="o">=</span> <span class="n">edid</span><span class="o">-&gt;</span><span class="n">height_cm</span> <span class="o">*</span> <span class="mi">10</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mode</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">DRM_MODE_TYPE_DRIVER</span><span class="p">;</span>
	<span class="n">drm_mode_set_name</span><span class="p">(</span><span class="n">mode</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">mode</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span>
<span class="nf">mode_in_hsync_range</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="n">mode</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">edid</span> <span class="o">*</span><span class="n">edid</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">hsync</span><span class="p">,</span> <span class="n">hmin</span><span class="p">,</span> <span class="n">hmax</span><span class="p">;</span>

	<span class="n">hmin</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">edid</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">)</span>
	    <span class="n">hmin</span> <span class="o">+=</span> <span class="p">((</span><span class="n">t</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x04</span><span class="p">)</span> <span class="o">?</span> <span class="mi">255</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">hmax</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">edid</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">)</span>
	    <span class="n">hmax</span> <span class="o">+=</span> <span class="p">((</span><span class="n">t</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x08</span><span class="p">)</span> <span class="o">?</span> <span class="mi">255</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">hsync</span> <span class="o">=</span> <span class="n">drm_mode_hsync</span><span class="p">(</span><span class="n">mode</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">hsync</span> <span class="o">&lt;=</span> <span class="n">hmax</span> <span class="o">&amp;&amp;</span> <span class="n">hsync</span> <span class="o">&gt;=</span> <span class="n">hmin</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span>
<span class="nf">mode_in_vsync_range</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="n">mode</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">edid</span> <span class="o">*</span><span class="n">edid</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">vsync</span><span class="p">,</span> <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">;</span>

	<span class="n">vmin</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">edid</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">)</span>
	    <span class="n">vmin</span> <span class="o">+=</span> <span class="p">((</span><span class="n">t</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">)</span> <span class="o">?</span> <span class="mi">255</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">vmax</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">edid</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">)</span>
	    <span class="n">vmax</span> <span class="o">+=</span> <span class="p">((</span><span class="n">t</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x02</span><span class="p">)</span> <span class="o">?</span> <span class="mi">255</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">vsync</span> <span class="o">=</span> <span class="n">drm_mode_vrefresh</span><span class="p">(</span><span class="n">mode</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">vsync</span> <span class="o">&lt;=</span> <span class="n">vmax</span> <span class="o">&amp;&amp;</span> <span class="n">vsync</span> <span class="o">&gt;=</span> <span class="n">vmin</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span>
<span class="nf">range_pixel_clock</span><span class="p">(</span><span class="k">struct</span> <span class="n">edid</span> <span class="o">*</span><span class="n">edid</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* unspecified */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">t</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">==</span> <span class="mi">255</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* 1.4 with CVT support gives us real precision, yay */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">edid</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">&gt;=</span> <span class="mi">4</span> <span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0x04</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">*</span> <span class="mi">10000</span><span class="p">)</span> <span class="o">-</span> <span class="p">((</span><span class="n">t</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="mi">250</span><span class="p">);</span>

	<span class="cm">/* 1.3 is pathetic, so fuzz up a bit */</span>
	<span class="k">return</span> <span class="n">t</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">*</span> <span class="mi">10000</span> <span class="o">+</span> <span class="mi">5001</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span>
<span class="nf">mode_in_range</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="n">mode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">edid</span> <span class="o">*</span><span class="n">edid</span><span class="p">,</span>
	      <span class="k">struct</span> <span class="n">detailed_timing</span> <span class="o">*</span><span class="n">timing</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">max_clock</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">timing</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mode_in_hsync_range</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">edid</span><span class="p">,</span> <span class="n">t</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mode_in_vsync_range</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">edid</span><span class="p">,</span> <span class="n">t</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">max_clock</span> <span class="o">=</span> <span class="n">range_pixel_clock</span><span class="p">(</span><span class="n">edid</span><span class="p">,</span> <span class="n">t</span><span class="p">)))</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mode</span><span class="o">-&gt;</span><span class="n">clock</span> <span class="o">&gt;</span> <span class="n">max_clock</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* 1.4 max horizontal check */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">edid</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">&gt;=</span> <span class="mi">4</span> <span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0x04</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">mode</span><span class="o">-&gt;</span><span class="n">hdisplay</span> <span class="o">&gt;</span> <span class="mi">8</span> <span class="o">*</span> <span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">256</span> <span class="o">*</span> <span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span><span class="o">&amp;</span><span class="mh">0x3</span><span class="p">))))</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mode_is_rb</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">drm_monitor_supports_rb</span><span class="p">(</span><span class="n">edid</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">valid_inferred_mode</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">drm_connector</span> <span class="o">*</span><span class="n">connector</span><span class="p">,</span>
				<span class="k">const</span> <span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="n">m</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">ok</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">connector</span><span class="o">-&gt;</span><span class="n">probed_modes</span><span class="p">,</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mode</span><span class="o">-&gt;</span><span class="n">hdisplay</span> <span class="o">==</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">hdisplay</span> <span class="o">&amp;&amp;</span>
		    <span class="n">mode</span><span class="o">-&gt;</span><span class="n">vdisplay</span> <span class="o">==</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">vdisplay</span> <span class="o">&amp;&amp;</span>
		    <span class="n">drm_mode_vrefresh</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="o">==</span> <span class="n">drm_mode_vrefresh</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="cm">/* duplicated */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mode</span><span class="o">-&gt;</span><span class="n">hdisplay</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">hdisplay</span> <span class="o">&amp;&amp;</span>
		    <span class="n">mode</span><span class="o">-&gt;</span><span class="n">vdisplay</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">vdisplay</span><span class="p">)</span>
			<span class="n">ok</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ok</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">drm_dmt_modes_for_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_connector</span> <span class="o">*</span><span class="n">connector</span><span class="p">,</span> <span class="k">struct</span> <span class="n">edid</span> <span class="o">*</span><span class="n">edid</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">detailed_timing</span> <span class="o">*</span><span class="n">timing</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">modes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="n">newmode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">connector</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">drm_num_dmt_modes</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mode_in_range</span><span class="p">(</span><span class="n">drm_dmt_modes</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">edid</span><span class="p">,</span> <span class="n">timing</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">valid_inferred_mode</span><span class="p">(</span><span class="n">connector</span><span class="p">,</span> <span class="n">drm_dmt_modes</span> <span class="o">+</span> <span class="n">i</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">newmode</span> <span class="o">=</span> <span class="n">drm_mode_duplicate</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">drm_dmt_modes</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">newmode</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">drm_mode_probed_add</span><span class="p">(</span><span class="n">connector</span><span class="p">,</span> <span class="n">newmode</span><span class="p">);</span>
				<span class="n">modes</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">modes</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* fix up 1366x768 mode from 1368x768;</span>
<span class="cm"> * GFT/CVT can&#39;t express 1366 width which isn&#39;t dividable by 8</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fixup_mode_1366x768</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mode</span><span class="o">-&gt;</span><span class="n">hdisplay</span> <span class="o">==</span> <span class="mi">1368</span> <span class="o">&amp;&amp;</span> <span class="n">mode</span><span class="o">-&gt;</span><span class="n">vdisplay</span> <span class="o">==</span> <span class="mi">768</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mode</span><span class="o">-&gt;</span><span class="n">hdisplay</span> <span class="o">=</span> <span class="mi">1366</span><span class="p">;</span>
		<span class="n">mode</span><span class="o">-&gt;</span><span class="n">hsync_start</span><span class="o">--</span><span class="p">;</span>
		<span class="n">mode</span><span class="o">-&gt;</span><span class="n">hsync_end</span><span class="o">--</span><span class="p">;</span>
		<span class="n">drm_mode_set_name</span><span class="p">(</span><span class="n">mode</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">drm_gtf_modes_for_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_connector</span> <span class="o">*</span><span class="n">connector</span><span class="p">,</span> <span class="k">struct</span> <span class="n">edid</span> <span class="o">*</span><span class="n">edid</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">detailed_timing</span> <span class="o">*</span><span class="n">timing</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">modes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="n">newmode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">connector</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_extra_modes</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">minimode</span> <span class="o">*</span><span class="n">m</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">extra_modes</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">newmode</span> <span class="o">=</span> <span class="n">drm_gtf_mode</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">w</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">h</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">newmode</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">modes</span><span class="p">;</span>

		<span class="n">fixup_mode_1366x768</span><span class="p">(</span><span class="n">newmode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mode_in_range</span><span class="p">(</span><span class="n">newmode</span><span class="p">,</span> <span class="n">edid</span><span class="p">,</span> <span class="n">timing</span><span class="p">)</span> <span class="o">||</span>
		    <span class="o">!</span><span class="n">valid_inferred_mode</span><span class="p">(</span><span class="n">connector</span><span class="p">,</span> <span class="n">newmode</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">drm_mode_destroy</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">newmode</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">drm_mode_probed_add</span><span class="p">(</span><span class="n">connector</span><span class="p">,</span> <span class="n">newmode</span><span class="p">);</span>
		<span class="n">modes</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">modes</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">drm_cvt_modes_for_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_connector</span> <span class="o">*</span><span class="n">connector</span><span class="p">,</span> <span class="k">struct</span> <span class="n">edid</span> <span class="o">*</span><span class="n">edid</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">detailed_timing</span> <span class="o">*</span><span class="n">timing</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">modes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="n">newmode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">connector</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">rb</span> <span class="o">=</span> <span class="n">drm_monitor_supports_rb</span><span class="p">(</span><span class="n">edid</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_extra_modes</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">minimode</span> <span class="o">*</span><span class="n">m</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">extra_modes</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">newmode</span> <span class="o">=</span> <span class="n">drm_cvt_mode</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">w</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">h</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">,</span> <span class="n">rb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">newmode</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">modes</span><span class="p">;</span>

		<span class="n">fixup_mode_1366x768</span><span class="p">(</span><span class="n">newmode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mode_in_range</span><span class="p">(</span><span class="n">newmode</span><span class="p">,</span> <span class="n">edid</span><span class="p">,</span> <span class="n">timing</span><span class="p">)</span> <span class="o">||</span>
		    <span class="o">!</span><span class="n">valid_inferred_mode</span><span class="p">(</span><span class="n">connector</span><span class="p">,</span> <span class="n">newmode</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">drm_mode_destroy</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">newmode</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">drm_mode_probed_add</span><span class="p">(</span><span class="n">connector</span><span class="p">,</span> <span class="n">newmode</span><span class="p">);</span>
		<span class="n">modes</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">modes</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">do_inferred_modes</span><span class="p">(</span><span class="k">struct</span> <span class="n">detailed_timing</span> <span class="o">*</span><span class="n">timing</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">detailed_mode_closure</span> <span class="o">*</span><span class="n">closure</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">detailed_non_pixel</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">timing</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">other_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">detailed_data_monitor_range</span> <span class="o">*</span><span class="n">range</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">range</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">EDID_DETAIL_MONITOR_RANGE</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">closure</span><span class="o">-&gt;</span><span class="n">modes</span> <span class="o">+=</span> <span class="n">drm_dmt_modes_for_range</span><span class="p">(</span><span class="n">closure</span><span class="o">-&gt;</span><span class="n">connector</span><span class="p">,</span>
						  <span class="n">closure</span><span class="o">-&gt;</span><span class="n">edid</span><span class="p">,</span>
						  <span class="n">timing</span><span class="p">);</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">version_greater</span><span class="p">(</span><span class="n">closure</span><span class="o">-&gt;</span><span class="n">edid</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span> <span class="cm">/* GTF not defined yet */</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">range</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mh">0x02</span>: <span class="cm">/* secondary gtf, XXX could do more */</span>
	<span class="k">case</span> <span class="mh">0x00</span>: <span class="cm">/* default gtf */</span>
		<span class="n">closure</span><span class="o">-&gt;</span><span class="n">modes</span> <span class="o">+=</span> <span class="n">drm_gtf_modes_for_range</span><span class="p">(</span><span class="n">closure</span><span class="o">-&gt;</span><span class="n">connector</span><span class="p">,</span>
							  <span class="n">closure</span><span class="o">-&gt;</span><span class="n">edid</span><span class="p">,</span>
							  <span class="n">timing</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x04</span>: <span class="cm">/* cvt, only in 1.4+ */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">version_greater</span><span class="p">(</span><span class="n">closure</span><span class="o">-&gt;</span><span class="n">edid</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">closure</span><span class="o">-&gt;</span><span class="n">modes</span> <span class="o">+=</span> <span class="n">drm_cvt_modes_for_range</span><span class="p">(</span><span class="n">closure</span><span class="o">-&gt;</span><span class="n">connector</span><span class="p">,</span>
							  <span class="n">closure</span><span class="o">-&gt;</span><span class="n">edid</span><span class="p">,</span>
							  <span class="n">timing</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x01</span>: <span class="cm">/* just the ranges, no formula */</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">add_inferred_modes</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_connector</span> <span class="o">*</span><span class="n">connector</span><span class="p">,</span> <span class="k">struct</span> <span class="n">edid</span> <span class="o">*</span><span class="n">edid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">detailed_mode_closure</span> <span class="n">closure</span> <span class="o">=</span> <span class="p">{</span>
		<span class="n">connector</span><span class="p">,</span> <span class="n">edid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
	<span class="p">};</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">version_greater</span><span class="p">(</span><span class="n">edid</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">drm_for_each_detailed_block</span><span class="p">((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">edid</span><span class="p">,</span> <span class="n">do_inferred_modes</span><span class="p">,</span>
					    <span class="o">&amp;</span><span class="n">closure</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">closure</span><span class="p">.</span><span class="n">modes</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">drm_est3_modes</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_connector</span> <span class="o">*</span><span class="n">connector</span><span class="p">,</span> <span class="k">struct</span> <span class="n">detailed_timing</span> <span class="o">*</span><span class="n">timing</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">modes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="n">mode</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">est</span> <span class="o">=</span> <span class="p">((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">timing</span><span class="p">)</span> <span class="o">+</span> <span class="mi">5</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">7</span> <span class="o">-</span> <span class="n">j</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">&gt;=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">est3_modes</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">est</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">j</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">mode</span> <span class="o">=</span> <span class="n">drm_mode_find_dmt</span><span class="p">(</span><span class="n">connector</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
							 <span class="n">est3_modes</span><span class="p">[</span><span class="n">m</span><span class="p">].</span><span class="n">w</span><span class="p">,</span>
							 <span class="n">est3_modes</span><span class="p">[</span><span class="n">m</span><span class="p">].</span><span class="n">h</span><span class="p">,</span>
							 <span class="n">est3_modes</span><span class="p">[</span><span class="n">m</span><span class="p">].</span><span class="n">r</span><span class="p">,</span>
							 <span class="n">est3_modes</span><span class="p">[</span><span class="n">m</span><span class="p">].</span><span class="n">rb</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">drm_mode_probed_add</span><span class="p">(</span><span class="n">connector</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
					<span class="n">modes</span><span class="o">++</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">modes</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">do_established_modes</span><span class="p">(</span><span class="k">struct</span> <span class="n">detailed_timing</span> <span class="o">*</span><span class="n">timing</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">detailed_mode_closure</span> <span class="o">*</span><span class="n">closure</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">detailed_non_pixel</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">timing</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">other_data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">EDID_DETAIL_EST_TIMINGS</span><span class="p">)</span>
		<span class="n">closure</span><span class="o">-&gt;</span><span class="n">modes</span> <span class="o">+=</span> <span class="n">drm_est3_modes</span><span class="p">(</span><span class="n">closure</span><span class="o">-&gt;</span><span class="n">connector</span><span class="p">,</span> <span class="n">timing</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * add_established_modes - get est. modes from EDID and add them</span>
<span class="cm"> * @edid: EDID block to scan</span>
<span class="cm"> *</span>
<span class="cm"> * Each EDID block contains a bitmap of the supported &quot;established modes&quot; list</span>
<span class="cm"> * (defined above).  Tease them out and add them to the global modes list.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">add_established_modes</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_connector</span> <span class="o">*</span><span class="n">connector</span><span class="p">,</span> <span class="k">struct</span> <span class="n">edid</span> <span class="o">*</span><span class="n">edid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">connector</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">est_bits</span> <span class="o">=</span> <span class="n">edid</span><span class="o">-&gt;</span><span class="n">established_timings</span><span class="p">.</span><span class="n">t1</span> <span class="o">|</span>
		<span class="p">(</span><span class="n">edid</span><span class="o">-&gt;</span><span class="n">established_timings</span><span class="p">.</span><span class="n">t2</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">((</span><span class="n">edid</span><span class="o">-&gt;</span><span class="n">established_timings</span><span class="p">.</span><span class="n">mfg_rsvd</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">9</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">modes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">detailed_mode_closure</span> <span class="n">closure</span> <span class="o">=</span> <span class="p">{</span>
		<span class="n">connector</span><span class="p">,</span> <span class="n">edid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
	<span class="p">};</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">EDID_EST_TIMINGS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">est_bits</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">i</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="n">newmode</span><span class="p">;</span>
			<span class="n">newmode</span> <span class="o">=</span> <span class="n">drm_mode_duplicate</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">edid_est_modes</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">newmode</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">drm_mode_probed_add</span><span class="p">(</span><span class="n">connector</span><span class="p">,</span> <span class="n">newmode</span><span class="p">);</span>
				<span class="n">modes</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">version_greater</span><span class="p">(</span><span class="n">edid</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
		    <span class="n">drm_for_each_detailed_block</span><span class="p">((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">edid</span><span class="p">,</span>
						<span class="n">do_established_modes</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">closure</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">modes</span> <span class="o">+</span> <span class="n">closure</span><span class="p">.</span><span class="n">modes</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">do_standard_modes</span><span class="p">(</span><span class="k">struct</span> <span class="n">detailed_timing</span> <span class="o">*</span><span class="n">timing</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">detailed_mode_closure</span> <span class="o">*</span><span class="n">closure</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">detailed_non_pixel</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">timing</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">other_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_connector</span> <span class="o">*</span><span class="n">connector</span> <span class="o">=</span> <span class="n">closure</span><span class="o">-&gt;</span><span class="n">connector</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">edid</span> <span class="o">*</span><span class="n">edid</span> <span class="o">=</span> <span class="n">closure</span><span class="o">-&gt;</span><span class="n">edid</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">EDID_DETAIL_STD_MODES</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">std_timing</span> <span class="o">*</span><span class="n">std</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="n">newmode</span><span class="p">;</span>

			<span class="n">std</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">timings</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">newmode</span> <span class="o">=</span> <span class="n">drm_mode_std</span><span class="p">(</span><span class="n">connector</span><span class="p">,</span> <span class="n">edid</span><span class="p">,</span> <span class="n">std</span><span class="p">,</span>
					       <span class="n">edid</span><span class="o">-&gt;</span><span class="n">revision</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">newmode</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">drm_mode_probed_add</span><span class="p">(</span><span class="n">connector</span><span class="p">,</span> <span class="n">newmode</span><span class="p">);</span>
				<span class="n">closure</span><span class="o">-&gt;</span><span class="n">modes</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * add_standard_modes - get std. modes from EDID and add them</span>
<span class="cm"> * @edid: EDID block to scan</span>
<span class="cm"> *</span>
<span class="cm"> * Standard modes can be calculated using the appropriate standard (DMT,</span>
<span class="cm"> * GTF or CVT. Grab them from @edid and add them to the list.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">add_standard_modes</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_connector</span> <span class="o">*</span><span class="n">connector</span><span class="p">,</span> <span class="k">struct</span> <span class="n">edid</span> <span class="o">*</span><span class="n">edid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">modes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">detailed_mode_closure</span> <span class="n">closure</span> <span class="o">=</span> <span class="p">{</span>
		<span class="n">connector</span><span class="p">,</span> <span class="n">edid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
	<span class="p">};</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">EDID_STD_TIMINGS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="n">newmode</span><span class="p">;</span>

		<span class="n">newmode</span> <span class="o">=</span> <span class="n">drm_mode_std</span><span class="p">(</span><span class="n">connector</span><span class="p">,</span> <span class="n">edid</span><span class="p">,</span>
				       <span class="o">&amp;</span><span class="n">edid</span><span class="o">-&gt;</span><span class="n">standard_timings</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
				       <span class="n">edid</span><span class="o">-&gt;</span><span class="n">revision</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">newmode</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">drm_mode_probed_add</span><span class="p">(</span><span class="n">connector</span><span class="p">,</span> <span class="n">newmode</span><span class="p">);</span>
			<span class="n">modes</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">version_greater</span><span class="p">(</span><span class="n">edid</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">drm_for_each_detailed_block</span><span class="p">((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">edid</span><span class="p">,</span> <span class="n">do_standard_modes</span><span class="p">,</span>
					    <span class="o">&amp;</span><span class="n">closure</span><span class="p">);</span>

	<span class="cm">/* XXX should also look for standard codes in VTB blocks */</span>

	<span class="k">return</span> <span class="n">modes</span> <span class="o">+</span> <span class="n">closure</span><span class="p">.</span><span class="n">modes</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">drm_cvt_modes</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_connector</span> <span class="o">*</span><span class="n">connector</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">detailed_timing</span> <span class="o">*</span><span class="n">timing</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">modes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="n">newmode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">connector</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cvt_timing</span> <span class="o">*</span><span class="n">cvt</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">rates</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">85</span><span class="p">,</span> <span class="mi">75</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">50</span> <span class="p">};</span>
	<span class="k">const</span> <span class="n">u8</span> <span class="n">empty</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">};</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">uninitialized_var</span><span class="p">(</span><span class="n">width</span><span class="p">),</span> <span class="n">height</span><span class="p">;</span>
		<span class="n">cvt</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">timing</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">other_data</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">cvt</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="n">cvt</span><span class="o">-&gt;</span><span class="n">code</span><span class="p">,</span> <span class="n">empty</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">height</span> <span class="o">=</span> <span class="p">(</span><span class="n">cvt</span><span class="o">-&gt;</span><span class="n">code</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">((</span><span class="n">cvt</span><span class="o">-&gt;</span><span class="n">code</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xf0</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">cvt</span><span class="o">-&gt;</span><span class="n">code</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x0c</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mh">0x00</span>:
			<span class="n">width</span> <span class="o">=</span> <span class="n">height</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">/</span> <span class="mi">3</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mh">0x04</span>:
			<span class="n">width</span> <span class="o">=</span> <span class="n">height</span> <span class="o">*</span> <span class="mi">16</span> <span class="o">/</span> <span class="mi">9</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mh">0x08</span>:
			<span class="n">width</span> <span class="o">=</span> <span class="n">height</span> <span class="o">*</span> <span class="mi">16</span> <span class="o">/</span> <span class="mi">10</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mh">0x0c</span>:
			<span class="n">width</span> <span class="o">=</span> <span class="n">height</span> <span class="o">*</span> <span class="mi">15</span> <span class="o">/</span> <span class="mi">9</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cvt</span><span class="o">-&gt;</span><span class="n">code</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">j</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">newmode</span> <span class="o">=</span> <span class="n">drm_cvt_mode</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span>
						       <span class="n">rates</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span>
						       <span class="nb">false</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">newmode</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">drm_mode_probed_add</span><span class="p">(</span><span class="n">connector</span><span class="p">,</span> <span class="n">newmode</span><span class="p">);</span>
					<span class="n">modes</span><span class="o">++</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">modes</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">do_cvt_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">detailed_timing</span> <span class="o">*</span><span class="n">timing</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">detailed_mode_closure</span> <span class="o">*</span><span class="n">closure</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">detailed_non_pixel</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">timing</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">other_data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">EDID_DETAIL_CVT_3BYTE</span><span class="p">)</span>
		<span class="n">closure</span><span class="o">-&gt;</span><span class="n">modes</span> <span class="o">+=</span> <span class="n">drm_cvt_modes</span><span class="p">(</span><span class="n">closure</span><span class="o">-&gt;</span><span class="n">connector</span><span class="p">,</span> <span class="n">timing</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">add_cvt_modes</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_connector</span> <span class="o">*</span><span class="n">connector</span><span class="p">,</span> <span class="k">struct</span> <span class="n">edid</span> <span class="o">*</span><span class="n">edid</span><span class="p">)</span>
<span class="p">{</span>	
	<span class="k">struct</span> <span class="n">detailed_mode_closure</span> <span class="n">closure</span> <span class="o">=</span> <span class="p">{</span>
		<span class="n">connector</span><span class="p">,</span> <span class="n">edid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
	<span class="p">};</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">version_greater</span><span class="p">(</span><span class="n">edid</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
		<span class="n">drm_for_each_detailed_block</span><span class="p">((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">edid</span><span class="p">,</span> <span class="n">do_cvt_mode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">closure</span><span class="p">);</span>

	<span class="cm">/* XXX should also look for CVT codes in VTB blocks */</span>

	<span class="k">return</span> <span class="n">closure</span><span class="p">.</span><span class="n">modes</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">do_detailed_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">detailed_timing</span> <span class="o">*</span><span class="n">timing</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">detailed_mode_closure</span> <span class="o">*</span><span class="n">closure</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="n">newmode</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">timing</span><span class="o">-&gt;</span><span class="n">pixel_clock</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">newmode</span> <span class="o">=</span> <span class="n">drm_mode_detailed</span><span class="p">(</span><span class="n">closure</span><span class="o">-&gt;</span><span class="n">connector</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					    <span class="n">closure</span><span class="o">-&gt;</span><span class="n">edid</span><span class="p">,</span> <span class="n">timing</span><span class="p">,</span>
					    <span class="n">closure</span><span class="o">-&gt;</span><span class="n">quirks</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">newmode</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">closure</span><span class="o">-&gt;</span><span class="n">preferred</span><span class="p">)</span>
			<span class="n">newmode</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">|=</span> <span class="n">DRM_MODE_TYPE_PREFERRED</span><span class="p">;</span>

		<span class="n">drm_mode_probed_add</span><span class="p">(</span><span class="n">closure</span><span class="o">-&gt;</span><span class="n">connector</span><span class="p">,</span> <span class="n">newmode</span><span class="p">);</span>
		<span class="n">closure</span><span class="o">-&gt;</span><span class="n">modes</span><span class="o">++</span><span class="p">;</span>
		<span class="n">closure</span><span class="o">-&gt;</span><span class="n">preferred</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * add_detailed_modes - Add modes from detailed timings</span>
<span class="cm"> * @connector: attached connector</span>
<span class="cm"> * @edid: EDID block to scan</span>
<span class="cm"> * @quirks: quirks to apply</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">add_detailed_modes</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_connector</span> <span class="o">*</span><span class="n">connector</span><span class="p">,</span> <span class="k">struct</span> <span class="n">edid</span> <span class="o">*</span><span class="n">edid</span><span class="p">,</span>
		   <span class="n">u32</span> <span class="n">quirks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">detailed_mode_closure</span> <span class="n">closure</span> <span class="o">=</span> <span class="p">{</span>
		<span class="n">connector</span><span class="p">,</span>
		<span class="n">edid</span><span class="p">,</span>
		<span class="mi">1</span><span class="p">,</span>
		<span class="n">quirks</span><span class="p">,</span>
		<span class="mi">0</span>
	<span class="p">};</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">closure</span><span class="p">.</span><span class="n">preferred</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">version_greater</span><span class="p">(</span><span class="n">edid</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
		<span class="n">closure</span><span class="p">.</span><span class="n">preferred</span> <span class="o">=</span>
		    <span class="p">(</span><span class="n">edid</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">DRM_EDID_FEATURE_PREFERRED_TIMING</span><span class="p">);</span>

	<span class="n">drm_for_each_detailed_block</span><span class="p">((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">edid</span><span class="p">,</span> <span class="n">do_detailed_mode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">closure</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">closure</span><span class="p">.</span><span class="n">modes</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define HDMI_IDENTIFIER 0x000C03</span>
<span class="cp">#define AUDIO_BLOCK	0x01</span>
<span class="cp">#define VIDEO_BLOCK     0x02</span>
<span class="cp">#define VENDOR_BLOCK    0x03</span>
<span class="cp">#define SPEAKER_BLOCK	0x04</span>
<span class="cp">#define EDID_BASIC_AUDIO	(1 &lt;&lt; 6)</span>
<span class="cp">#define EDID_CEA_YCRCB444	(1 &lt;&lt; 5)</span>
<span class="cp">#define EDID_CEA_YCRCB422	(1 &lt;&lt; 4)</span>

<span class="cm">/**</span>
<span class="cm"> * Search EDID for CEA extension block.</span>
<span class="cm"> */</span>
<span class="n">u8</span> <span class="o">*</span><span class="nf">drm_find_cea_extension</span><span class="p">(</span><span class="k">struct</span> <span class="n">edid</span> <span class="o">*</span><span class="n">edid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">edid_ext</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* No EDID or EDID extensions */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">edid</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">edid</span><span class="o">-&gt;</span><span class="n">extensions</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Find CEA extension */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">edid</span><span class="o">-&gt;</span><span class="n">extensions</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">edid_ext</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">edid</span> <span class="o">+</span> <span class="n">EDID_LENGTH</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">edid_ext</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">CEA_EXT</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">edid</span><span class="o">-&gt;</span><span class="n">extensions</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">edid_ext</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">drm_find_cea_extension</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">do_cea_modes</span> <span class="p">(</span><span class="k">struct</span> <span class="n">drm_connector</span> <span class="o">*</span><span class="n">connector</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">db</span><span class="p">,</span> <span class="n">u8</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">connector</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span> <span class="n">mode</span><span class="p">,</span> <span class="n">cea_mode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">modes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">mode</span> <span class="o">=</span> <span class="n">db</span><span class="p">;</span> <span class="n">mode</span> <span class="o">&lt;</span> <span class="n">db</span> <span class="o">+</span> <span class="n">len</span><span class="p">;</span> <span class="n">mode</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cea_mode</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="mi">127</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* CEA modes are numbered 1..127 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cea_mode</span> <span class="o">&lt;</span> <span class="n">drm_num_cea_modes</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="n">newmode</span><span class="p">;</span>
			<span class="n">newmode</span> <span class="o">=</span> <span class="n">drm_mode_duplicate</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
						     <span class="o">&amp;</span><span class="n">edid_cea_modes</span><span class="p">[</span><span class="n">cea_mode</span><span class="p">]);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">newmode</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">drm_mode_probed_add</span><span class="p">(</span><span class="n">connector</span><span class="p">,</span> <span class="n">newmode</span><span class="p">);</span>
				<span class="n">modes</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">modes</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">add_cea_modes</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_connector</span> <span class="o">*</span><span class="n">connector</span><span class="p">,</span> <span class="k">struct</span> <span class="n">edid</span> <span class="o">*</span><span class="n">edid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="o">*</span> <span class="n">cea</span> <span class="o">=</span> <span class="n">drm_find_cea_extension</span><span class="p">(</span><span class="n">edid</span><span class="p">);</span>
	<span class="n">u8</span> <span class="o">*</span> <span class="n">db</span><span class="p">,</span> <span class="n">dbl</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">modes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cea</span> <span class="o">&amp;&amp;</span> <span class="n">cea</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">db</span> <span class="o">=</span> <span class="n">cea</span> <span class="o">+</span> <span class="mi">4</span><span class="p">;</span> <span class="n">db</span> <span class="o">&lt;</span> <span class="n">cea</span> <span class="o">+</span> <span class="n">cea</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="n">db</span> <span class="o">+=</span> <span class="n">dbl</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dbl</span> <span class="o">=</span> <span class="n">db</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(((</span><span class="n">db</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xe0</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">==</span> <span class="n">VIDEO_BLOCK</span><span class="p">)</span>
				<span class="n">modes</span> <span class="o">+=</span> <span class="n">do_cea_modes</span> <span class="p">(</span><span class="n">connector</span><span class="p">,</span> <span class="n">db</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">dbl</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">modes</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">parse_hdmi_vsdb</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_connector</span> <span class="o">*</span><span class="n">connector</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">db</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">connector</span><span class="o">-&gt;</span><span class="n">eld</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">|=</span> <span class="p">(</span><span class="n">db</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>  <span class="cm">/* Supports_AI */</span>

	<span class="n">connector</span><span class="o">-&gt;</span><span class="n">dvi_dual</span> <span class="o">=</span> <span class="n">db</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">connector</span><span class="o">-&gt;</span><span class="n">max_tmds_clock</span> <span class="o">=</span> <span class="n">db</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">*</span> <span class="mi">5</span><span class="p">;</span>

	<span class="n">connector</span><span class="o">-&gt;</span><span class="n">latency_present</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">db</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">7</span><span class="p">;</span>
	<span class="n">connector</span><span class="o">-&gt;</span><span class="n">latency_present</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">db</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">6</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">connector</span><span class="o">-&gt;</span><span class="n">video_latency</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">db</span><span class="p">[</span><span class="mi">9</span><span class="p">];</span>
	<span class="n">connector</span><span class="o">-&gt;</span><span class="n">audio_latency</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">db</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
	<span class="n">connector</span><span class="o">-&gt;</span><span class="n">video_latency</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">db</span><span class="p">[</span><span class="mi">11</span><span class="p">];</span>
	<span class="n">connector</span><span class="o">-&gt;</span><span class="n">audio_latency</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">db</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>

	<span class="n">DRM_LOG_KMS</span><span class="p">(</span><span class="s">&quot;HDMI: DVI dual %d, &quot;</span>
		    <span class="s">&quot;max TMDS clock %d, &quot;</span>
		    <span class="s">&quot;latency present %d %d, &quot;</span>
		    <span class="s">&quot;video latency %d %d, &quot;</span>
		    <span class="s">&quot;audio latency %d %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		    <span class="n">connector</span><span class="o">-&gt;</span><span class="n">dvi_dual</span><span class="p">,</span>
		    <span class="n">connector</span><span class="o">-&gt;</span><span class="n">max_tmds_clock</span><span class="p">,</span>
	      <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">connector</span><span class="o">-&gt;</span><span class="n">latency_present</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
	      <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">connector</span><span class="o">-&gt;</span><span class="n">latency_present</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
		    <span class="n">connector</span><span class="o">-&gt;</span><span class="n">video_latency</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
		    <span class="n">connector</span><span class="o">-&gt;</span><span class="n">video_latency</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
		    <span class="n">connector</span><span class="o">-&gt;</span><span class="n">audio_latency</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
		    <span class="n">connector</span><span class="o">-&gt;</span><span class="n">audio_latency</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">monitor_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">detailed_timing</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">other_data</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">EDID_DETAIL_MONITOR_NAME</span><span class="p">)</span>
		<span class="o">*</span><span class="p">(</span><span class="n">u8</span> <span class="o">**</span><span class="p">)</span><span class="n">data</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">other_data</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">str</span><span class="p">.</span><span class="n">str</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * drm_edid_to_eld - build ELD from EDID</span>
<span class="cm"> * @connector: connector corresponding to the HDMI/DP sink</span>
<span class="cm"> * @edid: EDID to parse</span>
<span class="cm"> *</span>
<span class="cm"> * Fill the ELD (EDID-Like Data) buffer for passing to the audio driver.</span>
<span class="cm"> * Some ELD fields are left to the graphics driver caller:</span>
<span class="cm"> * - Conn_Type</span>
<span class="cm"> * - HDCP</span>
<span class="cm"> * - Port_ID</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">drm_edid_to_eld</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_connector</span> <span class="o">*</span><span class="n">connector</span><span class="p">,</span> <span class="k">struct</span> <span class="n">edid</span> <span class="o">*</span><span class="n">edid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">eld</span> <span class="o">=</span> <span class="n">connector</span><span class="o">-&gt;</span><span class="n">eld</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">cea</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">db</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sad_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mnl</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dbl</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">eld</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">connector</span><span class="o">-&gt;</span><span class="n">eld</span><span class="p">));</span>

	<span class="n">cea</span> <span class="o">=</span> <span class="n">drm_find_cea_extension</span><span class="p">(</span><span class="n">edid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cea</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DRM_DEBUG_KMS</span><span class="p">(</span><span class="s">&quot;ELD: no CEA Extension found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">name</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">drm_for_each_detailed_block</span><span class="p">((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">edid</span><span class="p">,</span> <span class="n">monitor_name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">name</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">mnl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">name</span> <span class="o">&amp;&amp;</span> <span class="n">mnl</span> <span class="o">&lt;</span> <span class="mi">13</span><span class="p">;</span> <span class="n">mnl</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">name</span><span class="p">[</span><span class="n">mnl</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0x0a</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">eld</span><span class="p">[</span><span class="mi">20</span> <span class="o">+</span> <span class="n">mnl</span><span class="p">]</span> <span class="o">=</span> <span class="n">name</span><span class="p">[</span><span class="n">mnl</span><span class="p">];</span>
	<span class="p">}</span>
	<span class="n">eld</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">cea</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">|</span> <span class="n">mnl</span><span class="p">;</span>
	<span class="n">DRM_DEBUG_KMS</span><span class="p">(</span><span class="s">&quot;ELD monitor %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">eld</span> <span class="o">+</span> <span class="mi">20</span><span class="p">);</span>

	<span class="n">eld</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">;</span>		<span class="cm">/* ELD version: 2 */</span>

	<span class="n">eld</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">=</span> <span class="n">edid</span><span class="o">-&gt;</span><span class="n">mfg_id</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">eld</span><span class="p">[</span><span class="mi">17</span><span class="p">]</span> <span class="o">=</span> <span class="n">edid</span><span class="o">-&gt;</span><span class="n">mfg_id</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">eld</span><span class="p">[</span><span class="mi">18</span><span class="p">]</span> <span class="o">=</span> <span class="n">edid</span><span class="o">-&gt;</span><span class="n">prod_code</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">eld</span><span class="p">[</span><span class="mi">19</span><span class="p">]</span> <span class="o">=</span> <span class="n">edid</span><span class="o">-&gt;</span><span class="n">prod_code</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cea</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">db</span> <span class="o">=</span> <span class="n">cea</span> <span class="o">+</span> <span class="mi">4</span><span class="p">;</span> <span class="n">db</span> <span class="o">&lt;</span> <span class="n">cea</span> <span class="o">+</span> <span class="n">cea</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="n">db</span> <span class="o">+=</span> <span class="n">dbl</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dbl</span> <span class="o">=</span> <span class="n">db</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">;</span>
			
			<span class="k">switch</span> <span class="p">((</span><span class="n">db</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xe0</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">AUDIO_BLOCK</span>:
				<span class="cm">/* Audio Data Block, contains SADs */</span>
				<span class="n">sad_count</span> <span class="o">=</span> <span class="n">dbl</span> <span class="o">/</span> <span class="mi">3</span><span class="p">;</span>
				<span class="n">memcpy</span><span class="p">(</span><span class="n">eld</span> <span class="o">+</span> <span class="mi">20</span> <span class="o">+</span> <span class="n">mnl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">db</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dbl</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">SPEAKER_BLOCK</span>:
                                <span class="cm">/* Speaker Allocation Data Block */</span>
				<span class="n">eld</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="n">db</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">VENDOR_BLOCK</span>:
				<span class="cm">/* HDMI Vendor-Specific Data Block */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">db</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0x03</span> <span class="o">&amp;&amp;</span> <span class="n">db</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0x0c</span> <span class="o">&amp;&amp;</span> <span class="n">db</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
					<span class="n">parse_hdmi_vsdb</span><span class="p">(</span><span class="n">connector</span><span class="p">,</span> <span class="n">db</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="nl">default:</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="n">eld</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">|=</span> <span class="n">sad_count</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">;</span>
	<span class="n">eld</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">20</span> <span class="o">+</span> <span class="n">mnl</span> <span class="o">+</span> <span class="n">sad_count</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span>

	<span class="n">DRM_DEBUG_KMS</span><span class="p">(</span><span class="s">&quot;ELD size %d, SAD count %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">eld</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">sad_count</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">drm_edid_to_eld</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * drm_av_sync_delay - HDMI/DP sink audio-video sync delay in millisecond</span>
<span class="cm"> * @connector: connector associated with the HDMI/DP sink</span>
<span class="cm"> * @mode: the display mode</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">drm_av_sync_delay</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_connector</span> <span class="o">*</span><span class="n">connector</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="o">!!</span><span class="p">(</span><span class="n">mode</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DRM_MODE_FLAG_INTERLACE</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">v</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">connector</span><span class="o">-&gt;</span><span class="n">latency_present</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">connector</span><span class="o">-&gt;</span><span class="n">latency_present</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
		<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">a</span> <span class="o">=</span> <span class="n">connector</span><span class="o">-&gt;</span><span class="n">audio_latency</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="n">v</span> <span class="o">=</span> <span class="n">connector</span><span class="o">-&gt;</span><span class="n">video_latency</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 * HDMI/DP sink doesn&#39;t support audio or video?</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="mi">255</span> <span class="o">||</span> <span class="n">v</span> <span class="o">==</span> <span class="mi">255</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Convert raw EDID values to millisecond.</span>
<span class="cm">	 * Treat unknown latency as 0ms.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">)</span>
		<span class="n">a</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">500</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">v</span><span class="p">)</span>
		<span class="n">v</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">v</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">500</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">max</span><span class="p">(</span><span class="n">v</span> <span class="o">-</span> <span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">drm_av_sync_delay</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * drm_select_eld - select one ELD from multiple HDMI/DP sinks</span>
<span class="cm"> * @encoder: the encoder just changed display mode</span>
<span class="cm"> * @mode: the adjusted display mode</span>
<span class="cm"> *</span>
<span class="cm"> * It&#39;s possible for one encoder to be associated with multiple HDMI/DP sinks.</span>
<span class="cm"> * The policy is now hard coded to simply use the first HDMI/DP sink&#39;s ELD.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">drm_connector</span> <span class="o">*</span><span class="nf">drm_select_eld</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_encoder</span> <span class="o">*</span><span class="n">encoder</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drm_connector</span> <span class="o">*</span><span class="n">connector</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">encoder</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">connector</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mode_config</span><span class="p">.</span><span class="n">connector_list</span><span class="p">,</span> <span class="n">head</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">connector</span><span class="o">-&gt;</span><span class="n">encoder</span> <span class="o">==</span> <span class="n">encoder</span> <span class="o">&amp;&amp;</span> <span class="n">connector</span><span class="o">-&gt;</span><span class="n">eld</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
			<span class="k">return</span> <span class="n">connector</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">drm_select_eld</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * drm_detect_hdmi_monitor - detect whether monitor is hdmi.</span>
<span class="cm"> * @edid: monitor EDID information</span>
<span class="cm"> *</span>
<span class="cm"> * Parse the CEA extension according to CEA-861-B.</span>
<span class="cm"> * Return true if HDMI, false if not or unknown.</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="nf">drm_detect_hdmi_monitor</span><span class="p">(</span><span class="k">struct</span> <span class="n">edid</span> <span class="o">*</span><span class="n">edid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">edid_ext</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">hdmi_id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">start_offset</span><span class="p">,</span> <span class="n">end_offset</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">is_hdmi</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">edid_ext</span> <span class="o">=</span> <span class="n">drm_find_cea_extension</span><span class="p">(</span><span class="n">edid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">edid_ext</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">end</span><span class="p">;</span>

	<span class="cm">/* Data block offset in CEA extension block */</span>
	<span class="n">start_offset</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="n">end_offset</span> <span class="o">=</span> <span class="n">edid_ext</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 * Because HDMI identifier is in Vendor Specific Block,</span>
<span class="cm">	 * search it from all data blocks of CEA extension.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">start_offset</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">end_offset</span><span class="p">;</span>
		<span class="cm">/* Increased by data block len */</span>
		<span class="n">i</span> <span class="o">+=</span> <span class="p">((</span><span class="n">edid_ext</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Find vendor specific block */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">edid_ext</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">==</span> <span class="n">VENDOR_BLOCK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">hdmi_id</span> <span class="o">=</span> <span class="n">edid_ext</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">|</span> <span class="p">(</span><span class="n">edid_ext</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span>
				  <span class="n">edid_ext</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">3</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
			<span class="cm">/* Find HDMI identifier */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hdmi_id</span> <span class="o">==</span> <span class="n">HDMI_IDENTIFIER</span><span class="p">)</span>
				<span class="n">is_hdmi</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">end:</span>
	<span class="k">return</span> <span class="n">is_hdmi</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">drm_detect_hdmi_monitor</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * drm_detect_monitor_audio - check monitor audio capability</span>
<span class="cm"> *</span>
<span class="cm"> * Monitor should have CEA extension block.</span>
<span class="cm"> * If monitor has &#39;basic audio&#39;, but no CEA audio blocks, it&#39;s &#39;basic</span>
<span class="cm"> * audio&#39; only. If there is any audio extension block and supported</span>
<span class="cm"> * audio format, assume at least &#39;basic audio&#39; support, even if &#39;basic</span>
<span class="cm"> * audio&#39; is not defined in EDID.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="nf">drm_detect_monitor_audio</span><span class="p">(</span><span class="k">struct</span> <span class="n">edid</span> <span class="o">*</span><span class="n">edid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">edid_ext</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">has_audio</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">start_offset</span><span class="p">,</span> <span class="n">end_offset</span><span class="p">;</span>

	<span class="n">edid_ext</span> <span class="o">=</span> <span class="n">drm_find_cea_extension</span><span class="p">(</span><span class="n">edid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">edid_ext</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">end</span><span class="p">;</span>

	<span class="n">has_audio</span> <span class="o">=</span> <span class="p">((</span><span class="n">edid_ext</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">EDID_BASIC_AUDIO</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">has_audio</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DRM_DEBUG_KMS</span><span class="p">(</span><span class="s">&quot;Monitor has basic audio support</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">end</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Data block offset in CEA extension block */</span>
	<span class="n">start_offset</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="n">end_offset</span> <span class="o">=</span> <span class="n">edid_ext</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">start_offset</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">end_offset</span><span class="p">;</span>
			<span class="n">i</span> <span class="o">+=</span> <span class="p">((</span><span class="n">edid_ext</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">edid_ext</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">==</span> <span class="n">AUDIO_BLOCK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">has_audio</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">edid_ext</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">);</span> <span class="n">j</span> <span class="o">+=</span> <span class="mi">3</span><span class="p">)</span>
				<span class="n">DRM_DEBUG_KMS</span><span class="p">(</span><span class="s">&quot;CEA audio format %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					      <span class="p">(</span><span class="n">edid_ext</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">end</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">end:</span>
	<span class="k">return</span> <span class="n">has_audio</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">drm_detect_monitor_audio</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * drm_add_display_info - pull display info out if present</span>
<span class="cm"> * @edid: EDID data</span>
<span class="cm"> * @info: display info (attached to connector)</span>
<span class="cm"> *</span>
<span class="cm"> * Grab any available display info and stuff it into the drm_display_info</span>
<span class="cm"> * structure that&#39;s part of the connector.  Useful for tracking bpp and</span>
<span class="cm"> * color spaces.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">drm_add_display_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">edid</span> <span class="o">*</span><span class="n">edid</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">drm_display_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">edid_ext</span><span class="p">;</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">width_mm</span> <span class="o">=</span> <span class="n">edid</span><span class="o">-&gt;</span><span class="n">width_cm</span> <span class="o">*</span> <span class="mi">10</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">height_mm</span> <span class="o">=</span> <span class="n">edid</span><span class="o">-&gt;</span><span class="n">height_cm</span> <span class="o">*</span> <span class="mi">10</span><span class="p">;</span>

	<span class="cm">/* driver figures it out in this case */</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">bpc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">color_formats</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">edid</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">edid</span><span class="o">-&gt;</span><span class="n">input</span> <span class="o">&amp;</span> <span class="n">DRM_EDID_INPUT_DIGITAL</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Get data from CEA blocks if present */</span>
	<span class="n">edid_ext</span> <span class="o">=</span> <span class="n">drm_find_cea_extension</span><span class="p">(</span><span class="n">edid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">edid_ext</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">cea_rev</span> <span class="o">=</span> <span class="n">edid_ext</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

		<span class="cm">/* The existence of a CEA block should imply RGB support */</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">color_formats</span> <span class="o">=</span> <span class="n">DRM_COLOR_FORMAT_RGB444</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">edid_ext</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">EDID_CEA_YCRCB444</span><span class="p">)</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">color_formats</span> <span class="o">|=</span> <span class="n">DRM_COLOR_FORMAT_YCRCB444</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">edid_ext</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">EDID_CEA_YCRCB422</span><span class="p">)</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">color_formats</span> <span class="o">|=</span> <span class="n">DRM_COLOR_FORMAT_YCRCB422</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Only defined for 1.4 with digital displays */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">edid</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">edid</span><span class="o">-&gt;</span><span class="n">input</span> <span class="o">&amp;</span> <span class="n">DRM_EDID_DIGITAL_DEPTH_MASK</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">DRM_EDID_DIGITAL_DEPTH_6</span>:
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">bpc</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DRM_EDID_DIGITAL_DEPTH_8</span>:
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">bpc</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DRM_EDID_DIGITAL_DEPTH_10</span>:
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">bpc</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DRM_EDID_DIGITAL_DEPTH_12</span>:
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">bpc</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DRM_EDID_DIGITAL_DEPTH_14</span>:
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">bpc</span> <span class="o">=</span> <span class="mi">14</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DRM_EDID_DIGITAL_DEPTH_16</span>:
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">bpc</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DRM_EDID_DIGITAL_DEPTH_UNDEF</span>:
	<span class="nl">default:</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">bpc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">color_formats</span> <span class="o">|=</span> <span class="n">DRM_COLOR_FORMAT_RGB444</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">edid</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">DRM_EDID_FEATURE_RGB_YCRCB444</span><span class="p">)</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">color_formats</span> <span class="o">|=</span> <span class="n">DRM_COLOR_FORMAT_YCRCB444</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">edid</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">DRM_EDID_FEATURE_RGB_YCRCB422</span><span class="p">)</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">color_formats</span> <span class="o">|=</span> <span class="n">DRM_COLOR_FORMAT_YCRCB422</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * drm_add_edid_modes - add modes from EDID data, if available</span>
<span class="cm"> * @connector: connector we&#39;re probing</span>
<span class="cm"> * @edid: edid data</span>
<span class="cm"> *</span>
<span class="cm"> * Add the specified modes to the connector&#39;s mode list.</span>
<span class="cm"> *</span>
<span class="cm"> * Return number of modes added or 0 if we couldn&#39;t find any.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">drm_add_edid_modes</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_connector</span> <span class="o">*</span><span class="n">connector</span><span class="p">,</span> <span class="k">struct</span> <span class="n">edid</span> <span class="o">*</span><span class="n">edid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">num_modes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">quirks</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">edid</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">drm_edid_is_valid</span><span class="p">(</span><span class="n">edid</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">connector</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: EDID invalid.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">drm_get_connector_name</span><span class="p">(</span><span class="n">connector</span><span class="p">));</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">quirks</span> <span class="o">=</span> <span class="n">edid_get_quirks</span><span class="p">(</span><span class="n">edid</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * EDID spec says modes should be preferred in this order:</span>
<span class="cm">	 * - preferred detailed mode</span>
<span class="cm">	 * - other detailed modes from base block</span>
<span class="cm">	 * - detailed modes from extension blocks</span>
<span class="cm">	 * - CVT 3-byte code modes</span>
<span class="cm">	 * - standard timing codes</span>
<span class="cm">	 * - established timing codes</span>
<span class="cm">	 * - modes inferred from GTF or CVT range information</span>
<span class="cm">	 *</span>
<span class="cm">	 * We get this pretty much right.</span>
<span class="cm">	 *</span>
<span class="cm">	 * XXX order for additional mode types in extension blocks?</span>
<span class="cm">	 */</span>
	<span class="n">num_modes</span> <span class="o">+=</span> <span class="n">add_detailed_modes</span><span class="p">(</span><span class="n">connector</span><span class="p">,</span> <span class="n">edid</span><span class="p">,</span> <span class="n">quirks</span><span class="p">);</span>
	<span class="n">num_modes</span> <span class="o">+=</span> <span class="n">add_cvt_modes</span><span class="p">(</span><span class="n">connector</span><span class="p">,</span> <span class="n">edid</span><span class="p">);</span>
	<span class="n">num_modes</span> <span class="o">+=</span> <span class="n">add_standard_modes</span><span class="p">(</span><span class="n">connector</span><span class="p">,</span> <span class="n">edid</span><span class="p">);</span>
	<span class="n">num_modes</span> <span class="o">+=</span> <span class="n">add_established_modes</span><span class="p">(</span><span class="n">connector</span><span class="p">,</span> <span class="n">edid</span><span class="p">);</span>
	<span class="n">num_modes</span> <span class="o">+=</span> <span class="n">add_inferred_modes</span><span class="p">(</span><span class="n">connector</span><span class="p">,</span> <span class="n">edid</span><span class="p">);</span>
	<span class="n">num_modes</span> <span class="o">+=</span> <span class="n">add_cea_modes</span><span class="p">(</span><span class="n">connector</span><span class="p">,</span> <span class="n">edid</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">EDID_QUIRK_PREFER_LARGE_60</span> <span class="o">|</span> <span class="n">EDID_QUIRK_PREFER_LARGE_75</span><span class="p">))</span>
		<span class="n">edid_fixup_preferred</span><span class="p">(</span><span class="n">connector</span><span class="p">,</span> <span class="n">quirks</span><span class="p">);</span>

	<span class="n">drm_add_display_info</span><span class="p">(</span><span class="n">edid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">connector</span><span class="o">-&gt;</span><span class="n">display_info</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">num_modes</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">drm_add_edid_modes</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * drm_add_modes_noedid - add modes for the connectors without EDID</span>
<span class="cm"> * @connector: connector we&#39;re probing</span>
<span class="cm"> * @hdisplay: the horizontal display limit</span>
<span class="cm"> * @vdisplay: the vertical display limit</span>
<span class="cm"> *</span>
<span class="cm"> * Add the specified modes to the connector&#39;s mode list. Only when the</span>
<span class="cm"> * hdisplay/vdisplay is not beyond the given limit, it will be added.</span>
<span class="cm"> *</span>
<span class="cm"> * Return number of modes added or 0 if we couldn&#39;t find any.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">drm_add_modes_noedid</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_connector</span> <span class="o">*</span><span class="n">connector</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">hdisplay</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vdisplay</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">num_modes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="n">mode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">connector</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="n">count</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">drm_dmt_modes</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_display_mode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hdisplay</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">hdisplay</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vdisplay</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">vdisplay</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">drm_dmt_modes</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hdisplay</span> <span class="o">&amp;&amp;</span> <span class="n">vdisplay</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Only when two are valid, they will be used to check</span>
<span class="cm">			 * whether the mode should be added to the mode list of</span>
<span class="cm">			 * the connector.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">hdisplay</span> <span class="o">&gt;</span> <span class="n">hdisplay</span> <span class="o">||</span>
					<span class="n">ptr</span><span class="o">-&gt;</span><span class="n">vdisplay</span> <span class="o">&gt;</span> <span class="n">vdisplay</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">drm_mode_vrefresh</span><span class="p">(</span><span class="n">ptr</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">61</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">mode</span> <span class="o">=</span> <span class="n">drm_mode_duplicate</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">drm_mode_probed_add</span><span class="p">(</span><span class="n">connector</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
			<span class="n">num_modes</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">num_modes</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">drm_add_modes_noedid</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
