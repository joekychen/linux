<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › gpu › vga › vgaarb.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>vgaarb.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * vgaarb.c: Implements the VGA arbitration. For details refer to</span>
<span class="cm"> * Documentation/vgaarbiter.txt</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * (C) Copyright 2005 Benjamin Herrenschmidt &lt;benh@kernel.crashing.org&gt;</span>
<span class="cm"> * (C) Copyright 2007 Paulo R. Zanoni &lt;przanoni@gmail.com&gt;</span>
<span class="cm"> * (C) Copyright 2007, 2009 Tiago Vignatti &lt;vignatti@freedesktop.org&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Permission is hereby granted, free of charge, to any person obtaining a</span>
<span class="cm"> * copy of this software and associated documentation files (the &quot;Software&quot;),</span>
<span class="cm"> * to deal in the Software without restriction, including without limitation</span>
<span class="cm"> * the rights to use, copy, modify, merge, publish, distribute, sublicense,</span>
<span class="cm"> * and/or sell copies of the Software, and to permit persons to whom the</span>
<span class="cm"> * Software is furnished to do so, subject to the following conditions:</span>
<span class="cm"> *</span>
<span class="cm"> * The above copyright notice and this permission notice (including the next</span>
<span class="cm"> * paragraph) shall be included in all copies or substantial portions of the</span>
<span class="cm"> * Software.</span>
<span class="cm"> *</span>
<span class="cm"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span>
<span class="cm"> * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL</span>
<span class="cm"> * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span>
<span class="cm"> * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING</span>
<span class="cm"> * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER</span>
<span class="cm"> * DEALINGS</span>
<span class="cm"> * IN THE SOFTWARE.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/wait.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/poll.h&gt;</span>
<span class="cp">#include &lt;linux/miscdevice.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>

<span class="cp">#include &lt;linux/uaccess.h&gt;</span>

<span class="cp">#include &lt;linux/vgaarb.h&gt;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">vga_arbiter_notify_clients</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cm">/*</span>
<span class="cm"> * We keep a list of all vga devices in the system to speed</span>
<span class="cm"> * up the various operations of the arbiter</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">vga_device</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">decodes</span><span class="p">;</span>	<span class="cm">/* what does it decodes */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">owns</span><span class="p">;</span>	<span class="cm">/* what does it owns */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">locks</span><span class="p">;</span>	<span class="cm">/* what does it locks */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">io_lock_cnt</span><span class="p">;</span>	<span class="cm">/* legacy IO lock count */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mem_lock_cnt</span><span class="p">;</span>	<span class="cm">/* legacy MEM lock count */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">io_norm_cnt</span><span class="p">;</span>	<span class="cm">/* normal IO count */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mem_norm_cnt</span><span class="p">;</span>	<span class="cm">/* normal MEM count */</span>
	<span class="n">bool</span> <span class="n">bridge_has_one_vga</span><span class="p">;</span>
	<span class="cm">/* allow IRQ enable/disable hook */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">cookie</span><span class="p">;</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">irq_set_state</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">cookie</span><span class="p">,</span> <span class="n">bool</span> <span class="n">enable</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">set_vga_decode</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">cookie</span><span class="p">,</span> <span class="n">bool</span> <span class="n">decode</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">vga_list</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">vga_count</span><span class="p">,</span> <span class="n">vga_decode_count</span><span class="p">;</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">vga_arbiter_used</span><span class="p">;</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">vga_lock</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DECLARE_WAIT_QUEUE_HEAD</span><span class="p">(</span><span class="n">vga_wait_queue</span><span class="p">);</span>


<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">vga_iostate_to_str</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">iostate</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Ignore VGA_RSRC_IO and VGA_RSRC_MEM */</span>
	<span class="n">iostate</span> <span class="o">&amp;=</span> <span class="n">VGA_RSRC_LEGACY_IO</span> <span class="o">|</span> <span class="n">VGA_RSRC_LEGACY_MEM</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">iostate</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">VGA_RSRC_LEGACY_IO</span> <span class="o">|</span> <span class="n">VGA_RSRC_LEGACY_MEM</span>:
		<span class="k">return</span> <span class="s">&quot;io+mem&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">VGA_RSRC_LEGACY_IO</span>:
		<span class="k">return</span> <span class="s">&quot;io&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">VGA_RSRC_LEGACY_MEM</span>:
		<span class="k">return</span> <span class="s">&quot;mem&quot;</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="s">&quot;none&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vga_str_to_iostate</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">str_size</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">io_state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* we could in theory hand out locks on IO and mem</span>
<span class="cm">	 * separately to userspace but it can cause deadlocks */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;none&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">io_state</span> <span class="o">=</span> <span class="n">VGA_RSRC_NONE</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* XXX We&#39;re not chekcing the str_size! */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;io+mem&quot;</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">both</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;io&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">both</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;mem&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">both</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">both:</span>
	<span class="o">*</span><span class="n">io_state</span> <span class="o">=</span> <span class="n">VGA_RSRC_LEGACY_IO</span> <span class="o">|</span> <span class="n">VGA_RSRC_LEGACY_MEM</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifndef __ARCH_HAS_VGA_DEFAULT_DEVICE</span>
<span class="cm">/* this is only used a cookie - it should not be dereferenced */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">vga_default</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">vga_arb_device_card_gone</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">);</span>

<span class="cm">/* Find somebody in our list */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">vga_device</span> <span class="o">*</span><span class="nf">vgadev_find</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vga_device</span> <span class="o">*</span><span class="n">vgadev</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">vgadev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vga_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pdev</span> <span class="o">==</span> <span class="n">vgadev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">vgadev</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Returns the default VGA device (vgacon&#39;s babe) */</span>
<span class="cp">#ifndef __ARCH_HAS_VGA_DEFAULT_DEVICE</span>
<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="nf">vga_default_device</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">vga_default</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">vga_default_device</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">vga_set_default_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vga_default</span> <span class="o">=</span> <span class="n">pdev</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">vga_irq_set_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">vga_device</span> <span class="o">*</span><span class="n">vgadev</span><span class="p">,</span> <span class="n">bool</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vgadev</span><span class="o">-&gt;</span><span class="n">irq_set_state</span><span class="p">)</span>
		<span class="n">vgadev</span><span class="o">-&gt;</span><span class="n">irq_set_state</span><span class="p">(</span><span class="n">vgadev</span><span class="o">-&gt;</span><span class="n">cookie</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/* If we don&#39;t ever use VGA arb we should avoid</span>
<span class="cm">   turning off anything anywhere due to old X servers getting</span>
<span class="cm">   confused about the boot device not being VGA */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">vga_check_first_use</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* we should inform all GPUs in the system that</span>
<span class="cm">	 * VGA arb has occurred and to try and disable resources</span>
<span class="cm">	 * if they can */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vga_arbiter_used</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vga_arbiter_used</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">vga_arbiter_notify_clients</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">vga_device</span> <span class="o">*</span><span class="nf">__vga_tryget</span><span class="p">(</span><span class="k">struct</span> <span class="n">vga_device</span> <span class="o">*</span><span class="n">vgadev</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rsrc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">wants</span><span class="p">,</span> <span class="n">legacy_wants</span><span class="p">,</span> <span class="n">match</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vga_device</span> <span class="o">*</span><span class="n">conflict</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pci_bits</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Account for &quot;normal&quot; resources to lock. If we decode the legacy,</span>
<span class="cm">	 * counterpart, we need to request it as well</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">rsrc</span> <span class="o">&amp;</span> <span class="n">VGA_RSRC_NORMAL_IO</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">vgadev</span><span class="o">-&gt;</span><span class="n">decodes</span> <span class="o">&amp;</span> <span class="n">VGA_RSRC_LEGACY_IO</span><span class="p">))</span>
		<span class="n">rsrc</span> <span class="o">|=</span> <span class="n">VGA_RSRC_LEGACY_IO</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">rsrc</span> <span class="o">&amp;</span> <span class="n">VGA_RSRC_NORMAL_MEM</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">vgadev</span><span class="o">-&gt;</span><span class="n">decodes</span> <span class="o">&amp;</span> <span class="n">VGA_RSRC_LEGACY_MEM</span><span class="p">))</span>
		<span class="n">rsrc</span> <span class="o">|=</span> <span class="n">VGA_RSRC_LEGACY_MEM</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">rsrc</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: owns: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">vgadev</span><span class="o">-&gt;</span><span class="n">owns</span><span class="p">);</span>

	<span class="cm">/* Check what resources we need to acquire */</span>
	<span class="n">wants</span> <span class="o">=</span> <span class="n">rsrc</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">vgadev</span><span class="o">-&gt;</span><span class="n">owns</span><span class="p">;</span>

	<span class="cm">/* We already own everything, just mark locked &amp; bye bye */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wants</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">lock_them</span><span class="p">;</span>

	<span class="cm">/* We don&#39;t need to request a legacy resource, we just enable</span>
<span class="cm">	 * appropriate decoding and go</span>
<span class="cm">	 */</span>
	<span class="n">legacy_wants</span> <span class="o">=</span> <span class="n">wants</span> <span class="o">&amp;</span> <span class="n">VGA_RSRC_LEGACY_MASK</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">legacy_wants</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">enable_them</span><span class="p">;</span>

	<span class="cm">/* Ok, we don&#39;t, let&#39;s find out how we need to kick off */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">conflict</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vga_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lwants</span> <span class="o">=</span> <span class="n">legacy_wants</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">change_bridge</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* Don&#39;t conflict with myself */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vgadev</span> <span class="o">==</span> <span class="n">conflict</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* Check if the architecture allows a conflict between those</span>
<span class="cm">		 * 2 devices or if they are on separate domains</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vga_conflicts</span><span class="p">(</span><span class="n">vgadev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">conflict</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* We have a possible conflict. before we go further, we must</span>
<span class="cm">		 * check if we sit on the same bus as the conflicting device.</span>
<span class="cm">		 * if we don&#39;t, then we must tie both IO and MEM resources</span>
<span class="cm">		 * together since there is only a single bit controlling</span>
<span class="cm">		 * VGA forwarding on P2P bridges</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vgadev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">bus</span> <span class="o">!=</span> <span class="n">conflict</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">change_bridge</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">lwants</span> <span class="o">=</span> <span class="n">VGA_RSRC_LEGACY_IO</span> <span class="o">|</span> <span class="n">VGA_RSRC_LEGACY_MEM</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Check if the guy has a lock on the resource. If he does,</span>
<span class="cm">		 * return the conflicting entry</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">conflict</span><span class="o">-&gt;</span><span class="n">locks</span> <span class="o">&amp;</span> <span class="n">lwants</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">conflict</span><span class="p">;</span>

		<span class="cm">/* Ok, now check if he owns the resource we want. We don&#39;t need</span>
<span class="cm">		 * to check &quot;decodes&quot; since it should be impossible to own</span>
<span class="cm">		 * own legacy resources you don&#39;t decode unless I have a bug</span>
<span class="cm">		 * in this code...</span>
<span class="cm">		 */</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">conflict</span><span class="o">-&gt;</span><span class="n">owns</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">conflict</span><span class="o">-&gt;</span><span class="n">decodes</span><span class="p">);</span>
		<span class="n">match</span> <span class="o">=</span> <span class="n">lwants</span> <span class="o">&amp;</span> <span class="n">conflict</span><span class="o">-&gt;</span><span class="n">owns</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">match</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* looks like he doesn&#39;t have a lock, we can steal</span>
<span class="cm">		 * them from him</span>
<span class="cm">		 */</span>

		<span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">pci_bits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">conflict</span><span class="o">-&gt;</span><span class="n">bridge_has_one_vga</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">vga_irq_set_state</span><span class="p">(</span><span class="n">conflict</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
			<span class="n">flags</span> <span class="o">|=</span> <span class="n">PCI_VGA_STATE_CHANGE_DECODES</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lwants</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">VGA_RSRC_LEGACY_MEM</span><span class="o">|</span><span class="n">VGA_RSRC_NORMAL_MEM</span><span class="p">))</span>
				<span class="n">pci_bits</span> <span class="o">|=</span> <span class="n">PCI_COMMAND_MEMORY</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lwants</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">VGA_RSRC_LEGACY_IO</span><span class="o">|</span><span class="n">VGA_RSRC_NORMAL_IO</span><span class="p">))</span>
				<span class="n">pci_bits</span> <span class="o">|=</span> <span class="n">PCI_COMMAND_IO</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">change_bridge</span><span class="p">)</span>
			<span class="n">flags</span> <span class="o">|=</span> <span class="n">PCI_VGA_STATE_CHANGE_BRIDGE</span><span class="p">;</span>

		<span class="n">pci_set_vga_state</span><span class="p">(</span><span class="n">conflict</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="n">pci_bits</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">conflict</span><span class="o">-&gt;</span><span class="n">owns</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">lwants</span><span class="p">;</span>
		<span class="cm">/* If he also owned non-legacy, that is no longer the case */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lwants</span> <span class="o">&amp;</span> <span class="n">VGA_RSRC_LEGACY_MEM</span><span class="p">)</span>
			<span class="n">conflict</span><span class="o">-&gt;</span><span class="n">owns</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">VGA_RSRC_NORMAL_MEM</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lwants</span> <span class="o">&amp;</span> <span class="n">VGA_RSRC_LEGACY_IO</span><span class="p">)</span>
			<span class="n">conflict</span><span class="o">-&gt;</span><span class="n">owns</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">VGA_RSRC_NORMAL_IO</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">enable_them:</span>
	<span class="cm">/* ok dude, we got it, everybody conflicting has been disabled, let&#39;s</span>
<span class="cm">	 * enable us. Make sure we don&#39;t mark a bit in &quot;owns&quot; that we don&#39;t</span>
<span class="cm">	 * also have in &quot;decodes&quot;. We can lock resources we don&#39;t decode but</span>
<span class="cm">	 * not own them.</span>
<span class="cm">	 */</span>
	<span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pci_bits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vgadev</span><span class="o">-&gt;</span><span class="n">bridge_has_one_vga</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">PCI_VGA_STATE_CHANGE_DECODES</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wants</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">VGA_RSRC_LEGACY_MEM</span><span class="o">|</span><span class="n">VGA_RSRC_NORMAL_MEM</span><span class="p">))</span>
			<span class="n">pci_bits</span> <span class="o">|=</span> <span class="n">PCI_COMMAND_MEMORY</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wants</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">VGA_RSRC_LEGACY_IO</span><span class="o">|</span><span class="n">VGA_RSRC_NORMAL_IO</span><span class="p">))</span>
			<span class="n">pci_bits</span> <span class="o">|=</span> <span class="n">PCI_COMMAND_IO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!!</span><span class="p">(</span><span class="n">wants</span> <span class="o">&amp;</span> <span class="n">VGA_RSRC_LEGACY_MASK</span><span class="p">))</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">PCI_VGA_STATE_CHANGE_BRIDGE</span><span class="p">;</span>

	<span class="n">pci_set_vga_state</span><span class="p">(</span><span class="n">vgadev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="n">pci_bits</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vgadev</span><span class="o">-&gt;</span><span class="n">bridge_has_one_vga</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vga_irq_set_state</span><span class="p">(</span><span class="n">vgadev</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">vgadev</span><span class="o">-&gt;</span><span class="n">owns</span> <span class="o">|=</span> <span class="p">(</span><span class="n">wants</span> <span class="o">&amp;</span> <span class="n">vgadev</span><span class="o">-&gt;</span><span class="n">decodes</span><span class="p">);</span>
<span class="nl">lock_them:</span>
	<span class="n">vgadev</span><span class="o">-&gt;</span><span class="n">locks</span> <span class="o">|=</span> <span class="p">(</span><span class="n">rsrc</span> <span class="o">&amp;</span> <span class="n">VGA_RSRC_LEGACY_MASK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rsrc</span> <span class="o">&amp;</span> <span class="n">VGA_RSRC_LEGACY_IO</span><span class="p">)</span>
		<span class="n">vgadev</span><span class="o">-&gt;</span><span class="n">io_lock_cnt</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rsrc</span> <span class="o">&amp;</span> <span class="n">VGA_RSRC_LEGACY_MEM</span><span class="p">)</span>
		<span class="n">vgadev</span><span class="o">-&gt;</span><span class="n">mem_lock_cnt</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rsrc</span> <span class="o">&amp;</span> <span class="n">VGA_RSRC_NORMAL_IO</span><span class="p">)</span>
		<span class="n">vgadev</span><span class="o">-&gt;</span><span class="n">io_norm_cnt</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rsrc</span> <span class="o">&amp;</span> <span class="n">VGA_RSRC_NORMAL_MEM</span><span class="p">)</span>
		<span class="n">vgadev</span><span class="o">-&gt;</span><span class="n">mem_norm_cnt</span><span class="o">++</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__vga_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">vga_device</span> <span class="o">*</span><span class="n">vgadev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rsrc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">old_locks</span> <span class="o">=</span> <span class="n">vgadev</span><span class="o">-&gt;</span><span class="n">locks</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="cm">/* Update our counters, and account for equivalent legacy resources</span>
<span class="cm">	 * if we decode them</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">rsrc</span> <span class="o">&amp;</span> <span class="n">VGA_RSRC_NORMAL_IO</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">vgadev</span><span class="o">-&gt;</span><span class="n">io_norm_cnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vgadev</span><span class="o">-&gt;</span><span class="n">io_norm_cnt</span><span class="o">--</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vgadev</span><span class="o">-&gt;</span><span class="n">decodes</span> <span class="o">&amp;</span> <span class="n">VGA_RSRC_LEGACY_IO</span><span class="p">)</span>
			<span class="n">rsrc</span> <span class="o">|=</span> <span class="n">VGA_RSRC_LEGACY_IO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">rsrc</span> <span class="o">&amp;</span> <span class="n">VGA_RSRC_NORMAL_MEM</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">vgadev</span><span class="o">-&gt;</span><span class="n">mem_norm_cnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vgadev</span><span class="o">-&gt;</span><span class="n">mem_norm_cnt</span><span class="o">--</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vgadev</span><span class="o">-&gt;</span><span class="n">decodes</span> <span class="o">&amp;</span> <span class="n">VGA_RSRC_LEGACY_MEM</span><span class="p">)</span>
			<span class="n">rsrc</span> <span class="o">|=</span> <span class="n">VGA_RSRC_LEGACY_MEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">rsrc</span> <span class="o">&amp;</span> <span class="n">VGA_RSRC_LEGACY_IO</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">vgadev</span><span class="o">-&gt;</span><span class="n">io_lock_cnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">vgadev</span><span class="o">-&gt;</span><span class="n">io_lock_cnt</span><span class="o">--</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">rsrc</span> <span class="o">&amp;</span> <span class="n">VGA_RSRC_LEGACY_MEM</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">vgadev</span><span class="o">-&gt;</span><span class="n">mem_lock_cnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">vgadev</span><span class="o">-&gt;</span><span class="n">mem_lock_cnt</span><span class="o">--</span><span class="p">;</span>

	<span class="cm">/* Just clear lock bits, we do lazy operations so we don&#39;t really</span>
<span class="cm">	 * have to bother about anything else at this point</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vgadev</span><span class="o">-&gt;</span><span class="n">io_lock_cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">vgadev</span><span class="o">-&gt;</span><span class="n">locks</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">VGA_RSRC_LEGACY_IO</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vgadev</span><span class="o">-&gt;</span><span class="n">mem_lock_cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">vgadev</span><span class="o">-&gt;</span><span class="n">locks</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">VGA_RSRC_LEGACY_MEM</span><span class="p">;</span>

	<span class="cm">/* Kick the wait queue in case somebody was waiting if we actually</span>
<span class="cm">	 * released something</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">old_locks</span> <span class="o">!=</span> <span class="n">vgadev</span><span class="o">-&gt;</span><span class="n">locks</span><span class="p">)</span>
		<span class="n">wake_up_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vga_wait_queue</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">vga_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rsrc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">interruptible</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vga_device</span> <span class="o">*</span><span class="n">vgadev</span><span class="p">,</span> <span class="o">*</span><span class="n">conflict</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">wait_queue_t</span> <span class="n">wait</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">vga_check_first_use</span><span class="p">();</span>
	<span class="cm">/* The one who calls us should check for this, but lets be sure... */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pdev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">pdev</span> <span class="o">=</span> <span class="n">vga_default_device</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pdev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vga_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">vgadev</span> <span class="o">=</span> <span class="n">vgadev_find</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vgadev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vga_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">conflict</span> <span class="o">=</span> <span class="n">__vga_tryget</span><span class="p">(</span><span class="n">vgadev</span><span class="p">,</span> <span class="n">rsrc</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vga_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">conflict</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>


		<span class="cm">/* We have a conflict, we wait until somebody kicks the</span>
<span class="cm">		 * work queue. Currently we have one work queue that we</span>
<span class="cm">		 * kick each time some resources are released, but it would</span>
<span class="cm">		 * be fairly easy to have a per device one so that we only</span>
<span class="cm">		 * need to attach to the conflicting device</span>
<span class="cm">		 */</span>
		<span class="n">init_waitqueue_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wait</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
		<span class="n">add_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vga_wait_queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
		<span class="n">set_current_state</span><span class="p">(</span><span class="n">interruptible</span> <span class="o">?</span>
				  <span class="n">TASK_INTERRUPTIBLE</span> <span class="o">:</span>
				  <span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">schedule</span><span class="p">();</span>
		<span class="n">remove_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vga_wait_queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
		<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">vga_get</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">vga_tryget</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rsrc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vga_device</span> <span class="o">*</span><span class="n">vgadev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">vga_check_first_use</span><span class="p">();</span>

	<span class="cm">/* The one who calls us should check for this, but lets be sure... */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pdev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">pdev</span> <span class="o">=</span> <span class="n">vga_default_device</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pdev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vga_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">vgadev</span> <span class="o">=</span> <span class="n">vgadev_find</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vgadev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">__vga_tryget</span><span class="p">(</span><span class="n">vgadev</span><span class="p">,</span> <span class="n">rsrc</span><span class="p">))</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
<span class="nl">bail:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vga_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">vga_tryget</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">vga_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rsrc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vga_device</span> <span class="o">*</span><span class="n">vgadev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* The one who calls us should check for this, but lets be sure... */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pdev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">pdev</span> <span class="o">=</span> <span class="n">vga_default_device</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pdev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vga_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">vgadev</span> <span class="o">=</span> <span class="n">vgadev_find</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vgadev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>
	<span class="n">__vga_put</span><span class="p">(</span><span class="n">vgadev</span><span class="p">,</span> <span class="n">rsrc</span><span class="p">);</span>
<span class="nl">bail:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vga_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">vga_put</span><span class="p">);</span>

<span class="cm">/* Rules for using a bridge to control a VGA descendant decoding:</span>
<span class="cm">   if a bridge has only one VGA descendant then it can be used</span>
<span class="cm">   to control the VGA routing for that device.</span>
<span class="cm">   It should always use the bridge closest to the device to control it.</span>
<span class="cm">   If a bridge has a direct VGA descendant, but also have a sub-bridge</span>
<span class="cm">   VGA descendant then we cannot use that bridge to control the direct VGA descendant.</span>
<span class="cm">   So for every device we register, we need to iterate all its parent bridges</span>
<span class="cm">   so we can invalidate any devices using them properly.</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">vga_arbiter_check_bridge_sharing</span><span class="p">(</span><span class="k">struct</span> <span class="n">vga_device</span> <span class="o">*</span><span class="n">vgadev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vga_device</span> <span class="o">*</span><span class="n">same_bridge_vgadev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">new_bus</span><span class="p">,</span> <span class="o">*</span><span class="n">bus</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">new_bridge</span><span class="p">,</span> <span class="o">*</span><span class="n">bridge</span><span class="p">;</span>

	<span class="n">vgadev</span><span class="o">-&gt;</span><span class="n">bridge_has_one_vga</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vga_list</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* okay iterate the new devices bridge hierarachy */</span>
	<span class="n">new_bus</span> <span class="o">=</span> <span class="n">vgadev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">new_bus</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">new_bridge</span> <span class="o">=</span> <span class="n">new_bus</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">;</span>

		<span class="cm">/* go through list of devices already registered */</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">same_bridge_vgadev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vga_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">bus</span> <span class="o">=</span> <span class="n">same_bridge_vgadev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">;</span>
			<span class="n">bridge</span> <span class="o">=</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">;</span>

			<span class="cm">/* see if the share a bridge with this device */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">new_bridge</span> <span class="o">==</span> <span class="n">bridge</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* if their direct parent bridge is the same</span>
<span class="cm">				   as any bridge of this device then it can&#39;t be used</span>
<span class="cm">				   for that device */</span>
				<span class="n">same_bridge_vgadev</span><span class="o">-&gt;</span><span class="n">bridge_has_one_vga</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* now iterate the previous devices bridge hierarchy */</span>
			<span class="cm">/* if the new devices parent bridge is in the other devices</span>
<span class="cm">			   hierarchy then we can&#39;t use it to control this device */</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">bus</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">bridge</span> <span class="o">=</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">bridge</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">bridge</span> <span class="o">==</span> <span class="n">vgadev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">)</span>
						<span class="n">vgadev</span><span class="o">-&gt;</span><span class="n">bridge_has_one_vga</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">bus</span> <span class="o">=</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">new_bus</span> <span class="o">=</span> <span class="n">new_bus</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Currently, we assume that the &quot;initial&quot; setup of the system is</span>
<span class="cm"> * not sane, that is we come up with conflicting devices and let</span>
<span class="cm"> * the arbiter&#39;s client decides if devices decodes or not legacy</span>
<span class="cm"> * things.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">vga_arbiter_add_pci_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vga_device</span> <span class="o">*</span><span class="n">vgadev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">bridge</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">cmd</span><span class="p">;</span>

	<span class="cm">/* Only deal with VGA class devices */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">!=</span> <span class="n">PCI_CLASS_DISPLAY_VGA</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* Allocate structure */</span>
	<span class="n">vgadev</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vga_device</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vgadev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;vgaarb: failed to allocate pci device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="cm">/* What to do on allocation failure ? For now, let&#39;s</span>
<span class="cm">		 * just do nothing, I&#39;m not sure there is anything saner</span>
<span class="cm">		 * to be done</span>
<span class="cm">		 */</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">vgadev</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">vgadev</span><span class="p">));</span>

	<span class="cm">/* Take lock &amp; check for duplicates */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vga_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vgadev_find</span><span class="p">(</span><span class="n">pdev</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">vgadev</span><span class="o">-&gt;</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">pdev</span><span class="p">;</span>

	<span class="cm">/* By default, assume we decode everything */</span>
	<span class="n">vgadev</span><span class="o">-&gt;</span><span class="n">decodes</span> <span class="o">=</span> <span class="n">VGA_RSRC_LEGACY_IO</span> <span class="o">|</span> <span class="n">VGA_RSRC_LEGACY_MEM</span> <span class="o">|</span>
			  <span class="n">VGA_RSRC_NORMAL_IO</span> <span class="o">|</span> <span class="n">VGA_RSRC_NORMAL_MEM</span><span class="p">;</span>

	<span class="cm">/* by default mark it as decoding */</span>
	<span class="n">vga_decode_count</span><span class="o">++</span><span class="p">;</span>
	<span class="cm">/* Mark that we &quot;own&quot; resources based on our enables, we will</span>
<span class="cm">	 * clear that below if the bridge isn&#39;t forwarding</span>
<span class="cm">	 */</span>
	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_COMMAND</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">&amp;</span> <span class="n">PCI_COMMAND_IO</span><span class="p">)</span>
		<span class="n">vgadev</span><span class="o">-&gt;</span><span class="n">owns</span> <span class="o">|=</span> <span class="n">VGA_RSRC_LEGACY_IO</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">&amp;</span> <span class="n">PCI_COMMAND_MEMORY</span><span class="p">)</span>
		<span class="n">vgadev</span><span class="o">-&gt;</span><span class="n">owns</span> <span class="o">|=</span> <span class="n">VGA_RSRC_LEGACY_MEM</span><span class="p">;</span>

	<span class="cm">/* Check if VGA cycles can get down to us */</span>
	<span class="n">bus</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">bus</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bridge</span> <span class="o">=</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bridge</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u16</span> <span class="n">l</span><span class="p">;</span>
			<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">bridge</span><span class="p">,</span> <span class="n">PCI_BRIDGE_CONTROL</span><span class="p">,</span>
					     <span class="o">&amp;</span><span class="n">l</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">l</span> <span class="o">&amp;</span> <span class="n">PCI_BRIDGE_CTL_VGA</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">vgadev</span><span class="o">-&gt;</span><span class="n">owns</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">bus</span> <span class="o">=</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Deal with VGA default device. Use first enabled one</span>
<span class="cm">	 * by default if arch doesn&#39;t have it&#39;s own hook</span>
<span class="cm">	 */</span>
<span class="cp">#ifndef __ARCH_HAS_VGA_DEFAULT_DEVICE</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vga_default</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span>
	    <span class="p">((</span><span class="n">vgadev</span><span class="o">-&gt;</span><span class="n">owns</span> <span class="o">&amp;</span> <span class="n">VGA_RSRC_LEGACY_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">VGA_RSRC_LEGACY_MASK</span><span class="p">))</span>
		<span class="n">vga_default</span> <span class="o">=</span> <span class="n">pci_dev_get</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">vga_arbiter_check_bridge_sharing</span><span class="p">(</span><span class="n">vgadev</span><span class="p">);</span>

	<span class="cm">/* Add to the list */</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vgadev</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vga_list</span><span class="p">);</span>
	<span class="n">vga_count</span><span class="o">++</span><span class="p">;</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;vgaarb: device added: PCI:%s,decodes=%s,owns=%s,locks=%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">pci_name</span><span class="p">(</span><span class="n">pdev</span><span class="p">),</span>
		<span class="n">vga_iostate_to_str</span><span class="p">(</span><span class="n">vgadev</span><span class="o">-&gt;</span><span class="n">decodes</span><span class="p">),</span>
		<span class="n">vga_iostate_to_str</span><span class="p">(</span><span class="n">vgadev</span><span class="o">-&gt;</span><span class="n">owns</span><span class="p">),</span>
		<span class="n">vga_iostate_to_str</span><span class="p">(</span><span class="n">vgadev</span><span class="o">-&gt;</span><span class="n">locks</span><span class="p">));</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vga_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="nl">fail:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vga_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">vgadev</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">vga_arbiter_del_pci_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vga_device</span> <span class="o">*</span><span class="n">vgadev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">ret</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vga_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">vgadev</span> <span class="o">=</span> <span class="n">vgadev_find</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vgadev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#ifndef __ARCH_HAS_VGA_DEFAULT_DEVICE</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vga_default</span> <span class="o">==</span> <span class="n">pdev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_dev_put</span><span class="p">(</span><span class="n">vga_default</span><span class="p">);</span>
		<span class="n">vga_default</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vgadev</span><span class="o">-&gt;</span><span class="n">decodes</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">VGA_RSRC_LEGACY_IO</span> <span class="o">|</span> <span class="n">VGA_RSRC_LEGACY_MEM</span><span class="p">))</span>
		<span class="n">vga_decode_count</span><span class="o">--</span><span class="p">;</span>

	<span class="cm">/* Remove entry from list */</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vgadev</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">vga_count</span><span class="o">--</span><span class="p">;</span>
	<span class="cm">/* Notify userland driver that the device is gone so it discards</span>
<span class="cm">	 * it&#39;s copies of the pci_dev pointer</span>
<span class="cm">	 */</span>
	<span class="n">vga_arb_device_card_gone</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="cm">/* Wake up all possible waiters */</span>
	<span class="n">wake_up_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vga_wait_queue</span><span class="p">);</span>
<span class="nl">bail:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vga_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">vgadev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* this is called with the lock */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">vga_update_device_decodes</span><span class="p">(</span><span class="k">struct</span> <span class="n">vga_device</span> <span class="o">*</span><span class="n">vgadev</span><span class="p">,</span>
					     <span class="kt">int</span> <span class="n">new_decodes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">old_decodes</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vga_device</span> <span class="o">*</span><span class="n">new_vgadev</span><span class="p">,</span> <span class="o">*</span><span class="n">conflict</span><span class="p">;</span>

	<span class="n">old_decodes</span> <span class="o">=</span> <span class="n">vgadev</span><span class="o">-&gt;</span><span class="n">decodes</span><span class="p">;</span>
	<span class="n">vgadev</span><span class="o">-&gt;</span><span class="n">decodes</span> <span class="o">=</span> <span class="n">new_decodes</span><span class="p">;</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;vgaarb: device changed decodes: PCI:%s,olddecodes=%s,decodes=%s:owns=%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">pci_name</span><span class="p">(</span><span class="n">vgadev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">),</span>
		<span class="n">vga_iostate_to_str</span><span class="p">(</span><span class="n">old_decodes</span><span class="p">),</span>
		<span class="n">vga_iostate_to_str</span><span class="p">(</span><span class="n">vgadev</span><span class="o">-&gt;</span><span class="n">decodes</span><span class="p">),</span>
		<span class="n">vga_iostate_to_str</span><span class="p">(</span><span class="n">vgadev</span><span class="o">-&gt;</span><span class="n">owns</span><span class="p">));</span>


	<span class="cm">/* if we own the decodes we should move them along to</span>
<span class="cm">	   another card */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">vgadev</span><span class="o">-&gt;</span><span class="n">owns</span> <span class="o">&amp;</span> <span class="n">old_decodes</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">vga_count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* set us to own nothing */</span>
		<span class="n">vgadev</span><span class="o">-&gt;</span><span class="n">owns</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">old_decodes</span><span class="p">;</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">new_vgadev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vga_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">new_vgadev</span> <span class="o">!=</span> <span class="n">vgadev</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="n">new_vgadev</span><span class="o">-&gt;</span><span class="n">decodes</span> <span class="o">&amp;</span> <span class="n">VGA_RSRC_LEGACY_MASK</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;vgaarb: transferring owner from PCI:%s to PCI:%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pci_name</span><span class="p">(</span><span class="n">vgadev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">),</span> <span class="n">pci_name</span><span class="p">(</span><span class="n">new_vgadev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">));</span>
				<span class="n">conflict</span> <span class="o">=</span> <span class="n">__vga_tryget</span><span class="p">(</span><span class="n">new_vgadev</span><span class="p">,</span> <span class="n">VGA_RSRC_LEGACY_MASK</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">conflict</span><span class="p">)</span>
					<span class="n">__vga_put</span><span class="p">(</span><span class="n">new_vgadev</span><span class="p">,</span> <span class="n">VGA_RSRC_LEGACY_MASK</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* change decodes counter */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">old_decodes</span> <span class="o">!=</span> <span class="n">new_decodes</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new_decodes</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">VGA_RSRC_LEGACY_IO</span> <span class="o">|</span> <span class="n">VGA_RSRC_LEGACY_MEM</span><span class="p">))</span>
			<span class="n">vga_decode_count</span><span class="o">++</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">vga_decode_count</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;vgaarb: decoding count now is: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">vga_decode_count</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__vga_set_legacy_decoding</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">decodes</span><span class="p">,</span> <span class="n">bool</span> <span class="n">userspace</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vga_device</span> <span class="o">*</span><span class="n">vgadev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">decodes</span> <span class="o">&amp;=</span> <span class="n">VGA_RSRC_LEGACY_MASK</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vga_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">vgadev</span> <span class="o">=</span> <span class="n">vgadev_find</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vgadev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>

	<span class="cm">/* don&#39;t let userspace futz with kernel driver decodes */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">userspace</span> <span class="o">&amp;&amp;</span> <span class="n">vgadev</span><span class="o">-&gt;</span><span class="n">set_vga_decode</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>

	<span class="cm">/* update the device decodes + counter */</span>
	<span class="n">vga_update_device_decodes</span><span class="p">(</span><span class="n">vgadev</span><span class="p">,</span> <span class="n">decodes</span><span class="p">);</span>

	<span class="cm">/* XXX if somebody is going from &quot;doesn&#39;t decode&quot; to &quot;decodes&quot; state</span>
<span class="cm">	 * here, additional care must be taken as we may have pending owner</span>
<span class="cm">	 * ship of non-legacy region ...</span>
<span class="cm">	 */</span>
<span class="nl">bail:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vga_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">vga_set_legacy_decoding</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">decodes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__vga_set_legacy_decoding</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">decodes</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">vga_set_legacy_decoding</span><span class="p">);</span>

<span class="cm">/* call with NULL to unregister */</span>
<span class="kt">int</span> <span class="nf">vga_client_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cookie</span><span class="p">,</span>
			<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">irq_set_state</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">cookie</span><span class="p">,</span> <span class="n">bool</span> <span class="n">state</span><span class="p">),</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">set_vga_decode</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">cookie</span><span class="p">,</span> <span class="n">bool</span> <span class="n">decode</span><span class="p">))</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vga_device</span> <span class="o">*</span><span class="n">vgadev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vga_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">vgadev</span> <span class="o">=</span> <span class="n">vgadev_find</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vgadev</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>

	<span class="n">vgadev</span><span class="o">-&gt;</span><span class="n">irq_set_state</span> <span class="o">=</span> <span class="n">irq_set_state</span><span class="p">;</span>
	<span class="n">vgadev</span><span class="o">-&gt;</span><span class="n">set_vga_decode</span> <span class="o">=</span> <span class="n">set_vga_decode</span><span class="p">;</span>
	<span class="n">vgadev</span><span class="o">-&gt;</span><span class="n">cookie</span> <span class="o">=</span> <span class="n">cookie</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">bail:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vga_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">vga_client_register</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Char driver implementation</span>
<span class="cm"> *</span>
<span class="cm"> * Semantics is:</span>
<span class="cm"> *</span>
<span class="cm"> *  open       : open user instance of the arbitrer. by default, it&#39;s</span>
<span class="cm"> *                attached to the default VGA device of the system.</span>
<span class="cm"> *</span>
<span class="cm"> *  close      : close user instance, release locks</span>
<span class="cm"> *</span>
<span class="cm"> *  read       : return a string indicating the status of the target.</span>
<span class="cm"> *                an IO state string is of the form {io,mem,io+mem,none},</span>
<span class="cm"> *                mc and ic are respectively mem and io lock counts (for</span>
<span class="cm"> *                debugging/diagnostic only). &quot;decodes&quot; indicate what the</span>
<span class="cm"> *                card currently decodes, &quot;owns&quot; indicates what is currently</span>
<span class="cm"> *                enabled on it, and &quot;locks&quot; indicates what is locked by this</span>
<span class="cm"> *                card. If the card is unplugged, we get &quot;invalid&quot; then for</span>
<span class="cm"> *                card_ID and an -ENODEV error is returned for any command</span>
<span class="cm"> *                until a new card is targeted</span>
<span class="cm"> *</span>
<span class="cm"> *   &quot;&lt;card_ID&gt;,decodes=&lt;io_state&gt;,owns=&lt;io_state&gt;,locks=&lt;io_state&gt; (ic,mc)&quot;</span>
<span class="cm"> *</span>
<span class="cm"> * write       : write a command to the arbiter. List of commands is:</span>
<span class="cm"> *</span>
<span class="cm"> *   target &lt;card_ID&gt;   : switch target to card &lt;card_ID&gt; (see below)</span>
<span class="cm"> *   lock &lt;io_state&gt;    : acquires locks on target (&quot;none&quot; is invalid io_state)</span>
<span class="cm"> *   trylock &lt;io_state&gt; : non-blocking acquire locks on target</span>
<span class="cm"> *   unlock &lt;io_state&gt;  : release locks on target</span>
<span class="cm"> *   unlock all         : release all locks on target held by this user</span>
<span class="cm"> *   decodes &lt;io_state&gt; : set the legacy decoding attributes for the card</span>
<span class="cm"> *</span>
<span class="cm"> * poll         : event if something change on any card (not just the target)</span>
<span class="cm"> *</span>
<span class="cm"> * card_ID is of the form &quot;PCI:domain:bus:dev.fn&quot;. It can be set to &quot;default&quot;</span>
<span class="cm"> * to go back to the system default card (TODO: not implemented yet).</span>
<span class="cm"> * Currently, only PCI is supported as a prefix, but the userland API may</span>
<span class="cm"> * support other bus types in the future, even if the current kernel</span>
<span class="cm"> * implementation doesn&#39;t.</span>
<span class="cm"> *</span>
<span class="cm"> * Note about locks:</span>
<span class="cm"> *</span>
<span class="cm"> * The driver keeps track of which user has what locks on which card. It</span>
<span class="cm"> * supports stacking, like the kernel one. This complexifies the implementation</span>
<span class="cm"> * a bit, but makes the arbiter more tolerant to userspace problems and able</span>
<span class="cm"> * to properly cleanup in all cases when a process dies.</span>
<span class="cm"> * Currently, a max of 16 cards simultaneously can have locks issued from</span>
<span class="cm"> * userspace for a given user (file descriptor instance) of the arbiter.</span>
<span class="cm"> *</span>
<span class="cm"> * If the device is hot-unplugged, there is a hook inside the module to notify</span>
<span class="cm"> * they being added/removed in the system and automatically added/removed in</span>
<span class="cm"> * the arbiter.</span>
<span class="cm"> */</span>

<span class="cp">#define MAX_USER_CARDS         CONFIG_VGA_ARB_MAX_GPUS</span>
<span class="cp">#define PCI_INVALID_CARD       ((struct pci_dev *)-1UL)</span>

<span class="cm">/*</span>
<span class="cm"> * Each user has an array of these, tracking which cards have locks</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">vga_arb_user_card</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mem_cnt</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">io_cnt</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">vga_arb_private</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">target</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vga_arb_user_card</span> <span class="n">cards</span><span class="p">[</span><span class="n">MAX_USER_CARDS</span><span class="p">];</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">vga_user_list</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">vga_user_lock</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> * This function gets a string in the format: &quot;PCI:domain:bus:dev.fn&quot; and</span>
<span class="cm"> * returns the respective values. If the string is not in this format,</span>
<span class="cm"> * it returns 0.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">vga_pci_str_to_vars</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">domain</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">devfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">slot</span><span class="p">,</span> <span class="n">func</span><span class="p">;</span>


	<span class="n">n</span> <span class="o">=</span> <span class="n">sscanf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;PCI:%x:%x:%x.%x&quot;</span><span class="p">,</span> <span class="n">domain</span><span class="p">,</span> <span class="n">bus</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">slot</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">func</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="o">*</span><span class="n">devfn</span> <span class="o">=</span> <span class="n">PCI_DEVFN</span><span class="p">(</span><span class="n">slot</span><span class="p">,</span> <span class="n">func</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">vga_arb_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span> <span class="n">buf</span><span class="p">,</span>
			    <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vga_arb_private</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vga_device</span> <span class="o">*</span><span class="n">vgadev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">lbuf</span><span class="p">;</span>

	<span class="n">lbuf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="mi">1024</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lbuf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* Shields against vga_arb_device_card_gone (pci_dev going</span>
<span class="cm">	 * away), and allows access to vga list</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vga_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* If we are targeting the default, use it */</span>
	<span class="n">pdev</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pdev</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">pdev</span> <span class="o">==</span> <span class="n">PCI_INVALID_CARD</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vga_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">lbuf</span><span class="p">,</span> <span class="s">&quot;invalid&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Find card vgadev structure */</span>
	<span class="n">vgadev</span> <span class="o">=</span> <span class="n">vgadev_find</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vgadev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Wow, it&#39;s not in the list, that shouldn&#39;t happen,</span>
<span class="cm">		 * let&#39;s fix us up and return invalid card</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pdev</span> <span class="o">==</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">)</span>
			<span class="n">vga_arb_device_card_gone</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vga_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">lbuf</span><span class="p">,</span> <span class="s">&quot;invalid&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Fill the buffer with infos */</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">lbuf</span><span class="p">,</span> <span class="mi">1024</span><span class="p">,</span>
		       <span class="s">&quot;count:%d,PCI:%s,decodes=%s,owns=%s,locks=%s(%d:%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">vga_decode_count</span><span class="p">,</span> <span class="n">pci_name</span><span class="p">(</span><span class="n">pdev</span><span class="p">),</span>
		       <span class="n">vga_iostate_to_str</span><span class="p">(</span><span class="n">vgadev</span><span class="o">-&gt;</span><span class="n">decodes</span><span class="p">),</span>
		       <span class="n">vga_iostate_to_str</span><span class="p">(</span><span class="n">vgadev</span><span class="o">-&gt;</span><span class="n">owns</span><span class="p">),</span>
		       <span class="n">vga_iostate_to_str</span><span class="p">(</span><span class="n">vgadev</span><span class="o">-&gt;</span><span class="n">locks</span><span class="p">),</span>
		       <span class="n">vgadev</span><span class="o">-&gt;</span><span class="n">io_lock_cnt</span><span class="p">,</span> <span class="n">vgadev</span><span class="o">-&gt;</span><span class="n">mem_lock_cnt</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vga_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="nl">done:</span>

	<span class="cm">/* Copy that to user */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">count</span><span class="p">)</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">lbuf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">lbuf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * TODO: To avoid parsing inside kernel and to improve the speed we may</span>
<span class="cm"> * consider use ioctl here</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">vga_arb_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span> <span class="n">buf</span><span class="p">,</span>
			     <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vga_arb_private</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vga_arb_user_card</span> <span class="o">*</span><span class="n">uc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">io_state</span><span class="p">;</span>

	<span class="kt">char</span> <span class="o">*</span><span class="n">kbuf</span><span class="p">,</span> <span class="o">*</span><span class="n">curr_pos</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">remaining</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>


	<span class="n">kbuf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kbuf</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">kbuf</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">kbuf</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">curr_pos</span> <span class="o">=</span> <span class="n">kbuf</span><span class="p">;</span>
	<span class="n">kbuf</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>	<span class="cm">/* Just to make sure... */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">curr_pos</span><span class="p">,</span> <span class="s">&quot;lock &quot;</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">curr_pos</span> <span class="o">+=</span> <span class="mi">5</span><span class="p">;</span>
		<span class="n">remaining</span> <span class="o">-=</span> <span class="mi">5</span><span class="p">;</span>

		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;client 0x%p called &#39;lock&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">priv</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vga_str_to_iostate</span><span class="p">(</span><span class="n">curr_pos</span><span class="p">,</span> <span class="n">remaining</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">io_state</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPROTO</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">io_state</span> <span class="o">==</span> <span class="n">VGA_RSRC_NONE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPROTO</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">pdev</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">target</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">vga_get_uninterruptible</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">io_state</span><span class="p">);</span>

		<span class="cm">/* Update the client&#39;s locks lists... */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_USER_CARDS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">cards</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pdev</span> <span class="o">==</span> <span class="n">pdev</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">io_state</span> <span class="o">&amp;</span> <span class="n">VGA_RSRC_LEGACY_IO</span><span class="p">)</span>
					<span class="n">priv</span><span class="o">-&gt;</span><span class="n">cards</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">io_cnt</span><span class="o">++</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">io_state</span> <span class="o">&amp;</span> <span class="n">VGA_RSRC_LEGACY_MEM</span><span class="p">)</span>
					<span class="n">priv</span><span class="o">-&gt;</span><span class="n">cards</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mem_cnt</span><span class="o">++</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">curr_pos</span><span class="p">,</span> <span class="s">&quot;unlock &quot;</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">curr_pos</span> <span class="o">+=</span> <span class="mi">7</span><span class="p">;</span>
		<span class="n">remaining</span> <span class="o">-=</span> <span class="mi">7</span><span class="p">;</span>

		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;client 0x%p called &#39;unlock&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">priv</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">curr_pos</span><span class="p">,</span> <span class="s">&quot;all&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">io_state</span> <span class="o">=</span> <span class="n">VGA_RSRC_LEGACY_IO</span> <span class="o">|</span> <span class="n">VGA_RSRC_LEGACY_MEM</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vga_str_to_iostate</span>
			    <span class="p">(</span><span class="n">curr_pos</span><span class="p">,</span> <span class="n">remaining</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">io_state</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ret_val</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPROTO</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* TODO: Add this?</span>
<span class="cm">			   if (io_state == VGA_RSRC_NONE) {</span>
<span class="cm">			   ret_val = -EPROTO;</span>
<span class="cm">			   goto done;</span>
<span class="cm">			   }</span>
<span class="cm">			  */</span>
		<span class="p">}</span>

		<span class="n">pdev</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">target</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_USER_CARDS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">cards</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pdev</span> <span class="o">==</span> <span class="n">pdev</span><span class="p">)</span>
				<span class="n">uc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">cards</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">uc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">io_state</span> <span class="o">&amp;</span> <span class="n">VGA_RSRC_LEGACY_IO</span> <span class="o">&amp;&amp;</span> <span class="n">uc</span><span class="o">-&gt;</span><span class="n">io_cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">io_state</span> <span class="o">&amp;</span> <span class="n">VGA_RSRC_LEGACY_MEM</span> <span class="o">&amp;&amp;</span> <span class="n">uc</span><span class="o">-&gt;</span><span class="n">mem_cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">vga_put</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">io_state</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">io_state</span> <span class="o">&amp;</span> <span class="n">VGA_RSRC_LEGACY_IO</span><span class="p">)</span>
			<span class="n">uc</span><span class="o">-&gt;</span><span class="n">io_cnt</span><span class="o">--</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">io_state</span> <span class="o">&amp;</span> <span class="n">VGA_RSRC_LEGACY_MEM</span><span class="p">)</span>
			<span class="n">uc</span><span class="o">-&gt;</span><span class="n">mem_cnt</span><span class="o">--</span><span class="p">;</span>

		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">curr_pos</span><span class="p">,</span> <span class="s">&quot;trylock &quot;</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">curr_pos</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">remaining</span> <span class="o">-=</span> <span class="mi">8</span><span class="p">;</span>

		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;client 0x%p called &#39;trylock&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">priv</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vga_str_to_iostate</span><span class="p">(</span><span class="n">curr_pos</span><span class="p">,</span> <span class="n">remaining</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">io_state</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPROTO</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* TODO: Add this?</span>
<span class="cm">		   if (io_state == VGA_RSRC_NONE) {</span>
<span class="cm">		   ret_val = -EPROTO;</span>
<span class="cm">		   goto done;</span>
<span class="cm">		   }</span>
<span class="cm">		 */</span>

		<span class="n">pdev</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">target</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">vga_tryget</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">io_state</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Update the client&#39;s locks lists... */</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_USER_CARDS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">cards</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pdev</span> <span class="o">==</span> <span class="n">pdev</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">io_state</span> <span class="o">&amp;</span> <span class="n">VGA_RSRC_LEGACY_IO</span><span class="p">)</span>
						<span class="n">priv</span><span class="o">-&gt;</span><span class="n">cards</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">io_cnt</span><span class="o">++</span><span class="p">;</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">io_state</span> <span class="o">&amp;</span> <span class="n">VGA_RSRC_LEGACY_MEM</span><span class="p">)</span>
						<span class="n">priv</span><span class="o">-&gt;</span><span class="n">cards</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mem_cnt</span><span class="o">++</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">curr_pos</span><span class="p">,</span> <span class="s">&quot;target &quot;</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">pbus</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">domain</span><span class="p">,</span> <span class="n">bus</span><span class="p">,</span> <span class="n">devfn</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">vga_device</span> <span class="o">*</span><span class="n">vgadev</span><span class="p">;</span>

		<span class="n">curr_pos</span> <span class="o">+=</span> <span class="mi">7</span><span class="p">;</span>
		<span class="n">remaining</span> <span class="o">-=</span> <span class="mi">7</span><span class="p">;</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;client 0x%p called &#39;target&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">priv</span><span class="p">);</span>
		<span class="cm">/* if target is default */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">curr_pos</span><span class="p">,</span> <span class="s">&quot;default&quot;</span><span class="p">,</span> <span class="mi">7</span><span class="p">))</span>
			<span class="n">pdev</span> <span class="o">=</span> <span class="n">pci_dev_get</span><span class="p">(</span><span class="n">vga_default_device</span><span class="p">());</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vga_pci_str_to_vars</span><span class="p">(</span><span class="n">curr_pos</span><span class="p">,</span> <span class="n">remaining</span><span class="p">,</span>
						 <span class="o">&amp;</span><span class="n">domain</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bus</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">devfn</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ret_val</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPROTO</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;vgaarb: %s ==&gt; %x:%x:%x.%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">curr_pos</span><span class="p">,</span>
				<span class="n">domain</span><span class="p">,</span> <span class="n">bus</span><span class="p">,</span> <span class="n">PCI_SLOT</span><span class="p">(</span><span class="n">devfn</span><span class="p">),</span> <span class="n">PCI_FUNC</span><span class="p">(</span><span class="n">devfn</span><span class="p">));</span>

			<span class="n">pbus</span> <span class="o">=</span> <span class="n">pci_find_bus</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">bus</span><span class="p">);</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;vgaarb: pbus %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pbus</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pbus</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;vgaarb: invalid PCI domain and/or bus address %x:%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">domain</span><span class="p">,</span> <span class="n">bus</span><span class="p">);</span>
				<span class="n">ret_val</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">pdev</span> <span class="o">=</span> <span class="n">pci_get_slot</span><span class="p">(</span><span class="n">pbus</span><span class="p">,</span> <span class="n">devfn</span><span class="p">);</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;vgaarb: pdev %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pdev</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pdev</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;vgaarb: invalid PCI address %x:%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">bus</span><span class="p">,</span> <span class="n">devfn</span><span class="p">);</span>
				<span class="n">ret_val</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">vgadev</span> <span class="o">=</span> <span class="n">vgadev_find</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;vgaarb: vgadev %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">vgadev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vgadev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;vgaarb: this pci device is not a vga device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">pci_dev_put</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">target</span> <span class="o">=</span> <span class="n">pdev</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_USER_CARDS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">cards</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pdev</span> <span class="o">==</span> <span class="n">pdev</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">cards</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pdev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">priv</span><span class="o">-&gt;</span><span class="n">cards</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">pdev</span><span class="p">;</span>
				<span class="n">priv</span><span class="o">-&gt;</span><span class="n">cards</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">io_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">priv</span><span class="o">-&gt;</span><span class="n">cards</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mem_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">MAX_USER_CARDS</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;vgaarb: maximum user cards (%d) number reached!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">MAX_USER_CARDS</span><span class="p">);</span>
			<span class="n">pci_dev_put</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
			<span class="cm">/* XXX: which value to return? */</span>
			<span class="n">ret_val</span> <span class="o">=</span>  <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
		<span class="n">pci_dev_put</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>


	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">curr_pos</span><span class="p">,</span> <span class="s">&quot;decodes &quot;</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">curr_pos</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">remaining</span> <span class="o">-=</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;vgaarb: client 0x%p called &#39;decodes&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">priv</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vga_str_to_iostate</span><span class="p">(</span><span class="n">curr_pos</span><span class="p">,</span> <span class="n">remaining</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">io_state</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPROTO</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">pdev</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">target</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">__vga_set_legacy_decoding</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">io_state</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* If we got here, the message written is not part of the protocol! */</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">kbuf</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EPROTO</span><span class="p">;</span>

<span class="nl">done:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">kbuf</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">vga_arb_fpoll</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">poll_table</span> <span class="o">*</span> <span class="n">wait</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vga_arb_private</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="n">poll_wait</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vga_wait_queue</span><span class="p">,</span> <span class="n">wait</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">POLLIN</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vga_arb_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vga_arb_private</span> <span class="o">*</span><span class="n">priv</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">priv</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">priv</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">priv</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vga_user_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vga_user_list</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vga_user_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Set the client&#39; lists of locks */</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">target</span> <span class="o">=</span> <span class="n">vga_default_device</span><span class="p">();</span> <span class="cm">/* Maybe this is still null! */</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">cards</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">cards</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">io_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">cards</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">mem_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>


	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vga_arb_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vga_arb_private</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vga_arb_user_card</span> <span class="o">*</span><span class="n">uc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vga_user_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_USER_CARDS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">uc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">cards</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">uc</span><span class="o">-&gt;</span><span class="n">pdev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;uc-&gt;io_cnt == %d, uc-&gt;mem_cnt == %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">uc</span><span class="o">-&gt;</span><span class="n">io_cnt</span><span class="p">,</span> <span class="n">uc</span><span class="o">-&gt;</span><span class="n">mem_cnt</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">uc</span><span class="o">-&gt;</span><span class="n">io_cnt</span><span class="o">--</span><span class="p">)</span>
			<span class="n">vga_put</span><span class="p">(</span><span class="n">uc</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">VGA_RSRC_LEGACY_IO</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">uc</span><span class="o">-&gt;</span><span class="n">mem_cnt</span><span class="o">--</span><span class="p">)</span>
			<span class="n">vga_put</span><span class="p">(</span><span class="n">uc</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">VGA_RSRC_LEGACY_MEM</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vga_user_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vga_arb_device_card_gone</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * callback any registered clients to let them know we have a</span>
<span class="cm"> * change in VGA cards</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">vga_arbiter_notify_clients</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vga_device</span> <span class="o">*</span><span class="n">vgadev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">new_decodes</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">new_state</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vga_arbiter_used</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vga_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">vgadev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vga_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vga_count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">new_state</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">new_state</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vgadev</span><span class="o">-&gt;</span><span class="n">set_vga_decode</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">new_decodes</span> <span class="o">=</span> <span class="n">vgadev</span><span class="o">-&gt;</span><span class="n">set_vga_decode</span><span class="p">(</span><span class="n">vgadev</span><span class="o">-&gt;</span><span class="n">cookie</span><span class="p">,</span> <span class="n">new_state</span><span class="p">);</span>
			<span class="n">vga_update_device_decodes</span><span class="p">(</span><span class="n">vgadev</span><span class="p">,</span> <span class="n">new_decodes</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vga_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pci_notify</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">action</span><span class="p">,</span>
		      <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">bool</span> <span class="n">notify</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="cm">/* For now we&#39;re only intereted in devices added and removed. I didn&#39;t</span>
<span class="cm">	 * test this thing here, so someone needs to double check for the</span>
<span class="cm">	 * cases of hotplugable vga cards. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">action</span> <span class="o">==</span> <span class="n">BUS_NOTIFY_ADD_DEVICE</span><span class="p">)</span>
		<span class="n">notify</span> <span class="o">=</span> <span class="n">vga_arbiter_add_pci_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">action</span> <span class="o">==</span> <span class="n">BUS_NOTIFY_DEL_DEVICE</span><span class="p">)</span>
		<span class="n">notify</span> <span class="o">=</span> <span class="n">vga_arbiter_del_pci_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">notify</span><span class="p">)</span>
		<span class="n">vga_arbiter_notify_clients</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">pci_notifier</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">notifier_call</span> <span class="o">=</span> <span class="n">pci_notify</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">vga_arb_device_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">vga_arb_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span> <span class="o">=</span> <span class="n">vga_arb_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">poll</span> <span class="o">=</span> <span class="n">vga_arb_fpoll</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">vga_arb_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">vga_arb_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span> <span class="n">noop_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">miscdevice</span> <span class="n">vga_arb_device</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">MISC_DYNAMIC_MINOR</span><span class="p">,</span> <span class="s">&quot;vga_arbiter&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vga_arb_device_fops</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">vga_arb_device_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vga_device</span> <span class="o">*</span><span class="n">vgadev</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">misc_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vga_arb_device</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;vgaarb: error %d registering device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>

	<span class="n">bus_register_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pci_bus_type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pci_notifier</span><span class="p">);</span>

	<span class="cm">/* We add all pci devices satisfying vga class in the arbiter by</span>
<span class="cm">	 * default */</span>
	<span class="n">pdev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">pdev</span> <span class="o">=</span>
		<span class="n">pci_get_subsys</span><span class="p">(</span><span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span>
			       <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">pdev</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">vga_arbiter_add_pci_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;vgaarb: loaded</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">vgadev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vga_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vgadev</span><span class="o">-&gt;</span><span class="n">bridge_has_one_vga</span><span class="p">)</span>
			<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;vgaarb: bridge control possible %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pci_name</span><span class="p">(</span><span class="n">vgadev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">));</span>
		<span class="k">else</span>
			<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;vgaarb: no bridge control possible %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pci_name</span><span class="p">(</span><span class="n">vgadev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">subsys_initcall</span><span class="p">(</span><span class="n">vga_arb_device_init</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
