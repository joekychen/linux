<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › scsi › osst_options.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>osst_options.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm">   The compile-time configurable defaults for the Linux SCSI tape driver.</span>

<span class="cm">   Copyright 1995 Kai Makisara.</span>
<span class="cm">   </span>
<span class="cm">   Last modified: Wed Sep  2 21:24:07 1998 by root@home</span>
<span class="cm">   </span>
<span class="cm">   Changed (and renamed) for OnStream SCSI drives garloff@suse.de</span>
<span class="cm">   2000-06-21</span>

<span class="cm">   $Header: /cvsroot/osst/Driver/osst_options.h,v 1.6 2003/12/23 14:22:12 wriede Exp $</span>
<span class="cm">*/</span>

<span class="cp">#ifndef _OSST_OPTIONS_H</span>
<span class="cp">#define _OSST_OPTIONS_H</span>

<span class="cm">/* The minimum limit for the number of SCSI tape devices is determined by</span>
<span class="cm">   OSST_MAX_TAPES. If the number of tape devices and the &quot;slack&quot; defined by</span>
<span class="cm">   OSST_EXTRA_DEVS exceeds OSST_MAX_TAPES, the large number is used. */</span>
<span class="cp">#define OSST_MAX_TAPES 4</span>

<span class="cm">/* If OSST_IN_FILE_POS is nonzero, the driver positions the tape after the</span>
<span class="cm">   record been read by the user program even if the tape has moved further</span>
<span class="cm">   because of buffered reads. Should be set to zero to support also drives</span>
<span class="cm">   that can&#39;t space backwards over records. NOTE: The tape will be</span>
<span class="cm">   spaced backwards over an &quot;accidentally&quot; crossed filemark in any case. */</span>
<span class="cp">#define OSST_IN_FILE_POS 1</span>

<span class="cm">/* The tape driver buffer size in kilobytes. */</span>
<span class="cm">/* Don&#39;t change, as this is the HW blocksize */</span>
<span class="cp">#define OSST_BUFFER_BLOCKS 32</span>

<span class="cm">/* The number of kilobytes of data in the buffer that triggers an</span>
<span class="cm">   asynchronous write in fixed block mode. See also OSST_ASYNC_WRITES</span>
<span class="cm">   below. */</span>
<span class="cp">#define OSST_WRITE_THRESHOLD_BLOCKS 32</span>

<span class="cm">/* OSST_EOM_RESERVE defines the number of frames are kept in reserve for</span>
<span class="cm"> *  * write error recovery when writing near end of medium. ENOSPC is returned</span>
<span class="cm"> *   * when write() is called and the tape write position is within this number</span>
<span class="cm"> *    * of blocks from the tape capacity. */</span>
<span class="cp">#define OSST_EOM_RESERVE 300</span>

<span class="cm">/* The maximum number of tape buffers the driver allocates. The number</span>
<span class="cm">   is also constrained by the number of drives detected. Determines the</span>
<span class="cm">   maximum number of concurrently active tape drives. */</span>
<span class="cp">#define OSST_MAX_BUFFERS OSST_MAX_TAPES </span>

<span class="cm">/* Maximum number of scatter/gather segments */</span>
<span class="cm">/* Fit one buffer in pages and add one for the AUX header */</span>
<span class="cp">#define OSST_MAX_SG      (((OSST_BUFFER_BLOCKS*1024) / PAGE_SIZE) + 1)</span>

<span class="cm">/* The number of scatter/gather segments to allocate at first try (must be</span>
<span class="cm">   smaller or equal to the maximum). */</span>
<span class="cp">#define OSST_FIRST_SG    ((OSST_BUFFER_BLOCKS*1024) / PAGE_SIZE)</span>

<span class="cm">/* The size of the first scatter/gather segments (determines the maximum block</span>
<span class="cm">   size for SCSI adapters not supporting scatter/gather). The default is set</span>
<span class="cm">   to try to allocate the buffer as one chunk. */</span>
<span class="cp">#define OSST_FIRST_ORDER  (15-PAGE_SHIFT)</span>


<span class="cm">/* The following lines define defaults for properties that can be set</span>
<span class="cm">   separately for each drive using the MTSTOPTIONS ioctl. */</span>

<span class="cm">/* If OSST_TWO_FM is non-zero, the driver writes two filemarks after a</span>
<span class="cm">   file being written. Some drives can&#39;t handle two filemarks at the</span>
<span class="cm">   end of data. */</span>
<span class="cp">#define OSST_TWO_FM 0</span>

<span class="cm">/* If OSST_BUFFER_WRITES is non-zero, writes in fixed block mode are</span>
<span class="cm">   buffered until the driver buffer is full or asynchronous write is</span>
<span class="cm">   triggered. */</span>
<span class="cp">#define OSST_BUFFER_WRITES 1</span>

<span class="cm">/* If OSST_ASYNC_WRITES is non-zero, the SCSI write command may be started</span>
<span class="cm">   without waiting for it to finish. May cause problems in multiple</span>
<span class="cm">   tape backups. */</span>
<span class="cp">#define OSST_ASYNC_WRITES 1</span>

<span class="cm">/* If OSST_READ_AHEAD is non-zero, blocks are read ahead in fixed block</span>
<span class="cm">   mode. */</span>
<span class="cp">#define OSST_READ_AHEAD 1</span>

<span class="cm">/* If OSST_AUTO_LOCK is non-zero, the drive door is locked at the first</span>
<span class="cm">   read or write command after the device is opened. The door is opened</span>
<span class="cm">   when the device is closed. */</span>
<span class="cp">#define OSST_AUTO_LOCK 0</span>

<span class="cm">/* If OSST_FAST_MTEOM is non-zero, the MTEOM ioctl is done using the</span>
<span class="cm">   direct SCSI command. The file number status is lost but this method</span>
<span class="cm">   is fast with some drives. Otherwise MTEOM is done by spacing over</span>
<span class="cm">   files and the file number status is retained. */</span>
<span class="cp">#define OSST_FAST_MTEOM 0</span>

<span class="cm">/* If OSST_SCSI2LOGICAL is nonzero, the logical block addresses are used for</span>
<span class="cm">   MTIOCPOS and MTSEEK by default. Vendor addresses are used if OSST_SCSI2LOGICAL</span>
<span class="cm">   is zero. */</span>
<span class="cp">#define OSST_SCSI2LOGICAL 0</span>

<span class="cm">/* If OSST_SYSV is non-zero, the tape behaves according to the SYS V semantics.</span>
<span class="cm">   The default is BSD semantics. */</span>
<span class="cp">#define OSST_SYSV 0</span>


<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
