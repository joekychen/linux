<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › scsi › isci › port_config.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>port_config.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * This file is provided under a dual BSD/GPLv2 license.  When using or</span>
<span class="cm"> * redistributing this file, you may do so under either license.</span>
<span class="cm"> *</span>
<span class="cm"> * GPL LICENSE SUMMARY</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of version 2 of the GNU General Public License as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="cm"> * General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.</span>
<span class="cm"> * The full GNU General Public License is included in this distribution</span>
<span class="cm"> * in the file called LICENSE.GPL.</span>
<span class="cm"> *</span>
<span class="cm"> * BSD LICENSE</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.</span>
<span class="cm"> * All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * Redistribution and use in source and binary forms, with or without</span>
<span class="cm"> * modification, are permitted provided that the following conditions</span>
<span class="cm"> * are met:</span>
<span class="cm"> *</span>
<span class="cm"> *   * Redistributions of source code must retain the above copyright</span>
<span class="cm"> *     notice, this list of conditions and the following disclaimer.</span>
<span class="cm"> *   * Redistributions in binary form must reproduce the above copyright</span>
<span class="cm"> *     notice, this list of conditions and the following disclaimer in</span>
<span class="cm"> *     the documentation and/or other materials provided with the</span>
<span class="cm"> *     distribution.</span>
<span class="cm"> *   * Neither the name of Intel Corporation nor the names of its</span>
<span class="cm"> *     contributors may be used to endorse or promote products derived</span>
<span class="cm"> *     from this software without specific prior written permission.</span>
<span class="cm"> *</span>
<span class="cm"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span>
<span class="cm"> * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span>
<span class="cm"> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</span>
<span class="cm"> * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</span>
<span class="cm"> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span>
<span class="cm"> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span>
<span class="cm"> * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span>
<span class="cm"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span>
<span class="cm"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
<span class="cm"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span>
<span class="cm"> * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<span class="cm"> */</span>

<span class="cp">#include &quot;host.h&quot;</span>

<span class="cp">#define SCIC_SDS_MPC_RECONFIGURATION_TIMEOUT    (10)</span>
<span class="cp">#define SCIC_SDS_APC_RECONFIGURATION_TIMEOUT    (10)</span>
<span class="cp">#define SCIC_SDS_APC_WAIT_LINK_UP_NOTIFICATION  (1000)</span>

<span class="k">enum</span> <span class="n">SCIC_SDS_APC_ACTIVITY</span> <span class="p">{</span>
	<span class="n">SCIC_SDS_APC_SKIP_PHY</span><span class="p">,</span>
	<span class="n">SCIC_SDS_APC_ADD_PHY</span><span class="p">,</span>
	<span class="n">SCIC_SDS_APC_START_TIMER</span><span class="p">,</span>

	<span class="n">SCIC_SDS_APC_ACTIVITY_MAX</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * ******************************************************************************</span>
<span class="cm"> * General port configuration agent routines</span>
<span class="cm"> * ****************************************************************************** */</span>

<span class="cm">/**</span>
<span class="cm"> *</span>
<span class="cm"> * @address_one: A SAS Address to be compared.</span>
<span class="cm"> * @address_two: A SAS Address to be compared.</span>
<span class="cm"> *</span>
<span class="cm"> * Compare the two SAS Address and if SAS Address One is greater than SAS</span>
<span class="cm"> * Address Two then return &gt; 0 else if SAS Address One is less than SAS Address</span>
<span class="cm"> * Two return &lt; 0 Otherwise they are the same return 0 A signed value of x &gt; 0</span>
<span class="cm"> * &gt; y where x is returned for Address One &gt; Address Two y is returned for</span>
<span class="cm"> * Address One &lt; Address Two 0 is returned ofr Address One = Address Two</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">sci_sas_address_compare</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">sci_sas_address</span> <span class="n">address_one</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">sci_sas_address</span> <span class="n">address_two</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">address_one</span><span class="p">.</span><span class="n">high</span> <span class="o">&gt;</span> <span class="n">address_two</span><span class="p">.</span><span class="n">high</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">address_one</span><span class="p">.</span><span class="n">high</span> <span class="o">&lt;</span> <span class="n">address_two</span><span class="p">.</span><span class="n">high</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">address_one</span><span class="p">.</span><span class="n">low</span> <span class="o">&gt;</span> <span class="n">address_two</span><span class="p">.</span><span class="n">low</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">address_one</span><span class="p">.</span><span class="n">low</span> <span class="o">&lt;</span> <span class="n">address_two</span><span class="p">.</span><span class="n">low</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* The two SAS Address must be identical */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *</span>
<span class="cm"> * @controller: The controller object used for the port search.</span>
<span class="cm"> * @phy: The phy object to match.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine will find a matching port for the phy.  This means that the</span>
<span class="cm"> * port and phy both have the same broadcast sas address and same received sas</span>
<span class="cm"> * address. The port address or the NULL if there is no matching</span>
<span class="cm"> * port. port address if the port can be found to match the phy.</span>
<span class="cm"> * NULL if there is no matching port for the phy.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="nf">sci_port_configuration_agent_find_port</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">isci_phy</span> <span class="o">*</span><span class="n">iphy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sci_sas_address</span> <span class="n">port_sas_address</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sci_sas_address</span> <span class="n">port_attached_device_address</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sci_sas_address</span> <span class="n">phy_sas_address</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sci_sas_address</span> <span class="n">phy_attached_device_address</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Since this phy can be a member of a wide port check to see if one or</span>
<span class="cm">	 * more phys match the sent and received SAS address as this phy in which</span>
<span class="cm">	 * case it should participate in the same port.</span>
<span class="cm">	 */</span>
	<span class="n">sci_phy_get_sas_address</span><span class="p">(</span><span class="n">iphy</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_sas_address</span><span class="p">);</span>
	<span class="n">sci_phy_get_attached_sas_address</span><span class="p">(</span><span class="n">iphy</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_attached_device_address</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ihost</span><span class="o">-&gt;</span><span class="n">logical_port_entries</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">iport</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">ports</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="n">sci_port_get_sas_address</span><span class="p">(</span><span class="n">iport</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port_sas_address</span><span class="p">);</span>
		<span class="n">sci_port_get_attached_sas_address</span><span class="p">(</span><span class="n">iport</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port_attached_device_address</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sci_sas_address_compare</span><span class="p">(</span><span class="n">port_sas_address</span><span class="p">,</span> <span class="n">phy_sas_address</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
		    <span class="n">sci_sas_address_compare</span><span class="p">(</span><span class="n">port_attached_device_address</span><span class="p">,</span> <span class="n">phy_attached_device_address</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">iport</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *</span>
<span class="cm"> * @controller: This is the controller object that contains the port agent</span>
<span class="cm"> * @port_agent: This is the port configruation agent for the controller.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine will validate the port configuration is correct for the SCU</span>
<span class="cm"> * hardware.  The SCU hardware allows for port configurations as follows. LP0</span>
<span class="cm"> * -&gt; (PE0), (PE0, PE1), (PE0, PE1, PE2, PE3) LP1 -&gt; (PE1) LP2 -&gt; (PE2), (PE2,</span>
<span class="cm"> * PE3) LP3 -&gt; (PE3) enum sci_status SCI_SUCCESS the port configuration is valid for</span>
<span class="cm"> * this port configuration agent. SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION</span>
<span class="cm"> * the port configuration is not valid for this port configuration agent.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">enum</span> <span class="n">sci_status</span> <span class="nf">sci_port_configuration_agent_validate_ports</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">sci_port_configuration_agent</span> <span class="o">*</span><span class="n">port_agent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sci_sas_address</span> <span class="n">first_address</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sci_sas_address</span> <span class="n">second_address</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Sanity check the max ranges for all the phys the max index</span>
<span class="cm">	 * is always equal to the port range index */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">port_agent</span><span class="o">-&gt;</span><span class="n">phy_valid_port_range</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">max_index</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span>
	    <span class="n">port_agent</span><span class="o">-&gt;</span><span class="n">phy_valid_port_range</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">max_index</span> <span class="o">!=</span> <span class="mi">1</span> <span class="o">||</span>
	    <span class="n">port_agent</span><span class="o">-&gt;</span><span class="n">phy_valid_port_range</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">max_index</span> <span class="o">!=</span> <span class="mi">2</span> <span class="o">||</span>
	    <span class="n">port_agent</span><span class="o">-&gt;</span><span class="n">phy_valid_port_range</span><span class="p">[</span><span class="mi">3</span><span class="p">].</span><span class="n">max_index</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This is a request to configure a single x4 port or at least attempt</span>
<span class="cm">	 * to make all the phys into a single port */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">port_agent</span><span class="o">-&gt;</span><span class="n">phy_valid_port_range</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">min_index</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
	    <span class="n">port_agent</span><span class="o">-&gt;</span><span class="n">phy_valid_port_range</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">min_index</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
	    <span class="n">port_agent</span><span class="o">-&gt;</span><span class="n">phy_valid_port_range</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">min_index</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
	    <span class="n">port_agent</span><span class="o">-&gt;</span><span class="n">phy_valid_port_range</span><span class="p">[</span><span class="mi">3</span><span class="p">].</span><span class="n">min_index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">SCI_SUCCESS</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This is a degenerate case where phy 1 and phy 2 are assigned</span>
<span class="cm">	 * to the same port this is explicitly disallowed by the hardware</span>
<span class="cm">	 * unless they are part of the same x4 port and this condition was</span>
<span class="cm">	 * already checked above. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">port_agent</span><span class="o">-&gt;</span><span class="n">phy_valid_port_range</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">min_index</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * PE0 and PE3 can never have the same SAS Address unless they</span>
<span class="cm">	 * are part of the same x4 wide port and we have already checked</span>
<span class="cm">	 * for this condition. */</span>
	<span class="n">sci_phy_get_sas_address</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">first_address</span><span class="p">);</span>
	<span class="n">sci_phy_get_sas_address</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">second_address</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sci_sas_address_compare</span><span class="p">(</span><span class="n">first_address</span><span class="p">,</span> <span class="n">second_address</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * PE0 and PE1 are configured into a 2x1 ports make sure that the</span>
<span class="cm">	 * SAS Address for PE0 and PE2 are different since they can not be</span>
<span class="cm">	 * part of the same port. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">port_agent</span><span class="o">-&gt;</span><span class="n">phy_valid_port_range</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">min_index</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
	    <span class="n">port_agent</span><span class="o">-&gt;</span><span class="n">phy_valid_port_range</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">min_index</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sci_phy_get_sas_address</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">first_address</span><span class="p">);</span>
		<span class="n">sci_phy_get_sas_address</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">second_address</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sci_sas_address_compare</span><span class="p">(</span><span class="n">first_address</span><span class="p">,</span> <span class="n">second_address</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * PE2 and PE3 are configured into a 2x1 ports make sure that the</span>
<span class="cm">	 * SAS Address for PE1 and PE3 are different since they can not be</span>
<span class="cm">	 * part of the same port. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">port_agent</span><span class="o">-&gt;</span><span class="n">phy_valid_port_range</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">min_index</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span>
	    <span class="n">port_agent</span><span class="o">-&gt;</span><span class="n">phy_valid_port_range</span><span class="p">[</span><span class="mi">3</span><span class="p">].</span><span class="n">min_index</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sci_phy_get_sas_address</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">first_address</span><span class="p">);</span>
		<span class="n">sci_phy_get_sas_address</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">second_address</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sci_sas_address_compare</span><span class="p">(</span><span class="n">first_address</span><span class="p">,</span> <span class="n">second_address</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">SCI_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ******************************************************************************</span>
<span class="cm"> * Manual port configuration agent routines</span>
<span class="cm"> * ****************************************************************************** */</span>

<span class="cm">/* verify all of the phys in the same port are using the same SAS address */</span>
<span class="k">static</span> <span class="k">enum</span> <span class="n">sci_status</span>
<span class="nf">sci_mpc_agent_validate_phy_configuration</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">,</span>
					      <span class="k">struct</span> <span class="n">sci_port_configuration_agent</span> <span class="o">*</span><span class="n">port_agent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">phy_mask</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">assigned_phy_mask</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sci_sas_address</span> <span class="n">sas_address</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sci_sas_address</span> <span class="n">phy_assigned_address</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">port_index</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">phy_index</span><span class="p">;</span>

	<span class="n">assigned_phy_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sas_address</span><span class="p">.</span><span class="n">high</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sas_address</span><span class="p">.</span><span class="n">low</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">port_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">port_index</span> <span class="o">&lt;</span> <span class="n">SCI_MAX_PORTS</span><span class="p">;</span> <span class="n">port_index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">phy_mask</span> <span class="o">=</span> <span class="n">ihost</span><span class="o">-&gt;</span><span class="n">oem_parameters</span><span class="p">.</span><span class="n">ports</span><span class="p">[</span><span class="n">port_index</span><span class="p">].</span><span class="n">phy_mask</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phy_mask</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Make sure that one or more of the phys were not already assinged to</span>
<span class="cm">		 * a different port. */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">phy_mask</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">assigned_phy_mask</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Find the starting phy index for this round through the loop */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">phy_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">phy_index</span> <span class="o">&lt;</span> <span class="n">SCI_MAX_PHYS</span><span class="p">;</span> <span class="n">phy_index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">phy_mask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">phy_index</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">sci_phy_get_sas_address</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">[</span><span class="n">phy_index</span><span class="p">],</span>
						     <span class="o">&amp;</span><span class="n">sas_address</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * The phy_index can be used as the starting point for the</span>
<span class="cm">			 * port range since the hardware starts all logical ports</span>
<span class="cm">			 * the same as the PE index. */</span>
			<span class="n">port_agent</span><span class="o">-&gt;</span><span class="n">phy_valid_port_range</span><span class="p">[</span><span class="n">phy_index</span><span class="p">].</span><span class="n">min_index</span> <span class="o">=</span> <span class="n">port_index</span><span class="p">;</span>
			<span class="n">port_agent</span><span class="o">-&gt;</span><span class="n">phy_valid_port_range</span><span class="p">[</span><span class="n">phy_index</span><span class="p">].</span><span class="n">max_index</span> <span class="o">=</span> <span class="n">phy_index</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">phy_index</span> <span class="o">!=</span> <span class="n">port_index</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">return</span> <span class="n">SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * See how many additional phys are being added to this logical port.</span>
<span class="cm">		 * Note: We have not moved the current phy_index so we will actually</span>
<span class="cm">		 *       compare the startting phy with itself.</span>
<span class="cm">		 *       This is expected and required to add the phy to the port. */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">phy_index</span> <span class="o">&lt;</span> <span class="n">SCI_MAX_PHYS</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">phy_mask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">phy_index</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">sci_phy_get_sas_address</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">[</span><span class="n">phy_index</span><span class="p">],</span>
						     <span class="o">&amp;</span><span class="n">phy_assigned_address</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">sci_sas_address_compare</span><span class="p">(</span><span class="n">sas_address</span><span class="p">,</span> <span class="n">phy_assigned_address</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * The phy mask specified that this phy is part of the same port</span>
<span class="cm">				 * as the starting phy and it is not so fail this configuration */</span>
				<span class="k">return</span> <span class="n">SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">port_agent</span><span class="o">-&gt;</span><span class="n">phy_valid_port_range</span><span class="p">[</span><span class="n">phy_index</span><span class="p">].</span><span class="n">min_index</span> <span class="o">=</span> <span class="n">port_index</span><span class="p">;</span>
			<span class="n">port_agent</span><span class="o">-&gt;</span><span class="n">phy_valid_port_range</span><span class="p">[</span><span class="n">phy_index</span><span class="p">].</span><span class="n">max_index</span> <span class="o">=</span> <span class="n">phy_index</span><span class="p">;</span>

			<span class="n">sci_port_add_phy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">ports</span><span class="p">[</span><span class="n">port_index</span><span class="p">],</span>
					      <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">[</span><span class="n">phy_index</span><span class="p">]);</span>

			<span class="n">assigned_phy_mask</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">phy_index</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">phy_index</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">sci_port_configuration_agent_validate_ports</span><span class="p">(</span><span class="n">ihost</span><span class="p">,</span> <span class="n">port_agent</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mpc_agent_timeout</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">index</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sci_timer</span> <span class="o">*</span><span class="n">tmr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sci_timer</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sci_port_configuration_agent</span> <span class="o">*</span><span class="n">port_agent</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">configure_phy_mask</span><span class="p">;</span>

	<span class="n">port_agent</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">tmr</span><span class="p">,</span> <span class="n">typeof</span><span class="p">(</span><span class="o">*</span><span class="n">port_agent</span><span class="p">),</span> <span class="n">timer</span><span class="p">);</span>
	<span class="n">ihost</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">port_agent</span><span class="p">,</span> <span class="n">typeof</span><span class="p">(</span><span class="o">*</span><span class="n">ihost</span><span class="p">),</span> <span class="n">port_agent</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">scic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tmr</span><span class="o">-&gt;</span><span class="n">cancel</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="n">port_agent</span><span class="o">-&gt;</span><span class="n">timer_pending</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* Find the mask of phys that are reported read but as yet unconfigured into a port */</span>
	<span class="n">configure_phy_mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">port_agent</span><span class="o">-&gt;</span><span class="n">phy_configured_mask</span> <span class="o">&amp;</span> <span class="n">port_agent</span><span class="o">-&gt;</span><span class="n">phy_ready_mask</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">SCI_MAX_PHYS</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">isci_phy</span> <span class="o">*</span><span class="n">iphy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">configure_phy_mask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">index</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">port_agent</span><span class="o">-&gt;</span><span class="n">link_up_handler</span><span class="p">(</span><span class="n">ihost</span><span class="p">,</span> <span class="n">port_agent</span><span class="p">,</span>
						    <span class="n">phy_get_non_dummy_port</span><span class="p">(</span><span class="n">iphy</span><span class="p">),</span>
						    <span class="n">iphy</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">done:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">scic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sci_mpc_agent_link_up</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">sci_port_configuration_agent</span> <span class="o">*</span><span class="n">port_agent</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">iport</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">isci_phy</span> <span class="o">*</span><span class="n">iphy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* If the port is NULL then the phy was not assigned to a port.</span>
<span class="cm">	 * This is because the phy was not given the same SAS Address as</span>
<span class="cm">	 * the other PHYs in the port.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iport</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">port_agent</span><span class="o">-&gt;</span><span class="n">phy_ready_mask</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">iphy</span><span class="o">-&gt;</span><span class="n">phy_index</span><span class="p">);</span>
	<span class="n">sci_port_link_up</span><span class="p">(</span><span class="n">iport</span><span class="p">,</span> <span class="n">iphy</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">iport</span><span class="o">-&gt;</span><span class="n">active_phy_mask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">iphy</span><span class="o">-&gt;</span><span class="n">phy_index</span><span class="p">)))</span>
		<span class="n">port_agent</span><span class="o">-&gt;</span><span class="n">phy_configured_mask</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">iphy</span><span class="o">-&gt;</span><span class="n">phy_index</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *</span>
<span class="cm"> * @controller: This is the controller object that receives the link down</span>
<span class="cm"> *    notification.</span>
<span class="cm"> * @port: This is the port object associated with the phy.  If the is no</span>
<span class="cm"> *    associated port this is an NULL.  The port is an invalid</span>
<span class="cm"> *    handle only if the phy was never port of this port.  This happens when</span>
<span class="cm"> *    the phy is not broadcasting the same SAS address as the other phys in the</span>
<span class="cm"> *    assigned port.</span>
<span class="cm"> * @phy: This is the phy object which has gone link down.</span>
<span class="cm"> *</span>
<span class="cm"> * This function handles the manual port configuration link down notifications.</span>
<span class="cm"> * Since all ports and phys are associated at initialization time we just turn</span>
<span class="cm"> * around and notifiy the port object of the link down event.  If this PHY is</span>
<span class="cm"> * not associated with a port there is no action taken. Is it possible to get a</span>
<span class="cm"> * link down notification from a phy that has no assocoated port?</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sci_mpc_agent_link_down</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">sci_port_configuration_agent</span> <span class="o">*</span><span class="n">port_agent</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">iport</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">isci_phy</span> <span class="o">*</span><span class="n">iphy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iport</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If we can form a new port from the remainder of the phys</span>
<span class="cm">		 * then we want to start the timer to allow the SCI User to</span>
<span class="cm">		 * cleanup old devices and rediscover the port before</span>
<span class="cm">		 * rebuilding the port with the phys that remain in the ready</span>
<span class="cm">		 * state.</span>
<span class="cm">		 */</span>
		<span class="n">port_agent</span><span class="o">-&gt;</span><span class="n">phy_ready_mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">iphy</span><span class="o">-&gt;</span><span class="n">phy_index</span><span class="p">);</span>
		<span class="n">port_agent</span><span class="o">-&gt;</span><span class="n">phy_configured_mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">iphy</span><span class="o">-&gt;</span><span class="n">phy_index</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Check to see if there are more phys waiting to be</span>
<span class="cm">		 * configured into a port. If there are allow the SCI User</span>
<span class="cm">		 * to tear down this port, if necessary, and then reconstruct</span>
<span class="cm">		 * the port after the timeout.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">port_agent</span><span class="o">-&gt;</span><span class="n">phy_configured_mask</span> <span class="o">==</span> <span class="mh">0x0000</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">port_agent</span><span class="o">-&gt;</span><span class="n">phy_ready_mask</span> <span class="o">!=</span> <span class="mh">0x0000</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">port_agent</span><span class="o">-&gt;</span><span class="n">timer_pending</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">port_agent</span><span class="o">-&gt;</span><span class="n">timer_pending</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

			<span class="n">sci_mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port_agent</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">,</span>
				      <span class="n">SCIC_SDS_MPC_RECONFIGURATION_TIMEOUT</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">sci_port_link_down</span><span class="p">(</span><span class="n">iport</span><span class="p">,</span> <span class="n">iphy</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* verify phys are assigned a valid SAS address for automatic port</span>
<span class="cm"> * configuration mode.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">enum</span> <span class="n">sci_status</span>
<span class="nf">sci_apc_agent_validate_phy_configuration</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">,</span>
					      <span class="k">struct</span> <span class="n">sci_port_configuration_agent</span> <span class="o">*</span><span class="n">port_agent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">phy_index</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">port_index</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sci_sas_address</span> <span class="n">sas_address</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sci_sas_address</span> <span class="n">phy_assigned_address</span><span class="p">;</span>

	<span class="n">phy_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">phy_index</span> <span class="o">&lt;</span> <span class="n">SCI_MAX_PHYS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">port_index</span> <span class="o">=</span> <span class="n">phy_index</span><span class="p">;</span>

		<span class="cm">/* Get the assigned SAS Address for the first PHY on the controller. */</span>
		<span class="n">sci_phy_get_sas_address</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">[</span><span class="n">phy_index</span><span class="p">],</span>
					    <span class="o">&amp;</span><span class="n">sas_address</span><span class="p">);</span>

		<span class="k">while</span> <span class="p">(</span><span class="o">++</span><span class="n">phy_index</span> <span class="o">&lt;</span> <span class="n">SCI_MAX_PHYS</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sci_phy_get_sas_address</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">[</span><span class="n">phy_index</span><span class="p">],</span>
						     <span class="o">&amp;</span><span class="n">phy_assigned_address</span><span class="p">);</span>

			<span class="cm">/* Verify each of the SAS address are all the same for every PHY */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sci_sas_address_compare</span><span class="p">(</span><span class="n">sas_address</span><span class="p">,</span> <span class="n">phy_assigned_address</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">port_agent</span><span class="o">-&gt;</span><span class="n">phy_valid_port_range</span><span class="p">[</span><span class="n">phy_index</span><span class="p">].</span><span class="n">min_index</span> <span class="o">=</span> <span class="n">port_index</span><span class="p">;</span>
				<span class="n">port_agent</span><span class="o">-&gt;</span><span class="n">phy_valid_port_range</span><span class="p">[</span><span class="n">phy_index</span><span class="p">].</span><span class="n">max_index</span> <span class="o">=</span> <span class="n">phy_index</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">port_agent</span><span class="o">-&gt;</span><span class="n">phy_valid_port_range</span><span class="p">[</span><span class="n">phy_index</span><span class="p">].</span><span class="n">min_index</span> <span class="o">=</span> <span class="n">phy_index</span><span class="p">;</span>
				<span class="n">port_agent</span><span class="o">-&gt;</span><span class="n">phy_valid_port_range</span><span class="p">[</span><span class="n">phy_index</span><span class="p">].</span><span class="n">max_index</span> <span class="o">=</span> <span class="n">phy_index</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">sci_port_configuration_agent_validate_ports</span><span class="p">(</span><span class="n">ihost</span><span class="p">,</span> <span class="n">port_agent</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This routine will restart the automatic port configuration timeout</span>
<span class="cm"> * timer for the next time period. This could be caused by either a link</span>
<span class="cm"> * down event or a link up event where we can not yet tell to which a phy</span>
<span class="cm"> * belongs.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sci_apc_agent_start_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">sci_port_configuration_agent</span> <span class="o">*</span><span class="n">port_agent</span><span class="p">,</span>
				      <span class="n">u32</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">port_agent</span><span class="o">-&gt;</span><span class="n">timer_pending</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">sci_mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port_agent</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sci_apc_agent_configure_ports</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">,</span>
					       <span class="k">struct</span> <span class="n">sci_port_configuration_agent</span> <span class="o">*</span><span class="n">port_agent</span><span class="p">,</span>
					       <span class="k">struct</span> <span class="n">isci_phy</span> <span class="o">*</span><span class="n">iphy</span><span class="p">,</span>
					       <span class="n">bool</span> <span class="n">start_timer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">port_index</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">sci_status</span> <span class="n">status</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">iport</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">SCIC_SDS_APC_ACTIVITY</span> <span class="n">apc_activity</span> <span class="o">=</span> <span class="n">SCIC_SDS_APC_SKIP_PHY</span><span class="p">;</span>

	<span class="n">iport</span> <span class="o">=</span> <span class="n">sci_port_configuration_agent_find_port</span><span class="p">(</span><span class="n">ihost</span><span class="p">,</span> <span class="n">iphy</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iport</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sci_port_is_valid_phy_assignment</span><span class="p">(</span><span class="n">iport</span><span class="p">,</span> <span class="n">iphy</span><span class="o">-&gt;</span><span class="n">phy_index</span><span class="p">))</span>
			<span class="n">apc_activity</span> <span class="o">=</span> <span class="n">SCIC_SDS_APC_ADD_PHY</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">apc_activity</span> <span class="o">=</span> <span class="n">SCIC_SDS_APC_SKIP_PHY</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * There is no matching Port for this PHY so lets search through the</span>
<span class="cm">		 * Ports and see if we can add the PHY to its own port or maybe start</span>
<span class="cm">		 * the timer and wait to see if a wider port can be made.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Note the break when we reach the condition of the port id == phy id */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">port_index</span> <span class="o">=</span> <span class="n">port_agent</span><span class="o">-&gt;</span><span class="n">phy_valid_port_range</span><span class="p">[</span><span class="n">iphy</span><span class="o">-&gt;</span><span class="n">phy_index</span><span class="p">].</span><span class="n">min_index</span><span class="p">;</span>
		     <span class="n">port_index</span> <span class="o">&lt;=</span> <span class="n">port_agent</span><span class="o">-&gt;</span><span class="n">phy_valid_port_range</span><span class="p">[</span><span class="n">iphy</span><span class="o">-&gt;</span><span class="n">phy_index</span><span class="p">].</span><span class="n">max_index</span><span class="p">;</span>
		     <span class="n">port_index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

			<span class="n">iport</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">ports</span><span class="p">[</span><span class="n">port_index</span><span class="p">];</span>

			<span class="cm">/* First we must make sure that this PHY can be added to this Port. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sci_port_is_valid_phy_assignment</span><span class="p">(</span><span class="n">iport</span><span class="p">,</span> <span class="n">iphy</span><span class="o">-&gt;</span><span class="n">phy_index</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Port contains a PHY with a greater PHY ID than the current</span>
<span class="cm">				 * PHY that has gone link up.  This phy can not be part of any</span>
<span class="cm">				 * port so skip it and move on. */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">iport</span><span class="o">-&gt;</span><span class="n">active_phy_mask</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">iphy</span><span class="o">-&gt;</span><span class="n">phy_index</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">apc_activity</span> <span class="o">=</span> <span class="n">SCIC_SDS_APC_SKIP_PHY</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="cm">/*</span>
<span class="cm">				 * We have reached the end of our Port list and have not found</span>
<span class="cm">				 * any reason why we should not either add the PHY to the port</span>
<span class="cm">				 * or wait for more phys to become active. */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">iport</span><span class="o">-&gt;</span><span class="n">physical_port_index</span> <span class="o">==</span> <span class="n">iphy</span><span class="o">-&gt;</span><span class="n">phy_index</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/*</span>
<span class="cm">					 * The Port either has no active PHYs.</span>
<span class="cm">					 * Consider that if the port had any active PHYs we would have</span>
<span class="cm">					 * or active PHYs with</span>
<span class="cm">					 * a lower PHY Id than this PHY. */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">apc_activity</span> <span class="o">!=</span> <span class="n">SCIC_SDS_APC_START_TIMER</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">apc_activity</span> <span class="o">=</span> <span class="n">SCIC_SDS_APC_ADD_PHY</span><span class="p">;</span>
					<span class="p">}</span>

					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="cm">/*</span>
<span class="cm">				 * The current Port has no active PHYs and this PHY could be part</span>
<span class="cm">				 * of this Port.  Since we dont know as yet setup to start the</span>
<span class="cm">				 * timer and see if there is a better configuration. */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">iport</span><span class="o">-&gt;</span><span class="n">active_phy_mask</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">apc_activity</span> <span class="o">=</span> <span class="n">SCIC_SDS_APC_START_TIMER</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">iport</span><span class="o">-&gt;</span><span class="n">active_phy_mask</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * The Port has an active phy and the current Phy can not</span>
<span class="cm">				 * participate in this port so skip the PHY and see if</span>
<span class="cm">				 * there is a better configuration. */</span>
				<span class="n">apc_activity</span> <span class="o">=</span> <span class="n">SCIC_SDS_APC_SKIP_PHY</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check to see if the start timer operations should instead map to an</span>
<span class="cm">	 * add phy operation.  This is caused because we have been waiting to</span>
<span class="cm">	 * add a phy to a port but could not becuase the automatic port</span>
<span class="cm">	 * configuration engine had a choice of possible ports for the phy.</span>
<span class="cm">	 * Since we have gone through a timeout we are going to restrict the</span>
<span class="cm">	 * choice to the smallest possible port. */</span>
	<span class="k">if</span> <span class="p">(</span>
		<span class="p">(</span><span class="n">start_timer</span> <span class="o">==</span> <span class="nb">false</span><span class="p">)</span>
		<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">apc_activity</span> <span class="o">==</span> <span class="n">SCIC_SDS_APC_START_TIMER</span><span class="p">)</span>
		<span class="p">)</span> <span class="p">{</span>
		<span class="n">apc_activity</span> <span class="o">=</span> <span class="n">SCIC_SDS_APC_ADD_PHY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">apc_activity</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SCIC_SDS_APC_ADD_PHY</span>:
		<span class="n">status</span> <span class="o">=</span> <span class="n">sci_port_add_phy</span><span class="p">(</span><span class="n">iport</span><span class="p">,</span> <span class="n">iphy</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">SCI_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">port_agent</span><span class="o">-&gt;</span><span class="n">phy_configured_mask</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">iphy</span><span class="o">-&gt;</span><span class="n">phy_index</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SCIC_SDS_APC_START_TIMER</span>:
		<span class="n">sci_apc_agent_start_timer</span><span class="p">(</span><span class="n">port_agent</span><span class="p">,</span>
					  <span class="n">SCIC_SDS_APC_WAIT_LINK_UP_NOTIFICATION</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SCIC_SDS_APC_SKIP_PHY</span>:
	<span class="nl">default:</span>
		<span class="cm">/* do nothing the PHY can not be made part of a port at this time. */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sci_apc_agent_link_up - handle apc link up events</span>
<span class="cm"> * @scic: This is the controller object that receives the link up</span>
<span class="cm"> *    notification.</span>
<span class="cm"> * @sci_port: This is the port object associated with the phy.  If the is no</span>
<span class="cm"> *    associated port this is an NULL.</span>
<span class="cm"> * @sci_phy: This is the phy object which has gone link up.</span>
<span class="cm"> *</span>
<span class="cm"> * This method handles the automatic port configuration for link up</span>
<span class="cm"> * notifications. Is it possible to get a link down notification from a phy</span>
<span class="cm"> * that has no assocoated port?</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sci_apc_agent_link_up</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">sci_port_configuration_agent</span> <span class="o">*</span><span class="n">port_agent</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">iport</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">isci_phy</span> <span class="o">*</span><span class="n">iphy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">phy_index</span>  <span class="o">=</span> <span class="n">iphy</span><span class="o">-&gt;</span><span class="n">phy_index</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iport</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* the phy is not the part of this port */</span>
		<span class="n">port_agent</span><span class="o">-&gt;</span><span class="n">phy_ready_mask</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">phy_index</span><span class="p">;</span>
		<span class="n">sci_apc_agent_start_timer</span><span class="p">(</span><span class="n">port_agent</span><span class="p">,</span>
					  <span class="n">SCIC_SDS_APC_WAIT_LINK_UP_NOTIFICATION</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* the phy is already the part of the port */</span>
		<span class="n">u32</span> <span class="n">port_state</span> <span class="o">=</span> <span class="n">iport</span><span class="o">-&gt;</span><span class="n">sm</span><span class="p">.</span><span class="n">current_state_id</span><span class="p">;</span>

		<span class="cm">/* if the PORT&#39;S state is resetting then the link up is from</span>
<span class="cm">		 * port hard reset in this case, we need to tell the port</span>
<span class="cm">		 * that link up is recieved</span>
<span class="cm">		 */</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">port_state</span> <span class="o">!=</span> <span class="n">SCI_PORT_RESETTING</span><span class="p">);</span>
		<span class="n">port_agent</span><span class="o">-&gt;</span><span class="n">phy_ready_mask</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">phy_index</span><span class="p">;</span>
		<span class="n">sci_port_link_up</span><span class="p">(</span><span class="n">iport</span><span class="p">,</span> <span class="n">iphy</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *</span>
<span class="cm"> * @controller: This is the controller object that receives the link down</span>
<span class="cm"> *    notification.</span>
<span class="cm"> * @iport: This is the port object associated with the phy.  If the is no</span>
<span class="cm"> *    associated port this is an NULL.</span>
<span class="cm"> * @iphy: This is the phy object which has gone link down.</span>
<span class="cm"> *</span>
<span class="cm"> * This method handles the automatic port configuration link down</span>
<span class="cm"> * notifications. not associated with a port there is no action taken. Is it</span>
<span class="cm"> * possible to get a link down notification from a phy that has no assocoated</span>
<span class="cm"> * port?</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sci_apc_agent_link_down</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">sci_port_configuration_agent</span> <span class="o">*</span><span class="n">port_agent</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">iport</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">isci_phy</span> <span class="o">*</span><span class="n">iphy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">port_agent</span><span class="o">-&gt;</span><span class="n">phy_ready_mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">iphy</span><span class="o">-&gt;</span><span class="n">phy_index</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iport</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">port_agent</span><span class="o">-&gt;</span><span class="n">phy_configured_mask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">iphy</span><span class="o">-&gt;</span><span class="n">phy_index</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">enum</span> <span class="n">sci_status</span> <span class="n">status</span><span class="p">;</span>

		<span class="n">status</span> <span class="o">=</span> <span class="n">sci_port_remove_phy</span><span class="p">(</span><span class="n">iport</span><span class="p">,</span> <span class="n">iphy</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">SCI_SUCCESS</span><span class="p">)</span>
			<span class="n">port_agent</span><span class="o">-&gt;</span><span class="n">phy_configured_mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">iphy</span><span class="o">-&gt;</span><span class="n">phy_index</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* configure the phys into ports when the timer fires */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">apc_agent_timeout</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">index</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sci_timer</span> <span class="o">*</span><span class="n">tmr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sci_timer</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sci_port_configuration_agent</span> <span class="o">*</span><span class="n">port_agent</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">configure_phy_mask</span><span class="p">;</span>

	<span class="n">port_agent</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">tmr</span><span class="p">,</span> <span class="n">typeof</span><span class="p">(</span><span class="o">*</span><span class="n">port_agent</span><span class="p">),</span> <span class="n">timer</span><span class="p">);</span>
	<span class="n">ihost</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">port_agent</span><span class="p">,</span> <span class="n">typeof</span><span class="p">(</span><span class="o">*</span><span class="n">ihost</span><span class="p">),</span> <span class="n">port_agent</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">scic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tmr</span><span class="o">-&gt;</span><span class="n">cancel</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="n">port_agent</span><span class="o">-&gt;</span><span class="n">timer_pending</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">configure_phy_mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">port_agent</span><span class="o">-&gt;</span><span class="n">phy_configured_mask</span> <span class="o">&amp;</span> <span class="n">port_agent</span><span class="o">-&gt;</span><span class="n">phy_ready_mask</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">configure_phy_mask</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">SCI_MAX_PHYS</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">configure_phy_mask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">index</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">sci_apc_agent_configure_ports</span><span class="p">(</span><span class="n">ihost</span><span class="p">,</span> <span class="n">port_agent</span><span class="p">,</span>
						   <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="nb">false</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_controller_start_complete</span><span class="p">(</span><span class="n">ihost</span><span class="p">))</span>
		<span class="n">sci_controller_transition_to_ready</span><span class="p">(</span><span class="n">ihost</span><span class="p">,</span> <span class="n">SCI_SUCCESS</span><span class="p">);</span>

<span class="nl">done:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">scic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ******************************************************************************</span>
<span class="cm"> * Public port configuration agent routines</span>
<span class="cm"> * ****************************************************************************** */</span>

<span class="cm">/**</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * This method will construct the port configuration agent for operation. This</span>
<span class="cm"> * call is universal for both manual port configuration and automatic port</span>
<span class="cm"> * configuration modes.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">sci_port_configuration_agent_construct</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">sci_port_configuration_agent</span> <span class="o">*</span><span class="n">port_agent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">index</span><span class="p">;</span>

	<span class="n">port_agent</span><span class="o">-&gt;</span><span class="n">phy_configured_mask</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
	<span class="n">port_agent</span><span class="o">-&gt;</span><span class="n">phy_ready_mask</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>

	<span class="n">port_agent</span><span class="o">-&gt;</span><span class="n">link_up_handler</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">port_agent</span><span class="o">-&gt;</span><span class="n">link_down_handler</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">port_agent</span><span class="o">-&gt;</span><span class="n">timer_pending</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">SCI_MAX_PORTS</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">port_agent</span><span class="o">-&gt;</span><span class="n">phy_valid_port_range</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">min_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">port_agent</span><span class="o">-&gt;</span><span class="n">phy_valid_port_range</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">max_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="n">bool</span> <span class="nf">is_port_config_apc</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ihost</span><span class="o">-&gt;</span><span class="n">port_agent</span><span class="p">.</span><span class="n">link_up_handler</span> <span class="o">==</span> <span class="n">sci_apc_agent_link_up</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="n">sci_status</span> <span class="nf">sci_port_configuration_agent_initialize</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">sci_port_configuration_agent</span> <span class="o">*</span><span class="n">port_agent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">sci_status</span> <span class="n">status</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">sci_port_configuration_mode</span> <span class="n">mode</span><span class="p">;</span>

	<span class="n">mode</span> <span class="o">=</span> <span class="n">ihost</span><span class="o">-&gt;</span><span class="n">oem_parameters</span><span class="p">.</span><span class="n">controller</span><span class="p">.</span><span class="n">mode_type</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="n">SCIC_PORT_MANUAL_CONFIGURATION_MODE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">sci_mpc_agent_validate_phy_configuration</span><span class="p">(</span>
				<span class="n">ihost</span><span class="p">,</span> <span class="n">port_agent</span><span class="p">);</span>

		<span class="n">port_agent</span><span class="o">-&gt;</span><span class="n">link_up_handler</span> <span class="o">=</span> <span class="n">sci_mpc_agent_link_up</span><span class="p">;</span>
		<span class="n">port_agent</span><span class="o">-&gt;</span><span class="n">link_down_handler</span> <span class="o">=</span> <span class="n">sci_mpc_agent_link_down</span><span class="p">;</span>

		<span class="n">sci_init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port_agent</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">,</span> <span class="n">mpc_agent_timeout</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">sci_apc_agent_validate_phy_configuration</span><span class="p">(</span>
				<span class="n">ihost</span><span class="p">,</span> <span class="n">port_agent</span><span class="p">);</span>

		<span class="n">port_agent</span><span class="o">-&gt;</span><span class="n">link_up_handler</span> <span class="o">=</span> <span class="n">sci_apc_agent_link_up</span><span class="p">;</span>
		<span class="n">port_agent</span><span class="o">-&gt;</span><span class="n">link_down_handler</span> <span class="o">=</span> <span class="n">sci_apc_agent_link_down</span><span class="p">;</span>

		<span class="n">sci_init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port_agent</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">,</span> <span class="n">apc_agent_timeout</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
