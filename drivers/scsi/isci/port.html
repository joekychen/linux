<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › scsi › isci › port.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>port.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * This file is provided under a dual BSD/GPLv2 license.  When using or</span>
<span class="cm"> * redistributing this file, you may do so under either license.</span>
<span class="cm"> *</span>
<span class="cm"> * GPL LICENSE SUMMARY</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of version 2 of the GNU General Public License as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="cm"> * General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.</span>
<span class="cm"> * The full GNU General Public License is included in this distribution</span>
<span class="cm"> * in the file called LICENSE.GPL.</span>
<span class="cm"> *</span>
<span class="cm"> * BSD LICENSE</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.</span>
<span class="cm"> * All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * Redistribution and use in source and binary forms, with or without</span>
<span class="cm"> * modification, are permitted provided that the following conditions</span>
<span class="cm"> * are met:</span>
<span class="cm"> *</span>
<span class="cm"> *   * Redistributions of source code must retain the above copyright</span>
<span class="cm"> *     notice, this list of conditions and the following disclaimer.</span>
<span class="cm"> *   * Redistributions in binary form must reproduce the above copyright</span>
<span class="cm"> *     notice, this list of conditions and the following disclaimer in</span>
<span class="cm"> *     the documentation and/or other materials provided with the</span>
<span class="cm"> *     distribution.</span>
<span class="cm"> *   * Neither the name of Intel Corporation nor the names of its</span>
<span class="cm"> *     contributors may be used to endorse or promote products derived</span>
<span class="cm"> *     from this software without specific prior written permission.</span>
<span class="cm"> *</span>
<span class="cm"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span>
<span class="cm"> * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span>
<span class="cm"> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</span>
<span class="cm"> * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</span>
<span class="cm"> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span>
<span class="cm"> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span>
<span class="cm"> * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span>
<span class="cm"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span>
<span class="cm"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
<span class="cm"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span>
<span class="cm"> * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<span class="cm"> */</span>

<span class="cp">#include &quot;isci.h&quot;</span>
<span class="cp">#include &quot;port.h&quot;</span>
<span class="cp">#include &quot;request.h&quot;</span>

<span class="cp">#define SCIC_SDS_PORT_HARD_RESET_TIMEOUT  (1000)</span>
<span class="cp">#define SCU_DUMMY_INDEX    (0xFFFF)</span>

<span class="cp">#undef C</span>
<span class="cp">#define C(a) (#a)</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">port_state_name</span><span class="p">(</span><span class="k">enum</span> <span class="n">sci_port_states</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="n">strings</span><span class="p">[]</span> <span class="o">=</span> <span class="n">PORT_STATES</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">strings</span><span class="p">[</span><span class="n">state</span><span class="p">];</span>
<span class="p">}</span>
<span class="cp">#undef C</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="nf">sciport_to_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">iport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">iport</span><span class="o">-&gt;</span><span class="n">physical_port_index</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">table</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">SCIC_SDS_DUMMY_PORT</span><span class="p">)</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">SCI_MAX_PORTS</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">table</span> <span class="o">=</span> <span class="n">iport</span> <span class="o">-</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">ihost</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">typeof</span><span class="p">(</span><span class="o">*</span><span class="n">ihost</span><span class="p">),</span> <span class="n">ports</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

	<span class="k">return</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sci_port_get_protocols</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">iport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sci_phy_proto</span> <span class="o">*</span><span class="n">proto</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">index</span><span class="p">;</span>

	<span class="n">proto</span><span class="o">-&gt;</span><span class="n">all</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">SCI_MAX_PHYS</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">isci_phy</span> <span class="o">*</span><span class="n">iphy</span> <span class="o">=</span> <span class="n">iport</span><span class="o">-&gt;</span><span class="n">phy_table</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iphy</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">sci_phy_get_protocols</span><span class="p">(</span><span class="n">iphy</span><span class="p">,</span> <span class="n">proto</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">sci_port_get_phys</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">iport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">index</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mask</span><span class="p">;</span>

	<span class="n">mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">SCI_MAX_PHYS</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iport</span><span class="o">-&gt;</span><span class="n">phy_table</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
			<span class="n">mask</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">index</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">mask</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sci_port_get_properties() - This method simply returns the properties</span>
<span class="cm"> *    regarding the port, such as: physical index, protocols, sas address, etc.</span>
<span class="cm"> * @port: this parameter specifies the port for which to retrieve the physical</span>
<span class="cm"> *    index.</span>
<span class="cm"> * @properties: This parameter specifies the properties structure into which to</span>
<span class="cm"> *    copy the requested information.</span>
<span class="cm"> *</span>
<span class="cm"> * Indicate if the user specified a valid port. SCI_SUCCESS This value is</span>
<span class="cm"> * returned if the specified port was valid. SCI_FAILURE_INVALID_PORT This</span>
<span class="cm"> * value is returned if the specified port is not valid.  When this value is</span>
<span class="cm"> * returned, no data is copied to the properties output parameter.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">sci_status</span> <span class="nf">sci_port_get_properties</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">iport</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">sci_port_properties</span> <span class="o">*</span><span class="n">prop</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iport</span> <span class="o">||</span> <span class="n">iport</span><span class="o">-&gt;</span><span class="n">logical_port_index</span> <span class="o">==</span> <span class="n">SCIC_SDS_DUMMY_PORT</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">SCI_FAILURE_INVALID_PORT</span><span class="p">;</span>

	<span class="n">prop</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">iport</span><span class="o">-&gt;</span><span class="n">logical_port_index</span><span class="p">;</span>
	<span class="n">prop</span><span class="o">-&gt;</span><span class="n">phy_mask</span> <span class="o">=</span> <span class="n">sci_port_get_phys</span><span class="p">(</span><span class="n">iport</span><span class="p">);</span>
	<span class="n">sci_port_get_sas_address</span><span class="p">(</span><span class="n">iport</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">prop</span><span class="o">-&gt;</span><span class="n">local</span><span class="p">.</span><span class="n">sas_address</span><span class="p">);</span>
	<span class="n">sci_port_get_protocols</span><span class="p">(</span><span class="n">iport</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">prop</span><span class="o">-&gt;</span><span class="n">local</span><span class="p">.</span><span class="n">protocols</span><span class="p">);</span>
	<span class="n">sci_port_get_attached_sas_address</span><span class="p">(</span><span class="n">iport</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">prop</span><span class="o">-&gt;</span><span class="n">remote</span><span class="p">.</span><span class="n">sas_address</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">SCI_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sci_port_bcn_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">iport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">isci_phy</span> <span class="o">*</span><span class="n">iphy</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">iport</span><span class="o">-&gt;</span><span class="n">phy_table</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iphy</span> <span class="o">=</span> <span class="n">iport</span><span class="o">-&gt;</span><span class="n">phy_table</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iphy</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iphy</span><span class="o">-&gt;</span><span class="n">link_layer_registers</span><span class="o">-&gt;</span><span class="n">link_layer_control</span><span class="p">);</span>
		<span class="cm">/* clear the bit by writing 1. */</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iphy</span><span class="o">-&gt;</span><span class="n">link_layer_registers</span><span class="o">-&gt;</span><span class="n">link_layer_control</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">isci_port_bc_change_received</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">iport</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">isci_phy</span> <span class="o">*</span><span class="n">iphy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;%s: isci_phy = %p, sas_phy = %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span> <span class="n">iphy</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iphy</span><span class="o">-&gt;</span><span class="n">sas_phy</span><span class="p">);</span>

	<span class="n">ihost</span><span class="o">-&gt;</span><span class="n">sas_ha</span><span class="p">.</span><span class="n">notify_port_event</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iphy</span><span class="o">-&gt;</span><span class="n">sas_phy</span><span class="p">,</span> <span class="n">PORTE_BROADCAST_RCVD</span><span class="p">);</span>
	<span class="n">sci_port_bcn_enable</span><span class="p">(</span><span class="n">iport</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">isci_port_link_up</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">isci_host</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">iport</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">isci_phy</span> <span class="o">*</span><span class="n">iphy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sci_port_properties</span> <span class="n">properties</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">success</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">isci_host</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;%s: isci_port = %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span> <span class="n">iport</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iphy</span><span class="o">-&gt;</span><span class="n">sas_phy</span><span class="p">.</span><span class="n">frame_rcvd_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">sci_port_get_properties</span><span class="p">(</span><span class="n">iport</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">properties</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iphy</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">SAS_PROTOCOL_SATA</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">attached_sas_address</span><span class="p">;</span>

		<span class="n">iphy</span><span class="o">-&gt;</span><span class="n">sas_phy</span><span class="p">.</span><span class="n">oob_mode</span> <span class="o">=</span> <span class="n">SATA_OOB_MODE</span><span class="p">;</span>
		<span class="n">iphy</span><span class="o">-&gt;</span><span class="n">sas_phy</span><span class="p">.</span><span class="n">frame_rcvd_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dev_to_host_fis</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * For direct-attached SATA devices, the SCI core will</span>
<span class="cm">		 * automagically assign a SAS address to the end device</span>
<span class="cm">		 * for the purpose of creating a port. This SAS address</span>
<span class="cm">		 * will not be the same as assigned to the PHY and needs</span>
<span class="cm">		 * to be obtained from struct sci_port_properties properties.</span>
<span class="cm">		 */</span>
		<span class="n">attached_sas_address</span> <span class="o">=</span> <span class="n">properties</span><span class="p">.</span><span class="n">remote</span><span class="p">.</span><span class="n">sas_address</span><span class="p">.</span><span class="n">high</span><span class="p">;</span>
		<span class="n">attached_sas_address</span> <span class="o">&lt;&lt;=</span> <span class="mi">32</span><span class="p">;</span>
		<span class="n">attached_sas_address</span> <span class="o">|=</span> <span class="n">properties</span><span class="p">.</span><span class="n">remote</span><span class="p">.</span><span class="n">sas_address</span><span class="p">.</span><span class="n">low</span><span class="p">;</span>
		<span class="n">swab64s</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attached_sas_address</span><span class="p">);</span>

		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iphy</span><span class="o">-&gt;</span><span class="n">sas_phy</span><span class="p">.</span><span class="n">attached_sas_addr</span><span class="p">,</span>
		       <span class="o">&amp;</span><span class="n">attached_sas_address</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">attached_sas_address</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">iphy</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">SAS_PROTOCOL_SSP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iphy</span><span class="o">-&gt;</span><span class="n">sas_phy</span><span class="p">.</span><span class="n">oob_mode</span> <span class="o">=</span> <span class="n">SAS_OOB_MODE</span><span class="p">;</span>
		<span class="n">iphy</span><span class="o">-&gt;</span><span class="n">sas_phy</span><span class="p">.</span><span class="n">frame_rcvd_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sas_identify_frame</span><span class="p">);</span>

		<span class="cm">/* Copy the attached SAS address from the IAF */</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">iphy</span><span class="o">-&gt;</span><span class="n">sas_phy</span><span class="p">.</span><span class="n">attached_sas_addr</span><span class="p">,</span>
		       <span class="n">iphy</span><span class="o">-&gt;</span><span class="n">frame_rcvd</span><span class="p">.</span><span class="n">iaf</span><span class="p">.</span><span class="n">sas_addr</span><span class="p">,</span> <span class="n">SAS_ADDR_SIZE</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">isci_host</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: unkown target</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">success</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">iphy</span><span class="o">-&gt;</span><span class="n">sas_phy</span><span class="p">.</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">negotiated_linkrate</span> <span class="o">=</span> <span class="n">sci_phy_linkrate</span><span class="p">(</span><span class="n">iphy</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iphy</span><span class="o">-&gt;</span><span class="n">sas_phy</span><span class="p">.</span><span class="n">frame_rcvd_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Notify libsas that we have an address frame, if indeed</span>
<span class="cm">	 * we&#39;ve found an SSP, SMP, or STP target */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">success</span><span class="p">)</span>
		<span class="n">isci_host</span><span class="o">-&gt;</span><span class="n">sas_ha</span><span class="p">.</span><span class="n">notify_port_event</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iphy</span><span class="o">-&gt;</span><span class="n">sas_phy</span><span class="p">,</span>
						    <span class="n">PORTE_BYTES_DMAED</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * isci_port_link_down() - This function is called by the sci core when a link</span>
<span class="cm"> *    becomes inactive.</span>
<span class="cm"> * @isci_host: This parameter specifies the isci host object.</span>
<span class="cm"> * @phy: This parameter specifies the isci phy with the active link.</span>
<span class="cm"> * @port: This parameter specifies the isci port with the active link.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">isci_port_link_down</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">isci_host</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">isci_phy</span> <span class="o">*</span><span class="n">isci_phy</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">isci_port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">isci_remote_device</span> <span class="o">*</span><span class="n">isci_device</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">isci_host</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;%s: isci_port = %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">isci_port</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">isci_port</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* check to see if this is the last phy on this port. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">isci_phy</span><span class="o">-&gt;</span><span class="n">sas_phy</span><span class="p">.</span><span class="n">port</span> <span class="o">&amp;&amp;</span>
		    <span class="n">isci_phy</span><span class="o">-&gt;</span><span class="n">sas_phy</span><span class="p">.</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">num_phys</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* change the state for all devices on this port.  The</span>
<span class="cm">			* next task sent to this device will be returned as</span>
<span class="cm">			* SAS_TASK_UNDELIVERED, and the scsi mid layer will</span>
<span class="cm">			* remove the target</span>
<span class="cm">			*/</span>
			<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">isci_device</span><span class="p">,</span>
					    <span class="o">&amp;</span><span class="n">isci_port</span><span class="o">-&gt;</span><span class="n">remote_dev_list</span><span class="p">,</span>
					    <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">isci_host</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="s">&quot;%s: isci_device = %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">__func__</span><span class="p">,</span> <span class="n">isci_device</span><span class="p">);</span>
				<span class="n">set_bit</span><span class="p">(</span><span class="n">IDEV_GONE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">isci_device</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Notify libsas of the borken link, this will trigger calls to our</span>
<span class="cm">	 * isci_port_deformed and isci_dev_gone functions.</span>
<span class="cm">	 */</span>
	<span class="n">sas_phy_disconnected</span><span class="p">(</span><span class="o">&amp;</span><span class="n">isci_phy</span><span class="o">-&gt;</span><span class="n">sas_phy</span><span class="p">);</span>
	<span class="n">isci_host</span><span class="o">-&gt;</span><span class="n">sas_ha</span><span class="p">.</span><span class="n">notify_phy_event</span><span class="p">(</span><span class="o">&amp;</span><span class="n">isci_phy</span><span class="o">-&gt;</span><span class="n">sas_phy</span><span class="p">,</span>
					   <span class="n">PHYE_LOSS_OF_SIGNAL</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">isci_host</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;%s: isci_port = %p - Done</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">isci_port</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">is_port_ready_state</span><span class="p">(</span><span class="k">enum</span> <span class="n">sci_port_states</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SCI_PORT_READY</span>:
	<span class="k">case</span> <span class="n">SCI_PORT_SUB_WAITING</span>:
	<span class="k">case</span> <span class="n">SCI_PORT_SUB_OPERATIONAL</span>:
	<span class="k">case</span> <span class="n">SCI_PORT_SUB_CONFIGURING</span>:
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* flag dummy rnc hanling when exiting a ready state */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">port_state_machine_change</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">iport</span><span class="p">,</span>
				      <span class="k">enum</span> <span class="n">sci_port_states</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sci_base_state_machine</span> <span class="o">*</span><span class="n">sm</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iport</span><span class="o">-&gt;</span><span class="n">sm</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">sci_port_states</span> <span class="n">old_state</span> <span class="o">=</span> <span class="n">sm</span><span class="o">-&gt;</span><span class="n">current_state_id</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_port_ready_state</span><span class="p">(</span><span class="n">old_state</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">is_port_ready_state</span><span class="p">(</span><span class="n">state</span><span class="p">))</span>
		<span class="n">iport</span><span class="o">-&gt;</span><span class="n">ready_exit</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="n">sci_change_state</span><span class="p">(</span><span class="n">sm</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
	<span class="n">iport</span><span class="o">-&gt;</span><span class="n">ready_exit</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * isci_port_hard_reset_complete() - This function is called by the sci core</span>
<span class="cm"> *    when the hard reset complete notification has been received.</span>
<span class="cm"> * @port: This parameter specifies the sci port with the active link.</span>
<span class="cm"> * @completion_status: This parameter specifies the core status for the reset</span>
<span class="cm"> *    process.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">isci_port_hard_reset_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">isci_port</span><span class="p">,</span>
					  <span class="k">enum</span> <span class="n">sci_status</span> <span class="n">completion_status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span> <span class="o">=</span> <span class="n">isci_port</span><span class="o">-&gt;</span><span class="n">owning_controller</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;%s: isci_port = %p, completion_status=%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">__func__</span><span class="p">,</span> <span class="n">isci_port</span><span class="p">,</span> <span class="n">completion_status</span><span class="p">);</span>

	<span class="cm">/* Save the status of the hard reset from the port. */</span>
	<span class="n">isci_port</span><span class="o">-&gt;</span><span class="n">hard_reset_status</span> <span class="o">=</span> <span class="n">completion_status</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">completion_status</span> <span class="o">!=</span> <span class="n">SCI_SUCCESS</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* The reset failed.  The port state is now SCI_PORT_FAILED. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">isci_port</span><span class="o">-&gt;</span><span class="n">active_phy_mask</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">phy_idx</span> <span class="o">=</span> <span class="n">isci_port</span><span class="o">-&gt;</span><span class="n">last_active_phy</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">isci_phy</span> <span class="o">*</span><span class="n">iphy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">[</span><span class="n">phy_idx</span><span class="p">];</span>

			<span class="cm">/* Generate the link down now to the host, since it</span>
<span class="cm">			 * was intercepted by the hard reset state machine when</span>
<span class="cm">			 * it really happened.</span>
<span class="cm">			 */</span>
			<span class="n">isci_port_link_down</span><span class="p">(</span><span class="n">ihost</span><span class="p">,</span> <span class="n">iphy</span><span class="p">,</span> <span class="n">isci_port</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* Advance the port state so that link state changes will be</span>
<span class="cm">		 * noticed.</span>
<span class="cm">		 */</span>
		<span class="n">port_state_machine_change</span><span class="p">(</span><span class="n">isci_port</span><span class="p">,</span> <span class="n">SCI_PORT_SUB_WAITING</span><span class="p">);</span>

	<span class="p">}</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">IPORT_RESET_PENDING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">isci_port</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">eventq</span><span class="p">);</span>

<span class="p">}</span>

<span class="cm">/* This method will return a true value if the specified phy can be assigned to</span>
<span class="cm"> * this port The following is a list of phys for each port that are allowed: -</span>
<span class="cm"> * Port 0 - 3 2 1 0 - Port 1 -     1 - Port 2 - 3 2 - Port 3 - 3 This method</span>
<span class="cm"> * doesn&#39;t preclude all configurations.  It merely ensures that a phy is part</span>
<span class="cm"> * of the allowable set of phy identifiers for that port.  For example, one</span>
<span class="cm"> * could assign phy 3 to port 0 and no other phys.  Please refer to</span>
<span class="cm"> * sci_port_is_phy_mask_valid() for information regarding whether the</span>
<span class="cm"> * phy_mask for a port can be supported. bool true if this is a valid phy</span>
<span class="cm"> * assignment for the port false if this is not a valid phy assignment for the</span>
<span class="cm"> * port</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="nf">sci_port_is_valid_phy_assignment</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">iport</span><span class="p">,</span> <span class="n">u32</span> <span class="n">phy_index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span> <span class="o">=</span> <span class="n">iport</span><span class="o">-&gt;</span><span class="n">owning_controller</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sci_user_parameters</span> <span class="o">*</span><span class="n">user</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">user_parameters</span><span class="p">;</span>

	<span class="cm">/* Initialize to invalid value. */</span>
	<span class="n">u32</span> <span class="n">existing_phy_index</span> <span class="o">=</span> <span class="n">SCI_MAX_PHYS</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">index</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">iport</span><span class="o">-&gt;</span><span class="n">physical_port_index</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">phy_index</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iport</span><span class="o">-&gt;</span><span class="n">physical_port_index</span> <span class="o">==</span> <span class="mi">3</span> <span class="o">&amp;&amp;</span> <span class="n">phy_index</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iport</span><span class="o">-&gt;</span><span class="n">physical_port_index</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">phy_index</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">phy_index</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">SCI_MAX_PHYS</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iport</span><span class="o">-&gt;</span><span class="n">phy_table</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">index</span> <span class="o">!=</span> <span class="n">phy_index</span><span class="p">)</span>
			<span class="n">existing_phy_index</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>

	<span class="cm">/* Ensure that all of the phys in the port are capable of</span>
<span class="cm">	 * operating at the same maximum link rate.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">existing_phy_index</span> <span class="o">&lt;</span> <span class="n">SCI_MAX_PHYS</span> <span class="o">&amp;&amp;</span>
	    <span class="n">user</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">[</span><span class="n">phy_index</span><span class="p">].</span><span class="n">max_speed_generation</span> <span class="o">!=</span>
	    <span class="n">user</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">[</span><span class="n">existing_phy_index</span><span class="p">].</span><span class="n">max_speed_generation</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *</span>
<span class="cm"> * @sci_port: This is the port object for which to determine if the phy mask</span>
<span class="cm"> *    can be supported.</span>
<span class="cm"> *</span>
<span class="cm"> * This method will return a true value if the port&#39;s phy mask can be supported</span>
<span class="cm"> * by the SCU. The following is a list of valid PHY mask configurations for</span>
<span class="cm"> * each port: - Port 0 - [[3  2] 1] 0 - Port 1 -        [1] - Port 2 - [[3] 2]</span>
<span class="cm"> * - Port 3 -  [3] This method returns a boolean indication specifying if the</span>
<span class="cm"> * phy mask can be supported. true if this is a valid phy assignment for the</span>
<span class="cm"> * port false if this is not a valid phy assignment for the port</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">sci_port_is_phy_mask_valid</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">iport</span><span class="p">,</span>
	<span class="n">u32</span> <span class="n">phy_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iport</span><span class="o">-&gt;</span><span class="n">physical_port_index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(((</span><span class="n">phy_mask</span> <span class="o">&amp;</span> <span class="mh">0x0F</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x0F</span><span class="p">)</span>
		    <span class="o">||</span> <span class="p">((</span><span class="n">phy_mask</span> <span class="o">&amp;</span> <span class="mh">0x03</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x03</span><span class="p">)</span>
		    <span class="o">||</span> <span class="p">((</span><span class="n">phy_mask</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x01</span><span class="p">)</span>
		    <span class="o">||</span> <span class="p">(</span><span class="n">phy_mask</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">iport</span><span class="o">-&gt;</span><span class="n">physical_port_index</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(((</span><span class="n">phy_mask</span> <span class="o">&amp;</span> <span class="mh">0x02</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x02</span><span class="p">)</span>
		    <span class="o">||</span> <span class="p">(</span><span class="n">phy_mask</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">iport</span><span class="o">-&gt;</span><span class="n">physical_port_index</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(((</span><span class="n">phy_mask</span> <span class="o">&amp;</span> <span class="mh">0x0C</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x0C</span><span class="p">)</span>
		    <span class="o">||</span> <span class="p">((</span><span class="n">phy_mask</span> <span class="o">&amp;</span> <span class="mh">0x04</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x04</span><span class="p">)</span>
		    <span class="o">||</span> <span class="p">(</span><span class="n">phy_mask</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">iport</span><span class="o">-&gt;</span><span class="n">physical_port_index</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(((</span><span class="n">phy_mask</span> <span class="o">&amp;</span> <span class="mh">0x08</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x08</span><span class="p">)</span>
		    <span class="o">||</span> <span class="p">(</span><span class="n">phy_mask</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This method retrieves a currently active (i.e. connected) phy contained in</span>
<span class="cm"> * the port.  Currently, the lowest order phy that is connected is returned.</span>
<span class="cm"> * This method returns a pointer to a SCIS_SDS_PHY object. NULL This value is</span>
<span class="cm"> * returned if there are no currently active (i.e. connected to a remote end</span>
<span class="cm"> * point) phys contained in the port. All other values specify a struct sci_phy</span>
<span class="cm"> * object that is active in the port.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">isci_phy</span> <span class="o">*</span><span class="nf">sci_port_get_a_connected_phy</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">iport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">index</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">isci_phy</span> <span class="o">*</span><span class="n">iphy</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">SCI_MAX_PHYS</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Ensure that the phy is both part of the port and currently</span>
<span class="cm">		 * connected to the remote end-point.</span>
<span class="cm">		 */</span>
		<span class="n">iphy</span> <span class="o">=</span> <span class="n">iport</span><span class="o">-&gt;</span><span class="n">phy_table</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iphy</span> <span class="o">&amp;&amp;</span> <span class="n">sci_port_active_phy</span><span class="p">(</span><span class="n">iport</span><span class="p">,</span> <span class="n">iphy</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">iphy</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">enum</span> <span class="n">sci_status</span> <span class="nf">sci_port_set_phy</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">iport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">isci_phy</span> <span class="o">*</span><span class="n">iphy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Check to see if we can add this phy to a port</span>
<span class="cm">	 * that means that the phy is not part of a port and that the port does</span>
<span class="cm">	 * not already have a phy assinged to the phy index.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iport</span><span class="o">-&gt;</span><span class="n">phy_table</span><span class="p">[</span><span class="n">iphy</span><span class="o">-&gt;</span><span class="n">phy_index</span><span class="p">]</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">phy_get_non_dummy_port</span><span class="p">(</span><span class="n">iphy</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">sci_port_is_valid_phy_assignment</span><span class="p">(</span><span class="n">iport</span><span class="p">,</span> <span class="n">iphy</span><span class="o">-&gt;</span><span class="n">phy_index</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Phy is being added in the stopped state so we are in MPC mode</span>
<span class="cm">		 * make logical port index = physical port index</span>
<span class="cm">		 */</span>
		<span class="n">iport</span><span class="o">-&gt;</span><span class="n">logical_port_index</span> <span class="o">=</span> <span class="n">iport</span><span class="o">-&gt;</span><span class="n">physical_port_index</span><span class="p">;</span>
		<span class="n">iport</span><span class="o">-&gt;</span><span class="n">phy_table</span><span class="p">[</span><span class="n">iphy</span><span class="o">-&gt;</span><span class="n">phy_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">iphy</span><span class="p">;</span>
		<span class="n">sci_phy_set_port</span><span class="p">(</span><span class="n">iphy</span><span class="p">,</span> <span class="n">iport</span><span class="p">);</span>

		<span class="k">return</span> <span class="n">SCI_SUCCESS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">SCI_FAILURE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">enum</span> <span class="n">sci_status</span> <span class="nf">sci_port_clear_phy</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">iport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">isci_phy</span> <span class="o">*</span><span class="n">iphy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Make sure that this phy is part of this port */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iport</span><span class="o">-&gt;</span><span class="n">phy_table</span><span class="p">[</span><span class="n">iphy</span><span class="o">-&gt;</span><span class="n">phy_index</span><span class="p">]</span> <span class="o">==</span> <span class="n">iphy</span> <span class="o">&amp;&amp;</span>
	    <span class="n">phy_get_non_dummy_port</span><span class="p">(</span><span class="n">iphy</span><span class="p">)</span> <span class="o">==</span> <span class="n">iport</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span> <span class="o">=</span> <span class="n">iport</span><span class="o">-&gt;</span><span class="n">owning_controller</span><span class="p">;</span>

		<span class="cm">/* Yep it is assigned to this port so remove it */</span>
		<span class="n">sci_phy_set_port</span><span class="p">(</span><span class="n">iphy</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">ports</span><span class="p">[</span><span class="n">SCI_MAX_PORTS</span><span class="p">]);</span>
		<span class="n">iport</span><span class="o">-&gt;</span><span class="n">phy_table</span><span class="p">[</span><span class="n">iphy</span><span class="o">-&gt;</span><span class="n">phy_index</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">SCI_SUCCESS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">SCI_FAILURE</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">sci_port_get_sas_address</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">iport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sci_sas_address</span> <span class="o">*</span><span class="n">sas</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">index</span><span class="p">;</span>

	<span class="n">sas</span><span class="o">-&gt;</span><span class="n">high</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sas</span><span class="o">-&gt;</span><span class="n">low</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">SCI_MAX_PHYS</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iport</span><span class="o">-&gt;</span><span class="n">phy_table</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
			<span class="n">sci_phy_get_sas_address</span><span class="p">(</span><span class="n">iport</span><span class="o">-&gt;</span><span class="n">phy_table</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">sas</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">sci_port_get_attached_sas_address</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">iport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sci_sas_address</span> <span class="o">*</span><span class="n">sas</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">isci_phy</span> <span class="o">*</span><span class="n">iphy</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Ensure that the phy is both part of the port and currently</span>
<span class="cm">	 * connected to the remote end-point.</span>
<span class="cm">	 */</span>
	<span class="n">iphy</span> <span class="o">=</span> <span class="n">sci_port_get_a_connected_phy</span><span class="p">(</span><span class="n">iport</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iphy</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iphy</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">!=</span> <span class="n">SAS_PROTOCOL_SATA</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sci_phy_get_attached_sas_address</span><span class="p">(</span><span class="n">iphy</span><span class="p">,</span> <span class="n">sas</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">sci_phy_get_sas_address</span><span class="p">(</span><span class="n">iphy</span><span class="p">,</span> <span class="n">sas</span><span class="p">);</span>
			<span class="n">sas</span><span class="o">-&gt;</span><span class="n">low</span> <span class="o">+=</span> <span class="n">iphy</span><span class="o">-&gt;</span><span class="n">phy_index</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">sas</span><span class="o">-&gt;</span><span class="n">high</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">sas</span><span class="o">-&gt;</span><span class="n">low</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sci_port_construct_dummy_rnc() - create dummy rnc for si workaround</span>
<span class="cm"> *</span>
<span class="cm"> * @sci_port: logical port on which we need to create the remote node context</span>
<span class="cm"> * @rni: remote node index for this remote node context.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine will construct a dummy remote node context data structure</span>
<span class="cm"> * This structure will be posted to the hardware to work around a scheduler</span>
<span class="cm"> * error in the hardware.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sci_port_construct_dummy_rnc</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">iport</span><span class="p">,</span> <span class="n">u16</span> <span class="n">rni</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">scu_remote_node_context</span> <span class="o">*</span><span class="n">rnc</span><span class="p">;</span>

	<span class="n">rnc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iport</span><span class="o">-&gt;</span><span class="n">owning_controller</span><span class="o">-&gt;</span><span class="n">remote_node_context_table</span><span class="p">[</span><span class="n">rni</span><span class="p">];</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">rnc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">scu_remote_node_context</span><span class="p">));</span>

	<span class="n">rnc</span><span class="o">-&gt;</span><span class="n">ssp</span><span class="p">.</span><span class="n">remote_sas_address_hi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">rnc</span><span class="o">-&gt;</span><span class="n">ssp</span><span class="p">.</span><span class="n">remote_sas_address_lo</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">rnc</span><span class="o">-&gt;</span><span class="n">ssp</span><span class="p">.</span><span class="n">remote_node_index</span> <span class="o">=</span> <span class="n">rni</span><span class="p">;</span>
	<span class="n">rnc</span><span class="o">-&gt;</span><span class="n">ssp</span><span class="p">.</span><span class="n">remote_node_port_width</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">rnc</span><span class="o">-&gt;</span><span class="n">ssp</span><span class="p">.</span><span class="n">logical_port_index</span> <span class="o">=</span> <span class="n">iport</span><span class="o">-&gt;</span><span class="n">physical_port_index</span><span class="p">;</span>

	<span class="n">rnc</span><span class="o">-&gt;</span><span class="n">ssp</span><span class="p">.</span><span class="n">nexus_loss_timer_enable</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">rnc</span><span class="o">-&gt;</span><span class="n">ssp</span><span class="p">.</span><span class="n">check_bit</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">rnc</span><span class="o">-&gt;</span><span class="n">ssp</span><span class="p">.</span><span class="n">is_valid</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">rnc</span><span class="o">-&gt;</span><span class="n">ssp</span><span class="p">.</span><span class="n">is_remote_node_context</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">rnc</span><span class="o">-&gt;</span><span class="n">ssp</span><span class="p">.</span><span class="n">function_number</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">rnc</span><span class="o">-&gt;</span><span class="n">ssp</span><span class="p">.</span><span class="n">arbitration_wait_time</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * construct a dummy task context data structure.  This</span>
<span class="cm"> * structure will be posted to the hardwre to work around a scheduler error</span>
<span class="cm"> * in the hardware.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sci_port_construct_dummy_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">iport</span><span class="p">,</span> <span class="n">u16</span> <span class="n">tag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span> <span class="o">=</span> <span class="n">iport</span><span class="o">-&gt;</span><span class="n">owning_controller</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scu_task_context</span> <span class="o">*</span><span class="n">task_context</span><span class="p">;</span>

	<span class="n">task_context</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">task_context_table</span><span class="p">[</span><span class="n">ISCI_TAG_TCI</span><span class="p">(</span><span class="n">tag</span><span class="p">)];</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">task_context</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">scu_task_context</span><span class="p">));</span>

	<span class="n">task_context</span><span class="o">-&gt;</span><span class="n">initiator_request</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">task_context</span><span class="o">-&gt;</span><span class="n">connection_rate</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">task_context</span><span class="o">-&gt;</span><span class="n">logical_port_index</span> <span class="o">=</span> <span class="n">iport</span><span class="o">-&gt;</span><span class="n">physical_port_index</span><span class="p">;</span>
	<span class="n">task_context</span><span class="o">-&gt;</span><span class="n">protocol_type</span> <span class="o">=</span> <span class="n">SCU_TASK_CONTEXT_PROTOCOL_SSP</span><span class="p">;</span>
	<span class="n">task_context</span><span class="o">-&gt;</span><span class="n">task_index</span> <span class="o">=</span> <span class="n">ISCI_TAG_TCI</span><span class="p">(</span><span class="n">tag</span><span class="p">);</span>
	<span class="n">task_context</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">=</span> <span class="n">SCU_TASK_CONTEXT_VALID</span><span class="p">;</span>
	<span class="n">task_context</span><span class="o">-&gt;</span><span class="n">context_type</span> <span class="o">=</span> <span class="n">SCU_TASK_CONTEXT_TYPE</span><span class="p">;</span>
	<span class="n">task_context</span><span class="o">-&gt;</span><span class="n">remote_node_index</span> <span class="o">=</span> <span class="n">iport</span><span class="o">-&gt;</span><span class="n">reserved_rni</span><span class="p">;</span>
	<span class="n">task_context</span><span class="o">-&gt;</span><span class="n">do_not_dma_ssp_good_response</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">task_context</span><span class="o">-&gt;</span><span class="n">task_phase</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sci_port_destroy_dummy_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">iport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span> <span class="o">=</span> <span class="n">iport</span><span class="o">-&gt;</span><span class="n">owning_controller</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iport</span><span class="o">-&gt;</span><span class="n">reserved_tag</span> <span class="o">!=</span> <span class="n">SCI_CONTROLLER_INVALID_IO_TAG</span><span class="p">)</span>
		<span class="n">isci_free_tag</span><span class="p">(</span><span class="n">ihost</span><span class="p">,</span> <span class="n">iport</span><span class="o">-&gt;</span><span class="n">reserved_tag</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iport</span><span class="o">-&gt;</span><span class="n">reserved_rni</span> <span class="o">!=</span> <span class="n">SCU_DUMMY_INDEX</span><span class="p">)</span>
		<span class="n">sci_remote_node_table_release_remote_node_index</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">available_remote_nodes</span><span class="p">,</span>
								     <span class="mi">1</span><span class="p">,</span> <span class="n">iport</span><span class="o">-&gt;</span><span class="n">reserved_rni</span><span class="p">);</span>

	<span class="n">iport</span><span class="o">-&gt;</span><span class="n">reserved_rni</span> <span class="o">=</span> <span class="n">SCU_DUMMY_INDEX</span><span class="p">;</span>
	<span class="n">iport</span><span class="o">-&gt;</span><span class="n">reserved_tag</span> <span class="o">=</span> <span class="n">SCI_CONTROLLER_INVALID_IO_TAG</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">sci_port_setup_transports</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">iport</span><span class="p">,</span> <span class="n">u32</span> <span class="n">device_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">index</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">SCI_MAX_PHYS</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iport</span><span class="o">-&gt;</span><span class="n">active_phy_mask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">index</span><span class="p">))</span>
			<span class="n">sci_phy_setup_transport</span><span class="p">(</span><span class="n">iport</span><span class="o">-&gt;</span><span class="n">phy_table</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">device_id</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sci_port_resume_phy</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">iport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">isci_phy</span> <span class="o">*</span><span class="n">iphy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sci_phy_resume</span><span class="p">(</span><span class="n">iphy</span><span class="p">);</span>
	<span class="n">iport</span><span class="o">-&gt;</span><span class="n">enabled_phy_mask</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">iphy</span><span class="o">-&gt;</span><span class="n">phy_index</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sci_port_activate_phy</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">iport</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">isci_phy</span> <span class="o">*</span><span class="n">iphy</span><span class="p">,</span>
				  <span class="n">u8</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span> <span class="o">=</span> <span class="n">iport</span><span class="o">-&gt;</span><span class="n">owning_controller</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iphy</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">!=</span> <span class="n">SAS_PROTOCOL_SATA</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_RESUME</span><span class="p">))</span>
		<span class="n">sci_phy_resume</span><span class="p">(</span><span class="n">iphy</span><span class="p">);</span>

	<span class="n">iport</span><span class="o">-&gt;</span><span class="n">active_phy_mask</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">iphy</span><span class="o">-&gt;</span><span class="n">phy_index</span><span class="p">;</span>

	<span class="n">sci_controller_clear_invalid_phy</span><span class="p">(</span><span class="n">ihost</span><span class="p">,</span> <span class="n">iphy</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_NOTIFY</span><span class="p">)</span>
		<span class="n">isci_port_link_up</span><span class="p">(</span><span class="n">ihost</span><span class="p">,</span> <span class="n">iport</span><span class="p">,</span> <span class="n">iphy</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">sci_port_deactivate_phy</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">iport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">isci_phy</span> <span class="o">*</span><span class="n">iphy</span><span class="p">,</span>
			     <span class="n">bool</span> <span class="n">do_notify_user</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span> <span class="o">=</span> <span class="n">iport</span><span class="o">-&gt;</span><span class="n">owning_controller</span><span class="p">;</span>

	<span class="n">iport</span><span class="o">-&gt;</span><span class="n">active_phy_mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">iphy</span><span class="o">-&gt;</span><span class="n">phy_index</span><span class="p">);</span>
	<span class="n">iport</span><span class="o">-&gt;</span><span class="n">enabled_phy_mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">iphy</span><span class="o">-&gt;</span><span class="n">phy_index</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iport</span><span class="o">-&gt;</span><span class="n">active_phy_mask</span><span class="p">)</span>
		<span class="n">iport</span><span class="o">-&gt;</span><span class="n">last_active_phy</span> <span class="o">=</span> <span class="n">iphy</span><span class="o">-&gt;</span><span class="n">phy_index</span><span class="p">;</span>

	<span class="n">iphy</span><span class="o">-&gt;</span><span class="n">max_negotiated_speed</span> <span class="o">=</span> <span class="n">SAS_LINK_RATE_UNKNOWN</span><span class="p">;</span>

	<span class="cm">/* Re-assign the phy back to the LP as if it were a narrow port for APC</span>
<span class="cm">	 * mode. For MPC mode, the phy will remain in the port.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iport</span><span class="o">-&gt;</span><span class="n">owning_controller</span><span class="o">-&gt;</span><span class="n">oem_parameters</span><span class="p">.</span><span class="n">controller</span><span class="p">.</span><span class="n">mode_type</span> <span class="o">==</span>
		<span class="n">SCIC_PORT_AUTOMATIC_CONFIGURATION_MODE</span><span class="p">)</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">iphy</span><span class="o">-&gt;</span><span class="n">phy_index</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">iport</span><span class="o">-&gt;</span><span class="n">port_pe_configuration_register</span><span class="p">[</span><span class="n">iphy</span><span class="o">-&gt;</span><span class="n">phy_index</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">do_notify_user</span> <span class="o">==</span> <span class="nb">true</span><span class="p">)</span>
		<span class="n">isci_port_link_down</span><span class="p">(</span><span class="n">ihost</span><span class="p">,</span> <span class="n">iphy</span><span class="p">,</span> <span class="n">iport</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sci_port_invalid_link_up</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">iport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">isci_phy</span> <span class="o">*</span><span class="n">iphy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span> <span class="o">=</span> <span class="n">iport</span><span class="o">-&gt;</span><span class="n">owning_controller</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check to see if we have alreay reported this link as bad and if</span>
<span class="cm">	 * not go ahead and tell the SCI_USER that we have discovered an</span>
<span class="cm">	 * invalid link.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">invalid_phy_mask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">iphy</span><span class="o">-&gt;</span><span class="n">phy_index</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ihost</span><span class="o">-&gt;</span><span class="n">invalid_phy_mask</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">iphy</span><span class="o">-&gt;</span><span class="n">phy_index</span><span class="p">;</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Invalid link up!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sci_port_general_link_up_handler - phy can be assigned to port?</span>
<span class="cm"> * @sci_port: sci_port object for which has a phy that has gone link up.</span>
<span class="cm"> * @sci_phy: This is the struct isci_phy object that has gone link up.</span>
<span class="cm"> * @flags: PF_RESUME, PF_NOTIFY to sci_port_activate_phy</span>
<span class="cm"> *</span>
<span class="cm"> * Determine if this phy can be assigned to this port . If the phy is</span>
<span class="cm"> * not a valid PHY for this port then the function will notify the user.</span>
<span class="cm"> * A PHY can only be part of a port if it&#39;s attached SAS ADDRESS is the</span>
<span class="cm"> * same as all other PHYs in the same port.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sci_port_general_link_up_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">iport</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">isci_phy</span> <span class="o">*</span><span class="n">iphy</span><span class="p">,</span>
					     <span class="n">u8</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sci_sas_address</span> <span class="n">port_sas_address</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sci_sas_address</span> <span class="n">phy_sas_address</span><span class="p">;</span>

	<span class="n">sci_port_get_attached_sas_address</span><span class="p">(</span><span class="n">iport</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port_sas_address</span><span class="p">);</span>
	<span class="n">sci_phy_get_attached_sas_address</span><span class="p">(</span><span class="n">iphy</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_sas_address</span><span class="p">);</span>

	<span class="cm">/* If the SAS address of the new phy matches the SAS address of</span>
<span class="cm">	 * other phys in the port OR this is the first phy in the port,</span>
<span class="cm">	 * then activate the phy and allow it to be used for operations</span>
<span class="cm">	 * in this port.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">phy_sas_address</span><span class="p">.</span><span class="n">high</span> <span class="o">==</span> <span class="n">port_sas_address</span><span class="p">.</span><span class="n">high</span> <span class="o">&amp;&amp;</span>
	     <span class="n">phy_sas_address</span><span class="p">.</span><span class="n">low</span>  <span class="o">==</span> <span class="n">port_sas_address</span><span class="p">.</span><span class="n">low</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">iport</span><span class="o">-&gt;</span><span class="n">active_phy_mask</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sci_base_state_machine</span> <span class="o">*</span><span class="n">sm</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iport</span><span class="o">-&gt;</span><span class="n">sm</span><span class="p">;</span>

		<span class="n">sci_port_activate_phy</span><span class="p">(</span><span class="n">iport</span><span class="p">,</span> <span class="n">iphy</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sm</span><span class="o">-&gt;</span><span class="n">current_state_id</span> <span class="o">==</span> <span class="n">SCI_PORT_RESETTING</span><span class="p">)</span>
			<span class="n">port_state_machine_change</span><span class="p">(</span><span class="n">iport</span><span class="p">,</span> <span class="n">SCI_PORT_READY</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">sci_port_invalid_link_up</span><span class="p">(</span><span class="n">iport</span><span class="p">,</span> <span class="n">iphy</span><span class="p">);</span>
<span class="p">}</span>



<span class="cm">/**</span>
<span class="cm"> * This method returns false if the port only has a single phy object assigned.</span>
<span class="cm"> *     If there are no phys or more than one phy then the method will return</span>
<span class="cm"> *    true.</span>
<span class="cm"> * @sci_port: The port for which the wide port condition is to be checked.</span>
<span class="cm"> *</span>
<span class="cm"> * bool true Is returned if this is a wide ported port. false Is returned if</span>
<span class="cm"> * this is a narrow port.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">sci_port_is_wide</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">iport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">index</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">phy_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">SCI_MAX_PHYS</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iport</span><span class="o">-&gt;</span><span class="n">phy_table</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">phy_count</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">phy_count</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * This method is called by the PHY object when the link is detected. if the</span>
<span class="cm"> *    port wants the PHY to continue on to the link up state then the port</span>
<span class="cm"> *    layer must return true.  If the port object returns false the phy object</span>
<span class="cm"> *    must halt its attempt to go link up.</span>
<span class="cm"> * @sci_port: The port associated with the phy object.</span>
<span class="cm"> * @sci_phy: The phy object that is trying to go link up.</span>
<span class="cm"> *</span>
<span class="cm"> * true if the phy object can continue to the link up condition. true Is</span>
<span class="cm"> * returned if this phy can continue to the ready state. false Is returned if</span>
<span class="cm"> * can not continue on to the ready state. This notification is in place for</span>
<span class="cm"> * wide ports and direct attached phys.  Since there are no wide ported SATA</span>
<span class="cm"> * devices this could become an invalid port configuration.</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="nf">sci_port_link_detected</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">iport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">isci_phy</span> <span class="o">*</span><span class="n">iphy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">iport</span><span class="o">-&gt;</span><span class="n">logical_port_index</span> <span class="o">!=</span> <span class="n">SCIC_SDS_DUMMY_PORT</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">iphy</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">SAS_PROTOCOL_SATA</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sci_port_is_wide</span><span class="p">(</span><span class="n">iport</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">sci_port_invalid_link_up</span><span class="p">(</span><span class="n">iport</span><span class="p">,</span> <span class="n">iphy</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span> <span class="o">=</span> <span class="n">iport</span><span class="o">-&gt;</span><span class="n">owning_controller</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">dst_port</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">ports</span><span class="p">[</span><span class="n">iphy</span><span class="o">-&gt;</span><span class="n">phy_index</span><span class="p">]);</span>
			<span class="n">writel</span><span class="p">(</span><span class="n">iphy</span><span class="o">-&gt;</span><span class="n">phy_index</span><span class="p">,</span>
			       <span class="o">&amp;</span><span class="n">dst_port</span><span class="o">-&gt;</span><span class="n">port_pe_configuration_register</span><span class="p">[</span><span class="n">iphy</span><span class="o">-&gt;</span><span class="n">phy_index</span><span class="p">]);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">port_timeout</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sci_timer</span> <span class="o">*</span><span class="n">tmr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sci_timer</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">iport</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">tmr</span><span class="p">,</span> <span class="n">typeof</span><span class="p">(</span><span class="o">*</span><span class="n">iport</span><span class="p">),</span> <span class="n">timer</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span> <span class="o">=</span> <span class="n">iport</span><span class="o">-&gt;</span><span class="n">owning_controller</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">current_state</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">scic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tmr</span><span class="o">-&gt;</span><span class="n">cancel</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="n">current_state</span> <span class="o">=</span> <span class="n">iport</span><span class="o">-&gt;</span><span class="n">sm</span><span class="p">.</span><span class="n">current_state_id</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">current_state</span> <span class="o">==</span> <span class="n">SCI_PORT_RESETTING</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* if the port is still in the resetting state then the timeout</span>
<span class="cm">		 * fired before the reset completed.</span>
<span class="cm">		 */</span>
		<span class="n">port_state_machine_change</span><span class="p">(</span><span class="n">iport</span><span class="p">,</span> <span class="n">SCI_PORT_FAILED</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">current_state</span> <span class="o">==</span> <span class="n">SCI_PORT_STOPPED</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* if the port is stopped then the start request failed In this</span>
<span class="cm">		 * case stay in the stopped state.</span>
<span class="cm">		 */</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">sciport_to_dev</span><span class="p">(</span><span class="n">iport</span><span class="p">),</span>
			<span class="s">&quot;%s: SCIC Port 0x%p failed to stop before tiemout.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span>
			<span class="n">iport</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">current_state</span> <span class="o">==</span> <span class="n">SCI_PORT_STOPPING</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">sciport_to_dev</span><span class="p">(</span><span class="n">iport</span><span class="p">),</span>
			<span class="s">&quot;%s: port%d: stop complete timeout</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">iport</span><span class="o">-&gt;</span><span class="n">physical_port_index</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* The port is in the ready state and we have a timer</span>
<span class="cm">		 * reporting a timeout this should not happen.</span>
<span class="cm">		 */</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">sciport_to_dev</span><span class="p">(</span><span class="n">iport</span><span class="p">),</span>
			<span class="s">&quot;%s: SCIC Port 0x%p is processing a timeout operation &quot;</span>
			<span class="s">&quot;in state %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">iport</span><span class="p">,</span> <span class="n">current_state</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">done:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">scic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* --------------------------------------------------------------------------- */</span>

<span class="cm">/**</span>
<span class="cm"> * This function updates the hardwares VIIT entry for this port.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sci_port_update_viit_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">iport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sci_sas_address</span> <span class="n">sas_address</span><span class="p">;</span>

	<span class="n">sci_port_get_sas_address</span><span class="p">(</span><span class="n">iport</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sas_address</span><span class="p">);</span>

	<span class="n">writel</span><span class="p">(</span><span class="n">sas_address</span><span class="p">.</span><span class="n">high</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">iport</span><span class="o">-&gt;</span><span class="n">viit_registers</span><span class="o">-&gt;</span><span class="n">initiator_sas_address_hi</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">sas_address</span><span class="p">.</span><span class="n">low</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">iport</span><span class="o">-&gt;</span><span class="n">viit_registers</span><span class="o">-&gt;</span><span class="n">initiator_sas_address_lo</span><span class="p">);</span>

	<span class="cm">/* This value get cleared just in case its not already cleared */</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iport</span><span class="o">-&gt;</span><span class="n">viit_registers</span><span class="o">-&gt;</span><span class="n">reserved</span><span class="p">);</span>

	<span class="cm">/* We are required to update the status register last */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">SCU_VIIT_ENTRY_ID_VIIT</span> <span class="o">|</span>
	       <span class="n">SCU_VIIT_IPPT_INITIATOR</span> <span class="o">|</span>
	       <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">iport</span><span class="o">-&gt;</span><span class="n">physical_port_index</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">SCU_VIIT_ENTRY_LPVIE_SHIFT</span><span class="p">)</span> <span class="o">|</span>
	       <span class="n">SCU_VIIT_STATUS_ALL_VALID</span><span class="p">,</span>
	       <span class="o">&amp;</span><span class="n">iport</span><span class="o">-&gt;</span><span class="n">viit_registers</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="n">sas_linkrate</span> <span class="nf">sci_port_get_max_allowed_speed</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">iport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">index</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">isci_phy</span> <span class="o">*</span><span class="n">iphy</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">sas_linkrate</span> <span class="n">max_allowed_speed</span> <span class="o">=</span> <span class="n">SAS_LINK_RATE_6_0_GBPS</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Loop through all of the phys in this port and find the phy with the</span>
<span class="cm">	 * lowest maximum link rate. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">SCI_MAX_PHYS</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iphy</span> <span class="o">=</span> <span class="n">iport</span><span class="o">-&gt;</span><span class="n">phy_table</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iphy</span> <span class="o">&amp;&amp;</span> <span class="n">sci_port_active_phy</span><span class="p">(</span><span class="n">iport</span><span class="p">,</span> <span class="n">iphy</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">iphy</span><span class="o">-&gt;</span><span class="n">max_negotiated_speed</span> <span class="o">&lt;</span> <span class="n">max_allowed_speed</span><span class="p">)</span>
			<span class="n">max_allowed_speed</span> <span class="o">=</span> <span class="n">iphy</span><span class="o">-&gt;</span><span class="n">max_negotiated_speed</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">max_allowed_speed</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sci_port_suspend_port_task_scheduler</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">iport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">pts_control_value</span><span class="p">;</span>

	<span class="n">pts_control_value</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iport</span><span class="o">-&gt;</span><span class="n">port_task_scheduler_registers</span><span class="o">-&gt;</span><span class="n">control</span><span class="p">);</span>
	<span class="n">pts_control_value</span> <span class="o">|=</span> <span class="n">SCU_PTSxCR_GEN_BIT</span><span class="p">(</span><span class="n">SUSPEND</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">pts_control_value</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iport</span><span class="o">-&gt;</span><span class="n">port_task_scheduler_registers</span><span class="o">-&gt;</span><span class="n">control</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sci_port_post_dummy_request() - post dummy/workaround request</span>
<span class="cm"> * @sci_port: port to post task</span>
<span class="cm"> *</span>
<span class="cm"> * Prevent the hardware scheduler from posting new requests to the front</span>
<span class="cm"> * of the scheduler queue causing a starvation problem for currently</span>
<span class="cm"> * ongoing requests.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sci_port_post_dummy_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">iport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span> <span class="o">=</span> <span class="n">iport</span><span class="o">-&gt;</span><span class="n">owning_controller</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">tag</span> <span class="o">=</span> <span class="n">iport</span><span class="o">-&gt;</span><span class="n">reserved_tag</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scu_task_context</span> <span class="o">*</span><span class="n">tc</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">command</span><span class="p">;</span>

	<span class="n">tc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">task_context_table</span><span class="p">[</span><span class="n">ISCI_TAG_TCI</span><span class="p">(</span><span class="n">tag</span><span class="p">)];</span>
	<span class="n">tc</span><span class="o">-&gt;</span><span class="n">abort</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">command</span> <span class="o">=</span> <span class="n">SCU_CONTEXT_COMMAND_REQUEST_TYPE_POST_TC</span> <span class="o">|</span>
		  <span class="n">iport</span><span class="o">-&gt;</span><span class="n">physical_port_index</span> <span class="o">&lt;&lt;</span> <span class="n">SCU_CONTEXT_COMMAND_LOGICAL_PORT_SHIFT</span> <span class="o">|</span>
		  <span class="n">ISCI_TAG_TCI</span><span class="p">(</span><span class="n">tag</span><span class="p">);</span>

	<span class="n">sci_controller_post_request</span><span class="p">(</span><span class="n">ihost</span><span class="p">,</span> <span class="n">command</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * This routine will abort the dummy request.  This will alow the hardware to</span>
<span class="cm"> * power down parts of the silicon to save power.</span>
<span class="cm"> *</span>
<span class="cm"> * @sci_port: The port on which the task must be aborted.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sci_port_abort_dummy_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">iport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span> <span class="o">=</span> <span class="n">iport</span><span class="o">-&gt;</span><span class="n">owning_controller</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">tag</span> <span class="o">=</span> <span class="n">iport</span><span class="o">-&gt;</span><span class="n">reserved_tag</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scu_task_context</span> <span class="o">*</span><span class="n">tc</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">command</span><span class="p">;</span>

	<span class="n">tc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">task_context_table</span><span class="p">[</span><span class="n">ISCI_TAG_TCI</span><span class="p">(</span><span class="n">tag</span><span class="p">)];</span>
	<span class="n">tc</span><span class="o">-&gt;</span><span class="n">abort</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">command</span> <span class="o">=</span> <span class="n">SCU_CONTEXT_COMMAND_REQUEST_POST_TC_ABORT</span> <span class="o">|</span>
		  <span class="n">iport</span><span class="o">-&gt;</span><span class="n">physical_port_index</span> <span class="o">&lt;&lt;</span> <span class="n">SCU_CONTEXT_COMMAND_LOGICAL_PORT_SHIFT</span> <span class="o">|</span>
		  <span class="n">ISCI_TAG_TCI</span><span class="p">(</span><span class="n">tag</span><span class="p">);</span>

	<span class="n">sci_controller_post_request</span><span class="p">(</span><span class="n">ihost</span><span class="p">,</span> <span class="n">command</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *</span>
<span class="cm"> * @sci_port: This is the struct isci_port object to resume.</span>
<span class="cm"> *</span>
<span class="cm"> * This method will resume the port task scheduler for this port object. none</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">sci_port_resume_port_task_scheduler</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">iport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">pts_control_value</span><span class="p">;</span>

	<span class="n">pts_control_value</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iport</span><span class="o">-&gt;</span><span class="n">port_task_scheduler_registers</span><span class="o">-&gt;</span><span class="n">control</span><span class="p">);</span>
	<span class="n">pts_control_value</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SCU_PTSxCR_GEN_BIT</span><span class="p">(</span><span class="n">SUSPEND</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">pts_control_value</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iport</span><span class="o">-&gt;</span><span class="n">port_task_scheduler_registers</span><span class="o">-&gt;</span><span class="n">control</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sci_port_ready_substate_waiting_enter</span><span class="p">(</span><span class="k">struct</span> <span class="n">sci_base_state_machine</span> <span class="o">*</span><span class="n">sm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">iport</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">sm</span><span class="p">,</span> <span class="n">typeof</span><span class="p">(</span><span class="o">*</span><span class="n">iport</span><span class="p">),</span> <span class="n">sm</span><span class="p">);</span>

	<span class="n">sci_port_suspend_port_task_scheduler</span><span class="p">(</span><span class="n">iport</span><span class="p">);</span>

	<span class="n">iport</span><span class="o">-&gt;</span><span class="n">not_ready_reason</span> <span class="o">=</span> <span class="n">SCIC_PORT_NOT_READY_NO_ACTIVE_PHYS</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iport</span><span class="o">-&gt;</span><span class="n">active_phy_mask</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* At least one of the phys on the port is ready */</span>
		<span class="n">port_state_machine_change</span><span class="p">(</span><span class="n">iport</span><span class="p">,</span>
					  <span class="n">SCI_PORT_SUB_OPERATIONAL</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">scic_sds_port_ready_substate_waiting_exit</span><span class="p">(</span>
					<span class="k">struct</span> <span class="n">sci_base_state_machine</span> <span class="o">*</span><span class="n">sm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">iport</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">sm</span><span class="p">,</span> <span class="n">typeof</span><span class="p">(</span><span class="o">*</span><span class="n">iport</span><span class="p">),</span> <span class="n">sm</span><span class="p">);</span>
	<span class="n">sci_port_resume_port_task_scheduler</span><span class="p">(</span><span class="n">iport</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sci_port_ready_substate_operational_enter</span><span class="p">(</span><span class="k">struct</span> <span class="n">sci_base_state_machine</span> <span class="o">*</span><span class="n">sm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">index</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">iport</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">sm</span><span class="p">,</span> <span class="n">typeof</span><span class="p">(</span><span class="o">*</span><span class="n">iport</span><span class="p">),</span> <span class="n">sm</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span> <span class="o">=</span> <span class="n">iport</span><span class="o">-&gt;</span><span class="n">owning_controller</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: port%d ready</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span> <span class="n">iport</span><span class="o">-&gt;</span><span class="n">physical_port_index</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">SCI_MAX_PHYS</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iport</span><span class="o">-&gt;</span><span class="n">phy_table</span><span class="p">[</span><span class="n">index</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">writel</span><span class="p">(</span><span class="n">iport</span><span class="o">-&gt;</span><span class="n">physical_port_index</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">iport</span><span class="o">-&gt;</span><span class="n">port_pe_configuration_register</span><span class="p">[</span>
					<span class="n">iport</span><span class="o">-&gt;</span><span class="n">phy_table</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">phy_index</span><span class="p">]);</span>
			<span class="k">if</span> <span class="p">(((</span><span class="n">iport</span><span class="o">-&gt;</span><span class="n">active_phy_mask</span><span class="o">^</span><span class="n">iport</span><span class="o">-&gt;</span><span class="n">enabled_phy_mask</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">index</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">sci_port_resume_phy</span><span class="p">(</span><span class="n">iport</span><span class="p">,</span> <span class="n">iport</span><span class="o">-&gt;</span><span class="n">phy_table</span><span class="p">[</span><span class="n">index</span><span class="p">]);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">sci_port_update_viit_entry</span><span class="p">(</span><span class="n">iport</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Post the dummy task for the port so the hardware can schedule</span>
<span class="cm">	 * io correctly</span>
<span class="cm">	 */</span>
	<span class="n">sci_port_post_dummy_request</span><span class="p">(</span><span class="n">iport</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sci_port_invalidate_dummy_remote_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">iport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span> <span class="o">=</span> <span class="n">iport</span><span class="o">-&gt;</span><span class="n">owning_controller</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">phys_index</span> <span class="o">=</span> <span class="n">iport</span><span class="o">-&gt;</span><span class="n">physical_port_index</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">scu_remote_node_context</span> <span class="o">*</span><span class="n">rnc</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">rni</span> <span class="o">=</span> <span class="n">iport</span><span class="o">-&gt;</span><span class="n">reserved_rni</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">command</span><span class="p">;</span>

	<span class="n">rnc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">remote_node_context_table</span><span class="p">[</span><span class="n">rni</span><span class="p">];</span>

	<span class="n">rnc</span><span class="o">-&gt;</span><span class="n">ssp</span><span class="p">.</span><span class="n">is_valid</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* ensure the preceding tc abort request has reached the</span>
<span class="cm">	 * controller and give it ample time to act before posting the rnc</span>
<span class="cm">	 * invalidate</span>
<span class="cm">	 */</span>
	<span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">smu_registers</span><span class="o">-&gt;</span><span class="n">interrupt_status</span><span class="p">);</span> <span class="cm">/* flush */</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

	<span class="n">command</span> <span class="o">=</span> <span class="n">SCU_CONTEXT_COMMAND_POST_RNC_INVALIDATE</span> <span class="o">|</span>
		  <span class="n">phys_index</span> <span class="o">&lt;&lt;</span> <span class="n">SCU_CONTEXT_COMMAND_LOGICAL_PORT_SHIFT</span> <span class="o">|</span> <span class="n">rni</span><span class="p">;</span>

	<span class="n">sci_controller_post_request</span><span class="p">(</span><span class="n">ihost</span><span class="p">,</span> <span class="n">command</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *</span>
<span class="cm"> * @object: This is the object which is cast to a struct isci_port object.</span>
<span class="cm"> *</span>
<span class="cm"> * This method will perform the actions required by the struct isci_port on</span>
<span class="cm"> * exiting the SCI_PORT_SUB_OPERATIONAL. This function reports</span>
<span class="cm"> * the port not ready and suspends the port task scheduler. none</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sci_port_ready_substate_operational_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sci_base_state_machine</span> <span class="o">*</span><span class="n">sm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">iport</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">sm</span><span class="p">,</span> <span class="n">typeof</span><span class="p">(</span><span class="o">*</span><span class="n">iport</span><span class="p">),</span> <span class="n">sm</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span> <span class="o">=</span> <span class="n">iport</span><span class="o">-&gt;</span><span class="n">owning_controller</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Kill the dummy task for this port if it has not yet posted</span>
<span class="cm">	 * the hardware will treat this as a NOP and just return abort</span>
<span class="cm">	 * complete.</span>
<span class="cm">	 */</span>
	<span class="n">sci_port_abort_dummy_request</span><span class="p">(</span><span class="n">iport</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: port%d !ready</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span> <span class="n">iport</span><span class="o">-&gt;</span><span class="n">physical_port_index</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iport</span><span class="o">-&gt;</span><span class="n">ready_exit</span><span class="p">)</span>
		<span class="n">sci_port_invalidate_dummy_remote_node</span><span class="p">(</span><span class="n">iport</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sci_port_ready_substate_configuring_enter</span><span class="p">(</span><span class="k">struct</span> <span class="n">sci_base_state_machine</span> <span class="o">*</span><span class="n">sm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">iport</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">sm</span><span class="p">,</span> <span class="n">typeof</span><span class="p">(</span><span class="o">*</span><span class="n">iport</span><span class="p">),</span> <span class="n">sm</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span> <span class="o">=</span> <span class="n">iport</span><span class="o">-&gt;</span><span class="n">owning_controller</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iport</span><span class="o">-&gt;</span><span class="n">active_phy_mask</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: port%d !ready</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">iport</span><span class="o">-&gt;</span><span class="n">physical_port_index</span><span class="p">);</span>

		<span class="n">port_state_machine_change</span><span class="p">(</span><span class="n">iport</span><span class="p">,</span> <span class="n">SCI_PORT_SUB_WAITING</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">port_state_machine_change</span><span class="p">(</span><span class="n">iport</span><span class="p">,</span> <span class="n">SCI_PORT_SUB_OPERATIONAL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="n">sci_status</span> <span class="nf">sci_port_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">iport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span> <span class="o">=</span> <span class="n">iport</span><span class="o">-&gt;</span><span class="n">owning_controller</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">sci_status</span> <span class="n">status</span> <span class="o">=</span> <span class="n">SCI_SUCCESS</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">sci_port_states</span> <span class="n">state</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">phy_mask</span><span class="p">;</span>

	<span class="n">state</span> <span class="o">=</span> <span class="n">iport</span><span class="o">-&gt;</span><span class="n">sm</span><span class="p">.</span><span class="n">current_state_id</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">!=</span> <span class="n">SCI_PORT_STOPPED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">sciport_to_dev</span><span class="p">(</span><span class="n">iport</span><span class="p">),</span> <span class="s">&quot;%s: in wrong state: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">__func__</span><span class="p">,</span> <span class="n">port_state_name</span><span class="p">(</span><span class="n">state</span><span class="p">));</span>
		<span class="k">return</span> <span class="n">SCI_FAILURE_INVALID_STATE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iport</span><span class="o">-&gt;</span><span class="n">assigned_device_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* TODO This is a start failure operation because</span>
<span class="cm">		 * there are still devices assigned to this port.</span>
<span class="cm">		 * There must be no devices assigned to a port on a</span>
<span class="cm">		 * start operation.</span>
<span class="cm">		 */</span>
		<span class="k">return</span> <span class="n">SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iport</span><span class="o">-&gt;</span><span class="n">reserved_rni</span> <span class="o">==</span> <span class="n">SCU_DUMMY_INDEX</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u16</span> <span class="n">rni</span> <span class="o">=</span> <span class="n">sci_remote_node_table_allocate_remote_node</span><span class="p">(</span>
				<span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">available_remote_nodes</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rni</span> <span class="o">!=</span> <span class="n">SCU_DUMMY_INDEX</span><span class="p">)</span>
			<span class="n">sci_port_construct_dummy_rnc</span><span class="p">(</span><span class="n">iport</span><span class="p">,</span> <span class="n">rni</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">SCI_FAILURE_INSUFFICIENT_RESOURCES</span><span class="p">;</span>
		<span class="n">iport</span><span class="o">-&gt;</span><span class="n">reserved_rni</span> <span class="o">=</span> <span class="n">rni</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iport</span><span class="o">-&gt;</span><span class="n">reserved_tag</span> <span class="o">==</span> <span class="n">SCI_CONTROLLER_INVALID_IO_TAG</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u16</span> <span class="n">tag</span><span class="p">;</span>

		<span class="n">tag</span> <span class="o">=</span> <span class="n">isci_alloc_tag</span><span class="p">(</span><span class="n">ihost</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tag</span> <span class="o">==</span> <span class="n">SCI_CONTROLLER_INVALID_IO_TAG</span><span class="p">)</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">SCI_FAILURE_INSUFFICIENT_RESOURCES</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">sci_port_construct_dummy_task</span><span class="p">(</span><span class="n">iport</span><span class="p">,</span> <span class="n">tag</span><span class="p">);</span>
		<span class="n">iport</span><span class="o">-&gt;</span><span class="n">reserved_tag</span> <span class="o">=</span> <span class="n">tag</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">SCI_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">phy_mask</span> <span class="o">=</span> <span class="n">sci_port_get_phys</span><span class="p">(</span><span class="n">iport</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * There are one or more phys assigned to this port.  Make sure</span>
<span class="cm">		 * the port&#39;s phy mask is in fact legal and supported by the</span>
<span class="cm">		 * silicon.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sci_port_is_phy_mask_valid</span><span class="p">(</span><span class="n">iport</span><span class="p">,</span> <span class="n">phy_mask</span><span class="p">)</span> <span class="o">==</span> <span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">port_state_machine_change</span><span class="p">(</span><span class="n">iport</span><span class="p">,</span>
						  <span class="n">SCI_PORT_READY</span><span class="p">);</span>

			<span class="k">return</span> <span class="n">SCI_SUCCESS</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">SCI_FAILURE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">SCI_SUCCESS</span><span class="p">)</span>
		<span class="n">sci_port_destroy_dummy_resources</span><span class="p">(</span><span class="n">iport</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="n">sci_status</span> <span class="nf">sci_port_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">iport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">sci_port_states</span> <span class="n">state</span><span class="p">;</span>

	<span class="n">state</span> <span class="o">=</span> <span class="n">iport</span><span class="o">-&gt;</span><span class="n">sm</span><span class="p">.</span><span class="n">current_state_id</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SCI_PORT_STOPPED</span>:
		<span class="k">return</span> <span class="n">SCI_SUCCESS</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCI_PORT_SUB_WAITING</span>:
	<span class="k">case</span> <span class="n">SCI_PORT_SUB_OPERATIONAL</span>:
	<span class="k">case</span> <span class="n">SCI_PORT_SUB_CONFIGURING</span>:
	<span class="k">case</span> <span class="n">SCI_PORT_RESETTING</span>:
		<span class="n">port_state_machine_change</span><span class="p">(</span><span class="n">iport</span><span class="p">,</span>
					  <span class="n">SCI_PORT_STOPPING</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">SCI_SUCCESS</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">sciport_to_dev</span><span class="p">(</span><span class="n">iport</span><span class="p">),</span> <span class="s">&quot;%s: in wrong state: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">__func__</span><span class="p">,</span> <span class="n">port_state_name</span><span class="p">(</span><span class="n">state</span><span class="p">));</span>
		<span class="k">return</span> <span class="n">SCI_FAILURE_INVALID_STATE</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">enum</span> <span class="n">sci_status</span> <span class="nf">sci_port_hard_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">iport</span><span class="p">,</span> <span class="n">u32</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">sci_status</span> <span class="n">status</span> <span class="o">=</span> <span class="n">SCI_FAILURE_INVALID_PHY</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">isci_phy</span> <span class="o">*</span><span class="n">iphy</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">sci_port_states</span> <span class="n">state</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">phy_index</span><span class="p">;</span>

	<span class="n">state</span> <span class="o">=</span> <span class="n">iport</span><span class="o">-&gt;</span><span class="n">sm</span><span class="p">.</span><span class="n">current_state_id</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">!=</span> <span class="n">SCI_PORT_SUB_OPERATIONAL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">sciport_to_dev</span><span class="p">(</span><span class="n">iport</span><span class="p">),</span> <span class="s">&quot;%s: in wrong state: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">__func__</span><span class="p">,</span> <span class="n">port_state_name</span><span class="p">(</span><span class="n">state</span><span class="p">));</span>
		<span class="k">return</span> <span class="n">SCI_FAILURE_INVALID_STATE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Select a phy on which we can send the hard reset request. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">phy_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">phy_index</span> <span class="o">&lt;</span> <span class="n">SCI_MAX_PHYS</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">iphy</span><span class="p">;</span> <span class="n">phy_index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iphy</span> <span class="o">=</span> <span class="n">iport</span><span class="o">-&gt;</span><span class="n">phy_table</span><span class="p">[</span><span class="n">phy_index</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iphy</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">sci_port_active_phy</span><span class="p">(</span><span class="n">iport</span><span class="p">,</span> <span class="n">iphy</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * We found a phy but it is not ready select</span>
<span class="cm">			 * different phy</span>
<span class="cm">			 */</span>
			<span class="n">iphy</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* If we have a phy then go ahead and start the reset procedure */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iphy</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">sci_phy_reset</span><span class="p">(</span><span class="n">iphy</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">SCI_SUCCESS</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">sci_mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iport</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>
	<span class="n">iport</span><span class="o">-&gt;</span><span class="n">not_ready_reason</span> <span class="o">=</span> <span class="n">SCIC_PORT_NOT_READY_HARD_RESET_REQUESTED</span><span class="p">;</span>

	<span class="n">port_state_machine_change</span><span class="p">(</span><span class="n">iport</span><span class="p">,</span> <span class="n">SCI_PORT_RESETTING</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">SCI_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sci_port_add_phy() -</span>
<span class="cm"> * @sci_port: This parameter specifies the port in which the phy will be added.</span>
<span class="cm"> * @sci_phy: This parameter is the phy which is to be added to the port.</span>
<span class="cm"> *</span>
<span class="cm"> * This method will add a PHY to the selected port. This method returns an</span>
<span class="cm"> * enum sci_status. SCI_SUCCESS the phy has been added to the port. Any other</span>
<span class="cm"> * status is a failure to add the phy to the port.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">sci_status</span> <span class="nf">sci_port_add_phy</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">iport</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">isci_phy</span> <span class="o">*</span><span class="n">iphy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">sci_status</span> <span class="n">status</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">sci_port_states</span> <span class="n">state</span><span class="p">;</span>

	<span class="n">sci_port_bcn_enable</span><span class="p">(</span><span class="n">iport</span><span class="p">);</span>

	<span class="n">state</span> <span class="o">=</span> <span class="n">iport</span><span class="o">-&gt;</span><span class="n">sm</span><span class="p">.</span><span class="n">current_state_id</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SCI_PORT_STOPPED</span>: <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sci_sas_address</span> <span class="n">port_sas_address</span><span class="p">;</span>

		<span class="cm">/* Read the port assigned SAS Address if there is one */</span>
		<span class="n">sci_port_get_sas_address</span><span class="p">(</span><span class="n">iport</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port_sas_address</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">port_sas_address</span><span class="p">.</span><span class="n">high</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">port_sas_address</span><span class="p">.</span><span class="n">low</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">sci_sas_address</span> <span class="n">phy_sas_address</span><span class="p">;</span>

			<span class="cm">/* Make sure that the PHY SAS Address matches the SAS Address</span>
<span class="cm">			 * for this port</span>
<span class="cm">			 */</span>
			<span class="n">sci_phy_get_sas_address</span><span class="p">(</span><span class="n">iphy</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_sas_address</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">port_sas_address</span><span class="p">.</span><span class="n">high</span> <span class="o">!=</span> <span class="n">phy_sas_address</span><span class="p">.</span><span class="n">high</span> <span class="o">||</span>
			    <span class="n">port_sas_address</span><span class="p">.</span><span class="n">low</span>  <span class="o">!=</span> <span class="n">phy_sas_address</span><span class="p">.</span><span class="n">low</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">sci_port_set_phy</span><span class="p">(</span><span class="n">iport</span><span class="p">,</span> <span class="n">iphy</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">SCI_PORT_SUB_WAITING</span>:
	<span class="k">case</span> <span class="n">SCI_PORT_SUB_OPERATIONAL</span>:
		<span class="n">status</span> <span class="o">=</span> <span class="n">sci_port_set_phy</span><span class="p">(</span><span class="n">iport</span><span class="p">,</span> <span class="n">iphy</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">SCI_SUCCESS</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">status</span><span class="p">;</span>

		<span class="n">sci_port_general_link_up_handler</span><span class="p">(</span><span class="n">iport</span><span class="p">,</span> <span class="n">iphy</span><span class="p">,</span> <span class="n">PF_NOTIFY</span><span class="o">|</span><span class="n">PF_RESUME</span><span class="p">);</span>
		<span class="n">iport</span><span class="o">-&gt;</span><span class="n">not_ready_reason</span> <span class="o">=</span> <span class="n">SCIC_PORT_NOT_READY_RECONFIGURING</span><span class="p">;</span>
		<span class="n">port_state_machine_change</span><span class="p">(</span><span class="n">iport</span><span class="p">,</span> <span class="n">SCI_PORT_SUB_CONFIGURING</span><span class="p">);</span>

		<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCI_PORT_SUB_CONFIGURING</span>:
		<span class="n">status</span> <span class="o">=</span> <span class="n">sci_port_set_phy</span><span class="p">(</span><span class="n">iport</span><span class="p">,</span> <span class="n">iphy</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">SCI_SUCCESS</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
		<span class="n">sci_port_general_link_up_handler</span><span class="p">(</span><span class="n">iport</span><span class="p">,</span> <span class="n">iphy</span><span class="p">,</span> <span class="n">PF_NOTIFY</span><span class="p">);</span>

		<span class="cm">/* Re-enter the configuring state since this may be the last phy in</span>
<span class="cm">		 * the port.</span>
<span class="cm">		 */</span>
		<span class="n">port_state_machine_change</span><span class="p">(</span><span class="n">iport</span><span class="p">,</span>
					  <span class="n">SCI_PORT_SUB_CONFIGURING</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">SCI_SUCCESS</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">sciport_to_dev</span><span class="p">(</span><span class="n">iport</span><span class="p">),</span> <span class="s">&quot;%s: in wrong state: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">__func__</span><span class="p">,</span> <span class="n">port_state_name</span><span class="p">(</span><span class="n">state</span><span class="p">));</span>
		<span class="k">return</span> <span class="n">SCI_FAILURE_INVALID_STATE</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sci_port_remove_phy() -</span>
<span class="cm"> * @sci_port: This parameter specifies the port in which the phy will be added.</span>
<span class="cm"> * @sci_phy: This parameter is the phy which is to be added to the port.</span>
<span class="cm"> *</span>
<span class="cm"> * This method will remove the PHY from the selected PORT. This method returns</span>
<span class="cm"> * an enum sci_status. SCI_SUCCESS the phy has been removed from the port. Any</span>
<span class="cm"> * other status is a failure to add the phy to the port.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">sci_status</span> <span class="nf">sci_port_remove_phy</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">iport</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">isci_phy</span> <span class="o">*</span><span class="n">iphy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">sci_status</span> <span class="n">status</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">sci_port_states</span> <span class="n">state</span><span class="p">;</span>

	<span class="n">state</span> <span class="o">=</span> <span class="n">iport</span><span class="o">-&gt;</span><span class="n">sm</span><span class="p">.</span><span class="n">current_state_id</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SCI_PORT_STOPPED</span>:
		<span class="k">return</span> <span class="n">sci_port_clear_phy</span><span class="p">(</span><span class="n">iport</span><span class="p">,</span> <span class="n">iphy</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">SCI_PORT_SUB_OPERATIONAL</span>:
		<span class="n">status</span> <span class="o">=</span> <span class="n">sci_port_clear_phy</span><span class="p">(</span><span class="n">iport</span><span class="p">,</span> <span class="n">iphy</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">SCI_SUCCESS</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">status</span><span class="p">;</span>

		<span class="n">sci_port_deactivate_phy</span><span class="p">(</span><span class="n">iport</span><span class="p">,</span> <span class="n">iphy</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
		<span class="n">iport</span><span class="o">-&gt;</span><span class="n">not_ready_reason</span> <span class="o">=</span> <span class="n">SCIC_PORT_NOT_READY_RECONFIGURING</span><span class="p">;</span>
		<span class="n">port_state_machine_change</span><span class="p">(</span><span class="n">iport</span><span class="p">,</span>
					  <span class="n">SCI_PORT_SUB_CONFIGURING</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">SCI_SUCCESS</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCI_PORT_SUB_CONFIGURING</span>:
		<span class="n">status</span> <span class="o">=</span> <span class="n">sci_port_clear_phy</span><span class="p">(</span><span class="n">iport</span><span class="p">,</span> <span class="n">iphy</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">SCI_SUCCESS</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
		<span class="n">sci_port_deactivate_phy</span><span class="p">(</span><span class="n">iport</span><span class="p">,</span> <span class="n">iphy</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

		<span class="cm">/* Re-enter the configuring state since this may be the last phy in</span>
<span class="cm">		 * the port</span>
<span class="cm">		 */</span>
		<span class="n">port_state_machine_change</span><span class="p">(</span><span class="n">iport</span><span class="p">,</span>
					  <span class="n">SCI_PORT_SUB_CONFIGURING</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">SCI_SUCCESS</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">sciport_to_dev</span><span class="p">(</span><span class="n">iport</span><span class="p">),</span> <span class="s">&quot;%s: in wrong state: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">__func__</span><span class="p">,</span> <span class="n">port_state_name</span><span class="p">(</span><span class="n">state</span><span class="p">));</span>
		<span class="k">return</span> <span class="n">SCI_FAILURE_INVALID_STATE</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="n">sci_status</span> <span class="nf">sci_port_link_up</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">iport</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">isci_phy</span> <span class="o">*</span><span class="n">iphy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">sci_port_states</span> <span class="n">state</span><span class="p">;</span>

	<span class="n">state</span> <span class="o">=</span> <span class="n">iport</span><span class="o">-&gt;</span><span class="n">sm</span><span class="p">.</span><span class="n">current_state_id</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SCI_PORT_SUB_WAITING</span>:
		<span class="cm">/* Since this is the first phy going link up for the port we</span>
<span class="cm">		 * can just enable it and continue</span>
<span class="cm">		 */</span>
		<span class="n">sci_port_activate_phy</span><span class="p">(</span><span class="n">iport</span><span class="p">,</span> <span class="n">iphy</span><span class="p">,</span> <span class="n">PF_NOTIFY</span><span class="o">|</span><span class="n">PF_RESUME</span><span class="p">);</span>

		<span class="n">port_state_machine_change</span><span class="p">(</span><span class="n">iport</span><span class="p">,</span>
					  <span class="n">SCI_PORT_SUB_OPERATIONAL</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">SCI_SUCCESS</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCI_PORT_SUB_OPERATIONAL</span>:
		<span class="n">sci_port_general_link_up_handler</span><span class="p">(</span><span class="n">iport</span><span class="p">,</span> <span class="n">iphy</span><span class="p">,</span> <span class="n">PF_NOTIFY</span><span class="o">|</span><span class="n">PF_RESUME</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">SCI_SUCCESS</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCI_PORT_RESETTING</span>:
		<span class="cm">/* TODO We should  make  sure  that  the phy  that  has gone</span>
<span class="cm">		 * link up is the same one on which we sent the reset.  It is</span>
<span class="cm">		 * possible that the phy on which we sent  the reset is not the</span>
<span class="cm">		 * one that has  gone  link up  and we  want to make sure that</span>
<span class="cm">		 * phy being reset  comes  back.  Consider the case where a</span>
<span class="cm">		 * reset is sent but before the hardware processes the reset it</span>
<span class="cm">		 * get a link up on  the  port because of a hot plug event.</span>
<span class="cm">		 * because  of  the reset request this phy will go link down</span>
<span class="cm">		 * almost immediately.</span>
<span class="cm">		 */</span>

		<span class="cm">/* In the resetting state we don&#39;t notify the user regarding</span>
<span class="cm">		 * link up and link down notifications.</span>
<span class="cm">		 */</span>
		<span class="n">sci_port_general_link_up_handler</span><span class="p">(</span><span class="n">iport</span><span class="p">,</span> <span class="n">iphy</span><span class="p">,</span> <span class="n">PF_RESUME</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">SCI_SUCCESS</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">sciport_to_dev</span><span class="p">(</span><span class="n">iport</span><span class="p">),</span> <span class="s">&quot;%s: in wrong state: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">__func__</span><span class="p">,</span> <span class="n">port_state_name</span><span class="p">(</span><span class="n">state</span><span class="p">));</span>
		<span class="k">return</span> <span class="n">SCI_FAILURE_INVALID_STATE</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="n">sci_status</span> <span class="nf">sci_port_link_down</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">iport</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">isci_phy</span> <span class="o">*</span><span class="n">iphy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">sci_port_states</span> <span class="n">state</span><span class="p">;</span>

	<span class="n">state</span> <span class="o">=</span> <span class="n">iport</span><span class="o">-&gt;</span><span class="n">sm</span><span class="p">.</span><span class="n">current_state_id</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SCI_PORT_SUB_OPERATIONAL</span>:
		<span class="n">sci_port_deactivate_phy</span><span class="p">(</span><span class="n">iport</span><span class="p">,</span> <span class="n">iphy</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

		<span class="cm">/* If there are no active phys left in the port, then</span>
<span class="cm">		 * transition the port to the WAITING state until such time</span>
<span class="cm">		 * as a phy goes link up</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iport</span><span class="o">-&gt;</span><span class="n">active_phy_mask</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">port_state_machine_change</span><span class="p">(</span><span class="n">iport</span><span class="p">,</span>
						  <span class="n">SCI_PORT_SUB_WAITING</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">SCI_SUCCESS</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCI_PORT_RESETTING</span>:
		<span class="cm">/* In the resetting state we don&#39;t notify the user regarding</span>
<span class="cm">		 * link up and link down notifications. */</span>
		<span class="n">sci_port_deactivate_phy</span><span class="p">(</span><span class="n">iport</span><span class="p">,</span> <span class="n">iphy</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">SCI_SUCCESS</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">sciport_to_dev</span><span class="p">(</span><span class="n">iport</span><span class="p">),</span> <span class="s">&quot;%s: in wrong state: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">__func__</span><span class="p">,</span> <span class="n">port_state_name</span><span class="p">(</span><span class="n">state</span><span class="p">));</span>
		<span class="k">return</span> <span class="n">SCI_FAILURE_INVALID_STATE</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="n">sci_status</span> <span class="nf">sci_port_start_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">iport</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">isci_remote_device</span> <span class="o">*</span><span class="n">idev</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">isci_request</span> <span class="o">*</span><span class="n">ireq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">sci_port_states</span> <span class="n">state</span><span class="p">;</span>

	<span class="n">state</span> <span class="o">=</span> <span class="n">iport</span><span class="o">-&gt;</span><span class="n">sm</span><span class="p">.</span><span class="n">current_state_id</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SCI_PORT_SUB_WAITING</span>:
		<span class="k">return</span> <span class="n">SCI_FAILURE_INVALID_STATE</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCI_PORT_SUB_OPERATIONAL</span>:
		<span class="n">iport</span><span class="o">-&gt;</span><span class="n">started_request_count</span><span class="o">++</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">SCI_SUCCESS</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">sciport_to_dev</span><span class="p">(</span><span class="n">iport</span><span class="p">),</span> <span class="s">&quot;%s: in wrong state: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">__func__</span><span class="p">,</span> <span class="n">port_state_name</span><span class="p">(</span><span class="n">state</span><span class="p">));</span>
		<span class="k">return</span> <span class="n">SCI_FAILURE_INVALID_STATE</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="n">sci_status</span> <span class="nf">sci_port_complete_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">iport</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">isci_remote_device</span> <span class="o">*</span><span class="n">idev</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">isci_request</span> <span class="o">*</span><span class="n">ireq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">sci_port_states</span> <span class="n">state</span><span class="p">;</span>

	<span class="n">state</span> <span class="o">=</span> <span class="n">iport</span><span class="o">-&gt;</span><span class="n">sm</span><span class="p">.</span><span class="n">current_state_id</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SCI_PORT_STOPPED</span>:
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">sciport_to_dev</span><span class="p">(</span><span class="n">iport</span><span class="p">),</span> <span class="s">&quot;%s: in wrong state: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">__func__</span><span class="p">,</span> <span class="n">port_state_name</span><span class="p">(</span><span class="n">state</span><span class="p">));</span>
		<span class="k">return</span> <span class="n">SCI_FAILURE_INVALID_STATE</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCI_PORT_STOPPING</span>:
		<span class="n">sci_port_decrement_request_count</span><span class="p">(</span><span class="n">iport</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">iport</span><span class="o">-&gt;</span><span class="n">started_request_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">port_state_machine_change</span><span class="p">(</span><span class="n">iport</span><span class="p">,</span>
						  <span class="n">SCI_PORT_STOPPED</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCI_PORT_READY</span>:
	<span class="k">case</span> <span class="n">SCI_PORT_RESETTING</span>:
	<span class="k">case</span> <span class="n">SCI_PORT_FAILED</span>:
	<span class="k">case</span> <span class="n">SCI_PORT_SUB_WAITING</span>:
	<span class="k">case</span> <span class="n">SCI_PORT_SUB_OPERATIONAL</span>:
		<span class="n">sci_port_decrement_request_count</span><span class="p">(</span><span class="n">iport</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCI_PORT_SUB_CONFIGURING</span>:
		<span class="n">sci_port_decrement_request_count</span><span class="p">(</span><span class="n">iport</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iport</span><span class="o">-&gt;</span><span class="n">started_request_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">port_state_machine_change</span><span class="p">(</span><span class="n">iport</span><span class="p">,</span>
						  <span class="n">SCI_PORT_SUB_OPERATIONAL</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">SCI_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sci_port_enable_port_task_scheduler</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">iport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">pts_control_value</span><span class="p">;</span>

	 <span class="cm">/* enable the port task scheduler in a suspended state */</span>
	<span class="n">pts_control_value</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iport</span><span class="o">-&gt;</span><span class="n">port_task_scheduler_registers</span><span class="o">-&gt;</span><span class="n">control</span><span class="p">);</span>
	<span class="n">pts_control_value</span> <span class="o">|=</span> <span class="n">SCU_PTSxCR_GEN_BIT</span><span class="p">(</span><span class="n">ENABLE</span><span class="p">)</span> <span class="o">|</span> <span class="n">SCU_PTSxCR_GEN_BIT</span><span class="p">(</span><span class="n">SUSPEND</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">pts_control_value</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iport</span><span class="o">-&gt;</span><span class="n">port_task_scheduler_registers</span><span class="o">-&gt;</span><span class="n">control</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sci_port_disable_port_task_scheduler</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">iport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">pts_control_value</span><span class="p">;</span>

	<span class="n">pts_control_value</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iport</span><span class="o">-&gt;</span><span class="n">port_task_scheduler_registers</span><span class="o">-&gt;</span><span class="n">control</span><span class="p">);</span>
	<span class="n">pts_control_value</span> <span class="o">&amp;=</span>
		<span class="o">~</span><span class="p">(</span><span class="n">SCU_PTSxCR_GEN_BIT</span><span class="p">(</span><span class="n">ENABLE</span><span class="p">)</span> <span class="o">|</span> <span class="n">SCU_PTSxCR_GEN_BIT</span><span class="p">(</span><span class="n">SUSPEND</span><span class="p">));</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">pts_control_value</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iport</span><span class="o">-&gt;</span><span class="n">port_task_scheduler_registers</span><span class="o">-&gt;</span><span class="n">control</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sci_port_post_dummy_remote_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">iport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span> <span class="o">=</span> <span class="n">iport</span><span class="o">-&gt;</span><span class="n">owning_controller</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">phys_index</span> <span class="o">=</span> <span class="n">iport</span><span class="o">-&gt;</span><span class="n">physical_port_index</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">scu_remote_node_context</span> <span class="o">*</span><span class="n">rnc</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">rni</span> <span class="o">=</span> <span class="n">iport</span><span class="o">-&gt;</span><span class="n">reserved_rni</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">command</span><span class="p">;</span>

	<span class="n">rnc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">remote_node_context_table</span><span class="p">[</span><span class="n">rni</span><span class="p">];</span>
	<span class="n">rnc</span><span class="o">-&gt;</span><span class="n">ssp</span><span class="p">.</span><span class="n">is_valid</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="n">command</span> <span class="o">=</span> <span class="n">SCU_CONTEXT_COMMAND_POST_RNC_32</span> <span class="o">|</span>
		  <span class="n">phys_index</span> <span class="o">&lt;&lt;</span> <span class="n">SCU_CONTEXT_COMMAND_LOGICAL_PORT_SHIFT</span> <span class="o">|</span> <span class="n">rni</span><span class="p">;</span>

	<span class="n">sci_controller_post_request</span><span class="p">(</span><span class="n">ihost</span><span class="p">,</span> <span class="n">command</span><span class="p">);</span>

	<span class="cm">/* ensure hardware has seen the post rnc command and give it</span>
<span class="cm">	 * ample time to act before sending the suspend</span>
<span class="cm">	 */</span>
	<span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">smu_registers</span><span class="o">-&gt;</span><span class="n">interrupt_status</span><span class="p">);</span> <span class="cm">/* flush */</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

	<span class="n">command</span> <span class="o">=</span> <span class="n">SCU_CONTEXT_COMMAND_POST_RNC_SUSPEND_TX_RX</span> <span class="o">|</span>
		  <span class="n">phys_index</span> <span class="o">&lt;&lt;</span> <span class="n">SCU_CONTEXT_COMMAND_LOGICAL_PORT_SHIFT</span> <span class="o">|</span> <span class="n">rni</span><span class="p">;</span>

	<span class="n">sci_controller_post_request</span><span class="p">(</span><span class="n">ihost</span><span class="p">,</span> <span class="n">command</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sci_port_stopped_state_enter</span><span class="p">(</span><span class="k">struct</span> <span class="n">sci_base_state_machine</span> <span class="o">*</span><span class="n">sm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">iport</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">sm</span><span class="p">,</span> <span class="n">typeof</span><span class="p">(</span><span class="o">*</span><span class="n">iport</span><span class="p">),</span> <span class="n">sm</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iport</span><span class="o">-&gt;</span><span class="n">sm</span><span class="p">.</span><span class="n">previous_state_id</span> <span class="o">==</span> <span class="n">SCI_PORT_STOPPING</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If we enter this state becasuse of a request to stop</span>
<span class="cm">		 * the port then we want to disable the hardwares port</span>
<span class="cm">		 * task scheduler. */</span>
		<span class="n">sci_port_disable_port_task_scheduler</span><span class="p">(</span><span class="n">iport</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sci_port_stopped_state_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sci_base_state_machine</span> <span class="o">*</span><span class="n">sm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">iport</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">sm</span><span class="p">,</span> <span class="n">typeof</span><span class="p">(</span><span class="o">*</span><span class="n">iport</span><span class="p">),</span> <span class="n">sm</span><span class="p">);</span>

	<span class="cm">/* Enable and suspend the port task scheduler */</span>
	<span class="n">sci_port_enable_port_task_scheduler</span><span class="p">(</span><span class="n">iport</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sci_port_ready_state_enter</span><span class="p">(</span><span class="k">struct</span> <span class="n">sci_base_state_machine</span> <span class="o">*</span><span class="n">sm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">iport</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">sm</span><span class="p">,</span> <span class="n">typeof</span><span class="p">(</span><span class="o">*</span><span class="n">iport</span><span class="p">),</span> <span class="n">sm</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span> <span class="o">=</span> <span class="n">iport</span><span class="o">-&gt;</span><span class="n">owning_controller</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">prev_state</span><span class="p">;</span>

	<span class="n">prev_state</span> <span class="o">=</span> <span class="n">iport</span><span class="o">-&gt;</span><span class="n">sm</span><span class="p">.</span><span class="n">previous_state_id</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">prev_state</span>  <span class="o">==</span> <span class="n">SCI_PORT_RESETTING</span><span class="p">)</span>
		<span class="n">isci_port_hard_reset_complete</span><span class="p">(</span><span class="n">iport</span><span class="p">,</span> <span class="n">SCI_SUCCESS</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: port%d !ready</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">iport</span><span class="o">-&gt;</span><span class="n">physical_port_index</span><span class="p">);</span>

	<span class="cm">/* Post and suspend the dummy remote node context for this port. */</span>
	<span class="n">sci_port_post_dummy_remote_node</span><span class="p">(</span><span class="n">iport</span><span class="p">);</span>

	<span class="cm">/* Start the ready substate machine */</span>
	<span class="n">port_state_machine_change</span><span class="p">(</span><span class="n">iport</span><span class="p">,</span>
				  <span class="n">SCI_PORT_SUB_WAITING</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sci_port_resetting_state_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sci_base_state_machine</span> <span class="o">*</span><span class="n">sm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">iport</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">sm</span><span class="p">,</span> <span class="n">typeof</span><span class="p">(</span><span class="o">*</span><span class="n">iport</span><span class="p">),</span> <span class="n">sm</span><span class="p">);</span>

	<span class="n">sci_del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iport</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sci_port_stopping_state_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sci_base_state_machine</span> <span class="o">*</span><span class="n">sm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">iport</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">sm</span><span class="p">,</span> <span class="n">typeof</span><span class="p">(</span><span class="o">*</span><span class="n">iport</span><span class="p">),</span> <span class="n">sm</span><span class="p">);</span>

	<span class="n">sci_del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iport</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>

	<span class="n">sci_port_destroy_dummy_resources</span><span class="p">(</span><span class="n">iport</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sci_port_failed_state_enter</span><span class="p">(</span><span class="k">struct</span> <span class="n">sci_base_state_machine</span> <span class="o">*</span><span class="n">sm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">iport</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">sm</span><span class="p">,</span> <span class="n">typeof</span><span class="p">(</span><span class="o">*</span><span class="n">iport</span><span class="p">),</span> <span class="n">sm</span><span class="p">);</span>

	<span class="n">isci_port_hard_reset_complete</span><span class="p">(</span><span class="n">iport</span><span class="p">,</span> <span class="n">SCI_FAILURE_TIMEOUT</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">sci_port_set_hang_detection_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">iport</span><span class="p">,</span> <span class="n">u32</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">phy_index</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">phy_mask</span> <span class="o">=</span> <span class="n">iport</span><span class="o">-&gt;</span><span class="n">active_phy_mask</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">timeout</span><span class="p">)</span>
		<span class="o">++</span><span class="n">iport</span><span class="o">-&gt;</span><span class="n">hang_detect_users</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">iport</span><span class="o">-&gt;</span><span class="n">hang_detect_users</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="o">--</span><span class="n">iport</span><span class="o">-&gt;</span><span class="n">hang_detect_users</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">iport</span><span class="o">-&gt;</span><span class="n">hang_detect_users</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">||</span> <span class="p">(</span><span class="n">iport</span><span class="o">-&gt;</span><span class="n">hang_detect_users</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">phy_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">phy_index</span> <span class="o">&lt;</span> <span class="n">SCI_MAX_PHYS</span><span class="p">;</span> <span class="n">phy_index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">phy_mask</span> <span class="o">&gt;&gt;</span> <span class="n">phy_index</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">writel</span><span class="p">(</span><span class="n">timeout</span><span class="p">,</span>
				       <span class="o">&amp;</span><span class="n">iport</span><span class="o">-&gt;</span><span class="n">phy_table</span><span class="p">[</span><span class="n">phy_index</span><span class="p">]</span>
					  <span class="o">-&gt;</span><span class="n">link_layer_registers</span>
					  <span class="o">-&gt;</span><span class="n">link_layer_hang_detection_timeout</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cm">/* --------------------------------------------------------------------------- */</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sci_base_state</span> <span class="n">sci_port_state_table</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">SCI_PORT_STOPPED</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">enter_state</span> <span class="o">=</span> <span class="n">sci_port_stopped_state_enter</span><span class="p">,</span>
		<span class="p">.</span><span class="n">exit_state</span>  <span class="o">=</span> <span class="n">sci_port_stopped_state_exit</span>
	<span class="p">},</span>
	<span class="p">[</span><span class="n">SCI_PORT_STOPPING</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">exit_state</span>  <span class="o">=</span> <span class="n">sci_port_stopping_state_exit</span>
	<span class="p">},</span>
	<span class="p">[</span><span class="n">SCI_PORT_READY</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">enter_state</span> <span class="o">=</span> <span class="n">sci_port_ready_state_enter</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">[</span><span class="n">SCI_PORT_SUB_WAITING</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">enter_state</span> <span class="o">=</span> <span class="n">sci_port_ready_substate_waiting_enter</span><span class="p">,</span>
		<span class="p">.</span><span class="n">exit_state</span>  <span class="o">=</span> <span class="n">scic_sds_port_ready_substate_waiting_exit</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">[</span><span class="n">SCI_PORT_SUB_OPERATIONAL</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">enter_state</span> <span class="o">=</span> <span class="n">sci_port_ready_substate_operational_enter</span><span class="p">,</span>
		<span class="p">.</span><span class="n">exit_state</span>  <span class="o">=</span> <span class="n">sci_port_ready_substate_operational_exit</span>
	<span class="p">},</span>
	<span class="p">[</span><span class="n">SCI_PORT_SUB_CONFIGURING</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">enter_state</span> <span class="o">=</span> <span class="n">sci_port_ready_substate_configuring_enter</span>
	<span class="p">},</span>
	<span class="p">[</span><span class="n">SCI_PORT_RESETTING</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">exit_state</span>  <span class="o">=</span> <span class="n">sci_port_resetting_state_exit</span>
	<span class="p">},</span>
	<span class="p">[</span><span class="n">SCI_PORT_FAILED</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">enter_state</span> <span class="o">=</span> <span class="n">sci_port_failed_state_enter</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">sci_port_construct</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">iport</span><span class="p">,</span> <span class="n">u8</span> <span class="n">index</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sci_init_sm</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iport</span><span class="o">-&gt;</span><span class="n">sm</span><span class="p">,</span> <span class="n">sci_port_state_table</span><span class="p">,</span> <span class="n">SCI_PORT_STOPPED</span><span class="p">);</span>

	<span class="n">iport</span><span class="o">-&gt;</span><span class="n">logical_port_index</span>  <span class="o">=</span> <span class="n">SCIC_SDS_DUMMY_PORT</span><span class="p">;</span>
	<span class="n">iport</span><span class="o">-&gt;</span><span class="n">physical_port_index</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>
	<span class="n">iport</span><span class="o">-&gt;</span><span class="n">active_phy_mask</span>     <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">iport</span><span class="o">-&gt;</span><span class="n">enabled_phy_mask</span>    <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">iport</span><span class="o">-&gt;</span><span class="n">last_active_phy</span>     <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">iport</span><span class="o">-&gt;</span><span class="n">ready_exit</span>	   <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">iport</span><span class="o">-&gt;</span><span class="n">owning_controller</span> <span class="o">=</span> <span class="n">ihost</span><span class="p">;</span>

	<span class="n">iport</span><span class="o">-&gt;</span><span class="n">started_request_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">iport</span><span class="o">-&gt;</span><span class="n">assigned_device_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">iport</span><span class="o">-&gt;</span><span class="n">hang_detect_users</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">iport</span><span class="o">-&gt;</span><span class="n">reserved_rni</span> <span class="o">=</span> <span class="n">SCU_DUMMY_INDEX</span><span class="p">;</span>
	<span class="n">iport</span><span class="o">-&gt;</span><span class="n">reserved_tag</span> <span class="o">=</span> <span class="n">SCI_CONTROLLER_INVALID_IO_TAG</span><span class="p">;</span>

	<span class="n">sci_init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iport</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">,</span> <span class="n">port_timeout</span><span class="p">);</span>

	<span class="n">iport</span><span class="o">-&gt;</span><span class="n">port_task_scheduler_registers</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">SCI_MAX_PHYS</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span>
		<span class="n">iport</span><span class="o">-&gt;</span><span class="n">phy_table</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">sci_port_broadcast_change_received</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">iport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">isci_phy</span> <span class="o">*</span><span class="n">iphy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span> <span class="o">=</span> <span class="n">iport</span><span class="o">-&gt;</span><span class="n">owning_controller</span><span class="p">;</span>

	<span class="cm">/* notify the user. */</span>
	<span class="n">isci_port_bc_change_received</span><span class="p">(</span><span class="n">ihost</span><span class="p">,</span> <span class="n">iport</span><span class="p">,</span> <span class="n">iphy</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">wait_port_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">,</span> <span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">iport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">wait_event</span><span class="p">(</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">eventq</span><span class="p">,</span> <span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">IPORT_RESET_PENDING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iport</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">isci_port_perform_hard_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">,</span> <span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">iport</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">isci_phy</span> <span class="o">*</span><span class="n">iphy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">sci_status</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">TMF_RESP_FUNC_COMPLETE</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: iport = %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span> <span class="n">iport</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">scic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">IPORT_RESET_PENDING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iport</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>

	<span class="cp">#define ISCI_PORT_RESET_TIMEOUT SCIC_SDS_SIGNATURE_FIS_TIMEOUT</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">sci_port_hard_reset</span><span class="p">(</span><span class="n">iport</span><span class="p">,</span> <span class="n">ISCI_PORT_RESET_TIMEOUT</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">scic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">SCI_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">wait_port_reset</span><span class="p">(</span><span class="n">ihost</span><span class="p">,</span> <span class="n">iport</span><span class="p">);</span>

		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;%s: iport = %p; hard reset completion</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">iport</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">iport</span><span class="o">-&gt;</span><span class="n">hard_reset_status</span> <span class="o">!=</span> <span class="n">SCI_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">TMF_RESP_FUNC_FAILED</span><span class="p">;</span>

			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;%s: iport = %p; hard reset failed (0x%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">iport</span><span class="p">,</span> <span class="n">iport</span><span class="o">-&gt;</span><span class="n">hard_reset_status</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">IPORT_RESET_PENDING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iport</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
		<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">eventq</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">TMF_RESP_FUNC_FAILED</span><span class="p">;</span>

		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;%s: iport = %p; sci_port_hard_reset call&quot;</span>
			<span class="s">&quot; failed 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">iport</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>

	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">isci_ata_check_ready</span><span class="p">(</span><span class="k">struct</span> <span class="n">domain_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">iport</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">lldd_port</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span> <span class="o">=</span> <span class="n">dev_to_ihost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">isci_remote_device</span> <span class="o">*</span><span class="n">idev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">scic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">idev</span> <span class="o">=</span> <span class="n">isci_lookup_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">scic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">idev</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">IPORT_RESET_PENDING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iport</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="o">!!</span><span class="n">iport</span><span class="o">-&gt;</span><span class="n">active_phy_mask</span><span class="p">;</span>
 <span class="nl">out:</span>
	<span class="n">isci_put_device</span><span class="p">(</span><span class="n">idev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">isci_port_deformed</span><span class="p">(</span><span class="k">struct</span> <span class="n">asd_sas_phy</span> <span class="o">*</span><span class="n">phy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span> <span class="o">=</span> <span class="n">phy</span><span class="o">-&gt;</span><span class="n">ha</span><span class="o">-&gt;</span><span class="n">lldd_ha</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">iport</span> <span class="o">=</span> <span class="n">phy</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">lldd_port</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* we got a port notification on a port that was subsequently</span>
<span class="cm">	 * torn down and libsas is just now catching up</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iport</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">scic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SCI_MAX_PHYS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iport</span><span class="o">-&gt;</span><span class="n">active_phy_mask</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">scic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">SCI_MAX_PHYS</span><span class="p">)</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: port: %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">iport</span> <span class="o">-</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">ports</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">isci_port_formed</span><span class="p">(</span><span class="k">struct</span> <span class="n">asd_sas_phy</span> <span class="o">*</span><span class="n">phy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span> <span class="o">=</span> <span class="n">phy</span><span class="o">-&gt;</span><span class="n">ha</span><span class="o">-&gt;</span><span class="n">lldd_ha</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">isci_phy</span> <span class="o">*</span><span class="n">iphy</span> <span class="o">=</span> <span class="n">to_iphy</span><span class="p">(</span><span class="n">phy</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">asd_sas_port</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="n">phy</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">iport</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* initial ports are formed as the driver is still initializing,</span>
<span class="cm">	 * wait for that process to complete</span>
<span class="cm">	 */</span>
	<span class="n">wait_for_start</span><span class="p">(</span><span class="n">ihost</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">scic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SCI_MAX_PORTS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iport</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">ports</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iport</span><span class="o">-&gt;</span><span class="n">active_phy_mask</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">iphy</span><span class="o">-&gt;</span><span class="n">phy_index</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">scic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">SCI_MAX_PORTS</span><span class="p">)</span>
		<span class="n">iport</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">port</span><span class="o">-&gt;</span><span class="n">lldd_port</span> <span class="o">=</span> <span class="n">iport</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
