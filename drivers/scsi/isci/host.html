<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › scsi › isci › host.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>host.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * This file is provided under a dual BSD/GPLv2 license.  When using or</span>
<span class="cm"> * redistributing this file, you may do so under either license.</span>
<span class="cm"> *</span>
<span class="cm"> * GPL LICENSE SUMMARY</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of version 2 of the GNU General Public License as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="cm"> * General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.</span>
<span class="cm"> * The full GNU General Public License is included in this distribution</span>
<span class="cm"> * in the file called LICENSE.GPL.</span>
<span class="cm"> *</span>
<span class="cm"> * BSD LICENSE</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.</span>
<span class="cm"> * All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * Redistribution and use in source and binary forms, with or without</span>
<span class="cm"> * modification, are permitted provided that the following conditions</span>
<span class="cm"> * are met:</span>
<span class="cm"> *</span>
<span class="cm"> *   * Redistributions of source code must retain the above copyright</span>
<span class="cm"> *     notice, this list of conditions and the following disclaimer.</span>
<span class="cm"> *   * Redistributions in binary form must reproduce the above copyright</span>
<span class="cm"> *     notice, this list of conditions and the following disclaimer in</span>
<span class="cm"> *     the documentation and/or other materials provided with the</span>
<span class="cm"> *     distribution.</span>
<span class="cm"> *   * Neither the name of Intel Corporation nor the names of its</span>
<span class="cm"> *     contributors may be used to endorse or promote products derived</span>
<span class="cm"> *     from this software without specific prior written permission.</span>
<span class="cm"> *</span>
<span class="cm"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span>
<span class="cm"> * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span>
<span class="cm"> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</span>
<span class="cm"> * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</span>
<span class="cm"> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span>
<span class="cm"> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span>
<span class="cm"> * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span>
<span class="cm"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span>
<span class="cm"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
<span class="cm"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span>
<span class="cm"> * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/circ_buf.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;scsi/sas.h&gt;</span>
<span class="cp">#include &quot;host.h&quot;</span>
<span class="cp">#include &quot;isci.h&quot;</span>
<span class="cp">#include &quot;port.h&quot;</span>
<span class="cp">#include &quot;probe_roms.h&quot;</span>
<span class="cp">#include &quot;remote_device.h&quot;</span>
<span class="cp">#include &quot;request.h&quot;</span>
<span class="cp">#include &quot;scu_completion_codes.h&quot;</span>
<span class="cp">#include &quot;scu_event_codes.h&quot;</span>
<span class="cp">#include &quot;registers.h&quot;</span>
<span class="cp">#include &quot;scu_remote_node_context.h&quot;</span>
<span class="cp">#include &quot;scu_task_context.h&quot;</span>

<span class="cp">#define SCU_CONTEXT_RAM_INIT_STALL_TIME      200</span>

<span class="cp">#define smu_max_ports(dcc_value) \</span>
<span class="cp">	(\</span>
<span class="cp">		(((dcc_value) &amp; SMU_DEVICE_CONTEXT_CAPACITY_MAX_LP_MASK) \</span>
<span class="cp">		 &gt;&gt; SMU_DEVICE_CONTEXT_CAPACITY_MAX_LP_SHIFT) + 1 \</span>
<span class="cp">	)</span>

<span class="cp">#define smu_max_task_contexts(dcc_value)	\</span>
<span class="cp">	(\</span>
<span class="cp">		(((dcc_value) &amp; SMU_DEVICE_CONTEXT_CAPACITY_MAX_TC_MASK) \</span>
<span class="cp">		 &gt;&gt; SMU_DEVICE_CONTEXT_CAPACITY_MAX_TC_SHIFT) + 1 \</span>
<span class="cp">	)</span>

<span class="cp">#define smu_max_rncs(dcc_value) \</span>
<span class="cp">	(\</span>
<span class="cp">		(((dcc_value) &amp; SMU_DEVICE_CONTEXT_CAPACITY_MAX_RNC_MASK) \</span>
<span class="cp">		 &gt;&gt; SMU_DEVICE_CONTEXT_CAPACITY_MAX_RNC_SHIFT) + 1 \</span>
<span class="cp">	)</span>

<span class="cp">#define SCIC_SDS_CONTROLLER_PHY_START_TIMEOUT      100</span>

<span class="cm">/**</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * The number of milliseconds to wait while a given phy is consuming power</span>
<span class="cm"> * before allowing another set of phys to consume power. Ultimately, this will</span>
<span class="cm"> * be specified by OEM parameter.</span>
<span class="cm"> */</span>
<span class="cp">#define SCIC_SDS_CONTROLLER_POWER_CONTROL_INTERVAL 500</span>

<span class="cm">/**</span>
<span class="cm"> * NORMALIZE_PUT_POINTER() -</span>
<span class="cm"> *</span>
<span class="cm"> * This macro will normalize the completion queue put pointer so its value can</span>
<span class="cm"> * be used as an array inde</span>
<span class="cm"> */</span>
<span class="cp">#define NORMALIZE_PUT_POINTER(x) \</span>
<span class="cp">	((x) &amp; SMU_COMPLETION_QUEUE_PUT_POINTER_MASK)</span>


<span class="cm">/**</span>
<span class="cm"> * NORMALIZE_EVENT_POINTER() -</span>
<span class="cm"> *</span>
<span class="cm"> * This macro will normalize the completion queue event entry so its value can</span>
<span class="cm"> * be used as an index.</span>
<span class="cm"> */</span>
<span class="cp">#define NORMALIZE_EVENT_POINTER(x) \</span>
<span class="cp">	(\</span>
<span class="cp">		((x) &amp; SMU_COMPLETION_QUEUE_GET_EVENT_POINTER_MASK) \</span>
<span class="cp">		&gt;&gt; SMU_COMPLETION_QUEUE_GET_EVENT_POINTER_SHIFT	\</span>
<span class="cp">	)</span>

<span class="cm">/**</span>
<span class="cm"> * NORMALIZE_GET_POINTER() -</span>
<span class="cm"> *</span>
<span class="cm"> * This macro will normalize the completion queue get pointer so its value can</span>
<span class="cm"> * be used as an index into an array</span>
<span class="cm"> */</span>
<span class="cp">#define NORMALIZE_GET_POINTER(x) \</span>
<span class="cp">	((x) &amp; SMU_COMPLETION_QUEUE_GET_POINTER_MASK)</span>

<span class="cm">/**</span>
<span class="cm"> * NORMALIZE_GET_POINTER_CYCLE_BIT() -</span>
<span class="cm"> *</span>
<span class="cm"> * This macro will normalize the completion queue cycle pointer so it matches</span>
<span class="cm"> * the completion queue cycle bit</span>
<span class="cm"> */</span>
<span class="cp">#define NORMALIZE_GET_POINTER_CYCLE_BIT(x) \</span>
<span class="cp">	((SMU_CQGR_CYCLE_BIT &amp; (x)) &lt;&lt; (31 - SMU_COMPLETION_QUEUE_GET_CYCLE_BIT_SHIFT))</span>

<span class="cm">/**</span>
<span class="cm"> * COMPLETION_QUEUE_CYCLE_BIT() -</span>
<span class="cm"> *</span>
<span class="cm"> * This macro will return the cycle bit of the completion queue entry</span>
<span class="cm"> */</span>
<span class="cp">#define COMPLETION_QUEUE_CYCLE_BIT(x) ((x) &amp; 0x80000000)</span>

<span class="cm">/* Init the state machine and call the state entry function (if any) */</span>
<span class="kt">void</span> <span class="nf">sci_init_sm</span><span class="p">(</span><span class="k">struct</span> <span class="n">sci_base_state_machine</span> <span class="o">*</span><span class="n">sm</span><span class="p">,</span>
		 <span class="k">const</span> <span class="k">struct</span> <span class="n">sci_base_state</span> <span class="o">*</span><span class="n">state_table</span><span class="p">,</span> <span class="n">u32</span> <span class="n">initial_state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sci_state_transition_t</span> <span class="n">handler</span><span class="p">;</span>

	<span class="n">sm</span><span class="o">-&gt;</span><span class="n">initial_state_id</span>    <span class="o">=</span> <span class="n">initial_state</span><span class="p">;</span>
	<span class="n">sm</span><span class="o">-&gt;</span><span class="n">previous_state_id</span>   <span class="o">=</span> <span class="n">initial_state</span><span class="p">;</span>
	<span class="n">sm</span><span class="o">-&gt;</span><span class="n">current_state_id</span>    <span class="o">=</span> <span class="n">initial_state</span><span class="p">;</span>
	<span class="n">sm</span><span class="o">-&gt;</span><span class="n">state_table</span>         <span class="o">=</span> <span class="n">state_table</span><span class="p">;</span>

	<span class="n">handler</span> <span class="o">=</span> <span class="n">sm</span><span class="o">-&gt;</span><span class="n">state_table</span><span class="p">[</span><span class="n">initial_state</span><span class="p">].</span><span class="n">enter_state</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">handler</span><span class="p">)</span>
		<span class="n">handler</span><span class="p">(</span><span class="n">sm</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Call the state exit fn, update the current state, call the state entry fn */</span>
<span class="kt">void</span> <span class="nf">sci_change_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">sci_base_state_machine</span> <span class="o">*</span><span class="n">sm</span><span class="p">,</span> <span class="n">u32</span> <span class="n">next_state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sci_state_transition_t</span> <span class="n">handler</span><span class="p">;</span>

	<span class="n">handler</span> <span class="o">=</span> <span class="n">sm</span><span class="o">-&gt;</span><span class="n">state_table</span><span class="p">[</span><span class="n">sm</span><span class="o">-&gt;</span><span class="n">current_state_id</span><span class="p">].</span><span class="n">exit_state</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">handler</span><span class="p">)</span>
		<span class="n">handler</span><span class="p">(</span><span class="n">sm</span><span class="p">);</span>

	<span class="n">sm</span><span class="o">-&gt;</span><span class="n">previous_state_id</span> <span class="o">=</span> <span class="n">sm</span><span class="o">-&gt;</span><span class="n">current_state_id</span><span class="p">;</span>
	<span class="n">sm</span><span class="o">-&gt;</span><span class="n">current_state_id</span> <span class="o">=</span> <span class="n">next_state</span><span class="p">;</span>

	<span class="n">handler</span> <span class="o">=</span> <span class="n">sm</span><span class="o">-&gt;</span><span class="n">state_table</span><span class="p">[</span><span class="n">sm</span><span class="o">-&gt;</span><span class="n">current_state_id</span><span class="p">].</span><span class="n">enter_state</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">handler</span><span class="p">)</span>
		<span class="n">handler</span><span class="p">(</span><span class="n">sm</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">sci_controller_completion_queue_has_entries</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">get_value</span> <span class="o">=</span> <span class="n">ihost</span><span class="o">-&gt;</span><span class="n">completion_queue_get</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">get_index</span> <span class="o">=</span> <span class="n">get_value</span> <span class="o">&amp;</span> <span class="n">SMU_COMPLETION_QUEUE_GET_POINTER_MASK</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">NORMALIZE_GET_POINTER_CYCLE_BIT</span><span class="p">(</span><span class="n">get_value</span><span class="p">)</span> <span class="o">==</span>
	    <span class="n">COMPLETION_QUEUE_CYCLE_BIT</span><span class="p">(</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">completion_queue</span><span class="p">[</span><span class="n">get_index</span><span class="p">]))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">sci_controller_isr</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sci_controller_completion_queue_has_entries</span><span class="p">(</span><span class="n">ihost</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="cm">/* we have a spurious interrupt it could be that we have already</span>
<span class="cm">	 * emptied the completion queue from a previous interrupt</span>
<span class="cm">	 * FIXME: really!?</span>
<span class="cm">	 */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">SMU_ISR_COMPLETION</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">smu_registers</span><span class="o">-&gt;</span><span class="n">interrupt_status</span><span class="p">);</span>

	<span class="cm">/* There is a race in the hardware that could cause us not to be</span>
<span class="cm">	 * notified of an interrupt completion if we do not take this</span>
<span class="cm">	 * step.  We will mask then unmask the interrupts so if there is</span>
<span class="cm">	 * another interrupt pending the clearing of the interrupt</span>
<span class="cm">	 * source we get the next interrupt message.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">scic_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">IHOST_IRQ_ENABLED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">writel</span><span class="p">(</span><span class="mh">0xFF000000</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">smu_registers</span><span class="o">-&gt;</span><span class="n">interrupt_mask</span><span class="p">);</span>
		<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">smu_registers</span><span class="o">-&gt;</span><span class="n">interrupt_mask</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">scic_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">irqreturn_t</span> <span class="nf">isci_msix_isr</span><span class="p">(</span><span class="kt">int</span> <span class="n">vec</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sci_controller_isr</span><span class="p">(</span><span class="n">ihost</span><span class="p">))</span>
		<span class="n">tasklet_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">completion_tasklet</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">sci_controller_error_isr</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">interrupt_status</span><span class="p">;</span>

	<span class="n">interrupt_status</span> <span class="o">=</span>
		<span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">smu_registers</span><span class="o">-&gt;</span><span class="n">interrupt_status</span><span class="p">);</span>
	<span class="n">interrupt_status</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">SMU_ISR_QUEUE_ERROR</span> <span class="o">|</span> <span class="n">SMU_ISR_QUEUE_SUSPEND</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">interrupt_status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * There is an error interrupt pending so let it through and handle</span>
<span class="cm">		 * in the callback */</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * There is a race in the hardware that could cause us not to be notified</span>
<span class="cm">	 * of an interrupt completion if we do not take this step.  We will mask</span>
<span class="cm">	 * then unmask the error interrupts so if there was another interrupt</span>
<span class="cm">	 * pending we will be notified.</span>
<span class="cm">	 * Could we write the value of (SMU_ISR_QUEUE_ERROR | SMU_ISR_QUEUE_SUSPEND)? */</span>
	<span class="n">writel</span><span class="p">(</span><span class="mh">0xff</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">smu_registers</span><span class="o">-&gt;</span><span class="n">interrupt_mask</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">smu_registers</span><span class="o">-&gt;</span><span class="n">interrupt_mask</span><span class="p">);</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sci_controller_task_completion</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">index</span> <span class="o">=</span> <span class="n">SCU_GET_COMPLETION_INDEX</span><span class="p">(</span><span class="n">ent</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">isci_request</span> <span class="o">*</span><span class="n">ireq</span> <span class="o">=</span> <span class="n">ihost</span><span class="o">-&gt;</span><span class="n">reqs</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>

	<span class="cm">/* Make sure that we really want to process this IO request */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">IREQ_ACTIVE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ireq</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">ireq</span><span class="o">-&gt;</span><span class="n">io_tag</span> <span class="o">!=</span> <span class="n">SCI_CONTROLLER_INVALID_IO_TAG</span> <span class="o">&amp;&amp;</span>
	    <span class="n">ISCI_TAG_SEQ</span><span class="p">(</span><span class="n">ireq</span><span class="o">-&gt;</span><span class="n">io_tag</span><span class="p">)</span> <span class="o">==</span> <span class="n">ihost</span><span class="o">-&gt;</span><span class="n">io_request_sequence</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
		<span class="cm">/* Yep this is a valid io request pass it along to the</span>
<span class="cm">		 * io request handler</span>
<span class="cm">		 */</span>
		<span class="n">sci_io_request_tc_completion</span><span class="p">(</span><span class="n">ireq</span><span class="p">,</span> <span class="n">ent</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sci_controller_sdma_completion</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">index</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">isci_request</span> <span class="o">*</span><span class="n">ireq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">isci_remote_device</span> <span class="o">*</span><span class="n">idev</span><span class="p">;</span>

	<span class="n">index</span> <span class="o">=</span> <span class="n">SCU_GET_COMPLETION_INDEX</span><span class="p">(</span><span class="n">ent</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">scu_get_command_request_type</span><span class="p">(</span><span class="n">ent</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SCU_CONTEXT_COMMAND_REQUEST_TYPE_POST_TC</span>:
	<span class="k">case</span> <span class="n">SCU_CONTEXT_COMMAND_REQUEST_TYPE_DUMP_TC</span>:
		<span class="n">ireq</span> <span class="o">=</span> <span class="n">ihost</span><span class="o">-&gt;</span><span class="n">reqs</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: %x for io request %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">__func__</span><span class="p">,</span> <span class="n">ent</span><span class="p">,</span> <span class="n">ireq</span><span class="p">);</span>
		<span class="cm">/* @todo For a post TC operation we need to fail the IO</span>
<span class="cm">		 * request</span>
<span class="cm">		 */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCU_CONTEXT_COMMAND_REQUEST_TYPE_DUMP_RNC</span>:
	<span class="k">case</span> <span class="n">SCU_CONTEXT_COMMAND_REQUEST_TYPE_OTHER_RNC</span>:
	<span class="k">case</span> <span class="n">SCU_CONTEXT_COMMAND_REQUEST_TYPE_POST_RNC</span>:
		<span class="n">idev</span> <span class="o">=</span> <span class="n">ihost</span><span class="o">-&gt;</span><span class="n">device_table</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: %x for device %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">__func__</span><span class="p">,</span> <span class="n">ent</span><span class="p">,</span> <span class="n">idev</span><span class="p">);</span>
		<span class="cm">/* @todo For a port RNC operation we need to fail the</span>
<span class="cm">		 * device</span>
<span class="cm">		 */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: unknown completion type %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">__func__</span><span class="p">,</span> <span class="n">ent</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sci_controller_unsolicited_frame</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">index</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">frame_index</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">scu_unsolicited_frame_header</span> <span class="o">*</span><span class="n">frame_header</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">isci_phy</span> <span class="o">*</span><span class="n">iphy</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">isci_remote_device</span> <span class="o">*</span><span class="n">idev</span><span class="p">;</span>

	<span class="k">enum</span> <span class="n">sci_status</span> <span class="n">result</span> <span class="o">=</span> <span class="n">SCI_FAILURE</span><span class="p">;</span>

	<span class="n">frame_index</span> <span class="o">=</span> <span class="n">SCU_GET_FRAME_INDEX</span><span class="p">(</span><span class="n">ent</span><span class="p">);</span>

	<span class="n">frame_header</span> <span class="o">=</span> <span class="n">ihost</span><span class="o">-&gt;</span><span class="n">uf_control</span><span class="p">.</span><span class="n">buffers</span><span class="p">.</span><span class="n">array</span><span class="p">[</span><span class="n">frame_index</span><span class="p">].</span><span class="n">header</span><span class="p">;</span>
	<span class="n">ihost</span><span class="o">-&gt;</span><span class="n">uf_control</span><span class="p">.</span><span class="n">buffers</span><span class="p">.</span><span class="n">array</span><span class="p">[</span><span class="n">frame_index</span><span class="p">].</span><span class="n">state</span> <span class="o">=</span> <span class="n">UNSOLICITED_FRAME_IN_USE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">SCU_GET_FRAME_ERROR</span><span class="p">(</span><span class="n">ent</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * / @todo If the IAF frame or SIGNATURE FIS frame has an error will</span>
<span class="cm">		 * /       this cause a problem? We expect the phy initialization will</span>
<span class="cm">		 * /       fail if there is an error in the frame. */</span>
		<span class="n">sci_controller_release_frame</span><span class="p">(</span><span class="n">ihost</span><span class="p">,</span> <span class="n">frame_index</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">frame_header</span><span class="o">-&gt;</span><span class="n">is_address_frame</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">index</span> <span class="o">=</span> <span class="n">SCU_GET_PROTOCOL_ENGINE_INDEX</span><span class="p">(</span><span class="n">ent</span><span class="p">);</span>
		<span class="n">iphy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">sci_phy_frame_handler</span><span class="p">(</span><span class="n">iphy</span><span class="p">,</span> <span class="n">frame_index</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>

		<span class="n">index</span> <span class="o">=</span> <span class="n">SCU_GET_COMPLETION_INDEX</span><span class="p">(</span><span class="n">ent</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">==</span> <span class="n">SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * This is a signature fis or a frame from a direct attached SATA</span>
<span class="cm">			 * device that has not yet been created.  In either case forwared</span>
<span class="cm">			 * the frame to the PE and let it take care of the frame data. */</span>
			<span class="n">index</span> <span class="o">=</span> <span class="n">SCU_GET_PROTOCOL_ENGINE_INDEX</span><span class="p">(</span><span class="n">ent</span><span class="p">);</span>
			<span class="n">iphy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
			<span class="n">result</span> <span class="o">=</span> <span class="n">sci_phy_frame_handler</span><span class="p">(</span><span class="n">iphy</span><span class="p">,</span> <span class="n">frame_index</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">ihost</span><span class="o">-&gt;</span><span class="n">remote_node_entries</span><span class="p">)</span>
				<span class="n">idev</span> <span class="o">=</span> <span class="n">ihost</span><span class="o">-&gt;</span><span class="n">device_table</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
			<span class="k">else</span>
				<span class="n">idev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">idev</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="n">result</span> <span class="o">=</span> <span class="n">sci_remote_device_frame_handler</span><span class="p">(</span><span class="n">idev</span><span class="p">,</span> <span class="n">frame_index</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">sci_controller_release_frame</span><span class="p">(</span><span class="n">ihost</span><span class="p">,</span> <span class="n">frame_index</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="n">SCI_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * / @todo Is there any reason to report some additional error message</span>
<span class="cm">		 * /       when we get this failure notifiction? */</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sci_controller_event_completion</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">isci_remote_device</span> <span class="o">*</span><span class="n">idev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">isci_request</span> <span class="o">*</span><span class="n">ireq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">isci_phy</span> <span class="o">*</span><span class="n">iphy</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">index</span><span class="p">;</span>

	<span class="n">index</span> <span class="o">=</span> <span class="n">SCU_GET_COMPLETION_INDEX</span><span class="p">(</span><span class="n">ent</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">scu_get_event_type</span><span class="p">(</span><span class="n">ent</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SCU_EVENT_TYPE_SMU_COMMAND_ERROR</span>:
		<span class="cm">/* / @todo The driver did something wrong and we need to fix the condtion. */</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;%s: SCIC Controller 0x%p received SMU command error &quot;</span>
			<span class="s">&quot;0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span>
			<span class="n">ihost</span><span class="p">,</span>
			<span class="n">ent</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SCU_EVENT_TYPE_SMU_PCQ_ERROR</span>:
	<span class="k">case</span> <span class="n">SCU_EVENT_TYPE_SMU_ERROR</span>:
	<span class="k">case</span> <span class="n">SCU_EVENT_TYPE_FATAL_MEMORY_ERROR</span>:
		<span class="cm">/*</span>
<span class="cm">		 * / @todo This is a hardware failure and its likely that we want to</span>
<span class="cm">		 * /       reset the controller. */</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;%s: SCIC Controller 0x%p received fatal controller &quot;</span>
			<span class="s">&quot;event  0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span>
			<span class="n">ihost</span><span class="p">,</span>
			<span class="n">ent</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SCU_EVENT_TYPE_TRANSPORT_ERROR</span>:
		<span class="n">ireq</span> <span class="o">=</span> <span class="n">ihost</span><span class="o">-&gt;</span><span class="n">reqs</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
		<span class="n">sci_io_request_event_handler</span><span class="p">(</span><span class="n">ireq</span><span class="p">,</span> <span class="n">ent</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SCU_EVENT_TYPE_PTX_SCHEDULE_EVENT</span>:
		<span class="k">switch</span> <span class="p">(</span><span class="n">scu_get_event_specifier</span><span class="p">(</span><span class="n">ent</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">SCU_EVENT_SPECIFIC_SMP_RESPONSE_NO_PE</span>:
		<span class="k">case</span> <span class="n">SCU_EVENT_SPECIFIC_TASK_TIMEOUT</span>:
			<span class="n">ireq</span> <span class="o">=</span> <span class="n">ihost</span><span class="o">-&gt;</span><span class="n">reqs</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ireq</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="n">sci_io_request_event_handler</span><span class="p">(</span><span class="n">ireq</span><span class="p">,</span> <span class="n">ent</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					 <span class="s">&quot;%s: SCIC Controller 0x%p received &quot;</span>
					 <span class="s">&quot;event 0x%x for io request object &quot;</span>
					 <span class="s">&quot;that doesnt exist.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					 <span class="n">__func__</span><span class="p">,</span>
					 <span class="n">ihost</span><span class="p">,</span>
					 <span class="n">ent</span><span class="p">);</span>

			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCU_EVENT_SPECIFIC_IT_NEXUS_TIMEOUT</span>:
			<span class="n">idev</span> <span class="o">=</span> <span class="n">ihost</span><span class="o">-&gt;</span><span class="n">device_table</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">idev</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="n">sci_remote_device_event_handler</span><span class="p">(</span><span class="n">idev</span><span class="p">,</span> <span class="n">ent</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					 <span class="s">&quot;%s: SCIC Controller 0x%p received &quot;</span>
					 <span class="s">&quot;event 0x%x for remote device object &quot;</span>
					 <span class="s">&quot;that doesnt exist.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					 <span class="n">__func__</span><span class="p">,</span>
					 <span class="n">ihost</span><span class="p">,</span>
					 <span class="n">ent</span><span class="p">);</span>

			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SCU_EVENT_TYPE_BROADCAST_CHANGE</span>:
	<span class="cm">/*</span>
<span class="cm">	 * direct the broadcast change event to the phy first and then let</span>
<span class="cm">	 * the phy redirect the broadcast change to the port object */</span>
	<span class="k">case</span> <span class="n">SCU_EVENT_TYPE_ERR_CNT_EVENT</span>:
	<span class="cm">/*</span>
<span class="cm">	 * direct error counter event to the phy object since that is where</span>
<span class="cm">	 * we get the event notification.  This is a type 4 event. */</span>
	<span class="k">case</span> <span class="n">SCU_EVENT_TYPE_OSSP_EVENT</span>:
		<span class="n">index</span> <span class="o">=</span> <span class="n">SCU_GET_PROTOCOL_ENGINE_INDEX</span><span class="p">(</span><span class="n">ent</span><span class="p">);</span>
		<span class="n">iphy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
		<span class="n">sci_phy_event_handler</span><span class="p">(</span><span class="n">iphy</span><span class="p">,</span> <span class="n">ent</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SCU_EVENT_TYPE_RNC_SUSPEND_TX</span>:
	<span class="k">case</span> <span class="n">SCU_EVENT_TYPE_RNC_SUSPEND_TX_RX</span>:
	<span class="k">case</span> <span class="n">SCU_EVENT_TYPE_RNC_OPS_MISC</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">ihost</span><span class="o">-&gt;</span><span class="n">remote_node_entries</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">idev</span> <span class="o">=</span> <span class="n">ihost</span><span class="o">-&gt;</span><span class="n">device_table</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">idev</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="n">sci_remote_device_event_handler</span><span class="p">(</span><span class="n">idev</span><span class="p">,</span> <span class="n">ent</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;%s: SCIC Controller 0x%p received event 0x%x &quot;</span>
				<span class="s">&quot;for remote device object 0x%0x that doesnt &quot;</span>
				<span class="s">&quot;exist.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span>
				<span class="n">ihost</span><span class="p">,</span>
				<span class="n">ent</span><span class="p">,</span>
				<span class="n">index</span><span class="p">);</span>

		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			 <span class="s">&quot;%s: SCIC Controller received unknown event code %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">__func__</span><span class="p">,</span>
			 <span class="n">ent</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sci_controller_process_completions</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">completion_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ent</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">get_index</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">get_cycle</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">event_get</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">event_cycle</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;%s: completion queue begining get:0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span>
		<span class="n">ihost</span><span class="o">-&gt;</span><span class="n">completion_queue_get</span><span class="p">);</span>

	<span class="cm">/* Get the component parts of the completion queue */</span>
	<span class="n">get_index</span> <span class="o">=</span> <span class="n">NORMALIZE_GET_POINTER</span><span class="p">(</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">completion_queue_get</span><span class="p">);</span>
	<span class="n">get_cycle</span> <span class="o">=</span> <span class="n">SMU_CQGR_CYCLE_BIT</span> <span class="o">&amp;</span> <span class="n">ihost</span><span class="o">-&gt;</span><span class="n">completion_queue_get</span><span class="p">;</span>

	<span class="n">event_get</span> <span class="o">=</span> <span class="n">NORMALIZE_EVENT_POINTER</span><span class="p">(</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">completion_queue_get</span><span class="p">);</span>
	<span class="n">event_cycle</span> <span class="o">=</span> <span class="n">SMU_CQGR_EVENT_CYCLE_BIT</span> <span class="o">&amp;</span> <span class="n">ihost</span><span class="o">-&gt;</span><span class="n">completion_queue_get</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span>
		<span class="n">NORMALIZE_GET_POINTER_CYCLE_BIT</span><span class="p">(</span><span class="n">get_cycle</span><span class="p">)</span>
		<span class="o">==</span> <span class="n">COMPLETION_QUEUE_CYCLE_BIT</span><span class="p">(</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">completion_queue</span><span class="p">[</span><span class="n">get_index</span><span class="p">])</span>
		<span class="p">)</span> <span class="p">{</span>
		<span class="n">completion_count</span><span class="o">++</span><span class="p">;</span>

		<span class="n">ent</span> <span class="o">=</span> <span class="n">ihost</span><span class="o">-&gt;</span><span class="n">completion_queue</span><span class="p">[</span><span class="n">get_index</span><span class="p">];</span>

		<span class="cm">/* increment the get pointer and check for rollover to toggle the cycle bit */</span>
		<span class="n">get_cycle</span> <span class="o">^=</span> <span class="p">((</span><span class="n">get_index</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SCU_MAX_COMPLETION_QUEUE_ENTRIES</span><span class="p">)</span> <span class="o">&lt;&lt;</span>
			     <span class="p">(</span><span class="n">SMU_COMPLETION_QUEUE_GET_CYCLE_BIT_SHIFT</span> <span class="o">-</span> <span class="n">SCU_MAX_COMPLETION_QUEUE_SHIFT</span><span class="p">);</span>
		<span class="n">get_index</span> <span class="o">=</span> <span class="p">(</span><span class="n">get_index</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">SCU_MAX_COMPLETION_QUEUE_ENTRIES</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>

		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;%s: completion queue entry:0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span>
			<span class="n">ent</span><span class="p">);</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">SCU_GET_COMPLETION_TYPE</span><span class="p">(</span><span class="n">ent</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">SCU_COMPLETION_TYPE_TASK</span>:
			<span class="n">sci_controller_task_completion</span><span class="p">(</span><span class="n">ihost</span><span class="p">,</span> <span class="n">ent</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCU_COMPLETION_TYPE_SDMA</span>:
			<span class="n">sci_controller_sdma_completion</span><span class="p">(</span><span class="n">ihost</span><span class="p">,</span> <span class="n">ent</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCU_COMPLETION_TYPE_UFI</span>:
			<span class="n">sci_controller_unsolicited_frame</span><span class="p">(</span><span class="n">ihost</span><span class="p">,</span> <span class="n">ent</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCU_COMPLETION_TYPE_EVENT</span>:
			<span class="n">sci_controller_event_completion</span><span class="p">(</span><span class="n">ihost</span><span class="p">,</span> <span class="n">ent</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCU_COMPLETION_TYPE_NOTIFY</span>: <span class="p">{</span>
			<span class="n">event_cycle</span> <span class="o">^=</span> <span class="p">((</span><span class="n">event_get</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SCU_MAX_EVENTS</span><span class="p">)</span> <span class="o">&lt;&lt;</span>
				       <span class="p">(</span><span class="n">SMU_COMPLETION_QUEUE_GET_EVENT_CYCLE_BIT_SHIFT</span> <span class="o">-</span> <span class="n">SCU_MAX_EVENTS_SHIFT</span><span class="p">);</span>
			<span class="n">event_get</span> <span class="o">=</span> <span class="p">(</span><span class="n">event_get</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">SCU_MAX_EVENTS</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>

			<span class="n">sci_controller_event_completion</span><span class="p">(</span><span class="n">ihost</span><span class="p">,</span> <span class="n">ent</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="nl">default:</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				 <span class="s">&quot;%s: SCIC Controller received unknown &quot;</span>
				 <span class="s">&quot;completion type %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">__func__</span><span class="p">,</span>
				 <span class="n">ent</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Update the get register if we completed one or more entries */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">completion_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ihost</span><span class="o">-&gt;</span><span class="n">completion_queue_get</span> <span class="o">=</span>
			<span class="n">SMU_CQGR_GEN_BIT</span><span class="p">(</span><span class="n">ENABLE</span><span class="p">)</span> <span class="o">|</span>
			<span class="n">SMU_CQGR_GEN_BIT</span><span class="p">(</span><span class="n">EVENT_ENABLE</span><span class="p">)</span> <span class="o">|</span>
			<span class="n">event_cycle</span> <span class="o">|</span>
			<span class="n">SMU_CQGR_GEN_VAL</span><span class="p">(</span><span class="n">EVENT_POINTER</span><span class="p">,</span> <span class="n">event_get</span><span class="p">)</span> <span class="o">|</span>
			<span class="n">get_cycle</span> <span class="o">|</span>
			<span class="n">SMU_CQGR_GEN_VAL</span><span class="p">(</span><span class="n">POINTER</span><span class="p">,</span> <span class="n">get_index</span><span class="p">);</span>

		<span class="n">writel</span><span class="p">(</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">completion_queue_get</span><span class="p">,</span>
		       <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">smu_registers</span><span class="o">-&gt;</span><span class="n">completion_queue_get</span><span class="p">);</span>

	<span class="p">}</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;%s: completion queue ending get:0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span>
		<span class="n">ihost</span><span class="o">-&gt;</span><span class="n">completion_queue_get</span><span class="p">);</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sci_controller_error_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">interrupt_status</span><span class="p">;</span>

	<span class="n">interrupt_status</span> <span class="o">=</span>
		<span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">smu_registers</span><span class="o">-&gt;</span><span class="n">interrupt_status</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">interrupt_status</span> <span class="o">&amp;</span> <span class="n">SMU_ISR_QUEUE_SUSPEND</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">sci_controller_completion_queue_has_entries</span><span class="p">(</span><span class="n">ihost</span><span class="p">))</span> <span class="p">{</span>

		<span class="n">sci_controller_process_completions</span><span class="p">(</span><span class="n">ihost</span><span class="p">);</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">SMU_ISR_QUEUE_SUSPEND</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">smu_registers</span><span class="o">-&gt;</span><span class="n">interrupt_status</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: status: %#x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
			<span class="n">interrupt_status</span><span class="p">);</span>

		<span class="n">sci_change_state</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">sm</span><span class="p">,</span> <span class="n">SCIC_FAILED</span><span class="p">);</span>

		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If we dont process any completions I am not sure that we want to do this.</span>
<span class="cm">	 * We are in the middle of a hardware fault and should probably be reset.</span>
<span class="cm">	 */</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">smu_registers</span><span class="o">-&gt;</span><span class="n">interrupt_mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">irqreturn_t</span> <span class="nf">isci_intx_isr</span><span class="p">(</span><span class="kt">int</span> <span class="n">vec</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">irqreturn_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">IRQ_NONE</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sci_controller_isr</span><span class="p">(</span><span class="n">ihost</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">SMU_ISR_COMPLETION</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">smu_registers</span><span class="o">-&gt;</span><span class="n">interrupt_status</span><span class="p">);</span>
		<span class="n">tasklet_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">completion_tasklet</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sci_controller_error_isr</span><span class="p">(</span><span class="n">ihost</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">scic_lock</span><span class="p">);</span>
		<span class="n">sci_controller_error_handler</span><span class="p">(</span><span class="n">ihost</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">scic_lock</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">irqreturn_t</span> <span class="nf">isci_error_isr</span><span class="p">(</span><span class="kt">int</span> <span class="n">vec</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sci_controller_error_isr</span><span class="p">(</span><span class="n">ihost</span><span class="p">))</span>
		<span class="n">sci_controller_error_handler</span><span class="p">(</span><span class="n">ihost</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * isci_host_start_complete() - This function is called by the core library,</span>
<span class="cm"> *    through the ISCI Module, to indicate controller start status.</span>
<span class="cm"> * @isci_host: This parameter specifies the ISCI host object</span>
<span class="cm"> * @completion_status: This parameter specifies the completion status from the</span>
<span class="cm"> *    core library.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">isci_host_start_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">,</span> <span class="k">enum</span> <span class="n">sci_status</span> <span class="n">completion_status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">completion_status</span> <span class="o">!=</span> <span class="n">SCI_SUCCESS</span><span class="p">)</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;controller start timed out, continuing...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">IHOST_START_PENDING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">eventq</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">isci_host_scan_finished</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">time</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sas_ha_struct</span> <span class="o">*</span><span class="n">ha</span> <span class="o">=</span> <span class="n">SHOST_TO_SAS_HA</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span> <span class="o">=</span> <span class="n">ha</span><span class="o">-&gt;</span><span class="n">lldd_ha</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">IHOST_START_PENDING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">sas_drain_work</span><span class="p">(</span><span class="n">ha</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sci_controller_get_suggested_start_timeout() - This method returns the</span>
<span class="cm"> *    suggested sci_controller_start() timeout amount.  The user is free to</span>
<span class="cm"> *    use any timeout value, but this method provides the suggested minimum</span>
<span class="cm"> *    start timeout value.  The returned value is based upon empirical</span>
<span class="cm"> *    information determined as a result of interoperability testing.</span>
<span class="cm"> * @controller: the handle to the controller object for which to return the</span>
<span class="cm"> *    suggested start timeout.</span>
<span class="cm"> *</span>
<span class="cm"> * This method returns the number of milliseconds for the suggested start</span>
<span class="cm"> * operation timeout.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="nf">sci_controller_get_suggested_start_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Validate the user supplied parameters. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ihost</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The suggested minimum timeout value for a controller start operation:</span>
<span class="cm">	 *</span>
<span class="cm">	 *     Signature FIS Timeout</span>
<span class="cm">	 *   + Phy Start Timeout</span>
<span class="cm">	 *   + Number of Phy Spin Up Intervals</span>
<span class="cm">	 *   ---------------------------------</span>
<span class="cm">	 *   Number of milliseconds for the controller start operation.</span>
<span class="cm">	 *</span>
<span class="cm">	 * NOTE: The number of phy spin up intervals will be equivalent</span>
<span class="cm">	 *       to the number of phys divided by the number phys allowed</span>
<span class="cm">	 *       per interval - 1 (once OEM parameters are supported).</span>
<span class="cm">	 *       Currently we assume only 1 phy per interval. */</span>

	<span class="k">return</span> <span class="n">SCIC_SDS_SIGNATURE_FIS_TIMEOUT</span>
		<span class="o">+</span> <span class="n">SCIC_SDS_CONTROLLER_PHY_START_TIMEOUT</span>
		<span class="o">+</span> <span class="p">((</span><span class="n">SCI_MAX_PHYS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">SCIC_SDS_CONTROLLER_POWER_CONTROL_INTERVAL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sci_controller_enable_interrupts</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">IHOST_IRQ_ENABLED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">smu_registers</span><span class="o">-&gt;</span><span class="n">interrupt_mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">sci_controller_disable_interrupts</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">IHOST_IRQ_ENABLED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mh">0xffffffff</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">smu_registers</span><span class="o">-&gt;</span><span class="n">interrupt_mask</span><span class="p">);</span>
	<span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">smu_registers</span><span class="o">-&gt;</span><span class="n">interrupt_mask</span><span class="p">);</span> <span class="cm">/* flush */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sci_controller_enable_port_task_scheduler</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">port_task_scheduler_value</span><span class="p">;</span>

	<span class="n">port_task_scheduler_value</span> <span class="o">=</span>
		<span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">scu_registers</span><span class="o">-&gt;</span><span class="n">peg0</span><span class="p">.</span><span class="n">ptsg</span><span class="p">.</span><span class="n">control</span><span class="p">);</span>
	<span class="n">port_task_scheduler_value</span> <span class="o">|=</span>
		<span class="p">(</span><span class="n">SCU_PTSGCR_GEN_BIT</span><span class="p">(</span><span class="n">ETM_ENABLE</span><span class="p">)</span> <span class="o">|</span>
		 <span class="n">SCU_PTSGCR_GEN_BIT</span><span class="p">(</span><span class="n">PTSG_ENABLE</span><span class="p">));</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">port_task_scheduler_value</span><span class="p">,</span>
	       <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">scu_registers</span><span class="o">-&gt;</span><span class="n">peg0</span><span class="p">.</span><span class="n">ptsg</span><span class="p">.</span><span class="n">control</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sci_controller_assign_task_entries</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">task_assignment</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Assign all the TCs to function 0</span>
<span class="cm">	 * TODO: Do we actually need to read this register to write it back?</span>
<span class="cm">	 */</span>

	<span class="n">task_assignment</span> <span class="o">=</span>
		<span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">smu_registers</span><span class="o">-&gt;</span><span class="n">task_context_assignment</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

	<span class="n">task_assignment</span> <span class="o">|=</span> <span class="p">(</span><span class="n">SMU_TCA_GEN_VAL</span><span class="p">(</span><span class="n">STARTING</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">|</span>
		<span class="p">(</span><span class="n">SMU_TCA_GEN_VAL</span><span class="p">(</span><span class="n">ENDING</span><span class="p">,</span>  <span class="n">ihost</span><span class="o">-&gt;</span><span class="n">task_context_entries</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">|</span>
		<span class="p">(</span><span class="n">SMU_TCA_GEN_BIT</span><span class="p">(</span><span class="n">RANGE_CHECK_ENABLE</span><span class="p">));</span>

	<span class="n">writel</span><span class="p">(</span><span class="n">task_assignment</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">smu_registers</span><span class="o">-&gt;</span><span class="n">task_context_assignment</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sci_controller_initialize_completion_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">index</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">completion_queue_control_value</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">completion_queue_get_value</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">completion_queue_put_value</span><span class="p">;</span>

	<span class="n">ihost</span><span class="o">-&gt;</span><span class="n">completion_queue_get</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">completion_queue_control_value</span> <span class="o">=</span>
		<span class="p">(</span><span class="n">SMU_CQC_QUEUE_LIMIT_SET</span><span class="p">(</span><span class="n">SCU_MAX_COMPLETION_QUEUE_ENTRIES</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span>
		 <span class="n">SMU_CQC_EVENT_LIMIT_SET</span><span class="p">(</span><span class="n">SCU_MAX_EVENTS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>

	<span class="n">writel</span><span class="p">(</span><span class="n">completion_queue_control_value</span><span class="p">,</span>
	       <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">smu_registers</span><span class="o">-&gt;</span><span class="n">completion_queue_control</span><span class="p">);</span>


	<span class="cm">/* Set the completion queue get pointer and enable the queue */</span>
	<span class="n">completion_queue_get_value</span> <span class="o">=</span> <span class="p">(</span>
		<span class="p">(</span><span class="n">SMU_CQGR_GEN_VAL</span><span class="p">(</span><span class="n">POINTER</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
		<span class="o">|</span> <span class="p">(</span><span class="n">SMU_CQGR_GEN_VAL</span><span class="p">(</span><span class="n">EVENT_POINTER</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
		<span class="o">|</span> <span class="p">(</span><span class="n">SMU_CQGR_GEN_BIT</span><span class="p">(</span><span class="n">ENABLE</span><span class="p">))</span>
		<span class="o">|</span> <span class="p">(</span><span class="n">SMU_CQGR_GEN_BIT</span><span class="p">(</span><span class="n">EVENT_ENABLE</span><span class="p">))</span>
		<span class="p">);</span>

	<span class="n">writel</span><span class="p">(</span><span class="n">completion_queue_get_value</span><span class="p">,</span>
	       <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">smu_registers</span><span class="o">-&gt;</span><span class="n">completion_queue_get</span><span class="p">);</span>

	<span class="cm">/* Set the completion queue put pointer */</span>
	<span class="n">completion_queue_put_value</span> <span class="o">=</span> <span class="p">(</span>
		<span class="p">(</span><span class="n">SMU_CQPR_GEN_VAL</span><span class="p">(</span><span class="n">POINTER</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
		<span class="o">|</span> <span class="p">(</span><span class="n">SMU_CQPR_GEN_VAL</span><span class="p">(</span><span class="n">EVENT_POINTER</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
		<span class="p">);</span>

	<span class="n">writel</span><span class="p">(</span><span class="n">completion_queue_put_value</span><span class="p">,</span>
	       <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">smu_registers</span><span class="o">-&gt;</span><span class="n">completion_queue_put</span><span class="p">);</span>

	<span class="cm">/* Initialize the cycle bit of the completion queue entries */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">SCU_MAX_COMPLETION_QUEUE_ENTRIES</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If get.cycle_bit != completion_queue.cycle_bit</span>
<span class="cm">		 * its not a valid completion queue entry</span>
<span class="cm">		 * so at system start all entries are invalid */</span>
		<span class="n">ihost</span><span class="o">-&gt;</span><span class="n">completion_queue</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x80000000</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sci_controller_initialize_unsolicited_frame_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">frame_queue_control_value</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">frame_queue_get_value</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">frame_queue_put_value</span><span class="p">;</span>

	<span class="cm">/* Write the queue size */</span>
	<span class="n">frame_queue_control_value</span> <span class="o">=</span>
		<span class="n">SCU_UFQC_GEN_VAL</span><span class="p">(</span><span class="n">QUEUE_SIZE</span><span class="p">,</span> <span class="n">SCU_MAX_UNSOLICITED_FRAMES</span><span class="p">);</span>

	<span class="n">writel</span><span class="p">(</span><span class="n">frame_queue_control_value</span><span class="p">,</span>
	       <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">scu_registers</span><span class="o">-&gt;</span><span class="n">sdma</span><span class="p">.</span><span class="n">unsolicited_frame_queue_control</span><span class="p">);</span>

	<span class="cm">/* Setup the get pointer for the unsolicited frame queue */</span>
	<span class="n">frame_queue_get_value</span> <span class="o">=</span> <span class="p">(</span>
		<span class="n">SCU_UFQGP_GEN_VAL</span><span class="p">(</span><span class="n">POINTER</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
		<span class="o">|</span>  <span class="n">SCU_UFQGP_GEN_BIT</span><span class="p">(</span><span class="n">ENABLE_BIT</span><span class="p">)</span>
		<span class="p">);</span>

	<span class="n">writel</span><span class="p">(</span><span class="n">frame_queue_get_value</span><span class="p">,</span>
	       <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">scu_registers</span><span class="o">-&gt;</span><span class="n">sdma</span><span class="p">.</span><span class="n">unsolicited_frame_get_pointer</span><span class="p">);</span>
	<span class="cm">/* Setup the put pointer for the unsolicited frame queue */</span>
	<span class="n">frame_queue_put_value</span> <span class="o">=</span> <span class="n">SCU_UFQPP_GEN_VAL</span><span class="p">(</span><span class="n">POINTER</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">frame_queue_put_value</span><span class="p">,</span>
	       <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">scu_registers</span><span class="o">-&gt;</span><span class="n">sdma</span><span class="p">.</span><span class="n">unsolicited_frame_put_pointer</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">sci_controller_transition_to_ready</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">,</span> <span class="k">enum</span> <span class="n">sci_status</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">sm</span><span class="p">.</span><span class="n">current_state_id</span> <span class="o">==</span> <span class="n">SCIC_STARTING</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We move into the ready state, because some of the phys/ports</span>
<span class="cm">		 * may be up and operational.</span>
<span class="cm">		 */</span>
		<span class="n">sci_change_state</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">sm</span><span class="p">,</span> <span class="n">SCIC_READY</span><span class="p">);</span>

		<span class="n">isci_host_start_complete</span><span class="p">(</span><span class="n">ihost</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">is_phy_starting</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_phy</span> <span class="o">*</span><span class="n">iphy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">sci_phy_states</span> <span class="n">state</span><span class="p">;</span>

	<span class="n">state</span> <span class="o">=</span> <span class="n">iphy</span><span class="o">-&gt;</span><span class="n">sm</span><span class="p">.</span><span class="n">current_state_id</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SCI_PHY_STARTING</span>:
	<span class="k">case</span> <span class="n">SCI_PHY_SUB_INITIAL</span>:
	<span class="k">case</span> <span class="n">SCI_PHY_SUB_AWAIT_SAS_SPEED_EN</span>:
	<span class="k">case</span> <span class="n">SCI_PHY_SUB_AWAIT_IAF_UF</span>:
	<span class="k">case</span> <span class="n">SCI_PHY_SUB_AWAIT_SAS_POWER</span>:
	<span class="k">case</span> <span class="n">SCI_PHY_SUB_AWAIT_SATA_POWER</span>:
	<span class="k">case</span> <span class="n">SCI_PHY_SUB_AWAIT_SATA_PHY_EN</span>:
	<span class="k">case</span> <span class="n">SCI_PHY_SUB_AWAIT_SATA_SPEED_EN</span>:
	<span class="k">case</span> <span class="n">SCI_PHY_SUB_AWAIT_OSSP_EN</span>:
	<span class="k">case</span> <span class="n">SCI_PHY_SUB_AWAIT_SIG_FIS_UF</span>:
	<span class="k">case</span> <span class="n">SCI_PHY_SUB_FINAL</span>:
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="n">bool</span> <span class="nf">is_controller_start_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SCI_MAX_PHYS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">isci_phy</span> <span class="o">*</span><span class="n">iphy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">u32</span> <span class="n">state</span> <span class="o">=</span> <span class="n">iphy</span><span class="o">-&gt;</span><span class="n">sm</span><span class="p">.</span><span class="n">current_state_id</span><span class="p">;</span>

		<span class="cm">/* in apc mode we need to check every phy, in</span>
<span class="cm">		 * mpc mode we only need to check phys that have</span>
<span class="cm">		 * been configured into a port</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_port_config_apc</span><span class="p">(</span><span class="n">ihost</span><span class="p">))</span>
			<span class="cm">/* pass */</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phy_get_non_dummy_port</span><span class="p">(</span><span class="n">iphy</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* The controller start operation is complete iff:</span>
<span class="cm">		 * - all links have been given an opportunity to start</span>
<span class="cm">		 * - have no indication of a connected device</span>
<span class="cm">		 * - have an indication of a connected device and it has</span>
<span class="cm">		 *   finished the link training process.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">iphy</span><span class="o">-&gt;</span><span class="n">is_in_link_training</span> <span class="o">==</span> <span class="nb">false</span> <span class="o">&amp;&amp;</span> <span class="n">state</span> <span class="o">==</span> <span class="n">SCI_PHY_INITIAL</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">iphy</span><span class="o">-&gt;</span><span class="n">is_in_link_training</span> <span class="o">==</span> <span class="nb">false</span> <span class="o">&amp;&amp;</span> <span class="n">state</span> <span class="o">==</span> <span class="n">SCI_PHY_STOPPED</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">iphy</span><span class="o">-&gt;</span><span class="n">is_in_link_training</span> <span class="o">==</span> <span class="nb">true</span> <span class="o">&amp;&amp;</span> <span class="n">is_phy_starting</span><span class="p">(</span><span class="n">iphy</span><span class="p">))</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">port_agent</span><span class="p">.</span><span class="n">phy_ready_mask</span> <span class="o">!=</span> <span class="n">ihost</span><span class="o">-&gt;</span><span class="n">port_agent</span><span class="p">.</span><span class="n">phy_configured_mask</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sci_controller_start_next_phy - start phy</span>
<span class="cm"> * @scic: controller</span>
<span class="cm"> *</span>
<span class="cm"> * If all the phys have been started, then attempt to transition the</span>
<span class="cm"> * controller to the READY state and inform the user</span>
<span class="cm"> * (sci_cb_controller_start_complete()).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">enum</span> <span class="n">sci_status</span> <span class="nf">sci_controller_start_next_phy</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sci_oem_params</span> <span class="o">*</span><span class="n">oem</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">oem_parameters</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">isci_phy</span> <span class="o">*</span><span class="n">iphy</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">sci_status</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">SCI_SUCCESS</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">phy_startup_timer_pending</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">status</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">next_phy_to_start</span> <span class="o">&gt;=</span> <span class="n">SCI_MAX_PHYS</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_controller_start_complete</span><span class="p">(</span><span class="n">ihost</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">sci_controller_transition_to_ready</span><span class="p">(</span><span class="n">ihost</span><span class="p">,</span> <span class="n">SCI_SUCCESS</span><span class="p">);</span>
			<span class="n">sci_del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">phy_timer</span><span class="p">);</span>
			<span class="n">ihost</span><span class="o">-&gt;</span><span class="n">phy_startup_timer_pending</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">iphy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">[</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">next_phy_to_start</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">oem</span><span class="o">-&gt;</span><span class="n">controller</span><span class="p">.</span><span class="n">mode_type</span> <span class="o">==</span> <span class="n">SCIC_PORT_MANUAL_CONFIGURATION_MODE</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">phy_get_non_dummy_port</span><span class="p">(</span><span class="n">iphy</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ihost</span><span class="o">-&gt;</span><span class="n">next_phy_to_start</span><span class="o">++</span><span class="p">;</span>

				<span class="cm">/* Caution recursion ahead be forwarned</span>
<span class="cm">				 *</span>
<span class="cm">				 * The PHY was never added to a PORT in MPC mode</span>
<span class="cm">				 * so start the next phy in sequence This phy</span>
<span class="cm">				 * will never go link up and will not draw power</span>
<span class="cm">				 * the OEM parameters either configured the phy</span>
<span class="cm">				 * incorrectly for the PORT or it was never</span>
<span class="cm">				 * assigned to a PORT</span>
<span class="cm">				 */</span>
				<span class="k">return</span> <span class="n">sci_controller_start_next_phy</span><span class="p">(</span><span class="n">ihost</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">status</span> <span class="o">=</span> <span class="n">sci_phy_start</span><span class="p">(</span><span class="n">iphy</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">SCI_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sci_mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">phy_timer</span><span class="p">,</span>
				      <span class="n">SCIC_SDS_CONTROLLER_PHY_START_TIMEOUT</span><span class="p">);</span>
			<span class="n">ihost</span><span class="o">-&gt;</span><span class="n">phy_startup_timer_pending</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				 <span class="s">&quot;%s: Controller stop operation failed &quot;</span>
				 <span class="s">&quot;to stop phy %d because of status &quot;</span>
				 <span class="s">&quot;%d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">__func__</span><span class="p">,</span>
				 <span class="n">ihost</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">[</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">next_phy_to_start</span><span class="p">].</span><span class="n">phy_index</span><span class="p">,</span>
				 <span class="n">status</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">ihost</span><span class="o">-&gt;</span><span class="n">next_phy_to_start</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">phy_startup_timeout</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sci_timer</span> <span class="o">*</span><span class="n">tmr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sci_timer</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">tmr</span><span class="p">,</span> <span class="n">typeof</span><span class="p">(</span><span class="o">*</span><span class="n">ihost</span><span class="p">),</span> <span class="n">phy_timer</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">sci_status</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">scic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tmr</span><span class="o">-&gt;</span><span class="n">cancel</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="n">ihost</span><span class="o">-&gt;</span><span class="n">phy_startup_timer_pending</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">sci_controller_start_next_phy</span><span class="p">(</span><span class="n">ihost</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">SCI_SUCCESS</span><span class="p">);</span>

<span class="nl">done:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">scic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u16</span> <span class="nf">isci_tci_active</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">CIRC_CNT</span><span class="p">(</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">tci_head</span><span class="p">,</span> <span class="n">ihost</span><span class="o">-&gt;</span><span class="n">tci_tail</span><span class="p">,</span> <span class="n">SCI_MAX_IO_REQUESTS</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">enum</span> <span class="n">sci_status</span> <span class="nf">sci_controller_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">,</span>
					     <span class="n">u32</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">sci_status</span> <span class="n">result</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">index</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">sm</span><span class="p">.</span><span class="n">current_state_id</span> <span class="o">!=</span> <span class="n">SCIC_INITIALIZED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s invalid state: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">__func__</span><span class="p">,</span> <span class="n">ihost</span><span class="o">-&gt;</span><span class="n">sm</span><span class="p">.</span><span class="n">current_state_id</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">SCI_FAILURE_INVALID_STATE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Build the TCi free pool */</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">SCI_MAX_IO_REQUESTS</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">tci_pool</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">ihost</span><span class="o">-&gt;</span><span class="n">tci_head</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ihost</span><span class="o">-&gt;</span><span class="n">tci_tail</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">ihost</span><span class="o">-&gt;</span><span class="n">task_context_entries</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span>
		<span class="n">isci_tci_free</span><span class="p">(</span><span class="n">ihost</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>

	<span class="cm">/* Build the RNi free pool */</span>
	<span class="n">sci_remote_node_table_initialize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">available_remote_nodes</span><span class="p">,</span>
					 <span class="n">ihost</span><span class="o">-&gt;</span><span class="n">remote_node_entries</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Before anything else lets make sure we will not be</span>
<span class="cm">	 * interrupted by the hardware.</span>
<span class="cm">	 */</span>
	<span class="n">sci_controller_disable_interrupts</span><span class="p">(</span><span class="n">ihost</span><span class="p">);</span>

	<span class="cm">/* Enable the port task scheduler */</span>
	<span class="n">sci_controller_enable_port_task_scheduler</span><span class="p">(</span><span class="n">ihost</span><span class="p">);</span>

	<span class="cm">/* Assign all the task entries to ihost physical function */</span>
	<span class="n">sci_controller_assign_task_entries</span><span class="p">(</span><span class="n">ihost</span><span class="p">);</span>

	<span class="cm">/* Now initialize the completion queue */</span>
	<span class="n">sci_controller_initialize_completion_queue</span><span class="p">(</span><span class="n">ihost</span><span class="p">);</span>

	<span class="cm">/* Initialize the unsolicited frame queue for use */</span>
	<span class="n">sci_controller_initialize_unsolicited_frame_queue</span><span class="p">(</span><span class="n">ihost</span><span class="p">);</span>

	<span class="cm">/* Start all of the ports on this controller */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">ihost</span><span class="o">-&gt;</span><span class="n">logical_port_entries</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">iport</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">ports</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>

		<span class="n">result</span> <span class="o">=</span> <span class="n">sci_port_start</span><span class="p">(</span><span class="n">iport</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sci_controller_start_next_phy</span><span class="p">(</span><span class="n">ihost</span><span class="p">);</span>

	<span class="n">sci_mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>

	<span class="n">sci_change_state</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">sm</span><span class="p">,</span> <span class="n">SCIC_STARTING</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">SCI_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">isci_host_scan_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span> <span class="o">=</span> <span class="n">SHOST_TO_SAS_HA</span><span class="p">(</span><span class="n">shost</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">lldd_ha</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tmo</span> <span class="o">=</span> <span class="n">sci_controller_get_suggested_start_timeout</span><span class="p">(</span><span class="n">ihost</span><span class="p">);</span>

	<span class="n">set_bit</span><span class="p">(</span><span class="n">IHOST_START_PENDING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">scic_lock</span><span class="p">);</span>
	<span class="n">sci_controller_start</span><span class="p">(</span><span class="n">ihost</span><span class="p">,</span> <span class="n">tmo</span><span class="p">);</span>
	<span class="n">sci_controller_enable_interrupts</span><span class="p">(</span><span class="n">ihost</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">scic_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">isci_host_stop_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sci_controller_disable_interrupts</span><span class="p">(</span><span class="n">ihost</span><span class="p">);</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">IHOST_STOP_PENDING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">eventq</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sci_controller_completion_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Empty out the completion queue */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sci_controller_completion_queue_has_entries</span><span class="p">(</span><span class="n">ihost</span><span class="p">))</span>
		<span class="n">sci_controller_process_completions</span><span class="p">(</span><span class="n">ihost</span><span class="p">);</span>

	<span class="cm">/* Clear the interrupt and enable all interrupts again */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">SMU_ISR_COMPLETION</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">smu_registers</span><span class="o">-&gt;</span><span class="n">interrupt_status</span><span class="p">);</span>
	<span class="cm">/* Could we write the value of SMU_ISR_COMPLETION? */</span>
	<span class="n">writel</span><span class="p">(</span><span class="mh">0xFF000000</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">smu_registers</span><span class="o">-&gt;</span><span class="n">interrupt_mask</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">smu_registers</span><span class="o">-&gt;</span><span class="n">interrupt_mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ireq_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">,</span> <span class="k">struct</span> <span class="n">isci_request</span> <span class="o">*</span><span class="n">ireq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sas_task</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">task</span><span class="o">-&gt;</span><span class="n">lldd_task</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">IREQ_ABORT_PATH_ACTIVE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ireq</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">task_state_flags</span> <span class="o">&amp;</span> <span class="n">SAS_TASK_STATE_ABORTED</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">IREQ_COMPLETE_IN_TARGET</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ireq</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Normal notification (task_done) */</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;%s: Normal - ireq/task = %p/%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">ireq</span><span class="p">,</span> <span class="n">task</span><span class="p">);</span>

			<span class="n">task</span><span class="o">-&gt;</span><span class="n">task_done</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;%s: Error - ireq/task = %p/%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">ireq</span><span class="p">,</span> <span class="n">task</span><span class="p">);</span>

			<span class="n">sas_task_abort</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">IREQ_ABORT_PATH_ACTIVE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ireq</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="n">wake_up_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">eventq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">IREQ_NO_AUTO_FREE_TAG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ireq</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="n">isci_free_tag</span><span class="p">(</span><span class="n">ihost</span><span class="p">,</span> <span class="n">ireq</span><span class="o">-&gt;</span><span class="n">io_tag</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/**</span>
<span class="cm"> * isci_host_completion_routine() - This function is the delayed service</span>
<span class="cm"> *    routine that calls the sci core library&#39;s completion handler. It&#39;s</span>
<span class="cm"> *    scheduled as a tasklet from the interrupt service routine when interrupts</span>
<span class="cm"> *    in use, or set as the timeout function in polled mode.</span>
<span class="cm"> * @data: This parameter specifies the ISCI host object</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">isci_host_completion_routine</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">active</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">scic_lock</span><span class="p">);</span>
	<span class="n">sci_controller_completion_handler</span><span class="p">(</span><span class="n">ihost</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">scic_lock</span><span class="p">);</span>

	<span class="cm">/* the coalesence timeout doubles at each encoding step, so</span>
<span class="cm">	 * update it based on the ilog2 value of the outstanding requests</span>
<span class="cm">	 */</span>
	<span class="n">active</span> <span class="o">=</span> <span class="n">isci_tci_active</span><span class="p">(</span><span class="n">ihost</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">SMU_ICC_GEN_VAL</span><span class="p">(</span><span class="n">NUMBER</span><span class="p">,</span> <span class="n">active</span><span class="p">)</span> <span class="o">|</span>
	       <span class="n">SMU_ICC_GEN_VAL</span><span class="p">(</span><span class="n">TIMER</span><span class="p">,</span> <span class="n">ISCI_COALESCE_BASE</span> <span class="o">+</span> <span class="n">ilog2</span><span class="p">(</span><span class="n">active</span><span class="p">)),</span>
	       <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">smu_registers</span><span class="o">-&gt;</span><span class="n">interrupt_coalesce_control</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sci_controller_stop() - This method will stop an individual controller</span>
<span class="cm"> *    object.This method will invoke the associated user callback upon</span>
<span class="cm"> *    completion.  The completion callback is called when the following</span>
<span class="cm"> *    conditions are met: -# the method return status is SCI_SUCCESS. -# the</span>
<span class="cm"> *    controller has been quiesced. This method will ensure that all IO</span>
<span class="cm"> *    requests are quiesced, phys are stopped, and all additional operation by</span>
<span class="cm"> *    the hardware is halted.</span>
<span class="cm"> * @controller: the handle to the controller object to stop.</span>
<span class="cm"> * @timeout: This parameter specifies the number of milliseconds in which the</span>
<span class="cm"> *    stop operation should complete.</span>
<span class="cm"> *</span>
<span class="cm"> * The controller must be in the STARTED or STOPPED state. Indicate if the</span>
<span class="cm"> * controller stop method succeeded or failed in some way. SCI_SUCCESS if the</span>
<span class="cm"> * stop operation successfully began. SCI_WARNING_ALREADY_IN_STATE if the</span>
<span class="cm"> * controller is already in the STOPPED state. SCI_FAILURE_INVALID_STATE if the</span>
<span class="cm"> * controller is not either in the STARTED or STOPPED states.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">enum</span> <span class="n">sci_status</span> <span class="nf">sci_controller_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">,</span> <span class="n">u32</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">sm</span><span class="p">.</span><span class="n">current_state_id</span> <span class="o">!=</span> <span class="n">SCIC_READY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s invalid state: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">__func__</span><span class="p">,</span> <span class="n">ihost</span><span class="o">-&gt;</span><span class="n">sm</span><span class="p">.</span><span class="n">current_state_id</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">SCI_FAILURE_INVALID_STATE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sci_mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>
	<span class="n">sci_change_state</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">sm</span><span class="p">,</span> <span class="n">SCIC_STOPPING</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">SCI_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sci_controller_reset() - This method will reset the supplied core</span>
<span class="cm"> *    controller regardless of the state of said controller.  This operation is</span>
<span class="cm"> *    considered destructive.  In other words, all current operations are wiped</span>
<span class="cm"> *    out.  No IO completions for outstanding devices occur.  Outstanding IO</span>
<span class="cm"> *    requests are not aborted or completed at the actual remote device.</span>
<span class="cm"> * @controller: the handle to the controller object to reset.</span>
<span class="cm"> *</span>
<span class="cm"> * Indicate if the controller reset method succeeded or failed in some way.</span>
<span class="cm"> * SCI_SUCCESS if the reset operation successfully started. SCI_FATAL_ERROR if</span>
<span class="cm"> * the controller reset operation is unable to complete.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">enum</span> <span class="n">sci_status</span> <span class="nf">sci_controller_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">sm</span><span class="p">.</span><span class="n">current_state_id</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SCIC_RESET</span>:
	<span class="k">case</span> <span class="n">SCIC_READY</span>:
	<span class="k">case</span> <span class="n">SCIC_STOPPING</span>:
	<span class="k">case</span> <span class="n">SCIC_FAILED</span>:
		<span class="cm">/*</span>
<span class="cm">		 * The reset operation is not a graceful cleanup, just</span>
<span class="cm">		 * perform the state transition.</span>
<span class="cm">		 */</span>
		<span class="n">sci_change_state</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">sm</span><span class="p">,</span> <span class="n">SCIC_RESETTING</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">SCI_SUCCESS</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s invalid state: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">__func__</span><span class="p">,</span> <span class="n">ihost</span><span class="o">-&gt;</span><span class="n">sm</span><span class="p">.</span><span class="n">current_state_id</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">SCI_FAILURE_INVALID_STATE</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">enum</span> <span class="n">sci_status</span> <span class="nf">sci_controller_stop_phys</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">index</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">sci_status</span> <span class="n">status</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">sci_status</span> <span class="n">phy_status</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">SCI_SUCCESS</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">SCI_MAX_PHYS</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">phy_status</span> <span class="o">=</span> <span class="n">sci_phy_stop</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">[</span><span class="n">index</span><span class="p">]);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">phy_status</span> <span class="o">!=</span> <span class="n">SCI_SUCCESS</span> <span class="o">&amp;&amp;</span>
		    <span class="n">phy_status</span> <span class="o">!=</span> <span class="n">SCI_FAILURE_INVALID_STATE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">SCI_FAILURE</span><span class="p">;</span>

			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				 <span class="s">&quot;%s: Controller stop operation failed to stop &quot;</span>
				 <span class="s">&quot;phy %d because of status %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">__func__</span><span class="p">,</span>
				 <span class="n">ihost</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">phy_index</span><span class="p">,</span> <span class="n">phy_status</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * isci_host_deinit - shutdown frame reception and dma</span>
<span class="cm"> * @ihost: host to take down</span>
<span class="cm"> *</span>
<span class="cm"> * This is called in either the driver shutdown or the suspend path.  In</span>
<span class="cm"> * the shutdown case libsas went through port teardown and normal device</span>
<span class="cm"> * removal (i.e. physical links stayed up to service scsi_device removal</span>
<span class="cm"> * commands).  In the suspend case we disable the hardware without</span>
<span class="cm"> * notifying libsas of the link down events since we want libsas to</span>
<span class="cm"> * remember the domain across the suspend/resume cycle</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">isci_host_deinit</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* disable output data selects */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">isci_gpio_count</span><span class="p">(</span><span class="n">ihost</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">SGPIO_HW_CONTROL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">scu_registers</span><span class="o">-&gt;</span><span class="n">peg0</span><span class="p">.</span><span class="n">sgpio</span><span class="p">.</span><span class="n">output_data_select</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="n">set_bit</span><span class="p">(</span><span class="n">IHOST_STOP_PENDING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">scic_lock</span><span class="p">);</span>
	<span class="n">sci_controller_stop</span><span class="p">(</span><span class="n">ihost</span><span class="p">,</span> <span class="n">SCIC_CONTROLLER_STOP_TIMEOUT</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">scic_lock</span><span class="p">);</span>

	<span class="n">wait_for_stop</span><span class="p">(</span><span class="n">ihost</span><span class="p">);</span>

	<span class="cm">/* phy stop is after controller stop to allow port and device to</span>
<span class="cm">	 * go idle before shutting down the phys, but the expectation is</span>
<span class="cm">	 * that i/o has been shut off well before we reach this</span>
<span class="cm">	 * function.</span>
<span class="cm">	 */</span>
	<span class="n">sci_controller_stop_phys</span><span class="p">(</span><span class="n">ihost</span><span class="p">);</span>

	<span class="cm">/* disable sgpio: where the above wait should give time for the</span>
<span class="cm">	 * enclosure to sample the gpios going inactive</span>
<span class="cm">	 */</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">scu_registers</span><span class="o">-&gt;</span><span class="n">peg0</span><span class="p">.</span><span class="n">sgpio</span><span class="p">.</span><span class="n">interface_control</span><span class="p">);</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">scic_lock</span><span class="p">);</span>
	<span class="n">sci_controller_reset</span><span class="p">(</span><span class="n">ihost</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">scic_lock</span><span class="p">);</span>

	<span class="cm">/* Cancel any/all outstanding port timers */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ihost</span><span class="o">-&gt;</span><span class="n">logical_port_entries</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">iport</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">ports</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iport</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">.</span><span class="n">timer</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Cancel any/all outstanding phy timers */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SCI_MAX_PHYS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">isci_phy</span> <span class="o">*</span><span class="n">iphy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iphy</span><span class="o">-&gt;</span><span class="n">sata_timer</span><span class="p">.</span><span class="n">timer</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">port_agent</span><span class="p">.</span><span class="n">timer</span><span class="p">.</span><span class="n">timer</span><span class="p">);</span>

	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">power_control</span><span class="p">.</span><span class="n">timer</span><span class="p">.</span><span class="n">timer</span><span class="p">);</span>

	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">.</span><span class="n">timer</span><span class="p">);</span>

	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">phy_timer</span><span class="p">.</span><span class="n">timer</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="nf">scu_base</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">isci_host</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">isci_host</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="n">isci_host</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">pcim_iomap_table</span><span class="p">(</span><span class="n">pdev</span><span class="p">)[</span><span class="n">SCI_SCU_BAR</span> <span class="o">*</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">SCI_SCU_BAR_SIZE</span> <span class="o">*</span> <span class="n">id</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="nf">smu_base</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">isci_host</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">isci_host</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="n">isci_host</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">pcim_iomap_table</span><span class="p">(</span><span class="n">pdev</span><span class="p">)[</span><span class="n">SCI_SMU_BAR</span> <span class="o">*</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">SCI_SMU_BAR_SIZE</span> <span class="o">*</span> <span class="n">id</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sci_controller_initial_state_enter</span><span class="p">(</span><span class="k">struct</span> <span class="n">sci_base_state_machine</span> <span class="o">*</span><span class="n">sm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">sm</span><span class="p">,</span> <span class="n">typeof</span><span class="p">(</span><span class="o">*</span><span class="n">ihost</span><span class="p">),</span> <span class="n">sm</span><span class="p">);</span>

	<span class="n">sci_change_state</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">sm</span><span class="p">,</span> <span class="n">SCIC_RESET</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sci_controller_starting_state_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sci_base_state_machine</span> <span class="o">*</span><span class="n">sm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">sm</span><span class="p">,</span> <span class="n">typeof</span><span class="p">(</span><span class="o">*</span><span class="n">ihost</span><span class="p">),</span> <span class="n">sm</span><span class="p">);</span>

	<span class="n">sci_del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define INTERRUPT_COALESCE_TIMEOUT_BASE_RANGE_LOWER_BOUND_NS 853</span>
<span class="cp">#define INTERRUPT_COALESCE_TIMEOUT_BASE_RANGE_UPPER_BOUND_NS 1280</span>
<span class="cp">#define INTERRUPT_COALESCE_TIMEOUT_MAX_US                    2700000</span>
<span class="cp">#define INTERRUPT_COALESCE_NUMBER_MAX                        256</span>
<span class="cp">#define INTERRUPT_COALESCE_TIMEOUT_ENCODE_MIN                7</span>
<span class="cp">#define INTERRUPT_COALESCE_TIMEOUT_ENCODE_MAX                28</span>

<span class="cm">/**</span>
<span class="cm"> * sci_controller_set_interrupt_coalescence() - This method allows the user to</span>
<span class="cm"> *    configure the interrupt coalescence.</span>
<span class="cm"> * @controller: This parameter represents the handle to the controller object</span>
<span class="cm"> *    for which its interrupt coalesce register is overridden.</span>
<span class="cm"> * @coalesce_number: Used to control the number of entries in the Completion</span>
<span class="cm"> *    Queue before an interrupt is generated. If the number of entries exceed</span>
<span class="cm"> *    this number, an interrupt will be generated. The valid range of the input</span>
<span class="cm"> *    is [0, 256]. A setting of 0 results in coalescing being disabled.</span>
<span class="cm"> * @coalesce_timeout: Timeout value in microseconds. The valid range of the</span>
<span class="cm"> *    input is [0, 2700000] . A setting of 0 is allowed and results in no</span>
<span class="cm"> *    interrupt coalescing timeout.</span>
<span class="cm"> *</span>
<span class="cm"> * Indicate if the user successfully set the interrupt coalesce parameters.</span>
<span class="cm"> * SCI_SUCCESS The user successfully updated the interrutp coalescence.</span>
<span class="cm"> * SCI_FAILURE_INVALID_PARAMETER_VALUE The user input value is out of range.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">enum</span> <span class="n">sci_status</span>
<span class="nf">sci_controller_set_interrupt_coalescence</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">,</span>
					 <span class="n">u32</span> <span class="n">coalesce_number</span><span class="p">,</span>
					 <span class="n">u32</span> <span class="n">coalesce_timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">timeout_encode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">min</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Check if the input parameters fall in the range. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">coalesce_number</span> <span class="o">&gt;</span> <span class="n">INTERRUPT_COALESCE_NUMBER_MAX</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">SCI_FAILURE_INVALID_PARAMETER_VALUE</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Defined encoding for interrupt coalescing timeout:</span>
<span class="cm">	 *              Value   Min      Max     Units</span>
<span class="cm">	 *              -----   ---      ---     -----</span>
<span class="cm">	 *              0       -        -       Disabled</span>
<span class="cm">	 *              1       13.3     20.0    ns</span>
<span class="cm">	 *              2       26.7     40.0</span>
<span class="cm">	 *              3       53.3     80.0</span>
<span class="cm">	 *              4       106.7    160.0</span>
<span class="cm">	 *              5       213.3    320.0</span>
<span class="cm">	 *              6       426.7    640.0</span>
<span class="cm">	 *              7       853.3    1280.0</span>
<span class="cm">	 *              8       1.7      2.6     us</span>
<span class="cm">	 *              9       3.4      5.1</span>
<span class="cm">	 *              10      6.8      10.2</span>
<span class="cm">	 *              11      13.7     20.5</span>
<span class="cm">	 *              12      27.3     41.0</span>
<span class="cm">	 *              13      54.6     81.9</span>
<span class="cm">	 *              14      109.2    163.8</span>
<span class="cm">	 *              15      218.5    327.7</span>
<span class="cm">	 *              16      436.9    655.4</span>
<span class="cm">	 *              17      873.8    1310.7</span>
<span class="cm">	 *              18      1.7      2.6     ms</span>
<span class="cm">	 *              19      3.5      5.2</span>
<span class="cm">	 *              20      7.0      10.5</span>
<span class="cm">	 *              21      14.0     21.0</span>
<span class="cm">	 *              22      28.0     41.9</span>
<span class="cm">	 *              23      55.9     83.9</span>
<span class="cm">	 *              24      111.8    167.8</span>
<span class="cm">	 *              25      223.7    335.5</span>
<span class="cm">	 *              26      447.4    671.1</span>
<span class="cm">	 *              27      894.8    1342.2</span>
<span class="cm">	 *              28      1.8      2.7     s</span>
<span class="cm">	 *              Others Undefined */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Use the table above to decide the encode of interrupt coalescing timeout</span>
<span class="cm">	 * value for register writing. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">coalesce_timeout</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">timeout_encode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span><span class="p">{</span>
		<span class="cm">/* make the timeout value in unit of (10 ns). */</span>
		<span class="n">coalesce_timeout</span> <span class="o">=</span> <span class="n">coalesce_timeout</span> <span class="o">*</span> <span class="mi">100</span><span class="p">;</span>
		<span class="n">min</span> <span class="o">=</span> <span class="n">INTERRUPT_COALESCE_TIMEOUT_BASE_RANGE_LOWER_BOUND_NS</span> <span class="o">/</span> <span class="mi">10</span><span class="p">;</span>
		<span class="n">max</span> <span class="o">=</span> <span class="n">INTERRUPT_COALESCE_TIMEOUT_BASE_RANGE_UPPER_BOUND_NS</span> <span class="o">/</span> <span class="mi">10</span><span class="p">;</span>

		<span class="cm">/* get the encode of timeout for register writing. */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">timeout_encode</span> <span class="o">=</span> <span class="n">INTERRUPT_COALESCE_TIMEOUT_ENCODE_MIN</span><span class="p">;</span>
		      <span class="n">timeout_encode</span> <span class="o">&lt;=</span> <span class="n">INTERRUPT_COALESCE_TIMEOUT_ENCODE_MAX</span><span class="p">;</span>
		      <span class="n">timeout_encode</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">min</span> <span class="o">&lt;=</span> <span class="n">coalesce_timeout</span> <span class="o">&amp;&amp;</span>  <span class="n">max</span> <span class="o">&gt;</span> <span class="n">coalesce_timeout</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">coalesce_timeout</span> <span class="o">&gt;=</span> <span class="n">max</span> <span class="o">&amp;&amp;</span> <span class="n">coalesce_timeout</span> <span class="o">&lt;</span> <span class="n">min</span> <span class="o">*</span> <span class="mi">2</span>
				 <span class="o">&amp;&amp;</span> <span class="n">coalesce_timeout</span> <span class="o">&lt;=</span> <span class="n">INTERRUPT_COALESCE_TIMEOUT_MAX_US</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">coalesce_timeout</span> <span class="o">-</span> <span class="n">max</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">min</span> <span class="o">-</span> <span class="n">coalesce_timeout</span><span class="p">))</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="k">else</span><span class="p">{</span>
					<span class="n">timeout_encode</span><span class="o">++</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">max</span> <span class="o">=</span> <span class="n">max</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
				<span class="n">min</span> <span class="o">=</span> <span class="n">min</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">timeout_encode</span> <span class="o">==</span> <span class="n">INTERRUPT_COALESCE_TIMEOUT_ENCODE_MAX</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
			<span class="cm">/* the value is out of range. */</span>
			<span class="k">return</span> <span class="n">SCI_FAILURE_INVALID_PARAMETER_VALUE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">writel</span><span class="p">(</span><span class="n">SMU_ICC_GEN_VAL</span><span class="p">(</span><span class="n">NUMBER</span><span class="p">,</span> <span class="n">coalesce_number</span><span class="p">)</span> <span class="o">|</span>
	       <span class="n">SMU_ICC_GEN_VAL</span><span class="p">(</span><span class="n">TIMER</span><span class="p">,</span> <span class="n">timeout_encode</span><span class="p">),</span>
	       <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">smu_registers</span><span class="o">-&gt;</span><span class="n">interrupt_coalesce_control</span><span class="p">);</span>


	<span class="n">ihost</span><span class="o">-&gt;</span><span class="n">interrupt_coalesce_number</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span><span class="n">coalesce_number</span><span class="p">;</span>
	<span class="n">ihost</span><span class="o">-&gt;</span><span class="n">interrupt_coalesce_timeout</span> <span class="o">=</span> <span class="n">coalesce_timeout</span> <span class="o">/</span> <span class="mi">100</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">SCI_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">sci_controller_ready_state_enter</span><span class="p">(</span><span class="k">struct</span> <span class="n">sci_base_state_machine</span> <span class="o">*</span><span class="n">sm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">sm</span><span class="p">,</span> <span class="n">typeof</span><span class="p">(</span><span class="o">*</span><span class="n">ihost</span><span class="p">),</span> <span class="n">sm</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">val</span><span class="p">;</span>

	<span class="cm">/* enable clock gating for power control of the scu unit */</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">smu_registers</span><span class="o">-&gt;</span><span class="n">clock_gating_control</span><span class="p">);</span>
	<span class="n">val</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">SMU_CGUCR_GEN_BIT</span><span class="p">(</span><span class="n">REGCLK_ENABLE</span><span class="p">)</span> <span class="o">|</span>
		 <span class="n">SMU_CGUCR_GEN_BIT</span><span class="p">(</span><span class="n">TXCLK_ENABLE</span><span class="p">)</span> <span class="o">|</span>
		 <span class="n">SMU_CGUCR_GEN_BIT</span><span class="p">(</span><span class="n">XCLK_ENABLE</span><span class="p">));</span>
	<span class="n">val</span> <span class="o">|=</span> <span class="n">SMU_CGUCR_GEN_BIT</span><span class="p">(</span><span class="n">IDLE_ENABLE</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">smu_registers</span><span class="o">-&gt;</span><span class="n">clock_gating_control</span><span class="p">);</span>

	<span class="cm">/* set the default interrupt coalescence number and timeout value. */</span>
	<span class="n">sci_controller_set_interrupt_coalescence</span><span class="p">(</span><span class="n">ihost</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sci_controller_ready_state_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sci_base_state_machine</span> <span class="o">*</span><span class="n">sm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">sm</span><span class="p">,</span> <span class="n">typeof</span><span class="p">(</span><span class="o">*</span><span class="n">ihost</span><span class="p">),</span> <span class="n">sm</span><span class="p">);</span>

	<span class="cm">/* disable interrupt coalescence. */</span>
	<span class="n">sci_controller_set_interrupt_coalescence</span><span class="p">(</span><span class="n">ihost</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">enum</span> <span class="n">sci_status</span> <span class="nf">sci_controller_stop_ports</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">index</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">sci_status</span> <span class="n">port_status</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">sci_status</span> <span class="n">status</span> <span class="o">=</span> <span class="n">SCI_SUCCESS</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">ihost</span><span class="o">-&gt;</span><span class="n">logical_port_entries</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">iport</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">ports</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>

		<span class="n">port_status</span> <span class="o">=</span> <span class="n">sci_port_stop</span><span class="p">(</span><span class="n">iport</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">port_status</span> <span class="o">!=</span> <span class="n">SCI_SUCCESS</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">port_status</span> <span class="o">!=</span> <span class="n">SCI_FAILURE_INVALID_STATE</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">SCI_FAILURE</span><span class="p">;</span>

			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				 <span class="s">&quot;%s: Controller stop operation failed to &quot;</span>
				 <span class="s">&quot;stop port %d because of status %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">__func__</span><span class="p">,</span>
				 <span class="n">iport</span><span class="o">-&gt;</span><span class="n">logical_port_index</span><span class="p">,</span>
				 <span class="n">port_status</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">enum</span> <span class="n">sci_status</span> <span class="nf">sci_controller_stop_devices</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">index</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">sci_status</span> <span class="n">status</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">sci_status</span> <span class="n">device_status</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">SCI_SUCCESS</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">ihost</span><span class="o">-&gt;</span><span class="n">remote_node_entries</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">device_table</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* / @todo What timeout value do we want to provide to this request? */</span>
			<span class="n">device_status</span> <span class="o">=</span> <span class="n">sci_remote_device_stop</span><span class="p">(</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">device_table</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">((</span><span class="n">device_status</span> <span class="o">!=</span> <span class="n">SCI_SUCCESS</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="n">device_status</span> <span class="o">!=</span> <span class="n">SCI_FAILURE_INVALID_STATE</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					 <span class="s">&quot;%s: Controller stop operation failed &quot;</span>
					 <span class="s">&quot;to stop device 0x%p because of &quot;</span>
					 <span class="s">&quot;status %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					 <span class="n">__func__</span><span class="p">,</span>
					 <span class="n">ihost</span><span class="o">-&gt;</span><span class="n">device_table</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">device_status</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sci_controller_stopping_state_enter</span><span class="p">(</span><span class="k">struct</span> <span class="n">sci_base_state_machine</span> <span class="o">*</span><span class="n">sm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">sm</span><span class="p">,</span> <span class="n">typeof</span><span class="p">(</span><span class="o">*</span><span class="n">ihost</span><span class="p">),</span> <span class="n">sm</span><span class="p">);</span>

	<span class="n">sci_controller_stop_devices</span><span class="p">(</span><span class="n">ihost</span><span class="p">);</span>
	<span class="n">sci_controller_stop_ports</span><span class="p">(</span><span class="n">ihost</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sci_controller_has_remote_devices_stopping</span><span class="p">(</span><span class="n">ihost</span><span class="p">))</span>
		<span class="n">isci_host_stop_complete</span><span class="p">(</span><span class="n">ihost</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sci_controller_stopping_state_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sci_base_state_machine</span> <span class="o">*</span><span class="n">sm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">sm</span><span class="p">,</span> <span class="n">typeof</span><span class="p">(</span><span class="o">*</span><span class="n">ihost</span><span class="p">),</span> <span class="n">sm</span><span class="p">);</span>

	<span class="n">sci_del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sci_controller_reset_hardware</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Disable interrupts so we dont take any spurious interrupts */</span>
	<span class="n">sci_controller_disable_interrupts</span><span class="p">(</span><span class="n">ihost</span><span class="p">);</span>

	<span class="cm">/* Reset the SCU */</span>
	<span class="n">writel</span><span class="p">(</span><span class="mh">0xFFFFFFFF</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">smu_registers</span><span class="o">-&gt;</span><span class="n">soft_reset_control</span><span class="p">);</span>

	<span class="cm">/* Delay for 1ms to before clearing the CQP and UFQPR. */</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>

	<span class="cm">/* The write to the CQGR clears the CQP */</span>
	<span class="n">writel</span><span class="p">(</span><span class="mh">0x00000000</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">smu_registers</span><span class="o">-&gt;</span><span class="n">completion_queue_get</span><span class="p">);</span>

	<span class="cm">/* The write to the UFQGP clears the UFQPR */</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">scu_registers</span><span class="o">-&gt;</span><span class="n">sdma</span><span class="p">.</span><span class="n">unsolicited_frame_get_pointer</span><span class="p">);</span>

	<span class="cm">/* clear all interrupts */</span>
	<span class="n">writel</span><span class="p">(</span><span class="o">~</span><span class="n">SMU_INTERRUPT_STATUS_RESERVED_MASK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">smu_registers</span><span class="o">-&gt;</span><span class="n">interrupt_status</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sci_controller_resetting_state_enter</span><span class="p">(</span><span class="k">struct</span> <span class="n">sci_base_state_machine</span> <span class="o">*</span><span class="n">sm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">sm</span><span class="p">,</span> <span class="n">typeof</span><span class="p">(</span><span class="o">*</span><span class="n">ihost</span><span class="p">),</span> <span class="n">sm</span><span class="p">);</span>

	<span class="n">sci_controller_reset_hardware</span><span class="p">(</span><span class="n">ihost</span><span class="p">);</span>
	<span class="n">sci_change_state</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">sm</span><span class="p">,</span> <span class="n">SCIC_RESET</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sci_base_state</span> <span class="n">sci_controller_state_table</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">SCIC_INITIAL</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">enter_state</span> <span class="o">=</span> <span class="n">sci_controller_initial_state_enter</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">[</span><span class="n">SCIC_RESET</span><span class="p">]</span> <span class="o">=</span> <span class="p">{},</span>
	<span class="p">[</span><span class="n">SCIC_INITIALIZING</span><span class="p">]</span> <span class="o">=</span> <span class="p">{},</span>
	<span class="p">[</span><span class="n">SCIC_INITIALIZED</span><span class="p">]</span> <span class="o">=</span> <span class="p">{},</span>
	<span class="p">[</span><span class="n">SCIC_STARTING</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">exit_state</span>  <span class="o">=</span> <span class="n">sci_controller_starting_state_exit</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">[</span><span class="n">SCIC_READY</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">enter_state</span> <span class="o">=</span> <span class="n">sci_controller_ready_state_enter</span><span class="p">,</span>
		<span class="p">.</span><span class="n">exit_state</span>  <span class="o">=</span> <span class="n">sci_controller_ready_state_exit</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">[</span><span class="n">SCIC_RESETTING</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">enter_state</span> <span class="o">=</span> <span class="n">sci_controller_resetting_state_enter</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">[</span><span class="n">SCIC_STOPPING</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">enter_state</span> <span class="o">=</span> <span class="n">sci_controller_stopping_state_enter</span><span class="p">,</span>
		<span class="p">.</span><span class="n">exit_state</span> <span class="o">=</span> <span class="n">sci_controller_stopping_state_exit</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">[</span><span class="n">SCIC_FAILED</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">controller_timeout</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sci_timer</span> <span class="o">*</span><span class="n">tmr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sci_timer</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">tmr</span><span class="p">,</span> <span class="n">typeof</span><span class="p">(</span><span class="o">*</span><span class="n">ihost</span><span class="p">),</span> <span class="n">timer</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sci_base_state_machine</span> <span class="o">*</span><span class="n">sm</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">sm</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">scic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tmr</span><span class="o">-&gt;</span><span class="n">cancel</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sm</span><span class="o">-&gt;</span><span class="n">current_state_id</span> <span class="o">==</span> <span class="n">SCIC_STARTING</span><span class="p">)</span>
		<span class="n">sci_controller_transition_to_ready</span><span class="p">(</span><span class="n">ihost</span><span class="p">,</span> <span class="n">SCI_FAILURE_TIMEOUT</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sm</span><span class="o">-&gt;</span><span class="n">current_state_id</span> <span class="o">==</span> <span class="n">SCIC_STOPPING</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sci_change_state</span><span class="p">(</span><span class="n">sm</span><span class="p">,</span> <span class="n">SCIC_FAILED</span><span class="p">);</span>
		<span class="n">isci_host_stop_complete</span><span class="p">(</span><span class="n">ihost</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>	<span class="cm">/* / @todo Now what do we want to do in this case? */</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;%s: Controller timer fired when controller was not &quot;</span>
			<span class="s">&quot;in a state being timed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">);</span>

<span class="nl">done:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">scic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">enum</span> <span class="n">sci_status</span> <span class="nf">sci_controller_construct</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">,</span>
						<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">scu_base</span><span class="p">,</span>
						<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">smu_base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">sci_init_sm</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">sm</span><span class="p">,</span> <span class="n">sci_controller_state_table</span><span class="p">,</span> <span class="n">SCIC_INITIAL</span><span class="p">);</span>

	<span class="n">ihost</span><span class="o">-&gt;</span><span class="n">scu_registers</span> <span class="o">=</span> <span class="n">scu_base</span><span class="p">;</span>
	<span class="n">ihost</span><span class="o">-&gt;</span><span class="n">smu_registers</span> <span class="o">=</span> <span class="n">smu_base</span><span class="p">;</span>

	<span class="n">sci_port_configuration_agent_construct</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">port_agent</span><span class="p">);</span>

	<span class="cm">/* Construct the ports for this controller */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SCI_MAX_PORTS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">sci_port_construct</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">ports</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="p">,</span> <span class="n">ihost</span><span class="p">);</span>
	<span class="n">sci_port_construct</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">ports</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">SCIC_SDS_DUMMY_PORT</span><span class="p">,</span> <span class="n">ihost</span><span class="p">);</span>

	<span class="cm">/* Construct the phys for this controller */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SCI_MAX_PHYS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Add all the PHYs to the dummy port */</span>
		<span class="n">sci_phy_construct</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
				  <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">ports</span><span class="p">[</span><span class="n">SCI_MAX_PORTS</span><span class="p">],</span> <span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ihost</span><span class="o">-&gt;</span><span class="n">invalid_phy_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">sci_init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">,</span> <span class="n">controller_timeout</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">sci_controller_reset</span><span class="p">(</span><span class="n">ihost</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">sci_oem_parameters_validate</span><span class="p">(</span><span class="k">struct</span> <span class="n">sci_oem_params</span> <span class="o">*</span><span class="n">oem</span><span class="p">,</span> <span class="n">u8</span> <span class="n">version</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SCI_MAX_PORTS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">oem</span><span class="o">-&gt;</span><span class="n">ports</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">phy_mask</span> <span class="o">&gt;</span> <span class="n">SCIC_SDS_PARM_PHY_MASK_MAX</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SCI_MAX_PHYS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">oem</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sas_address</span><span class="p">.</span><span class="n">high</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
		    <span class="n">oem</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sas_address</span><span class="p">.</span><span class="n">low</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">oem</span><span class="o">-&gt;</span><span class="n">controller</span><span class="p">.</span><span class="n">mode_type</span> <span class="o">==</span> <span class="n">SCIC_PORT_AUTOMATIC_CONFIGURATION_MODE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SCI_MAX_PHYS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">oem</span><span class="o">-&gt;</span><span class="n">ports</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">phy_mask</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">oem</span><span class="o">-&gt;</span><span class="n">controller</span><span class="p">.</span><span class="n">mode_type</span> <span class="o">==</span> <span class="n">SCIC_PORT_MANUAL_CONFIGURATION_MODE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u8</span> <span class="n">phy_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SCI_MAX_PHYS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">phy_mask</span> <span class="o">|=</span> <span class="n">oem</span><span class="o">-&gt;</span><span class="n">ports</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">phy_mask</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">phy_mask</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">oem</span><span class="o">-&gt;</span><span class="n">controller</span><span class="p">.</span><span class="n">max_concurr_spin_up</span> <span class="o">&gt;</span> <span class="n">MAX_CONCURRENT_DEVICE_SPIN_UP_COUNT</span> <span class="o">||</span>
	    <span class="n">oem</span><span class="o">-&gt;</span><span class="n">controller</span><span class="p">.</span><span class="n">max_concurr_spin_up</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">oem</span><span class="o">-&gt;</span><span class="n">controller</span><span class="p">.</span><span class="n">do_enable_ssc</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">version</span> <span class="o">&lt;</span> <span class="n">ISCI_ROM_VER_1_1</span> <span class="o">&amp;&amp;</span> <span class="n">oem</span><span class="o">-&gt;</span><span class="n">controller</span><span class="p">.</span><span class="n">do_enable_ssc</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">version</span> <span class="o">&gt;=</span> <span class="n">ISCI_ROM_VER_1_1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u8</span> <span class="n">test</span> <span class="o">=</span> <span class="n">oem</span><span class="o">-&gt;</span><span class="n">controller</span><span class="p">.</span><span class="n">ssc_sata_tx_spread_level</span><span class="p">;</span>

			<span class="k">switch</span> <span class="p">(</span><span class="n">test</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="mi">0</span>:
			<span class="k">case</span> <span class="mi">2</span>:
			<span class="k">case</span> <span class="mi">3</span>:
			<span class="k">case</span> <span class="mi">6</span>:
			<span class="k">case</span> <span class="mi">7</span>:
				<span class="k">break</span><span class="p">;</span>
			<span class="nl">default:</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">test</span> <span class="o">=</span> <span class="n">oem</span><span class="o">-&gt;</span><span class="n">controller</span><span class="p">.</span><span class="n">ssc_sas_tx_spread_level</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">oem</span><span class="o">-&gt;</span><span class="n">controller</span><span class="p">.</span><span class="n">ssc_sas_tx_type</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">switch</span> <span class="p">(</span><span class="n">test</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">case</span> <span class="mi">0</span>:
				<span class="k">case</span> <span class="mi">2</span>:
				<span class="k">case</span> <span class="mi">3</span>:
					<span class="k">break</span><span class="p">;</span>
				<span class="nl">default:</span>
					<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">oem</span><span class="o">-&gt;</span><span class="n">controller</span><span class="p">.</span><span class="n">ssc_sas_tx_type</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">switch</span> <span class="p">(</span><span class="n">test</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">case</span> <span class="mi">0</span>:
				<span class="k">case</span> <span class="mi">3</span>:
				<span class="k">case</span> <span class="mi">6</span>:
					<span class="k">break</span><span class="p">;</span>
				<span class="nl">default:</span>
					<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u8</span> <span class="nf">max_spin_up</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">user_parameters</span><span class="p">.</span><span class="n">max_concurr_spinup</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">min_t</span><span class="p">(</span><span class="n">u8</span><span class="p">,</span> <span class="n">ihost</span><span class="o">-&gt;</span><span class="n">user_parameters</span><span class="p">.</span><span class="n">max_concurr_spinup</span><span class="p">,</span>
			     <span class="n">MAX_CONCURRENT_DEVICE_SPIN_UP_COUNT</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">min_t</span><span class="p">(</span><span class="n">u8</span><span class="p">,</span> <span class="n">ihost</span><span class="o">-&gt;</span><span class="n">oem_parameters</span><span class="p">.</span><span class="n">controller</span><span class="p">.</span><span class="n">max_concurr_spin_up</span><span class="p">,</span>
			     <span class="n">MAX_CONCURRENT_DEVICE_SPIN_UP_COUNT</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">power_control_timeout</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sci_timer</span> <span class="o">*</span><span class="n">tmr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sci_timer</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">tmr</span><span class="p">,</span> <span class="n">typeof</span><span class="p">(</span><span class="o">*</span><span class="n">ihost</span><span class="p">),</span> <span class="n">power_control</span><span class="p">.</span><span class="n">timer</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">isci_phy</span> <span class="o">*</span><span class="n">iphy</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">scic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tmr</span><span class="o">-&gt;</span><span class="n">cancel</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="n">ihost</span><span class="o">-&gt;</span><span class="n">power_control</span><span class="p">.</span><span class="n">phys_granted_power</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">power_control</span><span class="p">.</span><span class="n">phys_waiting</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ihost</span><span class="o">-&gt;</span><span class="n">power_control</span><span class="p">.</span><span class="n">timer_started</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SCI_MAX_PHYS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">power_control</span><span class="p">.</span><span class="n">phys_waiting</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">iphy</span> <span class="o">=</span> <span class="n">ihost</span><span class="o">-&gt;</span><span class="n">power_control</span><span class="p">.</span><span class="n">requesters</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iphy</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">power_control</span><span class="p">.</span><span class="n">phys_granted_power</span> <span class="o">&gt;=</span> <span class="n">max_spin_up</span><span class="p">(</span><span class="n">ihost</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">ihost</span><span class="o">-&gt;</span><span class="n">power_control</span><span class="p">.</span><span class="n">requesters</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">ihost</span><span class="o">-&gt;</span><span class="n">power_control</span><span class="p">.</span><span class="n">phys_waiting</span><span class="o">--</span><span class="p">;</span>
		<span class="n">ihost</span><span class="o">-&gt;</span><span class="n">power_control</span><span class="p">.</span><span class="n">phys_granted_power</span><span class="o">++</span><span class="p">;</span>
		<span class="n">sci_phy_consume_power_handler</span><span class="p">(</span><span class="n">iphy</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">iphy</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">SAS_PROTOCOL_SSP</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u8</span> <span class="n">j</span><span class="p">;</span>

			<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">SCI_MAX_PHYS</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">struct</span> <span class="n">isci_phy</span> <span class="o">*</span><span class="n">requester</span> <span class="o">=</span> <span class="n">ihost</span><span class="o">-&gt;</span><span class="n">power_control</span><span class="p">.</span><span class="n">requesters</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>

				<span class="cm">/*</span>
<span class="cm">				 * Search the power_control queue to see if there are other phys</span>
<span class="cm">				 * attached to the same remote device. If found, take all of</span>
<span class="cm">				 * them out of await_sas_power state.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">requester</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">requester</span> <span class="o">!=</span> <span class="n">iphy</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">u8</span> <span class="n">other</span> <span class="o">=</span> <span class="n">memcmp</span><span class="p">(</span><span class="n">requester</span><span class="o">-&gt;</span><span class="n">frame_rcvd</span><span class="p">.</span><span class="n">iaf</span><span class="p">.</span><span class="n">sas_addr</span><span class="p">,</span>
							  <span class="n">iphy</span><span class="o">-&gt;</span><span class="n">frame_rcvd</span><span class="p">.</span><span class="n">iaf</span><span class="p">.</span><span class="n">sas_addr</span><span class="p">,</span>
							  <span class="k">sizeof</span><span class="p">(</span><span class="n">requester</span><span class="o">-&gt;</span><span class="n">frame_rcvd</span><span class="p">.</span><span class="n">iaf</span><span class="p">.</span><span class="n">sas_addr</span><span class="p">));</span>

					<span class="k">if</span> <span class="p">(</span><span class="n">other</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">ihost</span><span class="o">-&gt;</span><span class="n">power_control</span><span class="p">.</span><span class="n">requesters</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
						<span class="n">ihost</span><span class="o">-&gt;</span><span class="n">power_control</span><span class="p">.</span><span class="n">phys_waiting</span><span class="o">--</span><span class="p">;</span>
						<span class="n">sci_phy_consume_power_handler</span><span class="p">(</span><span class="n">requester</span><span class="p">);</span>
					<span class="p">}</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * It doesn&#39;t matter if the power list is empty, we need to start the</span>
<span class="cm">	 * timer in case another phy becomes ready.</span>
<span class="cm">	 */</span>
	<span class="n">sci_mod_timer</span><span class="p">(</span><span class="n">tmr</span><span class="p">,</span> <span class="n">SCIC_SDS_CONTROLLER_POWER_CONTROL_INTERVAL</span><span class="p">);</span>
	<span class="n">ihost</span><span class="o">-&gt;</span><span class="n">power_control</span><span class="p">.</span><span class="n">timer_started</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

<span class="nl">done:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">scic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">sci_controller_power_control_queue_insert</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">,</span>
					       <span class="k">struct</span> <span class="n">isci_phy</span> <span class="o">*</span><span class="n">iphy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">iphy</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">power_control</span><span class="p">.</span><span class="n">phys_granted_power</span> <span class="o">&lt;</span> <span class="n">max_spin_up</span><span class="p">(</span><span class="n">ihost</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ihost</span><span class="o">-&gt;</span><span class="n">power_control</span><span class="p">.</span><span class="n">phys_granted_power</span><span class="o">++</span><span class="p">;</span>
		<span class="n">sci_phy_consume_power_handler</span><span class="p">(</span><span class="n">iphy</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * stop and start the power_control timer. When the timer fires, the</span>
<span class="cm">		 * no_of_phys_granted_power will be set to 0</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">power_control</span><span class="p">.</span><span class="n">timer_started</span><span class="p">)</span>
			<span class="n">sci_del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">power_control</span><span class="p">.</span><span class="n">timer</span><span class="p">);</span>

		<span class="n">sci_mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">power_control</span><span class="p">.</span><span class="n">timer</span><span class="p">,</span>
				 <span class="n">SCIC_SDS_CONTROLLER_POWER_CONTROL_INTERVAL</span><span class="p">);</span>
		<span class="n">ihost</span><span class="o">-&gt;</span><span class="n">power_control</span><span class="p">.</span><span class="n">timer_started</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * There are phys, attached to the same sas address as this phy, are</span>
<span class="cm">		 * already in READY state, this phy don&#39;t need wait.</span>
<span class="cm">		 */</span>
		<span class="n">u8</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">isci_phy</span> <span class="o">*</span><span class="n">current_phy</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SCI_MAX_PHYS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u8</span> <span class="n">other</span><span class="p">;</span>
			<span class="n">current_phy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

			<span class="n">other</span> <span class="o">=</span> <span class="n">memcmp</span><span class="p">(</span><span class="n">current_phy</span><span class="o">-&gt;</span><span class="n">frame_rcvd</span><span class="p">.</span><span class="n">iaf</span><span class="p">.</span><span class="n">sas_addr</span><span class="p">,</span>
				       <span class="n">iphy</span><span class="o">-&gt;</span><span class="n">frame_rcvd</span><span class="p">.</span><span class="n">iaf</span><span class="p">.</span><span class="n">sas_addr</span><span class="p">,</span>
				       <span class="k">sizeof</span><span class="p">(</span><span class="n">current_phy</span><span class="o">-&gt;</span><span class="n">frame_rcvd</span><span class="p">.</span><span class="n">iaf</span><span class="p">.</span><span class="n">sas_addr</span><span class="p">));</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">current_phy</span><span class="o">-&gt;</span><span class="n">sm</span><span class="p">.</span><span class="n">current_state_id</span> <span class="o">==</span> <span class="n">SCI_PHY_READY</span> <span class="o">&amp;&amp;</span>
			    <span class="n">current_phy</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">SAS_PROTOCOL_SSP</span> <span class="o">&amp;&amp;</span>
			    <span class="n">other</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">sci_phy_consume_power_handler</span><span class="p">(</span><span class="n">iphy</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">SCI_MAX_PHYS</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Add the phy in the waiting list */</span>
			<span class="n">ihost</span><span class="o">-&gt;</span><span class="n">power_control</span><span class="p">.</span><span class="n">requesters</span><span class="p">[</span><span class="n">iphy</span><span class="o">-&gt;</span><span class="n">phy_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">iphy</span><span class="p">;</span>
			<span class="n">ihost</span><span class="o">-&gt;</span><span class="n">power_control</span><span class="p">.</span><span class="n">phys_waiting</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">sci_controller_power_control_queue_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">,</span>
					       <span class="k">struct</span> <span class="n">isci_phy</span> <span class="o">*</span><span class="n">iphy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">iphy</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">power_control</span><span class="p">.</span><span class="n">requesters</span><span class="p">[</span><span class="n">iphy</span><span class="o">-&gt;</span><span class="n">phy_index</span><span class="p">])</span>
		<span class="n">ihost</span><span class="o">-&gt;</span><span class="n">power_control</span><span class="p">.</span><span class="n">phys_waiting</span><span class="o">--</span><span class="p">;</span>

	<span class="n">ihost</span><span class="o">-&gt;</span><span class="n">power_control</span><span class="p">.</span><span class="n">requesters</span><span class="p">[</span><span class="n">iphy</span><span class="o">-&gt;</span><span class="n">phy_index</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">is_long_cable</span><span class="p">(</span><span class="kt">int</span> <span class="n">phy</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">selection_byte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!!</span><span class="p">(</span><span class="n">selection_byte</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">phy</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">is_medium_cable</span><span class="p">(</span><span class="kt">int</span> <span class="n">phy</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">selection_byte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!!</span><span class="p">(</span><span class="n">selection_byte</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">phy</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">enum</span> <span class="n">cable_selections</span> <span class="nf">decode_selection_byte</span><span class="p">(</span>
	<span class="kt">int</span> <span class="n">phy</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">selection_byte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">((</span><span class="n">selection_byte</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">phy</span><span class="p">))</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">)</span>
		<span class="o">+</span> <span class="p">(</span><span class="n">selection_byte</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">phy</span> <span class="o">+</span> <span class="mi">4</span><span class="p">))</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">to_cable_select</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_cable_select_overridden</span><span class="p">())</span>
		<span class="k">return</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">cable_selection_override</span><span class="p">)</span>
			<span class="o">+</span> <span class="n">ihost</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">oem_parameters</span><span class="p">.</span><span class="n">controller</span><span class="p">.</span><span class="n">cable_selection_mask</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="n">cable_selections</span> <span class="nf">decode_cable_selection</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">,</span> <span class="kt">int</span> <span class="n">phy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">decode_selection_byte</span><span class="p">(</span><span class="n">phy</span><span class="p">,</span> <span class="o">*</span><span class="n">to_cable_select</span><span class="p">(</span><span class="n">ihost</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">char</span> <span class="o">*</span><span class="nf">lookup_cable_names</span><span class="p">(</span><span class="k">enum</span> <span class="n">cable_selections</span> <span class="n">selection</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cable_names</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">[</span><span class="n">short_cable</span><span class="p">]</span>     <span class="o">=</span> <span class="s">&quot;short&quot;</span><span class="p">,</span>
		<span class="p">[</span><span class="n">long_cable</span><span class="p">]</span>      <span class="o">=</span> <span class="s">&quot;long&quot;</span><span class="p">,</span>
		<span class="p">[</span><span class="n">medium_cable</span><span class="p">]</span>    <span class="o">=</span> <span class="s">&quot;medium&quot;</span><span class="p">,</span>
		<span class="p">[</span><span class="n">undefined_cable</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;&lt;undefined, assumed long&gt;&quot;</span> <span class="cm">/* bit 0==1 */</span>
	<span class="p">};</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">selection</span> <span class="o">&lt;=</span> <span class="n">undefined_cable</span><span class="p">)</span> <span class="o">?</span> <span class="n">cable_names</span><span class="p">[</span><span class="n">selection</span><span class="p">]</span>
					      <span class="o">:</span> <span class="n">cable_names</span><span class="p">[</span><span class="n">undefined_cable</span><span class="p">];</span>
<span class="p">}</span>

<span class="cp">#define AFE_REGISTER_WRITE_DELAY 10</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sci_controller_afe_initialization</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scu_afe_registers</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">afe</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">scu_registers</span><span class="o">-&gt;</span><span class="n">afe</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sci_oem_params</span> <span class="o">*</span><span class="n">oem</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">oem_parameters</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">ihost</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">afe_status</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">phy_id</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">cable_selection_mask</span> <span class="o">=</span> <span class="o">*</span><span class="n">to_cable_select</span><span class="p">(</span><span class="n">ihost</span><span class="p">);</span>

	<span class="cm">/* Clear DFX Status registers */</span>
	<span class="n">writel</span><span class="p">(</span><span class="mh">0x0081000f</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">afe</span><span class="o">-&gt;</span><span class="n">afe_dfx_master_control0</span><span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="n">AFE_REGISTER_WRITE_DELAY</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_b0</span><span class="p">(</span><span class="n">pdev</span><span class="p">)</span> <span class="o">||</span> <span class="n">is_c0</span><span class="p">(</span><span class="n">pdev</span><span class="p">)</span> <span class="o">||</span> <span class="n">is_c1</span><span class="p">(</span><span class="n">pdev</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* PM Rx Equalization Save, PM SPhy Rx Acknowledgement</span>
<span class="cm">		 * Timer, PM Stagger Timer</span>
<span class="cm">		 */</span>
		<span class="n">writel</span><span class="p">(</span><span class="mh">0x0007FFFF</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">afe</span><span class="o">-&gt;</span><span class="n">afe_pmsn_master_control2</span><span class="p">);</span>
		<span class="n">udelay</span><span class="p">(</span><span class="n">AFE_REGISTER_WRITE_DELAY</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Configure bias currents to normal */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_a2</span><span class="p">(</span><span class="n">pdev</span><span class="p">))</span>
		<span class="n">writel</span><span class="p">(</span><span class="mh">0x00005A00</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">afe</span><span class="o">-&gt;</span><span class="n">afe_bias_control</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">is_b0</span><span class="p">(</span><span class="n">pdev</span><span class="p">)</span> <span class="o">||</span> <span class="n">is_c0</span><span class="p">(</span><span class="n">pdev</span><span class="p">))</span>
		<span class="n">writel</span><span class="p">(</span><span class="mh">0x00005F00</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">afe</span><span class="o">-&gt;</span><span class="n">afe_bias_control</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">is_c1</span><span class="p">(</span><span class="n">pdev</span><span class="p">))</span>
		<span class="n">writel</span><span class="p">(</span><span class="mh">0x00005500</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">afe</span><span class="o">-&gt;</span><span class="n">afe_bias_control</span><span class="p">);</span>

	<span class="n">udelay</span><span class="p">(</span><span class="n">AFE_REGISTER_WRITE_DELAY</span><span class="p">);</span>

	<span class="cm">/* Enable PLL */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_a2</span><span class="p">(</span><span class="n">pdev</span><span class="p">))</span>
		<span class="n">writel</span><span class="p">(</span><span class="mh">0x80040908</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">afe</span><span class="o">-&gt;</span><span class="n">afe_pll_control0</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">is_b0</span><span class="p">(</span><span class="n">pdev</span><span class="p">)</span> <span class="o">||</span> <span class="n">is_c0</span><span class="p">(</span><span class="n">pdev</span><span class="p">))</span>
		<span class="n">writel</span><span class="p">(</span><span class="mh">0x80040A08</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">afe</span><span class="o">-&gt;</span><span class="n">afe_pll_control0</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">is_c1</span><span class="p">(</span><span class="n">pdev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">writel</span><span class="p">(</span><span class="mh">0x80000B08</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">afe</span><span class="o">-&gt;</span><span class="n">afe_pll_control0</span><span class="p">);</span>
		<span class="n">udelay</span><span class="p">(</span><span class="n">AFE_REGISTER_WRITE_DELAY</span><span class="p">);</span>
		<span class="n">writel</span><span class="p">(</span><span class="mh">0x00000B08</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">afe</span><span class="o">-&gt;</span><span class="n">afe_pll_control0</span><span class="p">);</span>
		<span class="n">udelay</span><span class="p">(</span><span class="n">AFE_REGISTER_WRITE_DELAY</span><span class="p">);</span>
		<span class="n">writel</span><span class="p">(</span><span class="mh">0x80000B08</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">afe</span><span class="o">-&gt;</span><span class="n">afe_pll_control0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">udelay</span><span class="p">(</span><span class="n">AFE_REGISTER_WRITE_DELAY</span><span class="p">);</span>

	<span class="cm">/* Wait for the PLL to lock */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">afe_status</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">afe</span><span class="o">-&gt;</span><span class="n">afe_common_block_status</span><span class="p">);</span>
		<span class="n">udelay</span><span class="p">(</span><span class="n">AFE_REGISTER_WRITE_DELAY</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">afe_status</span> <span class="o">&amp;</span> <span class="mh">0x00001000</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_a2</span><span class="p">(</span><span class="n">pdev</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Shorten SAS SNW lock time (RxLock timer value from 76</span>
<span class="cm">		 * us to 50 us)</span>
<span class="cm">		 */</span>
		<span class="n">writel</span><span class="p">(</span><span class="mh">0x7bcc96ad</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">afe</span><span class="o">-&gt;</span><span class="n">afe_pmsn_master_control0</span><span class="p">);</span>
		<span class="n">udelay</span><span class="p">(</span><span class="n">AFE_REGISTER_WRITE_DELAY</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">phy_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">phy_id</span> <span class="o">&lt;</span> <span class="n">SCI_MAX_PHYS</span><span class="p">;</span> <span class="n">phy_id</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">scu_afe_transceiver</span> <span class="o">*</span><span class="n">xcvr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">afe</span><span class="o">-&gt;</span><span class="n">scu_afe_xcvr</span><span class="p">[</span><span class="n">phy_id</span><span class="p">];</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">sci_phy_oem_params</span> <span class="o">*</span><span class="n">oem_phy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">oem</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">[</span><span class="n">phy_id</span><span class="p">];</span>
		<span class="kt">int</span> <span class="n">cable_length_long</span> <span class="o">=</span>
			<span class="n">is_long_cable</span><span class="p">(</span><span class="n">phy_id</span><span class="p">,</span> <span class="n">cable_selection_mask</span><span class="p">);</span>
		<span class="kt">int</span> <span class="n">cable_length_medium</span> <span class="o">=</span>
			<span class="n">is_medium_cable</span><span class="p">(</span><span class="n">phy_id</span><span class="p">,</span> <span class="n">cable_selection_mask</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">is_a2</span><span class="p">(</span><span class="n">pdev</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* All defaults, except the Receive Word</span>
<span class="cm">			 * Alignament/Comma Detect Enable....(0xe800)</span>
<span class="cm">			 */</span>
			<span class="n">writel</span><span class="p">(</span><span class="mh">0x00004512</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xcvr</span><span class="o">-&gt;</span><span class="n">afe_xcvr_control0</span><span class="p">);</span>
			<span class="n">udelay</span><span class="p">(</span><span class="n">AFE_REGISTER_WRITE_DELAY</span><span class="p">);</span>

			<span class="n">writel</span><span class="p">(</span><span class="mh">0x0050100F</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xcvr</span><span class="o">-&gt;</span><span class="n">afe_xcvr_control1</span><span class="p">);</span>
			<span class="n">udelay</span><span class="p">(</span><span class="n">AFE_REGISTER_WRITE_DELAY</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">is_b0</span><span class="p">(</span><span class="n">pdev</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Configure transmitter SSC parameters */</span>
			<span class="n">writel</span><span class="p">(</span><span class="mh">0x00030000</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xcvr</span><span class="o">-&gt;</span><span class="n">afe_tx_ssc_control</span><span class="p">);</span>
			<span class="n">udelay</span><span class="p">(</span><span class="n">AFE_REGISTER_WRITE_DELAY</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">is_c0</span><span class="p">(</span><span class="n">pdev</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Configure transmitter SSC parameters */</span>
			<span class="n">writel</span><span class="p">(</span><span class="mh">0x00010202</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xcvr</span><span class="o">-&gt;</span><span class="n">afe_tx_ssc_control</span><span class="p">);</span>
			<span class="n">udelay</span><span class="p">(</span><span class="n">AFE_REGISTER_WRITE_DELAY</span><span class="p">);</span>

			<span class="cm">/* All defaults, except the Receive Word</span>
<span class="cm">			 * Alignament/Comma Detect Enable....(0xe800)</span>
<span class="cm">			 */</span>
			<span class="n">writel</span><span class="p">(</span><span class="mh">0x00014500</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xcvr</span><span class="o">-&gt;</span><span class="n">afe_xcvr_control0</span><span class="p">);</span>
			<span class="n">udelay</span><span class="p">(</span><span class="n">AFE_REGISTER_WRITE_DELAY</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">is_c1</span><span class="p">(</span><span class="n">pdev</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Configure transmitter SSC parameters */</span>
			<span class="n">writel</span><span class="p">(</span><span class="mh">0x00010202</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xcvr</span><span class="o">-&gt;</span><span class="n">afe_tx_ssc_control</span><span class="p">);</span>
			<span class="n">udelay</span><span class="p">(</span><span class="n">AFE_REGISTER_WRITE_DELAY</span><span class="p">);</span>

			<span class="cm">/* All defaults, except the Receive Word</span>
<span class="cm">			 * Alignament/Comma Detect Enable....(0xe800)</span>
<span class="cm">			 */</span>
			<span class="n">writel</span><span class="p">(</span><span class="mh">0x0001C500</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xcvr</span><span class="o">-&gt;</span><span class="n">afe_xcvr_control0</span><span class="p">);</span>
			<span class="n">udelay</span><span class="p">(</span><span class="n">AFE_REGISTER_WRITE_DELAY</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* Power up TX and RX out from power down (PWRDNTX and</span>
<span class="cm">		 * PWRDNRX) &amp; increase TX int &amp; ext bias 20%....(0xe85c)</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_a2</span><span class="p">(</span><span class="n">pdev</span><span class="p">))</span>
			<span class="n">writel</span><span class="p">(</span><span class="mh">0x000003F0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xcvr</span><span class="o">-&gt;</span><span class="n">afe_channel_control</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">is_b0</span><span class="p">(</span><span class="n">pdev</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">writel</span><span class="p">(</span><span class="mh">0x000003D7</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xcvr</span><span class="o">-&gt;</span><span class="n">afe_channel_control</span><span class="p">);</span>
			<span class="n">udelay</span><span class="p">(</span><span class="n">AFE_REGISTER_WRITE_DELAY</span><span class="p">);</span>

			<span class="n">writel</span><span class="p">(</span><span class="mh">0x000003D4</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xcvr</span><span class="o">-&gt;</span><span class="n">afe_channel_control</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">is_c0</span><span class="p">(</span><span class="n">pdev</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">writel</span><span class="p">(</span><span class="mh">0x000001E7</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xcvr</span><span class="o">-&gt;</span><span class="n">afe_channel_control</span><span class="p">);</span>
			<span class="n">udelay</span><span class="p">(</span><span class="n">AFE_REGISTER_WRITE_DELAY</span><span class="p">);</span>

			<span class="n">writel</span><span class="p">(</span><span class="mh">0x000001E4</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xcvr</span><span class="o">-&gt;</span><span class="n">afe_channel_control</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">is_c1</span><span class="p">(</span><span class="n">pdev</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">writel</span><span class="p">(</span><span class="n">cable_length_long</span> <span class="o">?</span> <span class="mh">0x000002F7</span> <span class="o">:</span> <span class="mh">0x000001F7</span><span class="p">,</span>
			       <span class="o">&amp;</span><span class="n">xcvr</span><span class="o">-&gt;</span><span class="n">afe_channel_control</span><span class="p">);</span>
			<span class="n">udelay</span><span class="p">(</span><span class="n">AFE_REGISTER_WRITE_DELAY</span><span class="p">);</span>

			<span class="n">writel</span><span class="p">(</span><span class="n">cable_length_long</span> <span class="o">?</span> <span class="mh">0x000002F4</span> <span class="o">:</span> <span class="mh">0x000001F4</span><span class="p">,</span>
			       <span class="o">&amp;</span><span class="n">xcvr</span><span class="o">-&gt;</span><span class="n">afe_channel_control</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">udelay</span><span class="p">(</span><span class="n">AFE_REGISTER_WRITE_DELAY</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">is_a2</span><span class="p">(</span><span class="n">pdev</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Enable TX equalization (0xe824) */</span>
			<span class="n">writel</span><span class="p">(</span><span class="mh">0x00040000</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xcvr</span><span class="o">-&gt;</span><span class="n">afe_tx_control</span><span class="p">);</span>
			<span class="n">udelay</span><span class="p">(</span><span class="n">AFE_REGISTER_WRITE_DELAY</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">is_a2</span><span class="p">(</span><span class="n">pdev</span><span class="p">)</span> <span class="o">||</span> <span class="n">is_b0</span><span class="p">(</span><span class="n">pdev</span><span class="p">))</span>
			<span class="cm">/* RDPI=0x0(RX Power On), RXOOBDETPDNC=0x0,</span>
<span class="cm">			 * TPD=0x0(TX Power On), RDD=0x0(RX Detect</span>
<span class="cm">			 * Enabled) ....(0xe800)</span>
<span class="cm">			 */</span>
			<span class="n">writel</span><span class="p">(</span><span class="mh">0x00004100</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xcvr</span><span class="o">-&gt;</span><span class="n">afe_xcvr_control0</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">is_c0</span><span class="p">(</span><span class="n">pdev</span><span class="p">))</span>
			<span class="n">writel</span><span class="p">(</span><span class="mh">0x00014100</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xcvr</span><span class="o">-&gt;</span><span class="n">afe_xcvr_control0</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">is_c1</span><span class="p">(</span><span class="n">pdev</span><span class="p">))</span>
			<span class="n">writel</span><span class="p">(</span><span class="mh">0x0001C100</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xcvr</span><span class="o">-&gt;</span><span class="n">afe_xcvr_control0</span><span class="p">);</span>
		<span class="n">udelay</span><span class="p">(</span><span class="n">AFE_REGISTER_WRITE_DELAY</span><span class="p">);</span>

		<span class="cm">/* Leave DFE/FFE on */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_a2</span><span class="p">(</span><span class="n">pdev</span><span class="p">))</span>
			<span class="n">writel</span><span class="p">(</span><span class="mh">0x3F11103F</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xcvr</span><span class="o">-&gt;</span><span class="n">afe_rx_ssc_control0</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">is_b0</span><span class="p">(</span><span class="n">pdev</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">writel</span><span class="p">(</span><span class="mh">0x3F11103F</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xcvr</span><span class="o">-&gt;</span><span class="n">afe_rx_ssc_control0</span><span class="p">);</span>
			<span class="n">udelay</span><span class="p">(</span><span class="n">AFE_REGISTER_WRITE_DELAY</span><span class="p">);</span>
			<span class="cm">/* Enable TX equalization (0xe824) */</span>
			<span class="n">writel</span><span class="p">(</span><span class="mh">0x00040000</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xcvr</span><span class="o">-&gt;</span><span class="n">afe_tx_control</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">is_c0</span><span class="p">(</span><span class="n">pdev</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">writel</span><span class="p">(</span><span class="mh">0x01400C0F</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xcvr</span><span class="o">-&gt;</span><span class="n">afe_rx_ssc_control1</span><span class="p">);</span>
			<span class="n">udelay</span><span class="p">(</span><span class="n">AFE_REGISTER_WRITE_DELAY</span><span class="p">);</span>

			<span class="n">writel</span><span class="p">(</span><span class="mh">0x3F6F103F</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xcvr</span><span class="o">-&gt;</span><span class="n">afe_rx_ssc_control0</span><span class="p">);</span>
			<span class="n">udelay</span><span class="p">(</span><span class="n">AFE_REGISTER_WRITE_DELAY</span><span class="p">);</span>

			<span class="cm">/* Enable TX equalization (0xe824) */</span>
			<span class="n">writel</span><span class="p">(</span><span class="mh">0x00040000</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xcvr</span><span class="o">-&gt;</span><span class="n">afe_tx_control</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">is_c1</span><span class="p">(</span><span class="n">pdev</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">writel</span><span class="p">(</span><span class="n">cable_length_long</span> <span class="o">?</span> <span class="mh">0x01500C0C</span> <span class="o">:</span>
			       <span class="n">cable_length_medium</span> <span class="o">?</span> <span class="mh">0x01400C0D</span> <span class="o">:</span> <span class="mh">0x02400C0D</span><span class="p">,</span>
			       <span class="o">&amp;</span><span class="n">xcvr</span><span class="o">-&gt;</span><span class="n">afe_xcvr_control1</span><span class="p">);</span>
			<span class="n">udelay</span><span class="p">(</span><span class="n">AFE_REGISTER_WRITE_DELAY</span><span class="p">);</span>

			<span class="n">writel</span><span class="p">(</span><span class="mh">0x000003E0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xcvr</span><span class="o">-&gt;</span><span class="n">afe_dfx_rx_control1</span><span class="p">);</span>
			<span class="n">udelay</span><span class="p">(</span><span class="n">AFE_REGISTER_WRITE_DELAY</span><span class="p">);</span>

			<span class="n">writel</span><span class="p">(</span><span class="n">cable_length_long</span> <span class="o">?</span> <span class="mh">0x33091C1F</span> <span class="o">:</span>
			       <span class="n">cable_length_medium</span> <span class="o">?</span> <span class="mh">0x3315181F</span> <span class="o">:</span> <span class="mh">0x2B17161F</span><span class="p">,</span>
			       <span class="o">&amp;</span><span class="n">xcvr</span><span class="o">-&gt;</span><span class="n">afe_rx_ssc_control0</span><span class="p">);</span>
			<span class="n">udelay</span><span class="p">(</span><span class="n">AFE_REGISTER_WRITE_DELAY</span><span class="p">);</span>

			<span class="cm">/* Enable TX equalization (0xe824) */</span>
			<span class="n">writel</span><span class="p">(</span><span class="mh">0x00040000</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xcvr</span><span class="o">-&gt;</span><span class="n">afe_tx_control</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">udelay</span><span class="p">(</span><span class="n">AFE_REGISTER_WRITE_DELAY</span><span class="p">);</span>

		<span class="n">writel</span><span class="p">(</span><span class="n">oem_phy</span><span class="o">-&gt;</span><span class="n">afe_tx_amp_control0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xcvr</span><span class="o">-&gt;</span><span class="n">afe_tx_amp_control0</span><span class="p">);</span>
		<span class="n">udelay</span><span class="p">(</span><span class="n">AFE_REGISTER_WRITE_DELAY</span><span class="p">);</span>

		<span class="n">writel</span><span class="p">(</span><span class="n">oem_phy</span><span class="o">-&gt;</span><span class="n">afe_tx_amp_control1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xcvr</span><span class="o">-&gt;</span><span class="n">afe_tx_amp_control1</span><span class="p">);</span>
		<span class="n">udelay</span><span class="p">(</span><span class="n">AFE_REGISTER_WRITE_DELAY</span><span class="p">);</span>

		<span class="n">writel</span><span class="p">(</span><span class="n">oem_phy</span><span class="o">-&gt;</span><span class="n">afe_tx_amp_control2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xcvr</span><span class="o">-&gt;</span><span class="n">afe_tx_amp_control2</span><span class="p">);</span>
		<span class="n">udelay</span><span class="p">(</span><span class="n">AFE_REGISTER_WRITE_DELAY</span><span class="p">);</span>

		<span class="n">writel</span><span class="p">(</span><span class="n">oem_phy</span><span class="o">-&gt;</span><span class="n">afe_tx_amp_control3</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xcvr</span><span class="o">-&gt;</span><span class="n">afe_tx_amp_control3</span><span class="p">);</span>
		<span class="n">udelay</span><span class="p">(</span><span class="n">AFE_REGISTER_WRITE_DELAY</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Transfer control to the PEs */</span>
	<span class="n">writel</span><span class="p">(</span><span class="mh">0x00010f00</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">afe</span><span class="o">-&gt;</span><span class="n">afe_dfx_master_control0</span><span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="n">AFE_REGISTER_WRITE_DELAY</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sci_controller_initialize_power_control</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sci_init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">power_control</span><span class="p">.</span><span class="n">timer</span><span class="p">,</span> <span class="n">power_control_timeout</span><span class="p">);</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">power_control</span><span class="p">.</span><span class="n">requesters</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
	       <span class="k">sizeof</span><span class="p">(</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">power_control</span><span class="p">.</span><span class="n">requesters</span><span class="p">));</span>

	<span class="n">ihost</span><span class="o">-&gt;</span><span class="n">power_control</span><span class="p">.</span><span class="n">phys_waiting</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ihost</span><span class="o">-&gt;</span><span class="n">power_control</span><span class="p">.</span><span class="n">phys_granted_power</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">enum</span> <span class="n">sci_status</span> <span class="nf">sci_controller_initialize</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sci_base_state_machine</span> <span class="o">*</span><span class="n">sm</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">sm</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">sci_status</span> <span class="n">result</span> <span class="o">=</span> <span class="n">SCI_FAILURE</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">val</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">sm</span><span class="p">.</span><span class="n">current_state_id</span> <span class="o">!=</span> <span class="n">SCIC_RESET</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s invalid state: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">__func__</span><span class="p">,</span> <span class="n">ihost</span><span class="o">-&gt;</span><span class="n">sm</span><span class="p">.</span><span class="n">current_state_id</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">SCI_FAILURE_INVALID_STATE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sci_change_state</span><span class="p">(</span><span class="n">sm</span><span class="p">,</span> <span class="n">SCIC_INITIALIZING</span><span class="p">);</span>

	<span class="n">sci_init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">phy_timer</span><span class="p">,</span> <span class="n">phy_startup_timeout</span><span class="p">);</span>

	<span class="n">ihost</span><span class="o">-&gt;</span><span class="n">next_phy_to_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ihost</span><span class="o">-&gt;</span><span class="n">phy_startup_timer_pending</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">sci_controller_initialize_power_control</span><span class="p">(</span><span class="n">ihost</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * There is nothing to do here for B0 since we do not have to</span>
<span class="cm">	 * program the AFE registers.</span>
<span class="cm">	 * / @todo The AFE settings are supposed to be correct for the B0 but</span>
<span class="cm">	 * /       presently they seem to be wrong. */</span>
	<span class="n">sci_controller_afe_initialization</span><span class="p">(</span><span class="n">ihost</span><span class="p">);</span>


	<span class="cm">/* Take the hardware out of reset */</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">smu_registers</span><span class="o">-&gt;</span><span class="n">soft_reset_control</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * / @todo Provide meaningfull error code for hardware failure</span>
<span class="cm">	 * result = SCI_FAILURE_CONTROLLER_HARDWARE; */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">status</span><span class="p">;</span>

		<span class="cm">/* Loop until the hardware reports success */</span>
		<span class="n">udelay</span><span class="p">(</span><span class="n">SCU_CONTEXT_RAM_INIT_STALL_TIME</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">smu_registers</span><span class="o">-&gt;</span><span class="n">control_status</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">SCU_RAM_INIT_COMPLETED</span><span class="p">)</span> <span class="o">==</span> <span class="n">SCU_RAM_INIT_COMPLETED</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Determine what are the actaul device capacities that the</span>
<span class="cm">	 * hardware will support */</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">smu_registers</span><span class="o">-&gt;</span><span class="n">device_context_capacity</span><span class="p">);</span>

	<span class="cm">/* Record the smaller of the two capacity values */</span>
	<span class="n">ihost</span><span class="o">-&gt;</span><span class="n">logical_port_entries</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">smu_max_ports</span><span class="p">(</span><span class="n">val</span><span class="p">),</span> <span class="n">SCI_MAX_PORTS</span><span class="p">);</span>
	<span class="n">ihost</span><span class="o">-&gt;</span><span class="n">task_context_entries</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">smu_max_task_contexts</span><span class="p">(</span><span class="n">val</span><span class="p">),</span> <span class="n">SCI_MAX_IO_REQUESTS</span><span class="p">);</span>
	<span class="n">ihost</span><span class="o">-&gt;</span><span class="n">remote_node_entries</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">smu_max_rncs</span><span class="p">(</span><span class="n">val</span><span class="p">),</span> <span class="n">SCI_MAX_REMOTE_DEVICES</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Make all PEs that are unassigned match up with the</span>
<span class="cm">	 * logical ports</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ihost</span><span class="o">-&gt;</span><span class="n">logical_port_entries</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">scu_port_task_scheduler_group_registers</span> <span class="n">__iomem</span>
			<span class="o">*</span><span class="n">ptsg</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">scu_registers</span><span class="o">-&gt;</span><span class="n">peg0</span><span class="p">.</span><span class="n">ptsg</span><span class="p">;</span>

		<span class="n">writel</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ptsg</span><span class="o">-&gt;</span><span class="n">protocol_engine</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="cm">/* Initialize hardware PCI Relaxed ordering in DMA engines */</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">scu_registers</span><span class="o">-&gt;</span><span class="n">sdma</span><span class="p">.</span><span class="n">pdma_configuration</span><span class="p">);</span>
	<span class="n">val</span> <span class="o">|=</span> <span class="n">SCU_PDMACR_GEN_BIT</span><span class="p">(</span><span class="n">PCI_RELAXED_ORDERING_ENABLE</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">scu_registers</span><span class="o">-&gt;</span><span class="n">sdma</span><span class="p">.</span><span class="n">pdma_configuration</span><span class="p">);</span>

	<span class="n">val</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">scu_registers</span><span class="o">-&gt;</span><span class="n">sdma</span><span class="p">.</span><span class="n">cdma_configuration</span><span class="p">);</span>
	<span class="n">val</span> <span class="o">|=</span> <span class="n">SCU_CDMACR_GEN_BIT</span><span class="p">(</span><span class="n">PCI_RELAXED_ORDERING_ENABLE</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">scu_registers</span><span class="o">-&gt;</span><span class="n">sdma</span><span class="p">.</span><span class="n">cdma_configuration</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialize the PHYs before the PORTs because the PHY registers</span>
<span class="cm">	 * are accessed during the port initialization.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SCI_MAX_PHYS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">sci_phy_initialize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
					    <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">scu_registers</span><span class="o">-&gt;</span><span class="n">peg0</span><span class="p">.</span><span class="n">pe</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">tl</span><span class="p">,</span>
					    <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">scu_registers</span><span class="o">-&gt;</span><span class="n">peg0</span><span class="p">.</span><span class="n">pe</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">ll</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="n">SCI_SUCCESS</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ihost</span><span class="o">-&gt;</span><span class="n">logical_port_entries</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">iport</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">ports</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="n">iport</span><span class="o">-&gt;</span><span class="n">port_task_scheduler_registers</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">scu_registers</span><span class="o">-&gt;</span><span class="n">peg0</span><span class="p">.</span><span class="n">ptsg</span><span class="p">.</span><span class="n">port</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">iport</span><span class="o">-&gt;</span><span class="n">port_pe_configuration_register</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">scu_registers</span><span class="o">-&gt;</span><span class="n">peg0</span><span class="p">.</span><span class="n">ptsg</span><span class="p">.</span><span class="n">protocol_engine</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">iport</span><span class="o">-&gt;</span><span class="n">viit_registers</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">scu_registers</span><span class="o">-&gt;</span><span class="n">peg0</span><span class="p">.</span><span class="n">viit</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="p">}</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">sci_port_configuration_agent_initialize</span><span class="p">(</span><span class="n">ihost</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">port_agent</span><span class="p">);</span>

 <span class="nl">out:</span>
	<span class="cm">/* Advance the controller state machine */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">SCI_SUCCESS</span><span class="p">)</span>
		<span class="n">state</span> <span class="o">=</span> <span class="n">SCIC_INITIALIZED</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">state</span> <span class="o">=</span> <span class="n">SCIC_FAILED</span><span class="p">;</span>
	<span class="n">sci_change_state</span><span class="p">(</span><span class="n">sm</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sci_controller_dma_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* detect re-initialization */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">completion_queue</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="n">SCU_MAX_COMPLETION_QUEUE_ENTRIES</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">);</span>
	<span class="n">ihost</span><span class="o">-&gt;</span><span class="n">completion_queue</span> <span class="o">=</span> <span class="n">dmam_alloc_coherent</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">cq_dma</span><span class="p">,</span>
						      <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">completion_queue</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="n">ihost</span><span class="o">-&gt;</span><span class="n">remote_node_entries</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">scu_remote_node_context</span><span class="p">);</span>
	<span class="n">ihost</span><span class="o">-&gt;</span><span class="n">remote_node_context_table</span> <span class="o">=</span> <span class="n">dmam_alloc_coherent</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">rnc_dma</span><span class="p">,</span>
							       <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">remote_node_context_table</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="n">ihost</span><span class="o">-&gt;</span><span class="n">task_context_entries</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">scu_task_context</span><span class="p">),</span>
	<span class="n">ihost</span><span class="o">-&gt;</span><span class="n">task_context_table</span> <span class="o">=</span> <span class="n">dmam_alloc_coherent</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">tc_dma</span><span class="p">,</span>
							<span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">task_context_table</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="n">SCI_UFI_TOTAL_SIZE</span><span class="p">;</span>
	<span class="n">ihost</span><span class="o">-&gt;</span><span class="n">ufi_buf</span> <span class="o">=</span> <span class="n">dmam_alloc_coherent</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">ufi_dma</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">ufi_buf</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SCI_MAX_IO_REQUESTS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">isci_request</span> <span class="o">*</span><span class="n">ireq</span><span class="p">;</span>
		<span class="n">dma_addr_t</span> <span class="n">dma</span><span class="p">;</span>

		<span class="n">ireq</span> <span class="o">=</span> <span class="n">dmam_alloc_coherent</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ireq</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">dma</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ireq</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

		<span class="n">ireq</span><span class="o">-&gt;</span><span class="n">tc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">task_context_table</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">ireq</span><span class="o">-&gt;</span><span class="n">owning_controller</span> <span class="o">=</span> <span class="n">ihost</span><span class="p">;</span>
		<span class="n">ireq</span><span class="o">-&gt;</span><span class="n">request_daddr</span> <span class="o">=</span> <span class="n">dma</span><span class="p">;</span>
		<span class="n">ireq</span><span class="o">-&gt;</span><span class="n">isci_host</span> <span class="o">=</span> <span class="n">ihost</span><span class="p">;</span>
		<span class="n">ihost</span><span class="o">-&gt;</span><span class="n">reqs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ireq</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sci_controller_mem_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="n">sci_controller_dma_alloc</span><span class="p">(</span><span class="n">ihost</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">writel</span><span class="p">(</span><span class="n">lower_32_bits</span><span class="p">(</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">cq_dma</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">smu_registers</span><span class="o">-&gt;</span><span class="n">completion_queue_lower</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">upper_32_bits</span><span class="p">(</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">cq_dma</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">smu_registers</span><span class="o">-&gt;</span><span class="n">completion_queue_upper</span><span class="p">);</span>

	<span class="n">writel</span><span class="p">(</span><span class="n">lower_32_bits</span><span class="p">(</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">rnc_dma</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">smu_registers</span><span class="o">-&gt;</span><span class="n">remote_node_context_lower</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">upper_32_bits</span><span class="p">(</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">rnc_dma</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">smu_registers</span><span class="o">-&gt;</span><span class="n">remote_node_context_upper</span><span class="p">);</span>

	<span class="n">writel</span><span class="p">(</span><span class="n">lower_32_bits</span><span class="p">(</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">tc_dma</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">smu_registers</span><span class="o">-&gt;</span><span class="n">host_task_table_lower</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">upper_32_bits</span><span class="p">(</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">tc_dma</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">smu_registers</span><span class="o">-&gt;</span><span class="n">host_task_table_upper</span><span class="p">);</span>

	<span class="n">sci_unsolicited_frame_control_construct</span><span class="p">(</span><span class="n">ihost</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Inform the silicon as to the location of the UF headers and</span>
<span class="cm">	 * address table.</span>
<span class="cm">	 */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">lower_32_bits</span><span class="p">(</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">uf_control</span><span class="p">.</span><span class="n">headers</span><span class="p">.</span><span class="n">physical_address</span><span class="p">),</span>
		<span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">scu_registers</span><span class="o">-&gt;</span><span class="n">sdma</span><span class="p">.</span><span class="n">uf_header_base_address_lower</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">upper_32_bits</span><span class="p">(</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">uf_control</span><span class="p">.</span><span class="n">headers</span><span class="p">.</span><span class="n">physical_address</span><span class="p">),</span>
		<span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">scu_registers</span><span class="o">-&gt;</span><span class="n">sdma</span><span class="p">.</span><span class="n">uf_header_base_address_upper</span><span class="p">);</span>

	<span class="n">writel</span><span class="p">(</span><span class="n">lower_32_bits</span><span class="p">(</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">uf_control</span><span class="p">.</span><span class="n">address_table</span><span class="p">.</span><span class="n">physical_address</span><span class="p">),</span>
		<span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">scu_registers</span><span class="o">-&gt;</span><span class="n">sdma</span><span class="p">.</span><span class="n">uf_address_table_lower</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">upper_32_bits</span><span class="p">(</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">uf_control</span><span class="p">.</span><span class="n">address_table</span><span class="p">.</span><span class="n">physical_address</span><span class="p">),</span>
		<span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">scu_registers</span><span class="o">-&gt;</span><span class="n">sdma</span><span class="p">.</span><span class="n">uf_address_table_upper</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * isci_host_init - (re-)initialize hardware and internal (private) state</span>
<span class="cm"> * @ihost: host to init</span>
<span class="cm"> *</span>
<span class="cm"> * Any public facing objects (like asd_sas_port, and asd_sas_phys), or</span>
<span class="cm"> * one-time initialization objects like locks and waitqueues, are</span>
<span class="cm"> * not touched (they are initialized in isci_host_alloc)</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">isci_host_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">sci_status</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">scic_lock</span><span class="p">);</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">sci_controller_construct</span><span class="p">(</span><span class="n">ihost</span><span class="p">,</span> <span class="n">scu_base</span><span class="p">(</span><span class="n">ihost</span><span class="p">),</span> <span class="n">smu_base</span><span class="p">(</span><span class="n">ihost</span><span class="p">));</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">scic_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">SCI_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;%s: sci_controller_construct failed - status = %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span>
			<span class="n">status</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">scic_lock</span><span class="p">);</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">sci_controller_initialize</span><span class="p">(</span><span class="n">ihost</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">scic_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">SCI_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			 <span class="s">&quot;%s: sci_controller_initialize failed -&quot;</span>
			 <span class="s">&quot; status = 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">__func__</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">sci_controller_mem_init</span><span class="p">(</span><span class="n">ihost</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* enable sgpio */</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">scu_registers</span><span class="o">-&gt;</span><span class="n">peg0</span><span class="p">.</span><span class="n">sgpio</span><span class="p">.</span><span class="n">interface_control</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">isci_gpio_count</span><span class="p">(</span><span class="n">ihost</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">SGPIO_HW_CONTROL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">scu_registers</span><span class="o">-&gt;</span><span class="n">peg0</span><span class="p">.</span><span class="n">sgpio</span><span class="p">.</span><span class="n">output_data_select</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">scu_registers</span><span class="o">-&gt;</span><span class="n">peg0</span><span class="p">.</span><span class="n">sgpio</span><span class="p">.</span><span class="n">vendor_specific_code</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">sci_controller_link_up</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">,</span> <span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">iport</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">isci_phy</span> <span class="o">*</span><span class="n">iphy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">sm</span><span class="p">.</span><span class="n">current_state_id</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SCIC_STARTING</span>:
		<span class="n">sci_del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">phy_timer</span><span class="p">);</span>
		<span class="n">ihost</span><span class="o">-&gt;</span><span class="n">phy_startup_timer_pending</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">ihost</span><span class="o">-&gt;</span><span class="n">port_agent</span><span class="p">.</span><span class="n">link_up_handler</span><span class="p">(</span><span class="n">ihost</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">port_agent</span><span class="p">,</span>
						  <span class="n">iport</span><span class="p">,</span> <span class="n">iphy</span><span class="p">);</span>
		<span class="n">sci_controller_start_next_phy</span><span class="p">(</span><span class="n">ihost</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCIC_READY</span>:
		<span class="n">ihost</span><span class="o">-&gt;</span><span class="n">port_agent</span><span class="p">.</span><span class="n">link_up_handler</span><span class="p">(</span><span class="n">ihost</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">port_agent</span><span class="p">,</span>
						  <span class="n">iport</span><span class="p">,</span> <span class="n">iphy</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;%s: SCIC Controller linkup event from phy %d in &quot;</span>
			<span class="s">&quot;unexpected state %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">iphy</span><span class="o">-&gt;</span><span class="n">phy_index</span><span class="p">,</span>
			<span class="n">ihost</span><span class="o">-&gt;</span><span class="n">sm</span><span class="p">.</span><span class="n">current_state_id</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">sci_controller_link_down</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">,</span> <span class="k">struct</span> <span class="n">isci_port</span> <span class="o">*</span><span class="n">iport</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">isci_phy</span> <span class="o">*</span><span class="n">iphy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">sm</span><span class="p">.</span><span class="n">current_state_id</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SCIC_STARTING</span>:
	<span class="k">case</span> <span class="n">SCIC_READY</span>:
		<span class="n">ihost</span><span class="o">-&gt;</span><span class="n">port_agent</span><span class="p">.</span><span class="n">link_down_handler</span><span class="p">(</span><span class="n">ihost</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">port_agent</span><span class="p">,</span>
						   <span class="n">iport</span><span class="p">,</span> <span class="n">iphy</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;%s: SCIC Controller linkdown event from phy %d in &quot;</span>
			<span class="s">&quot;unexpected state %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span>
			<span class="n">iphy</span><span class="o">-&gt;</span><span class="n">phy_index</span><span class="p">,</span>
			<span class="n">ihost</span><span class="o">-&gt;</span><span class="n">sm</span><span class="p">.</span><span class="n">current_state_id</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="n">bool</span> <span class="nf">sci_controller_has_remote_devices_stopping</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">index</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">ihost</span><span class="o">-&gt;</span><span class="n">remote_node_entries</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">device_table</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		   <span class="p">(</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">device_table</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">sm</span><span class="p">.</span><span class="n">current_state_id</span> <span class="o">==</span> <span class="n">SCI_DEV_STOPPING</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">sci_controller_remote_device_stopped</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">isci_remote_device</span> <span class="o">*</span><span class="n">idev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">sm</span><span class="p">.</span><span class="n">current_state_id</span> <span class="o">!=</span> <span class="n">SCIC_STOPPING</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;SCIC Controller 0x%p remote device stopped event &quot;</span>
			<span class="s">&quot;from device 0x%p in unexpected state %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">ihost</span><span class="p">,</span> <span class="n">idev</span><span class="p">,</span>
			<span class="n">ihost</span><span class="o">-&gt;</span><span class="n">sm</span><span class="p">.</span><span class="n">current_state_id</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sci_controller_has_remote_devices_stopping</span><span class="p">(</span><span class="n">ihost</span><span class="p">))</span>
		<span class="n">isci_host_stop_complete</span><span class="p">(</span><span class="n">ihost</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">sci_controller_post_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">,</span> <span class="n">u32</span> <span class="n">request</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s[%d]: %#x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span> <span class="n">ihost</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">request</span><span class="p">);</span>

	<span class="n">writel</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">smu_registers</span><span class="o">-&gt;</span><span class="n">post_context_port</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">isci_request</span> <span class="o">*</span><span class="nf">sci_request_by_tag</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">,</span> <span class="n">u16</span> <span class="n">io_tag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">task_index</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">task_sequence</span><span class="p">;</span>

	<span class="n">task_index</span> <span class="o">=</span> <span class="n">ISCI_TAG_TCI</span><span class="p">(</span><span class="n">io_tag</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">task_index</span> <span class="o">&lt;</span> <span class="n">ihost</span><span class="o">-&gt;</span><span class="n">task_context_entries</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">isci_request</span> <span class="o">*</span><span class="n">ireq</span> <span class="o">=</span> <span class="n">ihost</span><span class="o">-&gt;</span><span class="n">reqs</span><span class="p">[</span><span class="n">task_index</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">IREQ_ACTIVE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ireq</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">task_sequence</span> <span class="o">=</span> <span class="n">ISCI_TAG_SEQ</span><span class="p">(</span><span class="n">io_tag</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">task_sequence</span> <span class="o">==</span> <span class="n">ihost</span><span class="o">-&gt;</span><span class="n">io_request_sequence</span><span class="p">[</span><span class="n">task_index</span><span class="p">])</span>
				<span class="k">return</span> <span class="n">ireq</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * This method allocates remote node index and the reserves the remote node</span>
<span class="cm"> *    context space for use. This method can fail if there are no more remote</span>
<span class="cm"> *    node index available.</span>
<span class="cm"> * @scic: This is the controller object which contains the set of</span>
<span class="cm"> *    free remote node ids</span>
<span class="cm"> * @sci_dev: This is the device object which is requesting the a remote node</span>
<span class="cm"> *    id</span>
<span class="cm"> * @node_id: This is the remote node id that is assinged to the device if one</span>
<span class="cm"> *    is available</span>
<span class="cm"> *</span>
<span class="cm"> * enum sci_status SCI_FAILURE_OUT_OF_RESOURCES if there are no available remote</span>
<span class="cm"> * node index available.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">sci_status</span> <span class="nf">sci_controller_allocate_remote_node_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">,</span>
							    <span class="k">struct</span> <span class="n">isci_remote_device</span> <span class="o">*</span><span class="n">idev</span><span class="p">,</span>
							    <span class="n">u16</span> <span class="o">*</span><span class="n">node_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">node_index</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">remote_node_count</span> <span class="o">=</span> <span class="n">sci_remote_device_node_count</span><span class="p">(</span><span class="n">idev</span><span class="p">);</span>

	<span class="n">node_index</span> <span class="o">=</span> <span class="n">sci_remote_node_table_allocate_remote_node</span><span class="p">(</span>
		<span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">available_remote_nodes</span><span class="p">,</span> <span class="n">remote_node_count</span>
		<span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">node_index</span> <span class="o">!=</span> <span class="n">SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ihost</span><span class="o">-&gt;</span><span class="n">device_table</span><span class="p">[</span><span class="n">node_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">idev</span><span class="p">;</span>

		<span class="o">*</span><span class="n">node_id</span> <span class="o">=</span> <span class="n">node_index</span><span class="p">;</span>

		<span class="k">return</span> <span class="n">SCI_SUCCESS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">SCI_FAILURE_INSUFFICIENT_RESOURCES</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">sci_controller_free_remote_node_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">isci_remote_device</span> <span class="o">*</span><span class="n">idev</span><span class="p">,</span>
					     <span class="n">u16</span> <span class="n">node_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">remote_node_count</span> <span class="o">=</span> <span class="n">sci_remote_device_node_count</span><span class="p">(</span><span class="n">idev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">device_table</span><span class="p">[</span><span class="n">node_id</span><span class="p">]</span> <span class="o">==</span> <span class="n">idev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ihost</span><span class="o">-&gt;</span><span class="n">device_table</span><span class="p">[</span><span class="n">node_id</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">sci_remote_node_table_release_remote_node_index</span><span class="p">(</span>
			<span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">available_remote_nodes</span><span class="p">,</span> <span class="n">remote_node_count</span><span class="p">,</span> <span class="n">node_id</span>
			<span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">sci_controller_copy_sata_response</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">response_buffer</span><span class="p">,</span>
				       <span class="kt">void</span> <span class="o">*</span><span class="n">frame_header</span><span class="p">,</span>
				       <span class="kt">void</span> <span class="o">*</span><span class="n">frame_buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* XXX type safety? */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">response_buffer</span><span class="p">,</span> <span class="n">frame_header</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">));</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">response_buffer</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">),</span>
	       <span class="n">frame_buffer</span><span class="p">,</span>
	       <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dev_to_host_fis</span><span class="p">)</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">sci_controller_release_frame</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">,</span> <span class="n">u32</span> <span class="n">frame_index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sci_unsolicited_frame_control_release_frame</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">uf_control</span><span class="p">,</span> <span class="n">frame_index</span><span class="p">))</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">uf_control</span><span class="p">.</span><span class="n">get</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">scu_registers</span><span class="o">-&gt;</span><span class="n">sdma</span><span class="p">.</span><span class="n">unsolicited_frame_get_pointer</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">isci_tci_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">,</span> <span class="n">u16</span> <span class="n">tci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">tail</span> <span class="o">=</span> <span class="n">ihost</span><span class="o">-&gt;</span><span class="n">tci_tail</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">SCI_MAX_IO_REQUESTS</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>

	<span class="n">ihost</span><span class="o">-&gt;</span><span class="n">tci_pool</span><span class="p">[</span><span class="n">tail</span><span class="p">]</span> <span class="o">=</span> <span class="n">tci</span><span class="p">;</span>
	<span class="n">ihost</span><span class="o">-&gt;</span><span class="n">tci_tail</span> <span class="o">=</span> <span class="n">tail</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u16</span> <span class="nf">isci_tci_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">head</span> <span class="o">=</span> <span class="n">ihost</span><span class="o">-&gt;</span><span class="n">tci_head</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">SCI_MAX_IO_REQUESTS</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">u16</span> <span class="n">tci</span> <span class="o">=</span> <span class="n">ihost</span><span class="o">-&gt;</span><span class="n">tci_pool</span><span class="p">[</span><span class="n">head</span><span class="p">];</span>

	<span class="n">ihost</span><span class="o">-&gt;</span><span class="n">tci_head</span> <span class="o">=</span> <span class="n">head</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">tci</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u16</span> <span class="nf">isci_tci_space</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">CIRC_SPACE</span><span class="p">(</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">tci_head</span><span class="p">,</span> <span class="n">ihost</span><span class="o">-&gt;</span><span class="n">tci_tail</span><span class="p">,</span> <span class="n">SCI_MAX_IO_REQUESTS</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">u16</span> <span class="nf">isci_alloc_tag</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">isci_tci_space</span><span class="p">(</span><span class="n">ihost</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">u16</span> <span class="n">tci</span> <span class="o">=</span> <span class="n">isci_tci_alloc</span><span class="p">(</span><span class="n">ihost</span><span class="p">);</span>
		<span class="n">u8</span> <span class="n">seq</span> <span class="o">=</span> <span class="n">ihost</span><span class="o">-&gt;</span><span class="n">io_request_sequence</span><span class="p">[</span><span class="n">tci</span><span class="p">];</span>

		<span class="k">return</span> <span class="n">ISCI_TAG</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">tci</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">SCI_CONTROLLER_INVALID_IO_TAG</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="n">sci_status</span> <span class="nf">isci_free_tag</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">,</span> <span class="n">u16</span> <span class="n">io_tag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">tci</span> <span class="o">=</span> <span class="n">ISCI_TAG_TCI</span><span class="p">(</span><span class="n">io_tag</span><span class="p">);</span>
	<span class="n">u16</span> <span class="n">seq</span> <span class="o">=</span> <span class="n">ISCI_TAG_SEQ</span><span class="p">(</span><span class="n">io_tag</span><span class="p">);</span>

	<span class="cm">/* prevent tail from passing head */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">isci_tci_active</span><span class="p">(</span><span class="n">ihost</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">SCI_FAILURE_INVALID_IO_TAG</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">seq</span> <span class="o">==</span> <span class="n">ihost</span><span class="o">-&gt;</span><span class="n">io_request_sequence</span><span class="p">[</span><span class="n">tci</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">ihost</span><span class="o">-&gt;</span><span class="n">io_request_sequence</span><span class="p">[</span><span class="n">tci</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">seq</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">SCI_MAX_SEQ</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>

		<span class="n">isci_tci_free</span><span class="p">(</span><span class="n">ihost</span><span class="p">,</span> <span class="n">tci</span><span class="p">);</span>

		<span class="k">return</span> <span class="n">SCI_SUCCESS</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">SCI_FAILURE_INVALID_IO_TAG</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="n">sci_status</span> <span class="nf">sci_controller_start_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">isci_remote_device</span> <span class="o">*</span><span class="n">idev</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">isci_request</span> <span class="o">*</span><span class="n">ireq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">sci_status</span> <span class="n">status</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">sm</span><span class="p">.</span><span class="n">current_state_id</span> <span class="o">!=</span> <span class="n">SCIC_READY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s invalid state: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">__func__</span><span class="p">,</span> <span class="n">ihost</span><span class="o">-&gt;</span><span class="n">sm</span><span class="p">.</span><span class="n">current_state_id</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">SCI_FAILURE_INVALID_STATE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">sci_remote_device_start_io</span><span class="p">(</span><span class="n">ihost</span><span class="p">,</span> <span class="n">idev</span><span class="p">,</span> <span class="n">ireq</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">SCI_SUCCESS</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">set_bit</span><span class="p">(</span><span class="n">IREQ_ACTIVE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ireq</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">sci_controller_post_request</span><span class="p">(</span><span class="n">ihost</span><span class="p">,</span> <span class="n">ireq</span><span class="o">-&gt;</span><span class="n">post_context</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">SCI_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="n">sci_status</span> <span class="nf">sci_controller_terminate_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">,</span>
						 <span class="k">struct</span> <span class="n">isci_remote_device</span> <span class="o">*</span><span class="n">idev</span><span class="p">,</span>
						 <span class="k">struct</span> <span class="n">isci_request</span> <span class="o">*</span><span class="n">ireq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* terminate an ongoing (i.e. started) core IO request.  This does not</span>
<span class="cm">	 * abort the IO request at the target, but rather removes the IO</span>
<span class="cm">	 * request from the host controller.</span>
<span class="cm">	 */</span>
	<span class="k">enum</span> <span class="n">sci_status</span> <span class="n">status</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">sm</span><span class="p">.</span><span class="n">current_state_id</span> <span class="o">!=</span> <span class="n">SCIC_READY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s invalid state: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">__func__</span><span class="p">,</span> <span class="n">ihost</span><span class="o">-&gt;</span><span class="n">sm</span><span class="p">.</span><span class="n">current_state_id</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">SCI_FAILURE_INVALID_STATE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">sci_io_request_terminate</span><span class="p">(</span><span class="n">ireq</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: status=%d; ireq=%p; flags=%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">ireq</span><span class="p">,</span> <span class="n">ireq</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">status</span> <span class="o">==</span> <span class="n">SCI_SUCCESS</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">IREQ_PENDING_ABORT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ireq</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">IREQ_TC_ABORT_POSTED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ireq</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Utilize the original post context command and or in the</span>
<span class="cm">		 * POST_TC_ABORT request sub-type.</span>
<span class="cm">		 */</span>
		<span class="n">sci_controller_post_request</span><span class="p">(</span>
			<span class="n">ihost</span><span class="p">,</span> <span class="n">ireq</span><span class="o">-&gt;</span><span class="n">post_context</span> <span class="o">|</span>
				<span class="n">SCU_CONTEXT_COMMAND_REQUEST_POST_TC_ABORT</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sci_controller_complete_io() - This method will perform core specific</span>
<span class="cm"> *    completion operations for an IO request.  After this method is invoked,</span>
<span class="cm"> *    the user should consider the IO request as invalid until it is properly</span>
<span class="cm"> *    reused (i.e. re-constructed).</span>
<span class="cm"> * @ihost: The handle to the controller object for which to complete the</span>
<span class="cm"> *    IO request.</span>
<span class="cm"> * @idev: The handle to the remote device object for which to complete</span>
<span class="cm"> *    the IO request.</span>
<span class="cm"> * @ireq: the handle to the io request object to complete.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">sci_status</span> <span class="nf">sci_controller_complete_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">isci_remote_device</span> <span class="o">*</span><span class="n">idev</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">isci_request</span> <span class="o">*</span><span class="n">ireq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">sci_status</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">index</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">sm</span><span class="p">.</span><span class="n">current_state_id</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SCIC_STOPPING</span>:
		<span class="cm">/* XXX: Implement this function */</span>
		<span class="k">return</span> <span class="n">SCI_FAILURE</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCIC_READY</span>:
		<span class="n">status</span> <span class="o">=</span> <span class="n">sci_remote_device_complete_io</span><span class="p">(</span><span class="n">ihost</span><span class="p">,</span> <span class="n">idev</span><span class="p">,</span> <span class="n">ireq</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">SCI_SUCCESS</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">status</span><span class="p">;</span>

		<span class="n">index</span> <span class="o">=</span> <span class="n">ISCI_TAG_TCI</span><span class="p">(</span><span class="n">ireq</span><span class="o">-&gt;</span><span class="n">io_tag</span><span class="p">);</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">IREQ_ACTIVE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ireq</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">SCI_SUCCESS</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s invalid state: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">__func__</span><span class="p">,</span> <span class="n">ihost</span><span class="o">-&gt;</span><span class="n">sm</span><span class="p">.</span><span class="n">current_state_id</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">SCI_FAILURE_INVALID_STATE</span><span class="p">;</span>
	<span class="p">}</span>

<span class="p">}</span>

<span class="k">enum</span> <span class="n">sci_status</span> <span class="nf">sci_controller_continue_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_request</span> <span class="o">*</span><span class="n">ireq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span> <span class="o">=</span> <span class="n">ireq</span><span class="o">-&gt;</span><span class="n">owning_controller</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">sm</span><span class="p">.</span><span class="n">current_state_id</span> <span class="o">!=</span> <span class="n">SCIC_READY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s invalid state: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">__func__</span><span class="p">,</span> <span class="n">ihost</span><span class="o">-&gt;</span><span class="n">sm</span><span class="p">.</span><span class="n">current_state_id</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">SCI_FAILURE_INVALID_STATE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">set_bit</span><span class="p">(</span><span class="n">IREQ_ACTIVE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ireq</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">sci_controller_post_request</span><span class="p">(</span><span class="n">ihost</span><span class="p">,</span> <span class="n">ireq</span><span class="o">-&gt;</span><span class="n">post_context</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">SCI_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sci_controller_start_task() - This method is called by the SCIC user to</span>
<span class="cm"> *    send/start a framework task management request.</span>
<span class="cm"> * @controller: the handle to the controller object for which to start the task</span>
<span class="cm"> *    management request.</span>
<span class="cm"> * @remote_device: the handle to the remote device object for which to start</span>
<span class="cm"> *    the task management request.</span>
<span class="cm"> * @task_request: the handle to the task request object to start.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">sci_task_status</span> <span class="nf">sci_controller_start_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">,</span>
					       <span class="k">struct</span> <span class="n">isci_remote_device</span> <span class="o">*</span><span class="n">idev</span><span class="p">,</span>
					       <span class="k">struct</span> <span class="n">isci_request</span> <span class="o">*</span><span class="n">ireq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">sci_status</span> <span class="n">status</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">sm</span><span class="p">.</span><span class="n">current_state_id</span> <span class="o">!=</span> <span class="n">SCIC_READY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			 <span class="s">&quot;%s: SCIC Controller starting task from invalid &quot;</span>
			 <span class="s">&quot;state</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">SCI_TASK_FAILURE_INVALID_STATE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">sci_remote_device_start_task</span><span class="p">(</span><span class="n">ihost</span><span class="p">,</span> <span class="n">idev</span><span class="p">,</span> <span class="n">ireq</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SCI_FAILURE_RESET_DEVICE_PARTIAL_SUCCESS</span>:
		<span class="n">set_bit</span><span class="p">(</span><span class="n">IREQ_ACTIVE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ireq</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * We will let framework know this task request started successfully,</span>
<span class="cm">		 * although core is still woring on starting the request (to post tc when</span>
<span class="cm">		 * RNC is resumed.)</span>
<span class="cm">		 */</span>
		<span class="k">return</span> <span class="n">SCI_SUCCESS</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCI_SUCCESS</span>:
		<span class="n">set_bit</span><span class="p">(</span><span class="n">IREQ_ACTIVE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ireq</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">sci_controller_post_request</span><span class="p">(</span><span class="n">ihost</span><span class="p">,</span> <span class="n">ireq</span><span class="o">-&gt;</span><span class="n">post_context</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sci_write_gpio_tx_gp</span><span class="p">(</span><span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span><span class="p">,</span> <span class="n">u8</span> <span class="n">reg_index</span><span class="p">,</span> <span class="n">u8</span> <span class="n">reg_count</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">write_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">d</span><span class="p">;</span>

	<span class="cm">/* no support for TX_GP_CFG */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reg_index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">d</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="n">isci_gpio_count</span><span class="p">(</span><span class="n">ihost</span><span class="p">);</span> <span class="n">d</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">val</span> <span class="o">=</span> <span class="mh">0x444</span><span class="p">;</span> <span class="cm">/* all ODx.n clear */</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">bit</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>

			<span class="n">bit</span> <span class="o">=</span> <span class="n">try_test_sas_gpio_gp_bit</span><span class="p">(</span><span class="n">to_sas_gpio_od</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span>
						       <span class="n">write_data</span><span class="p">,</span> <span class="n">reg_index</span><span class="p">,</span>
						       <span class="n">reg_count</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bit</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="cm">/* if od is set, clear the &#39;invert&#39; bit */</span>
			<span class="n">val</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">bit</span> <span class="o">&lt;&lt;</span> <span class="p">((</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">));</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ihost</span><span class="o">-&gt;</span><span class="n">scu_registers</span><span class="o">-&gt;</span><span class="n">peg0</span><span class="p">.</span><span class="n">sgpio</span><span class="p">.</span><span class="n">output_data_select</span><span class="p">[</span><span class="n">d</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="cm">/* unless reg_index is &gt; 1, we should always be able to write at</span>
<span class="cm">	 * least one register</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">d</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">isci_gpio_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">sas_ha_struct</span> <span class="o">*</span><span class="n">sas_ha</span><span class="p">,</span> <span class="n">u8</span> <span class="n">reg_type</span><span class="p">,</span> <span class="n">u8</span> <span class="n">reg_index</span><span class="p">,</span>
		    <span class="n">u8</span> <span class="n">reg_count</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">write_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">isci_host</span> <span class="o">*</span><span class="n">ihost</span> <span class="o">=</span> <span class="n">sas_ha</span><span class="o">-&gt;</span><span class="n">lldd_ha</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">written</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">reg_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SAS_GPIO_REG_TX_GP</span>:
		<span class="n">written</span> <span class="o">=</span> <span class="n">sci_write_gpio_tx_gp</span><span class="p">(</span><span class="n">ihost</span><span class="p">,</span> <span class="n">reg_index</span><span class="p">,</span> <span class="n">reg_count</span><span class="p">,</span> <span class="n">write_data</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">written</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">written</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
