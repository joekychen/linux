<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › scsi › megaraid › mbox_defs.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>mbox_defs.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *</span>
<span class="cm"> *			Linux MegaRAID Unified device driver</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2003-2004  LSI Logic Corporation.</span>
<span class="cm"> *</span>
<span class="cm"> *	   This program is free software; you can redistribute it and/or</span>
<span class="cm"> *	   modify it under the terms of the GNU General Public License</span>
<span class="cm"> *	   as published by the Free Software Foundation; either version</span>
<span class="cm"> *	   2 of the License, or (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * FILE		: mbox_defs.h</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="cp">#ifndef _MRAID_MBOX_DEFS_H_</span>
<span class="cp">#define _MRAID_MBOX_DEFS_H_</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * Commands and states for mailbox based controllers</span>
<span class="cm"> */</span>

<span class="cp">#define MBOXCMD_LREAD		0x01</span>
<span class="cp">#define MBOXCMD_LWRITE		0x02</span>
<span class="cp">#define MBOXCMD_PASSTHRU	0x03</span>
<span class="cp">#define MBOXCMD_ADPEXTINQ	0x04</span>
<span class="cp">#define MBOXCMD_ADAPTERINQ	0x05</span>
<span class="cp">#define MBOXCMD_LREAD64		0xA7</span>
<span class="cp">#define MBOXCMD_LWRITE64	0xA8</span>
<span class="cp">#define MBOXCMD_PASSTHRU64	0xC3</span>
<span class="cp">#define MBOXCMD_EXTPTHRU	0xE3</span>

<span class="cp">#define MAIN_MISC_OPCODE	0xA4</span>
<span class="cp">#define GET_MAX_SG_SUPPORT	0x01</span>
<span class="cp">#define SUPPORT_EXT_CDB		0x16</span>

<span class="cp">#define FC_NEW_CONFIG		0xA1</span>
<span class="cp">#define NC_SUBOP_PRODUCT_INFO	0x0E</span>
<span class="cp">#define NC_SUBOP_ENQUIRY3	0x0F</span>
<span class="cp">#define ENQ3_GET_SOLICITED_FULL	0x02</span>
<span class="cp">#define OP_DCMD_READ_CONFIG	0x04</span>
<span class="cp">#define NEW_READ_CONFIG_8LD	0x67</span>
<span class="cp">#define READ_CONFIG_8LD		0x07</span>
<span class="cp">#define FLUSH_ADAPTER		0x0A</span>
<span class="cp">#define FLUSH_SYSTEM		0xFE</span>

<span class="cm">/*</span>
<span class="cm"> * Command for random deletion of logical drives</span>
<span class="cm"> */</span>
<span class="cp">#define	FC_DEL_LOGDRV		0xA4</span>
<span class="cp">#define	OP_SUP_DEL_LOGDRV	0x2A</span>
<span class="cp">#define OP_GET_LDID_MAP		0x18</span>
<span class="cp">#define OP_DEL_LOGDRV		0x1C</span>

<span class="cm">/*</span>
<span class="cm"> * BIOS commands</span>
<span class="cm"> */</span>
<span class="cp">#define IS_BIOS_ENABLED		0x62</span>
<span class="cp">#define GET_BIOS		0x01</span>
<span class="cp">#define CHNL_CLASS		0xA9</span>
<span class="cp">#define GET_CHNL_CLASS		0x00</span>
<span class="cp">#define SET_CHNL_CLASS		0x01</span>
<span class="cp">#define CH_RAID			0x01</span>
<span class="cp">#define CH_SCSI			0x00</span>
<span class="cp">#define BIOS_PVT_DATA		0x40</span>
<span class="cp">#define GET_BIOS_PVT_DATA	0x00</span>


<span class="cm">/*</span>
<span class="cm"> * Commands to support clustering</span>
<span class="cm"> */</span>
<span class="cp">#define GET_TARGET_ID		0x7D</span>
<span class="cp">#define CLUSTER_OP		0x70</span>
<span class="cp">#define GET_CLUSTER_MODE	0x02</span>
<span class="cp">#define CLUSTER_CMD		0x6E</span>
<span class="cp">#define RESERVE_LD		0x01</span>
<span class="cp">#define RELEASE_LD		0x02</span>
<span class="cp">#define RESET_RESERVATIONS	0x03</span>
<span class="cp">#define RESERVATION_STATUS	0x04</span>
<span class="cp">#define RESERVE_PD		0x05</span>
<span class="cp">#define RELEASE_PD		0x06</span>


<span class="cm">/*</span>
<span class="cm"> * Module battery status</span>
<span class="cm"> */</span>
<span class="cp">#define BATTERY_MODULE_MISSING		0x01</span>
<span class="cp">#define BATTERY_LOW_VOLTAGE		0x02</span>
<span class="cp">#define BATTERY_TEMP_HIGH		0x04</span>
<span class="cp">#define BATTERY_PACK_MISSING		0x08</span>
<span class="cp">#define BATTERY_CHARGE_MASK		0x30</span>
<span class="cp">#define BATTERY_CHARGE_DONE		0x00</span>
<span class="cp">#define BATTERY_CHARGE_INPROG		0x10</span>
<span class="cp">#define BATTERY_CHARGE_FAIL		0x20</span>
<span class="cp">#define BATTERY_CYCLES_EXCEEDED		0x40</span>

<span class="cm">/*</span>
<span class="cm"> * Physical drive states.</span>
<span class="cm"> */</span>
<span class="cp">#define PDRV_UNCNF	0</span>
<span class="cp">#define PDRV_ONLINE	3</span>
<span class="cp">#define PDRV_FAILED	4</span>
<span class="cp">#define PDRV_RBLD	5</span>
<span class="cp">#define PDRV_HOTSPARE	6</span>


<span class="cm">/*</span>
<span class="cm"> * Raid logical drive states.</span>
<span class="cm"> */</span>
<span class="cp">#define RDRV_OFFLINE	0</span>
<span class="cp">#define RDRV_DEGRADED	1</span>
<span class="cp">#define RDRV_OPTIMAL	2</span>
<span class="cp">#define RDRV_DELETED	3</span>

<span class="cm">/*</span>
<span class="cm"> * Read, write and cache policies</span>
<span class="cm"> */</span>
<span class="cp">#define NO_READ_AHEAD		0</span>
<span class="cp">#define READ_AHEAD		1</span>
<span class="cp">#define ADAP_READ_AHEAD		2</span>
<span class="cp">#define WRMODE_WRITE_THRU	0</span>
<span class="cp">#define WRMODE_WRITE_BACK	1</span>
<span class="cp">#define CACHED_IO		0</span>
<span class="cp">#define DIRECT_IO		1</span>

<span class="cp">#define MAX_LOGICAL_DRIVES_8LD		8</span>
<span class="cp">#define MAX_LOGICAL_DRIVES_40LD		40</span>
<span class="cp">#define FC_MAX_PHYSICAL_DEVICES		256</span>
<span class="cp">#define MAX_MBOX_CHANNELS		5</span>
<span class="cp">#define MAX_MBOX_TARGET			15</span>
<span class="cp">#define MBOX_MAX_PHYSICAL_DRIVES	MAX_MBOX_CHANNELS*MAX_MBOX_TARGET</span>
<span class="cp">#define MAX_ROW_SIZE_40LD		32</span>
<span class="cp">#define MAX_ROW_SIZE_8LD		8</span>
<span class="cp">#define SPAN_DEPTH_8_SPANS		8</span>
<span class="cp">#define SPAN_DEPTH_4_SPANS		4</span>
<span class="cp">#define MAX_REQ_SENSE_LEN		0x20</span>



<span class="cm">/**</span>
<span class="cm"> * struct mbox_t - Driver and f/w handshake structure.</span>
<span class="cm"> * @cmd		: firmware command</span>
<span class="cm"> * @cmdid	: command id</span>
<span class="cm"> * @numsectors	: number of sectors to be transferred</span>
<span class="cm"> * @lba		: Logical Block Address on LD</span>
<span class="cm"> * @xferaddr	: DMA address for data transfer</span>
<span class="cm"> * @logdrv	: logical drive number</span>
<span class="cm"> * @numsge	: number of scatter gather elements in sg list</span>
<span class="cm"> * @resvd	: reserved</span>
<span class="cm"> * @busy	: f/w busy, must wait to issue more commands.</span>
<span class="cm"> * @numstatus	: number of commands completed.</span>
<span class="cm"> * @status	: status of the commands completed</span>
<span class="cm"> * @completed	: array of completed command ids.</span>
<span class="cm"> * @poll	: poll and ack sequence</span>
<span class="cm"> * @ack		: poll and ack sequence</span>
<span class="cm"> *</span>
<span class="cm"> * The central handshake structure between the driver and the firmware. This</span>
<span class="cm"> * structure must be allocated by the driver and aligned at 8-byte boundary.</span>
<span class="cm"> */</span>
<span class="cp">#define MBOX_MAX_FIRMWARE_STATUS	46</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">uint8_t</span>		<span class="n">cmd</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">cmdid</span><span class="p">;</span>
	<span class="kt">uint16_t</span>	<span class="n">numsectors</span><span class="p">;</span>
	<span class="kt">uint32_t</span>	<span class="n">lba</span><span class="p">;</span>
	<span class="kt">uint32_t</span>	<span class="n">xferaddr</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">logdrv</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">numsge</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">resvd</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">busy</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">numstatus</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">status</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">completed</span><span class="p">[</span><span class="n">MBOX_MAX_FIRMWARE_STATUS</span><span class="p">];</span>
	<span class="kt">uint8_t</span>		<span class="n">poll</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">ack</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">mbox_t</span><span class="p">;</span>


<span class="cm">/**</span>
<span class="cm"> * mbox64_t - 64-bit extension for the mailbox</span>
<span class="cm"> * @segment_lo	: the low 32-bits of the address of the scatter-gather list</span>
<span class="cm"> * @segment_hi	: the upper 32-bits of the address of the scatter-gather list</span>
<span class="cm"> * @mbox	: 32-bit mailbox, whose xferadder field must be set to</span>
<span class="cm"> *		0xFFFFFFFF</span>
<span class="cm"> *</span>
<span class="cm"> * This is the extension of the 32-bit mailbox to be able to perform DMA</span>
<span class="cm"> * beyond 4GB address range.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">uint32_t</span>	<span class="n">xferaddr_lo</span><span class="p">;</span>
	<span class="kt">uint32_t</span>	<span class="n">xferaddr_hi</span><span class="p">;</span>
	<span class="n">mbox_t</span>		<span class="n">mbox32</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">mbox64_t</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * mailbox structure used for internal commands</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">u8</span>	<span class="n">cmd</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">cmdid</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">opcode</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">subopcode</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">lba</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">xferaddr</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">logdrv</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">rsvd</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="n">u8</span>	<span class="n">numstatus</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">status</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">int_mbox_t</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * mraid_passthru_t - passthru structure to issue commands to physical devices</span>
<span class="cm"> * @timeout		: command timeout, 0=6sec, 1=60sec, 2=10min, 3=3hr</span>
<span class="cm"> * @ars			: set if ARS required after check condition</span>
<span class="cm"> * @islogical		: set if command meant for logical devices</span>
<span class="cm"> * @logdrv		: logical drive number if command for LD</span>
<span class="cm"> * @channel		: Channel on which physical device is located</span>
<span class="cm"> * @target		: SCSI target of the device</span>
<span class="cm"> * @queuetag		: unused</span>
<span class="cm"> * @queueaction		: unused</span>
<span class="cm"> * @cdb			: SCSI CDB</span>
<span class="cm"> * @cdblen		: length of the CDB</span>
<span class="cm"> * @reqsenselen		: amount of request sense data to be returned</span>
<span class="cm"> * @reqsensearea	: Sense information buffer</span>
<span class="cm"> * @numsge		: number of scatter-gather elements in the sg list</span>
<span class="cm"> * @scsistatus		: SCSI status of the command completed.</span>
<span class="cm"> * @dataxferaddr	: DMA data transfer address</span>
<span class="cm"> * @dataxferlen		: amount of the data to be transferred.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">uint8_t</span>		<span class="n">timeout</span>		<span class="o">:</span><span class="mi">3</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">ars</span>		<span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">reserved</span>	<span class="o">:</span><span class="mi">3</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">islogical</span>	<span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">logdrv</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">channel</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">target</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">queuetag</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">queueaction</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">cdb</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
	<span class="kt">uint8_t</span>		<span class="n">cdblen</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">reqsenselen</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">reqsensearea</span><span class="p">[</span><span class="n">MAX_REQ_SENSE_LEN</span><span class="p">];</span>
	<span class="kt">uint8_t</span>		<span class="n">numsge</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">scsistatus</span><span class="p">;</span>
	<span class="kt">uint32_t</span>	<span class="n">dataxferaddr</span><span class="p">;</span>
	<span class="kt">uint32_t</span>	<span class="n">dataxferlen</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">mraid_passthru_t</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>

	<span class="kt">uint32_t</span>		<span class="n">dataxferaddr_lo</span><span class="p">;</span>
	<span class="kt">uint32_t</span>		<span class="n">dataxferaddr_hi</span><span class="p">;</span>
	<span class="n">mraid_passthru_t</span>	<span class="n">pthru32</span><span class="p">;</span>

<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">mega_passthru64_t</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * mraid_epassthru_t - passthru structure to issue commands to physical devices</span>
<span class="cm"> * @timeout		: command timeout, 0=6sec, 1=60sec, 2=10min, 3=3hr</span>
<span class="cm"> * @ars			: set if ARS required after check condition</span>
<span class="cm"> * @rsvd1		: reserved field</span>
<span class="cm"> * @cd_rom		: (?)</span>
<span class="cm"> * @rsvd2		: reserved field</span>
<span class="cm"> * @islogical		: set if command meant for logical devices</span>
<span class="cm"> * @logdrv		: logical drive number if command for LD</span>
<span class="cm"> * @channel		: Channel on which physical device is located</span>
<span class="cm"> * @target		: SCSI target of the device</span>
<span class="cm"> * @queuetag		: unused</span>
<span class="cm"> * @queueaction		: unused</span>
<span class="cm"> * @cdblen		: length of the CDB</span>
<span class="cm"> * @rsvd3		: reserved field</span>
<span class="cm"> * @cdb			: SCSI CDB</span>
<span class="cm"> * @numsge		: number of scatter-gather elements in the sg list</span>
<span class="cm"> * @status		: SCSI status of the command completed.</span>
<span class="cm"> * @reqsenselen		: amount of request sense data to be returned</span>
<span class="cm"> * @reqsensearea	: Sense information buffer</span>
<span class="cm"> * @rsvd4		: reserved field</span>
<span class="cm"> * @dataxferaddr	: DMA data transfer address</span>
<span class="cm"> * @dataxferlen		: amount of the data to be transferred.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">uint8_t</span>		<span class="n">timeout</span>		<span class="o">:</span><span class="mi">3</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">ars</span>		<span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">rsvd1</span>		<span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">cd_rom</span>		<span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">rsvd2</span>		<span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">islogical</span>	<span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">logdrv</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">channel</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">target</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">queuetag</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">queueaction</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">cdblen</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">rsvd3</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">cdb</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
	<span class="kt">uint8_t</span>		<span class="n">numsge</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">status</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">reqsenselen</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">reqsensearea</span><span class="p">[</span><span class="n">MAX_REQ_SENSE_LEN</span><span class="p">];</span>
	<span class="kt">uint8_t</span>		<span class="n">rsvd4</span><span class="p">;</span>
	<span class="kt">uint32_t</span>	<span class="n">dataxferaddr</span><span class="p">;</span>
	<span class="kt">uint32_t</span>	<span class="n">dataxferlen</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">mraid_epassthru_t</span><span class="p">;</span>


<span class="cm">/**</span>
<span class="cm"> * mraid_pinfo_t - product info, static information about the controller</span>
<span class="cm"> * @data_size		: current size in bytes (not including resvd)</span>
<span class="cm"> * @config_signature	: Current value is 0x00282008</span>
<span class="cm"> * @fw_version		: Firmware version</span>
<span class="cm"> * @bios_version	: version of the BIOS</span>
<span class="cm"> * @product_name	: Name given to the controller</span>
<span class="cm"> * @max_commands	: Maximum concurrent commands supported</span>
<span class="cm"> * @nchannels		: Number of SCSI Channels detected</span>
<span class="cm"> * @fc_loop_present	: Number of Fibre Loops detected</span>
<span class="cm"> * @mem_type		: EDO, FPM, SDRAM etc</span>
<span class="cm"> * @signature		:</span>
<span class="cm"> * @dram_size		: In terms of MB</span>
<span class="cm"> * @subsysid		: device PCI subsystem ID</span>
<span class="cm"> * @subsysvid		: device PCI subsystem vendor ID</span>
<span class="cm"> * @notify_counters	:</span>
<span class="cm"> * @pad1k		: 135 + 889 resvd = 1024 total size</span>
<span class="cm"> *</span>
<span class="cm"> * This structures holds the information about the controller which is not</span>
<span class="cm"> * expected to change dynamically.</span>
<span class="cm"> *</span>
<span class="cm"> * The current value of config signature is 0x00282008:</span>
<span class="cm"> * 0x28 = MAX_LOGICAL_DRIVES,</span>
<span class="cm"> * 0x20 = Number of stripes and</span>
<span class="cm"> * 0x08 = Number of spans</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">uint32_t</span>	<span class="n">data_size</span><span class="p">;</span>
	<span class="kt">uint32_t</span>	<span class="n">config_signature</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">fw_version</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
	<span class="kt">uint8_t</span>		<span class="n">bios_version</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
	<span class="kt">uint8_t</span>		<span class="n">product_name</span><span class="p">[</span><span class="mi">80</span><span class="p">];</span>
	<span class="kt">uint8_t</span>		<span class="n">max_commands</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">nchannels</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">fc_loop_present</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">mem_type</span><span class="p">;</span>
	<span class="kt">uint32_t</span>	<span class="n">signature</span><span class="p">;</span>
	<span class="kt">uint16_t</span>	<span class="n">dram_size</span><span class="p">;</span>
	<span class="kt">uint16_t</span>	<span class="n">subsysid</span><span class="p">;</span>
	<span class="kt">uint16_t</span>	<span class="n">subsysvid</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">notify_counters</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">pad1k</span><span class="p">[</span><span class="mi">889</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">mraid_pinfo_t</span><span class="p">;</span>


<span class="cm">/**</span>
<span class="cm"> * mraid_notify_t - the notification structure</span>
<span class="cm"> * @global_counter		: Any change increments this counter</span>
<span class="cm"> * @param_counter		: Indicates any params changed</span>
<span class="cm"> * @param_id			: Param modified - defined below</span>
<span class="cm"> * @param_val			: New val of last param modified</span>
<span class="cm"> * @write_config_counter	: write config occurred</span>
<span class="cm"> * @write_config_rsvd		:</span>
<span class="cm"> * @ldrv_op_counter		: Indicates ldrv op started/completed</span>
<span class="cm"> * @ldrv_opid			: ldrv num</span>
<span class="cm"> * @ldrv_opcmd			: ldrv operation - defined below</span>
<span class="cm"> * @ldrv_opstatus		: status of the operation</span>
<span class="cm"> * @ldrv_state_counter		: Indicates change of ldrv state</span>
<span class="cm"> * @ldrv_state_id		: ldrv num</span>
<span class="cm"> * @ldrv_state_new		: New state</span>
<span class="cm"> * @ldrv_state_old		: old state</span>
<span class="cm"> * @pdrv_state_counter		: Indicates change of ldrv state</span>
<span class="cm"> * @pdrv_state_id		: pdrv id</span>
<span class="cm"> * @pdrv_state_new		: New state</span>
<span class="cm"> * @pdrv_state_old		: old state</span>
<span class="cm"> * @pdrv_fmt_counter		: Indicates pdrv format started/over</span>
<span class="cm"> * @pdrv_fmt_id			: pdrv id</span>
<span class="cm"> * @pdrv_fmt_val		: format started/over</span>
<span class="cm"> * @pdrv_fmt_rsvd		:</span>
<span class="cm"> * @targ_xfer_counter		: Indicates SCSI-2 Xfer rate change</span>
<span class="cm"> * @targ_xfer_id		: pdrv Id</span>
<span class="cm"> * @targ_xfer_val		: new Xfer params of last pdrv</span>
<span class="cm"> * @targ_xfer_rsvd		:</span>
<span class="cm"> * @fcloop_id_chg_counter	: Indicates loopid changed</span>
<span class="cm"> * @fcloopid_pdrvid		: pdrv id</span>
<span class="cm"> * @fcloop_id0			: loopid on fc loop 0</span>
<span class="cm"> * @fcloop_id1			: loopid on fc loop 1</span>
<span class="cm"> * @fcloop_state_counter	: Indicates loop state changed</span>
<span class="cm"> * @fcloop_state0		: state of fc loop 0</span>
<span class="cm"> * @fcloop_state1		: state of fc loop 1</span>
<span class="cm"> * @fcloop_state_rsvd		:</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">uint32_t</span>	<span class="n">global_counter</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">param_counter</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">param_id</span><span class="p">;</span>
	<span class="kt">uint16_t</span>	<span class="n">param_val</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">write_config_counter</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">write_config_rsvd</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="kt">uint8_t</span>		<span class="n">ldrv_op_counter</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">ldrv_opid</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">ldrv_opcmd</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">ldrv_opstatus</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">ldrv_state_counter</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">ldrv_state_id</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">ldrv_state_new</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">ldrv_state_old</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">pdrv_state_counter</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">pdrv_state_id</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">pdrv_state_new</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">pdrv_state_old</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">pdrv_fmt_counter</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">pdrv_fmt_id</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">pdrv_fmt_val</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">pdrv_fmt_rsvd</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">targ_xfer_counter</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">targ_xfer_id</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">targ_xfer_val</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">targ_xfer_rsvd</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">fcloop_id_chg_counter</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">fcloopid_pdrvid</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">fcloop_id0</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">fcloop_id1</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">fcloop_state_counter</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">fcloop_state0</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">fcloop_state1</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">fcloop_state_rsvd</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">mraid_notify_t</span><span class="p">;</span>


<span class="cm">/**</span>
<span class="cm"> * mraid_inquiry3_t - enquiry for device information</span>
<span class="cm"> *</span>
<span class="cm"> * @data_size		: current size in bytes (not including resvd)</span>
<span class="cm"> * @notify		:</span>
<span class="cm"> * @notify_rsvd		:</span>
<span class="cm"> * @rebuild_rate	: rebuild rate (0% - 100%)</span>
<span class="cm"> * @cache_flush_int	: cache flush interval in seconds</span>
<span class="cm"> * @sense_alert		:</span>
<span class="cm"> * @drive_insert_count	: drive insertion count</span>
<span class="cm"> * @battery_status	:</span>
<span class="cm"> * @num_ldrv		: no. of Log Drives configured</span>
<span class="cm"> * @recon_state		: state of reconstruct</span>
<span class="cm"> * @ldrv_op_status	: logdrv Status</span>
<span class="cm"> * @ldrv_size		: size of each log drv</span>
<span class="cm"> * @ldrv_prop		:</span>
<span class="cm"> * @ldrv_state		: state of log drives</span>
<span class="cm"> * @pdrv_state		: state of phys drvs.</span>
<span class="cm"> * @pdrv_format		:</span>
<span class="cm"> * @targ_xfer		: phys device transfer rate</span>
<span class="cm"> * @pad1k		: 761 + 263reserved = 1024 bytes total size</span>
<span class="cm"> */</span>
<span class="cp">#define MAX_NOTIFY_SIZE		0x80</span>
<span class="cp">#define CUR_NOTIFY_SIZE		sizeof(mraid_notify_t)</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">uint32_t</span>	<span class="n">data_size</span><span class="p">;</span>

	<span class="n">mraid_notify_t</span>	<span class="n">notify</span><span class="p">;</span>

	<span class="kt">uint8_t</span>		<span class="n">notify_rsvd</span><span class="p">[</span><span class="n">MAX_NOTIFY_SIZE</span> <span class="o">-</span> <span class="n">CUR_NOTIFY_SIZE</span><span class="p">];</span>

	<span class="kt">uint8_t</span>		<span class="n">rebuild_rate</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">cache_flush_int</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">sense_alert</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">drive_insert_count</span><span class="p">;</span>

	<span class="kt">uint8_t</span>		<span class="n">battery_status</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">num_ldrv</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">recon_state</span><span class="p">[</span><span class="n">MAX_LOGICAL_DRIVES_40LD</span> <span class="o">/</span> <span class="mi">8</span><span class="p">];</span>
	<span class="kt">uint16_t</span>	<span class="n">ldrv_op_status</span><span class="p">[</span><span class="n">MAX_LOGICAL_DRIVES_40LD</span> <span class="o">/</span> <span class="mi">8</span><span class="p">];</span>

	<span class="kt">uint32_t</span>	<span class="n">ldrv_size</span><span class="p">[</span><span class="n">MAX_LOGICAL_DRIVES_40LD</span><span class="p">];</span>
	<span class="kt">uint8_t</span>		<span class="n">ldrv_prop</span><span class="p">[</span><span class="n">MAX_LOGICAL_DRIVES_40LD</span><span class="p">];</span>
	<span class="kt">uint8_t</span>		<span class="n">ldrv_state</span><span class="p">[</span><span class="n">MAX_LOGICAL_DRIVES_40LD</span><span class="p">];</span>
	<span class="kt">uint8_t</span>		<span class="n">pdrv_state</span><span class="p">[</span><span class="n">FC_MAX_PHYSICAL_DEVICES</span><span class="p">];</span>
	<span class="kt">uint16_t</span>	<span class="n">pdrv_format</span><span class="p">[</span><span class="n">FC_MAX_PHYSICAL_DEVICES</span> <span class="o">/</span> <span class="mi">16</span><span class="p">];</span>

	<span class="kt">uint8_t</span>		<span class="n">targ_xfer</span><span class="p">[</span><span class="mi">80</span><span class="p">];</span>
	<span class="kt">uint8_t</span>		<span class="n">pad1k</span><span class="p">[</span><span class="mi">263</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">mraid_inquiry3_t</span><span class="p">;</span>


<span class="cm">/**</span>
<span class="cm"> * mraid_adapinfo_t - information about the adapter</span>
<span class="cm"> * @max_commands		: max concurrent commands supported</span>
<span class="cm"> * @rebuild_rate		: rebuild rate - 0% thru 100%</span>
<span class="cm"> * @max_targ_per_chan		: max targ per channel</span>
<span class="cm"> * @nchannels			: number of channels on HBA</span>
<span class="cm"> * @fw_version			: firmware version</span>
<span class="cm"> * @age_of_flash		: number of times FW has been flashed</span>
<span class="cm"> * @chip_set_value		: contents of 0xC0000832</span>
<span class="cm"> * @dram_size			: in MB</span>
<span class="cm"> * @cache_flush_interval	: in seconds</span>
<span class="cm"> * @bios_version		:</span>
<span class="cm"> * @board_type			:</span>
<span class="cm"> * @sense_alert			:</span>
<span class="cm"> * @write_config_count		: increase with every configuration change</span>
<span class="cm"> * @drive_inserted_count	: increase with every drive inserted</span>
<span class="cm"> * @inserted_drive		: channel:Id of inserted drive</span>
<span class="cm"> * @battery_status		: bit 0: battery module missing</span>
<span class="cm"> *				bit 1: VBAD</span>
<span class="cm"> *				bit 2: temperature high</span>
<span class="cm"> *				bit 3: battery pack missing</span>
<span class="cm"> *				bit 4,5:</span>
<span class="cm"> *					00 - charge complete</span>
<span class="cm"> *					01 - fast charge in progress</span>
<span class="cm"> *					10 - fast charge fail</span>
<span class="cm"> *					11 - undefined</span>
<span class="cm"> *				bit 6: counter &gt; 1000</span>
<span class="cm"> *				bit 7: Undefined</span>
<span class="cm"> * @dec_fault_bus_info		:</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">uint8_t</span>		<span class="n">max_commands</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">rebuild_rate</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">max_targ_per_chan</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">nchannels</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">fw_version</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="kt">uint16_t</span>	<span class="n">age_of_flash</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">chip_set_value</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">dram_size</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">cache_flush_interval</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">bios_version</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="kt">uint8_t</span>		<span class="n">board_type</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">sense_alert</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">write_config_count</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">battery_status</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">dec_fault_bus_info</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">mraid_adapinfo_t</span><span class="p">;</span>


<span class="cm">/**</span>
<span class="cm"> * mraid_ldrv_info_t - information about the logical drives</span>
<span class="cm"> * @nldrv	: Number of logical drives configured</span>
<span class="cm"> * @rsvd	:</span>
<span class="cm"> * @size	: size of each logical drive</span>
<span class="cm"> * @prop	:</span>
<span class="cm"> * @state	: state of each logical drive</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">uint8_t</span>		<span class="n">nldrv</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">rsvd</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="kt">uint32_t</span>	<span class="n">size</span><span class="p">[</span><span class="n">MAX_LOGICAL_DRIVES_8LD</span><span class="p">];</span>
	<span class="kt">uint8_t</span>		<span class="n">prop</span><span class="p">[</span><span class="n">MAX_LOGICAL_DRIVES_8LD</span><span class="p">];</span>
	<span class="kt">uint8_t</span>		<span class="n">state</span><span class="p">[</span><span class="n">MAX_LOGICAL_DRIVES_8LD</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">mraid_ldrv_info_t</span><span class="p">;</span>


<span class="cm">/**</span>
<span class="cm"> * mraid_pdrv_info_t - information about the physical drives</span>
<span class="cm"> * @pdrv_state	: state of each physical drive</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">uint8_t</span>		<span class="n">pdrv_state</span><span class="p">[</span><span class="n">MBOX_MAX_PHYSICAL_DRIVES</span><span class="p">];</span>
	<span class="kt">uint8_t</span>		<span class="n">rsvd</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">mraid_pdrv_info_t</span><span class="p">;</span>


<span class="cm">/**</span>
<span class="cm"> * mraid_inquiry_t - RAID inquiry, mailbox command 0x05</span>
<span class="cm"> * @mraid_adapinfo_t	: adapter information</span>
<span class="cm"> * @mraid_ldrv_info_t	: logical drives information</span>
<span class="cm"> * @mraid_pdrv_info_t	: physical drives information</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">mraid_adapinfo_t</span>	<span class="n">adapter_info</span><span class="p">;</span>
	<span class="n">mraid_ldrv_info_t</span>	<span class="n">logdrv_info</span><span class="p">;</span>
	<span class="n">mraid_pdrv_info_t</span>	<span class="n">pdrv_info</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">mraid_inquiry_t</span><span class="p">;</span>


<span class="cm">/**</span>
<span class="cm"> * mraid_extinq_t - RAID extended inquiry, mailbox command 0x04</span>
<span class="cm"> *</span>
<span class="cm"> * @raid_inq		: raid inquiry</span>
<span class="cm"> * @phys_drv_format	:</span>
<span class="cm"> * @stack_attn		:</span>
<span class="cm"> * @modem_status	:</span>
<span class="cm"> * @rsvd		:</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">mraid_inquiry_t</span>	<span class="n">raid_inq</span><span class="p">;</span>
	<span class="kt">uint16_t</span>	<span class="n">phys_drv_format</span><span class="p">[</span><span class="n">MAX_MBOX_CHANNELS</span><span class="p">];</span>
	<span class="kt">uint8_t</span>		<span class="n">stack_attn</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">modem_status</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">rsvd</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">mraid_extinq_t</span><span class="p">;</span>


<span class="cm">/**</span>
<span class="cm"> * adap_device_t - device information</span>
<span class="cm"> * @channel	: channel fpor the device</span>
<span class="cm"> * @target	: target ID of the device</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">uint8_t</span>		<span class="n">channel</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">target</span><span class="p">;</span>
<span class="p">}</span><span class="n">__attribute__</span> <span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">adap_device_t</span><span class="p">;</span>


<span class="cm">/**</span>
<span class="cm"> * adap_span_40ld_t - 40LD span</span>
<span class="cm"> * @start_blk	: starting block</span>
<span class="cm"> * @num_blks	: number of blocks</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">uint32_t</span>	<span class="n">start_blk</span><span class="p">;</span>
	<span class="kt">uint32_t</span>	<span class="n">num_blks</span><span class="p">;</span>
	<span class="n">adap_device_t</span>	<span class="n">device</span><span class="p">[</span><span class="n">MAX_ROW_SIZE_40LD</span><span class="p">];</span>
<span class="p">}</span><span class="n">__attribute__</span> <span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">adap_span_40ld_t</span><span class="p">;</span>


<span class="cm">/**</span>
<span class="cm"> * adap_span_8ld_t - 8LD span</span>
<span class="cm"> * @start_blk	: starting block</span>
<span class="cm"> * @num_blks	: number of blocks</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">uint32_t</span>	<span class="n">start_blk</span><span class="p">;</span>
	<span class="kt">uint32_t</span>	<span class="n">num_blks</span><span class="p">;</span>
	<span class="n">adap_device_t</span>	<span class="n">device</span><span class="p">[</span><span class="n">MAX_ROW_SIZE_8LD</span><span class="p">];</span>
<span class="p">}</span><span class="n">__attribute__</span> <span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">adap_span_8ld_t</span><span class="p">;</span>


<span class="cm">/**</span>
<span class="cm"> * logdrv_param_t - logical drives parameters</span>
<span class="cm"> *</span>
<span class="cm"> * @span_depth	: total number of spans</span>
<span class="cm"> * @level	: RAID level</span>
<span class="cm"> * @read_ahead	: read ahead, no read ahead, adaptive read ahead</span>
<span class="cm"> * @stripe_sz	: encoded stripe size</span>
<span class="cm"> * @status	: status of the logical drive</span>
<span class="cm"> * @write_mode	: write mode, write_through/write_back</span>
<span class="cm"> * @direct_io	: direct io or through cache</span>
<span class="cm"> * @row_size	: number of stripes in a row</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">uint8_t</span>		<span class="n">span_depth</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">level</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">read_ahead</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">stripe_sz</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">status</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">write_mode</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">direct_io</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">row_size</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">logdrv_param_t</span><span class="p">;</span>


<span class="cm">/**</span>
<span class="cm"> * logdrv_40ld_t - logical drive definition for 40LD controllers</span>
<span class="cm"> * @lparam	: logical drives parameters</span>
<span class="cm"> * @span	: span</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">logdrv_param_t</span>		<span class="n">lparam</span><span class="p">;</span>
	<span class="n">adap_span_40ld_t</span>	<span class="n">span</span><span class="p">[</span><span class="n">SPAN_DEPTH_8_SPANS</span><span class="p">];</span>
<span class="p">}</span><span class="n">__attribute__</span> <span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">logdrv_40ld_t</span><span class="p">;</span>


<span class="cm">/**</span>
<span class="cm"> * logdrv_8ld_span8_t - logical drive definition for 8LD controllers</span>
<span class="cm"> * @lparam	: logical drives parameters</span>
<span class="cm"> * @span	: span</span>
<span class="cm"> *</span>
<span class="cm"> * 8-LD logical drive with up to 8 spans</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">logdrv_param_t</span>	<span class="n">lparam</span><span class="p">;</span>
	<span class="n">adap_span_8ld_t</span>	<span class="n">span</span><span class="p">[</span><span class="n">SPAN_DEPTH_8_SPANS</span><span class="p">];</span>
<span class="p">}</span><span class="n">__attribute__</span> <span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">logdrv_8ld_span8_t</span><span class="p">;</span>


<span class="cm">/**</span>
<span class="cm"> * logdrv_8ld_span4_t - logical drive definition for 8LD controllers</span>
<span class="cm"> * @lparam	: logical drives parameters</span>
<span class="cm"> * @span	: span</span>
<span class="cm"> *</span>
<span class="cm"> * 8-LD logical drive with up to 4 spans</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">logdrv_param_t</span>	<span class="n">lparam</span><span class="p">;</span>
	<span class="n">adap_span_8ld_t</span>	<span class="n">span</span><span class="p">[</span><span class="n">SPAN_DEPTH_4_SPANS</span><span class="p">];</span>
<span class="p">}</span><span class="n">__attribute__</span> <span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">logdrv_8ld_span4_t</span><span class="p">;</span>


<span class="cm">/**</span>
<span class="cm"> * phys_drive_t - physical device information</span>
<span class="cm"> * @type	: Type of the device</span>
<span class="cm"> * @cur_status	: current status of the device</span>
<span class="cm"> * @tag_depth	: Level of tagging</span>
<span class="cm"> * @sync_neg	: sync negotiation - ENABLE or DISABLE</span>
<span class="cm"> * @size	: configurable size in terms of 512 byte</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">uint8_t</span>		<span class="n">type</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">cur_status</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">tag_depth</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">sync_neg</span><span class="p">;</span>
	<span class="kt">uint32_t</span>	<span class="n">size</span><span class="p">;</span>
<span class="p">}</span><span class="n">__attribute__</span> <span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">phys_drive_t</span><span class="p">;</span>


<span class="cm">/**</span>
<span class="cm"> * disk_array_40ld_t - disk array for 40LD controllers</span>
<span class="cm"> * @numldrv	: number of logical drives</span>
<span class="cm"> * @resvd	:</span>
<span class="cm"> * @ldrv	: logical drives information</span>
<span class="cm"> * @pdrv	: physical drives information</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">uint8_t</span>		<span class="n">numldrv</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">resvd</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="n">logdrv_40ld_t</span>	<span class="n">ldrv</span><span class="p">[</span><span class="n">MAX_LOGICAL_DRIVES_40LD</span><span class="p">];</span>
	<span class="n">phys_drive_t</span>	<span class="n">pdrv</span><span class="p">[</span><span class="n">MBOX_MAX_PHYSICAL_DRIVES</span><span class="p">];</span>
<span class="p">}</span><span class="n">__attribute__</span> <span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">disk_array_40ld_t</span><span class="p">;</span>


<span class="cm">/**</span>
<span class="cm"> * disk_array_8ld_span8_t - disk array for 8LD controllers</span>
<span class="cm"> * @numldrv	: number of logical drives</span>
<span class="cm"> * @resvd	:</span>
<span class="cm"> * @ldrv	: logical drives information</span>
<span class="cm"> * @pdrv	: physical drives information</span>
<span class="cm"> *</span>
<span class="cm"> * Disk array for 8LD logical drives with up to 8 spans</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">uint8_t</span>			<span class="n">numldrv</span><span class="p">;</span>
	<span class="kt">uint8_t</span>			<span class="n">resvd</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="n">logdrv_8ld_span8_t</span>	<span class="n">ldrv</span><span class="p">[</span><span class="n">MAX_LOGICAL_DRIVES_8LD</span><span class="p">];</span>
	<span class="n">phys_drive_t</span>		<span class="n">pdrv</span><span class="p">[</span><span class="n">MBOX_MAX_PHYSICAL_DRIVES</span><span class="p">];</span>
<span class="p">}</span><span class="n">__attribute__</span> <span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">disk_array_8ld_span8_t</span><span class="p">;</span>


<span class="cm">/**</span>
<span class="cm"> * disk_array_8ld_span4_t - disk array for 8LD controllers</span>
<span class="cm"> * @numldrv	: number of logical drives</span>
<span class="cm"> * @resvd	:</span>
<span class="cm"> * @ldrv	: logical drives information</span>
<span class="cm"> * @pdrv	: physical drives information</span>
<span class="cm"> *</span>
<span class="cm"> * Disk array for 8LD logical drives with up to 4 spans</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">uint8_t</span>			<span class="n">numldrv</span><span class="p">;</span>
	<span class="kt">uint8_t</span>			<span class="n">resvd</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="n">logdrv_8ld_span4_t</span>	<span class="n">ldrv</span><span class="p">[</span><span class="n">MAX_LOGICAL_DRIVES_8LD</span><span class="p">];</span>
	<span class="n">phys_drive_t</span>		<span class="n">pdrv</span><span class="p">[</span><span class="n">MBOX_MAX_PHYSICAL_DRIVES</span><span class="p">];</span>
<span class="p">}</span><span class="n">__attribute__</span> <span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">disk_array_8ld_span4_t</span><span class="p">;</span>


<span class="cm">/**</span>
<span class="cm"> * struct private_bios_data - bios private data for boot devices</span>
<span class="cm"> * @geometry	: bits 0-3 - BIOS geometry, 0x0001 - 1GB, 0x0010 - 2GB,</span>
<span class="cm"> *		0x1000 - 8GB, Others values are invalid</span>
<span class="cm"> * @unused	: bits 4-7 are unused</span>
<span class="cm"> * @boot_drv	: logical drive set as boot drive, 0..7 - for 8LD cards,</span>
<span class="cm"> * 		0..39 - for 40LD cards</span>
<span class="cm"> * @cksum	: 0-(sum of first 13 bytes of this structure)</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">private_bios_data</span> <span class="p">{</span>
	<span class="kt">uint8_t</span>		<span class="n">geometry</span>	<span class="o">:</span><span class="mi">4</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">unused</span>		<span class="o">:</span><span class="mi">4</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">boot_drv</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">rsvd</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>
	<span class="kt">uint16_t</span>	<span class="n">cksum</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">packed</span><span class="p">));</span>


<span class="cm">/**</span>
<span class="cm"> * mbox_sgl64 - 64-bit scatter list for mailbox based controllers</span>
<span class="cm"> * @address	: address of the buffer</span>
<span class="cm"> * @length	: data transfer length</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">uint64_t</span>	<span class="n">address</span><span class="p">;</span>
	<span class="kt">uint32_t</span>	<span class="n">length</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">mbox_sgl64</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * mbox_sgl32 - 32-bit scatter list for mailbox based controllers</span>
<span class="cm"> * @address	: address of the buffer</span>
<span class="cm"> * @length	: data transfer length</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">uint32_t</span>	<span class="n">address</span><span class="p">;</span>
	<span class="kt">uint32_t</span>	<span class="n">length</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">mbox_sgl32</span><span class="p">;</span>

<span class="cp">#endif		</span><span class="c1">// _MRAID_MBOX_DEFS_H_</span>

<span class="cm">/* vim: set ts=8 sw=8 tw=78: */</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
