<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › scsi › megaraid › mega_common.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>mega_common.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *</span>
<span class="cm"> *			Linux MegaRAID device driver</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2003-2004  LSI Logic Corporation.</span>
<span class="cm"> *</span>
<span class="cm"> *	   This program is free software; you can redistribute it and/or</span>
<span class="cm"> *	   modify it under the terms of the GNU General Public License</span>
<span class="cm"> *	   as published by the Free Software Foundation; either version</span>
<span class="cm"> *	   2 of the License, or (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * FILE		: mega_common.h</span>
<span class="cm"> *</span>
<span class="cm"> * Libaray of common routine used by all low-level megaraid drivers</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _MEGA_COMMON_H_</span>
<span class="cp">#define _MEGA_COMMON_H_</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/moduleparam.h&gt;</span>
<span class="cp">#include &lt;linux/dma-mapping.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_cmnd.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_device.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_host.h&gt;</span>


<span class="cp">#define LSI_MAX_CHANNELS		16</span>
<span class="cp">#define LSI_MAX_LOGICAL_DRIVES_64LD	(64+1)</span>

<span class="cp">#define HBA_SIGNATURE_64_BIT		0x299</span>
<span class="cp">#define PCI_CONF_AMISIG64		0xa4</span>

<span class="cp">#define MEGA_SCSI_INQ_EVPD		1</span>
<span class="cp">#define MEGA_INVALID_FIELD_IN_CDB	0x24</span>


<span class="cm">/**</span>
<span class="cm"> * scb_t - scsi command control block</span>
<span class="cm"> * @ccb			: command control block for individual driver</span>
<span class="cm"> * @list		: list of control blocks</span>
<span class="cm"> * @gp			: general purpose field for LLDs</span>
<span class="cm"> * @sno			: all SCBs have a serial number</span>
<span class="cm"> * @scp			: associated scsi command</span>
<span class="cm"> * @state		: current state of scb</span>
<span class="cm"> * @dma_dir		: direction of data transfer</span>
<span class="cm"> * @dma_type		: transfer with sg list, buffer, or no data transfer</span>
<span class="cm"> * @dev_channel		: actual channel on the device</span>
<span class="cm"> * @dev_target		: actual target on the device</span>
<span class="cm"> * @status		: completion status</span>
<span class="cm"> *</span>
<span class="cm"> * This is our central data structure to issue commands the each driver.</span>
<span class="cm"> * Driver specific data structures are maintained in the ccb field.</span>
<span class="cm"> * scb provides a field &#39;gp&#39;, which can be used by LLD for its own purposes</span>
<span class="cm"> *</span>
<span class="cm"> * dev_channel and dev_target must be initialized with the actual channel and</span>
<span class="cm"> * target on the controller.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">caddr_t</span>			<span class="n">ccb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">list</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">gp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">sno</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span>	<span class="o">*</span><span class="n">scp</span><span class="p">;</span>
	<span class="kt">uint32_t</span>		<span class="n">state</span><span class="p">;</span>
	<span class="kt">uint32_t</span>		<span class="n">dma_direction</span><span class="p">;</span>
	<span class="kt">uint32_t</span>		<span class="n">dma_type</span><span class="p">;</span>
	<span class="kt">uint16_t</span>		<span class="n">dev_channel</span><span class="p">;</span>
	<span class="kt">uint16_t</span>		<span class="n">dev_target</span><span class="p">;</span>
	<span class="kt">uint32_t</span>		<span class="n">status</span><span class="p">;</span>
<span class="p">}</span> <span class="n">scb_t</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * SCB states as it transitions from one state to another</span>
<span class="cm"> */</span>
<span class="cp">#define SCB_FREE	0x0000	</span><span class="cm">/* on the free list */</span><span class="cp"></span>
<span class="cp">#define SCB_ACTIVE	0x0001	</span><span class="cm">/* off the free list */</span><span class="cp"></span>
<span class="cp">#define SCB_PENDQ	0x0002	</span><span class="cm">/* on the pending queue */</span><span class="cp"></span>
<span class="cp">#define SCB_ISSUED	0x0004	</span><span class="cm">/* issued - owner f/w */</span><span class="cp"></span>
<span class="cp">#define SCB_ABORT	0x0008	</span><span class="cm">/* Got an abort for this one */</span><span class="cp"></span>
<span class="cp">#define SCB_RESET	0x0010	</span><span class="cm">/* Got a reset for this one */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * DMA types for scb</span>
<span class="cm"> */</span>
<span class="cp">#define MRAID_DMA_NONE	0x0000	</span><span class="cm">/* no data transfer for this command */</span><span class="cp"></span>
<span class="cp">#define MRAID_DMA_WSG	0x0001	</span><span class="cm">/* data transfer using a sg list */</span><span class="cp"></span>
<span class="cp">#define MRAID_DMA_WBUF	0x0002	</span><span class="cm">/* data transfer using a contiguous buffer */</span><span class="cp"></span>


<span class="cm">/**</span>
<span class="cm"> * struct adapter_t - driver&#39;s initialization structure</span>
<span class="cm"> * @aram dpc_h			: tasklet handle</span>
<span class="cm"> * @pdev			: pci configuration pointer for kernel</span>
<span class="cm"> * @host			: pointer to host structure of mid-layer</span>
<span class="cm"> * @lock			: synchronization lock for mid-layer and driver</span>
<span class="cm"> * @quiescent			: driver is quiescent for now.</span>
<span class="cm"> * @outstanding_cmds		: number of commands pending in the driver</span>
<span class="cm"> * @kscb_list			: pointer to the bulk of SCBs pointers for IO</span>
<span class="cm"> * @kscb_pool			: pool of free scbs for IO</span>
<span class="cm"> * @kscb_pool_lock		: lock for pool of free scbs</span>
<span class="cm"> * @pend_list			: pending commands list</span>
<span class="cm"> * @pend_list_lock		: exclusion lock for pending commands list</span>
<span class="cm"> * @completed_list		: list of completed commands</span>
<span class="cm"> * @completed_list_lock		: exclusion lock for list of completed commands</span>
<span class="cm"> * @sglen			: max sg elements supported</span>
<span class="cm"> * @device_ids			: to convert kernel device addr to our devices.</span>
<span class="cm"> * @raid_device			: raid adapter specific pointer</span>
<span class="cm"> * @max_channel			: maximum channel number supported - inclusive</span>
<span class="cm"> * @max_target			: max target supported - inclusive</span>
<span class="cm"> * @max_lun			: max lun supported - inclusive</span>
<span class="cm"> * @unique_id			: unique identifier for each adapter</span>
<span class="cm"> * @irq				: IRQ for this adapter</span>
<span class="cm"> * @ito				: internal timeout value, (-1) means no timeout</span>
<span class="cm"> * @ibuf			: buffer to issue internal commands</span>
<span class="cm"> * @ibuf_dma_h			: dma handle for the above buffer</span>
<span class="cm"> * @uscb_list			: SCB pointers for user cmds, common mgmt module</span>
<span class="cm"> * @uscb_pool			: pool of SCBs for user commands</span>
<span class="cm"> * @uscb_pool_lock		: exclusion lock for these SCBs</span>
<span class="cm"> * @max_cmds			: max outstanding commands</span>
<span class="cm"> * @fw_version			: firmware version</span>
<span class="cm"> * @bios_version		: bios version</span>
<span class="cm"> * @max_cdb_sz			: biggest CDB size supported.</span>
<span class="cm"> * @ha				: is high availability present - clustering</span>
<span class="cm"> * @init_id			: initiator ID, the default value should be 7</span>
<span class="cm"> * @max_sectors			: max sectors per request</span>
<span class="cm"> * @cmd_per_lun			: max outstanding commands per LUN</span>
<span class="cm"> * @being_detached		: set when unloading, no more mgmt calls</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * mraid_setup_device_map() can be called anytime after the device map is</span>
<span class="cm"> * available and MRAID_GET_DEVICE_MAP() can be called whenever the mapping is</span>
<span class="cm"> * required, usually from LLD&#39;s queue entry point. The formar API sets up the</span>
<span class="cm"> * MRAID_IS_LOGICAL(adapter_t *, struct scsi_cmnd *) to find out if the</span>
<span class="cm"> * device in question is a logical drive.</span>
<span class="cm"> *</span>
<span class="cm"> * quiescent flag should be set by the driver if it is not accepting more</span>
<span class="cm"> * commands</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: The fields of this structures are placed to minimize cache misses</span>
<span class="cm"> */</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>amount of space required to store the bios and firmware version strings</p></td><td class="code"><div class="highlight"><pre><span class="cp">#define VERSION_SIZE	16</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">tasklet_struct</span>	<span class="n">dpc_h</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span>		<span class="o">*</span><span class="n">pdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>	<span class="o">*</span><span class="n">host</span><span class="p">;</span>
	<span class="n">spinlock_t</span>		<span class="n">lock</span><span class="p">;</span>
	<span class="kt">uint8_t</span>			<span class="n">quiescent</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">outstanding_cmds</span><span class="p">;</span>
	<span class="n">scb_t</span>			<span class="o">*</span><span class="n">kscb_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">kscb_pool</span><span class="p">;</span>
	<span class="n">spinlock_t</span>		<span class="n">kscb_pool_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">pend_list</span><span class="p">;</span>
	<span class="n">spinlock_t</span>		<span class="n">pend_list_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">completed_list</span><span class="p">;</span>
	<span class="n">spinlock_t</span>		<span class="n">completed_list_lock</span><span class="p">;</span>
	<span class="kt">uint16_t</span>		<span class="n">sglen</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">device_ids</span><span class="p">[</span><span class="n">LSI_MAX_CHANNELS</span><span class="p">]</span>
					<span class="p">[</span><span class="n">LSI_MAX_LOGICAL_DRIVES_64LD</span><span class="p">];</span>
	<span class="n">caddr_t</span>			<span class="n">raid_device</span><span class="p">;</span>
	<span class="kt">uint8_t</span>			<span class="n">max_channel</span><span class="p">;</span>
	<span class="kt">uint16_t</span>		<span class="n">max_target</span><span class="p">;</span>
	<span class="kt">uint8_t</span>			<span class="n">max_lun</span><span class="p">;</span>

	<span class="kt">uint32_t</span>		<span class="n">unique_id</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">irq</span><span class="p">;</span>
	<span class="kt">uint8_t</span>			<span class="n">ito</span><span class="p">;</span>
	<span class="n">caddr_t</span>			<span class="n">ibuf</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>		<span class="n">ibuf_dma_h</span><span class="p">;</span>
	<span class="n">scb_t</span>			<span class="o">*</span><span class="n">uscb_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">uscb_pool</span><span class="p">;</span>
	<span class="n">spinlock_t</span>		<span class="n">uscb_pool_lock</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">max_cmds</span><span class="p">;</span>
	<span class="kt">uint8_t</span>			<span class="n">fw_version</span><span class="p">[</span><span class="n">VERSION_SIZE</span><span class="p">];</span>
	<span class="kt">uint8_t</span>			<span class="n">bios_version</span><span class="p">[</span><span class="n">VERSION_SIZE</span><span class="p">];</span>
	<span class="kt">uint8_t</span>			<span class="n">max_cdb_sz</span><span class="p">;</span>
	<span class="kt">uint8_t</span>			<span class="n">ha</span><span class="p">;</span>
	<span class="kt">uint16_t</span>		<span class="n">init_id</span><span class="p">;</span>
	<span class="kt">uint16_t</span>		<span class="n">max_sectors</span><span class="p">;</span>
	<span class="kt">uint16_t</span>		<span class="n">cmd_per_lun</span><span class="p">;</span>
	<span class="n">atomic_t</span>		<span class="n">being_detached</span><span class="p">;</span>
<span class="p">}</span> <span class="n">adapter_t</span><span class="p">;</span>

<span class="cp">#define SCSI_FREE_LIST_LOCK(adapter)	(&amp;adapter-&gt;kscb_pool_lock)</span>
<span class="cp">#define USER_FREE_LIST_LOCK(adapter)	(&amp;adapter-&gt;uscb_pool_lock)</span>
<span class="cp">#define PENDING_LIST_LOCK(adapter)	(&amp;adapter-&gt;pend_list_lock)</span>
<span class="cp">#define COMPLETED_LIST_LOCK(adapter)	(&amp;adapter-&gt;completed_list_lock)</span></pre></div></td></tr>


<tr id="section-3"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-3">&#182;</a></div><p>conversion from scsi command</p></td><td class="code"><div class="highlight"><pre><span class="cp">#define SCP2HOST(scp)			(scp)-&gt;device-&gt;host	</span><span class="c1">// to host</span>
<span class="cp">#define SCP2HOSTDATA(scp)		SCP2HOST(scp)-&gt;hostdata	</span><span class="c1">// to soft state</span>
<span class="cp">#define SCP2CHANNEL(scp)		(scp)-&gt;device-&gt;channel	</span><span class="c1">// to channel</span>
<span class="cp">#define SCP2TARGET(scp)			(scp)-&gt;device-&gt;id	</span><span class="c1">// to target</span>
<span class="cp">#define SCP2LUN(scp)			(scp)-&gt;device-&gt;lun	</span><span class="c1">// to LUN</span></pre></div></td></tr>


<tr id="section-4"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-4">&#182;</a></div><p>generic macro to convert scsi command and host to controller's soft state</p></td><td class="code"><div class="highlight"><pre><span class="cp">#define SCSIHOST2ADAP(host)	(((caddr_t *)(host-&gt;hostdata))[0])</span>
<span class="cp">#define SCP2ADAPTER(scp)	(adapter_t *)SCSIHOST2ADAP(SCP2HOST(scp))</span>


<span class="cp">#define MRAID_IS_LOGICAL(adp, scp)	\</span>
<span class="cp">	(SCP2CHANNEL(scp) == (adp)-&gt;max_channel) ? 1 : 0</span>

<span class="cp">#define MRAID_IS_LOGICAL_SDEV(adp, sdev)	\</span>
<span class="cp">	(sdev-&gt;channel == (adp)-&gt;max_channel) ? 1 : 0</span>

<span class="cm">/**</span>
<span class="cm"> * MRAID_GET_DEVICE_MAP - device ids</span>
<span class="cm"> * @adp			: adapter&#39;s soft state</span>
<span class="cm"> * @scp			: mid-layer scsi command pointer</span>
<span class="cm"> * @p_chan		: physical channel on the controller</span>
<span class="cm"> * @target		: target id of the device or logical drive number</span>
<span class="cm"> * @islogical		: set if the command is for the logical drive</span>
<span class="cm"> *</span>
<span class="cm"> * Macro to retrieve information about device class, logical or physical and</span>
<span class="cm"> * the corresponding physical channel and target or logical drive number</span>
<span class="cm"> */</span>
<span class="cp">#define MRAID_GET_DEVICE_MAP(adp, scp, p_chan, target, islogical)	\</span>
<span class="cp">	</span><span class="cm">/*								\</span>
<span class="cm">	 * Is the request coming for the virtual channel		\</span>
<span class="cm">	 */</span><span class="cp">								\</span>
<span class="cp">	islogical = MRAID_IS_LOGICAL(adp, scp);				\</span>
<span class="cp">									\</span>
<span class="cp">	</span><span class="cm">/*								\</span>
<span class="cm">	 * Get an index into our table of drive ids mapping		\</span>
<span class="cm">	 */</span><span class="cp">								\</span>
<span class="cp">	if (islogical) {						\</span>
<span class="cp">		p_chan = 0xFF;						\</span>
<span class="cp">		target =						\</span>
<span class="cp">		(adp)-&gt;device_ids[(adp)-&gt;max_channel][SCP2TARGET(scp)];	\</span>
<span class="cp">	}								\</span>
<span class="cp">	else {								\</span>
<span class="cp">		p_chan = ((adp)-&gt;device_ids[SCP2CHANNEL(scp)]		\</span>
<span class="cp">					[SCP2TARGET(scp)] &gt;&gt; 8) &amp; 0xFF;	\</span>
<span class="cp">		target = ((adp)-&gt;device_ids[SCP2CHANNEL(scp)]		\</span>
<span class="cp">					[SCP2TARGET(scp)] &amp; 0xFF);	\</span>
<span class="cp">	}</span>

<span class="cm">/*</span>
<span class="cm"> * ### Helper routines ###</span>
<span class="cm"> */</span>
<span class="cp">#define LSI_DBGLVL mraid_debug_level	</span><span class="c1">// each LLD must define a global</span></pre></div></td></tr>


<tr id="section-5"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-5">&#182;</a></div><p>mraid<em>debug</em>level</p></td><td class="code"><div class="highlight"><pre><span class="cp">#ifdef DEBUG</span>
<span class="cp">#if defined (_ASSERT_PANIC)</span>
<span class="cp">#define ASSERT_ACTION	panic</span>
<span class="cp">#else</span>
<span class="cp">#define ASSERT_ACTION	printk</span>
<span class="cp">#endif</span>

<span class="cp">#define ASSERT(expression)						\</span>
<span class="cp">	if (!(expression)) {						\</span>
<span class="cp">	ASSERT_ACTION(&quot;assertion failed:(%s), file: %s, line: %d:%s\n&quot;,	\</span>
<span class="cp">			#expression, __FILE__, __LINE__, __func__);	\</span>
<span class="cp">	}</span>
<span class="cp">#else</span>
<span class="cp">#define ASSERT(expression)</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * struct mraid_pci_blk - structure holds DMA memory block info</span>
<span class="cm"> * @vaddr		: virtual address to a memory block</span>
<span class="cm"> * @dma_addr		: DMA handle to a memory block</span>
<span class="cm"> *</span>
<span class="cm"> * This structure is filled up for the caller. It is the responsibilty of the</span>
<span class="cm"> * caller to allocate this array big enough to store addresses for all</span>
<span class="cm"> * requested elements</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">mraid_pci_blk</span> <span class="p">{</span>
	<span class="n">caddr_t</span>		<span class="n">vaddr</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>	<span class="n">dma_addr</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#endif </span><span class="c1">// _MEGA_COMMON_H_</span></pre></div></td></tr>


<tr id="section-6"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-6">&#182;</a></div><p>vim: set ts=8 sw=8 tw=78:</p></td><td class="code"><div class="highlight"><pre></pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
