<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › scsi › megaraid › megaraid_mbox.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>megaraid_mbox.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *</span>
<span class="cm"> *			Linux MegaRAID device driver</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2003-2004  LSI Logic Corporation.</span>
<span class="cm"> *</span>
<span class="cm"> *	   This program is free software; you can redistribute it and/or</span>
<span class="cm"> *	   modify it under the terms of the GNU General Public License</span>
<span class="cm"> *	   as published by the Free Software Foundation; either version</span>
<span class="cm"> *	   2 of the License, or (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * FILE		: megaraid_mbox.c</span>
<span class="cm"> * Version	: v2.20.5.1 (Nov 16 2006)</span>
<span class="cm"> *</span>
<span class="cm"> * Authors:</span>
<span class="cm"> * 	Atul Mukker		&lt;Atul.Mukker@lsi.com&gt;</span>
<span class="cm"> * 	Sreenivas Bagalkote	&lt;Sreenivas.Bagalkote@lsi.com&gt;</span>
<span class="cm"> * 	Manoj Jose		&lt;Manoj.Jose@lsi.com&gt;</span>
<span class="cm"> * 	Seokmann Ju</span>
<span class="cm"> *</span>
<span class="cm"> * List of supported controllers</span>
<span class="cm"> *</span>
<span class="cm"> * OEM	Product Name			VID	DID	SSVID	SSID</span>
<span class="cm"> * ---	------------			---	---	----	----</span>
<span class="cm"> * Dell PERC3/QC			101E	1960	1028	0471</span>
<span class="cm"> * Dell PERC3/DC			101E	1960	1028	0493</span>
<span class="cm"> * Dell PERC3/SC			101E	1960	1028	0475</span>
<span class="cm"> * Dell PERC3/Di			1028	1960	1028	0123</span>
<span class="cm"> * Dell PERC4/SC			1000	1960	1028	0520</span>
<span class="cm"> * Dell PERC4/DC			1000	1960	1028	0518</span>
<span class="cm"> * Dell PERC4/QC			1000	0407	1028	0531</span>
<span class="cm"> * Dell PERC4/Di			1028	000F	1028	014A</span>
<span class="cm"> * Dell PERC 4e/Si			1028	0013	1028	016c</span>
<span class="cm"> * Dell PERC 4e/Di			1028	0013	1028	016d</span>
<span class="cm"> * Dell PERC 4e/Di			1028	0013	1028	016e</span>
<span class="cm"> * Dell PERC 4e/Di			1028	0013	1028	016f</span>
<span class="cm"> * Dell PERC 4e/Di			1028	0013	1028	0170</span>
<span class="cm"> * Dell PERC 4e/DC			1000	0408	1028	0002</span>
<span class="cm"> * Dell PERC 4e/SC			1000	0408	1028	0001</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * LSI MegaRAID SCSI 320-0		1000	1960	1000	A520</span>
<span class="cm"> * LSI MegaRAID SCSI 320-1		1000	1960	1000	0520</span>
<span class="cm"> * LSI MegaRAID SCSI 320-2		1000	1960	1000	0518</span>
<span class="cm"> * LSI MegaRAID SCSI 320-0X		1000	0407	1000	0530</span>
<span class="cm"> * LSI MegaRAID SCSI 320-2X		1000	0407	1000	0532</span>
<span class="cm"> * LSI MegaRAID SCSI 320-4X		1000	0407	1000	0531</span>
<span class="cm"> * LSI MegaRAID SCSI 320-1E		1000	0408	1000	0001</span>
<span class="cm"> * LSI MegaRAID SCSI 320-2E		1000	0408	1000	0002</span>
<span class="cm"> * LSI MegaRAID SATA 150-4		1000	1960	1000	4523</span>
<span class="cm"> * LSI MegaRAID SATA 150-6		1000	1960	1000	0523</span>
<span class="cm"> * LSI MegaRAID SATA 300-4X		1000	0409	1000	3004</span>
<span class="cm"> * LSI MegaRAID SATA 300-8X		1000	0409	1000	3008</span>
<span class="cm"> *</span>
<span class="cm"> * INTEL RAID Controller SRCU42X	1000	0407	8086	0532</span>
<span class="cm"> * INTEL RAID Controller SRCS16		1000	1960	8086	0523</span>
<span class="cm"> * INTEL RAID Controller SRCU42E	1000	0408	8086	0002</span>
<span class="cm"> * INTEL RAID Controller SRCZCRX	1000	0407	8086	0530</span>
<span class="cm"> * INTEL RAID Controller SRCS28X	1000	0409	8086	3008</span>
<span class="cm"> * INTEL RAID Controller SROMBU42E	1000	0408	8086	3431</span>
<span class="cm"> * INTEL RAID Controller SROMBU42E	1000	0408	8086	3499</span>
<span class="cm"> * INTEL RAID Controller SRCU51L	1000	1960	8086	0520</span>
<span class="cm"> *</span>
<span class="cm"> * FSC	MegaRAID PCI Express ROMB	1000	0408	1734	1065</span>
<span class="cm"> *</span>
<span class="cm"> * ACER	MegaRAID ROMB-2E		1000	0408	1025	004D</span>
<span class="cm"> *</span>
<span class="cm"> * NEC	MegaRAID PCI Express ROMB	1000	0408	1033	8287</span>
<span class="cm"> *</span>
<span class="cm"> * For history of changes, see Documentation/scsi/ChangeLog.megaraid</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &quot;megaraid_mbox.h&quot;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">megaraid_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">megaraid_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">megaraid_probe_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span><span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">megaraid_detach_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">megaraid_mbox_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">megaraid_io_attach</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">megaraid_io_detach</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">megaraid_init_mbox</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">megaraid_fini_mbox</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">megaraid_alloc_cmd_packets</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">megaraid_free_cmd_packets</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">megaraid_mbox_setup_dma_pools</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">megaraid_mbox_teardown_dma_pools</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">megaraid_sysfs_alloc_resources</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">megaraid_sysfs_free_resources</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">megaraid_abort_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">megaraid_reset_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">mbox_post_sync_cmd</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="p">[]);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">mbox_post_sync_cmd_fast</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="p">[]);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">megaraid_busywait_mbox</span><span class="p">(</span><span class="n">mraid_device_t</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">megaraid_mbox_product_info</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">megaraid_mbox_extended_cdb</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">megaraid_mbox_support_ha</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">megaraid_mbox_support_random_del</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">megaraid_mbox_get_max_sg</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">megaraid_mbox_enum_raid_scsi</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">megaraid_mbox_flush_cache</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">megaraid_mbox_fire_sync_cmd</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">megaraid_mbox_display_scb</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="p">,</span> <span class="n">scb_t</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">megaraid_mbox_setup_device_map</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">megaraid_queue_command</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="n">scb_t</span> <span class="o">*</span><span class="n">megaraid_mbox_build_cmd</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">megaraid_mbox_runpendq</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="p">,</span> <span class="n">scb_t</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">megaraid_mbox_prepare_pthru</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="p">,</span> <span class="n">scb_t</span> <span class="o">*</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">megaraid_mbox_prepare_epthru</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="p">,</span> <span class="n">scb_t</span> <span class="o">*</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="p">);</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="n">megaraid_isr</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">megaraid_mbox_dpc</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="n">megaraid_sysfs_show_app_hndl</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="n">megaraid_sysfs_show_ldnum</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">megaraid_cmm_register</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">megaraid_cmm_unregister</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">megaraid_mbox_mm_handler</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">uioc_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">uint32_t</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">megaraid_mbox_mm_command</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="p">,</span> <span class="n">uioc_t</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">megaraid_mbox_mm_done</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="p">,</span> <span class="n">scb_t</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">gather_hbainfo</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="p">,</span> <span class="n">mraid_hba_info_t</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">wait_till_fw_empty</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="p">);</span>



<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;megaraidlinux@lsi.com&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;LSI Logic MegaRAID Mailbox Driver&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_VERSION</span><span class="p">(</span><span class="n">MEGARAID_VERSION</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * ### modules parameters for driver ###</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Set to enable driver to expose unconfigured disk to kernel</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">megaraid_expose_unconf_disks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">module_param_named</span><span class="p">(</span><span class="n">unconf_disks</span><span class="p">,</span> <span class="n">megaraid_expose_unconf_disks</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">unconf_disks</span><span class="p">,</span>
	<span class="s">&quot;Set to expose unconfigured disks to kernel (default=0)&quot;</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * driver wait time if the adapter&#39;s mailbox is busy</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_mbox_busy_wait</span> <span class="o">=</span> <span class="n">MBOX_BUSY_WAIT</span><span class="p">;</span>
<span class="n">module_param_named</span><span class="p">(</span><span class="n">busy_wait</span><span class="p">,</span> <span class="n">max_mbox_busy_wait</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">busy_wait</span><span class="p">,</span>
	<span class="s">&quot;Max wait for mailbox in microseconds if busy (default=10)&quot;</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * number of sectors per IO command</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">megaraid_max_sectors</span> <span class="o">=</span> <span class="n">MBOX_MAX_SECTORS</span><span class="p">;</span>
<span class="n">module_param_named</span><span class="p">(</span><span class="n">max_sectors</span><span class="p">,</span> <span class="n">megaraid_max_sectors</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">max_sectors</span><span class="p">,</span>
	<span class="s">&quot;Maximum number of sectors per IO command (default=128)&quot;</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * number of commands per logical unit</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">megaraid_cmd_per_lun</span> <span class="o">=</span> <span class="n">MBOX_DEF_CMD_PER_LUN</span><span class="p">;</span>
<span class="n">module_param_named</span><span class="p">(</span><span class="n">cmd_per_lun</span><span class="p">,</span> <span class="n">megaraid_cmd_per_lun</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">cmd_per_lun</span><span class="p">,</span>
	<span class="s">&quot;Maximum number of commands per logical unit (default=64)&quot;</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> * Fast driver load option, skip scanning for physical devices during load.</span>
<span class="cm"> * This would result in non-disk devices being skipped during driver load</span>
<span class="cm"> * time. These can be later added though, using /proc/scsi/scsi</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">megaraid_fast_load</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">module_param_named</span><span class="p">(</span><span class="n">fast_load</span><span class="p">,</span> <span class="n">megaraid_fast_load</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">fast_load</span><span class="p">,</span>
	<span class="s">&quot;Faster loading of the driver, skips physical devices! (default=0)&quot;</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> * mraid_debug level - threshold for amount of information to be displayed by</span>
<span class="cm"> * the driver. This level can be changed through modules parameters, ioctl or</span>
<span class="cm"> * sysfs/proc interface. By default, print the announcement messages only.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">mraid_debug_level</span> <span class="o">=</span> <span class="n">CL_ANN</span><span class="p">;</span>
<span class="n">module_param_named</span><span class="p">(</span><span class="n">debug_level</span><span class="p">,</span> <span class="n">mraid_debug_level</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">debug_level</span><span class="p">,</span> <span class="s">&quot;Debug level for driver (default=0)&quot;</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * ### global data ###</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">uint8_t</span> <span class="n">megaraid_mbox_version</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span>
	<span class="p">{</span> <span class="mh">0x02</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">,</span> <span class="mh">0x04</span><span class="p">,</span> <span class="mh">0x06</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">5</span> <span class="p">};</span>


<span class="cm">/*</span>
<span class="cm"> * PCI table for all supported controllers.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="n">pci_id_table_g</span><span class="p">[]</span> <span class="o">=</span>  <span class="p">{</span>
	<span class="p">{</span>
		<span class="n">PCI_VENDOR_ID_DELL</span><span class="p">,</span>
		<span class="n">PCI_DEVICE_ID_PERC4_DI_DISCOVERY</span><span class="p">,</span>
		<span class="n">PCI_VENDOR_ID_DELL</span><span class="p">,</span>
		<span class="n">PCI_SUBSYS_ID_PERC4_DI_DISCOVERY</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="n">PCI_VENDOR_ID_LSI_LOGIC</span><span class="p">,</span>
		<span class="n">PCI_DEVICE_ID_PERC4_SC</span><span class="p">,</span>
		<span class="n">PCI_VENDOR_ID_DELL</span><span class="p">,</span>
		<span class="n">PCI_SUBSYS_ID_PERC4_SC</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="n">PCI_VENDOR_ID_LSI_LOGIC</span><span class="p">,</span>
		<span class="n">PCI_DEVICE_ID_PERC4_DC</span><span class="p">,</span>
		<span class="n">PCI_VENDOR_ID_DELL</span><span class="p">,</span>
		<span class="n">PCI_SUBSYS_ID_PERC4_DC</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="n">PCI_VENDOR_ID_LSI_LOGIC</span><span class="p">,</span>
		<span class="n">PCI_DEVICE_ID_VERDE</span><span class="p">,</span>
		<span class="n">PCI_ANY_ID</span><span class="p">,</span>
		<span class="n">PCI_ANY_ID</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="n">PCI_VENDOR_ID_DELL</span><span class="p">,</span>
		<span class="n">PCI_DEVICE_ID_PERC4_DI_EVERGLADES</span><span class="p">,</span>
		<span class="n">PCI_VENDOR_ID_DELL</span><span class="p">,</span>
		<span class="n">PCI_SUBSYS_ID_PERC4_DI_EVERGLADES</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="n">PCI_VENDOR_ID_DELL</span><span class="p">,</span>
		<span class="n">PCI_DEVICE_ID_PERC4E_SI_BIGBEND</span><span class="p">,</span>
		<span class="n">PCI_VENDOR_ID_DELL</span><span class="p">,</span>
		<span class="n">PCI_SUBSYS_ID_PERC4E_SI_BIGBEND</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="n">PCI_VENDOR_ID_DELL</span><span class="p">,</span>
		<span class="n">PCI_DEVICE_ID_PERC4E_DI_KOBUK</span><span class="p">,</span>
		<span class="n">PCI_VENDOR_ID_DELL</span><span class="p">,</span>
		<span class="n">PCI_SUBSYS_ID_PERC4E_DI_KOBUK</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="n">PCI_VENDOR_ID_DELL</span><span class="p">,</span>
		<span class="n">PCI_DEVICE_ID_PERC4E_DI_CORVETTE</span><span class="p">,</span>
		<span class="n">PCI_VENDOR_ID_DELL</span><span class="p">,</span>
		<span class="n">PCI_SUBSYS_ID_PERC4E_DI_CORVETTE</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="n">PCI_VENDOR_ID_DELL</span><span class="p">,</span>
		<span class="n">PCI_DEVICE_ID_PERC4E_DI_EXPEDITION</span><span class="p">,</span>
		<span class="n">PCI_VENDOR_ID_DELL</span><span class="p">,</span>
		<span class="n">PCI_SUBSYS_ID_PERC4E_DI_EXPEDITION</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="n">PCI_VENDOR_ID_DELL</span><span class="p">,</span>
		<span class="n">PCI_DEVICE_ID_PERC4E_DI_GUADALUPE</span><span class="p">,</span>
		<span class="n">PCI_VENDOR_ID_DELL</span><span class="p">,</span>
		<span class="n">PCI_SUBSYS_ID_PERC4E_DI_GUADALUPE</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="n">PCI_VENDOR_ID_LSI_LOGIC</span><span class="p">,</span>
		<span class="n">PCI_DEVICE_ID_DOBSON</span><span class="p">,</span>
		<span class="n">PCI_ANY_ID</span><span class="p">,</span>
		<span class="n">PCI_ANY_ID</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="n">PCI_VENDOR_ID_AMI</span><span class="p">,</span>
		<span class="n">PCI_DEVICE_ID_AMI_MEGARAID3</span><span class="p">,</span>
		<span class="n">PCI_ANY_ID</span><span class="p">,</span>
		<span class="n">PCI_ANY_ID</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="n">PCI_VENDOR_ID_LSI_LOGIC</span><span class="p">,</span>
		<span class="n">PCI_DEVICE_ID_AMI_MEGARAID3</span><span class="p">,</span>
		<span class="n">PCI_ANY_ID</span><span class="p">,</span>
		<span class="n">PCI_ANY_ID</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="n">PCI_VENDOR_ID_LSI_LOGIC</span><span class="p">,</span>
		<span class="n">PCI_DEVICE_ID_LINDSAY</span><span class="p">,</span>
		<span class="n">PCI_ANY_ID</span><span class="p">,</span>
		<span class="n">PCI_ANY_ID</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span><span class="mi">0</span><span class="p">}</span>	<span class="cm">/* Terminating entry */</span>
<span class="p">};</span>
<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">pci_id_table_g</span><span class="p">);</span>


<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_driver</span> <span class="n">megaraid_pci_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;megaraid&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_table</span>	<span class="o">=</span> <span class="n">pci_id_table_g</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span>		<span class="o">=</span> <span class="n">megaraid_probe_one</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span>		<span class="o">=</span> <span class="n">__devexit_p</span><span class="p">(</span><span class="n">megaraid_detach_one</span><span class="p">),</span>
	<span class="p">.</span><span class="n">shutdown</span>	<span class="o">=</span> <span class="n">megaraid_mbox_shutdown</span><span class="p">,</span>
<span class="p">};</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>definitions for the device attributes for exporting logical drive number
for a scsi address (Host, Channel, Id, Lun)</p></td><td class="code"><div class="highlight"><pre><span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">megaraid_mbox_app_hndl</span><span class="p">,</span> <span class="n">S_IRUSR</span><span class="p">,</span> <span class="n">megaraid_sysfs_show_app_hndl</span><span class="p">,</span>
		<span class="nb">NULL</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-3"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-3">&#182;</a></div><p>Host template initializer for megaraid mbox sysfs device attributes</p></td><td class="code"><div class="highlight"><pre><span class="k">static</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">megaraid_shost_attrs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="o">&amp;</span><span class="n">dev_attr_megaraid_mbox_app_hndl</span><span class="p">,</span>
	<span class="nb">NULL</span><span class="p">,</span>
<span class="p">};</span>


<span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">megaraid_mbox_ld</span><span class="p">,</span> <span class="n">S_IRUSR</span><span class="p">,</span> <span class="n">megaraid_sysfs_show_ldnum</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-4"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-4">&#182;</a></div><p>Host template initializer for megaraid mbox sysfs device attributes</p></td><td class="code"><div class="highlight"><pre><span class="k">static</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">megaraid_sdev_attrs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="o">&amp;</span><span class="n">dev_attr_megaraid_mbox_ld</span><span class="p">,</span>
	<span class="nb">NULL</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * megaraid_change_queue_depth - Change the device&#39;s queue depth</span>
<span class="cm"> * @sdev:	scsi device struct</span>
<span class="cm"> * @qdepth:	depth to set</span>
<span class="cm"> * @reason:	calling context</span>
<span class="cm"> *</span>
<span class="cm"> * Return value:</span>
<span class="cm"> * 	actual depth set</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">megaraid_change_queue_depth</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">qdepth</span><span class="p">,</span>
				       <span class="kt">int</span> <span class="n">reason</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reason</span> <span class="o">!=</span> <span class="n">SCSI_QDEPTH_DEFAULT</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">qdepth</span> <span class="o">&gt;</span> <span class="n">MBOX_MAX_SCSI_CMDS</span><span class="p">)</span>
		<span class="n">qdepth</span> <span class="o">=</span> <span class="n">MBOX_MAX_SCSI_CMDS</span><span class="p">;</span>
	<span class="n">scsi_adjust_queue_depth</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">qdepth</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">queue_depth</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Scsi host template for megaraid unified driver</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">scsi_host_template</span> <span class="n">megaraid_template_g</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">module</span>				<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span>				<span class="o">=</span> <span class="s">&quot;LSI Logic MegaRAID driver&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">proc_name</span>			<span class="o">=</span> <span class="s">&quot;megaraid&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">queuecommand</span>			<span class="o">=</span> <span class="n">megaraid_queue_command</span><span class="p">,</span>
	<span class="p">.</span><span class="n">eh_abort_handler</span>		<span class="o">=</span> <span class="n">megaraid_abort_handler</span><span class="p">,</span>
	<span class="p">.</span><span class="n">eh_device_reset_handler</span>	<span class="o">=</span> <span class="n">megaraid_reset_handler</span><span class="p">,</span>
	<span class="p">.</span><span class="n">eh_bus_reset_handler</span>		<span class="o">=</span> <span class="n">megaraid_reset_handler</span><span class="p">,</span>
	<span class="p">.</span><span class="n">eh_host_reset_handler</span>		<span class="o">=</span> <span class="n">megaraid_reset_handler</span><span class="p">,</span>
	<span class="p">.</span><span class="n">change_queue_depth</span>		<span class="o">=</span> <span class="n">megaraid_change_queue_depth</span><span class="p">,</span>
	<span class="p">.</span><span class="n">use_clustering</span>			<span class="o">=</span> <span class="n">ENABLE_CLUSTERING</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sdev_attrs</span>			<span class="o">=</span> <span class="n">megaraid_sdev_attrs</span><span class="p">,</span>
	<span class="p">.</span><span class="n">shost_attrs</span>			<span class="o">=</span> <span class="n">megaraid_shost_attrs</span><span class="p">,</span>
<span class="p">};</span>


<span class="cm">/**</span>
<span class="cm"> * megaraid_init - module load hook</span>
<span class="cm"> *</span>
<span class="cm"> * We register ourselves as hotplug enabled module and let PCI subsystem</span>
<span class="cm"> * discover our adapters.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span>
<span class="nf">megaraid_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>	<span class="n">rval</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-5"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-5">&#182;</a></div><p>Announce the driver version</p></td><td class="code"><div class="highlight"><pre>	<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;megaraid: %s %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">MEGARAID_VERSION</span><span class="p">,</span>
		<span class="n">MEGARAID_EXT_VERSION</span><span class="p">));</span></pre></div></td></tr>


<tr id="section-6"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-6">&#182;</a></div><p>check validity of module parameters</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span> <span class="p">(</span><span class="n">megaraid_cmd_per_lun</span> <span class="o">&gt;</span> <span class="n">MBOX_MAX_SCSI_CMDS</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="n">KERN_WARNING</span>
			<span class="s">&quot;megaraid mailbox: max commands per lun reset to %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">MBOX_MAX_SCSI_CMDS</span><span class="p">));</span>

		<span class="n">megaraid_cmd_per_lun</span> <span class="o">=</span> <span class="n">MBOX_MAX_SCSI_CMDS</span><span class="p">;</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-7"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-7">&#182;</a></div><p>register as a PCI hot-plug driver module</p></td><td class="code"><div class="highlight"><pre>	<span class="n">rval</span> <span class="o">=</span> <span class="n">pci_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">megaraid_pci_driver</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="n">KERN_WARNING</span>
			<span class="s">&quot;megaraid: could not register hotplug support.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">rval</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * megaraid_exit - driver unload entry point</span>
<span class="cm"> *</span>
<span class="cm"> * We simply unwrap the megaraid_init routine here.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span>
<span class="nf">megaraid_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">con_log</span><span class="p">(</span><span class="n">CL_DLEVEL1</span><span class="p">,</span> <span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;megaraid: unloading framework</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span></pre></div></td></tr>


<tr id="section-8"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-8">&#182;</a></div><p>unregister as PCI hotplug driver</p></td><td class="code"><div class="highlight"><pre>	<span class="n">pci_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">megaraid_pci_driver</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * megaraid_probe_one - PCI hotplug entry point</span>
<span class="cm"> * @pdev	: handle to this controller&#39;s PCI configuration space</span>
<span class="cm"> * @id		: pci device id of the class of controllers</span>
<span class="cm"> *</span>
<span class="cm"> * This routine should be called whenever a new adapter is detected by the</span>
<span class="cm"> * PCI hotplug susbsystem.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span>
<span class="nf">megaraid_probe_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">adapter_t</span>	<span class="o">*</span><span class="n">adapter</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-9"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-9">&#182;</a></div><p>detected a new controller</p></td><td class="code"><div class="highlight"><pre>	<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="n">KERN_INFO</span>
		<span class="s">&quot;megaraid: probe new device %#4.04x:%#4.04x:%#4.04x:%#4.04x: &quot;</span><span class="p">,</span>
		<span class="n">pdev</span><span class="o">-&gt;</span><span class="n">vendor</span><span class="p">,</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">subsystem_vendor</span><span class="p">,</span>
		<span class="n">pdev</span><span class="o">-&gt;</span><span class="n">subsystem_device</span><span class="p">));</span>

	<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;bus %d:slot %d:func %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">,</span>
		<span class="n">PCI_SLOT</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">),</span> <span class="n">PCI_FUNC</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">)));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pci_enable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="n">KERN_WARNING</span>
				<span class="s">&quot;megaraid: pci_enable_device failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>

		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-10"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-10">&#182;</a></div><p>Enable bus-mastering on this controller</p></td><td class="code"><div class="highlight"><pre>	<span class="n">pci_set_master</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-11"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-11">&#182;</a></div><p>Allocate the per driver initialization structure</p></td><td class="code"><div class="highlight"><pre>	<span class="n">adapter</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">adapter_t</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="n">KERN_WARNING</span>
		<span class="s">&quot;megaraid: out of memory, %s %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">));</span>

		<span class="k">goto</span> <span class="n">out_probe_one</span><span class="p">;</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-12"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-12">&#182;</a></div><p>set up PCI related soft state and other pre-known parameters</p></td><td class="code"><div class="highlight"><pre>	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">unique_id</span>	<span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">number</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span> <span class="o">|</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">irq</span>		<span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span>		<span class="o">=</span> <span class="n">pdev</span><span class="p">;</span>

	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">being_detached</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-13"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-13">&#182;</a></div><p>Setup the default DMA mask. This would be changed later on
depending on hardware capabilities</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span> <span class="p">(</span><span class="n">pci_set_dma_mask</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">32</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="n">KERN_WARNING</span>
			<span class="s">&quot;megaraid: pci_set_dma_mask failed:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">));</span>

		<span class="k">goto</span> <span class="n">out_free_adapter</span><span class="p">;</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-14"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-14">&#182;</a></div><p>Initialize the synchronization lock for kernel and LLD</p></td><td class="code"><div class="highlight"><pre>	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-15"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-15">&#182;</a></div><p>Initialize the command queues: the list of free SCBs and the list
of pending SCBs.</p></td><td class="code"><div class="highlight"><pre>	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">kscb_pool</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="n">SCSI_FREE_LIST_LOCK</span><span class="p">(</span><span class="n">adapter</span><span class="p">));</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pend_list</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="n">PENDING_LIST_LOCK</span><span class="p">(</span><span class="n">adapter</span><span class="p">));</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">completed_list</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="n">COMPLETED_LIST_LOCK</span><span class="p">(</span><span class="n">adapter</span><span class="p">));</span></pre></div></td></tr>


<tr id="section-16"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-16">&#182;</a></div><p>Start the mailbox based controller</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span> <span class="p">(</span><span class="n">megaraid_init_mbox</span><span class="p">(</span><span class="n">adapter</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="n">KERN_WARNING</span>
			<span class="s">&quot;megaraid: maibox adapter did not initialize</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>

		<span class="k">goto</span> <span class="n">out_free_adapter</span><span class="p">;</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-17"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-17">&#182;</a></div><p>Register with LSI Common Management Module</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span> <span class="p">(</span><span class="n">megaraid_cmm_register</span><span class="p">(</span><span class="n">adapter</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="n">KERN_WARNING</span>
		<span class="s">&quot;megaraid: could not register with management module</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>

		<span class="k">goto</span> <span class="n">out_fini_mbox</span><span class="p">;</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-18"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-18">&#182;</a></div><p>setup adapter handle in PCI soft state</p></td><td class="code"><div class="highlight"><pre>	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">adapter</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-19"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-19">&#182;</a></div><p>attach with scsi mid-layer</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span> <span class="p">(</span><span class="n">megaraid_io_attach</span><span class="p">(</span><span class="n">adapter</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;megaraid: io attach failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>

		<span class="k">goto</span> <span class="n">out_cmm_unreg</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_cmm_unreg:</span>
	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">megaraid_cmm_unregister</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
<span class="nl">out_fini_mbox:</span>
	<span class="n">megaraid_fini_mbox</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
<span class="nl">out_free_adapter:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
<span class="nl">out_probe_one:</span>
	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * megaraid_detach_one - release framework resources and call LLD release routine</span>
<span class="cm"> * @pdev	: handle for our PCI cofiguration space</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is called during driver unload. We free all the allocated</span>
<span class="cm"> * resources and call the corresponding LLD so that it can also release all</span>
<span class="cm"> * its resources.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is also called from the PCI hotplug system.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">megaraid_detach_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">adapter_t</span>		<span class="o">*</span><span class="n">adapter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>	<span class="o">*</span><span class="n">host</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-20"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-20">&#182;</a></div><p>Start a rollback on this adapter</p></td><td class="code"><div class="highlight"><pre>	<span class="n">adapter</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">adapter</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="n">KERN_CRIT</span>
		<span class="s">&quot;megaraid: Invalid detach on %#4.04x:%#4.04x:%#4.04x:%#4.04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">pdev</span><span class="o">-&gt;</span><span class="n">vendor</span><span class="p">,</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">subsystem_vendor</span><span class="p">,</span>
			<span class="n">pdev</span><span class="o">-&gt;</span><span class="n">subsystem_device</span><span class="p">));</span>

		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="n">KERN_NOTICE</span>
		<span class="s">&quot;megaraid: detaching device %#4.04x:%#4.04x:%#4.04x:%#4.04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">pdev</span><span class="o">-&gt;</span><span class="n">vendor</span><span class="p">,</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">subsystem_vendor</span><span class="p">,</span>
			<span class="n">pdev</span><span class="o">-&gt;</span><span class="n">subsystem_device</span><span class="p">));</span>
	<span class="p">}</span>


	<span class="n">host</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-21"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-21">&#182;</a></div><p>do not allow any more requests from the management module for this
adapter.
FIXME: How do we account for the request which might still be
pending with us?</p></td><td class="code"><div class="highlight"><pre>	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">being_detached</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-22"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-22">&#182;</a></div><p>detach from the IO sub-system</p></td><td class="code"><div class="highlight"><pre>	<span class="n">megaraid_io_detach</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-23"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-23">&#182;</a></div><p>reset the device state in the PCI structure. We check this
condition when we enter here. If the device state is NULL,
that would mean the device has already been removed</p></td><td class="code"><div class="highlight"><pre>	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-24"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-24">&#182;</a></div><p>Unregister from common management module</p>

<p>FIXME: this must return success or failure for conditions if there
is a command pending with LLD or not.</p></td><td class="code"><div class="highlight"><pre>	<span class="n">megaraid_cmm_unregister</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-25"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-25">&#182;</a></div><p>finalize the mailbox based controller and release all resources</p></td><td class="code"><div class="highlight"><pre>	<span class="n">megaraid_fini_mbox</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">scsi_host_put</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>

	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * megaraid_mbox_shutdown - PCI shutdown for megaraid HBA</span>
<span class="cm"> * @pdev		: generic driver model device</span>
<span class="cm"> *</span>
<span class="cm"> * Shutdown notification, perform flush cache.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">megaraid_mbox_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">adapter_t</span>		<span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">static</span> <span class="kt">int</span>		<span class="n">counter</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">adapter</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="n">KERN_WARNING</span>
			<span class="s">&quot;megaraid: null device in shutdown</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-26"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-26">&#182;</a></div><p>flush caches now</p></td><td class="code"><div class="highlight"><pre>	<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;megaraid: flushing adapter %d...&quot;</span><span class="p">,</span>
		<span class="n">counter</span><span class="o">++</span><span class="p">));</span>

	<span class="n">megaraid_mbox_flush_cache</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;done</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * megaraid_io_attach - attach a device with the IO subsystem</span>
<span class="cm"> * @adapter		: controller&#39;s soft state</span>
<span class="cm"> *</span>
<span class="cm"> * Attach this device with the IO subsystem.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">megaraid_io_attach</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>	<span class="o">*</span><span class="n">host</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-27"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-27">&#182;</a></div><p>Initialize SCSI Host structure</p></td><td class="code"><div class="highlight"><pre>	<span class="n">host</span> <span class="o">=</span> <span class="n">scsi_host_alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">megaraid_template_g</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">host</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="n">KERN_WARNING</span>
			<span class="s">&quot;megaraid mbox: scsi_register failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>

		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">SCSIHOST2ADAP</span><span class="p">(</span><span class="n">host</span><span class="p">)</span>	<span class="o">=</span> <span class="p">(</span><span class="n">caddr_t</span><span class="p">)</span><span class="n">adapter</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">host</span>		<span class="o">=</span> <span class="n">host</span><span class="p">;</span>

	<span class="n">host</span><span class="o">-&gt;</span><span class="n">irq</span>		<span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>
	<span class="n">host</span><span class="o">-&gt;</span><span class="n">unique_id</span>		<span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">unique_id</span><span class="p">;</span>
	<span class="n">host</span><span class="o">-&gt;</span><span class="n">can_queue</span>		<span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">max_cmds</span><span class="p">;</span>
	<span class="n">host</span><span class="o">-&gt;</span><span class="n">this_id</span>		<span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">init_id</span><span class="p">;</span>
	<span class="n">host</span><span class="o">-&gt;</span><span class="n">sg_tablesize</span>	<span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sglen</span><span class="p">;</span>
	<span class="n">host</span><span class="o">-&gt;</span><span class="n">max_sectors</span>	<span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">max_sectors</span><span class="p">;</span>
	<span class="n">host</span><span class="o">-&gt;</span><span class="n">cmd_per_lun</span>	<span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">cmd_per_lun</span><span class="p">;</span>
	<span class="n">host</span><span class="o">-&gt;</span><span class="n">max_channel</span>	<span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">max_channel</span><span class="p">;</span>
	<span class="n">host</span><span class="o">-&gt;</span><span class="n">max_id</span>		<span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">max_target</span><span class="p">;</span>
	<span class="n">host</span><span class="o">-&gt;</span><span class="n">max_lun</span>		<span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">max_lun</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-28"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-28">&#182;</a></div><p>notify mid-layer about the new controller</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span> <span class="p">(</span><span class="n">scsi_add_host</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>

		<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="n">KERN_WARNING</span>
			<span class="s">&quot;megaraid mbox: scsi_add_host failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>

		<span class="n">scsi_host_put</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>

		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">scsi_scan_host</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * megaraid_io_detach - detach a device from the IO subsystem</span>
<span class="cm"> * @adapter		: controller&#39;s soft state</span>
<span class="cm"> *</span>
<span class="cm"> * Detach this device from the IO subsystem.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">megaraid_io_detach</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>	<span class="o">*</span><span class="n">host</span><span class="p">;</span>

	<span class="n">con_log</span><span class="p">(</span><span class="n">CL_DLEVEL1</span><span class="p">,</span> <span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;megaraid: io detach</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>

	<span class="n">host</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>

	<span class="n">scsi_remove_host</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * START: Mailbox Low Level Driver</span>
<span class="cm"> *</span>
<span class="cm"> * This is section specific to the single mailbox based controllers</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * megaraid_init_mbox - initialize controller</span>
<span class="cm"> * @adapter		: our soft state</span>
<span class="cm"> *</span>
<span class="cm"> * - Allocate 16-byte aligned mailbox memory for firmware handshake</span>
<span class="cm"> * - Allocate controller&#39;s memory resources</span>
<span class="cm"> * - Find out all initialization data</span>
<span class="cm"> * - Allocate memory required for all the commands</span>
<span class="cm"> * - Use internal library of FW routines, build up complete soft state</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span>
<span class="nf">megaraid_init_mbox</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span>		<span class="o">*</span><span class="n">pdev</span><span class="p">;</span>
	<span class="n">mraid_device_t</span>		<span class="o">*</span><span class="n">raid_dev</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">i</span><span class="p">;</span>
	<span class="kt">uint32_t</span>		<span class="n">magic64</span><span class="p">;</span>


	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ito</span>	<span class="o">=</span> <span class="n">MBOX_TIMEOUT</span><span class="p">;</span>
	<span class="n">pdev</span>		<span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate and initialize the init data structure for mailbox</span>
<span class="cm">	 * controllers</span>
<span class="cm">	 */</span>
	<span class="n">raid_dev</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">mraid_device_t</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">raid_dev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>


	<span class="cm">/*</span>
<span class="cm">	 * Attach the adapter soft state to raid device soft state</span>
<span class="cm">	 */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">raid_device</span>	<span class="o">=</span> <span class="p">(</span><span class="n">caddr_t</span><span class="p">)</span><span class="n">raid_dev</span><span class="p">;</span>
	<span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">fast_load</span>	<span class="o">=</span> <span class="n">megaraid_fast_load</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-29"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-29">&#182;</a></div><p>our baseport</p></td><td class="code"><div class="highlight"><pre>	<span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">baseport</span> <span class="o">=</span> <span class="n">pci_resource_start</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pci_request_regions</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="s">&quot;MegaRAID: LSI Logic Corporation&quot;</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="n">KERN_WARNING</span>
				<span class="s">&quot;megaraid: mem region busy</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>

		<span class="k">goto</span> <span class="n">out_free_raid_dev</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">baseaddr</span> <span class="o">=</span> <span class="n">ioremap_nocache</span><span class="p">(</span><span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">baseport</span><span class="p">,</span> <span class="mi">128</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">baseaddr</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="n">KERN_WARNING</span>
			<span class="s">&quot;megaraid: could not map hba memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span> <span class="p">);</span>

		<span class="k">goto</span> <span class="n">out_release_regions</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* initialize the mutual exclusion lock for the mailbox */</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">mailbox_lock</span><span class="p">);</span>

	<span class="cm">/* allocate memory required for commands */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">megaraid_alloc_cmd_packets</span><span class="p">(</span><span class="n">adapter</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_iounmap</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Issue SYNC cmd to flush the pending cmds in the adapter</span>
<span class="cm">	 * and initialize its internal state</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">megaraid_mbox_fire_sync_cmd</span><span class="p">(</span><span class="n">adapter</span><span class="p">))</span>
		<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;megaraid: sync cmd failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Setup the rest of the soft state using the library of</span>
<span class="cm">	 * FW routines</span>
<span class="cm">	 */</span>

	<span class="cm">/* request IRQ and register the interrupt service routine */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">request_irq</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">megaraid_isr</span><span class="p">,</span> <span class="n">IRQF_SHARED</span><span class="p">,</span> <span class="s">&quot;megaraid&quot;</span><span class="p">,</span>
		<span class="n">adapter</span><span class="p">))</span> <span class="p">{</span>

		<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="n">KERN_WARNING</span>
			<span class="s">&quot;megaraid: Couldn&#39;t register IRQ %d!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">));</span>
		<span class="k">goto</span> <span class="n">out_alloc_cmds</span><span class="p">;</span>

	<span class="p">}</span></pre></div></td></tr>


<tr id="section-30"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-30">&#182;</a></div><p>Product info</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span> <span class="p">(</span><span class="n">megaraid_mbox_product_info</span><span class="p">(</span><span class="n">adapter</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free_irq</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-31"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-31">&#182;</a></div><p>Do we support extended CDBs</p></td><td class="code"><div class="highlight"><pre>	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">max_cdb_sz</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">megaraid_mbox_extended_cdb</span><span class="p">(</span><span class="n">adapter</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">max_cdb_sz</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Do we support cluster environment, if we do, what is the initiator</span>
<span class="cm">	 * id.</span>
<span class="cm">	 * NOTE: In a non-cluster aware firmware environment, the LLD should</span>
<span class="cm">	 * return 7 as initiator id.</span>
<span class="cm">	 */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ha</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">init_id</span>	<span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">megaraid_mbox_support_ha</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">init_id</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ha</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Prepare the device ids array to have the mapping between the kernel</span>
<span class="cm">	 * device address and megaraid device address.</span>
<span class="cm">	 * We export the physical devices on their actual addresses. The</span>
<span class="cm">	 * logical drives are exported on a virtual SCSI channel</span>
<span class="cm">	 */</span>
	<span class="n">megaraid_mbox_setup_device_map</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-32"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-32">&#182;</a></div><p>If the firmware supports random deletion, update the device id map</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span> <span class="p">(</span><span class="n">megaraid_mbox_support_random_del</span><span class="p">(</span><span class="n">adapter</span><span class="p">))</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-33"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-33">&#182;</a></div><p>Change the logical drives numbers in device<em>ids array one
slot in device</em>ids is reserved for target id, that's why
"&lt;=" below</p></td><td class="code"><div class="highlight"><pre>		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">MAX_LOGICAL_DRIVES_40LD</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">device_ids</span><span class="p">[</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">max_channel</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mh">0x80</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">device_ids</span><span class="p">[</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">max_channel</span><span class="p">][</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">init_id</span><span class="p">]</span> <span class="o">=</span>
			<span class="mh">0xFF</span><span class="p">;</span>

		<span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">random_del_supported</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * find out the maximum number of scatter-gather elements supported by</span>
<span class="cm">	 * this firmware</span>
<span class="cm">	 */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sglen</span> <span class="o">=</span> <span class="n">megaraid_mbox_get_max_sg</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-34"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-34">&#182;</a></div><p>enumerate RAID and SCSI channels so that all devices on SCSI
channels can later be exported, including disk devices</p></td><td class="code"><div class="highlight"><pre>	<span class="n">megaraid_mbox_enum_raid_scsi</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Other parameters required by upper layer</span>
<span class="cm">	 *</span>
<span class="cm">	 * maximum number of sectors per IO command</span>
<span class="cm">	 */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">max_sectors</span> <span class="o">=</span> <span class="n">megaraid_max_sectors</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * number of queued commands per LUN.</span>
<span class="cm">	 */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">cmd_per_lun</span> <span class="o">=</span> <span class="n">megaraid_cmd_per_lun</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate resources required to issue FW calls, when sysfs is</span>
<span class="cm">	 * accessed</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">megaraid_sysfs_alloc_resources</span><span class="p">(</span><span class="n">adapter</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free_irq</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-35"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-35">&#182;</a></div><p>Set the DMA mask to 64-bit. All supported controllers as capable of
DMA in this range</p></td><td class="code"><div class="highlight"><pre>	<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_CONF_AMISIG64</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">magic64</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(((</span><span class="n">magic64</span> <span class="o">==</span> <span class="n">HBA_SIGNATURE_64_BIT</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="p">((</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">subsystem_device</span> <span class="o">!=</span>
		<span class="n">PCI_SUBSYS_ID_MEGARAID_SATA_150_6</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">subsystem_device</span> <span class="o">!=</span>
		<span class="n">PCI_SUBSYS_ID_MEGARAID_SATA_150_4</span><span class="p">)))</span> <span class="o">||</span>
		<span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">vendor</span> <span class="o">==</span> <span class="n">PCI_VENDOR_ID_LSI_LOGIC</span> <span class="o">&amp;&amp;</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_VERDE</span><span class="p">)</span> <span class="o">||</span>
		<span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">vendor</span> <span class="o">==</span> <span class="n">PCI_VENDOR_ID_LSI_LOGIC</span> <span class="o">&amp;&amp;</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_DOBSON</span><span class="p">)</span> <span class="o">||</span>
		<span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">vendor</span> <span class="o">==</span> <span class="n">PCI_VENDOR_ID_LSI_LOGIC</span> <span class="o">&amp;&amp;</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_LINDSAY</span><span class="p">)</span> <span class="o">||</span>
		<span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">vendor</span> <span class="o">==</span> <span class="n">PCI_VENDOR_ID_DELL</span> <span class="o">&amp;&amp;</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_PERC4_DI_EVERGLADES</span><span class="p">)</span> <span class="o">||</span>
		<span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">vendor</span> <span class="o">==</span> <span class="n">PCI_VENDOR_ID_DELL</span> <span class="o">&amp;&amp;</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_PERC4E_DI_KOBUK</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pci_set_dma_mask</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">64</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="n">KERN_WARNING</span>
				<span class="s">&quot;megaraid: DMA mask for 64-bit failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">pci_set_dma_mask</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">32</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="n">KERN_WARNING</span>
					<span class="s">&quot;megaraid: 32-bit DMA mask failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
				<span class="k">goto</span> <span class="n">out_free_sysfs_res</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-36"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-36">&#182;</a></div><p>setup tasklet for DPC</p></td><td class="code"><div class="highlight"><pre>	<span class="n">tasklet_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">dpc_h</span><span class="p">,</span> <span class="n">megaraid_mbox_dpc</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">con_log</span><span class="p">(</span><span class="n">CL_DLEVEL1</span><span class="p">,</span> <span class="p">(</span><span class="n">KERN_INFO</span>
		<span class="s">&quot;megaraid mbox hba successfully initialized</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_free_sysfs_res:</span>
	<span class="n">megaraid_sysfs_free_resources</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
<span class="nl">out_free_irq:</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">adapter</span><span class="p">);</span>
<span class="nl">out_alloc_cmds:</span>
	<span class="n">megaraid_free_cmd_packets</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
<span class="nl">out_iounmap:</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">baseaddr</span><span class="p">);</span>
<span class="nl">out_release_regions:</span>
	<span class="n">pci_release_regions</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
<span class="nl">out_free_raid_dev:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">raid_dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * megaraid_fini_mbox - undo controller initialization</span>
<span class="cm"> * @adapter		: our soft state</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">megaraid_fini_mbox</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mraid_device_t</span> <span class="o">*</span><span class="n">raid_dev</span> <span class="o">=</span> <span class="n">ADAP2RAIDDEV</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-37"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-37">&#182;</a></div><p>flush all caches</p></td><td class="code"><div class="highlight"><pre>	<span class="n">megaraid_mbox_flush_cache</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">tasklet_kill</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">dpc_h</span><span class="p">);</span>

	<span class="n">megaraid_sysfs_free_resources</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">megaraid_free_cmd_packets</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">free_irq</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">adapter</span><span class="p">);</span>

	<span class="n">iounmap</span><span class="p">(</span><span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">baseaddr</span><span class="p">);</span>

	<span class="n">pci_release_regions</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">raid_dev</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * megaraid_alloc_cmd_packets - allocate shared mailbox</span>
<span class="cm"> * @adapter		: soft state of the raid controller</span>
<span class="cm"> *</span>
<span class="cm"> * Allocate and align the shared mailbox. This maibox is used to issue</span>
<span class="cm"> * all the commands. For IO based controllers, the mailbox is also regsitered</span>
<span class="cm"> * with the FW. Allocate memory for all commands as well.</span>
<span class="cm"> * This is our big allocator.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">megaraid_alloc_cmd_packets</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mraid_device_t</span>		<span class="o">*</span><span class="n">raid_dev</span> <span class="o">=</span> <span class="n">ADAP2RAIDDEV</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pci_dev</span>		<span class="o">*</span><span class="n">pdev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">align</span><span class="p">;</span>
	<span class="n">scb_t</span>			<span class="o">*</span><span class="n">scb</span><span class="p">;</span>
	<span class="n">mbox_ccb_t</span>		<span class="o">*</span><span class="n">ccb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mraid_pci_blk</span>	<span class="o">*</span><span class="n">epthru_pci_blk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mraid_pci_blk</span>	<span class="o">*</span><span class="n">sg_pci_blk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mraid_pci_blk</span>	<span class="o">*</span><span class="n">mbox_pci_blk</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">i</span><span class="p">;</span>

	<span class="n">pdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Setup the mailbox</span>
<span class="cm">	 * Allocate the common 16-byte aligned memory for the handshake</span>
<span class="cm">	 * mailbox.</span>
<span class="cm">	 */</span>
	<span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">una_mbox64</span> <span class="o">=</span> <span class="n">pci_alloc_consistent</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="n">mbox64_t</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">una_mbox64_dma</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">una_mbox64</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="n">KERN_WARNING</span>
			<span class="s">&quot;megaraid: out of memory, %s %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
			<span class="n">__LINE__</span><span class="p">));</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">una_mbox64</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mbox64_t</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Align the mailbox at 16-byte boundary</span>
<span class="cm">	 */</span>
	<span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">mbox</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">una_mbox64</span><span class="o">-&gt;</span><span class="n">mbox32</span><span class="p">;</span>

	<span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">mbox</span>	<span class="o">=</span> <span class="p">(</span><span class="n">mbox_t</span> <span class="o">*</span><span class="p">)((((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">mbox</span><span class="p">)</span> <span class="o">+</span> <span class="mi">15</span><span class="p">)</span> <span class="o">&amp;</span>
				<span class="p">(</span><span class="o">~</span><span class="mi">0UL</span> <span class="o">^</span> <span class="mh">0xFUL</span><span class="p">));</span>

	<span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">mbox64</span> <span class="o">=</span> <span class="p">(</span><span class="n">mbox64_t</span> <span class="o">*</span><span class="p">)(((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">mbox</span><span class="p">)</span> <span class="o">-</span> <span class="mi">8</span><span class="p">);</span>

	<span class="n">align</span> <span class="o">=</span> <span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">mbox</span> <span class="o">-</span>
			<span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">una_mbox64</span><span class="o">-&gt;</span><span class="n">mbox32</span><span class="p">));</span>

	<span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">mbox_dma</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">una_mbox64_dma</span> <span class="o">+</span> <span class="mi">8</span> <span class="o">+</span>
			<span class="n">align</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-38"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-38">&#182;</a></div><p>Allocate memory for commands issued internally</p></td><td class="code"><div class="highlight"><pre>	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ibuf</span> <span class="o">=</span> <span class="n">pci_alloc_consistent</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">MBOX_IBUF_SIZE</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ibuf_dma_h</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ibuf</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="n">KERN_WARNING</span>
			<span class="s">&quot;megaraid: out of memory, %s %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
			<span class="n">__LINE__</span><span class="p">));</span>

		<span class="k">goto</span> <span class="n">out_free_common_mbox</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ibuf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MBOX_IBUF_SIZE</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-39"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-39">&#182;</a></div><p>Allocate memory for our SCSI Command Blocks and their associated
memory</p></td><td class="code"><div class="highlight"><pre>	<span class="cm">/*</span>
<span class="cm">	 * Allocate memory for the base list of scb. Later allocate memory for</span>
<span class="cm">	 * CCBs and embedded components of each CCB and point the pointers in</span>
<span class="cm">	 * scb to the allocated components</span>
<span class="cm">	 * NOTE: The code to allocate SCB will be duplicated in all the LLD</span>
<span class="cm">	 * since the calling routine does not yet know the number of available</span>
<span class="cm">	 * commands.</span>
<span class="cm">	 */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">kscb_list</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">MBOX_MAX_SCSI_CMDS</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">scb_t</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">kscb_list</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="n">KERN_WARNING</span>
			<span class="s">&quot;megaraid: out of memory, %s %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
			<span class="n">__LINE__</span><span class="p">));</span>
		<span class="k">goto</span> <span class="n">out_free_ibuf</span><span class="p">;</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-40"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-40">&#182;</a></div><p>memory allocation for our command packets</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span> <span class="p">(</span><span class="n">megaraid_mbox_setup_dma_pools</span><span class="p">(</span><span class="n">adapter</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="n">KERN_WARNING</span>
			<span class="s">&quot;megaraid: out of memory, %s %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
			<span class="n">__LINE__</span><span class="p">));</span>
		<span class="k">goto</span> <span class="n">out_free_scb_list</span><span class="p">;</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-41"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-41">&#182;</a></div><p>Adjust the scb pointers and link in the free pool</p></td><td class="code"><div class="highlight"><pre>	<span class="n">epthru_pci_blk</span>	<span class="o">=</span> <span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">epthru_pool</span><span class="p">;</span>
	<span class="n">sg_pci_blk</span>	<span class="o">=</span> <span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">sg_pool</span><span class="p">;</span>
	<span class="n">mbox_pci_blk</span>	<span class="o">=</span> <span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">mbox_pool</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MBOX_MAX_SCSI_CMDS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">scb</span>			<span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">kscb_list</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">ccb</span>			<span class="o">=</span> <span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">ccb_list</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>

		<span class="n">ccb</span><span class="o">-&gt;</span><span class="n">mbox</span>	<span class="o">=</span> <span class="p">(</span><span class="n">mbox_t</span> <span class="o">*</span><span class="p">)(</span><span class="n">mbox_pci_blk</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vaddr</span> <span class="o">+</span> <span class="mi">16</span><span class="p">);</span>
		<span class="n">ccb</span><span class="o">-&gt;</span><span class="n">raw_mbox</span>	<span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span><span class="n">ccb</span><span class="o">-&gt;</span><span class="n">mbox</span><span class="p">;</span>
		<span class="n">ccb</span><span class="o">-&gt;</span><span class="n">mbox64</span>	<span class="o">=</span> <span class="p">(</span><span class="n">mbox64_t</span> <span class="o">*</span><span class="p">)(</span><span class="n">mbox_pci_blk</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vaddr</span> <span class="o">+</span> <span class="mi">8</span><span class="p">);</span>
		<span class="n">ccb</span><span class="o">-&gt;</span><span class="n">mbox_dma_h</span>	<span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">mbox_pci_blk</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">dma_addr</span> <span class="o">+</span> <span class="mi">16</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-42"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-42">&#182;</a></div><p>make sure the mailbox is aligned properly</p></td><td class="code"><div class="highlight"><pre>		<span class="k">if</span> <span class="p">(</span><span class="n">ccb</span><span class="o">-&gt;</span><span class="n">mbox_dma_h</span> <span class="o">&amp;</span> <span class="mh">0x0F</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="n">KERN_CRIT</span>
				<span class="s">&quot;megaraid mbox: not aligned on 16-bytes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>

			<span class="k">goto</span> <span class="n">out_teardown_dma_pools</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ccb</span><span class="o">-&gt;</span><span class="n">epthru</span>		<span class="o">=</span> <span class="p">(</span><span class="n">mraid_epassthru_t</span> <span class="o">*</span><span class="p">)</span>
						<span class="n">epthru_pci_blk</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vaddr</span><span class="p">;</span>
		<span class="n">ccb</span><span class="o">-&gt;</span><span class="n">epthru_dma_h</span>	<span class="o">=</span> <span class="n">epthru_pci_blk</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">dma_addr</span><span class="p">;</span>
		<span class="n">ccb</span><span class="o">-&gt;</span><span class="n">pthru</span>		<span class="o">=</span> <span class="p">(</span><span class="n">mraid_passthru_t</span> <span class="o">*</span><span class="p">)</span><span class="n">ccb</span><span class="o">-&gt;</span><span class="n">epthru</span><span class="p">;</span>
		<span class="n">ccb</span><span class="o">-&gt;</span><span class="n">pthru_dma_h</span>	<span class="o">=</span> <span class="n">ccb</span><span class="o">-&gt;</span><span class="n">epthru_dma_h</span><span class="p">;</span>


		<span class="n">ccb</span><span class="o">-&gt;</span><span class="n">sgl64</span>		<span class="o">=</span> <span class="p">(</span><span class="n">mbox_sgl64</span> <span class="o">*</span><span class="p">)</span><span class="n">sg_pci_blk</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vaddr</span><span class="p">;</span>
		<span class="n">ccb</span><span class="o">-&gt;</span><span class="n">sgl_dma_h</span>		<span class="o">=</span> <span class="n">sg_pci_blk</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">dma_addr</span><span class="p">;</span>
		<span class="n">ccb</span><span class="o">-&gt;</span><span class="n">sgl32</span>		<span class="o">=</span> <span class="p">(</span><span class="n">mbox_sgl32</span> <span class="o">*</span><span class="p">)</span><span class="n">ccb</span><span class="o">-&gt;</span><span class="n">sgl64</span><span class="p">;</span>

		<span class="n">scb</span><span class="o">-&gt;</span><span class="n">ccb</span>		<span class="o">=</span> <span class="p">(</span><span class="n">caddr_t</span><span class="p">)</span><span class="n">ccb</span><span class="p">;</span>
		<span class="n">scb</span><span class="o">-&gt;</span><span class="n">gp</span>			<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">scb</span><span class="o">-&gt;</span><span class="n">sno</span>		<span class="o">=</span> <span class="n">i</span><span class="p">;</span>	<span class="c1">// command index</span>

		<span class="n">scb</span><span class="o">-&gt;</span><span class="n">scp</span>		<span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">scb</span><span class="o">-&gt;</span><span class="n">state</span>		<span class="o">=</span> <span class="n">SCB_FREE</span><span class="p">;</span>
		<span class="n">scb</span><span class="o">-&gt;</span><span class="n">dma_direction</span>	<span class="o">=</span> <span class="n">PCI_DMA_NONE</span><span class="p">;</span>
		<span class="n">scb</span><span class="o">-&gt;</span><span class="n">dma_type</span>		<span class="o">=</span> <span class="n">MRAID_DMA_NONE</span><span class="p">;</span>
		<span class="n">scb</span><span class="o">-&gt;</span><span class="n">dev_channel</span>	<span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">scb</span><span class="o">-&gt;</span><span class="n">dev_target</span>		<span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-43"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-43">&#182;</a></div><p>put scb in the free pool</p></td><td class="code"><div class="highlight"><pre>		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">kscb_pool</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_teardown_dma_pools:</span>
	<span class="n">megaraid_mbox_teardown_dma_pools</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
<span class="nl">out_free_scb_list:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">kscb_list</span><span class="p">);</span>
<span class="nl">out_free_ibuf:</span>
	<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">MBOX_IBUF_SIZE</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ibuf</span><span class="p">,</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ibuf_dma_h</span><span class="p">);</span>
<span class="nl">out_free_common_mbox:</span>
	<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mbox64_t</span><span class="p">),</span>
		<span class="p">(</span><span class="n">caddr_t</span><span class="p">)</span><span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">una_mbox64</span><span class="p">,</span> <span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">una_mbox64_dma</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * megaraid_free_cmd_packets - free memory</span>
<span class="cm"> * @adapter		: soft state of the raid controller</span>
<span class="cm"> *</span>
<span class="cm"> * Release memory resources allocated for commands.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">megaraid_free_cmd_packets</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mraid_device_t</span> <span class="o">*</span><span class="n">raid_dev</span> <span class="o">=</span> <span class="n">ADAP2RAIDDEV</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">megaraid_mbox_teardown_dma_pools</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">kscb_list</span><span class="p">);</span>

	<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">MBOX_IBUF_SIZE</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ibuf</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ibuf_dma_h</span><span class="p">);</span>

	<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mbox64_t</span><span class="p">),</span>
		<span class="p">(</span><span class="n">caddr_t</span><span class="p">)</span><span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">una_mbox64</span><span class="p">,</span> <span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">una_mbox64_dma</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * megaraid_mbox_setup_dma_pools - setup dma pool for command packets</span>
<span class="cm"> * @adapter		: HBA soft state</span>
<span class="cm"> *</span>
<span class="cm"> * Setup the dma pools for mailbox, passthru and extended passthru structures,</span>
<span class="cm"> * and scatter-gather lists.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">megaraid_mbox_setup_dma_pools</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mraid_device_t</span>		<span class="o">*</span><span class="n">raid_dev</span> <span class="o">=</span> <span class="n">ADAP2RAIDDEV</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">mraid_pci_blk</span>	<span class="o">*</span><span class="n">epthru_pci_blk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mraid_pci_blk</span>	<span class="o">*</span><span class="n">sg_pci_blk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mraid_pci_blk</span>	<span class="o">*</span><span class="n">mbox_pci_blk</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">i</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-44"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-44">&#182;</a></div><p>Allocate memory for 16-bytes aligned mailboxes</p></td><td class="code"><div class="highlight"><pre>	<span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">mbox_pool_handle</span> <span class="o">=</span> <span class="n">pci_pool_create</span><span class="p">(</span><span class="s">&quot;megaraid mbox pool&quot;</span><span class="p">,</span>
						<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
						<span class="k">sizeof</span><span class="p">(</span><span class="n">mbox64_t</span><span class="p">)</span> <span class="o">+</span> <span class="mi">16</span><span class="p">,</span>
						<span class="mi">16</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">mbox_pool_handle</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">goto</span> <span class="n">fail_setup_dma_pool</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mbox_pci_blk</span> <span class="o">=</span> <span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">mbox_pool</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MBOX_MAX_SCSI_CMDS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mbox_pci_blk</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vaddr</span> <span class="o">=</span> <span class="n">pci_pool_alloc</span><span class="p">(</span>
						<span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">mbox_pool_handle</span><span class="p">,</span>
						<span class="n">GFP_KERNEL</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">mbox_pci_blk</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">dma_addr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mbox_pci_blk</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vaddr</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">goto</span> <span class="n">fail_setup_dma_pool</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate memory for each embedded passthru strucuture pointer</span>
<span class="cm">	 * Request for a 128 bytes aligned structure for each passthru command</span>
<span class="cm">	 * structure</span>
<span class="cm">	 * Since passthru and extended passthru commands are exclusive, they</span>
<span class="cm">	 * share common memory pool. Passthru structures piggyback on memory</span>
<span class="cm">	 * allocted to extended passthru since passthru is smaller of the two</span>
<span class="cm">	 */</span>
	<span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">epthru_pool_handle</span> <span class="o">=</span> <span class="n">pci_pool_create</span><span class="p">(</span><span class="s">&quot;megaraid mbox pthru&quot;</span><span class="p">,</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mraid_epassthru_t</span><span class="p">),</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">epthru_pool_handle</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">goto</span> <span class="n">fail_setup_dma_pool</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">epthru_pci_blk</span> <span class="o">=</span> <span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">epthru_pool</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MBOX_MAX_SCSI_CMDS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">epthru_pci_blk</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vaddr</span> <span class="o">=</span> <span class="n">pci_pool_alloc</span><span class="p">(</span>
						<span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">epthru_pool_handle</span><span class="p">,</span>
						<span class="n">GFP_KERNEL</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">epthru_pci_blk</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">dma_addr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">epthru_pci_blk</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vaddr</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">goto</span> <span class="n">fail_setup_dma_pool</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-45"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-45">&#182;</a></div><p>Allocate memory for each scatter-gather list. Request for 512 bytes
alignment for each sg list</p></td><td class="code"><div class="highlight"><pre>	<span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">sg_pool_handle</span> <span class="o">=</span> <span class="n">pci_pool_create</span><span class="p">(</span><span class="s">&quot;megaraid mbox sg&quot;</span><span class="p">,</span>
					<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="n">mbox_sgl64</span><span class="p">)</span> <span class="o">*</span> <span class="n">MBOX_MAX_SG_SIZE</span><span class="p">,</span>
					<span class="mi">512</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">sg_pool_handle</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">goto</span> <span class="n">fail_setup_dma_pool</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sg_pci_blk</span> <span class="o">=</span> <span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">sg_pool</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MBOX_MAX_SCSI_CMDS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sg_pci_blk</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vaddr</span> <span class="o">=</span> <span class="n">pci_pool_alloc</span><span class="p">(</span>
						<span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">sg_pool_handle</span><span class="p">,</span>
						<span class="n">GFP_KERNEL</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">sg_pci_blk</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">dma_addr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sg_pci_blk</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vaddr</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">goto</span> <span class="n">fail_setup_dma_pool</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fail_setup_dma_pool:</span>
	<span class="n">megaraid_mbox_teardown_dma_pools</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * megaraid_mbox_teardown_dma_pools - teardown dma pools for command packets</span>
<span class="cm"> * @adapter		: HBA soft state</span>
<span class="cm"> *</span>
<span class="cm"> * Teardown the dma pool for mailbox, passthru and extended passthru</span>
<span class="cm"> * structures, and scatter-gather lists.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">megaraid_mbox_teardown_dma_pools</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mraid_device_t</span>		<span class="o">*</span><span class="n">raid_dev</span> <span class="o">=</span> <span class="n">ADAP2RAIDDEV</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">mraid_pci_blk</span>	<span class="o">*</span><span class="n">epthru_pci_blk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mraid_pci_blk</span>	<span class="o">*</span><span class="n">sg_pci_blk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mraid_pci_blk</span>	<span class="o">*</span><span class="n">mbox_pci_blk</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">i</span><span class="p">;</span>


	<span class="n">sg_pci_blk</span> <span class="o">=</span> <span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">sg_pool</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MBOX_MAX_SCSI_CMDS</span> <span class="o">&amp;&amp;</span> <span class="n">sg_pci_blk</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vaddr</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_pool_free</span><span class="p">(</span><span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">sg_pool_handle</span><span class="p">,</span> <span class="n">sg_pci_blk</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vaddr</span><span class="p">,</span>
			<span class="n">sg_pci_blk</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">dma_addr</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">sg_pool_handle</span><span class="p">)</span>
		<span class="n">pci_pool_destroy</span><span class="p">(</span><span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">sg_pool_handle</span><span class="p">);</span>


	<span class="n">epthru_pci_blk</span> <span class="o">=</span> <span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">epthru_pool</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MBOX_MAX_SCSI_CMDS</span> <span class="o">&amp;&amp;</span> <span class="n">epthru_pci_blk</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vaddr</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_pool_free</span><span class="p">(</span><span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">epthru_pool_handle</span><span class="p">,</span>
			<span class="n">epthru_pci_blk</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vaddr</span><span class="p">,</span> <span class="n">epthru_pci_blk</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">dma_addr</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">epthru_pool_handle</span><span class="p">)</span>
		<span class="n">pci_pool_destroy</span><span class="p">(</span><span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">epthru_pool_handle</span><span class="p">);</span>


	<span class="n">mbox_pci_blk</span> <span class="o">=</span> <span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">mbox_pool</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MBOX_MAX_SCSI_CMDS</span> <span class="o">&amp;&amp;</span> <span class="n">mbox_pci_blk</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vaddr</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_pool_free</span><span class="p">(</span><span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">mbox_pool_handle</span><span class="p">,</span>
			<span class="n">mbox_pci_blk</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vaddr</span><span class="p">,</span> <span class="n">mbox_pci_blk</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">dma_addr</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">mbox_pool_handle</span><span class="p">)</span>
		<span class="n">pci_pool_destroy</span><span class="p">(</span><span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">mbox_pool_handle</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * megaraid_alloc_scb - detach and return a scb from the free list</span>
<span class="cm"> * @adapter	: controller&#39;s soft state</span>
<span class="cm"> * @scp		: pointer to the scsi command to be executed</span>
<span class="cm"> *</span>
<span class="cm"> * Return the scb from the head of the free list. %NULL if there are none</span>
<span class="cm"> * available.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">scb_t</span> <span class="o">*</span>
<span class="nf">megaraid_alloc_scb</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">scp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">kscb_pool</span><span class="p">;</span>
	<span class="n">scb_t</span>			<span class="o">*</span><span class="n">scb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-46"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-46">&#182;</a></div><p>detach scb from free pool</p></td><td class="code"><div class="highlight"><pre>	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">SCSI_FREE_LIST_LOCK</span><span class="p">(</span><span class="n">adapter</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="n">head</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">SCSI_FREE_LIST_LOCK</span><span class="p">(</span><span class="n">adapter</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">scb</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">scb_t</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">SCSI_FREE_LIST_LOCK</span><span class="p">(</span><span class="n">adapter</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">scb</span><span class="o">-&gt;</span><span class="n">state</span>	<span class="o">=</span> <span class="n">SCB_ACTIVE</span><span class="p">;</span>
	<span class="n">scb</span><span class="o">-&gt;</span><span class="n">scp</span>	<span class="o">=</span> <span class="n">scp</span><span class="p">;</span>
	<span class="n">scb</span><span class="o">-&gt;</span><span class="n">dma_type</span>	<span class="o">=</span> <span class="n">MRAID_DMA_NONE</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">scb</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * megaraid_dealloc_scb - return the scb to the free pool</span>
<span class="cm"> * @adapter	: controller&#39;s soft state</span>
<span class="cm"> * @scb		: scb to be freed</span>
<span class="cm"> *</span>
<span class="cm"> * Return the scb back to the free list of scbs. The caller must &#39;flush&#39; the</span>
<span class="cm"> * SCB before calling us. E.g., performing pci_unamp and/or pci_sync etc.</span>
<span class="cm"> * NOTE NOTE: Make sure the scb is not on any list before calling this</span>
<span class="cm"> * routine.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">megaraid_dealloc_scb</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="n">scb_t</span> <span class="o">*</span><span class="n">scb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-47"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-47">&#182;</a></div><p>put scb in the free pool</p></td><td class="code"><div class="highlight"><pre>	<span class="n">scb</span><span class="o">-&gt;</span><span class="n">state</span>	<span class="o">=</span> <span class="n">SCB_FREE</span><span class="p">;</span>
	<span class="n">scb</span><span class="o">-&gt;</span><span class="n">scp</span>	<span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">SCSI_FREE_LIST_LOCK</span><span class="p">(</span><span class="n">adapter</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">kscb_pool</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">SCSI_FREE_LIST_LOCK</span><span class="p">(</span><span class="n">adapter</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * megaraid_mbox_mksgl - make the scatter-gather list</span>
<span class="cm"> * @adapter	: controller&#39;s soft state</span>
<span class="cm"> * @scb		: scsi control block</span>
<span class="cm"> *</span>
<span class="cm"> * Prepare the scatter-gather list.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">megaraid_mbox_mksgl</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="n">scb_t</span> <span class="o">*</span><span class="n">scb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scatterlist</span>	<span class="o">*</span><span class="n">sgl</span><span class="p">;</span>
	<span class="n">mbox_ccb_t</span>		<span class="o">*</span><span class="n">ccb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span>	<span class="o">*</span><span class="n">scp</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">sgcnt</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">i</span><span class="p">;</span>


	<span class="n">scp</span>	<span class="o">=</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">scp</span><span class="p">;</span>
	<span class="n">ccb</span>	<span class="o">=</span> <span class="p">(</span><span class="n">mbox_ccb_t</span> <span class="o">*</span><span class="p">)</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">ccb</span><span class="p">;</span>

	<span class="n">sgcnt</span> <span class="o">=</span> <span class="n">scsi_dma_map</span><span class="p">(</span><span class="n">scp</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">sgcnt</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">sgcnt</span> <span class="o">&gt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sglen</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-48"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-48">&#182;</a></div><p>no mapping required if no data to be transferred</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sgcnt</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">scb</span><span class="o">-&gt;</span><span class="n">dma_type</span> <span class="o">=</span> <span class="n">MRAID_DMA_WSG</span><span class="p">;</span>

	<span class="n">scsi_for_each_sg</span><span class="p">(</span><span class="n">scp</span><span class="p">,</span> <span class="n">sgl</span><span class="p">,</span> <span class="n">sgcnt</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ccb</span><span class="o">-&gt;</span><span class="n">sgl64</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">address</span>	<span class="o">=</span> <span class="n">sg_dma_address</span><span class="p">(</span><span class="n">sgl</span><span class="p">);</span>
		<span class="n">ccb</span><span class="o">-&gt;</span><span class="n">sgl64</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">length</span>	<span class="o">=</span> <span class="n">sg_dma_len</span><span class="p">(</span><span class="n">sgl</span><span class="p">);</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-49"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-49">&#182;</a></div><p>Return count of SG nodes</p></td><td class="code"><div class="highlight"><pre>	<span class="k">return</span> <span class="n">sgcnt</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * mbox_post_cmd - issue a mailbox command</span>
<span class="cm"> * @adapter	: controller&#39;s soft state</span>
<span class="cm"> * @scb		: command to be issued</span>
<span class="cm"> *</span>
<span class="cm"> * Post the command to the controller if mailbox is available.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">mbox_post_cmd</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="n">scb_t</span> <span class="o">*</span><span class="n">scb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mraid_device_t</span>	<span class="o">*</span><span class="n">raid_dev</span> <span class="o">=</span> <span class="n">ADAP2RAIDDEV</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">mbox64_t</span>	<span class="o">*</span><span class="n">mbox64</span><span class="p">;</span>
	<span class="n">mbox_t</span>		<span class="o">*</span><span class="n">mbox</span><span class="p">;</span>
	<span class="n">mbox_ccb_t</span>	<span class="o">*</span><span class="n">ccb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>


	<span class="n">ccb</span>	<span class="o">=</span> <span class="p">(</span><span class="n">mbox_ccb_t</span> <span class="o">*</span><span class="p">)</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">ccb</span><span class="p">;</span>
	<span class="n">mbox</span>	<span class="o">=</span> <span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">mbox</span><span class="p">;</span>
	<span class="n">mbox64</span>	<span class="o">=</span> <span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">mbox64</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check for busy mailbox. If it is, return failure - the caller</span>
<span class="cm">	 * should retry later.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">MAILBOX_LOCK</span><span class="p">(</span><span class="n">raid_dev</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">mbox</span><span class="o">-&gt;</span><span class="n">busy</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
			<span class="n">i</span><span class="o">++</span><span class="p">;</span>
			<span class="n">rmb</span><span class="p">();</span>
		<span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="n">mbox</span><span class="o">-&gt;</span><span class="n">busy</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">max_mbox_busy_wait</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">mbox</span><span class="o">-&gt;</span><span class="n">busy</span><span class="p">)</span> <span class="p">{</span>

			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">MAILBOX_LOCK</span><span class="p">(</span><span class="n">raid_dev</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>

			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-50"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-50">&#182;</a></div><p>Copy this command's mailbox data into "adapter's" mailbox</p></td><td class="code"><div class="highlight"><pre>	<span class="n">memcpy</span><span class="p">((</span><span class="n">caddr_t</span><span class="p">)</span><span class="n">mbox64</span><span class="p">,</span> <span class="p">(</span><span class="n">caddr_t</span><span class="p">)</span><span class="n">ccb</span><span class="o">-&gt;</span><span class="n">mbox64</span><span class="p">,</span> <span class="mi">22</span><span class="p">);</span>
	<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">cmdid</span> <span class="o">=</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">sno</span><span class="p">;</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">outstanding_cmds</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">dma_direction</span> <span class="o">==</span> <span class="n">PCI_DMA_TODEVICE</span><span class="p">)</span>
		<span class="n">pci_dma_sync_sg_for_device</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
					   <span class="n">scsi_sglist</span><span class="p">(</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">scp</span><span class="p">),</span>
					   <span class="n">scsi_sg_count</span><span class="p">(</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">scp</span><span class="p">),</span>
					   <span class="n">PCI_DMA_TODEVICE</span><span class="p">);</span>

	<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">busy</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">;</span>	<span class="c1">// Set busy</span>
	<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">poll</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">ack</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">wmb</span><span class="p">();</span>

	<span class="n">WRINDOOR</span><span class="p">(</span><span class="n">raid_dev</span><span class="p">,</span> <span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">mbox_dma</span> <span class="o">|</span> <span class="mh">0x1</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">MAILBOX_LOCK</span><span class="p">(</span><span class="n">raid_dev</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * megaraid_queue_command - generic queue entry point for all LLDs</span>
<span class="cm"> * @scp		: pointer to the scsi command to be executed</span>
<span class="cm"> * @done	: callback routine to be called after the cmd has be completed</span>
<span class="cm"> *</span>
<span class="cm"> * Queue entry point for mailbox based controllers.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">megaraid_queue_command_lck</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">scp</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">done</span><span class="p">)(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
	<span class="n">adapter_t</span>	<span class="o">*</span><span class="n">adapter</span><span class="p">;</span>
	<span class="n">scb_t</span>		<span class="o">*</span><span class="n">scb</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">if_busy</span><span class="p">;</span>

	<span class="n">adapter</span>		<span class="o">=</span> <span class="n">SCP2ADAPTER</span><span class="p">(</span><span class="n">scp</span><span class="p">);</span>
	<span class="n">scp</span><span class="o">-&gt;</span><span class="n">scsi_done</span>	<span class="o">=</span> <span class="n">done</span><span class="p">;</span>
	<span class="n">scp</span><span class="o">-&gt;</span><span class="n">result</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate and build a SCB request</span>
<span class="cm">	 * if_busy flag will be set if megaraid_mbox_build_cmd() command could</span>
<span class="cm">	 * not allocate scb. We will return non-zero status in that case.</span>
<span class="cm">	 * NOTE: scb can be null even though certain commands completed</span>
<span class="cm">	 * successfully, e.g., MODE_SENSE and TEST_UNIT_READY, it would</span>
<span class="cm">	 * return 0 in that case, and we would do the callback right away.</span>
<span class="cm">	 */</span>
	<span class="n">if_busy</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">scb</span> <span class="o">=</span> <span class="n">megaraid_mbox_build_cmd</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">scp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">if_busy</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">scb</span><span class="p">)</span> <span class="p">{</span>	<span class="c1">// command already completed</span>
		<span class="n">done</span><span class="p">(</span><span class="n">scp</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">megaraid_mbox_runpendq</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">if_busy</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="nf">DEF_SCSI_QCMD</span><span class="p">(</span><span class="n">megaraid_queue_command</span><span class="p">)</span>

<span class="cm">/**</span>
<span class="cm"> * megaraid_mbox_build_cmd - transform the mid-layer scsi commands</span>
<span class="cm"> * @adapter	: controller&#39;s soft state</span>
<span class="cm"> * @scp		: mid-layer scsi command pointer</span>
<span class="cm"> * @busy	: set if request could not be completed because of lack of</span>
<span class="cm"> *		resources</span>
<span class="cm"> *</span>
<span class="cm"> * Transform the mid-layer scsi command to megaraid firmware lingua.</span>
<span class="cm"> * Convert the command issued by mid-layer to format understood by megaraid</span>
<span class="cm"> * firmware. We also complete certain commands without sending them to firmware.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">scb_t</span> <span class="o">*</span>
<span class="n">megaraid_mbox_build_cmd</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">scp</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">busy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mraid_device_t</span>		<span class="o">*</span><span class="n">rdev</span> <span class="o">=</span> <span class="n">ADAP2RAIDDEV</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="n">channel</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">target</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">islogical</span><span class="p">;</span>
	<span class="n">mbox_ccb_t</span>		<span class="o">*</span><span class="n">ccb</span><span class="p">;</span>
	<span class="n">mraid_passthru_t</span>	<span class="o">*</span><span class="n">pthru</span><span class="p">;</span>
	<span class="n">mbox64_t</span>		<span class="o">*</span><span class="n">mbox64</span><span class="p">;</span>
	<span class="n">mbox_t</span>			<span class="o">*</span><span class="n">mbox</span><span class="p">;</span>
	<span class="n">scb_t</span>			<span class="o">*</span><span class="n">scb</span><span class="p">;</span>
	<span class="kt">char</span>			<span class="n">skip</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;skipping&quot;</span><span class="p">;</span>
	<span class="kt">char</span>			<span class="n">scan</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;scanning&quot;</span><span class="p">;</span>
	<span class="kt">char</span>			<span class="o">*</span><span class="n">ss</span><span class="p">;</span>


	<span class="cm">/*</span>
<span class="cm">	 * Get the appropriate device map for the device this command is</span>
<span class="cm">	 * intended for</span>
<span class="cm">	 */</span>
	<span class="n">MRAID_GET_DEVICE_MAP</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">scp</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">islogical</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Logical drive commands</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">islogical</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">TEST_UNIT_READY</span>:
			<span class="cm">/*</span>
<span class="cm">			 * Do we support clustering and is the support enabled</span>
<span class="cm">			 * If no, return success always</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ha</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">scp</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DID_OK</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
				<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">scb</span> <span class="o">=</span> <span class="n">megaraid_alloc_scb</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">scp</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">scp</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DID_ERROR</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
				<span class="o">*</span><span class="n">busy</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">scb</span><span class="o">-&gt;</span><span class="n">dma_direction</span>	<span class="o">=</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">sc_data_direction</span><span class="p">;</span>
			<span class="n">scb</span><span class="o">-&gt;</span><span class="n">dev_channel</span>	<span class="o">=</span> <span class="mh">0xFF</span><span class="p">;</span>
			<span class="n">scb</span><span class="o">-&gt;</span><span class="n">dev_target</span>		<span class="o">=</span> <span class="n">target</span><span class="p">;</span>
			<span class="n">ccb</span>			<span class="o">=</span> <span class="p">(</span><span class="n">mbox_ccb_t</span> <span class="o">*</span><span class="p">)</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">ccb</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * The command id will be provided by the command</span>
<span class="cm">			 * issuance routine</span>
<span class="cm">			 */</span>
			<span class="n">ccb</span><span class="o">-&gt;</span><span class="n">raw_mbox</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>	<span class="o">=</span> <span class="n">CLUSTER_CMD</span><span class="p">;</span>
			<span class="n">ccb</span><span class="o">-&gt;</span><span class="n">raw_mbox</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>	<span class="o">=</span> <span class="n">RESERVATION_STATUS</span><span class="p">;</span>
			<span class="n">ccb</span><span class="o">-&gt;</span><span class="n">raw_mbox</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>	<span class="o">=</span> <span class="n">target</span><span class="p">;</span>

			<span class="k">return</span> <span class="n">scb</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">MODE_SENSE</span>:
		<span class="p">{</span>
			<span class="k">struct</span> <span class="n">scatterlist</span>	<span class="o">*</span><span class="n">sgl</span><span class="p">;</span>
			<span class="n">caddr_t</span>			<span class="n">vaddr</span><span class="p">;</span>

			<span class="n">sgl</span> <span class="o">=</span> <span class="n">scsi_sglist</span><span class="p">(</span><span class="n">scp</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sg_page</span><span class="p">(</span><span class="n">sgl</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">vaddr</span> <span class="o">=</span> <span class="p">(</span><span class="n">caddr_t</span><span class="p">)</span> <span class="n">sg_virt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sgl</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

				<span class="n">memset</span><span class="p">(</span><span class="n">vaddr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span>
			<span class="p">}</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="n">KERN_WARNING</span>
						 <span class="s">&quot;megaraid mailbox: invalid sg:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						 <span class="n">__LINE__</span><span class="p">));</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">scp</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DID_OK</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">INQUIRY</span>:
			<span class="cm">/*</span>
<span class="cm">			 * Display the channel scan for logical drives</span>
<span class="cm">			 * Do not display scan for a channel if already done.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">rdev</span><span class="o">-&gt;</span><span class="n">last_disp</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1L</span> <span class="o">&lt;&lt;</span> <span class="n">SCP2CHANNEL</span><span class="p">(</span><span class="n">scp</span><span class="p">))))</span> <span class="p">{</span>

				<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="n">KERN_INFO</span>
					<span class="s">&quot;scsi[%d]: scanning scsi channel %d&quot;</span><span class="p">,</span>
					<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">,</span>
					<span class="n">SCP2CHANNEL</span><span class="p">(</span><span class="n">scp</span><span class="p">)));</span>

				<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span>
					<span class="s">&quot; [virtual] for logical drives</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>

				<span class="n">rdev</span><span class="o">-&gt;</span><span class="n">last_disp</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1L</span> <span class="o">&lt;&lt;</span> <span class="n">SCP2CHANNEL</span><span class="p">(</span><span class="n">scp</span><span class="p">));</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">MEGA_SCSI_INQ_EVPD</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">scp</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x70</span><span class="p">;</span>
				<span class="n">scp</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">ILLEGAL_REQUEST</span><span class="p">;</span>
				<span class="n">scp</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="n">MEGA_INVALID_FIELD_IN_CDB</span><span class="p">;</span>
				<span class="n">scp</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">CHECK_CONDITION</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* Fall through */</span>

		<span class="k">case</span> <span class="n">READ_CAPACITY</span>:
			<span class="cm">/*</span>
<span class="cm">			 * Do not allow LUN &gt; 0 for logical drives and</span>
<span class="cm">			 * requests for more than 40 logical drives</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">SCP2LUN</span><span class="p">(</span><span class="n">scp</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">scp</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DID_BAD_TARGET</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
				<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">target</span> <span class="o">%</span> <span class="mh">0x80</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">MAX_LOGICAL_DRIVES_40LD</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">scp</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DID_BAD_TARGET</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
				<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>


			<span class="cm">/* Allocate a SCB and initialize passthru */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">scb</span> <span class="o">=</span> <span class="n">megaraid_alloc_scb</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">scp</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">scp</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DID_ERROR</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
				<span class="o">*</span><span class="n">busy</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">ccb</span>			<span class="o">=</span> <span class="p">(</span><span class="n">mbox_ccb_t</span> <span class="o">*</span><span class="p">)</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">ccb</span><span class="p">;</span>
			<span class="n">scb</span><span class="o">-&gt;</span><span class="n">dev_channel</span>	<span class="o">=</span> <span class="mh">0xFF</span><span class="p">;</span>
			<span class="n">scb</span><span class="o">-&gt;</span><span class="n">dev_target</span>		<span class="o">=</span> <span class="n">target</span><span class="p">;</span>
			<span class="n">pthru</span>			<span class="o">=</span> <span class="n">ccb</span><span class="o">-&gt;</span><span class="n">pthru</span><span class="p">;</span>
			<span class="n">mbox</span>			<span class="o">=</span> <span class="n">ccb</span><span class="o">-&gt;</span><span class="n">mbox</span><span class="p">;</span>
			<span class="n">mbox64</span>			<span class="o">=</span> <span class="n">ccb</span><span class="o">-&gt;</span><span class="n">mbox64</span><span class="p">;</span>

			<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">timeout</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">ars</span>		<span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">reqsenselen</span>	<span class="o">=</span> <span class="mi">14</span><span class="p">;</span>
			<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">islogical</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">logdrv</span>		<span class="o">=</span> <span class="n">target</span><span class="p">;</span>
			<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">cdblen</span>		<span class="o">=</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmd_len</span><span class="p">;</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">pthru</span><span class="o">-&gt;</span><span class="n">cdb</span><span class="p">,</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">,</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmd_len</span><span class="p">);</span>

			<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">cmd</span>		<span class="o">=</span> <span class="n">MBOXCMD_PASSTHRU64</span><span class="p">;</span>
			<span class="n">scb</span><span class="o">-&gt;</span><span class="n">dma_direction</span>	<span class="o">=</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">sc_data_direction</span><span class="p">;</span>

			<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">dataxferlen</span>	<span class="o">=</span> <span class="n">scsi_bufflen</span><span class="p">(</span><span class="n">scp</span><span class="p">);</span>
			<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">dataxferaddr</span>	<span class="o">=</span> <span class="n">ccb</span><span class="o">-&gt;</span><span class="n">sgl_dma_h</span><span class="p">;</span>
			<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">numsge</span>		<span class="o">=</span> <span class="n">megaraid_mbox_mksgl</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span>
							<span class="n">scb</span><span class="p">);</span>

			<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">xferaddr</span>		<span class="o">=</span> <span class="mh">0xFFFFFFFF</span><span class="p">;</span>
			<span class="n">mbox64</span><span class="o">-&gt;</span><span class="n">xferaddr_lo</span>	<span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="p">)</span><span class="n">ccb</span><span class="o">-&gt;</span><span class="n">pthru_dma_h</span><span class="p">;</span>
			<span class="n">mbox64</span><span class="o">-&gt;</span><span class="n">xferaddr_hi</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="k">return</span> <span class="n">scb</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">READ_6</span>:
		<span class="k">case</span> <span class="n">WRITE_6</span>:
		<span class="k">case</span> <span class="n">READ_10</span>:
		<span class="k">case</span> <span class="n">WRITE_10</span>:
		<span class="k">case</span> <span class="n">READ_12</span>:
		<span class="k">case</span> <span class="n">WRITE_12</span>:

			<span class="cm">/*</span>
<span class="cm">			 * Allocate a SCB and initialize mailbox</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">scb</span> <span class="o">=</span> <span class="n">megaraid_alloc_scb</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">scp</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">scp</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DID_ERROR</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
				<span class="o">*</span><span class="n">busy</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">ccb</span>			<span class="o">=</span> <span class="p">(</span><span class="n">mbox_ccb_t</span> <span class="o">*</span><span class="p">)</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">ccb</span><span class="p">;</span>
			<span class="n">scb</span><span class="o">-&gt;</span><span class="n">dev_channel</span>	<span class="o">=</span> <span class="mh">0xFF</span><span class="p">;</span>
			<span class="n">scb</span><span class="o">-&gt;</span><span class="n">dev_target</span>		<span class="o">=</span> <span class="n">target</span><span class="p">;</span>
			<span class="n">mbox</span>			<span class="o">=</span> <span class="n">ccb</span><span class="o">-&gt;</span><span class="n">mbox</span><span class="p">;</span>
			<span class="n">mbox64</span>			<span class="o">=</span> <span class="n">ccb</span><span class="o">-&gt;</span><span class="n">mbox64</span><span class="p">;</span>
			<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">logdrv</span>		<span class="o">=</span> <span class="n">target</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * A little HACK: 2nd bit is zero for all scsi read</span>
<span class="cm">			 * commands and is set for all scsi write commands</span>
<span class="cm">			 */</span>
			<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">=</span> <span class="p">(</span><span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x02</span><span class="p">)</span> <span class="o">?</span>  <span class="n">MBOXCMD_LWRITE64</span><span class="o">:</span>
					<span class="n">MBOXCMD_LREAD64</span> <span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * 6-byte READ(0x08) or WRITE(0x0A) cdb</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmd_len</span> <span class="o">==</span> <span class="mi">6</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">numsectors</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
				<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">lba</span> <span class="o">=</span>
					<span class="p">((</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span>	<span class="o">|</span>
					<span class="p">((</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span>	<span class="o">|</span>
					<span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>

				<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">lba</span> <span class="o">&amp;=</span> <span class="mh">0x1FFFFF</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * 10-byte READ(0x28) or WRITE(0x2A) cdb</span>
<span class="cm">			 */</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmd_len</span> <span class="o">==</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">numsectors</span> <span class="o">=</span>
					<span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">|</span>
					<span class="p">((</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>
				<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">lba</span> <span class="o">=</span>
					<span class="p">((</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span>
					<span class="p">((</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span>
					<span class="p">((</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span>
					<span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * 12-byte READ(0xA8) or WRITE(0xAA) cdb</span>
<span class="cm">			 */</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmd_len</span> <span class="o">==</span> <span class="mi">12</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">lba</span> <span class="o">=</span>
					<span class="p">((</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span>
					<span class="p">((</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span>
					<span class="p">((</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span>
					<span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>

				<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">numsectors</span> <span class="o">=</span>
					<span class="p">((</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span>
					<span class="p">((</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span>
					<span class="p">((</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span>
					<span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">9</span><span class="p">];</span>
			<span class="p">}</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="n">KERN_WARNING</span>
					<span class="s">&quot;megaraid: unsupported CDB length</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>

				<span class="n">megaraid_dealloc_scb</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>

				<span class="n">scp</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DID_ERROR</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
				<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">scb</span><span class="o">-&gt;</span><span class="n">dma_direction</span> <span class="o">=</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">sc_data_direction</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-51"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-51">&#182;</a></div><p>Calculate Scatter-Gather info</p></td><td class="code"><div class="highlight"><pre>			<span class="n">mbox64</span><span class="o">-&gt;</span><span class="n">xferaddr_lo</span>	<span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="p">)</span><span class="n">ccb</span><span class="o">-&gt;</span><span class="n">sgl_dma_h</span><span class="p">;</span>
			<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">numsge</span>		<span class="o">=</span> <span class="n">megaraid_mbox_mksgl</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span>
							<span class="n">scb</span><span class="p">);</span>
			<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">xferaddr</span>		<span class="o">=</span> <span class="mh">0xFFFFFFFF</span><span class="p">;</span>
			<span class="n">mbox64</span><span class="o">-&gt;</span><span class="n">xferaddr_hi</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="k">return</span> <span class="n">scb</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">RESERVE</span>:
		<span class="k">case</span> <span class="n">RELEASE</span>:
			<span class="cm">/*</span>
<span class="cm">			 * Do we support clustering and is the support enabled</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ha</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">scp</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DID_BAD_TARGET</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
				<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * Allocate a SCB and initialize mailbox</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">scb</span> <span class="o">=</span> <span class="n">megaraid_alloc_scb</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">scp</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">scp</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DID_ERROR</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
				<span class="o">*</span><span class="n">busy</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">ccb</span>			<span class="o">=</span> <span class="p">(</span><span class="n">mbox_ccb_t</span> <span class="o">*</span><span class="p">)</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">ccb</span><span class="p">;</span>
			<span class="n">scb</span><span class="o">-&gt;</span><span class="n">dev_channel</span>	<span class="o">=</span> <span class="mh">0xFF</span><span class="p">;</span>
			<span class="n">scb</span><span class="o">-&gt;</span><span class="n">dev_target</span>		<span class="o">=</span> <span class="n">target</span><span class="p">;</span>
			<span class="n">ccb</span><span class="o">-&gt;</span><span class="n">raw_mbox</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>	<span class="o">=</span> <span class="n">CLUSTER_CMD</span><span class="p">;</span>
			<span class="n">ccb</span><span class="o">-&gt;</span><span class="n">raw_mbox</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>	<span class="o">=</span>  <span class="p">(</span><span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">RESERVE</span><span class="p">)</span> <span class="o">?</span>
						<span class="n">RESERVE_LD</span> <span class="o">:</span> <span class="n">RELEASE_LD</span><span class="p">;</span>

			<span class="n">ccb</span><span class="o">-&gt;</span><span class="n">raw_mbox</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>	<span class="o">=</span> <span class="n">target</span><span class="p">;</span>
			<span class="n">scb</span><span class="o">-&gt;</span><span class="n">dma_direction</span>	<span class="o">=</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">sc_data_direction</span><span class="p">;</span>

			<span class="k">return</span> <span class="n">scb</span><span class="p">;</span>

		<span class="nl">default:</span>
			<span class="n">scp</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DID_BAD_TARGET</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span> <span class="c1">// Passthru device commands</span></pre></div></td></tr>


<tr id="section-52"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-52">&#182;</a></div><p>Do not allow access to target id > 15 or LUN > 7</p></td><td class="code"><div class="highlight"><pre>		<span class="k">if</span> <span class="p">(</span><span class="n">target</span> <span class="o">&gt;</span> <span class="mi">15</span> <span class="o">||</span> <span class="n">SCP2LUN</span><span class="p">(</span><span class="n">scp</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">7</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">scp</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DID_BAD_TARGET</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span></pre></div></td></tr>


<tr id="section-53"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-53">&#182;</a></div><p>if fast load option was set and scan for last device is
over, reset the fast_load flag so that during a possible
next scan, devices can be made available</p></td><td class="code"><div class="highlight"><pre>		<span class="k">if</span> <span class="p">(</span><span class="n">rdev</span><span class="o">-&gt;</span><span class="n">fast_load</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">target</span> <span class="o">==</span> <span class="mi">15</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">SCP2CHANNEL</span><span class="p">(</span><span class="n">scp</span><span class="p">)</span> <span class="o">==</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">max_channel</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="p">{</span>

			<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="n">KERN_INFO</span>
			<span class="s">&quot;megaraid[%d]: physical device scan re-enabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">));</span>
			<span class="n">rdev</span><span class="o">-&gt;</span><span class="n">fast_load</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Display the channel scan for physical devices</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">rdev</span><span class="o">-&gt;</span><span class="n">last_disp</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1L</span> <span class="o">&lt;&lt;</span> <span class="n">SCP2CHANNEL</span><span class="p">(</span><span class="n">scp</span><span class="p">))))</span> <span class="p">{</span>

			<span class="n">ss</span> <span class="o">=</span> <span class="n">rdev</span><span class="o">-&gt;</span><span class="n">fast_load</span> <span class="o">?</span> <span class="n">skip</span> <span class="o">:</span> <span class="n">scan</span><span class="p">;</span>

			<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="n">KERN_INFO</span>
				<span class="s">&quot;scsi[%d]: %s scsi channel %d [Phy %d]&quot;</span><span class="p">,</span>
				<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">,</span> <span class="n">ss</span><span class="p">,</span> <span class="n">SCP2CHANNEL</span><span class="p">(</span><span class="n">scp</span><span class="p">),</span>
				<span class="n">channel</span><span class="p">));</span>

			<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span>
				<span class="s">&quot; for non-raid devices</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>

			<span class="n">rdev</span><span class="o">-&gt;</span><span class="n">last_disp</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1L</span> <span class="o">&lt;&lt;</span> <span class="n">SCP2CHANNEL</span><span class="p">(</span><span class="n">scp</span><span class="p">));</span>
		<span class="p">}</span></pre></div></td></tr>


<tr id="section-54"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-54">&#182;</a></div><p>disable channel sweep if fast load option given</p></td><td class="code"><div class="highlight"><pre>		<span class="k">if</span> <span class="p">(</span><span class="n">rdev</span><span class="o">-&gt;</span><span class="n">fast_load</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">scp</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DID_BAD_TARGET</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span></pre></div></td></tr>


<tr id="section-55"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-55">&#182;</a></div><p>Allocate a SCB and initialize passthru</p></td><td class="code"><div class="highlight"><pre>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">scb</span> <span class="o">=</span> <span class="n">megaraid_alloc_scb</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">scp</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">scp</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DID_ERROR</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
			<span class="o">*</span><span class="n">busy</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ccb</span>			<span class="o">=</span> <span class="p">(</span><span class="n">mbox_ccb_t</span> <span class="o">*</span><span class="p">)</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">ccb</span><span class="p">;</span>
		<span class="n">scb</span><span class="o">-&gt;</span><span class="n">dev_channel</span>	<span class="o">=</span> <span class="n">channel</span><span class="p">;</span>
		<span class="n">scb</span><span class="o">-&gt;</span><span class="n">dev_target</span>		<span class="o">=</span> <span class="n">target</span><span class="p">;</span>
		<span class="n">scb</span><span class="o">-&gt;</span><span class="n">dma_direction</span>	<span class="o">=</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">sc_data_direction</span><span class="p">;</span>
		<span class="n">mbox</span>			<span class="o">=</span> <span class="n">ccb</span><span class="o">-&gt;</span><span class="n">mbox</span><span class="p">;</span>
		<span class="n">mbox64</span>			<span class="o">=</span> <span class="n">ccb</span><span class="o">-&gt;</span><span class="n">mbox64</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-56"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-56">&#182;</a></div><p>Does this firmware support extended CDBs</p></td><td class="code"><div class="highlight"><pre>		<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">max_cdb_sz</span> <span class="o">==</span> <span class="mi">16</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">cmd</span>		<span class="o">=</span> <span class="n">MBOXCMD_EXTPTHRU</span><span class="p">;</span>

			<span class="n">megaraid_mbox_prepare_epthru</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">scb</span><span class="p">,</span> <span class="n">scp</span><span class="p">);</span>

			<span class="n">mbox64</span><span class="o">-&gt;</span><span class="n">xferaddr_lo</span>	<span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">ccb</span><span class="o">-&gt;</span><span class="n">epthru_dma_h</span><span class="p">;</span>
			<span class="n">mbox64</span><span class="o">-&gt;</span><span class="n">xferaddr_hi</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">xferaddr</span>		<span class="o">=</span> <span class="mh">0xFFFFFFFF</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">MBOXCMD_PASSTHRU64</span><span class="p">;</span>

			<span class="n">megaraid_mbox_prepare_pthru</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">scb</span><span class="p">,</span> <span class="n">scp</span><span class="p">);</span>

			<span class="n">mbox64</span><span class="o">-&gt;</span><span class="n">xferaddr_lo</span>	<span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">ccb</span><span class="o">-&gt;</span><span class="n">pthru_dma_h</span><span class="p">;</span>
			<span class="n">mbox64</span><span class="o">-&gt;</span><span class="n">xferaddr_hi</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">xferaddr</span>		<span class="o">=</span> <span class="mh">0xFFFFFFFF</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">scb</span><span class="p">;</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-57"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-57">&#182;</a></div><p>NOT REACHED</p></td><td class="code"><div class="highlight"><pre><span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * megaraid_mbox_runpendq - execute commands queued in the pending queue</span>
<span class="cm"> * @adapter	: controller&#39;s soft state</span>
<span class="cm"> * @scb_q	: SCB to be queued in the pending list</span>
<span class="cm"> *</span>
<span class="cm"> * Scan the pending list for commands which are not yet issued and try to</span>
<span class="cm"> * post to the controller. The SCB can be a null pointer, which would indicate</span>
<span class="cm"> * no SCB to be queue, just try to execute the ones in the pending list.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: We do not actually traverse the pending list. The SCBs are plucked</span>
<span class="cm"> * out from the head of the pending list. If it is successfully issued, the</span>
<span class="cm"> * next SCB is at the head now.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">megaraid_mbox_runpendq</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="n">scb_t</span> <span class="o">*</span><span class="n">scb_q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">scb_t</span>			<span class="o">*</span><span class="n">scb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">PENDING_LIST_LOCK</span><span class="p">(</span><span class="n">adapter</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">scb_q</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">scb_q</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">SCB_PENDQ</span><span class="p">;</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scb_q</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pend_list</span><span class="p">);</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-58"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-58">&#182;</a></div><p>if the adapter in not in quiescent mode, post the commands to FW</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">quiescent</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">PENDING_LIST_LOCK</span><span class="p">(</span><span class="n">adapter</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pend_list</span><span class="p">))</span> <span class="p">{</span>

		<span class="n">assert_spin_locked</span><span class="p">(</span><span class="n">PENDING_LIST_LOCK</span><span class="p">(</span><span class="n">adapter</span><span class="p">));</span>

		<span class="n">scb</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pend_list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="n">scb_t</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-59"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-59">&#182;</a></div><p>remove the scb from the pending list and try to
issue. If we are unable to issue it, put back in
the pending list and return</p></td><td class="code"><div class="highlight"><pre>		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>

		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">PENDING_LIST_LOCK</span><span class="p">(</span><span class="n">adapter</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-60"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-60">&#182;</a></div><p>if mailbox was busy, return SCB back to pending
list. Make sure to add at the head, since that's
where it would have been removed from</p></td><td class="code"><div class="highlight"><pre>		<span class="n">scb</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">SCB_ISSUED</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">mbox_post_cmd</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">scb</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">PENDING_LIST_LOCK</span><span class="p">(</span><span class="n">adapter</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>

			<span class="n">scb</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">SCB_PENDQ</span><span class="p">;</span>

			<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pend_list</span><span class="p">);</span>

			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">PENDING_LIST_LOCK</span><span class="p">(</span><span class="n">adapter</span><span class="p">),</span>
				<span class="n">flags</span><span class="p">);</span>

			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">PENDING_LIST_LOCK</span><span class="p">(</span><span class="n">adapter</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">PENDING_LIST_LOCK</span><span class="p">(</span><span class="n">adapter</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>


	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * megaraid_mbox_prepare_pthru - prepare a command for physical devices</span>
<span class="cm"> * @adapter	: pointer to controller&#39;s soft state</span>
<span class="cm"> * @scb		: scsi control block</span>
<span class="cm"> * @scp		: scsi command from the mid-layer</span>
<span class="cm"> *</span>
<span class="cm"> * Prepare a command for the scsi physical devices.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">megaraid_mbox_prepare_pthru</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="n">scb_t</span> <span class="o">*</span><span class="n">scb</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">scp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mbox_ccb_t</span>		<span class="o">*</span><span class="n">ccb</span><span class="p">;</span>
	<span class="n">mraid_passthru_t</span>	<span class="o">*</span><span class="n">pthru</span><span class="p">;</span>
	<span class="kt">uint8_t</span>			<span class="n">channel</span><span class="p">;</span>
	<span class="kt">uint8_t</span>			<span class="n">target</span><span class="p">;</span>

	<span class="n">ccb</span>	<span class="o">=</span> <span class="p">(</span><span class="n">mbox_ccb_t</span> <span class="o">*</span><span class="p">)</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">ccb</span><span class="p">;</span>
	<span class="n">pthru</span>	<span class="o">=</span> <span class="n">ccb</span><span class="o">-&gt;</span><span class="n">pthru</span><span class="p">;</span>
	<span class="n">channel</span>	<span class="o">=</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">dev_channel</span><span class="p">;</span>
	<span class="n">target</span>	<span class="o">=</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">dev_target</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-61"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-61">&#182;</a></div><p>0=6sec, 1=60sec, 2=10min, 3=3hrs, 4=NO timeout</p></td><td class="code"><div class="highlight"><pre>	<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">timeout</span>		<span class="o">=</span> <span class="mi">4</span><span class="p">;</span>	
	<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">ars</span>		<span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">islogical</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">channel</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">target</span>		<span class="o">=</span> <span class="p">(</span><span class="n">channel</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">|</span> <span class="n">target</span><span class="p">;</span>
	<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">logdrv</span>		<span class="o">=</span> <span class="n">SCP2LUN</span><span class="p">(</span><span class="n">scp</span><span class="p">);</span>
	<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">reqsenselen</span>	<span class="o">=</span> <span class="mi">14</span><span class="p">;</span>
	<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">cdblen</span>		<span class="o">=</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmd_len</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">pthru</span><span class="o">-&gt;</span><span class="n">cdb</span><span class="p">,</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">,</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmd_len</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">scsi_bufflen</span><span class="p">(</span><span class="n">scp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">dataxferlen</span>	<span class="o">=</span> <span class="n">scsi_bufflen</span><span class="p">(</span><span class="n">scp</span><span class="p">);</span>
		<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">dataxferaddr</span>	<span class="o">=</span> <span class="n">ccb</span><span class="o">-&gt;</span><span class="n">sgl_dma_h</span><span class="p">;</span>
		<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">numsge</span>		<span class="o">=</span> <span class="n">megaraid_mbox_mksgl</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">dataxferaddr</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">dataxferlen</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">numsge</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * megaraid_mbox_prepare_epthru - prepare a command for physical devices</span>
<span class="cm"> * @adapter	: pointer to controller&#39;s soft state</span>
<span class="cm"> * @scb		: scsi control block</span>
<span class="cm"> * @scp		: scsi command from the mid-layer</span>
<span class="cm"> *</span>
<span class="cm"> * Prepare a command for the scsi physical devices. This rountine prepares</span>
<span class="cm"> * commands for devices which can take extended CDBs (&gt;10 bytes).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">megaraid_mbox_prepare_epthru</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="n">scb_t</span> <span class="o">*</span><span class="n">scb</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">scp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mbox_ccb_t</span>		<span class="o">*</span><span class="n">ccb</span><span class="p">;</span>
	<span class="n">mraid_epassthru_t</span>	<span class="o">*</span><span class="n">epthru</span><span class="p">;</span>
	<span class="kt">uint8_t</span>			<span class="n">channel</span><span class="p">;</span>
	<span class="kt">uint8_t</span>			<span class="n">target</span><span class="p">;</span>

	<span class="n">ccb</span>	<span class="o">=</span> <span class="p">(</span><span class="n">mbox_ccb_t</span> <span class="o">*</span><span class="p">)</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">ccb</span><span class="p">;</span>
	<span class="n">epthru</span>	<span class="o">=</span> <span class="n">ccb</span><span class="o">-&gt;</span><span class="n">epthru</span><span class="p">;</span>
	<span class="n">channel</span>	<span class="o">=</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">dev_channel</span><span class="p">;</span>
	<span class="n">target</span>	<span class="o">=</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">dev_target</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-62"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-62">&#182;</a></div><p>0=6sec, 1=60sec, 2=10min, 3=3hrs, 4=NO timeout</p></td><td class="code"><div class="highlight"><pre>	<span class="n">epthru</span><span class="o">-&gt;</span><span class="n">timeout</span>		<span class="o">=</span> <span class="mi">4</span><span class="p">;</span>	
	<span class="n">epthru</span><span class="o">-&gt;</span><span class="n">ars</span>		<span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">epthru</span><span class="o">-&gt;</span><span class="n">islogical</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">epthru</span><span class="o">-&gt;</span><span class="n">channel</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">epthru</span><span class="o">-&gt;</span><span class="n">target</span>		<span class="o">=</span> <span class="p">(</span><span class="n">channel</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">|</span> <span class="n">target</span><span class="p">;</span>
	<span class="n">epthru</span><span class="o">-&gt;</span><span class="n">logdrv</span>		<span class="o">=</span> <span class="n">SCP2LUN</span><span class="p">(</span><span class="n">scp</span><span class="p">);</span>
	<span class="n">epthru</span><span class="o">-&gt;</span><span class="n">reqsenselen</span>	<span class="o">=</span> <span class="mi">14</span><span class="p">;</span>
	<span class="n">epthru</span><span class="o">-&gt;</span><span class="n">cdblen</span>		<span class="o">=</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmd_len</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">epthru</span><span class="o">-&gt;</span><span class="n">cdb</span><span class="p">,</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">,</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmd_len</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">scsi_bufflen</span><span class="p">(</span><span class="n">scp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">epthru</span><span class="o">-&gt;</span><span class="n">dataxferlen</span>	<span class="o">=</span> <span class="n">scsi_bufflen</span><span class="p">(</span><span class="n">scp</span><span class="p">);</span>
		<span class="n">epthru</span><span class="o">-&gt;</span><span class="n">dataxferaddr</span>	<span class="o">=</span> <span class="n">ccb</span><span class="o">-&gt;</span><span class="n">sgl_dma_h</span><span class="p">;</span>
		<span class="n">epthru</span><span class="o">-&gt;</span><span class="n">numsge</span>		<span class="o">=</span> <span class="n">megaraid_mbox_mksgl</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">epthru</span><span class="o">-&gt;</span><span class="n">dataxferaddr</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">epthru</span><span class="o">-&gt;</span><span class="n">dataxferlen</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">epthru</span><span class="o">-&gt;</span><span class="n">numsge</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * megaraid_ack_sequence - interrupt ack sequence for memory mapped HBAs</span>
<span class="cm"> * @adapter	: controller&#39;s soft state</span>
<span class="cm"> *</span>
<span class="cm"> * Interrupt acknowledgement sequence for memory mapped HBAs. Find out the</span>
<span class="cm"> * completed command and put them on the completed list for later processing.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:	1 if the interrupt is valid, 0 otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">megaraid_ack_sequence</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mraid_device_t</span>		<span class="o">*</span><span class="n">raid_dev</span> <span class="o">=</span> <span class="n">ADAP2RAIDDEV</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">mbox_t</span>			<span class="o">*</span><span class="n">mbox</span><span class="p">;</span>
	<span class="n">scb_t</span>			<span class="o">*</span><span class="n">scb</span><span class="p">;</span>
	<span class="kt">uint8_t</span>			<span class="n">nstatus</span><span class="p">;</span>
	<span class="kt">uint8_t</span>			<span class="n">completed</span><span class="p">[</span><span class="n">MBOX_MAX_FIRMWARE_STATUS</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">clist</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">handled</span><span class="p">;</span>
	<span class="kt">uint32_t</span>		<span class="n">dword</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>


	<span class="n">mbox</span>	<span class="o">=</span> <span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">mbox</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-63"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-63">&#182;</a></div><p>move the SCBs from the firmware completed array to our local list</p></td><td class="code"><div class="highlight"><pre>	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clist</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-64"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-64">&#182;</a></div><p>loop till F/W has more commands for us to complete</p></td><td class="code"><div class="highlight"><pre>	<span class="n">handled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">MAILBOX_LOCK</span><span class="p">(</span><span class="n">raid_dev</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Check if a valid interrupt is pending. If found, force the</span>
<span class="cm">		 * interrupt line low.</span>
<span class="cm">		 */</span>
		<span class="n">dword</span> <span class="o">=</span> <span class="n">RDOUTDOOR</span><span class="p">(</span><span class="n">raid_dev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dword</span> <span class="o">!=</span> <span class="mh">0x10001234</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>

		<span class="n">handled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">WROUTDOOR</span><span class="p">(</span><span class="n">raid_dev</span><span class="p">,</span> <span class="mh">0x10001234</span><span class="p">);</span>

		<span class="n">nstatus</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-65"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-65">&#182;</a></div><p>wait for valid numstatus to post</p></td><td class="code"><div class="highlight"><pre>		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mh">0xFFFFF</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mbox</span><span class="o">-&gt;</span><span class="n">numstatus</span> <span class="o">!=</span> <span class="mh">0xFF</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">nstatus</span> <span class="o">=</span> <span class="n">mbox</span><span class="o">-&gt;</span><span class="n">numstatus</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">rmb</span><span class="p">();</span>
		<span class="p">}</span>
		<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">numstatus</span> <span class="o">=</span> <span class="mh">0xFF</span><span class="p">;</span>

		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">outstanding_cmds</span> <span class="o">-=</span> <span class="n">nstatus</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nstatus</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-66"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-66">&#182;</a></div><p>wait for valid command index to post</p></td><td class="code"><div class="highlight"><pre>			<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mh">0xFFFFF</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">mbox</span><span class="o">-&gt;</span><span class="n">completed</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mh">0xFF</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
				<span class="n">rmb</span><span class="p">();</span>
			<span class="p">}</span>
			<span class="n">completed</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>		<span class="o">=</span> <span class="n">mbox</span><span class="o">-&gt;</span><span class="n">completed</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">completed</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>	<span class="o">=</span> <span class="mh">0xFF</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">completed</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0xFF</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="n">KERN_CRIT</span>
				<span class="s">&quot;megaraid: command posting timed out</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>

				<span class="n">BUG</span><span class="p">();</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span></pre></div></td></tr>


<tr id="section-67"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-67">&#182;</a></div><p>Get SCB associated with this command id</p></td><td class="code"><div class="highlight"><pre>			<span class="k">if</span> <span class="p">(</span><span class="n">completed</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">MBOX_MAX_SCSI_CMDS</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-68"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-68">&#182;</a></div><p>a cmm command</p></td><td class="code"><div class="highlight"><pre>				<span class="n">scb</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">uscb_list</span> <span class="o">+</span> <span class="p">(</span><span class="n">completed</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span>
						<span class="n">MBOX_MAX_SCSI_CMDS</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">else</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-69"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-69">&#182;</a></div><p>an os command</p></td><td class="code"><div class="highlight"><pre>				<span class="n">scb</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">kscb_list</span> <span class="o">+</span> <span class="n">completed</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="p">}</span>

			<span class="n">scb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">mbox</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">;</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clist</span><span class="p">);</span>
		<span class="p">}</span></pre></div></td></tr>


<tr id="section-70"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-70">&#182;</a></div><p>Acknowledge interrupt</p></td><td class="code"><div class="highlight"><pre>		<span class="n">WRINDOOR</span><span class="p">(</span><span class="n">raid_dev</span><span class="p">,</span> <span class="mh">0x02</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">MAILBOX_LOCK</span><span class="p">(</span><span class="n">raid_dev</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-71"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-71">&#182;</a></div><p>put the completed commands in the completed list. DPC would
complete these commands later</p></td><td class="code"><div class="highlight"><pre>	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">COMPLETED_LIST_LOCK</span><span class="p">(</span><span class="n">adapter</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">list_splice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clist</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">completed_list</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">COMPLETED_LIST_LOCK</span><span class="p">(</span><span class="n">adapter</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-72"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-72">&#182;</a></div><p>schedule the DPC if there is some work for it</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span> <span class="p">(</span><span class="n">handled</span><span class="p">)</span>
		<span class="n">tasklet_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">dpc_h</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">handled</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * megaraid_isr - isr for memory based mailbox based controllers</span>
<span class="cm"> * @irq		: irq</span>
<span class="cm"> * @devp	: pointer to our soft state</span>
<span class="cm"> *</span>
<span class="cm"> * Interrupt service routine for memory-mapped mailbox controllers.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span>
<span class="nf">megaraid_isr</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">devp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">adapter_t</span>	<span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">devp</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">handled</span><span class="p">;</span>

	<span class="n">handled</span> <span class="o">=</span> <span class="n">megaraid_ack_sequence</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="cm">/* Loop through any pending requests */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">quiescent</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">megaraid_mbox_runpendq</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">IRQ_RETVAL</span><span class="p">(</span><span class="n">handled</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * megaraid_mbox_sync_scb - sync kernel buffers</span>
<span class="cm"> * @adapter	: controller&#39;s soft state</span>
<span class="cm"> * @scb		: pointer to the resource packet</span>
<span class="cm"> *</span>
<span class="cm"> * DMA sync if required.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">megaraid_mbox_sync_scb</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="n">scb_t</span> <span class="o">*</span><span class="n">scb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mbox_ccb_t</span>	<span class="o">*</span><span class="n">ccb</span><span class="p">;</span>

	<span class="n">ccb</span>	<span class="o">=</span> <span class="p">(</span><span class="n">mbox_ccb_t</span> <span class="o">*</span><span class="p">)</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">ccb</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">dma_direction</span> <span class="o">==</span> <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">)</span>
		<span class="n">pci_dma_sync_sg_for_cpu</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
					<span class="n">scsi_sglist</span><span class="p">(</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">scp</span><span class="p">),</span>
					<span class="n">scsi_sg_count</span><span class="p">(</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">scp</span><span class="p">),</span>
					<span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>

	<span class="n">scsi_dma_unmap</span><span class="p">(</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">scp</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * megaraid_mbox_dpc - the tasklet to complete the commands from completed list</span>
<span class="cm"> * @devp	: pointer to HBA soft state</span>
<span class="cm"> *</span>
<span class="cm"> * Pick up the commands from the completed list and send back to the owners.</span>
<span class="cm"> * This is a reentrant function and does not assume any locks are held while</span>
<span class="cm"> * it is being called.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">megaraid_mbox_dpc</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">devp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">adapter_t</span>		<span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="p">)</span><span class="n">devp</span><span class="p">;</span>
	<span class="n">mraid_device_t</span>		<span class="o">*</span><span class="n">raid_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">clist</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span>	<span class="o">*</span><span class="n">sgl</span><span class="p">;</span>
	<span class="n">scb_t</span>			<span class="o">*</span><span class="n">scb</span><span class="p">;</span>
	<span class="n">scb_t</span>			<span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span>	<span class="o">*</span><span class="n">scp</span><span class="p">;</span>
	<span class="n">mraid_passthru_t</span>	<span class="o">*</span><span class="n">pthru</span><span class="p">;</span>
	<span class="n">mraid_epassthru_t</span>	<span class="o">*</span><span class="n">epthru</span><span class="p">;</span>
	<span class="n">mbox_ccb_t</span>		<span class="o">*</span><span class="n">ccb</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">islogical</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">pdev_index</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">pdev_state</span><span class="p">;</span>
	<span class="n">mbox_t</span>			<span class="o">*</span><span class="n">mbox</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span>
	<span class="kt">uint8_t</span>			<span class="n">c</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">status</span><span class="p">;</span>
	<span class="n">uioc_t</span>			<span class="o">*</span><span class="n">kioc</span><span class="p">;</span>


	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">adapter</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

	<span class="n">raid_dev</span> <span class="o">=</span> <span class="n">ADAP2RAIDDEV</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-73"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-73">&#182;</a></div><p>move the SCBs from the completed list to our local list</p></td><td class="code"><div class="highlight"><pre>	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clist</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">COMPLETED_LIST_LOCK</span><span class="p">(</span><span class="n">adapter</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">completed_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clist</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">COMPLETED_LIST_LOCK</span><span class="p">(</span><span class="n">adapter</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>


	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">scb</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clist</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">status</span>		<span class="o">=</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">;</span>
		<span class="n">scp</span>		<span class="o">=</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">scp</span><span class="p">;</span>
		<span class="n">ccb</span>		<span class="o">=</span> <span class="p">(</span><span class="n">mbox_ccb_t</span> <span class="o">*</span><span class="p">)</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">ccb</span><span class="p">;</span>
		<span class="n">pthru</span>		<span class="o">=</span> <span class="n">ccb</span><span class="o">-&gt;</span><span class="n">pthru</span><span class="p">;</span>
		<span class="n">epthru</span>		<span class="o">=</span> <span class="n">ccb</span><span class="o">-&gt;</span><span class="n">epthru</span><span class="p">;</span>
		<span class="n">mbox</span>		<span class="o">=</span> <span class="n">ccb</span><span class="o">-&gt;</span><span class="n">mbox</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-74"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-74">&#182;</a></div><p>Make sure f/w has completed a valid command</p></td><td class="code"><div class="highlight"><pre>		<span class="k">if</span> <span class="p">(</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">SCB_ISSUED</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="n">KERN_CRIT</span>
			<span class="s">&quot;megaraid critical err: invalid command %d:%d:%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">scb</span><span class="o">-&gt;</span><span class="n">sno</span><span class="p">,</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">,</span> <span class="n">scp</span><span class="p">));</span>
			<span class="n">BUG</span><span class="p">();</span>
			<span class="k">continue</span><span class="p">;</span>	<span class="c1">// Must never happen!</span>
		<span class="p">}</span></pre></div></td></tr>


<tr id="section-75"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-75">&#182;</a></div><p>check for the management command and complete it right away</p></td><td class="code"><div class="highlight"><pre>		<span class="k">if</span> <span class="p">(</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">sno</span> <span class="o">&gt;=</span> <span class="n">MBOX_MAX_SCSI_CMDS</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">scb</span><span class="o">-&gt;</span><span class="n">state</span>	<span class="o">=</span> <span class="n">SCB_FREE</span><span class="p">;</span>
			<span class="n">scb</span><span class="o">-&gt;</span><span class="n">status</span>	<span class="o">=</span> <span class="n">status</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-76"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-76">&#182;</a></div><p>remove from local clist</p></td><td class="code"><div class="highlight"><pre>			<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>

			<span class="n">kioc</span>			<span class="o">=</span> <span class="p">(</span><span class="n">uioc_t</span> <span class="o">*</span><span class="p">)</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">gp</span><span class="p">;</span>
			<span class="n">kioc</span><span class="o">-&gt;</span><span class="n">status</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="n">megaraid_mbox_mm_done</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>

			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span></pre></div></td></tr>


<tr id="section-77"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-77">&#182;</a></div><p>Was an abort issued for this command earlier</p></td><td class="code"><div class="highlight"><pre>		<span class="k">if</span> <span class="p">(</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">SCB_ABORT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="n">KERN_NOTICE</span>
			<span class="s">&quot;megaraid: aborted cmd [%x] completed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">scb</span><span class="o">-&gt;</span><span class="n">sno</span><span class="p">));</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * If the inquiry came of a disk drive which is not part of</span>
<span class="cm">		 * any RAID array, expose it to the kernel. For this to be</span>
<span class="cm">		 * enabled, user must set the &quot;megaraid_expose_unconf_disks&quot;</span>
<span class="cm">		 * flag to 1 by specifying it on module parameter list.</span>
<span class="cm">		 * This would enable data migration off drives from other</span>
<span class="cm">		 * configurations.</span>
<span class="cm">		 */</span>
		<span class="n">islogical</span> <span class="o">=</span> <span class="n">MRAID_IS_LOGICAL</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">scp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">INQUIRY</span> <span class="o">&amp;&amp;</span> <span class="n">status</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">islogical</span> <span class="o">==</span> <span class="mi">0</span>
				<span class="o">&amp;&amp;</span> <span class="n">IS_RAID_CH</span><span class="p">(</span><span class="n">raid_dev</span><span class="p">,</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">dev_channel</span><span class="p">))</span> <span class="p">{</span>

			<span class="n">sgl</span> <span class="o">=</span> <span class="n">scsi_sglist</span><span class="p">(</span><span class="n">scp</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sg_page</span><span class="p">(</span><span class="n">sgl</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">c</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">sg_virt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sgl</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="n">KERN_WARNING</span>
						 <span class="s">&quot;megaraid mailbox: invalid sg:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						 <span class="n">__LINE__</span><span class="p">));</span>
				<span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">((</span><span class="n">c</span> <span class="o">&amp;</span> <span class="mh">0x1F</span> <span class="p">)</span> <span class="o">==</span> <span class="n">TYPE_DISK</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pdev_index</span> <span class="o">=</span> <span class="p">(</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">dev_channel</span> <span class="o">*</span> <span class="mi">16</span><span class="p">)</span> <span class="o">+</span>
					<span class="n">scb</span><span class="o">-&gt;</span><span class="n">dev_target</span><span class="p">;</span>
				<span class="n">pdev_state</span> <span class="o">=</span>
					<span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">pdrv_state</span><span class="p">[</span><span class="n">pdev_index</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x0F</span><span class="p">;</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">pdev_state</span> <span class="o">==</span> <span class="n">PDRV_ONLINE</span>		<span class="o">||</span>
					<span class="n">pdev_state</span> <span class="o">==</span> <span class="n">PDRV_FAILED</span>	<span class="o">||</span>
					<span class="n">pdev_state</span> <span class="o">==</span> <span class="n">PDRV_RBLD</span>		<span class="o">||</span>
					<span class="n">pdev_state</span> <span class="o">==</span> <span class="n">PDRV_HOTSPARE</span>	<span class="o">||</span>
					<span class="n">megaraid_expose_unconf_disks</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

					<span class="n">status</span> <span class="o">=</span> <span class="mh">0xF0</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span></pre></div></td></tr>


<tr id="section-78"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-78">&#182;</a></div><p>Convert MegaRAID status to Linux error code</p></td><td class="code"><div class="highlight"><pre>		<span class="k">switch</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">case</span> <span class="mh">0x00</span>:

			<span class="n">scp</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DID_OK</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="mh">0x02</span>:

			<span class="cm">/* set sense_buffer and result fields */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mbox</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">MBOXCMD_PASSTHRU</span> <span class="o">||</span>
				<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">MBOXCMD_PASSTHRU64</span><span class="p">)</span> <span class="p">{</span>

				<span class="n">memcpy</span><span class="p">(</span><span class="n">scp</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">,</span> <span class="n">pthru</span><span class="o">-&gt;</span><span class="n">reqsensearea</span><span class="p">,</span>
						<span class="mi">14</span><span class="p">);</span>

				<span class="n">scp</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DRIVER_SENSE</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span> <span class="o">|</span>
					<span class="n">DID_OK</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span> <span class="o">|</span> <span class="n">CHECK_CONDITION</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">mbox</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">MBOXCMD_EXTPTHRU</span><span class="p">)</span> <span class="p">{</span>

					<span class="n">memcpy</span><span class="p">(</span><span class="n">scp</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">,</span>
						<span class="n">epthru</span><span class="o">-&gt;</span><span class="n">reqsensearea</span><span class="p">,</span> <span class="mi">14</span><span class="p">);</span>

					<span class="n">scp</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DRIVER_SENSE</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span> <span class="o">|</span>
						<span class="n">DID_OK</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span> <span class="o">|</span>
						<span class="n">CHECK_CONDITION</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">scp</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x70</span><span class="p">;</span>
					<span class="n">scp</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">ABORTED_COMMAND</span><span class="p">;</span>
					<span class="n">scp</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">CHECK_CONDITION</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="mh">0x08</span>:

			<span class="n">scp</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_BUS_BUSY</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span> <span class="o">|</span> <span class="n">status</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="nl">default:</span>

			<span class="cm">/*</span>
<span class="cm">			 * If TEST_UNIT_READY fails, we know RESERVATION_STATUS</span>
<span class="cm">			 * failed</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">TEST_UNIT_READY</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">scp</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_ERROR</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span> <span class="o">|</span>
					<span class="n">RESERVATION_CONFLICT</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">else</span>
			<span class="cm">/*</span>
<span class="cm">			 * Error code returned is 1 if Reserve or Release</span>
<span class="cm">			 * failed or the input parameter is invalid</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">RESERVE</span> <span class="o">||</span>
					 <span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">RELEASE</span><span class="p">))</span> <span class="p">{</span>

				<span class="n">scp</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_ERROR</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span> <span class="o">|</span>
					<span class="n">RESERVATION_CONFLICT</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">scp</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_BAD_TARGET</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span> <span class="o">|</span> <span class="n">status</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span></pre></div></td></tr>


<tr id="section-79"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-79">&#182;</a></div><p>print a debug message for all failed commands</p></td><td class="code"><div class="highlight"><pre>		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">megaraid_mbox_display_scb</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
		<span class="p">}</span></pre></div></td></tr>


<tr id="section-80"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-80">&#182;</a></div><p>Free our internal resources and call the mid-layer callback
routine</p></td><td class="code"><div class="highlight"><pre>		<span class="n">megaraid_mbox_sync_scb</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-81"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-81">&#182;</a></div><p>remove from local clist</p></td><td class="code"><div class="highlight"><pre>		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-82"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-82">&#182;</a></div><p>put back in free list</p></td><td class="code"><div class="highlight"><pre>		<span class="n">megaraid_dealloc_scb</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-83"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-83">&#182;</a></div><p>send the scsi packet back to kernel</p></td><td class="code"><div class="highlight"><pre>		<span class="n">scp</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">(</span><span class="n">scp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * megaraid_abort_handler - abort the scsi command</span>
<span class="cm"> * @scp		: command to be aborted</span>
<span class="cm"> *</span>
<span class="cm"> * Abort a previous SCSI request. Only commands on the pending list can be</span>
<span class="cm"> * aborted. All the commands issued to the F/W must complete.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">megaraid_abort_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">scp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">adapter_t</span>		<span class="o">*</span><span class="n">adapter</span><span class="p">;</span>
	<span class="n">mraid_device_t</span>		<span class="o">*</span><span class="n">raid_dev</span><span class="p">;</span>
	<span class="n">scb_t</span>			<span class="o">*</span><span class="n">scb</span><span class="p">;</span>
	<span class="n">scb_t</span>			<span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">found</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">i</span><span class="p">;</span>


	<span class="n">adapter</span>		<span class="o">=</span> <span class="n">SCP2ADAPTER</span><span class="p">(</span><span class="n">scp</span><span class="p">);</span>
	<span class="n">raid_dev</span>	<span class="o">=</span> <span class="n">ADAP2RAIDDEV</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="n">KERN_WARNING</span>
		<span class="s">&quot;megaraid: aborting cmd=%x &lt;c=%d t=%d l=%d&gt;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">SCP2CHANNEL</span><span class="p">(</span><span class="n">scp</span><span class="p">),</span>
		<span class="n">SCP2TARGET</span><span class="p">(</span><span class="n">scp</span><span class="p">),</span> <span class="n">SCP2LUN</span><span class="p">(</span><span class="n">scp</span><span class="p">)));</span></pre></div></td></tr>


<tr id="section-84"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-84">&#182;</a></div><p>If FW has stopped responding, simply return failure</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span> <span class="p">(</span><span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">hw_error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="n">KERN_NOTICE</span>
			<span class="s">&quot;megaraid: hw error, not aborting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
		<span class="k">return</span> <span class="n">FAILED</span><span class="p">;</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-85"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-85">&#182;</a></div><p>There might a race here, where the command was completed by the
firmware and now it is on the completed list. Before we could
complete the command to the kernel in dpc, the abort came.
Find out if this is the case to avoid the race.</p></td><td class="code"><div class="highlight"><pre>	<span class="n">scb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">COMPLETED_LIST_LOCK</span><span class="p">(</span><span class="n">adapter</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">scb</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">completed_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">scp</span> <span class="o">==</span> <span class="n">scp</span><span class="p">)</span> <span class="p">{</span>	<span class="c1">// Found command</span>

			<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>	<span class="c1">// from completed list</span>

			<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="n">KERN_WARNING</span>
			<span class="s">&quot;megaraid: %d[%d:%d], abort from completed list</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">scb</span><span class="o">-&gt;</span><span class="n">sno</span><span class="p">,</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">dev_channel</span><span class="p">,</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">dev_target</span><span class="p">));</span>

			<span class="n">scp</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DID_ABORT</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
			<span class="n">scp</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">(</span><span class="n">scp</span><span class="p">);</span>

			<span class="n">megaraid_dealloc_scb</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>

			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">COMPLETED_LIST_LOCK</span><span class="p">(</span><span class="n">adapter</span><span class="p">),</span>
				<span class="n">flags</span><span class="p">);</span>

			<span class="k">return</span> <span class="n">SUCCESS</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">COMPLETED_LIST_LOCK</span><span class="p">(</span><span class="n">adapter</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-86"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-86">&#182;</a></div><p>Find out if this command is still on the pending list. If it is and
was never issued, abort and return success. If the command is owned
by the firmware, we must wait for it to complete by the FW.</p></td><td class="code"><div class="highlight"><pre>	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">PENDING_LIST_LOCK</span><span class="p">(</span><span class="n">adapter</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">scb</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pend_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">scp</span> <span class="o">==</span> <span class="n">scp</span><span class="p">)</span> <span class="p">{</span>	<span class="c1">// Found command</span>

			<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>	<span class="c1">// from pending list</span>

			<span class="n">ASSERT</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">SCB_ISSUED</span><span class="p">));</span>

			<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="n">KERN_WARNING</span>
				<span class="s">&quot;megaraid abort: [%d:%d], driver owner</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">scb</span><span class="o">-&gt;</span><span class="n">dev_channel</span><span class="p">,</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">dev_target</span><span class="p">));</span>

			<span class="n">scp</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DID_ABORT</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
			<span class="n">scp</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">(</span><span class="n">scp</span><span class="p">);</span>

			<span class="n">megaraid_dealloc_scb</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>

			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">PENDING_LIST_LOCK</span><span class="p">(</span><span class="n">adapter</span><span class="p">),</span>
				<span class="n">flags</span><span class="p">);</span>

			<span class="k">return</span> <span class="n">SUCCESS</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">PENDING_LIST_LOCK</span><span class="p">(</span><span class="n">adapter</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-87"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-87">&#182;</a></div><p>Check do we even own this command, in which case this would be
owned by the firmware. The only way to locate the FW scb is to
traverse through the list of all SCB, since driver does not
maintain these SCBs on any list</p></td><td class="code"><div class="highlight"><pre>	<span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MBOX_MAX_SCSI_CMDS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">scb</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">kscb_list</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">scp</span> <span class="o">==</span> <span class="n">scp</span><span class="p">)</span> <span class="p">{</span>

			<span class="n">found</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">SCB_ISSUED</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="n">KERN_WARNING</span>
				<span class="s">&quot;megaraid abort: %d[%d:%d], invalid state</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">scb</span><span class="o">-&gt;</span><span class="n">sno</span><span class="p">,</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">dev_channel</span><span class="p">,</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">dev_target</span><span class="p">));</span>
				<span class="n">BUG</span><span class="p">();</span>
			<span class="p">}</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="n">KERN_WARNING</span>
				<span class="s">&quot;megaraid abort: %d[%d:%d], fw owner</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">scb</span><span class="o">-&gt;</span><span class="n">sno</span><span class="p">,</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">dev_channel</span><span class="p">,</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">dev_target</span><span class="p">));</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">found</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;megaraid abort: do now own</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span></pre></div></td></tr>


<tr id="section-88"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-88">&#182;</a></div><p>FIXME: Should there be a callback for this command?</p></td><td class="code"><div class="highlight"><pre>		<span class="k">return</span> <span class="n">SUCCESS</span><span class="p">;</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-89"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-89">&#182;</a></div><p>We cannot actually abort a command owned by firmware, return
failure and wait for reset. In host reset handler, we will find out
if the HBA is still live</p></td><td class="code"><div class="highlight"><pre>	<span class="k">return</span> <span class="n">FAILED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * megaraid_reset_handler - device reset hadler for mailbox based driver</span>
<span class="cm"> * @scp		: reference command</span>
<span class="cm"> *</span>
<span class="cm"> * Reset handler for the mailbox based controller. First try to find out if</span>
<span class="cm"> * the FW is still live, in which case the outstanding commands counter mut go</span>
<span class="cm"> * down to 0. If that happens, also issue the reservation reset command to</span>
<span class="cm"> * relinquish (possible) reservations on the logical drives connected to this</span>
<span class="cm"> * host.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">megaraid_reset_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">scp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">adapter_t</span>	<span class="o">*</span><span class="n">adapter</span><span class="p">;</span>
	<span class="n">scb_t</span>		<span class="o">*</span><span class="n">scb</span><span class="p">;</span>
	<span class="n">scb_t</span>		<span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="n">mraid_device_t</span>	<span class="o">*</span><span class="n">raid_dev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">flags</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">raw_mbox</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">mbox_t</span><span class="p">)];</span>
	<span class="kt">int</span>		<span class="n">rval</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">recovery_window</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">recovering</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">i</span><span class="p">;</span>
	<span class="n">uioc_t</span>		<span class="o">*</span><span class="n">kioc</span><span class="p">;</span>

	<span class="n">adapter</span>		<span class="o">=</span> <span class="n">SCP2ADAPTER</span><span class="p">(</span><span class="n">scp</span><span class="p">);</span>
	<span class="n">raid_dev</span>	<span class="o">=</span> <span class="n">ADAP2RAIDDEV</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-90"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-90">&#182;</a></div><p>return failure if adapter is not responding</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span> <span class="p">(</span><span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">hw_error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="n">KERN_NOTICE</span>
			<span class="s">&quot;megaraid: hw error, cannot reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
		<span class="k">return</span> <span class="n">FAILED</span><span class="p">;</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-91"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-91">&#182;</a></div><p>Under exceptional conditions, FW can take up to 3 minutes to
complete command processing. Wait for additional 2 minutes for the
pending commands counter to go down to 0. If it doesn't, let the
controller be marked offline
Also, reset all the commands currently owned by the driver</p></td><td class="code"><div class="highlight"><pre>	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">PENDING_LIST_LOCK</span><span class="p">(</span><span class="n">adapter</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">scb</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pend_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>	<span class="c1">// from pending list</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">sno</span> <span class="o">&gt;=</span> <span class="n">MBOX_MAX_SCSI_CMDS</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="n">KERN_WARNING</span>
			<span class="s">&quot;megaraid: IOCTL packet with %d[%d:%d] being reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">scb</span><span class="o">-&gt;</span><span class="n">sno</span><span class="p">,</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">dev_channel</span><span class="p">,</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">dev_target</span><span class="p">));</span>

			<span class="n">scb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

			<span class="n">kioc</span>			<span class="o">=</span> <span class="p">(</span><span class="n">uioc_t</span> <span class="o">*</span><span class="p">)</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">gp</span><span class="p">;</span>
			<span class="n">kioc</span><span class="o">-&gt;</span><span class="n">status</span>		<span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

			<span class="n">megaraid_mbox_mm_done</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">scp</span> <span class="o">==</span> <span class="n">scp</span><span class="p">)</span> <span class="p">{</span>	<span class="c1">// Found command</span>
				<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="n">KERN_WARNING</span>
					<span class="s">&quot;megaraid: %d[%d:%d], reset from pending list</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">scb</span><span class="o">-&gt;</span><span class="n">sno</span><span class="p">,</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">dev_channel</span><span class="p">,</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">dev_target</span><span class="p">));</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="n">KERN_WARNING</span>
				<span class="s">&quot;megaraid: IO packet with %d[%d:%d] being reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">scb</span><span class="o">-&gt;</span><span class="n">sno</span><span class="p">,</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">dev_channel</span><span class="p">,</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">dev_target</span><span class="p">));</span>
			<span class="p">}</span>

			<span class="n">scb</span><span class="o">-&gt;</span><span class="n">scp</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DID_RESET</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
			<span class="n">scb</span><span class="o">-&gt;</span><span class="n">scp</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">(</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">scp</span><span class="p">);</span>

			<span class="n">megaraid_dealloc_scb</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">PENDING_LIST_LOCK</span><span class="p">(</span><span class="n">adapter</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">outstanding_cmds</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="n">KERN_NOTICE</span>
			<span class="s">&quot;megaraid: %d outstanding commands. Max wait %d sec</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">outstanding_cmds</span><span class="p">,</span>
			<span class="p">(</span><span class="n">MBOX_RESET_WAIT</span> <span class="o">+</span> <span class="n">MBOX_RESET_EXT_WAIT</span><span class="p">)));</span>
	<span class="p">}</span>

	<span class="n">recovery_window</span> <span class="o">=</span> <span class="n">MBOX_RESET_WAIT</span> <span class="o">+</span> <span class="n">MBOX_RESET_EXT_WAIT</span><span class="p">;</span>

	<span class="n">recovering</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">outstanding_cmds</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">recovery_window</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">megaraid_ack_sequence</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-92"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-92">&#182;</a></div><p>print a message once every 5 seconds only</p></td><td class="code"><div class="highlight"><pre>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">5</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span>
			<span class="s">&quot;megaraid mbox: Wait for %d commands to complete:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">outstanding_cmds</span><span class="p">,</span>
				<span class="p">(</span><span class="n">MBOX_RESET_WAIT</span> <span class="o">+</span> <span class="n">MBOX_RESET_EXT_WAIT</span><span class="p">)</span> <span class="o">-</span> <span class="n">i</span><span class="p">));</span>
		<span class="p">}</span></pre></div></td></tr>


<tr id="section-93"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-93">&#182;</a></div><p>bailout if no recovery happened in reset time</p></td><td class="code"><div class="highlight"><pre>		<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">outstanding_cmds</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">msleep</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-94"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-94">&#182;</a></div><p>If still outstanding commands, bail out</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">outstanding_cmds</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="n">KERN_WARNING</span>
			<span class="s">&quot;megaraid mbox: critical hardware error!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>

		<span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">hw_error</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">rval</span> <span class="o">=</span> <span class="n">FAILED</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="n">KERN_NOTICE</span>
		<span class="s">&quot;megaraid mbox: reset sequence completed successfully</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-95"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-95">&#182;</a></div><p>If the controller supports clustering, reset reservations</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ha</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rval</span> <span class="o">=</span> <span class="n">SUCCESS</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-96"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-96">&#182;</a></div><p>clear reservations if any</p></td><td class="code"><div class="highlight"><pre>	<span class="n">raw_mbox</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">CLUSTER_CMD</span><span class="p">;</span>
	<span class="n">raw_mbox</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">RESET_RESERVATIONS</span><span class="p">;</span>

	<span class="n">rval</span> <span class="o">=</span> <span class="n">SUCCESS</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mbox_post_sync_cmd_fast</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">raw_mbox</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span>
			<span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;megaraid: reservation reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">rval</span> <span class="o">=</span> <span class="n">FAILED</span><span class="p">;</span>
		<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="n">KERN_WARNING</span>
				<span class="s">&quot;megaraid: reservation reset failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
	<span class="p">}</span>

 <span class="nl">out:</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * START: internal commands library</span>
<span class="cm"> *</span>
<span class="cm"> * This section of the driver has the common routine used by the driver and</span>
<span class="cm"> * also has all the FW routines</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * mbox_post_sync_cmd() - blocking command to the mailbox based controllers</span>
<span class="cm"> * @adapter	: controller&#39;s soft state</span>
<span class="cm"> * @raw_mbox	: the mailbox</span>
<span class="cm"> *</span>
<span class="cm"> * Issue a scb in synchronous and non-interrupt mode for mailbox based</span>
<span class="cm"> * controllers.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">mbox_post_sync_cmd</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">raw_mbox</span><span class="p">[])</span>
<span class="p">{</span>
	<span class="n">mraid_device_t</span>	<span class="o">*</span><span class="n">raid_dev</span> <span class="o">=</span> <span class="n">ADAP2RAIDDEV</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">mbox64_t</span>	<span class="o">*</span><span class="n">mbox64</span><span class="p">;</span>
	<span class="n">mbox_t</span>		<span class="o">*</span><span class="n">mbox</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">status</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">i</span><span class="p">;</span>


	<span class="n">mbox64</span>	<span class="o">=</span> <span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">mbox64</span><span class="p">;</span>
	<span class="n">mbox</span>	<span class="o">=</span> <span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">mbox</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Wait until mailbox is free</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">megaraid_busywait_mbox</span><span class="p">(</span><span class="n">raid_dev</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">blocked_mailbox</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Copy mailbox data into host structure</span>
<span class="cm">	 */</span>
	<span class="n">memcpy</span><span class="p">((</span><span class="n">caddr_t</span><span class="p">)</span><span class="n">mbox</span><span class="p">,</span> <span class="p">(</span><span class="n">caddr_t</span><span class="p">)</span><span class="n">raw_mbox</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
	<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">cmdid</span>		<span class="o">=</span> <span class="mh">0xFE</span><span class="p">;</span>
	<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">busy</span>		<span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">poll</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">ack</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">numstatus</span>		<span class="o">=</span> <span class="mh">0xFF</span><span class="p">;</span>
	<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">status</span>		<span class="o">=</span> <span class="mh">0xFF</span><span class="p">;</span>

	<span class="n">wmb</span><span class="p">();</span>
	<span class="n">WRINDOOR</span><span class="p">(</span><span class="n">raid_dev</span><span class="p">,</span> <span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">mbox_dma</span> <span class="o">|</span> <span class="mh">0x1</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-97"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-97">&#182;</a></div><p>wait for maximum 1 second for status to post. If the status is not
available within 1 second, assume FW is initializing and wait
for an extended amount of time</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span> <span class="p">(</span><span class="n">mbox</span><span class="o">-&gt;</span><span class="n">numstatus</span> <span class="o">==</span> <span class="mh">0xFF</span><span class="p">)</span> <span class="p">{</span>	<span class="c1">// status not yet available</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">25</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">mbox</span><span class="o">-&gt;</span><span class="n">numstatus</span> <span class="o">==</span> <span class="mh">0xFF</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rmb</span><span class="p">();</span>
			<span class="n">msleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>


		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1000</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="n">KERN_NOTICE</span>
				<span class="s">&quot;megaraid mailbox: wait for FW to boot      &quot;</span><span class="p">));</span>

			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">(</span><span class="n">mbox</span><span class="o">-&gt;</span><span class="n">numstatus</span> <span class="o">==</span> <span class="mh">0xFF</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
					<span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">MBOX_RESET_WAIT</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">rmb</span><span class="p">();</span>
				<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;</span><span class="se">\b\b\b\b\b</span><span class="s">[%03d]&quot;</span><span class="p">,</span>
							<span class="n">MBOX_RESET_WAIT</span> <span class="o">-</span> <span class="n">i</span><span class="p">));</span>
				<span class="n">msleep</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">MBOX_RESET_WAIT</span><span class="p">)</span> <span class="p">{</span>

				<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span>
				<span class="s">&quot;</span><span class="se">\n</span><span class="s">megaraid mailbox: status not available</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>

				<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;</span><span class="se">\b\b\b\b\b</span><span class="s">[ok] </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-98"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-98">&#182;</a></div><p>wait for maximum 1 second for poll semaphore</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span> <span class="p">(</span><span class="n">mbox</span><span class="o">-&gt;</span><span class="n">poll</span> <span class="o">!=</span> <span class="mh">0x77</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">25</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">(</span><span class="n">mbox</span><span class="o">-&gt;</span><span class="n">poll</span> <span class="o">!=</span> <span class="mh">0x77</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rmb</span><span class="p">();</span>
			<span class="n">msleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1000</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="n">KERN_WARNING</span>
			<span class="s">&quot;megaraid mailbox: could not get poll semaphore</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">WRINDOOR</span><span class="p">(</span><span class="n">raid_dev</span><span class="p">,</span> <span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">mbox_dma</span> <span class="o">|</span> <span class="mh">0x2</span><span class="p">);</span>
	<span class="n">wmb</span><span class="p">();</span></pre></div></td></tr>


<tr id="section-99"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-99">&#182;</a></div><p>wait for maximum 1 second for acknowledgement</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span> <span class="p">(</span><span class="n">RDINDOOR</span><span class="p">(</span><span class="n">raid_dev</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">25</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">(</span><span class="n">RDINDOOR</span><span class="p">(</span><span class="n">raid_dev</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x2</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rmb</span><span class="p">();</span>
			<span class="n">msleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1000</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="n">KERN_WARNING</span>
				<span class="s">&quot;megaraid mailbox: could not acknowledge</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">poll</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">ack</span>	<span class="o">=</span> <span class="mh">0x77</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">mbox</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-100"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-100">&#182;</a></div><p>invalidate the completed command id array. After command
completion, firmware would write the valid id.</p></td><td class="code"><div class="highlight"><pre>	<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">numstatus</span>	<span class="o">=</span> <span class="mh">0xFF</span><span class="p">;</span>
	<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">status</span>	<span class="o">=</span> <span class="mh">0xFF</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MBOX_MAX_FIRMWARE_STATUS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">completed</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xFF</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>

<span class="nl">blocked_mailbox:</span>

	<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;megaraid: blocked mailbox</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span> <span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * mbox_post_sync_cmd_fast - blocking command to the mailbox based controllers</span>
<span class="cm"> * @adapter	: controller&#39;s soft state</span>
<span class="cm"> * @raw_mbox	: the mailbox</span>
<span class="cm"> *</span>
<span class="cm"> * Issue a scb in synchronous and non-interrupt mode for mailbox based</span>
<span class="cm"> * controllers. This is a faster version of the synchronous command and</span>
<span class="cm"> * therefore can be called in interrupt-context as well.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">mbox_post_sync_cmd_fast</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">raw_mbox</span><span class="p">[])</span>
<span class="p">{</span>
	<span class="n">mraid_device_t</span>	<span class="o">*</span><span class="n">raid_dev</span> <span class="o">=</span> <span class="n">ADAP2RAIDDEV</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">mbox_t</span>		<span class="o">*</span><span class="n">mbox</span><span class="p">;</span>
	<span class="kt">long</span>		<span class="n">i</span><span class="p">;</span>


	<span class="n">mbox</span>	<span class="o">=</span> <span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">mbox</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-101"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-101">&#182;</a></div><p>return immediately if the mailbox is busy</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span> <span class="p">(</span><span class="n">mbox</span><span class="o">-&gt;</span><span class="n">busy</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-102"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-102">&#182;</a></div><p>Copy mailbox data into host structure</p></td><td class="code"><div class="highlight"><pre>	<span class="n">memcpy</span><span class="p">((</span><span class="n">caddr_t</span><span class="p">)</span><span class="n">mbox</span><span class="p">,</span> <span class="p">(</span><span class="n">caddr_t</span><span class="p">)</span><span class="n">raw_mbox</span><span class="p">,</span> <span class="mi">14</span><span class="p">);</span>
	<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">cmdid</span>		<span class="o">=</span> <span class="mh">0xFE</span><span class="p">;</span>
	<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">busy</span>		<span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">poll</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">ack</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">numstatus</span>		<span class="o">=</span> <span class="mh">0xFF</span><span class="p">;</span>
	<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">status</span>		<span class="o">=</span> <span class="mh">0xFF</span><span class="p">;</span>

	<span class="n">wmb</span><span class="p">();</span>
	<span class="n">WRINDOOR</span><span class="p">(</span><span class="n">raid_dev</span><span class="p">,</span> <span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">mbox_dma</span> <span class="o">|</span> <span class="mh">0x1</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MBOX_SYNC_WAIT_CNT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mbox</span><span class="o">-&gt;</span><span class="n">numstatus</span> <span class="o">!=</span> <span class="mh">0xFF</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
		<span class="n">rmb</span><span class="p">();</span>
		<span class="n">udelay</span><span class="p">(</span><span class="n">MBOX_SYNC_DELAY_200</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">MBOX_SYNC_WAIT_CNT</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-103"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-103">&#182;</a></div><p>We may need to re-calibrate the counter</p></td><td class="code"><div class="highlight"><pre>		<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="n">KERN_CRIT</span>
			<span class="s">&quot;megaraid: fast sync command timed out</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">WRINDOOR</span><span class="p">(</span><span class="n">raid_dev</span><span class="p">,</span> <span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">mbox_dma</span> <span class="o">|</span> <span class="mh">0x2</span><span class="p">);</span>
	<span class="n">wmb</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">mbox</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * megaraid_busywait_mbox() - Wait until the controller&#39;s mailbox is available</span>
<span class="cm"> * @raid_dev	: RAID device (HBA) soft state</span>
<span class="cm"> *</span>
<span class="cm"> * Wait until the controller&#39;s mailbox is available to accept more commands.</span>
<span class="cm"> * Wait for at most 1 second.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">megaraid_busywait_mbox</span><span class="p">(</span><span class="n">mraid_device_t</span> <span class="o">*</span><span class="n">raid_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mbox_t</span>	<span class="o">*</span><span class="n">mbox</span> <span class="o">=</span> <span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">mbox</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mbox</span><span class="o">-&gt;</span><span class="n">busy</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">25</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">mbox</span><span class="o">-&gt;</span><span class="n">busy</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">msleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * megaraid_mbox_product_info - some static information about the controller</span>
<span class="cm"> * @adapter	: our soft state</span>
<span class="cm"> *</span>
<span class="cm"> * Issue commands to the controller to grab some parameters required by our</span>
<span class="cm"> * caller.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">megaraid_mbox_product_info</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mraid_device_t</span>		<span class="o">*</span><span class="n">raid_dev</span> <span class="o">=</span> <span class="n">ADAP2RAIDDEV</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">mbox_t</span>			<span class="o">*</span><span class="n">mbox</span><span class="p">;</span>
	<span class="kt">uint8_t</span>			<span class="n">raw_mbox</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">mbox_t</span><span class="p">)];</span>
	<span class="n">mraid_pinfo_t</span>		<span class="o">*</span><span class="n">pinfo</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>		<span class="n">pinfo_dma_h</span><span class="p">;</span>
	<span class="n">mraid_inquiry3_t</span>	<span class="o">*</span><span class="n">mraid_inq3</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">i</span><span class="p">;</span>


	<span class="n">memset</span><span class="p">((</span><span class="n">caddr_t</span><span class="p">)</span><span class="n">raw_mbox</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">raw_mbox</span><span class="p">));</span>
	<span class="n">mbox</span> <span class="o">=</span> <span class="p">(</span><span class="n">mbox_t</span> <span class="o">*</span><span class="p">)</span><span class="n">raw_mbox</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Issue an ENQUIRY3 command to find out certain adapter parameters,</span>
<span class="cm">	 * e.g., max channels, max commands etc.</span>
<span class="cm">	 */</span>
	<span class="n">pinfo</span> <span class="o">=</span> <span class="n">pci_alloc_consistent</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mraid_pinfo_t</span><span class="p">),</span>
			<span class="o">&amp;</span><span class="n">pinfo_dma_h</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pinfo</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="n">KERN_WARNING</span>
			<span class="s">&quot;megaraid: out of memory, %s %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
			<span class="n">__LINE__</span><span class="p">));</span>

		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">pinfo</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mraid_pinfo_t</span><span class="p">));</span>

	<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">xferaddr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ibuf_dma_h</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ibuf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MBOX_IBUF_SIZE</span><span class="p">);</span>

	<span class="n">raw_mbox</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">FC_NEW_CONFIG</span><span class="p">;</span>
	<span class="n">raw_mbox</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">NC_SUBOP_ENQUIRY3</span><span class="p">;</span>
	<span class="n">raw_mbox</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">ENQ3_GET_SOLICITED_FULL</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-104"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-104">&#182;</a></div><p>Issue the command</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span> <span class="p">(</span><span class="n">mbox_post_sync_cmd</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">raw_mbox</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;megaraid: Inquiry3 failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>

		<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mraid_pinfo_t</span><span class="p">),</span>
			<span class="n">pinfo</span><span class="p">,</span> <span class="n">pinfo_dma_h</span><span class="p">);</span>

		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Collect information about state of each physical drive</span>
<span class="cm">	 * attached to the controller. We will expose all the disks</span>
<span class="cm">	 * which are not part of RAID</span>
<span class="cm">	 */</span>
	<span class="n">mraid_inq3</span> <span class="o">=</span> <span class="p">(</span><span class="n">mraid_inquiry3_t</span> <span class="o">*</span><span class="p">)</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ibuf</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MBOX_MAX_PHYSICAL_DRIVES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">pdrv_state</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">mraid_inq3</span><span class="o">-&gt;</span><span class="n">pdrv_state</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Get product info for information like number of channels,</span>
<span class="cm">	 * maximum commands supported.</span>
<span class="cm">	 */</span>
	<span class="n">memset</span><span class="p">((</span><span class="n">caddr_t</span><span class="p">)</span><span class="n">raw_mbox</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">raw_mbox</span><span class="p">));</span>
	<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">xferaddr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">pinfo_dma_h</span><span class="p">;</span>

	<span class="n">raw_mbox</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">FC_NEW_CONFIG</span><span class="p">;</span>
	<span class="n">raw_mbox</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">NC_SUBOP_PRODUCT_INFO</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mbox_post_sync_cmd</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">raw_mbox</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="n">KERN_WARNING</span>
			<span class="s">&quot;megaraid: product info failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>

		<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mraid_pinfo_t</span><span class="p">),</span>
			<span class="n">pinfo</span><span class="p">,</span> <span class="n">pinfo_dma_h</span><span class="p">);</span>

		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Setup some parameters for host, as required by our caller</span>
<span class="cm">	 */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">max_channel</span> <span class="o">=</span> <span class="n">pinfo</span><span class="o">-&gt;</span><span class="n">nchannels</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * we will export all the logical drives on a single channel.</span>
<span class="cm">	 * Add 1 since inquires do not come for inititor ID</span>
<span class="cm">	 */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">max_target</span>	<span class="o">=</span> <span class="n">MAX_LOGICAL_DRIVES_40LD</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">max_lun</span>	<span class="o">=</span> <span class="mi">8</span><span class="p">;</span>	<span class="c1">// up to 8 LUNs for non-disk devices</span>

	<span class="cm">/*</span>
<span class="cm">	 * These are the maximum outstanding commands for the scsi-layer</span>
<span class="cm">	 */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">max_cmds</span>	<span class="o">=</span> <span class="n">MBOX_MAX_SCSI_CMDS</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">fw_version</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">VERSION_SIZE</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">bios_version</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">VERSION_SIZE</span><span class="p">);</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">fw_version</span><span class="p">,</span> <span class="n">pinfo</span><span class="o">-&gt;</span><span class="n">fw_version</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">fw_version</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">bios_version</span><span class="p">,</span> <span class="n">pinfo</span><span class="o">-&gt;</span><span class="n">bios_version</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">bios_version</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="n">KERN_NOTICE</span>
		<span class="s">&quot;megaraid: fw version:[%s] bios version:[%s]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">fw_version</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">bios_version</span><span class="p">));</span>

	<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mraid_pinfo_t</span><span class="p">),</span> <span class="n">pinfo</span><span class="p">,</span>
			<span class="n">pinfo_dma_h</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>



<span class="cm">/**</span>
<span class="cm"> * megaraid_mbox_extended_cdb - check for support for extended CDBs</span>
<span class="cm"> * @adapter	: soft state for the controller</span>
<span class="cm"> *</span>
<span class="cm"> * This routine check whether the controller in question supports extended</span>
<span class="cm"> * ( &gt; 10 bytes ) CDBs.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">megaraid_mbox_extended_cdb</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mbox_t</span>		<span class="o">*</span><span class="n">mbox</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">raw_mbox</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">mbox_t</span><span class="p">)];</span>
	<span class="kt">int</span>		<span class="n">rval</span><span class="p">;</span>

	<span class="n">mbox</span> <span class="o">=</span> <span class="p">(</span><span class="n">mbox_t</span> <span class="o">*</span><span class="p">)</span><span class="n">raw_mbox</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">((</span><span class="n">caddr_t</span><span class="p">)</span><span class="n">raw_mbox</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">raw_mbox</span><span class="p">));</span>
	<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">xferaddr</span>	<span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ibuf_dma_h</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ibuf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MBOX_IBUF_SIZE</span><span class="p">);</span>

	<span class="n">raw_mbox</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">MAIN_MISC_OPCODE</span><span class="p">;</span>
	<span class="n">raw_mbox</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">SUPPORT_EXT_CDB</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Issue the command</span>
<span class="cm">	 */</span>
	<span class="n">rval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mbox_post_sync_cmd</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">raw_mbox</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rval</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">rval</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * megaraid_mbox_support_ha - Do we support clustering</span>
<span class="cm"> * @adapter	: soft state for the controller</span>
<span class="cm"> * @init_id	: ID of the initiator</span>
<span class="cm"> *</span>
<span class="cm"> * Determine if the firmware supports clustering and the ID of the initiator.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">megaraid_mbox_support_ha</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="o">*</span><span class="n">init_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mbox_t</span>		<span class="o">*</span><span class="n">mbox</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">raw_mbox</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">mbox_t</span><span class="p">)];</span>
	<span class="kt">int</span>		<span class="n">rval</span><span class="p">;</span>


	<span class="n">mbox</span> <span class="o">=</span> <span class="p">(</span><span class="n">mbox_t</span> <span class="o">*</span><span class="p">)</span><span class="n">raw_mbox</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">((</span><span class="n">caddr_t</span><span class="p">)</span><span class="n">raw_mbox</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">raw_mbox</span><span class="p">));</span>

	<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">xferaddr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ibuf_dma_h</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ibuf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MBOX_IBUF_SIZE</span><span class="p">);</span>

	<span class="n">raw_mbox</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">GET_TARGET_ID</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-105"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-105">&#182;</a></div><p>Issue the command</p></td><td class="code"><div class="highlight"><pre>	<span class="o">*</span><span class="n">init_id</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
	<span class="n">rval</span> <span class="o">=</span>  <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mbox_post_sync_cmd</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">raw_mbox</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

		<span class="o">*</span><span class="n">init_id</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ibuf</span><span class="p">;</span>

		<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="n">KERN_INFO</span>
			<span class="s">&quot;megaraid: cluster firmware, initiator ID: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="o">*</span><span class="n">init_id</span><span class="p">));</span>

		<span class="n">rval</span> <span class="o">=</span>  <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">rval</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * megaraid_mbox_support_random_del - Do we support random deletion</span>
<span class="cm"> * @adapter	: soft state for the controller</span>
<span class="cm"> *</span>
<span class="cm"> * Determine if the firmware supports random deletion.</span>
<span class="cm"> * Return:	1 is operation supported, 0 otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">megaraid_mbox_support_random_del</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mbox_t</span>		<span class="o">*</span><span class="n">mbox</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">raw_mbox</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">mbox_t</span><span class="p">)];</span>
	<span class="kt">int</span>		<span class="n">rval</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Newer firmware on Dell CERC expect a different</span>
<span class="cm">	 * random deletion handling, so disable it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">vendor</span> <span class="o">==</span> <span class="n">PCI_VENDOR_ID_AMI</span> <span class="o">&amp;&amp;</span>
	    <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_AMI_MEGARAID3</span> <span class="o">&amp;&amp;</span>
	    <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">subsystem_vendor</span> <span class="o">==</span> <span class="n">PCI_VENDOR_ID_DELL</span> <span class="o">&amp;&amp;</span>
	    <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">subsystem_device</span> <span class="o">==</span> <span class="n">PCI_SUBSYS_ID_CERC_ATA100_4CH</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">fw_version</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="sc">&#39;6&#39;</span> <span class="o">||</span>
	     <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">fw_version</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;6&#39;</span> <span class="o">&amp;&amp;</span>
	      <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">fw_version</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="sc">&#39;6&#39;</span><span class="p">)</span> <span class="o">||</span>
	     <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">fw_version</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;6&#39;</span>
	      <span class="o">&amp;&amp;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">fw_version</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;6&#39;</span>
	      <span class="o">&amp;&amp;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">fw_version</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&gt;</span> <span class="sc">&#39;1&#39;</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">con_log</span><span class="p">(</span><span class="n">CL_DLEVEL1</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;megaraid: disable random deletion</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mbox</span> <span class="o">=</span> <span class="p">(</span><span class="n">mbox_t</span> <span class="o">*</span><span class="p">)</span><span class="n">raw_mbox</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">((</span><span class="n">caddr_t</span><span class="p">)</span><span class="n">raw_mbox</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mbox_t</span><span class="p">));</span>

	<span class="n">raw_mbox</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">FC_DEL_LOGDRV</span><span class="p">;</span>
	<span class="n">raw_mbox</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">OP_SUP_DEL_LOGDRV</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-106"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-106">&#182;</a></div><p>Issue the command</p></td><td class="code"><div class="highlight"><pre>	<span class="n">rval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mbox_post_sync_cmd</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">raw_mbox</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">con_log</span><span class="p">(</span><span class="n">CL_DLEVEL1</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;megaraid: supports random deletion</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>

		<span class="n">rval</span> <span class="o">=</span>  <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">rval</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * megaraid_mbox_get_max_sg - maximum sg elements supported by the firmware</span>
<span class="cm"> * @adapter	: soft state for the controller</span>
<span class="cm"> *</span>
<span class="cm"> * Find out the maximum number of scatter-gather elements supported by the</span>
<span class="cm"> * firmware.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">megaraid_mbox_get_max_sg</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mbox_t</span>		<span class="o">*</span><span class="n">mbox</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">raw_mbox</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">mbox_t</span><span class="p">)];</span>
	<span class="kt">int</span>		<span class="n">nsg</span><span class="p">;</span>


	<span class="n">mbox</span> <span class="o">=</span> <span class="p">(</span><span class="n">mbox_t</span> <span class="o">*</span><span class="p">)</span><span class="n">raw_mbox</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">((</span><span class="n">caddr_t</span><span class="p">)</span><span class="n">raw_mbox</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mbox_t</span><span class="p">));</span>

	<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">xferaddr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ibuf_dma_h</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ibuf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MBOX_IBUF_SIZE</span><span class="p">);</span>

	<span class="n">raw_mbox</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">MAIN_MISC_OPCODE</span><span class="p">;</span>
	<span class="n">raw_mbox</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">GET_MAX_SG_SUPPORT</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-107"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-107">&#182;</a></div><p>Issue the command</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span> <span class="p">(</span><span class="n">mbox_post_sync_cmd</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">raw_mbox</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nsg</span> <span class="o">=</span>  <span class="o">*</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ibuf</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">nsg</span> <span class="o">=</span>  <span class="n">MBOX_DEFAULT_SG_SIZE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nsg</span> <span class="o">&gt;</span> <span class="n">MBOX_MAX_SG_SIZE</span><span class="p">)</span> <span class="n">nsg</span> <span class="o">=</span> <span class="n">MBOX_MAX_SG_SIZE</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">nsg</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * megaraid_mbox_enum_raid_scsi - enumerate the RAID and SCSI channels</span>
<span class="cm"> * @adapter	: soft state for the controller</span>
<span class="cm"> *</span>
<span class="cm"> * Enumerate the RAID and SCSI channels for ROMB platforms so that channels</span>
<span class="cm"> * can be exported as regular SCSI channels.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">megaraid_mbox_enum_raid_scsi</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mraid_device_t</span>	<span class="o">*</span><span class="n">raid_dev</span> <span class="o">=</span> <span class="n">ADAP2RAIDDEV</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">mbox_t</span>		<span class="o">*</span><span class="n">mbox</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">raw_mbox</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">mbox_t</span><span class="p">)];</span>


	<span class="n">mbox</span> <span class="o">=</span> <span class="p">(</span><span class="n">mbox_t</span> <span class="o">*</span><span class="p">)</span><span class="n">raw_mbox</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">((</span><span class="n">caddr_t</span><span class="p">)</span><span class="n">raw_mbox</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mbox_t</span><span class="p">));</span>

	<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">xferaddr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ibuf_dma_h</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ibuf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MBOX_IBUF_SIZE</span><span class="p">);</span>

	<span class="n">raw_mbox</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">CHNL_CLASS</span><span class="p">;</span>
	<span class="n">raw_mbox</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">GET_CHNL_CLASS</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-108"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-108">&#182;</a></div><p>Issue the command. If the command fails, all channels are RAID
channels</p></td><td class="code"><div class="highlight"><pre>	<span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">channel_class</span> <span class="o">=</span> <span class="mh">0xFF</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mbox_post_sync_cmd</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">raw_mbox</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">channel_class</span> <span class="o">=</span>  <span class="o">*</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ibuf</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * megaraid_mbox_flush_cache - flush adapter and disks cache</span>
<span class="cm"> * @adapter		: soft state for the controller</span>
<span class="cm"> *</span>
<span class="cm"> * Flush adapter cache followed by disks cache.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">megaraid_mbox_flush_cache</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mbox_t</span>	<span class="o">*</span><span class="n">mbox</span><span class="p">;</span>
	<span class="kt">uint8_t</span>	<span class="n">raw_mbox</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">mbox_t</span><span class="p">)];</span>


	<span class="n">mbox</span> <span class="o">=</span> <span class="p">(</span><span class="n">mbox_t</span> <span class="o">*</span><span class="p">)</span><span class="n">raw_mbox</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">((</span><span class="n">caddr_t</span><span class="p">)</span><span class="n">raw_mbox</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mbox_t</span><span class="p">));</span>

	<span class="n">raw_mbox</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">FLUSH_ADAPTER</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mbox_post_sync_cmd</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">raw_mbox</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;megaraid: flush adapter failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">raw_mbox</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">FLUSH_SYSTEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mbox_post_sync_cmd</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">raw_mbox</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;megaraid: flush disks cache failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * megaraid_mbox_fire_sync_cmd - fire the sync cmd</span>
<span class="cm"> * @adapter		: soft state for the controller</span>
<span class="cm"> *</span>
<span class="cm"> * Clears the pending cmds in FW and reinits its RAID structs.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">megaraid_mbox_fire_sync_cmd</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mbox_t</span>	<span class="o">*</span><span class="n">mbox</span><span class="p">;</span>
	<span class="kt">uint8_t</span>	<span class="n">raw_mbox</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">mbox_t</span><span class="p">)];</span>
	<span class="n">mraid_device_t</span>	<span class="o">*</span><span class="n">raid_dev</span> <span class="o">=</span> <span class="n">ADAP2RAIDDEV</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">mbox64_t</span> <span class="o">*</span><span class="n">mbox64</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">dword</span><span class="p">;</span>

	<span class="n">mbox</span> <span class="o">=</span> <span class="p">(</span><span class="n">mbox_t</span> <span class="o">*</span><span class="p">)</span><span class="n">raw_mbox</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">((</span><span class="n">caddr_t</span><span class="p">)</span><span class="n">raw_mbox</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mbox_t</span><span class="p">));</span>

	<span class="n">raw_mbox</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xFF</span><span class="p">;</span>

	<span class="n">mbox64</span>	<span class="o">=</span> <span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">mbox64</span><span class="p">;</span>
	<span class="n">mbox</span>	<span class="o">=</span> <span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">mbox</span><span class="p">;</span>

	<span class="cm">/* Wait until mailbox is free */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">megaraid_busywait_mbox</span><span class="p">(</span><span class="n">raid_dev</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">blocked_mailbox</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Copy mailbox data into host structure */</span>
	<span class="n">memcpy</span><span class="p">((</span><span class="n">caddr_t</span><span class="p">)</span><span class="n">mbox</span><span class="p">,</span> <span class="p">(</span><span class="n">caddr_t</span><span class="p">)</span><span class="n">raw_mbox</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
	<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">cmdid</span>		<span class="o">=</span> <span class="mh">0xFE</span><span class="p">;</span>
	<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">busy</span>		<span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">poll</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">ack</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">numstatus</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">status</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">wmb</span><span class="p">();</span>
	<span class="n">WRINDOOR</span><span class="p">(</span><span class="n">raid_dev</span><span class="p">,</span> <span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">mbox_dma</span> <span class="o">|</span> <span class="mh">0x1</span><span class="p">);</span>

	<span class="cm">/* Wait for maximum 1 min for status to post.</span>
<span class="cm">	 * If the Firmware SUPPORTS the ABOVE COMMAND,</span>
<span class="cm">	 * mbox-&gt;cmd will be set to 0</span>
<span class="cm">	 * else</span>
<span class="cm">	 * the firmware will reject the command with</span>
<span class="cm">	 * mbox-&gt;numstatus set to 1</span>
<span class="cm">	 */</span>

	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">mbox</span><span class="o">-&gt;</span><span class="n">numstatus</span> <span class="o">&amp;&amp;</span> <span class="n">mbox</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">==</span> <span class="mh">0xFF</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rmb</span><span class="p">();</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">i</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">1000</span> <span class="o">*</span> <span class="mi">60</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mbox</span><span class="o">-&gt;</span><span class="n">numstatus</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/*cmd not supported*/</span>

	<span class="cm">/* Check for interrupt line */</span>
	<span class="n">dword</span> <span class="o">=</span> <span class="n">RDOUTDOOR</span><span class="p">(</span><span class="n">raid_dev</span><span class="p">);</span>
	<span class="n">WROUTDOOR</span><span class="p">(</span><span class="n">raid_dev</span><span class="p">,</span> <span class="n">dword</span><span class="p">);</span>
	<span class="n">WRINDOOR</span><span class="p">(</span><span class="n">raid_dev</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>

<span class="nl">blocked_mailbox:</span>
	<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;megaraid: blocked mailbox</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * megaraid_mbox_display_scb - display SCB information, mostly debug purposes</span>
<span class="cm"> * @adapter		: controller&#39;s soft state</span>
<span class="cm"> * @scb			: SCB to be displayed</span>
<span class="cm"> * @level		: debug level for console print</span>
<span class="cm"> *</span>
<span class="cm"> * Diplay information about the given SCB iff the current debug level is</span>
<span class="cm"> * verbose.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">megaraid_mbox_display_scb</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="n">scb_t</span> <span class="o">*</span><span class="n">scb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mbox_ccb_t</span>		<span class="o">*</span><span class="n">ccb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span>	<span class="o">*</span><span class="n">scp</span><span class="p">;</span>
	<span class="n">mbox_t</span>			<span class="o">*</span><span class="n">mbox</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">level</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">i</span><span class="p">;</span>


	<span class="n">ccb</span>	<span class="o">=</span> <span class="p">(</span><span class="n">mbox_ccb_t</span> <span class="o">*</span><span class="p">)</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">ccb</span><span class="p">;</span>
	<span class="n">scp</span>	<span class="o">=</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">scp</span><span class="p">;</span>
	<span class="n">mbox</span>	<span class="o">=</span> <span class="n">ccb</span><span class="o">-&gt;</span><span class="n">mbox</span><span class="p">;</span>

	<span class="n">level</span> <span class="o">=</span> <span class="n">CL_DLEVEL3</span><span class="p">;</span>

	<span class="n">con_log</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="p">(</span><span class="n">KERN_NOTICE</span>
		<span class="s">&quot;megaraid mailbox: status:%#x cmd:%#x id:%#x &quot;</span><span class="p">,</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">,</span>
		<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">,</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">sno</span><span class="p">));</span>

	<span class="n">con_log</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;sec:%#x lba:%#x addr:%#x ld:%d sg:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">numsectors</span><span class="p">,</span> <span class="n">mbox</span><span class="o">-&gt;</span><span class="n">lba</span><span class="p">,</span> <span class="n">mbox</span><span class="o">-&gt;</span><span class="n">xferaddr</span><span class="p">,</span> <span class="n">mbox</span><span class="o">-&gt;</span><span class="n">logdrv</span><span class="p">,</span>
		<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">numsge</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">scp</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

	<span class="n">con_log</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;scsi cmnd: &quot;</span><span class="p">));</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmd_len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">con_log</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;%#2.02x &quot;</span><span class="p">,</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
	<span class="p">}</span>

	<span class="n">con_log</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * megaraid_mbox_setup_device_map - manage device ids</span>
<span class="cm"> * @adapter	: Driver&#39;s soft state</span>
<span class="cm"> *</span>
<span class="cm"> * Manange the device ids to have an appropriate mapping between the kernel</span>
<span class="cm"> * scsi addresses and megaraid scsi and logical drive addresses. We export</span>
<span class="cm"> * scsi devices on their actual addresses, whereas the logical drives are</span>
<span class="cm"> * exported on a virtual scsi channel.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">megaraid_mbox_setup_device_map</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint8_t</span>		<span class="n">c</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">t</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * First fill the values on the logical drive channel</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">t</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">LSI_MAX_LOGICAL_DRIVES_64LD</span><span class="p">;</span> <span class="n">t</span><span class="o">++</span><span class="p">)</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">device_ids</span><span class="p">[</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">max_channel</span><span class="p">][</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span>
			<span class="p">(</span><span class="n">t</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">init_id</span><span class="p">)</span> <span class="o">?</span>  <span class="n">t</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">device_ids</span><span class="p">[</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">max_channel</span><span class="p">][</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">init_id</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xFF</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Fill the values on the physical devices channels</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">max_channel</span><span class="p">;</span> <span class="n">c</span><span class="o">++</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">t</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">LSI_MAX_LOGICAL_DRIVES_64LD</span><span class="p">;</span> <span class="n">t</span><span class="o">++</span><span class="p">)</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">device_ids</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">c</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">t</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * END: internal commands library</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * START: Interface for the common management module</span>
<span class="cm"> *</span>
<span class="cm"> * This is the module, which interfaces with the common management module to</span>
<span class="cm"> * provide support for ioctl and sysfs</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * megaraid_cmm_register - register with the management module</span>
<span class="cm"> * @adapter		: HBA soft state</span>
<span class="cm"> *</span>
<span class="cm"> * Register with the management module, which allows applications to issue</span>
<span class="cm"> * ioctl calls to the drivers. This interface is used by the management module</span>
<span class="cm"> * to setup sysfs support as well.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">megaraid_cmm_register</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mraid_device_t</span>	<span class="o">*</span><span class="n">raid_dev</span> <span class="o">=</span> <span class="n">ADAP2RAIDDEV</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">mraid_mmadp_t</span>	<span class="n">adp</span><span class="p">;</span>
	<span class="n">scb_t</span>		<span class="o">*</span><span class="n">scb</span><span class="p">;</span>
	<span class="n">mbox_ccb_t</span>	<span class="o">*</span><span class="n">ccb</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">rval</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">i</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-109"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-109">&#182;</a></div><p>Allocate memory for the base list of scb for management module.</p></td><td class="code"><div class="highlight"><pre>	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">uscb_list</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">MBOX_MAX_USER_CMDS</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">scb_t</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">uscb_list</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="n">KERN_WARNING</span>
			<span class="s">&quot;megaraid: out of memory, %s %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
			<span class="n">__LINE__</span><span class="p">));</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-110"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-110">&#182;</a></div><p>Initialize the synchronization parameters for resources for
commands for management module</p></td><td class="code"><div class="highlight"><pre>	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">uscb_pool</span><span class="p">);</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="n">USER_FREE_LIST_LOCK</span><span class="p">(</span><span class="n">adapter</span><span class="p">));</span></pre></div></td></tr>


<tr id="section-111"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-111">&#182;</a></div><p>link all the packets. Note, CCB for commands, coming from the
commom management module, mailbox physical address are already
setup by it. We just need placeholder for that in our local command
control blocks</p></td><td class="code"><div class="highlight"><pre>	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MBOX_MAX_USER_CMDS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">scb</span>			<span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">uscb_list</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">ccb</span>			<span class="o">=</span> <span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">uccb_list</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>

		<span class="n">scb</span><span class="o">-&gt;</span><span class="n">ccb</span>		<span class="o">=</span> <span class="p">(</span><span class="n">caddr_t</span><span class="p">)</span><span class="n">ccb</span><span class="p">;</span>
		<span class="n">ccb</span><span class="o">-&gt;</span><span class="n">mbox64</span>		<span class="o">=</span> <span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">umbox64</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">ccb</span><span class="o">-&gt;</span><span class="n">mbox</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">ccb</span><span class="o">-&gt;</span><span class="n">mbox64</span><span class="o">-&gt;</span><span class="n">mbox32</span><span class="p">;</span>
		<span class="n">ccb</span><span class="o">-&gt;</span><span class="n">raw_mbox</span>		<span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span><span class="n">ccb</span><span class="o">-&gt;</span><span class="n">mbox</span><span class="p">;</span>

		<span class="n">scb</span><span class="o">-&gt;</span><span class="n">gp</span>			<span class="o">=</span> <span class="mi">0</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-112"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-112">&#182;</a></div><p>COMMAND ID 0 - (MBOX<em>MAX</em>SCSI_CMDS-1) ARE RESERVED FOR
COMMANDS COMING FROM IO SUBSYSTEM (MID-LAYER)</p></td><td class="code"><div class="highlight"><pre>		<span class="n">scb</span><span class="o">-&gt;</span><span class="n">sno</span>		<span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">MBOX_MAX_SCSI_CMDS</span><span class="p">;</span>

		<span class="n">scb</span><span class="o">-&gt;</span><span class="n">scp</span>		<span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">scb</span><span class="o">-&gt;</span><span class="n">state</span>		<span class="o">=</span> <span class="n">SCB_FREE</span><span class="p">;</span>
		<span class="n">scb</span><span class="o">-&gt;</span><span class="n">dma_direction</span>	<span class="o">=</span> <span class="n">PCI_DMA_NONE</span><span class="p">;</span>
		<span class="n">scb</span><span class="o">-&gt;</span><span class="n">dma_type</span>		<span class="o">=</span> <span class="n">MRAID_DMA_NONE</span><span class="p">;</span>
		<span class="n">scb</span><span class="o">-&gt;</span><span class="n">dev_channel</span>	<span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">scb</span><span class="o">-&gt;</span><span class="n">dev_target</span>		<span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-113"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-113">&#182;</a></div><p>put scb in the free pool</p></td><td class="code"><div class="highlight"><pre>		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">uscb_pool</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">adp</span><span class="p">.</span><span class="n">unique_id</span>		<span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">unique_id</span><span class="p">;</span>
	<span class="n">adp</span><span class="p">.</span><span class="n">drvr_type</span>		<span class="o">=</span> <span class="n">DRVRTYPE_MBOX</span><span class="p">;</span>
	<span class="n">adp</span><span class="p">.</span><span class="n">drvr_data</span>		<span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">adapter</span><span class="p">;</span>
	<span class="n">adp</span><span class="p">.</span><span class="n">pdev</span>		<span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="n">adp</span><span class="p">.</span><span class="n">issue_uioc</span>		<span class="o">=</span> <span class="n">megaraid_mbox_mm_handler</span><span class="p">;</span>
	<span class="n">adp</span><span class="p">.</span><span class="n">timeout</span>		<span class="o">=</span> <span class="n">MBOX_RESET_WAIT</span> <span class="o">+</span> <span class="n">MBOX_RESET_EXT_WAIT</span><span class="p">;</span>
	<span class="n">adp</span><span class="p">.</span><span class="n">max_kioc</span>		<span class="o">=</span> <span class="n">MBOX_MAX_USER_CMDS</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">rval</span> <span class="o">=</span> <span class="n">mraid_mm_register_adp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adp</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="n">KERN_WARNING</span>
			<span class="s">&quot;megaraid mbox: did not register with CMM</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>

		<span class="n">kfree</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">uscb_list</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">rval</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * megaraid_cmm_unregister - un-register with the management module</span>
<span class="cm"> * @adapter		: HBA soft state</span>
<span class="cm"> *</span>
<span class="cm"> * Un-register with the management module.</span>
<span class="cm"> * FIXME: mgmt module must return failure for unregister if it has pending</span>
<span class="cm"> * commands in LLD.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">megaraid_cmm_unregister</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">uscb_list</span><span class="p">);</span>
	<span class="n">mraid_mm_unregister_adp</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">unique_id</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * megaraid_mbox_mm_handler - interface for CMM to issue commands to LLD</span>
<span class="cm"> * @drvr_data		: LLD specific data</span>
<span class="cm"> * @kioc		: CMM interface packet</span>
<span class="cm"> * @action		: command action</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked whenever the Common Management Module (CMM) has a</span>
<span class="cm"> * command for us. The &#39;action&#39; parameter specifies if this is a new command</span>
<span class="cm"> * or otherwise.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">megaraid_mbox_mm_handler</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">drvr_data</span><span class="p">,</span> <span class="n">uioc_t</span> <span class="o">*</span><span class="n">kioc</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">action</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">action</span> <span class="o">!=</span> <span class="n">IOCTL_ISSUE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="n">KERN_WARNING</span>
			<span class="s">&quot;megaraid: unsupported management action:%#2x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">action</span><span class="p">));</span>
		<span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="n">ENOTSUPP</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">adapter</span> <span class="o">=</span> <span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="p">)</span><span class="n">drvr_data</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-114"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-114">&#182;</a></div><p>make sure this adapter is not being detached right now.</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">being_detached</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="n">KERN_WARNING</span>
			<span class="s">&quot;megaraid: reject management request, detaching</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
		<span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="n">ENODEV</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">kioc</span><span class="o">-&gt;</span><span class="n">opcode</span><span class="p">)</span> <span class="p">{</span>

	<span class="k">case</span> <span class="n">GET_ADAP_INFO</span>:

		<span class="n">kioc</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span>  <span class="n">gather_hbainfo</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="p">(</span><span class="n">mraid_hba_info_t</span> <span class="o">*</span><span class="p">)</span>
					<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">kioc</span><span class="o">-&gt;</span><span class="n">buf_vaddr</span><span class="p">);</span>

		<span class="n">kioc</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">(</span><span class="n">kioc</span><span class="p">);</span>

		<span class="k">return</span> <span class="n">kioc</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">MBOX_CMD</span>:

		<span class="k">return</span> <span class="n">megaraid_mbox_mm_command</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">kioc</span><span class="p">);</span>

	<span class="nl">default:</span>
		<span class="n">kioc</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
		<span class="n">kioc</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">(</span><span class="n">kioc</span><span class="p">);</span>
		<span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>	<span class="c1">// not reached</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * megaraid_mbox_mm_command - issues commands routed through CMM</span>
<span class="cm"> * @adapter		: HBA soft state</span>
<span class="cm"> * @kioc		: management command packet</span>
<span class="cm"> *</span>
<span class="cm"> * Issues commands, which are routed through the management module.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">megaraid_mbox_mm_command</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="n">uioc_t</span> <span class="o">*</span><span class="n">kioc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">uscb_pool</span><span class="p">;</span>
	<span class="n">mbox64_t</span>		<span class="o">*</span><span class="n">mbox64</span><span class="p">;</span>
	<span class="kt">uint8_t</span>			<span class="o">*</span><span class="n">raw_mbox</span><span class="p">;</span>
	<span class="n">scb_t</span>			<span class="o">*</span><span class="n">scb</span><span class="p">;</span>
	<span class="n">mbox_ccb_t</span>		<span class="o">*</span><span class="n">ccb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-115"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-115">&#182;</a></div><p>detach one scb from free pool</p></td><td class="code"><div class="highlight"><pre>	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">USER_FREE_LIST_LOCK</span><span class="p">(</span><span class="n">adapter</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="n">head</span><span class="p">))</span> <span class="p">{</span>	<span class="c1">// should never happen because of CMM</span>

		<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="n">KERN_WARNING</span>
			<span class="s">&quot;megaraid mbox: bug in cmm handler, lost resources</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>

		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">USER_FREE_LIST_LOCK</span><span class="p">(</span><span class="n">adapter</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>

		<span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">scb</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">scb_t</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">USER_FREE_LIST_LOCK</span><span class="p">(</span><span class="n">adapter</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">scb</span><span class="o">-&gt;</span><span class="n">state</span>		<span class="o">=</span> <span class="n">SCB_ACTIVE</span><span class="p">;</span>
	<span class="n">scb</span><span class="o">-&gt;</span><span class="n">dma_type</span>		<span class="o">=</span> <span class="n">MRAID_DMA_NONE</span><span class="p">;</span>
	<span class="n">scb</span><span class="o">-&gt;</span><span class="n">dma_direction</span>	<span class="o">=</span> <span class="n">PCI_DMA_NONE</span><span class="p">;</span>

	<span class="n">ccb</span>		<span class="o">=</span> <span class="p">(</span><span class="n">mbox_ccb_t</span> <span class="o">*</span><span class="p">)</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">ccb</span><span class="p">;</span>
	<span class="n">mbox64</span>		<span class="o">=</span> <span class="p">(</span><span class="n">mbox64_t</span> <span class="o">*</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">kioc</span><span class="o">-&gt;</span><span class="n">cmdbuf</span><span class="p">;</span>
	<span class="n">raw_mbox</span>	<span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">mbox64</span><span class="o">-&gt;</span><span class="n">mbox32</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">ccb</span><span class="o">-&gt;</span><span class="n">mbox64</span><span class="p">,</span> <span class="n">mbox64</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mbox64_t</span><span class="p">));</span>

	<span class="n">scb</span><span class="o">-&gt;</span><span class="n">gp</span>		<span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">kioc</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If it is a logdrv random delete operation, we have to wait till</span>
<span class="cm">	 * there are no outstanding cmds at the fw and then issue it directly</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">raw_mbox</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">FC_DEL_LOGDRV</span> <span class="o">&amp;&amp;</span> <span class="n">raw_mbox</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">OP_DEL_LOGDRV</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">wait_till_fw_empty</span><span class="p">(</span><span class="n">adapter</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="n">KERN_NOTICE</span>
				<span class="s">&quot;megaraid mbox: LD delete, timed out</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>

			<span class="n">kioc</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ETIME</span><span class="p">;</span>

			<span class="n">scb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

			<span class="n">megaraid_mbox_mm_done</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>

			<span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="n">ETIME</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>

		<span class="n">scb</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">SCB_ISSUED</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mbox_post_cmd</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">scb</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

			<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="n">KERN_NOTICE</span>
				<span class="s">&quot;megaraid mbox: LD delete, mailbox busy</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>

			<span class="n">kioc</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

			<span class="n">scb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

			<span class="n">megaraid_mbox_mm_done</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>

			<span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="n">EBUSY</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-116"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-116">&#182;</a></div><p>put the command on the pending list and execute</p></td><td class="code"><div class="highlight"><pre>	<span class="n">megaraid_mbox_runpendq</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span>
<span class="nf">wait_till_fw_empty</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">i</span><span class="p">;</span>


	<span class="cm">/*</span>
<span class="cm">	 * Set the quiescent flag to stop issuing cmds to FW.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">quiescent</span><span class="o">++</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Wait till there are no more cmds outstanding at FW. Try for at most</span>
<span class="cm">	 * 60 seconds</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">60</span> <span class="o">&amp;&amp;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">outstanding_cmds</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">con_log</span><span class="p">(</span><span class="n">CL_DLEVEL1</span><span class="p">,</span> <span class="p">(</span><span class="n">KERN_INFO</span>
			<span class="s">&quot;megaraid: FW has %d pending commands</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">outstanding_cmds</span><span class="p">));</span>

		<span class="n">msleep</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">outstanding_cmds</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * megaraid_mbox_mm_done - callback for CMM commands</span>
<span class="cm"> * @adapter	: HBA soft state</span>
<span class="cm"> * @scb		: completed command</span>
<span class="cm"> *</span>
<span class="cm"> * Callback routine for internal commands originated from the management</span>
<span class="cm"> * module.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">megaraid_mbox_mm_done</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="n">scb_t</span> <span class="o">*</span><span class="n">scb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">uioc_t</span>			<span class="o">*</span><span class="n">kioc</span><span class="p">;</span>
	<span class="n">mbox64_t</span>		<span class="o">*</span><span class="n">mbox64</span><span class="p">;</span>
	<span class="kt">uint8_t</span>			<span class="o">*</span><span class="n">raw_mbox</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span>

	<span class="n">kioc</span>			<span class="o">=</span> <span class="p">(</span><span class="n">uioc_t</span> <span class="o">*</span><span class="p">)</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">gp</span><span class="p">;</span>
	<span class="n">mbox64</span>			<span class="o">=</span> <span class="p">(</span><span class="n">mbox64_t</span> <span class="o">*</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">kioc</span><span class="o">-&gt;</span><span class="n">cmdbuf</span><span class="p">;</span>
	<span class="n">mbox64</span><span class="o">-&gt;</span><span class="n">mbox32</span><span class="p">.</span><span class="n">status</span>	<span class="o">=</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">;</span>
	<span class="n">raw_mbox</span>		<span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">mbox64</span><span class="o">-&gt;</span><span class="n">mbox32</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-117"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-117">&#182;</a></div><p>put scb in the free pool</p></td><td class="code"><div class="highlight"><pre>	<span class="n">scb</span><span class="o">-&gt;</span><span class="n">state</span>	<span class="o">=</span> <span class="n">SCB_FREE</span><span class="p">;</span>
	<span class="n">scb</span><span class="o">-&gt;</span><span class="n">scp</span>	<span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">USER_FREE_LIST_LOCK</span><span class="p">(</span><span class="n">adapter</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">uscb_pool</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">USER_FREE_LIST_LOCK</span><span class="p">(</span><span class="n">adapter</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-118"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-118">&#182;</a></div><p>if a delete logical drive operation succeeded, restart the
controller</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span> <span class="p">(</span><span class="n">raw_mbox</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">FC_DEL_LOGDRV</span> <span class="o">&amp;&amp;</span> <span class="n">raw_mbox</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">OP_DEL_LOGDRV</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">quiescent</span><span class="o">--</span><span class="p">;</span>

		<span class="n">megaraid_mbox_runpendq</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">kioc</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">(</span><span class="n">kioc</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * gather_hbainfo - HBA characteristics for the applications</span>
<span class="cm"> * @adapter		: HBA soft state</span>
<span class="cm"> * @hinfo		: pointer to the caller&#39;s host info strucuture</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">gather_hbainfo</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="n">mraid_hba_info_t</span> <span class="o">*</span><span class="n">hinfo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint8_t</span>	<span class="n">dmajor</span><span class="p">;</span>

	<span class="n">dmajor</span>			<span class="o">=</span> <span class="n">megaraid_mbox_version</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="n">hinfo</span><span class="o">-&gt;</span><span class="n">pci_vendor_id</span>	<span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">vendor</span><span class="p">;</span>
	<span class="n">hinfo</span><span class="o">-&gt;</span><span class="n">pci_device_id</span>	<span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">;</span>
	<span class="n">hinfo</span><span class="o">-&gt;</span><span class="n">subsys_vendor_id</span>	<span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">subsystem_vendor</span><span class="p">;</span>
	<span class="n">hinfo</span><span class="o">-&gt;</span><span class="n">subsys_device_id</span>	<span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">subsystem_device</span><span class="p">;</span>

	<span class="n">hinfo</span><span class="o">-&gt;</span><span class="n">pci_bus</span>		<span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">;</span>
	<span class="n">hinfo</span><span class="o">-&gt;</span><span class="n">pci_dev_fn</span>	<span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">;</span>
	<span class="n">hinfo</span><span class="o">-&gt;</span><span class="n">pci_slot</span>		<span class="o">=</span> <span class="n">PCI_SLOT</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">);</span>
	<span class="n">hinfo</span><span class="o">-&gt;</span><span class="n">irq</span>		<span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>
	<span class="n">hinfo</span><span class="o">-&gt;</span><span class="n">baseport</span>		<span class="o">=</span> <span class="n">ADAP2RAIDDEV</span><span class="p">(</span><span class="n">adapter</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">baseport</span><span class="p">;</span>

	<span class="n">hinfo</span><span class="o">-&gt;</span><span class="n">unique_id</span>	<span class="o">=</span> <span class="p">(</span><span class="n">hinfo</span><span class="o">-&gt;</span><span class="n">pci_bus</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">;</span>
	<span class="n">hinfo</span><span class="o">-&gt;</span><span class="n">host_no</span>		<span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * END: Interface for the common management module</span>
<span class="cm"> */</span>



<span class="cm">/**</span>
<span class="cm"> * megaraid_sysfs_alloc_resources - allocate sysfs related resources</span>
<span class="cm"> * @adapter	: controller&#39;s soft state</span>
<span class="cm"> *</span>
<span class="cm"> * Allocate packets required to issue FW calls whenever the sysfs attributes</span>
<span class="cm"> * are read. These attributes would require up-to-date information from the</span>
<span class="cm"> * FW. Also set up resources for mutual exclusion to share these resources and</span>
<span class="cm"> * the wait queue.</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 on success.</span>
<span class="cm"> * Return -ERROR_CODE on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">megaraid_sysfs_alloc_resources</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mraid_device_t</span>	<span class="o">*</span><span class="n">raid_dev</span> <span class="o">=</span> <span class="n">ADAP2RAIDDEV</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="kt">int</span>		<span class="n">rval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">sysfs_uioc</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">uioc_t</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">sysfs_mbox64</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">mbox64_t</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">sysfs_buffer</span> <span class="o">=</span> <span class="n">pci_alloc_consistent</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
			<span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">sysfs_buffer_dma</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">sysfs_uioc</span> <span class="o">||</span> <span class="o">!</span><span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">sysfs_mbox64</span> <span class="o">||</span>
		<span class="o">!</span><span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">sysfs_buffer</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="n">KERN_WARNING</span>
			<span class="s">&quot;megaraid: out of memory, %s %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
			<span class="n">__LINE__</span><span class="p">));</span>

		<span class="n">rval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

		<span class="n">megaraid_sysfs_free_resources</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">sysfs_mtx</span><span class="p">);</span>

	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">sysfs_wait_q</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rval</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * megaraid_sysfs_free_resources - free sysfs related resources</span>
<span class="cm"> * @adapter	: controller&#39;s soft state</span>
<span class="cm"> *</span>
<span class="cm"> * Free packets allocated for sysfs FW commands</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">megaraid_sysfs_free_resources</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mraid_device_t</span>	<span class="o">*</span><span class="n">raid_dev</span> <span class="o">=</span> <span class="n">ADAP2RAIDDEV</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">sysfs_uioc</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">sysfs_mbox64</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">sysfs_buffer</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span>
			<span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">sysfs_buffer</span><span class="p">,</span> <span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">sysfs_buffer_dma</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * megaraid_sysfs_get_ldmap_done - callback for get ldmap</span>
<span class="cm"> * @uioc	: completed packet</span>
<span class="cm"> *</span>
<span class="cm"> * Callback routine called in the ISR/tasklet context for get ldmap call</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">megaraid_sysfs_get_ldmap_done</span><span class="p">(</span><span class="n">uioc_t</span> <span class="o">*</span><span class="n">uioc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">adapter_t</span>	<span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="p">)</span><span class="n">uioc</span><span class="o">-&gt;</span><span class="n">buf_vaddr</span><span class="p">;</span>
	<span class="n">mraid_device_t</span>	<span class="o">*</span><span class="n">raid_dev</span> <span class="o">=</span> <span class="n">ADAP2RAIDDEV</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">uioc</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">sysfs_wait_q</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * megaraid_sysfs_get_ldmap_timeout - timeout handling for get ldmap</span>
<span class="cm"> * @data	: timed out packet</span>
<span class="cm"> *</span>
<span class="cm"> * Timeout routine to recover and return to application, in case the adapter</span>
<span class="cm"> * has stopped responding. A timeout of 60 seconds for this command seems like</span>
<span class="cm"> * a good value.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">megaraid_sysfs_get_ldmap_timeout</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">uioc_t</span>		<span class="o">*</span><span class="n">uioc</span> <span class="o">=</span> <span class="p">(</span><span class="n">uioc_t</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
	<span class="n">adapter_t</span>	<span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="p">)</span><span class="n">uioc</span><span class="o">-&gt;</span><span class="n">buf_vaddr</span><span class="p">;</span>
	<span class="n">mraid_device_t</span>	<span class="o">*</span><span class="n">raid_dev</span> <span class="o">=</span> <span class="n">ADAP2RAIDDEV</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">uioc</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ETIME</span><span class="p">;</span>

	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">sysfs_wait_q</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * megaraid_sysfs_get_ldmap - get update logical drive map</span>
<span class="cm"> * @adapter	: controller&#39;s soft state</span>
<span class="cm"> *</span>
<span class="cm"> * This routine will be called whenever user reads the logical drive</span>
<span class="cm"> * attributes, go get the current logical drive mapping table from the</span>
<span class="cm"> * firmware. We use the management API&#39;s to issue commands to the controller.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: The commands issuance functionality is not generalized and</span>
<span class="cm"> * implemented in context of &quot;get ld map&quot; command only. If required, the</span>
<span class="cm"> * command issuance logical can be trivially pulled out and implemented as a</span>
<span class="cm"> * standalone library. For now, this should suffice since there is no other</span>
<span class="cm"> * user of this interface.</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 on success.</span>
<span class="cm"> * Return -1 on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">megaraid_sysfs_get_ldmap</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mraid_device_t</span>		<span class="o">*</span><span class="n">raid_dev</span> <span class="o">=</span> <span class="n">ADAP2RAIDDEV</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">uioc_t</span>			<span class="o">*</span><span class="n">uioc</span><span class="p">;</span>
	<span class="n">mbox64_t</span>		<span class="o">*</span><span class="n">mbox64</span><span class="p">;</span>
	<span class="n">mbox_t</span>			<span class="o">*</span><span class="n">mbox</span><span class="p">;</span>
	<span class="kt">char</span>			<span class="o">*</span><span class="n">raw_mbox</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timer_list</span>	<span class="n">sysfs_timer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timer_list</span>	<span class="o">*</span><span class="n">timerp</span><span class="p">;</span>
	<span class="n">caddr_t</span>			<span class="n">ldmap</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">rval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allow only one read at a time to go through the sysfs attributes</span>
<span class="cm">	 */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">sysfs_mtx</span><span class="p">);</span>

	<span class="n">uioc</span>	<span class="o">=</span> <span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">sysfs_uioc</span><span class="p">;</span>
	<span class="n">mbox64</span>	<span class="o">=</span> <span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">sysfs_mbox64</span><span class="p">;</span>
	<span class="n">ldmap</span>	<span class="o">=</span> <span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">sysfs_buffer</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">uioc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">uioc_t</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">mbox64</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mbox64_t</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">ldmap</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">curr_ldmap</span><span class="p">));</span>

	<span class="n">mbox</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">mbox64</span><span class="o">-&gt;</span><span class="n">mbox32</span><span class="p">;</span>
	<span class="n">raw_mbox</span>	<span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">mbox</span><span class="p">;</span>
	<span class="n">uioc</span><span class="o">-&gt;</span><span class="n">cmdbuf</span>    <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">mbox64</span><span class="p">;</span>
	<span class="n">uioc</span><span class="o">-&gt;</span><span class="n">buf_vaddr</span>	<span class="o">=</span> <span class="p">(</span><span class="n">caddr_t</span><span class="p">)</span><span class="n">adapter</span><span class="p">;</span>
	<span class="n">uioc</span><span class="o">-&gt;</span><span class="n">status</span>	<span class="o">=</span> <span class="o">-</span><span class="n">ENODATA</span><span class="p">;</span>
	<span class="n">uioc</span><span class="o">-&gt;</span><span class="n">done</span>	<span class="o">=</span> <span class="n">megaraid_sysfs_get_ldmap_done</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Prepare the mailbox packet to get the current logical drive mapping</span>
<span class="cm">	 * table</span>
<span class="cm">	 */</span>
	<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">xferaddr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">sysfs_buffer_dma</span><span class="p">;</span>

	<span class="n">raw_mbox</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">FC_DEL_LOGDRV</span><span class="p">;</span>
	<span class="n">raw_mbox</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">OP_GET_LDID_MAP</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Setup a timer to recover from a non-responding controller</span>
<span class="cm">	 */</span>
	<span class="n">timerp</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">sysfs_timer</span><span class="p">;</span>
	<span class="n">init_timer</span><span class="p">(</span><span class="n">timerp</span><span class="p">);</span>

	<span class="n">timerp</span><span class="o">-&gt;</span><span class="n">function</span>	<span class="o">=</span> <span class="n">megaraid_sysfs_get_ldmap_timeout</span><span class="p">;</span>
	<span class="n">timerp</span><span class="o">-&gt;</span><span class="n">data</span>		<span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">uioc</span><span class="p">;</span>
	<span class="n">timerp</span><span class="o">-&gt;</span><span class="n">expires</span>		<span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="mi">60</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">;</span>

	<span class="n">add_timer</span><span class="p">(</span><span class="n">timerp</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Send the command to the firmware</span>
<span class="cm">	 */</span>
	<span class="n">rval</span> <span class="o">=</span> <span class="n">megaraid_mbox_mm_command</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">uioc</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rval</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>	<span class="c1">// command successfully issued</span>
		<span class="n">wait_event</span><span class="p">(</span><span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">sysfs_wait_q</span><span class="p">,</span> <span class="p">(</span><span class="n">uioc</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENODATA</span><span class="p">));</span>

		<span class="cm">/*</span>
<span class="cm">		 * Check if the command timed out</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">uioc</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">ETIME</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="n">KERN_NOTICE</span>
				<span class="s">&quot;megaraid: sysfs get ld map timed out</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>

			<span class="n">rval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ETIME</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">rval</span> <span class="o">=</span> <span class="n">mbox</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rval</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">curr_ldmap</span><span class="p">,</span> <span class="n">ldmap</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">curr_ldmap</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="n">KERN_NOTICE</span>
				<span class="s">&quot;megaraid: get ld map failed with %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rval</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="n">KERN_NOTICE</span>
			<span class="s">&quot;megaraid: could not issue ldmap command:%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rval</span><span class="p">));</span>
	<span class="p">}</span>


	<span class="n">del_timer_sync</span><span class="p">(</span><span class="n">timerp</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">sysfs_mtx</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rval</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * megaraid_sysfs_show_app_hndl - display application handle for this adapter</span>
<span class="cm"> * @cdev	: class device object representation for the host</span>
<span class="cm"> * @buf		: buffer to send data to</span>
<span class="cm"> *</span>
<span class="cm"> * Display the handle used by the applications while executing management</span>
<span class="cm"> * tasks on the adapter. We invoke a management module API to get the adapter</span>
<span class="cm"> * handle, since we do not interface with applications directly.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">megaraid_sysfs_show_app_hndl</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			     <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">adapter_t</span>	<span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="p">)</span><span class="n">SCSIHOST2ADAP</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="kt">uint32_t</span>	<span class="n">app_hndl</span><span class="p">;</span>

	<span class="n">app_hndl</span> <span class="o">=</span> <span class="n">mraid_mm_adapter_app_handle</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">unique_id</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">app_hndl</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * megaraid_sysfs_show_ldnum - display the logical drive number for this device</span>
<span class="cm"> * @dev		: device object representation for the scsi device</span>
<span class="cm"> * @attr	: device attribute to show</span>
<span class="cm"> * @buf		: buffer to send data to</span>
<span class="cm"> *</span>
<span class="cm"> * Display the logical drive number for the device in question, if it a valid</span>
<span class="cm"> * logical drive. For physical devices, &quot;-1&quot; is returned.</span>
<span class="cm"> *</span>
<span class="cm"> * The logical drive number is displayed in following format:</span>
<span class="cm"> *</span>
<span class="cm"> * &lt;SCSI ID&gt; &lt;LD NUM&gt; &lt;LD STICKY ID&gt; &lt;APP ADAPTER HANDLE&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *   &lt;int&gt;     &lt;int&gt;       &lt;int&gt;            &lt;int&gt;</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">megaraid_sysfs_show_ldnum</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span> <span class="o">=</span> <span class="n">to_scsi_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">adapter_t</span>	<span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="p">)</span><span class="n">SCSIHOST2ADAP</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>
	<span class="n">mraid_device_t</span>	<span class="o">*</span><span class="n">raid_dev</span> <span class="o">=</span> <span class="n">ADAP2RAIDDEV</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="kt">int</span>		<span class="n">scsi_id</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">logical_drv</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">ldid_map</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">uint32_t</span>	<span class="n">app_hndl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">mapped_sdev_id</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">rval</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">random_del_supported</span> <span class="o">&amp;&amp;</span>
			<span class="n">MRAID_IS_LOGICAL_SDEV</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">sdev</span><span class="p">))</span> <span class="p">{</span>

		<span class="n">rval</span> <span class="o">=</span> <span class="n">megaraid_sysfs_get_ldmap</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rval</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_LOGICAL_DRIVES_40LD</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

				<span class="n">mapped_sdev_id</span> <span class="o">=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">&gt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">init_id</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">mapped_sdev_id</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">curr_ldmap</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">mapped_sdev_id</span><span class="p">)</span> <span class="p">{</span>

					<span class="n">scsi_id</span> <span class="o">=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>

					<span class="n">logical_drv</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

					<span class="n">ldid_map</span> <span class="o">=</span> <span class="n">raid_dev</span><span class="o">-&gt;</span><span class="n">curr_ldmap</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

					<span class="n">app_hndl</span> <span class="o">=</span> <span class="n">mraid_mm_adapter_app_handle</span><span class="p">(</span>
							<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">unique_id</span><span class="p">);</span>

					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">con_log</span><span class="p">(</span><span class="n">CL_ANN</span><span class="p">,</span> <span class="p">(</span><span class="n">KERN_NOTICE</span>
				<span class="s">&quot;megaraid: sysfs get ld map failed: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">rval</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">36</span><span class="p">,</span> <span class="s">&quot;%d %d %d %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">scsi_id</span><span class="p">,</span> <span class="n">logical_drv</span><span class="p">,</span>
			<span class="n">ldid_map</span><span class="p">,</span> <span class="n">app_hndl</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * END: Mailbox Low Level Driver</span>
<span class="cm"> */</span>
<span class="n">module_init</span><span class="p">(</span><span class="n">megaraid_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">megaraid_exit</span><span class="p">);</span>

<span class="cm">/* vim: set ts=8 sw=8 tw=78 ai si: */</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
