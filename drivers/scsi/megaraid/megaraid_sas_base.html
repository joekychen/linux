<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › scsi › megaraid › megaraid_sas_base.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>megaraid_sas_base.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  Linux MegaRAID driver for SAS based RAID controllers</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (c) 2009-2011  LSI Corporation.</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is free software; you can redistribute it and/or</span>
<span class="cm"> *  modify it under the terms of the GNU General Public License</span>
<span class="cm"> *  as published by the Free Software Foundation; either version 2</span>
<span class="cm"> *  of the License, or (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is distributed in the hope that it will be useful,</span>
<span class="cm"> *  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> *  GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> *  You should have received a copy of the GNU General Public License</span>
<span class="cm"> *  along with this program; if not, write to the Free Software</span>
<span class="cm"> *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA</span>
<span class="cm"> *</span>
<span class="cm"> *  FILE: megaraid_sas_base.c</span>
<span class="cm"> *  Version : v00.00.06.15-rc1</span>
<span class="cm"> *</span>
<span class="cm"> *  Authors: LSI Corporation</span>
<span class="cm"> *           Sreenivas Bagalkote</span>
<span class="cm"> *           Sumant Patro</span>
<span class="cm"> *           Bo Yang</span>
<span class="cm"> *           Adam Radford &lt;linuxraid@lsi.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *  Send feedback to: &lt;megaraidlinux@lsi.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *  Mail to: LSI Corporation, 1621 Barber Lane, Milpitas, CA 95035</span>
<span class="cm"> *     ATTN: Linuxraid</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/moduleparam.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/uio.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/compat.h&gt;</span>
<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/poll.h&gt;</span>

<span class="cp">#include &lt;scsi/scsi.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_cmnd.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_device.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_host.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_tcq.h&gt;</span>
<span class="cp">#include &quot;megaraid_sas_fusion.h&quot;</span>
<span class="cp">#include &quot;megaraid_sas.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * Number of sectors per IO command</span>
<span class="cm"> * Will be set in megasas_init_mfi if user does not provide</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_sectors</span><span class="p">;</span>
<span class="n">module_param_named</span><span class="p">(</span><span class="n">max_sectors</span><span class="p">,</span> <span class="n">max_sectors</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">max_sectors</span><span class="p">,</span>
	<span class="s">&quot;Maximum number of sectors per IO command&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">msix_disable</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">msix_disable</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">msix_disable</span><span class="p">,</span> <span class="s">&quot;Disable MSI-X interrupt handling. Default: 0&quot;</span><span class="p">);</span>

<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_VERSION</span><span class="p">(</span><span class="n">MEGASAS_VERSION</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;megaraidlinux@lsi.com&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;LSI MegaRAID SAS Driver&quot;</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">megasas_transition_to_ready</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ocr</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">megasas_get_pd_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">megasas_issue_init_mfi</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">megasas_register_aen</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span>
				<span class="n">u32</span> <span class="n">seq_num</span><span class="p">,</span> <span class="n">u32</span> <span class="n">class_locale_word</span><span class="p">);</span>
<span class="cm">/*</span>
<span class="cm"> * PCI ID table for all supported controllers</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="n">megasas_pci_table</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>

	<span class="p">{</span><span class="n">PCI_DEVICE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_LSI_LOGIC</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_LSI_SAS1064R</span><span class="p">)},</span>
	<span class="cm">/* xscale IOP */</span>
	<span class="p">{</span><span class="n">PCI_DEVICE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_LSI_LOGIC</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_LSI_SAS1078R</span><span class="p">)},</span>
	<span class="cm">/* ppc IOP */</span>
	<span class="p">{</span><span class="n">PCI_DEVICE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_LSI_LOGIC</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_LSI_SAS1078DE</span><span class="p">)},</span>
	<span class="cm">/* ppc IOP */</span>
	<span class="p">{</span><span class="n">PCI_DEVICE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_LSI_LOGIC</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_LSI_SAS1078GEN2</span><span class="p">)},</span>
	<span class="cm">/* gen2*/</span>
	<span class="p">{</span><span class="n">PCI_DEVICE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_LSI_LOGIC</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_LSI_SAS0079GEN2</span><span class="p">)},</span>
	<span class="cm">/* gen2*/</span>
	<span class="p">{</span><span class="n">PCI_DEVICE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_LSI_LOGIC</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_LSI_SAS0073SKINNY</span><span class="p">)},</span>
	<span class="cm">/* skinny*/</span>
	<span class="p">{</span><span class="n">PCI_DEVICE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_LSI_LOGIC</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_LSI_SAS0071SKINNY</span><span class="p">)},</span>
	<span class="cm">/* skinny*/</span>
	<span class="p">{</span><span class="n">PCI_DEVICE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_LSI_LOGIC</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_LSI_VERDE_ZCR</span><span class="p">)},</span>
	<span class="cm">/* xscale IOP, vega */</span>
	<span class="p">{</span><span class="n">PCI_DEVICE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_DELL</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_DELL_PERC5</span><span class="p">)},</span>
	<span class="cm">/* xscale IOP */</span>
	<span class="p">{</span><span class="n">PCI_DEVICE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_LSI_LOGIC</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_LSI_FUSION</span><span class="p">)},</span>
	<span class="cm">/* Fusion */</span>
	<span class="p">{</span><span class="n">PCI_DEVICE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_LSI_LOGIC</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_LSI_INVADER</span><span class="p">)},</span>
	<span class="cm">/* Invader */</span>
	<span class="p">{}</span>
<span class="p">};</span>

<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">megasas_pci_table</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">megasas_mgmt_majorno</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">megasas_mgmt_info</span> <span class="n">megasas_mgmt_info</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">fasync_struct</span> <span class="o">*</span><span class="n">megasas_async_queue</span><span class="p">;</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">megasas_async_queue_mutex</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">megasas_poll_wait_aen</span><span class="p">;</span>
<span class="k">static</span> <span class="n">DECLARE_WAIT_QUEUE_HEAD</span><span class="p">(</span><span class="n">megasas_poll_wait</span><span class="p">);</span>
<span class="k">static</span> <span class="n">u32</span> <span class="n">support_poll_for_event</span><span class="p">;</span>
<span class="n">u32</span> <span class="n">megasas_dbg_lvl</span><span class="p">;</span>
<span class="k">static</span> <span class="n">u32</span> <span class="n">support_device_change</span><span class="p">;</span>

<span class="cm">/* define lock for aen poll */</span>
<span class="n">spinlock_t</span> <span class="n">poll_aen_lock</span><span class="p">;</span>

<span class="kt">void</span>
<span class="n">megasas_complete_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span> <span class="k">struct</span> <span class="n">megasas_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span>
		     <span class="n">u8</span> <span class="n">alt_status</span><span class="p">);</span>
<span class="k">static</span> <span class="n">u32</span>
<span class="n">megasas_read_fw_status_reg_gen2</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_register_set</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">regs</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="n">megasas_adp_reset_gen2</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">megasas_register_set</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">reg_set</span><span class="p">);</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="n">megasas_isr</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">devp</span><span class="p">);</span>
<span class="k">static</span> <span class="n">u32</span>
<span class="n">megasas_init_adapter_mfi</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">);</span>
<span class="n">u32</span>
<span class="n">megasas_build_and_issue_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">scmd</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">megasas_complete_cmd_dpc</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">instance_addr</span><span class="p">);</span>
<span class="kt">void</span>
<span class="n">megasas_release_fusion</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">);</span>
<span class="kt">int</span>
<span class="n">megasas_ioc_init_fusion</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">);</span>
<span class="kt">void</span>
<span class="n">megasas_free_cmds_fusion</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">);</span>
<span class="n">u8</span>
<span class="n">megasas_get_map_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">);</span>
<span class="kt">int</span>
<span class="n">megasas_sync_map_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">);</span>
<span class="kt">int</span>
<span class="n">wait_and_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span> <span class="k">struct</span> <span class="n">megasas_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">megasas_reset_reply_desc</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">);</span>
<span class="n">u8</span> <span class="n">MR_ValidateMapInfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">MR_FW_RAID_MAP_ALL</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">LD_LOAD_BALANCE_INFO</span> <span class="o">*</span><span class="n">lbInfo</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">megasas_reset_fusion</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">megasas_fusion_ocr_wq</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>

<span class="kt">void</span>
<span class="nf">megasas_issue_dcmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span> <span class="k">struct</span> <span class="n">megasas_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">instancet</span><span class="o">-&gt;</span><span class="n">fire_cmd</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">frame_phys_addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">reg_set</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * megasas_get_cmd -	Get a command from the free pool</span>
<span class="cm"> * @instance:		Adapter soft state</span>
<span class="cm"> *</span>
<span class="cm"> * Returns a free command from the pool</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">megasas_cmd</span> <span class="o">*</span><span class="nf">megasas_get_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_instance</span>
						  <span class="o">*</span><span class="n">instance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">megasas_cmd</span> <span class="o">*</span><span class="n">cmd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">cmd_pool_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">cmd_pool</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cmd</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">((</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">cmd_pool</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">megasas_cmd</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;megasas: Command pool empty!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">cmd_pool_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">cmd</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * megasas_return_cmd -	Return a cmd to free command pool</span>
<span class="cm"> * @instance:		Adapter soft state</span>
<span class="cm"> * @cmd:		Command packet to be returned to free command pool</span>
<span class="cm"> */</span>
<span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">megasas_return_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span> <span class="k">struct</span> <span class="n">megasas_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">cmd_pool_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scmd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">frame_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">!=</span> <span class="n">PCI_DEVICE_ID_LSI_FUSION</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">!=</span> <span class="n">PCI_DEVICE_ID_LSI_INVADER</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">reset_devices</span><span class="p">))</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">MFI_CMD_INVALID</span><span class="p">;</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">cmd_pool</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">cmd_pool_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm">*	The following functions are defined for xscale</span>
<span class="cm">*	(deviceid : 1064R, PERC5) controllers</span>
<span class="cm">*/</span>

<span class="cm">/**</span>
<span class="cm"> * megasas_enable_intr_xscale -	Enables interrupts</span>
<span class="cm"> * @regs:			MFI register set</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">megasas_enable_intr_xscale</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_register_set</span> <span class="n">__iomem</span> <span class="o">*</span> <span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">outbound_intr_mask</span><span class="p">);</span>

	<span class="cm">/* Dummy readl to force pci flush */</span>
	<span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">outbound_intr_mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * megasas_disable_intr_xscale -Disables interrupt</span>
<span class="cm"> * @regs:			MFI register set</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">megasas_disable_intr_xscale</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_register_set</span> <span class="n">__iomem</span> <span class="o">*</span> <span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">mask</span> <span class="o">=</span> <span class="mh">0x1f</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">outbound_intr_mask</span><span class="p">);</span>
	<span class="cm">/* Dummy readl to force pci flush */</span>
	<span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">outbound_intr_mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * megasas_read_fw_status_reg_xscale - returns the current FW status value</span>
<span class="cm"> * @regs:			MFI register set</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u32</span>
<span class="nf">megasas_read_fw_status_reg_xscale</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_register_set</span> <span class="n">__iomem</span> <span class="o">*</span> <span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">outbound_msg_0</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/**</span>
<span class="cm"> * megasas_clear_interrupt_xscale -	Check &amp; clear interrupt</span>
<span class="cm"> * @regs:				MFI register set</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">megasas_clear_intr_xscale</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_register_set</span> <span class="n">__iomem</span> <span class="o">*</span> <span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mfiStatus</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Check if it is our interrupt</span>
<span class="cm">	 */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">outbound_intr_status</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">MFI_OB_INTR_STATUS_MASK</span><span class="p">)</span>
		<span class="n">mfiStatus</span> <span class="o">=</span> <span class="n">MFI_INTR_FLAG_REPLY_MESSAGE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">MFI_XSCALE_OMR0_CHANGE_INTERRUPT</span><span class="p">)</span>
		<span class="n">mfiStatus</span> <span class="o">|=</span> <span class="n">MFI_INTR_FLAG_FIRMWARE_STATE_CHANGE</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Clear the interrupt by writing back the same value</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mfiStatus</span><span class="p">)</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">outbound_intr_status</span><span class="p">);</span>

	<span class="cm">/* Dummy readl to force pci flush */</span>
	<span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">outbound_intr_status</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">mfiStatus</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * megasas_fire_cmd_xscale -	Sends command to the FW</span>
<span class="cm"> * @frame_phys_addr :		Physical address of cmd</span>
<span class="cm"> * @frame_count :		Number of frames for the command</span>
<span class="cm"> * @regs :			MFI register set</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">megasas_fire_cmd_xscale</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span>
		<span class="n">dma_addr_t</span> <span class="n">frame_phys_addr</span><span class="p">,</span>
		<span class="n">u32</span> <span class="n">frame_count</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">megasas_register_set</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">hba_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">((</span><span class="n">frame_phys_addr</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="n">frame_count</span><span class="p">),</span>
	       <span class="o">&amp;</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">inbound_queue_port</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">hba_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * megasas_adp_reset_xscale -  For controller reset</span>
<span class="cm"> * @regs:                              MFI register set</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">megasas_adp_reset_xscale</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">megasas_register_set</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pcidata</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">MFI_ADP_RESET</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">inbound_doorbell</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span> <span class="cm">/* sleep for 3 secs */</span>
	<span class="n">pcidata</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">MFI_1068_PCSR_OFFSET</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pcidata</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;pcidata = %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pcidata</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pcidata</span> <span class="o">&amp;</span> <span class="mh">0x2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;mfi 1068 offset read=%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pcidata</span><span class="p">);</span>
		<span class="n">pcidata</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mh">0x2</span><span class="p">;</span>
		<span class="n">pci_write_config_dword</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
				<span class="n">MFI_1068_PCSR_OFFSET</span><span class="p">,</span> <span class="n">pcidata</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">msleep</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span> <span class="cm">/* need to wait 2 secs again */</span>

		<span class="n">pcidata</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
				<span class="n">MFI_1068_FW_HANDSHAKE_OFFSET</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pcidata</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;1068 offset handshake read=%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pcidata</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">pcidata</span> <span class="o">&amp;</span> <span class="mh">0xffff0000</span><span class="p">)</span> <span class="o">==</span> <span class="n">MFI_1068_FW_READY</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;1068 offset pcidt=%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pcidata</span><span class="p">);</span>
			<span class="n">pcidata</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">pci_write_config_dword</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
				<span class="n">MFI_1068_FW_HANDSHAKE_OFFSET</span><span class="p">,</span> <span class="n">pcidata</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * megasas_check_reset_xscale -	For controller reset check</span>
<span class="cm"> * @regs:				MFI register set</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">megasas_check_reset_xscale</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">megasas_register_set</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">consumer</span><span class="p">;</span>
	<span class="n">consumer</span> <span class="o">=</span> <span class="o">*</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">consumer</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">adprecovery</span> <span class="o">!=</span> <span class="n">MEGASAS_HBA_OPERATIONAL</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="o">*</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">consumer</span> <span class="o">==</span> <span class="n">MEGASAS_ADPRESET_INPROG_SIGN</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">megasas_instance_template</span> <span class="n">megasas_instance_template_xscale</span> <span class="o">=</span> <span class="p">{</span>

	<span class="p">.</span><span class="n">fire_cmd</span> <span class="o">=</span> <span class="n">megasas_fire_cmd_xscale</span><span class="p">,</span>
	<span class="p">.</span><span class="n">enable_intr</span> <span class="o">=</span> <span class="n">megasas_enable_intr_xscale</span><span class="p">,</span>
	<span class="p">.</span><span class="n">disable_intr</span> <span class="o">=</span> <span class="n">megasas_disable_intr_xscale</span><span class="p">,</span>
	<span class="p">.</span><span class="n">clear_intr</span> <span class="o">=</span> <span class="n">megasas_clear_intr_xscale</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read_fw_status_reg</span> <span class="o">=</span> <span class="n">megasas_read_fw_status_reg_xscale</span><span class="p">,</span>
	<span class="p">.</span><span class="n">adp_reset</span> <span class="o">=</span> <span class="n">megasas_adp_reset_xscale</span><span class="p">,</span>
	<span class="p">.</span><span class="n">check_reset</span> <span class="o">=</span> <span class="n">megasas_check_reset_xscale</span><span class="p">,</span>
	<span class="p">.</span><span class="n">service_isr</span> <span class="o">=</span> <span class="n">megasas_isr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">tasklet</span> <span class="o">=</span> <span class="n">megasas_complete_cmd_dpc</span><span class="p">,</span>
	<span class="p">.</span><span class="n">init_adapter</span> <span class="o">=</span> <span class="n">megasas_init_adapter_mfi</span><span class="p">,</span>
	<span class="p">.</span><span class="n">build_and_issue_cmd</span> <span class="o">=</span> <span class="n">megasas_build_and_issue_cmd</span><span class="p">,</span>
	<span class="p">.</span><span class="n">issue_dcmd</span> <span class="o">=</span> <span class="n">megasas_issue_dcmd</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm">*	This is the end of set of functions &amp; definitions specific</span>
<span class="cm">*	to xscale (deviceid : 1064R, PERC5) controllers</span>
<span class="cm">*/</span>

<span class="cm">/**</span>
<span class="cm">*	The following functions are defined for ppc (deviceid : 0x60)</span>
<span class="cm">* 	controllers</span>
<span class="cm">*/</span>

<span class="cm">/**</span>
<span class="cm"> * megasas_enable_intr_ppc -	Enables interrupts</span>
<span class="cm"> * @regs:			MFI register set</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">megasas_enable_intr_ppc</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_register_set</span> <span class="n">__iomem</span> <span class="o">*</span> <span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writel</span><span class="p">(</span><span class="mh">0xFFFFFFFF</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">outbound_doorbell_clear</span><span class="p">);</span>

	<span class="n">writel</span><span class="p">(</span><span class="o">~</span><span class="mh">0x80000000</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">outbound_intr_mask</span><span class="p">);</span>

	<span class="cm">/* Dummy readl to force pci flush */</span>
	<span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">outbound_intr_mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * megasas_disable_intr_ppc -	Disable interrupt</span>
<span class="cm"> * @regs:			MFI register set</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">megasas_disable_intr_ppc</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_register_set</span> <span class="n">__iomem</span> <span class="o">*</span> <span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">mask</span> <span class="o">=</span> <span class="mh">0xFFFFFFFF</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">outbound_intr_mask</span><span class="p">);</span>
	<span class="cm">/* Dummy readl to force pci flush */</span>
	<span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">outbound_intr_mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * megasas_read_fw_status_reg_ppc - returns the current FW status value</span>
<span class="cm"> * @regs:			MFI register set</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u32</span>
<span class="nf">megasas_read_fw_status_reg_ppc</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_register_set</span> <span class="n">__iomem</span> <span class="o">*</span> <span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">outbound_scratch_pad</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * megasas_clear_interrupt_ppc -	Check &amp; clear interrupt</span>
<span class="cm"> * @regs:				MFI register set</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">megasas_clear_intr_ppc</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_register_set</span> <span class="n">__iomem</span> <span class="o">*</span> <span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">status</span><span class="p">,</span> <span class="n">mfiStatus</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check if it is our interrupt</span>
<span class="cm">	 */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">outbound_intr_status</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">MFI_REPLY_1078_MESSAGE_INTERRUPT</span><span class="p">)</span>
		<span class="n">mfiStatus</span> <span class="o">=</span> <span class="n">MFI_INTR_FLAG_REPLY_MESSAGE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">MFI_G2_OUTBOUND_DOORBELL_CHANGE_INTERRUPT</span><span class="p">)</span>
		<span class="n">mfiStatus</span> <span class="o">|=</span> <span class="n">MFI_INTR_FLAG_FIRMWARE_STATE_CHANGE</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Clear the interrupt by writing back the same value</span>
<span class="cm">	 */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">outbound_doorbell_clear</span><span class="p">);</span>

	<span class="cm">/* Dummy readl to force pci flush */</span>
	<span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">outbound_doorbell_clear</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">mfiStatus</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * megasas_fire_cmd_ppc -	Sends command to the FW</span>
<span class="cm"> * @frame_phys_addr :		Physical address of cmd</span>
<span class="cm"> * @frame_count :		Number of frames for the command</span>
<span class="cm"> * @regs :			MFI register set</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">megasas_fire_cmd_ppc</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span>
		<span class="n">dma_addr_t</span> <span class="n">frame_phys_addr</span><span class="p">,</span>
		<span class="n">u32</span> <span class="n">frame_count</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">megasas_register_set</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">hba_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">((</span><span class="n">frame_phys_addr</span> <span class="o">|</span> <span class="p">(</span><span class="n">frame_count</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">))</span><span class="o">|</span><span class="mi">1</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">inbound_queue_port</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">hba_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * megasas_check_reset_ppc -	For controller reset check</span>
<span class="cm"> * @regs:				MFI register set</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">megasas_check_reset_ppc</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">megasas_register_set</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">adprecovery</span> <span class="o">!=</span> <span class="n">MEGASAS_HBA_OPERATIONAL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">megasas_instance_template</span> <span class="n">megasas_instance_template_ppc</span> <span class="o">=</span> <span class="p">{</span>

	<span class="p">.</span><span class="n">fire_cmd</span> <span class="o">=</span> <span class="n">megasas_fire_cmd_ppc</span><span class="p">,</span>
	<span class="p">.</span><span class="n">enable_intr</span> <span class="o">=</span> <span class="n">megasas_enable_intr_ppc</span><span class="p">,</span>
	<span class="p">.</span><span class="n">disable_intr</span> <span class="o">=</span> <span class="n">megasas_disable_intr_ppc</span><span class="p">,</span>
	<span class="p">.</span><span class="n">clear_intr</span> <span class="o">=</span> <span class="n">megasas_clear_intr_ppc</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read_fw_status_reg</span> <span class="o">=</span> <span class="n">megasas_read_fw_status_reg_ppc</span><span class="p">,</span>
	<span class="p">.</span><span class="n">adp_reset</span> <span class="o">=</span> <span class="n">megasas_adp_reset_xscale</span><span class="p">,</span>
	<span class="p">.</span><span class="n">check_reset</span> <span class="o">=</span> <span class="n">megasas_check_reset_ppc</span><span class="p">,</span>
	<span class="p">.</span><span class="n">service_isr</span> <span class="o">=</span> <span class="n">megasas_isr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">tasklet</span> <span class="o">=</span> <span class="n">megasas_complete_cmd_dpc</span><span class="p">,</span>
	<span class="p">.</span><span class="n">init_adapter</span> <span class="o">=</span> <span class="n">megasas_init_adapter_mfi</span><span class="p">,</span>
	<span class="p">.</span><span class="n">build_and_issue_cmd</span> <span class="o">=</span> <span class="n">megasas_build_and_issue_cmd</span><span class="p">,</span>
	<span class="p">.</span><span class="n">issue_dcmd</span> <span class="o">=</span> <span class="n">megasas_issue_dcmd</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * megasas_enable_intr_skinny -	Enables interrupts</span>
<span class="cm"> * @regs:			MFI register set</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">megasas_enable_intr_skinny</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_register_set</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writel</span><span class="p">(</span><span class="mh">0xFFFFFFFF</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">outbound_intr_mask</span><span class="p">);</span>

	<span class="n">writel</span><span class="p">(</span><span class="o">~</span><span class="n">MFI_SKINNY_ENABLE_INTERRUPT_MASK</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">outbound_intr_mask</span><span class="p">);</span>

	<span class="cm">/* Dummy readl to force pci flush */</span>
	<span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">outbound_intr_mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * megasas_disable_intr_skinny -	Disables interrupt</span>
<span class="cm"> * @regs:			MFI register set</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">megasas_disable_intr_skinny</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_register_set</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">mask</span> <span class="o">=</span> <span class="mh">0xFFFFFFFF</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">outbound_intr_mask</span><span class="p">);</span>
	<span class="cm">/* Dummy readl to force pci flush */</span>
	<span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">outbound_intr_mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * megasas_read_fw_status_reg_skinny - returns the current FW status value</span>
<span class="cm"> * @regs:			MFI register set</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u32</span>
<span class="nf">megasas_read_fw_status_reg_skinny</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_register_set</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">outbound_scratch_pad</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * megasas_clear_interrupt_skinny -	Check &amp; clear interrupt</span>
<span class="cm"> * @regs:				MFI register set</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">megasas_clear_intr_skinny</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_register_set</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mfiStatus</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check if it is our interrupt</span>
<span class="cm">	 */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">outbound_intr_status</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">MFI_SKINNY_ENABLE_INTERRUPT_MASK</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check if it is our interrupt</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">megasas_read_fw_status_reg_gen2</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">MFI_STATE_MASK</span><span class="p">)</span> <span class="o">==</span>
	    <span class="n">MFI_STATE_FAULT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mfiStatus</span> <span class="o">=</span> <span class="n">MFI_INTR_FLAG_FIRMWARE_STATE_CHANGE</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">mfiStatus</span> <span class="o">=</span> <span class="n">MFI_INTR_FLAG_REPLY_MESSAGE</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Clear the interrupt by writing back the same value</span>
<span class="cm">	 */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">outbound_intr_status</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	* dummy read to flush PCI</span>
<span class="cm">	*/</span>
	<span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">outbound_intr_status</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">mfiStatus</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * megasas_fire_cmd_skinny -	Sends command to the FW</span>
<span class="cm"> * @frame_phys_addr :		Physical address of cmd</span>
<span class="cm"> * @frame_count :		Number of frames for the command</span>
<span class="cm"> * @regs :			MFI register set</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">megasas_fire_cmd_skinny</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span>
			<span class="n">dma_addr_t</span> <span class="n">frame_phys_addr</span><span class="p">,</span>
			<span class="n">u32</span> <span class="n">frame_count</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">megasas_register_set</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">hba_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">inbound_high_queue_port</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">((</span><span class="n">frame_phys_addr</span> <span class="o">|</span> <span class="p">(</span><span class="n">frame_count</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">))</span><span class="o">|</span><span class="mi">1</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">inbound_low_queue_port</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">hba_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * megasas_check_reset_skinny -	For controller reset check</span>
<span class="cm"> * @regs:				MFI register set</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">megasas_check_reset_skinny</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">megasas_register_set</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">adprecovery</span> <span class="o">!=</span> <span class="n">MEGASAS_HBA_OPERATIONAL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">megasas_instance_template</span> <span class="n">megasas_instance_template_skinny</span> <span class="o">=</span> <span class="p">{</span>

	<span class="p">.</span><span class="n">fire_cmd</span> <span class="o">=</span> <span class="n">megasas_fire_cmd_skinny</span><span class="p">,</span>
	<span class="p">.</span><span class="n">enable_intr</span> <span class="o">=</span> <span class="n">megasas_enable_intr_skinny</span><span class="p">,</span>
	<span class="p">.</span><span class="n">disable_intr</span> <span class="o">=</span> <span class="n">megasas_disable_intr_skinny</span><span class="p">,</span>
	<span class="p">.</span><span class="n">clear_intr</span> <span class="o">=</span> <span class="n">megasas_clear_intr_skinny</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read_fw_status_reg</span> <span class="o">=</span> <span class="n">megasas_read_fw_status_reg_skinny</span><span class="p">,</span>
	<span class="p">.</span><span class="n">adp_reset</span> <span class="o">=</span> <span class="n">megasas_adp_reset_gen2</span><span class="p">,</span>
	<span class="p">.</span><span class="n">check_reset</span> <span class="o">=</span> <span class="n">megasas_check_reset_skinny</span><span class="p">,</span>
	<span class="p">.</span><span class="n">service_isr</span> <span class="o">=</span> <span class="n">megasas_isr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">tasklet</span> <span class="o">=</span> <span class="n">megasas_complete_cmd_dpc</span><span class="p">,</span>
	<span class="p">.</span><span class="n">init_adapter</span> <span class="o">=</span> <span class="n">megasas_init_adapter_mfi</span><span class="p">,</span>
	<span class="p">.</span><span class="n">build_and_issue_cmd</span> <span class="o">=</span> <span class="n">megasas_build_and_issue_cmd</span><span class="p">,</span>
	<span class="p">.</span><span class="n">issue_dcmd</span> <span class="o">=</span> <span class="n">megasas_issue_dcmd</span><span class="p">,</span>
<span class="p">};</span>


<span class="cm">/**</span>
<span class="cm">*	The following functions are defined for gen2 (deviceid : 0x78 0x79)</span>
<span class="cm">*	controllers</span>
<span class="cm">*/</span>

<span class="cm">/**</span>
<span class="cm"> * megasas_enable_intr_gen2 -  Enables interrupts</span>
<span class="cm"> * @regs:                      MFI register set</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">megasas_enable_intr_gen2</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_register_set</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writel</span><span class="p">(</span><span class="mh">0xFFFFFFFF</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">outbound_doorbell_clear</span><span class="p">);</span>

	<span class="cm">/* write ~0x00000005 (4 &amp; 1) to the intr mask*/</span>
	<span class="n">writel</span><span class="p">(</span><span class="o">~</span><span class="n">MFI_GEN2_ENABLE_INTERRUPT_MASK</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">outbound_intr_mask</span><span class="p">);</span>

	<span class="cm">/* Dummy readl to force pci flush */</span>
	<span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">outbound_intr_mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * megasas_disable_intr_gen2 - Disables interrupt</span>
<span class="cm"> * @regs:                      MFI register set</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">megasas_disable_intr_gen2</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_register_set</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">mask</span> <span class="o">=</span> <span class="mh">0xFFFFFFFF</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">outbound_intr_mask</span><span class="p">);</span>
	<span class="cm">/* Dummy readl to force pci flush */</span>
	<span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">outbound_intr_mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * megasas_read_fw_status_reg_gen2 - returns the current FW status value</span>
<span class="cm"> * @regs:                      MFI register set</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u32</span>
<span class="nf">megasas_read_fw_status_reg_gen2</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_register_set</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">outbound_scratch_pad</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * megasas_clear_interrupt_gen2 -      Check &amp; clear interrupt</span>
<span class="cm"> * @regs:                              MFI register set</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">megasas_clear_intr_gen2</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_register_set</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mfiStatus</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Check if it is our interrupt</span>
<span class="cm">	 */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">outbound_intr_status</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">MFI_GEN2_ENABLE_INTERRUPT_MASK</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mfiStatus</span> <span class="o">=</span> <span class="n">MFI_INTR_FLAG_REPLY_MESSAGE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">MFI_G2_OUTBOUND_DOORBELL_CHANGE_INTERRUPT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mfiStatus</span> <span class="o">|=</span> <span class="n">MFI_INTR_FLAG_FIRMWARE_STATE_CHANGE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Clear the interrupt by writing back the same value</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mfiStatus</span><span class="p">)</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">outbound_doorbell_clear</span><span class="p">);</span>

	<span class="cm">/* Dummy readl to force pci flush */</span>
	<span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">outbound_intr_status</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">mfiStatus</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/**</span>
<span class="cm"> * megasas_fire_cmd_gen2 -     Sends command to the FW</span>
<span class="cm"> * @frame_phys_addr :          Physical address of cmd</span>
<span class="cm"> * @frame_count :              Number of frames for the command</span>
<span class="cm"> * @regs :                     MFI register set</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">megasas_fire_cmd_gen2</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span>
			<span class="n">dma_addr_t</span> <span class="n">frame_phys_addr</span><span class="p">,</span>
			<span class="n">u32</span> <span class="n">frame_count</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">megasas_register_set</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">hba_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">((</span><span class="n">frame_phys_addr</span> <span class="o">|</span> <span class="p">(</span><span class="n">frame_count</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">))</span><span class="o">|</span><span class="mi">1</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">inbound_queue_port</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">hba_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * megasas_adp_reset_gen2 -	For controller reset</span>
<span class="cm"> * @regs:				MFI register set</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">megasas_adp_reset_gen2</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">megasas_register_set</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">reg_set</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span>			<span class="n">retry</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
	<span class="n">u32</span>			<span class="n">HostDiag</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="o">*</span><span class="n">seq_offset</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">reg_set</span><span class="o">-&gt;</span><span class="n">seq_offset</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="o">*</span><span class="n">hostdiag_offset</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">reg_set</span><span class="o">-&gt;</span><span class="n">host_diag</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">instancet</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">megasas_instance_template_skinny</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">seq_offset</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">reg_set</span><span class="o">-&gt;</span><span class="n">fusion_seq_offset</span><span class="p">;</span>
		<span class="n">hostdiag_offset</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">reg_set</span><span class="o">-&gt;</span><span class="n">fusion_host_diag</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">seq_offset</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">seq_offset</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mh">0xb</span><span class="p">,</span> <span class="n">seq_offset</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">seq_offset</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="n">seq_offset</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mh">0xd</span><span class="p">,</span> <span class="n">seq_offset</span><span class="p">);</span>

	<span class="n">msleep</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>

	<span class="n">HostDiag</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">readl</span><span class="p">(</span><span class="n">hostdiag_offset</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span> <span class="o">!</span><span class="p">(</span> <span class="n">HostDiag</span> <span class="o">&amp;</span> <span class="n">DIAG_WRITE_ENABLE</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
		<span class="n">HostDiag</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">readl</span><span class="p">(</span><span class="n">hostdiag_offset</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;RESETGEN2: retry=%x, hostdiag=%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">retry</span><span class="p">,</span> <span class="n">HostDiag</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">retry</span><span class="o">++</span> <span class="o">&gt;=</span> <span class="mi">100</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="p">}</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;ADP_RESET_GEN2: HostDiag=%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">HostDiag</span><span class="p">);</span>

	<span class="n">writel</span><span class="p">((</span><span class="n">HostDiag</span> <span class="o">|</span> <span class="n">DIAG_RESET_ADAPTER</span><span class="p">),</span> <span class="n">hostdiag_offset</span><span class="p">);</span>

	<span class="n">ssleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

	<span class="n">HostDiag</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">readl</span><span class="p">(</span><span class="n">hostdiag_offset</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span> <span class="p">(</span> <span class="n">HostDiag</span> <span class="o">&amp;</span> <span class="n">DIAG_RESET_ADAPTER</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
		<span class="n">HostDiag</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">readl</span><span class="p">(</span><span class="n">hostdiag_offset</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;RESET_GEN2: retry=%x, hostdiag=%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">retry</span><span class="p">,</span> <span class="n">HostDiag</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">retry</span><span class="o">++</span> <span class="o">&gt;=</span> <span class="mi">1000</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * megasas_check_reset_gen2 -	For controller reset check</span>
<span class="cm"> * @regs:				MFI register set</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">megasas_check_reset_gen2</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">megasas_register_set</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">adprecovery</span> <span class="o">!=</span> <span class="n">MEGASAS_HBA_OPERATIONAL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">megasas_instance_template</span> <span class="n">megasas_instance_template_gen2</span> <span class="o">=</span> <span class="p">{</span>

	<span class="p">.</span><span class="n">fire_cmd</span> <span class="o">=</span> <span class="n">megasas_fire_cmd_gen2</span><span class="p">,</span>
	<span class="p">.</span><span class="n">enable_intr</span> <span class="o">=</span> <span class="n">megasas_enable_intr_gen2</span><span class="p">,</span>
	<span class="p">.</span><span class="n">disable_intr</span> <span class="o">=</span> <span class="n">megasas_disable_intr_gen2</span><span class="p">,</span>
	<span class="p">.</span><span class="n">clear_intr</span> <span class="o">=</span> <span class="n">megasas_clear_intr_gen2</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read_fw_status_reg</span> <span class="o">=</span> <span class="n">megasas_read_fw_status_reg_gen2</span><span class="p">,</span>
	<span class="p">.</span><span class="n">adp_reset</span> <span class="o">=</span> <span class="n">megasas_adp_reset_gen2</span><span class="p">,</span>
	<span class="p">.</span><span class="n">check_reset</span> <span class="o">=</span> <span class="n">megasas_check_reset_gen2</span><span class="p">,</span>
	<span class="p">.</span><span class="n">service_isr</span> <span class="o">=</span> <span class="n">megasas_isr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">tasklet</span> <span class="o">=</span> <span class="n">megasas_complete_cmd_dpc</span><span class="p">,</span>
	<span class="p">.</span><span class="n">init_adapter</span> <span class="o">=</span> <span class="n">megasas_init_adapter_mfi</span><span class="p">,</span>
	<span class="p">.</span><span class="n">build_and_issue_cmd</span> <span class="o">=</span> <span class="n">megasas_build_and_issue_cmd</span><span class="p">,</span>
	<span class="p">.</span><span class="n">issue_dcmd</span> <span class="o">=</span> <span class="n">megasas_issue_dcmd</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm">*	This is the end of set of functions &amp; definitions</span>
<span class="cm">*       specific to gen2 (deviceid : 0x78, 0x79) controllers</span>
<span class="cm">*/</span>

<span class="cm">/*</span>
<span class="cm"> * Template added for TB (Fusion)</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">megasas_instance_template</span> <span class="n">megasas_instance_template_fusion</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * megasas_issue_polled -	Issues a polling command</span>
<span class="cm"> * @instance:			Adapter soft state</span>
<span class="cm"> * @cmd:			Command packet to be issued</span>
<span class="cm"> *</span>
<span class="cm"> * For polling, MFI requires the cmd_status to be set to 0xFF before posting.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">megasas_issue_polled</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span> <span class="k">struct</span> <span class="n">megasas_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>

	<span class="k">struct</span> <span class="n">megasas_header</span> <span class="o">*</span><span class="n">frame_hdr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">;</span>

	<span class="n">frame_hdr</span><span class="o">-&gt;</span><span class="n">cmd_status</span> <span class="o">=</span> <span class="mh">0xFF</span><span class="p">;</span>
	<span class="n">frame_hdr</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">MFI_FRAME_DONT_POST_IN_REPLY_QUEUE</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Issue the frame using inbound queue port</span>
<span class="cm">	 */</span>
	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">instancet</span><span class="o">-&gt;</span><span class="n">issue_dcmd</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Wait for cmd_status to change</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">wait_and_poll</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * megasas_issue_blocked_cmd -	Synchronous wrapper around regular FW cmds</span>
<span class="cm"> * @instance:			Adapter soft state</span>
<span class="cm"> * @cmd:			Command to be issued</span>
<span class="cm"> *</span>
<span class="cm"> * This function waits on an event for the command to be returned from ISR.</span>
<span class="cm"> * Max wait time is MEGASAS_INTERNAL_CMD_WAIT_TIME secs</span>
<span class="cm"> * Used to issue ioctl commands.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">megasas_issue_blocked_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">megasas_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmd_status</span> <span class="o">=</span> <span class="n">ENODATA</span><span class="p">;</span>

	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">instancet</span><span class="o">-&gt;</span><span class="n">issue_dcmd</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>

	<span class="n">wait_event</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">int_cmd_wait_q</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmd_status</span> <span class="o">!=</span> <span class="n">ENODATA</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * megasas_issue_blocked_abort_cmd -	Aborts previously issued cmd</span>
<span class="cm"> * @instance:				Adapter soft state</span>
<span class="cm"> * @cmd_to_abort:			Previously issued cmd to be aborted</span>
<span class="cm"> *</span>
<span class="cm"> * MFI firmware can abort previously issued AEN command (automatic event</span>
<span class="cm"> * notification). The megasas_issue_blocked_abort_cmd() issues such abort</span>
<span class="cm"> * cmd and waits for return status.</span>
<span class="cm"> * Max wait time is MEGASAS_INTERNAL_CMD_WAIT_TIME secs</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">megasas_issue_blocked_abort_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">megasas_cmd</span> <span class="o">*</span><span class="n">cmd_to_abort</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">megasas_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">megasas_abort_frame</span> <span class="o">*</span><span class="n">abort_fr</span><span class="p">;</span>

	<span class="n">cmd</span> <span class="o">=</span> <span class="n">megasas_get_cmd</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cmd</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">abort_fr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">abort</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Prepare and issue the abort frame</span>
<span class="cm">	 */</span>
	<span class="n">abort_fr</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">MFI_CMD_ABORT</span><span class="p">;</span>
	<span class="n">abort_fr</span><span class="o">-&gt;</span><span class="n">cmd_status</span> <span class="o">=</span> <span class="mh">0xFF</span><span class="p">;</span>
	<span class="n">abort_fr</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">abort_fr</span><span class="o">-&gt;</span><span class="n">abort_context</span> <span class="o">=</span> <span class="n">cmd_to_abort</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>
	<span class="n">abort_fr</span><span class="o">-&gt;</span><span class="n">abort_mfi_phys_addr_lo</span> <span class="o">=</span> <span class="n">cmd_to_abort</span><span class="o">-&gt;</span><span class="n">frame_phys_addr</span><span class="p">;</span>
	<span class="n">abort_fr</span><span class="o">-&gt;</span><span class="n">abort_mfi_phys_addr_hi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sync_cmd</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmd_status</span> <span class="o">=</span> <span class="mh">0xFF</span><span class="p">;</span>

	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">instancet</span><span class="o">-&gt;</span><span class="n">issue_dcmd</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Wait for this cmd to complete</span>
<span class="cm">	 */</span>
	<span class="n">wait_event</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">abort_cmd_wait_q</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmd_status</span> <span class="o">!=</span> <span class="mh">0xFF</span><span class="p">);</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sync_cmd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">megasas_return_cmd</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * megasas_make_sgl32 -	Prepares 32-bit SGL</span>
<span class="cm"> * @instance:		Adapter soft state</span>
<span class="cm"> * @scp:		SCSI command from the mid-layer</span>
<span class="cm"> * @mfi_sgl:		SGL to be filled in</span>
<span class="cm"> *</span>
<span class="cm"> * If successful, this function returns the number of SG elements. Otherwise,</span>
<span class="cm"> * it returnes -1.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">megasas_make_sgl32</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">scp</span><span class="p">,</span>
		   <span class="k">union</span> <span class="n">megasas_sgl</span> <span class="o">*</span><span class="n">mfi_sgl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sge_count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">os_sgl</span><span class="p">;</span>

	<span class="n">sge_count</span> <span class="o">=</span> <span class="n">scsi_dma_map</span><span class="p">(</span><span class="n">scp</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">sge_count</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sge_count</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">scsi_for_each_sg</span><span class="p">(</span><span class="n">scp</span><span class="p">,</span> <span class="n">os_sgl</span><span class="p">,</span> <span class="n">sge_count</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mfi_sgl</span><span class="o">-&gt;</span><span class="n">sge32</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">length</span> <span class="o">=</span> <span class="n">sg_dma_len</span><span class="p">(</span><span class="n">os_sgl</span><span class="p">);</span>
			<span class="n">mfi_sgl</span><span class="o">-&gt;</span><span class="n">sge32</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">phys_addr</span> <span class="o">=</span> <span class="n">sg_dma_address</span><span class="p">(</span><span class="n">os_sgl</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">sge_count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * megasas_make_sgl64 -	Prepares 64-bit SGL</span>
<span class="cm"> * @instance:		Adapter soft state</span>
<span class="cm"> * @scp:		SCSI command from the mid-layer</span>
<span class="cm"> * @mfi_sgl:		SGL to be filled in</span>
<span class="cm"> *</span>
<span class="cm"> * If successful, this function returns the number of SG elements. Otherwise,</span>
<span class="cm"> * it returnes -1.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">megasas_make_sgl64</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">scp</span><span class="p">,</span>
		   <span class="k">union</span> <span class="n">megasas_sgl</span> <span class="o">*</span><span class="n">mfi_sgl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sge_count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">os_sgl</span><span class="p">;</span>

	<span class="n">sge_count</span> <span class="o">=</span> <span class="n">scsi_dma_map</span><span class="p">(</span><span class="n">scp</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">sge_count</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sge_count</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">scsi_for_each_sg</span><span class="p">(</span><span class="n">scp</span><span class="p">,</span> <span class="n">os_sgl</span><span class="p">,</span> <span class="n">sge_count</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mfi_sgl</span><span class="o">-&gt;</span><span class="n">sge64</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">length</span> <span class="o">=</span> <span class="n">sg_dma_len</span><span class="p">(</span><span class="n">os_sgl</span><span class="p">);</span>
			<span class="n">mfi_sgl</span><span class="o">-&gt;</span><span class="n">sge64</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">phys_addr</span> <span class="o">=</span> <span class="n">sg_dma_address</span><span class="p">(</span><span class="n">os_sgl</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">sge_count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * megasas_make_sgl_skinny - Prepares IEEE SGL</span>
<span class="cm"> * @instance:           Adapter soft state</span>
<span class="cm"> * @scp:                SCSI command from the mid-layer</span>
<span class="cm"> * @mfi_sgl:            SGL to be filled in</span>
<span class="cm"> *</span>
<span class="cm"> * If successful, this function returns the number of SG elements. Otherwise,</span>
<span class="cm"> * it returnes -1.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">megasas_make_sgl_skinny</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">scp</span><span class="p">,</span> <span class="k">union</span> <span class="n">megasas_sgl</span> <span class="o">*</span><span class="n">mfi_sgl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sge_count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">os_sgl</span><span class="p">;</span>

	<span class="n">sge_count</span> <span class="o">=</span> <span class="n">scsi_dma_map</span><span class="p">(</span><span class="n">scp</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sge_count</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">scsi_for_each_sg</span><span class="p">(</span><span class="n">scp</span><span class="p">,</span> <span class="n">os_sgl</span><span class="p">,</span> <span class="n">sge_count</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mfi_sgl</span><span class="o">-&gt;</span><span class="n">sge_skinny</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">length</span> <span class="o">=</span> <span class="n">sg_dma_len</span><span class="p">(</span><span class="n">os_sgl</span><span class="p">);</span>
			<span class="n">mfi_sgl</span><span class="o">-&gt;</span><span class="n">sge_skinny</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">phys_addr</span> <span class="o">=</span>
						<span class="n">sg_dma_address</span><span class="p">(</span><span class="n">os_sgl</span><span class="p">);</span>
			<span class="n">mfi_sgl</span><span class="o">-&gt;</span><span class="n">sge_skinny</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">sge_count</span><span class="p">;</span>
<span class="p">}</span>

 <span class="cm">/**</span>
<span class="cm"> * megasas_get_frame_count - Computes the number of frames</span>
<span class="cm"> * @frame_type		: type of frame- io or pthru frame</span>
<span class="cm"> * @sge_count		: number of sg elements</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the number of frames required for numnber of sge&#39;s (sge_count)</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">megasas_get_frame_count</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span>
			<span class="n">u8</span> <span class="n">sge_count</span><span class="p">,</span> <span class="n">u8</span> <span class="n">frame_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">num_cnt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sge_bytes</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sge_sz</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">frame_count</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>

	<span class="n">sge_sz</span> <span class="o">=</span> <span class="p">(</span><span class="n">IS_DMA64</span><span class="p">)</span> <span class="o">?</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_sge64</span><span class="p">)</span> <span class="o">:</span>
	    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_sge32</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">flag_ieee</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sge_sz</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_sge_skinny</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Main frame can contain 2 SGEs for 64-bit SGLs and</span>
<span class="cm">	 * 3 SGEs for 32-bit SGLs for ldio &amp;</span>
<span class="cm">	 * 1 SGEs for 64-bit SGLs and</span>
<span class="cm">	 * 2 SGEs for 32-bit SGLs for pthru frame</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">frame_type</span> <span class="o">==</span> <span class="n">PTHRU_FRAME</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">flag_ieee</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">num_cnt</span> <span class="o">=</span> <span class="n">sge_count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">IS_DMA64</span><span class="p">)</span>
			<span class="n">num_cnt</span> <span class="o">=</span> <span class="n">sge_count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">num_cnt</span> <span class="o">=</span> <span class="n">sge_count</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">flag_ieee</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">num_cnt</span> <span class="o">=</span> <span class="n">sge_count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">IS_DMA64</span><span class="p">)</span>
			<span class="n">num_cnt</span> <span class="o">=</span> <span class="n">sge_count</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">num_cnt</span> <span class="o">=</span> <span class="n">sge_count</span> <span class="o">-</span> <span class="mi">3</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span><span class="p">(</span><span class="n">num_cnt</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">){</span>
		<span class="n">sge_bytes</span> <span class="o">=</span> <span class="n">sge_sz</span> <span class="o">*</span> <span class="n">num_cnt</span><span class="p">;</span>

		<span class="n">frame_count</span> <span class="o">=</span> <span class="p">(</span><span class="n">sge_bytes</span> <span class="o">/</span> <span class="n">MEGAMFI_FRAME_SIZE</span><span class="p">)</span> <span class="o">+</span>
		    <span class="p">((</span><span class="n">sge_bytes</span> <span class="o">%</span> <span class="n">MEGAMFI_FRAME_SIZE</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">)</span> <span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Main frame */</span>
	<span class="n">frame_count</span> <span class="o">+=</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">frame_count</span> <span class="o">&gt;</span> <span class="mi">7</span><span class="p">)</span>
		<span class="n">frame_count</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">frame_count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * megasas_build_dcdb -	Prepares a direct cdb (DCDB) command</span>
<span class="cm"> * @instance:		Adapter soft state</span>
<span class="cm"> * @scp:		SCSI command</span>
<span class="cm"> * @cmd:		Command to be prepared in</span>
<span class="cm"> *</span>
<span class="cm"> * This function prepares CDB commands. These are typcially pass-through</span>
<span class="cm"> * commands to the devices.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">megasas_build_dcdb</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">scp</span><span class="p">,</span>
		   <span class="k">struct</span> <span class="n">megasas_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">is_logical</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">device_id</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">megasas_pthru_frame</span> <span class="o">*</span><span class="n">pthru</span><span class="p">;</span>

	<span class="n">is_logical</span> <span class="o">=</span> <span class="n">MEGASAS_IS_LOGICAL</span><span class="p">(</span><span class="n">scp</span><span class="p">);</span>
	<span class="n">device_id</span> <span class="o">=</span> <span class="n">MEGASAS_DEV_INDEX</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">scp</span><span class="p">);</span>
	<span class="n">pthru</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">megasas_pthru_frame</span> <span class="o">*</span><span class="p">)</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">frame</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">scp</span><span class="o">-&gt;</span><span class="n">sc_data_direction</span> <span class="o">==</span> <span class="n">PCI_DMA_TODEVICE</span><span class="p">)</span>
		<span class="n">flags</span> <span class="o">=</span> <span class="n">MFI_FRAME_DIR_WRITE</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">scp</span><span class="o">-&gt;</span><span class="n">sc_data_direction</span> <span class="o">==</span> <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">)</span>
		<span class="n">flags</span> <span class="o">=</span> <span class="n">MFI_FRAME_DIR_READ</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">scp</span><span class="o">-&gt;</span><span class="n">sc_data_direction</span> <span class="o">==</span> <span class="n">PCI_DMA_NONE</span><span class="p">)</span>
		<span class="n">flags</span> <span class="o">=</span> <span class="n">MFI_FRAME_DIR_NONE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">flag_ieee</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">MFI_FRAME_IEEE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Prepare the DCDB frame</span>
<span class="cm">	 */</span>
	<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">=</span> <span class="p">(</span><span class="n">is_logical</span><span class="p">)</span> <span class="o">?</span> <span class="n">MFI_CMD_LD_SCSI_IO</span> <span class="o">:</span> <span class="n">MFI_CMD_PD_SCSI_IO</span><span class="p">;</span>
	<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">cmd_status</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>
	<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">scsi_status</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>
	<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">target_id</span> <span class="o">=</span> <span class="n">device_id</span><span class="p">;</span>
	<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">lun</span> <span class="o">=</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">;</span>
	<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">cdb_len</span> <span class="o">=</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmd_len</span><span class="p">;</span>
	<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">pad_0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">data_xfer_len</span> <span class="o">=</span> <span class="n">scsi_bufflen</span><span class="p">(</span><span class="n">scp</span><span class="p">);</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">pthru</span><span class="o">-&gt;</span><span class="n">cdb</span><span class="p">,</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">,</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmd_len</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	* If the command is for the tape device, set the</span>
<span class="cm">	* pthru timeout to the os layer timeout value.</span>
<span class="cm">	*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">scp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">TYPE_TAPE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">scp</span><span class="o">-&gt;</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">/</span> <span class="n">HZ</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mh">0xFFFF</span><span class="p">)</span>
			<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">=</span> <span class="mh">0xFFFF</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">=</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">/</span> <span class="n">HZ</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Construct SGL</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">flag_ieee</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">MFI_FRAME_SGL64</span><span class="p">;</span>
		<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">sge_count</span> <span class="o">=</span> <span class="n">megasas_make_sgl_skinny</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">scp</span><span class="p">,</span>
						      <span class="o">&amp;</span><span class="n">pthru</span><span class="o">-&gt;</span><span class="n">sgl</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">IS_DMA64</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">MFI_FRAME_SGL64</span><span class="p">;</span>
		<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">sge_count</span> <span class="o">=</span> <span class="n">megasas_make_sgl64</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">scp</span><span class="p">,</span>
						      <span class="o">&amp;</span><span class="n">pthru</span><span class="o">-&gt;</span><span class="n">sgl</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">sge_count</span> <span class="o">=</span> <span class="n">megasas_make_sgl32</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">scp</span><span class="p">,</span>
						      <span class="o">&amp;</span><span class="n">pthru</span><span class="o">-&gt;</span><span class="n">sgl</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pthru</span><span class="o">-&gt;</span><span class="n">sge_count</span> <span class="o">&gt;</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">max_num_sge</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;megasas: DCDB two many SGE NUM=%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">sge_count</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Sense info specific</span>
<span class="cm">	 */</span>
	<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">sense_len</span> <span class="o">=</span> <span class="n">SCSI_SENSE_BUFFERSIZE</span><span class="p">;</span>
	<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">sense_buf_phys_addr_hi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">sense_buf_phys_addr_lo</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sense_phys_addr</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Compute the total number of frames this command consumes. FW uses</span>
<span class="cm">	 * this number to pull sufficient number of frames from host memory.</span>
<span class="cm">	 */</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">frame_count</span> <span class="o">=</span> <span class="n">megasas_get_frame_count</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">pthru</span><span class="o">-&gt;</span><span class="n">sge_count</span><span class="p">,</span>
							<span class="n">PTHRU_FRAME</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">frame_count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * megasas_build_ldio -	Prepares IOs to logical devices</span>
<span class="cm"> * @instance:		Adapter soft state</span>
<span class="cm"> * @scp:		SCSI command</span>
<span class="cm"> * @cmd:		Command to be prepared</span>
<span class="cm"> *</span>
<span class="cm"> * Frames (and accompanying SGLs) for regular SCSI IOs use this function.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">megasas_build_ldio</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">scp</span><span class="p">,</span>
		   <span class="k">struct</span> <span class="n">megasas_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">device_id</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">sc</span> <span class="o">=</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">u16</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">megasas_io_frame</span> <span class="o">*</span><span class="n">ldio</span><span class="p">;</span>

	<span class="n">device_id</span> <span class="o">=</span> <span class="n">MEGASAS_DEV_INDEX</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">scp</span><span class="p">);</span>
	<span class="n">ldio</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">megasas_io_frame</span> <span class="o">*</span><span class="p">)</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">frame</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">scp</span><span class="o">-&gt;</span><span class="n">sc_data_direction</span> <span class="o">==</span> <span class="n">PCI_DMA_TODEVICE</span><span class="p">)</span>
		<span class="n">flags</span> <span class="o">=</span> <span class="n">MFI_FRAME_DIR_WRITE</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">scp</span><span class="o">-&gt;</span><span class="n">sc_data_direction</span> <span class="o">==</span> <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">)</span>
		<span class="n">flags</span> <span class="o">=</span> <span class="n">MFI_FRAME_DIR_READ</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">flag_ieee</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">MFI_FRAME_IEEE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Prepare the Logical IO frame: 2nd bit is zero for all read cmds</span>
<span class="cm">	 */</span>
	<span class="n">ldio</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">=</span> <span class="p">(</span><span class="n">sc</span> <span class="o">&amp;</span> <span class="mh">0x02</span><span class="p">)</span> <span class="o">?</span> <span class="n">MFI_CMD_LD_WRITE</span> <span class="o">:</span> <span class="n">MFI_CMD_LD_READ</span><span class="p">;</span>
	<span class="n">ldio</span><span class="o">-&gt;</span><span class="n">cmd_status</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>
	<span class="n">ldio</span><span class="o">-&gt;</span><span class="n">scsi_status</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>
	<span class="n">ldio</span><span class="o">-&gt;</span><span class="n">target_id</span> <span class="o">=</span> <span class="n">device_id</span><span class="p">;</span>
	<span class="n">ldio</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ldio</span><span class="o">-&gt;</span><span class="n">reserved_0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ldio</span><span class="o">-&gt;</span><span class="n">pad_0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ldio</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">ldio</span><span class="o">-&gt;</span><span class="n">start_lba_hi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ldio</span><span class="o">-&gt;</span><span class="n">access_byte</span> <span class="o">=</span> <span class="p">(</span><span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmd_len</span> <span class="o">!=</span> <span class="mi">6</span><span class="p">)</span> <span class="o">?</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * 6-byte READ(0x08) or WRITE(0x0A) cdb</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmd_len</span> <span class="o">==</span> <span class="mi">6</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ldio</span><span class="o">-&gt;</span><span class="n">lba_count</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
		<span class="n">ldio</span><span class="o">-&gt;</span><span class="n">start_lba_lo</span> <span class="o">=</span> <span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span>
		    <span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>

		<span class="n">ldio</span><span class="o">-&gt;</span><span class="n">start_lba_lo</span> <span class="o">&amp;=</span> <span class="mh">0x1FFFFF</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * 10-byte READ(0x28) or WRITE(0x2A) cdb</span>
<span class="cm">	 */</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmd_len</span> <span class="o">==</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ldio</span><span class="o">-&gt;</span><span class="n">lba_count</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">|</span>
		    <span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>
		<span class="n">ldio</span><span class="o">-&gt;</span><span class="n">start_lba_lo</span> <span class="o">=</span> <span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span>
		    <span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span>
		    <span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * 12-byte READ(0xA8) or WRITE(0xAA) cdb</span>
<span class="cm">	 */</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmd_len</span> <span class="o">==</span> <span class="mi">12</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ldio</span><span class="o">-&gt;</span><span class="n">lba_count</span> <span class="o">=</span> <span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span>
		    <span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span>
		    <span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">9</span><span class="p">];</span>

		<span class="n">ldio</span><span class="o">-&gt;</span><span class="n">start_lba_lo</span> <span class="o">=</span> <span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span>
		    <span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span>
		    <span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * 16-byte READ(0x88) or WRITE(0x8A) cdb</span>
<span class="cm">	 */</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmd_len</span> <span class="o">==</span> <span class="mi">16</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ldio</span><span class="o">-&gt;</span><span class="n">lba_count</span> <span class="o">=</span> <span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span>
		    <span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span>
		    <span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">13</span><span class="p">];</span>

		<span class="n">ldio</span><span class="o">-&gt;</span><span class="n">start_lba_lo</span> <span class="o">=</span> <span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span>
		    <span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span>
		    <span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">9</span><span class="p">];</span>

		<span class="n">ldio</span><span class="o">-&gt;</span><span class="n">start_lba_hi</span> <span class="o">=</span> <span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span>
		    <span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span>
		    <span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">scp</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>

	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Construct SGL</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">flag_ieee</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ldio</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">MFI_FRAME_SGL64</span><span class="p">;</span>
		<span class="n">ldio</span><span class="o">-&gt;</span><span class="n">sge_count</span> <span class="o">=</span> <span class="n">megasas_make_sgl_skinny</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">scp</span><span class="p">,</span>
					      <span class="o">&amp;</span><span class="n">ldio</span><span class="o">-&gt;</span><span class="n">sgl</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">IS_DMA64</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ldio</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">MFI_FRAME_SGL64</span><span class="p">;</span>
		<span class="n">ldio</span><span class="o">-&gt;</span><span class="n">sge_count</span> <span class="o">=</span> <span class="n">megasas_make_sgl64</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">scp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ldio</span><span class="o">-&gt;</span><span class="n">sgl</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">ldio</span><span class="o">-&gt;</span><span class="n">sge_count</span> <span class="o">=</span> <span class="n">megasas_make_sgl32</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">scp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ldio</span><span class="o">-&gt;</span><span class="n">sgl</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ldio</span><span class="o">-&gt;</span><span class="n">sge_count</span> <span class="o">&gt;</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">max_num_sge</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;megasas: build_ld_io: sge_count = %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">ldio</span><span class="o">-&gt;</span><span class="n">sge_count</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Sense info specific</span>
<span class="cm">	 */</span>
	<span class="n">ldio</span><span class="o">-&gt;</span><span class="n">sense_len</span> <span class="o">=</span> <span class="n">SCSI_SENSE_BUFFERSIZE</span><span class="p">;</span>
	<span class="n">ldio</span><span class="o">-&gt;</span><span class="n">sense_buf_phys_addr_hi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ldio</span><span class="o">-&gt;</span><span class="n">sense_buf_phys_addr_lo</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sense_phys_addr</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Compute the total number of frames this command consumes. FW uses</span>
<span class="cm">	 * this number to pull sufficient number of frames from host memory.</span>
<span class="cm">	 */</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">frame_count</span> <span class="o">=</span> <span class="n">megasas_get_frame_count</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span>
			<span class="n">ldio</span><span class="o">-&gt;</span><span class="n">sge_count</span><span class="p">,</span> <span class="n">IO_FRAME</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">frame_count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * megasas_is_ldio -		Checks if the cmd is for logical drive</span>
<span class="cm"> * @scmd:			SCSI command</span>
<span class="cm"> *</span>
<span class="cm"> * Called by megasas_queue_command to find out if the command to be queued</span>
<span class="cm"> * is a logical drive command</span>
<span class="cm"> */</span>
<span class="kr">inline</span> <span class="kt">int</span> <span class="nf">megasas_is_ldio</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">MEGASAS_IS_LOGICAL</span><span class="p">(</span><span class="n">cmd</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">READ_10</span>:
	<span class="k">case</span> <span class="n">WRITE_10</span>:
	<span class="k">case</span> <span class="n">READ_12</span>:
	<span class="k">case</span> <span class="n">WRITE_12</span>:
	<span class="k">case</span> <span class="n">READ_6</span>:
	<span class="k">case</span> <span class="n">WRITE_6</span>:
	<span class="k">case</span> <span class="n">READ_16</span>:
	<span class="k">case</span> <span class="n">WRITE_16</span>:
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

 <span class="cm">/**</span>
<span class="cm"> * megasas_dump_pending_frames -	Dumps the frame address of all pending cmds</span>
<span class="cm"> *                              	in FW</span>
<span class="cm"> * @instance:				Adapter soft state</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">megasas_dump_pending_frames</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">megasas_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">n</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">megasas_sgl</span> <span class="o">*</span><span class="n">mfi_sgl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">megasas_io_frame</span> <span class="o">*</span><span class="n">ldio</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">megasas_pthru_frame</span> <span class="o">*</span><span class="n">pthru</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sgcount</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">max_cmd</span> <span class="o">=</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">max_fw_cmds</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">megasas[%d]: Dumping Frame Phys Address of all pending cmds in FW</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;megasas[%d]: Total OS Pending cmds : %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">,</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">fw_outstanding</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_DMA64</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">megasas[%d]: 64 bit SGLs were sent to FW</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">megasas[%d]: 32 bit SGLs were sent to FW</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;megasas[%d]: Pending OS cmds in FW : </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">max_cmd</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cmd</span> <span class="o">=</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">cmd_list</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scmd</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;megasas[%d]: Frame addr :0x%08lx : &quot;</span><span class="p">,</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">,(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">frame_phys_addr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">megasas_is_ldio</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scmd</span><span class="p">)){</span>
			<span class="n">ldio</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">megasas_io_frame</span> <span class="o">*</span><span class="p">)</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">frame</span><span class="p">;</span>
			<span class="n">mfi_sgl</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ldio</span><span class="o">-&gt;</span><span class="n">sgl</span><span class="p">;</span>
			<span class="n">sgcount</span> <span class="o">=</span> <span class="n">ldio</span><span class="o">-&gt;</span><span class="n">sge_count</span><span class="p">;</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;megasas[%d]: frame count : 0x%x, Cmd : 0x%x, Tgt id : 0x%x, lba lo : 0x%x, lba_hi : 0x%x, sense_buf addr : 0x%x,sge count : 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">frame_count</span><span class="p">,</span><span class="n">ldio</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">,</span><span class="n">ldio</span><span class="o">-&gt;</span><span class="n">target_id</span><span class="p">,</span> <span class="n">ldio</span><span class="o">-&gt;</span><span class="n">start_lba_lo</span><span class="p">,</span><span class="n">ldio</span><span class="o">-&gt;</span><span class="n">start_lba_hi</span><span class="p">,</span><span class="n">ldio</span><span class="o">-&gt;</span><span class="n">sense_buf_phys_addr_lo</span><span class="p">,</span><span class="n">sgcount</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">pthru</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">megasas_pthru_frame</span> <span class="o">*</span><span class="p">)</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">frame</span><span class="p">;</span>
			<span class="n">mfi_sgl</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pthru</span><span class="o">-&gt;</span><span class="n">sgl</span><span class="p">;</span>
			<span class="n">sgcount</span> <span class="o">=</span> <span class="n">pthru</span><span class="o">-&gt;</span><span class="n">sge_count</span><span class="p">;</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;megasas[%d]: frame count : 0x%x, Cmd : 0x%x, Tgt id : 0x%x, lun : 0x%x, cdb_len : 0x%x, data xfer len : 0x%x, sense_buf addr : 0x%x,sge count : 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">,</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">frame_count</span><span class="p">,</span><span class="n">pthru</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">,</span><span class="n">pthru</span><span class="o">-&gt;</span><span class="n">target_id</span><span class="p">,</span><span class="n">pthru</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">,</span><span class="n">pthru</span><span class="o">-&gt;</span><span class="n">cdb_len</span> <span class="p">,</span> <span class="n">pthru</span><span class="o">-&gt;</span><span class="n">data_xfer_len</span><span class="p">,</span><span class="n">pthru</span><span class="o">-&gt;</span><span class="n">sense_buf_phys_addr_lo</span><span class="p">,</span><span class="n">sgcount</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="k">if</span><span class="p">(</span><span class="n">megasas_dbg_lvl</span> <span class="o">&amp;</span> <span class="n">MEGASAS_DBG_LVL</span><span class="p">){</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">sgcount</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">){</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">IS_DMA64</span><span class="p">)</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;megasas: sgl len : 0x%x, sgl addr : 0x%08lx &quot;</span><span class="p">,</span><span class="n">mfi_sgl</span><span class="o">-&gt;</span><span class="n">sge64</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">length</span> <span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">mfi_sgl</span><span class="o">-&gt;</span><span class="n">sge64</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">phys_addr</span><span class="p">)</span> <span class="p">;</span>
			<span class="k">else</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;megasas: sgl len : 0x%x, sgl addr : 0x%x &quot;</span><span class="p">,</span><span class="n">mfi_sgl</span><span class="o">-&gt;</span><span class="n">sge32</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">length</span> <span class="p">,</span> <span class="n">mfi_sgl</span><span class="o">-&gt;</span><span class="n">sge32</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">phys_addr</span><span class="p">)</span> <span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="cm">/*for max_cmd*/</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">megasas[%d]: Pending Internal cmds in FW : </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">max_cmd</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">cmd</span> <span class="o">=</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">cmd_list</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sync_cmd</span> <span class="o">==</span> <span class="mi">1</span><span class="p">){</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;0x%08lx : &quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">frame_phys_addr</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;megasas[%d]: Dumping Done.</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">u32</span>
<span class="nf">megasas_build_and_issue_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">scmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">megasas_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">frame_count</span><span class="p">;</span>

	<span class="n">cmd</span> <span class="o">=</span> <span class="n">megasas_get_cmd</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cmd</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">SCSI_MLQUEUE_HOST_BUSY</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Logical drive command</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">megasas_is_ldio</span><span class="p">(</span><span class="n">scmd</span><span class="p">))</span>
		<span class="n">frame_count</span> <span class="o">=</span> <span class="n">megasas_build_ldio</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">scmd</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">frame_count</span> <span class="o">=</span> <span class="n">megasas_build_dcdb</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">scmd</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">frame_count</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_return_cmd</span><span class="p">;</span>

	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scmd</span> <span class="o">=</span> <span class="n">scmd</span><span class="p">;</span>
	<span class="n">scmd</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">cmd</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Issue the command to the FW</span>
<span class="cm">	 */</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">fw_outstanding</span><span class="p">);</span>

	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">instancet</span><span class="o">-&gt;</span><span class="n">fire_cmd</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">frame_phys_addr</span><span class="p">,</span>
				<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">frame_count</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">reg_set</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out_return_cmd:</span>
	<span class="n">megasas_return_cmd</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * megasas_queue_command -	Queue entry point</span>
<span class="cm"> * @scmd:			SCSI command to be queued</span>
<span class="cm"> * @done:			Callback entry point</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">megasas_queue_command_lck</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">scmd</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">done</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">instance</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="p">)</span>
	    <span class="n">scmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">issuepend_done</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">SCSI_MLQUEUE_HOST_BUSY</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">hba_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">adprecovery</span> <span class="o">!=</span> <span class="n">MEGASAS_HBA_OPERATIONAL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">hba_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">SCSI_MLQUEUE_HOST_BUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">hba_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">scmd</span><span class="o">-&gt;</span><span class="n">scsi_done</span> <span class="o">=</span> <span class="n">done</span><span class="p">;</span>
	<span class="n">scmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">MEGASAS_IS_LOGICAL</span><span class="p">(</span><span class="n">scmd</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">scmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">&gt;=</span> <span class="n">MEGASAS_MAX_LD</span> <span class="o">||</span> <span class="n">scmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">scmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_BAD_TARGET</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">scmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SYNCHRONIZE_CACHE</span>:
		<span class="cm">/*</span>
<span class="cm">		 * FW takes care of flush cache on its own</span>
<span class="cm">		 * No need to send it down</span>
<span class="cm">		 */</span>
		<span class="n">scmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_OK</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_done</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">instancet</span><span class="o">-&gt;</span><span class="n">build_and_issue_cmd</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">scmd</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;megasas: Err returned from build_and_issue_cmd</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">SCSI_MLQUEUE_HOST_BUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">out_done:</span>
	<span class="n">done</span><span class="p">(</span><span class="n">scmd</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="nf">DEF_SCSI_QCMD</span><span class="p">(</span><span class="n">megasas_queue_command</span><span class="p">)</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">megasas_lookup_instance</span><span class="p">(</span><span class="n">u16</span> <span class="n">host_no</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">megasas_mgmt_info</span><span class="p">.</span><span class="n">max_index</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">megasas_mgmt_info</span><span class="p">.</span><span class="n">instance</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">megasas_mgmt_info</span><span class="p">.</span><span class="n">instance</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_no</span> <span class="o">==</span> <span class="n">host_no</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">megasas_mgmt_info</span><span class="p">.</span><span class="n">instance</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">megasas_slave_configure</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span>             <span class="n">pd_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span>  <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span> <span class="p">;</span>

	<span class="n">instance</span> <span class="o">=</span> <span class="n">megasas_lookup_instance</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	* Don&#39;t export physical disk devices to the disk driver.</span>
<span class="cm">	*</span>
<span class="cm">	* FIXME: Currently we don&#39;t export them to the midlayer at all.</span>
<span class="cm">	*        That will be fixed once LSI engineers have audited the</span>
<span class="cm">	*        firmware for possible issues.</span>
<span class="cm">	*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">channel</span> <span class="o">&lt;</span> <span class="n">MEGASAS_MAX_PD_CHANNELS</span> <span class="o">&amp;&amp;</span>
				<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">TYPE_DISK</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pd_index</span> <span class="o">=</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">channel</span> <span class="o">*</span> <span class="n">MEGASAS_MAX_DEV_PER_CHANNEL</span><span class="p">)</span> <span class="o">+</span>
								<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pd_list</span><span class="p">[</span><span class="n">pd_index</span><span class="p">].</span><span class="n">driveState</span> <span class="o">==</span>
						<span class="n">MR_PD_STATE_SYSTEM</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">blk_queue_rq_timeout</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="p">,</span>
				<span class="n">MEGASAS_DEFAULT_CMD_TIMEOUT</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	* The RAID firmware may require extended timeouts.</span>
<span class="cm">	*/</span>
	<span class="n">blk_queue_rq_timeout</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="p">,</span>
		<span class="n">MEGASAS_DEFAULT_CMD_TIMEOUT</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">megasas_slave_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span>             <span class="n">pd_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span> <span class="p">;</span>
	<span class="n">instance</span> <span class="o">=</span> <span class="n">megasas_lookup_instance</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">channel</span> <span class="o">&lt;</span> <span class="n">MEGASAS_MAX_PD_CHANNELS</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				<span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">TYPE_DISK</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Open the OS scan to the SYSTEM PD</span>
<span class="cm">		 */</span>
		<span class="n">pd_index</span> <span class="o">=</span>
			<span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">channel</span> <span class="o">*</span> <span class="n">MEGASAS_MAX_DEV_PER_CHANNEL</span><span class="p">)</span> <span class="o">+</span>
			<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pd_list</span><span class="p">[</span><span class="n">pd_index</span><span class="p">].</span><span class="n">driveState</span> <span class="o">==</span>
					<span class="n">MR_PD_STATE_SYSTEM</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pd_list</span><span class="p">[</span><span class="n">pd_index</span><span class="p">].</span><span class="n">driveType</span> <span class="o">==</span>
						<span class="n">TYPE_DISK</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">megaraid_sas_kill_hba</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_LSI_SAS0073SKINNY</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_LSI_SAS0071SKINNY</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_LSI_FUSION</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_LSI_INVADER</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">MFI_STOP_ADP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">reg_set</span><span class="o">-&gt;</span><span class="n">doorbell</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">MFI_STOP_ADP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">reg_set</span><span class="o">-&gt;</span><span class="n">inbound_doorbell</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

 <span class="cm">/**</span>
<span class="cm">  * megasas_check_and_restore_queue_depth - Check if queue depth needs to be</span>
<span class="cm">  *					restored to max value</span>
<span class="cm">  * @instance:			Adapter soft state</span>
<span class="cm">  *</span>
<span class="cm">  */</span>
<span class="kt">void</span>
<span class="nf">megasas_check_and_restore_queue_depth</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">MEGASAS_FW_BUSY</span>
		<span class="o">&amp;&amp;</span> <span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">last_time</span> <span class="o">+</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">)</span>
		<span class="o">&amp;&amp;</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">fw_outstanding</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">17</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">instance</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MEGASAS_FW_BUSY</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span>
			<span class="n">PCI_DEVICE_ID_LSI_SAS0073SKINNY</span><span class="p">)</span> <span class="o">||</span>
			<span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span>
			<span class="n">PCI_DEVICE_ID_LSI_SAS0071SKINNY</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">instance</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">can_queue</span> <span class="o">=</span>
				<span class="n">instance</span><span class="o">-&gt;</span><span class="n">max_fw_cmds</span> <span class="o">-</span> <span class="n">MEGASAS_SKINNY_INT_CMDS</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">instance</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">can_queue</span> <span class="o">=</span>
				<span class="n">instance</span><span class="o">-&gt;</span><span class="n">max_fw_cmds</span> <span class="o">-</span> <span class="n">MEGASAS_INT_CMDS</span><span class="p">;</span>

		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * megasas_complete_cmd_dpc	 -	Returns FW&#39;s controller structure</span>
<span class="cm"> * @instance_addr:			Address of adapter soft state</span>
<span class="cm"> *</span>
<span class="cm"> * Tasklet to complete cmds</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">megasas_complete_cmd_dpc</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">instance_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">producer</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">consumer</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">context</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">megasas_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span> <span class="o">=</span>
				<span class="p">(</span><span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="p">)</span><span class="n">instance_addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* If we have already declared adapter dead, donot complete cmds */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">adprecovery</span> <span class="o">==</span> <span class="n">MEGASAS_HW_CRITICAL_ERROR</span> <span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">completion_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">producer</span> <span class="o">=</span> <span class="o">*</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">producer</span><span class="p">;</span>
	<span class="n">consumer</span> <span class="o">=</span> <span class="o">*</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">consumer</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">consumer</span> <span class="o">!=</span> <span class="n">producer</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">context</span> <span class="o">=</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">reply_queue</span><span class="p">[</span><span class="n">consumer</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">context</span> <span class="o">&gt;=</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">max_fw_cmds</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Unexpected context value %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">context</span><span class="p">);</span>
			<span class="n">BUG</span><span class="p">();</span>
		<span class="p">}</span>

		<span class="n">cmd</span> <span class="o">=</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">cmd_list</span><span class="p">[</span><span class="n">context</span><span class="p">];</span>

		<span class="n">megasas_complete_cmd</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">DID_OK</span><span class="p">);</span>

		<span class="n">consumer</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">consumer</span> <span class="o">==</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">max_fw_cmds</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">consumer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">consumer</span> <span class="o">=</span> <span class="n">producer</span><span class="p">;</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">completion_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check if we can restore can_queue</span>
<span class="cm">	 */</span>
	<span class="n">megasas_check_and_restore_queue_depth</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="n">megasas_internal_reset_defer_cmds</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="n">process_fw_state_change_wq</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">megasas_do_ocr</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_LSI_SAS1064R</span><span class="p">)</span> <span class="o">||</span>
	<span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_DELL_PERC5</span><span class="p">)</span> <span class="o">||</span>
	<span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_LSI_VERDE_ZCR</span><span class="p">))</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">consumer</span>     <span class="o">=</span> <span class="n">MEGASAS_ADPRESET_INPROG_SIGN</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">instancet</span><span class="o">-&gt;</span><span class="n">disable_intr</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">reg_set</span><span class="p">);</span>
	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">adprecovery</span>   <span class="o">=</span> <span class="n">MEGASAS_ADPRESET_SM_INFAULT</span><span class="p">;</span>
	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">issuepend_done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">fw_outstanding</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">megasas_internal_reset_defer_cmds</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>
	<span class="n">process_fw_state_change_wq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">work_init</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * megasas_wait_for_outstanding -	Wait for all outstanding cmds</span>
<span class="cm"> * @instance:				Adapter soft state</span>
<span class="cm"> *</span>
<span class="cm"> * This function waits for up to MEGASAS_RESET_WAIT_TIME seconds for FW to</span>
<span class="cm"> * complete all its outstanding commands. Returns error if one or more IOs</span>
<span class="cm"> * are pending after this time period. It also marks the controller dead.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">megasas_wait_for_outstanding</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reset_index</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">wait_time</span> <span class="o">=</span> <span class="n">MEGASAS_RESET_WAIT_TIME</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">adprecovery</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">clist_local</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">megasas_cmd</span> <span class="o">*</span><span class="n">reset_cmd</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">fw_state</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">kill_adapter_flag</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">hba_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">adprecovery</span> <span class="o">=</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">adprecovery</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">hba_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adprecovery</span> <span class="o">!=</span> <span class="n">MEGASAS_HBA_OPERATIONAL</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clist_local</span><span class="p">);</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">hba_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">internal_reset_pending_q</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">clist_local</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">hba_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;megasas: HBA reset wait ...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">wait_time</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">msleep</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">hba_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">adprecovery</span> <span class="o">=</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">adprecovery</span><span class="p">;</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">hba_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">adprecovery</span> <span class="o">==</span> <span class="n">MEGASAS_HBA_OPERATIONAL</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">adprecovery</span> <span class="o">!=</span> <span class="n">MEGASAS_HBA_OPERATIONAL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;megasas: reset: Stopping HBA.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">hba_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">instance</span><span class="o">-&gt;</span><span class="n">adprecovery</span>	<span class="o">=</span> <span class="n">MEGASAS_HW_CRITICAL_ERROR</span><span class="p">;</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">hba_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">FAILED</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">reset_index</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clist_local</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">reset_cmd</span>	<span class="o">=</span> <span class="n">list_entry</span><span class="p">((</span><span class="o">&amp;</span><span class="n">clist_local</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">megasas_cmd</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
			<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reset_cmd</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">reset_cmd</span><span class="o">-&gt;</span><span class="n">scmd</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">reset_cmd</span><span class="o">-&gt;</span><span class="n">scmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_RESET</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;%d:%p reset [%02x]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">reset_index</span><span class="p">,</span> <span class="n">reset_cmd</span><span class="p">,</span>
					<span class="n">reset_cmd</span><span class="o">-&gt;</span><span class="n">scmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

				<span class="n">reset_cmd</span><span class="o">-&gt;</span><span class="n">scmd</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">(</span><span class="n">reset_cmd</span><span class="o">-&gt;</span><span class="n">scmd</span><span class="p">);</span>
				<span class="n">megasas_return_cmd</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">reset_cmd</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">reset_cmd</span><span class="o">-&gt;</span><span class="n">sync_cmd</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;megasas:%p synch cmds&quot;</span>
						<span class="s">&quot;reset queue</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">reset_cmd</span><span class="p">);</span>

				<span class="n">reset_cmd</span><span class="o">-&gt;</span><span class="n">cmd_status</span> <span class="o">=</span> <span class="n">ENODATA</span><span class="p">;</span>
				<span class="n">instance</span><span class="o">-&gt;</span><span class="n">instancet</span><span class="o">-&gt;</span><span class="n">fire_cmd</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span>
						<span class="n">reset_cmd</span><span class="o">-&gt;</span><span class="n">frame_phys_addr</span><span class="p">,</span>
						<span class="mi">0</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">reg_set</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;megasas: %p unexpected&quot;</span>
					<span class="s">&quot;cmds lst</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">reset_cmd</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">reset_index</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">return</span> <span class="n">SUCCESS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">wait_time</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="kt">int</span> <span class="n">outstanding</span> <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">fw_outstanding</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">outstanding</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="n">MEGASAS_RESET_NOTICE_INTERVAL</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;megasas: [%2d]waiting for %d &quot;</span>
			       <span class="s">&quot;commands to complete</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">outstanding</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * Call cmd completion routine. Cmd to be</span>
<span class="cm">			 * be completed directly without depending on isr.</span>
<span class="cm">			 */</span>
			<span class="n">megasas_complete_cmd_dpc</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">instance</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">msleep</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">kill_adapter_flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">fw_state</span> <span class="o">=</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">instancet</span><span class="o">-&gt;</span><span class="n">read_fw_status_reg</span><span class="p">(</span>
					<span class="n">instance</span><span class="o">-&gt;</span><span class="n">reg_set</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">MFI_STATE_MASK</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">fw_state</span> <span class="o">==</span> <span class="n">MFI_STATE_FAULT</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">disableOnlineCtrlReset</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">kill_adapter_flag</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">megasas_do_ocr</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>
			<span class="n">kill_adapter_flag</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

			<span class="cm">/* wait for 1 secs to let FW finish the pending cmds */</span>
			<span class="n">msleep</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">i</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">fw_outstanding</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
					<span class="o">!</span><span class="n">kill_adapter_flag</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">disableOnlineCtrlReset</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

			<span class="n">megasas_do_ocr</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>

			<span class="cm">/* wait for 5 secs to let FW finish the pending cmds */</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">wait_time</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="kt">int</span> <span class="n">outstanding</span> <span class="o">=</span>
					<span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">fw_outstanding</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">outstanding</span><span class="p">)</span>
					<span class="k">return</span> <span class="n">SUCCESS</span><span class="p">;</span>
				<span class="n">msleep</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">fw_outstanding</span><span class="p">)</span> <span class="o">||</span>
					<span class="p">(</span><span class="n">kill_adapter_flag</span> <span class="o">==</span> <span class="mi">2</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;megaraid_sas: pending cmds after reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		* Send signal to FW to stop processing any pending cmds.</span>
<span class="cm">		* The controller will be taken offline by the OS now.</span>
<span class="cm">		*/</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span>
			<span class="n">PCI_DEVICE_ID_LSI_SAS0073SKINNY</span><span class="p">)</span> <span class="o">||</span>
			<span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span>
			<span class="n">PCI_DEVICE_ID_LSI_SAS0071SKINNY</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">writel</span><span class="p">(</span><span class="n">MFI_STOP_ADP</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">reg_set</span><span class="o">-&gt;</span><span class="n">doorbell</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">writel</span><span class="p">(</span><span class="n">MFI_STOP_ADP</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">reg_set</span><span class="o">-&gt;</span><span class="n">inbound_doorbell</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">megasas_dump_pending_frames</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">hba_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">instance</span><span class="o">-&gt;</span><span class="n">adprecovery</span>	<span class="o">=</span> <span class="n">MEGASAS_HW_CRITICAL_ERROR</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">hba_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">FAILED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;megaraid_sas: no pending cmds after reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * megasas_generic_reset -	Generic reset routine</span>
<span class="cm"> * @scmd:			Mid-layer SCSI command</span>
<span class="cm"> *</span>
<span class="cm"> * This routine implements a generic reset handler for device, bus and host</span>
<span class="cm"> * reset requests. Device, bus and host specific reset handlers can use this</span>
<span class="cm"> * function after they do their specific tasks.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">megasas_generic_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">scmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">;</span>

	<span class="n">instance</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="p">)</span><span class="n">scmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>

	<span class="n">scmd_printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span><span class="p">,</span> <span class="n">scmd</span><span class="p">,</span> <span class="s">&quot;megasas: RESET cmd=%x retries=%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">scmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">scmd</span><span class="o">-&gt;</span><span class="n">retries</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">adprecovery</span> <span class="o">==</span> <span class="n">MEGASAS_HW_CRITICAL_ERROR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;megasas: cannot recover from previous reset &quot;</span>
		       <span class="s">&quot;failures</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">FAILED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">megasas_wait_for_outstanding</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span> <span class="o">==</span> <span class="n">SUCCESS</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;megasas: reset successful </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;megasas: failed to do reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * megasas_reset_timer - quiesce the adapter if required</span>
<span class="cm"> * @scmd:		scsi cmnd</span>
<span class="cm"> *</span>
<span class="cm"> * Sets the FW busy flag and reduces the host-&gt;can_queue if the</span>
<span class="cm"> * cmd has not been completed within the timeout period.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">enum</span>
<span class="n">blk_eh_timer_return</span> <span class="nf">megasas_reset_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">scmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">scmd</span><span class="o">-&gt;</span><span class="n">jiffies_at_alloc</span> <span class="o">+</span>
				<span class="p">(</span><span class="n">MEGASAS_DEFAULT_CMD_TIMEOUT</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">BLK_EH_NOT_HANDLED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">instance</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="p">)</span><span class="n">scmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">MEGASAS_FW_BUSY</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* FW is busy, throttle IO */</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="n">instance</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">can_queue</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
		<span class="n">instance</span><span class="o">-&gt;</span><span class="n">last_time</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
		<span class="n">instance</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">|=</span> <span class="n">MEGASAS_FW_BUSY</span><span class="p">;</span>

		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">BLK_EH_RESET_TIMER</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * megasas_reset_device -	Device reset handler entry point</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">megasas_reset_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">scmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * First wait for all commands to complete</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">megasas_generic_reset</span><span class="p">(</span><span class="n">scmd</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * megasas_reset_bus_host -	Bus &amp; host reset handler entry point</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">megasas_reset_bus_host</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">scmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">;</span>
	<span class="n">instance</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="p">)</span><span class="n">scmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * First wait for all commands to complete</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_LSI_FUSION</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_LSI_INVADER</span><span class="p">))</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">megasas_reset_fusion</span><span class="p">(</span><span class="n">scmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">megasas_generic_reset</span><span class="p">(</span><span class="n">scmd</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * megasas_bios_param - Returns disk geometry for a disk</span>
<span class="cm"> * @sdev: 		device handle</span>
<span class="cm"> * @bdev:		block device</span>
<span class="cm"> * @capacity:		drive capacity</span>
<span class="cm"> * @geom:		geometry parameters</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">megasas_bios_param</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span>
		 <span class="n">sector_t</span> <span class="n">capacity</span><span class="p">,</span> <span class="kt">int</span> <span class="n">geom</span><span class="p">[])</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">heads</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sectors</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">cylinders</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="cm">/* Default heads (64) &amp; sectors (32) */</span>
	<span class="n">heads</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>
	<span class="n">sectors</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">heads</span> <span class="o">*</span> <span class="n">sectors</span><span class="p">;</span>
	<span class="n">cylinders</span> <span class="o">=</span> <span class="n">capacity</span><span class="p">;</span>

	<span class="n">sector_div</span><span class="p">(</span><span class="n">cylinders</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Handle extended translation size for logical drives &gt; 1Gb</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">capacity</span> <span class="o">&gt;=</span> <span class="mh">0x200000</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">heads</span> <span class="o">=</span> <span class="mi">255</span><span class="p">;</span>
		<span class="n">sectors</span> <span class="o">=</span> <span class="mi">63</span><span class="p">;</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">heads</span><span class="o">*</span><span class="n">sectors</span><span class="p">;</span>
		<span class="n">cylinders</span> <span class="o">=</span> <span class="n">capacity</span><span class="p">;</span>
		<span class="n">sector_div</span><span class="p">(</span><span class="n">cylinders</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">geom</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">heads</span><span class="p">;</span>
	<span class="n">geom</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sectors</span><span class="p">;</span>
	<span class="n">geom</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">cylinders</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">megasas_aen_polling</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * megasas_service_aen -	Processes an event notification</span>
<span class="cm"> * @instance:			Adapter soft state</span>
<span class="cm"> * @cmd:			AEN command completed by the ISR</span>
<span class="cm"> *</span>
<span class="cm"> * For AEN, driver sends a command down to FW that is held by the FW till an</span>
<span class="cm"> * event occurs. When an event of interest occurs, FW completes the command</span>
<span class="cm"> * that it was previously holding.</span>
<span class="cm"> *</span>
<span class="cm"> * This routines sends SIGIO signal to processes that have registered with the</span>
<span class="cm"> * driver for AEN.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">megasas_service_aen</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span> <span class="k">struct</span> <span class="n">megasas_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Don&#39;t signal app if it is just an aborted previously registered aen</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">abort_aen</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">unload</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">poll_aen_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">megasas_poll_wait_aen</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">poll_aen_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">megasas_poll_wait</span><span class="p">);</span>
		<span class="n">kill_fasync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">megasas_async_queue</span><span class="p">,</span> <span class="n">SIGIO</span><span class="p">,</span> <span class="n">POLL_IN</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">abort_aen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">aen_cmd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">megasas_return_cmd</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">unload</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="p">((</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">issuepend_done</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">megasas_aen_event</span> <span class="o">*</span><span class="n">ev</span><span class="p">;</span>
		<span class="n">ev</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ev</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ev</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;megasas_service_aen: out of memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ev</span><span class="o">-&gt;</span><span class="n">instance</span> <span class="o">=</span> <span class="n">instance</span><span class="p">;</span>
			<span class="n">instance</span><span class="o">-&gt;</span><span class="n">ev</span> <span class="o">=</span> <span class="n">ev</span><span class="p">;</span>
			<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">hotplug_work</span><span class="p">,</span> <span class="n">megasas_aen_polling</span><span class="p">);</span>
			<span class="n">schedule_delayed_work</span><span class="p">(</span>
				<span class="p">(</span><span class="k">struct</span> <span class="n">delayed_work</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">hotplug_work</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">megasas_change_queue_depth</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">,</span>
				      <span class="kt">int</span> <span class="n">queue_depth</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reason</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reason</span> <span class="o">!=</span> <span class="n">SCSI_QDEPTH_DEFAULT</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">queue_depth</span> <span class="o">&gt;</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">can_queue</span><span class="p">)</span>
		<span class="n">queue_depth</span> <span class="o">=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">can_queue</span><span class="p">;</span>
	<span class="n">scsi_adjust_queue_depth</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">scsi_get_tag_type</span><span class="p">(</span><span class="n">sdev</span><span class="p">),</span>
				<span class="n">queue_depth</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">queue_depth</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Scsi host template for megaraid_sas driver</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">scsi_host_template</span> <span class="n">megasas_template</span> <span class="o">=</span> <span class="p">{</span>

	<span class="p">.</span><span class="n">module</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;LSI SAS based MegaRAID driver&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">proc_name</span> <span class="o">=</span> <span class="s">&quot;megaraid_sas&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">slave_configure</span> <span class="o">=</span> <span class="n">megasas_slave_configure</span><span class="p">,</span>
	<span class="p">.</span><span class="n">slave_alloc</span> <span class="o">=</span> <span class="n">megasas_slave_alloc</span><span class="p">,</span>
	<span class="p">.</span><span class="n">queuecommand</span> <span class="o">=</span> <span class="n">megasas_queue_command</span><span class="p">,</span>
	<span class="p">.</span><span class="n">eh_device_reset_handler</span> <span class="o">=</span> <span class="n">megasas_reset_device</span><span class="p">,</span>
	<span class="p">.</span><span class="n">eh_bus_reset_handler</span> <span class="o">=</span> <span class="n">megasas_reset_bus_host</span><span class="p">,</span>
	<span class="p">.</span><span class="n">eh_host_reset_handler</span> <span class="o">=</span> <span class="n">megasas_reset_bus_host</span><span class="p">,</span>
	<span class="p">.</span><span class="n">eh_timed_out</span> <span class="o">=</span> <span class="n">megasas_reset_timer</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bios_param</span> <span class="o">=</span> <span class="n">megasas_bios_param</span><span class="p">,</span>
	<span class="p">.</span><span class="n">use_clustering</span> <span class="o">=</span> <span class="n">ENABLE_CLUSTERING</span><span class="p">,</span>
	<span class="p">.</span><span class="n">change_queue_depth</span> <span class="o">=</span> <span class="n">megasas_change_queue_depth</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * megasas_complete_int_cmd -	Completes an internal command</span>
<span class="cm"> * @instance:			Adapter soft state</span>
<span class="cm"> * @cmd:			Command to be completed</span>
<span class="cm"> *</span>
<span class="cm"> * The megasas_issue_blocked_cmd() function waits for a command to complete</span>
<span class="cm"> * after it issues a command. This function wakes up that waiting routine by</span>
<span class="cm"> * calling wake_up() on the wait queue.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">megasas_complete_int_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">megasas_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmd_status</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">cmd_status</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmd_status</span> <span class="o">==</span> <span class="n">ENODATA</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmd_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">int_cmd_wait_q</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * megasas_complete_abort -	Completes aborting a command</span>
<span class="cm"> * @instance:			Adapter soft state</span>
<span class="cm"> * @cmd:			Cmd that was issued to abort another cmd</span>
<span class="cm"> *</span>
<span class="cm"> * The megasas_issue_blocked_abort_cmd() function waits on abort_cmd_wait_q</span>
<span class="cm"> * after it issues an abort on a previously issued command. This function</span>
<span class="cm"> * wakes up all functions waiting on the same wait queue.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">megasas_complete_abort</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">megasas_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sync_cmd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sync_cmd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmd_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">abort_cmd_wait_q</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * megasas_complete_cmd -	Completes a command</span>
<span class="cm"> * @instance:			Adapter soft state</span>
<span class="cm"> * @cmd:			Command to be completed</span>
<span class="cm"> * @alt_status:			If non-zero, use this value as status to</span>
<span class="cm"> * 				SCSI mid-layer instead of the value returned</span>
<span class="cm"> * 				by the FW. This should be used if caller wants</span>
<span class="cm"> * 				an alternate status (as in the case of aborted</span>
<span class="cm"> * 				commands)</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">megasas_complete_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span> <span class="k">struct</span> <span class="n">megasas_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span>
		     <span class="n">u8</span> <span class="n">alt_status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">exception</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">megasas_header</span> <span class="o">*</span><span class="n">hdr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fusion_context</span> <span class="o">*</span><span class="n">fusion</span> <span class="o">=</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">ctrl_context</span><span class="p">;</span>

	<span class="cm">/* flag for the retry reset */</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">retry_for_fw_reset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scmd</span><span class="p">)</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scmd</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">MFI_CMD_INVALID</span>:
		<span class="cm">/* Some older 1068 controller FW may keep a pended</span>
<span class="cm">		   MR_DCMD_CTRL_EVENT_GET_INFO left over from the main kernel</span>
<span class="cm">		   when booting the kdump kernel.  Ignore this command to</span>
<span class="cm">		   prevent a kernel panic on shutdown of the kdump kernel. */</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;megaraid_sas: MFI_CMD_INVALID command &quot;</span>
		       <span class="s">&quot;completed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;megaraid_sas: If you have a controller &quot;</span>
		       <span class="s">&quot;other than PERC5, please upgrade your firmware.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MFI_CMD_PD_SCSI_IO</span>:
	<span class="k">case</span> <span class="n">MFI_CMD_LD_SCSI_IO</span>:

		<span class="cm">/*</span>
<span class="cm">		 * MFI_CMD_PD_SCSI_IO and MFI_CMD_LD_SCSI_IO could have been</span>
<span class="cm">		 * issued either through an IO path or an IOCTL path. If it</span>
<span class="cm">		 * was via IOCTL, we will send it to internal completion.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sync_cmd</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sync_cmd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">megasas_complete_int_cmd</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="k">case</span> <span class="n">MFI_CMD_LD_READ</span>:
	<span class="k">case</span> <span class="n">MFI_CMD_LD_WRITE</span>:

		<span class="k">if</span> <span class="p">(</span><span class="n">alt_status</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">alt_status</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
			<span class="n">exception</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">exception</span><span class="p">)</span> <span class="p">{</span>

			<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">fw_outstanding</span><span class="p">);</span>

			<span class="n">scsi_dma_unmap</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scmd</span><span class="p">);</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scmd</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scmd</span><span class="p">);</span>
			<span class="n">megasas_return_cmd</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>

			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">cmd_status</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">case</span> <span class="n">MFI_STAT_OK</span>:
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_OK</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">MFI_STAT_SCSI_IO_FAILED</span>:
		<span class="k">case</span> <span class="n">MFI_STAT_LD_INIT_IN_PROGRESS</span>:
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span>
			    <span class="p">(</span><span class="n">DID_ERROR</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">scsi_status</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">MFI_STAT_SCSI_DONE_WITH_ERROR</span>:

			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DID_OK</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">scsi_status</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">scsi_status</span> <span class="o">==</span> <span class="n">SAM_STAT_CHECK_CONDITION</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">memset</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scmd</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				       <span class="n">SCSI_SENSE_BUFFERSIZE</span><span class="p">);</span>
				<span class="n">memcpy</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scmd</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sense</span><span class="p">,</span>
				       <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">sense_len</span><span class="p">);</span>

				<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">|=</span> <span class="n">DRIVER_SENSE</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">MFI_STAT_LD_OFFLINE</span>:
		<span class="k">case</span> <span class="n">MFI_STAT_DEVICE_NOT_FOUND</span>:
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_BAD_TARGET</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="nl">default:</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;megasas: MFI FW status %#x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">cmd_status</span><span class="p">);</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_ERROR</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">fw_outstanding</span><span class="p">);</span>

		<span class="n">scsi_dma_unmap</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scmd</span><span class="p">);</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scmd</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scmd</span><span class="p">);</span>
		<span class="n">megasas_return_cmd</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>

		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">MFI_CMD_SMP</span>:
	<span class="k">case</span> <span class="n">MFI_CMD_STP</span>:
	<span class="k">case</span> <span class="n">MFI_CMD_DCMD</span>:
		<span class="cm">/* Check for LD map update */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">dcmd</span><span class="p">.</span><span class="n">opcode</span> <span class="o">==</span> <span class="n">MR_DCMD_LD_MAP_GET_INFO</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">dcmd</span><span class="p">.</span><span class="n">mbox</span><span class="p">.</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">cmd_status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">cmd_status</span> <span class="o">!=</span>
				    <span class="n">MFI_STAT_NOT_FOUND</span><span class="p">)</span>
					<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;megasas: map sync&quot;</span>
					       <span class="s">&quot;failed, status = 0x%x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					       <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">cmd_status</span><span class="p">);</span>
				<span class="k">else</span> <span class="p">{</span>
					<span class="n">megasas_return_cmd</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
					<span class="n">spin_unlock_irqrestore</span><span class="p">(</span>
						<span class="n">instance</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span>
						<span class="n">flags</span><span class="p">);</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="n">instance</span><span class="o">-&gt;</span><span class="n">map_id</span><span class="o">++</span><span class="p">;</span>
			<span class="n">megasas_return_cmd</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">MR_ValidateMapInfo</span><span class="p">(</span>
				    <span class="n">fusion</span><span class="o">-&gt;</span><span class="n">ld_map</span><span class="p">[(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">map_id</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)],</span>
				    <span class="n">fusion</span><span class="o">-&gt;</span><span class="n">load_balance_info</span><span class="p">))</span>
				<span class="n">fusion</span><span class="o">-&gt;</span><span class="n">fast_path_io</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">fusion</span><span class="o">-&gt;</span><span class="n">fast_path_io</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">megasas_sync_map_info</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span>
					       <span class="n">flags</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">dcmd</span><span class="p">.</span><span class="n">opcode</span> <span class="o">==</span> <span class="n">MR_DCMD_CTRL_EVENT_GET_INFO</span> <span class="o">||</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">dcmd</span><span class="p">.</span><span class="n">opcode</span> <span class="o">==</span> <span class="n">MR_DCMD_CTRL_EVENT_GET</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">poll_aen_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">megasas_poll_wait_aen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">poll_aen_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * See if got an event notification</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">dcmd</span><span class="p">.</span><span class="n">opcode</span> <span class="o">==</span> <span class="n">MR_DCMD_CTRL_EVENT_WAIT</span><span class="p">)</span>
			<span class="n">megasas_service_aen</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">megasas_complete_int_cmd</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>

		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">MFI_CMD_ABORT</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Cmd issued to abort another cmd returned</span>
<span class="cm">		 */</span>
		<span class="n">megasas_complete_abort</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;megasas: Unknown command completed! [0x%X]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * megasas_issue_pending_cmds_again -	issue all pending cmds</span>
<span class="cm"> *                              	in FW again because of the fw reset</span>
<span class="cm"> * @instance:				Adapter soft state</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">megasas_issue_pending_cmds_again</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">megasas_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">clist_local</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">megasas_evt_class_locale</span> <span class="n">class_locale</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">seq_num</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clist_local</span><span class="p">);</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">hba_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">internal_reset_pending_q</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clist_local</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">hba_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clist_local</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cmd</span>	<span class="o">=</span> <span class="n">list_entry</span><span class="p">((</span><span class="o">&amp;</span><span class="n">clist_local</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">megasas_cmd</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sync_cmd</span> <span class="o">||</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scmd</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;megaraid_sas: command %p, %p:%d&quot;</span>
				<span class="s">&quot;detected to be pending while HBA reset.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">cmd</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scmd</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sync_cmd</span><span class="p">);</span>

			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">retry_for_fw_reset</span><span class="o">++</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">retry_for_fw_reset</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;megaraid_sas: cmd %p, %p:%d&quot;</span>
					<span class="s">&quot;was tried multiple times during reset.&quot;</span>
					<span class="s">&quot;Shutting down the HBA</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">cmd</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scmd</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sync_cmd</span><span class="p">);</span>
				<span class="n">megaraid_sas_kill_hba</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>

				<span class="n">instance</span><span class="o">-&gt;</span><span class="n">adprecovery</span> <span class="o">=</span>
						<span class="n">MEGASAS_HW_CRITICAL_ERROR</span><span class="p">;</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sync_cmd</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scmd</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;megaraid_sas: unexpected&quot;</span>
					<span class="s">&quot;cmd attached to internal command!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;megasas: %p synchronous cmd&quot;</span>
						<span class="s">&quot;on the internal reset queue,&quot;</span>
						<span class="s">&quot;issue it again.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmd_status</span> <span class="o">=</span> <span class="n">ENODATA</span><span class="p">;</span>
			<span class="n">instance</span><span class="o">-&gt;</span><span class="n">instancet</span><span class="o">-&gt;</span><span class="n">fire_cmd</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span>
							<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">frame_phys_addr</span> <span class="p">,</span>
							<span class="mi">0</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">reg_set</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scmd</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;megasas: %p scsi cmd [%02x]&quot;</span>
			<span class="s">&quot;detected on the internal queue, issue again.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">cmd</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

			<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">fw_outstanding</span><span class="p">);</span>
			<span class="n">instance</span><span class="o">-&gt;</span><span class="n">instancet</span><span class="o">-&gt;</span><span class="n">fire_cmd</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span>
					<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">frame_phys_addr</span><span class="p">,</span>
					<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">frame_count</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">reg_set</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;megasas: %p unexpected cmd on the&quot;</span>
				<span class="s">&quot;internal reset defer list while re-issue!!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">cmd</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">aen_cmd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;megaraid_sas: aen_cmd in def process</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">megasas_return_cmd</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">aen_cmd</span><span class="p">);</span>

		<span class="n">instance</span><span class="o">-&gt;</span><span class="n">aen_cmd</span>	<span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	* Initiate AEN (Asynchronous Event Notification)</span>
<span class="cm">	*/</span>
	<span class="n">seq_num</span> <span class="o">=</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">last_seq_num</span><span class="p">;</span>
	<span class="n">class_locale</span><span class="p">.</span><span class="n">members</span><span class="p">.</span><span class="n">reserved</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">class_locale</span><span class="p">.</span><span class="n">members</span><span class="p">.</span><span class="n">locale</span> <span class="o">=</span> <span class="n">MR_EVT_LOCALE_ALL</span><span class="p">;</span>
	<span class="n">class_locale</span><span class="p">.</span><span class="n">members</span><span class="p">.</span><span class="n">class</span> <span class="o">=</span> <span class="n">MR_EVT_CLASS_DEBUG</span><span class="p">;</span>

	<span class="n">megasas_register_aen</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">seq_num</span><span class="p">,</span> <span class="n">class_locale</span><span class="p">.</span><span class="n">word</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Move the internal reset pending commands to a deferred queue.</span>
<span class="cm"> *</span>
<span class="cm"> * We move the commands pending at internal reset time to a</span>
<span class="cm"> * pending queue. This queue would be flushed after successful</span>
<span class="cm"> * completion of the internal reset sequence. if the internal reset</span>
<span class="cm"> * did not complete in time, the kernel reset handler would flush</span>
<span class="cm"> * these commands.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">megasas_internal_reset_defer_cmds</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">megasas_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">max_cmd</span> <span class="o">=</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">max_fw_cmds</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">defer_index</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">defer_index</span>     <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">cmd_pool_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">max_cmd</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cmd</span> <span class="o">=</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">cmd_list</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sync_cmd</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scmd</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;megasas: moving cmd[%d]:%p:%d:%p&quot;</span>
					<span class="s">&quot;on the defer queue as internal</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">defer_index</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sync_cmd</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scmd</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;megaraid_sas: ERROR while&quot;</span>
					<span class="s">&quot; moving this cmd:%p, %d %p, it was&quot;</span>
					<span class="s">&quot;discovered on some list?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">cmd</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sync_cmd</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scmd</span><span class="p">);</span>

				<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">defer_index</span><span class="o">++</span><span class="p">;</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">internal_reset_pending_q</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">cmd_pool_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span>
<span class="nf">process_fw_state_change_wq</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">megasas_instance</span><span class="p">,</span> <span class="n">work_init</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">wait</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">adprecovery</span> <span class="o">!=</span> <span class="n">MEGASAS_ADPRESET_SM_INFAULT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;megaraid_sas: error, recovery st %x </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">instance</span><span class="o">-&gt;</span><span class="n">adprecovery</span><span class="p">);</span>
		<span class="k">return</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">adprecovery</span> <span class="o">==</span> <span class="n">MEGASAS_ADPRESET_SM_INFAULT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;megaraid_sas: FW detected to be in fault&quot;</span>
					<span class="s">&quot;state, restarting it...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="n">instance</span><span class="o">-&gt;</span><span class="n">instancet</span><span class="o">-&gt;</span><span class="n">disable_intr</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">reg_set</span><span class="p">);</span>
		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">fw_outstanding</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">fw_reset_no_pci_access</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">instance</span><span class="o">-&gt;</span><span class="n">instancet</span><span class="o">-&gt;</span><span class="n">adp_reset</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">reg_set</span><span class="p">);</span>
		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">fw_reset_no_pci_access</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>

		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;megaraid_sas: FW restarted successfully,&quot;</span>
					<span class="s">&quot;initiating next stage...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;megaraid_sas: HBA recovery state machine,&quot;</span>
					<span class="s">&quot;state 2 starting...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="cm">/*waitting for about 20 second before start the second init*/</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">wait</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">wait</span> <span class="o">&lt;</span> <span class="mi">30</span><span class="p">;</span> <span class="n">wait</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">msleep</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">megasas_transition_to_ready</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;megaraid_sas:adapter not ready</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

			<span class="n">megaraid_sas_kill_hba</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>
			<span class="n">instance</span><span class="o">-&gt;</span><span class="n">adprecovery</span>	<span class="o">=</span> <span class="n">MEGASAS_HW_CRITICAL_ERROR</span><span class="p">;</span>
			<span class="k">return</span> <span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_LSI_SAS1064R</span><span class="p">)</span> <span class="o">||</span>
			<span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_DELL_PERC5</span><span class="p">)</span> <span class="o">||</span>
			<span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_LSI_VERDE_ZCR</span><span class="p">)</span>
			<span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">consumer</span> <span class="o">=</span> <span class="o">*</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">producer</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">consumer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="o">*</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">producer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">megasas_issue_init_mfi</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>

		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">hba_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">instance</span><span class="o">-&gt;</span><span class="n">adprecovery</span>	<span class="o">=</span> <span class="n">MEGASAS_HBA_OPERATIONAL</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">hba_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">instance</span><span class="o">-&gt;</span><span class="n">instancet</span><span class="o">-&gt;</span><span class="n">enable_intr</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">reg_set</span><span class="p">);</span>

		<span class="n">megasas_issue_pending_cmds_again</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>
		<span class="n">instance</span><span class="o">-&gt;</span><span class="n">issuepend_done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * megasas_deplete_reply_queue -	Processes all completed commands</span>
<span class="cm"> * @instance:				Adapter soft state</span>
<span class="cm"> * @alt_status:				Alternate status to be returned to</span>
<span class="cm"> * 					SCSI mid-layer instead of the status</span>
<span class="cm"> * 					returned by the FW</span>
<span class="cm"> * Note: this must be called with hba lock held</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">megasas_deplete_reply_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span>
					<span class="n">u8</span> <span class="n">alt_status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">mfiStatus</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">fw_state</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">mfiStatus</span> <span class="o">=</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">instancet</span><span class="o">-&gt;</span><span class="n">check_reset</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span>
					<span class="n">instance</span><span class="o">-&gt;</span><span class="n">reg_set</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">mfiStatus</span> <span class="o">=</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">instancet</span><span class="o">-&gt;</span><span class="n">clear_intr</span><span class="p">(</span>
						<span class="n">instance</span><span class="o">-&gt;</span><span class="n">reg_set</span><span class="p">)</span>
						<span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Hardware may not set outbound_intr_status in MSI-X mode */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">msix_vectors</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">mfiStatus</span> <span class="o">=</span> <span class="n">mfiStatus</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">mfiStatus</span> <span class="o">&amp;</span> <span class="n">MFI_INTR_FLAG_FIRMWARE_STATE_CHANGE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">fw_state</span> <span class="o">=</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">instancet</span><span class="o">-&gt;</span><span class="n">read_fw_status_reg</span><span class="p">(</span>
				<span class="n">instance</span><span class="o">-&gt;</span><span class="n">reg_set</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">MFI_STATE_MASK</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">fw_state</span> <span class="o">!=</span> <span class="n">MFI_STATE_FAULT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;megaraid_sas: fw state:%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">fw_state</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">fw_state</span> <span class="o">==</span> <span class="n">MFI_STATE_FAULT</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				<span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">disableOnlineCtrlReset</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;megaraid_sas: wait adp restart</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">((</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span>
					<span class="n">PCI_DEVICE_ID_LSI_SAS1064R</span><span class="p">)</span> <span class="o">||</span>
				<span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span>
					<span class="n">PCI_DEVICE_ID_DELL_PERC5</span><span class="p">)</span> <span class="o">||</span>
				<span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span>
					<span class="n">PCI_DEVICE_ID_LSI_VERDE_ZCR</span><span class="p">))</span> <span class="p">{</span>

				<span class="o">*</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">consumer</span> <span class="o">=</span>
					<span class="n">MEGASAS_ADPRESET_INPROG_SIGN</span><span class="p">;</span>
			<span class="p">}</span>


			<span class="n">instance</span><span class="o">-&gt;</span><span class="n">instancet</span><span class="o">-&gt;</span><span class="n">disable_intr</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">reg_set</span><span class="p">);</span>
			<span class="n">instance</span><span class="o">-&gt;</span><span class="n">adprecovery</span>	<span class="o">=</span> <span class="n">MEGASAS_ADPRESET_SM_INFAULT</span><span class="p">;</span>
			<span class="n">instance</span><span class="o">-&gt;</span><span class="n">issuepend_done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">fw_outstanding</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">megasas_internal_reset_defer_cmds</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>

			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;megasas: fwState=%x, stage:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">fw_state</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">adprecovery</span><span class="p">);</span>

			<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">work_init</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>

		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;megasas: fwstate:%x, dis_OCR=%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">fw_state</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">disableOnlineCtrlReset</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">tasklet_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">isr_tasklet</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/**</span>
<span class="cm"> * megasas_isr - isr entry point</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">megasas_isr</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">devp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">megasas_irq_context</span> <span class="o">*</span><span class="n">irq_context</span> <span class="o">=</span> <span class="n">devp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span> <span class="o">=</span> <span class="n">irq_context</span><span class="o">-&gt;</span><span class="n">instance</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">irqreturn_t</span>	<span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">fw_reset_no_pci_access</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">hba_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span>  <span class="n">megasas_deplete_reply_queue</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">DID_OK</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">hba_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * megasas_transition_to_ready -	Move the FW to READY state</span>
<span class="cm"> * @instance:				Adapter soft state</span>
<span class="cm"> *</span>
<span class="cm"> * During the initialization, FW passes can potentially be in any one of</span>
<span class="cm"> * several possible states. If the FW in operational, waiting-for-handshake</span>
<span class="cm"> * states, driver must take steps to bring it to ready state. Otherwise, it</span>
<span class="cm"> * has to wait for the ready state.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">megasas_transition_to_ready</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ocr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">max_wait</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">fw_state</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">cur_state</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">abs_state</span><span class="p">,</span> <span class="n">curr_abs_state</span><span class="p">;</span>

	<span class="n">fw_state</span> <span class="o">=</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">instancet</span><span class="o">-&gt;</span><span class="n">read_fw_status_reg</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">reg_set</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">MFI_STATE_MASK</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fw_state</span> <span class="o">!=</span> <span class="n">MFI_STATE_READY</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;megasas: Waiting for FW to come to ready&quot;</span>
		       <span class="s">&quot; state</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">fw_state</span> <span class="o">!=</span> <span class="n">MFI_STATE_READY</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">abs_state</span> <span class="o">=</span>
		<span class="n">instance</span><span class="o">-&gt;</span><span class="n">instancet</span><span class="o">-&gt;</span><span class="n">read_fw_status_reg</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">reg_set</span><span class="p">);</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">fw_state</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">case</span> <span class="n">MFI_STATE_FAULT</span>:
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;megasas: FW in FAULT state!!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ocr</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">max_wait</span> <span class="o">=</span> <span class="n">MEGASAS_RESET_WAIT_TIME</span><span class="p">;</span>
				<span class="n">cur_state</span> <span class="o">=</span> <span class="n">MFI_STATE_FAULT</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">MFI_STATE_WAIT_HANDSHAKE</span>:
			<span class="cm">/*</span>
<span class="cm">			 * Set the CLR bit in inbound doorbell</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span>
				<span class="n">PCI_DEVICE_ID_LSI_SAS0073SKINNY</span><span class="p">)</span> <span class="o">||</span>
				<span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span>
				 <span class="n">PCI_DEVICE_ID_LSI_SAS0071SKINNY</span><span class="p">)</span> <span class="o">||</span>
				<span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span>
				 <span class="n">PCI_DEVICE_ID_LSI_FUSION</span><span class="p">)</span> <span class="o">||</span>
				<span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span>
				<span class="n">PCI_DEVICE_ID_LSI_INVADER</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">writel</span><span class="p">(</span>
				  <span class="n">MFI_INIT_CLEAR_HANDSHAKE</span><span class="o">|</span><span class="n">MFI_INIT_HOTPLUG</span><span class="p">,</span>
				  <span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">reg_set</span><span class="o">-&gt;</span><span class="n">doorbell</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">writel</span><span class="p">(</span>
				    <span class="n">MFI_INIT_CLEAR_HANDSHAKE</span><span class="o">|</span><span class="n">MFI_INIT_HOTPLUG</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">reg_set</span><span class="o">-&gt;</span><span class="n">inbound_doorbell</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="n">max_wait</span> <span class="o">=</span> <span class="n">MEGASAS_RESET_WAIT_TIME</span><span class="p">;</span>
			<span class="n">cur_state</span> <span class="o">=</span> <span class="n">MFI_STATE_WAIT_HANDSHAKE</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">MFI_STATE_BOOT_MESSAGE_PENDING</span>:
			<span class="k">if</span> <span class="p">((</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span>
			     <span class="n">PCI_DEVICE_ID_LSI_SAS0073SKINNY</span><span class="p">)</span> <span class="o">||</span>
				<span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span>
				 <span class="n">PCI_DEVICE_ID_LSI_SAS0071SKINNY</span><span class="p">)</span> <span class="o">||</span>
			    <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span>
			     <span class="n">PCI_DEVICE_ID_LSI_FUSION</span><span class="p">)</span> <span class="o">||</span>
			    <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span>
			     <span class="n">PCI_DEVICE_ID_LSI_INVADER</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">writel</span><span class="p">(</span><span class="n">MFI_INIT_HOTPLUG</span><span class="p">,</span>
				       <span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">reg_set</span><span class="o">-&gt;</span><span class="n">doorbell</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="n">writel</span><span class="p">(</span><span class="n">MFI_INIT_HOTPLUG</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">reg_set</span><span class="o">-&gt;</span><span class="n">inbound_doorbell</span><span class="p">);</span>

			<span class="n">max_wait</span> <span class="o">=</span> <span class="n">MEGASAS_RESET_WAIT_TIME</span><span class="p">;</span>
			<span class="n">cur_state</span> <span class="o">=</span> <span class="n">MFI_STATE_BOOT_MESSAGE_PENDING</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">MFI_STATE_OPERATIONAL</span>:
			<span class="cm">/*</span>
<span class="cm">			 * Bring it to READY state; assuming max wait 10 secs</span>
<span class="cm">			 */</span>
			<span class="n">instance</span><span class="o">-&gt;</span><span class="n">instancet</span><span class="o">-&gt;</span><span class="n">disable_intr</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">reg_set</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span>
				<span class="n">PCI_DEVICE_ID_LSI_SAS0073SKINNY</span><span class="p">)</span> <span class="o">||</span>
				<span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span>
				<span class="n">PCI_DEVICE_ID_LSI_SAS0071SKINNY</span><span class="p">)</span>  <span class="o">||</span>
				<span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span>
					<span class="o">==</span> <span class="n">PCI_DEVICE_ID_LSI_FUSION</span><span class="p">)</span> <span class="o">||</span>
				<span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span>
					<span class="o">==</span> <span class="n">PCI_DEVICE_ID_LSI_INVADER</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">writel</span><span class="p">(</span><span class="n">MFI_RESET_FLAGS</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">reg_set</span><span class="o">-&gt;</span><span class="n">doorbell</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span>
				    <span class="n">PCI_DEVICE_ID_LSI_FUSION</span><span class="p">)</span> <span class="o">||</span>
				    <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span>
				     <span class="n">PCI_DEVICE_ID_LSI_INVADER</span><span class="p">))</span> <span class="p">{</span>
					<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">);</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">20</span><span class="p">)</span> <span class="p">{</span>
						<span class="k">if</span> <span class="p">(</span><span class="n">readl</span><span class="p">(</span>
							    <span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span>
							    <span class="n">reg_set</span><span class="o">-&gt;</span>
							    <span class="n">doorbell</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
							<span class="n">msleep</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
						<span class="k">else</span>
							<span class="k">break</span><span class="p">;</span>
					<span class="p">}</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="n">writel</span><span class="p">(</span><span class="n">MFI_RESET_FLAGS</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">reg_set</span><span class="o">-&gt;</span><span class="n">inbound_doorbell</span><span class="p">);</span>

			<span class="n">max_wait</span> <span class="o">=</span> <span class="n">MEGASAS_RESET_WAIT_TIME</span><span class="p">;</span>
			<span class="n">cur_state</span> <span class="o">=</span> <span class="n">MFI_STATE_OPERATIONAL</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">MFI_STATE_UNDEFINED</span>:
			<span class="cm">/*</span>
<span class="cm">			 * This state should not last for more than 2 seconds</span>
<span class="cm">			 */</span>
			<span class="n">max_wait</span> <span class="o">=</span> <span class="n">MEGASAS_RESET_WAIT_TIME</span><span class="p">;</span>
			<span class="n">cur_state</span> <span class="o">=</span> <span class="n">MFI_STATE_UNDEFINED</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">MFI_STATE_BB_INIT</span>:
			<span class="n">max_wait</span> <span class="o">=</span> <span class="n">MEGASAS_RESET_WAIT_TIME</span><span class="p">;</span>
			<span class="n">cur_state</span> <span class="o">=</span> <span class="n">MFI_STATE_BB_INIT</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">MFI_STATE_FW_INIT</span>:
			<span class="n">max_wait</span> <span class="o">=</span> <span class="n">MEGASAS_RESET_WAIT_TIME</span><span class="p">;</span>
			<span class="n">cur_state</span> <span class="o">=</span> <span class="n">MFI_STATE_FW_INIT</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">MFI_STATE_FW_INIT_2</span>:
			<span class="n">max_wait</span> <span class="o">=</span> <span class="n">MEGASAS_RESET_WAIT_TIME</span><span class="p">;</span>
			<span class="n">cur_state</span> <span class="o">=</span> <span class="n">MFI_STATE_FW_INIT_2</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">MFI_STATE_DEVICE_SCAN</span>:
			<span class="n">max_wait</span> <span class="o">=</span> <span class="n">MEGASAS_RESET_WAIT_TIME</span><span class="p">;</span>
			<span class="n">cur_state</span> <span class="o">=</span> <span class="n">MFI_STATE_DEVICE_SCAN</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">MFI_STATE_FLUSH_CACHE</span>:
			<span class="n">max_wait</span> <span class="o">=</span> <span class="n">MEGASAS_RESET_WAIT_TIME</span><span class="p">;</span>
			<span class="n">cur_state</span> <span class="o">=</span> <span class="n">MFI_STATE_FLUSH_CACHE</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="nl">default:</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;megasas: Unknown state 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">fw_state</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * The cur_state should not last for more than max_wait secs</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">max_wait</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">fw_state</span> <span class="o">=</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">instancet</span><span class="o">-&gt;</span><span class="n">read_fw_status_reg</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">reg_set</span><span class="p">)</span> <span class="o">&amp;</span>
					<span class="n">MFI_STATE_MASK</span> <span class="p">;</span>
		<span class="n">curr_abs_state</span> <span class="o">=</span>
		<span class="n">instance</span><span class="o">-&gt;</span><span class="n">instancet</span><span class="o">-&gt;</span><span class="n">read_fw_status_reg</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">reg_set</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">abs_state</span> <span class="o">==</span> <span class="n">curr_abs_state</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">msleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Return error if fw_state hasn&#39;t changed after max_wait</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">curr_abs_state</span> <span class="o">==</span> <span class="n">abs_state</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;FW state [%d] hasn&#39;t changed &quot;</span>
			       <span class="s">&quot;in %d secs</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fw_state</span><span class="p">,</span> <span class="n">max_wait</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;megasas: FW now in Ready state</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * megasas_teardown_frame_pool -	Destroy the cmd frame DMA pool</span>
<span class="cm"> * @instance:				Adapter soft state</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">megasas_teardown_frame_pool</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">max_cmd</span> <span class="o">=</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">max_mfi_cmds</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">megasas_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">frame_dma_pool</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Return all frames to pool</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">max_cmd</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">cmd</span> <span class="o">=</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">cmd_list</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">frame</span><span class="p">)</span>
			<span class="n">pci_pool_free</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">frame_dma_pool</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">frame</span><span class="p">,</span>
				      <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">frame_phys_addr</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sense</span><span class="p">)</span>
			<span class="n">pci_pool_free</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">sense_dma_pool</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sense</span><span class="p">,</span>
				      <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sense_phys_addr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now destroy the pool itself</span>
<span class="cm">	 */</span>
	<span class="n">pci_pool_destroy</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">frame_dma_pool</span><span class="p">);</span>
	<span class="n">pci_pool_destroy</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">sense_dma_pool</span><span class="p">);</span>

	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">frame_dma_pool</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">sense_dma_pool</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * megasas_create_frame_pool -	Creates DMA pool for cmd frames</span>
<span class="cm"> * @instance:			Adapter soft state</span>
<span class="cm"> *</span>
<span class="cm"> * Each command packet has an embedded DMA memory buffer that is used for</span>
<span class="cm"> * filling MFI frame and the SG list that immediately follows the frame. This</span>
<span class="cm"> * function creates those DMA memory buffers for each command packet by using</span>
<span class="cm"> * PCI pool facility.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">megasas_create_frame_pool</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">max_cmd</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sge_sz</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sgl_sz</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">total_sz</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">frame_count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">megasas_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>

	<span class="n">max_cmd</span> <span class="o">=</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">max_mfi_cmds</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Size of our frame is 64 bytes for MFI frame, followed by max SG</span>
<span class="cm">	 * elements and finally SCSI_SENSE_BUFFERSIZE bytes for sense buffer</span>
<span class="cm">	 */</span>
	<span class="n">sge_sz</span> <span class="o">=</span> <span class="p">(</span><span class="n">IS_DMA64</span><span class="p">)</span> <span class="o">?</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_sge64</span><span class="p">)</span> <span class="o">:</span>
	    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_sge32</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">flag_ieee</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sge_sz</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_sge_skinny</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Calculated the number of 64byte frames required for SGL</span>
<span class="cm">	 */</span>
	<span class="n">sgl_sz</span> <span class="o">=</span> <span class="n">sge_sz</span> <span class="o">*</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">max_num_sge</span><span class="p">;</span>
	<span class="n">frame_count</span> <span class="o">=</span> <span class="p">(</span><span class="n">sgl_sz</span> <span class="o">+</span> <span class="n">MEGAMFI_FRAME_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">MEGAMFI_FRAME_SIZE</span><span class="p">;</span>
	<span class="n">frame_count</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We need one extra frame for the MFI command</span>
<span class="cm">	 */</span>
	<span class="n">frame_count</span><span class="o">++</span><span class="p">;</span>

	<span class="n">total_sz</span> <span class="o">=</span> <span class="n">MEGAMFI_FRAME_SIZE</span> <span class="o">*</span> <span class="n">frame_count</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Use DMA pool facility provided by PCI layer</span>
<span class="cm">	 */</span>
	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">frame_dma_pool</span> <span class="o">=</span> <span class="n">pci_pool_create</span><span class="p">(</span><span class="s">&quot;megasas frame pool&quot;</span><span class="p">,</span>
						   <span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">total_sz</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span>
						   <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">frame_dma_pool</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;megasas: failed to setup frame pool</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">sense_dma_pool</span> <span class="o">=</span> <span class="n">pci_pool_create</span><span class="p">(</span><span class="s">&quot;megasas sense pool&quot;</span><span class="p">,</span>
						   <span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">sense_dma_pool</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;megasas: failed to setup sense pool</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="n">pci_pool_destroy</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">frame_dma_pool</span><span class="p">);</span>
		<span class="n">instance</span><span class="o">-&gt;</span><span class="n">frame_dma_pool</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate and attach a frame to each of the commands in cmd_list.</span>
<span class="cm">	 * By making cmd-&gt;index as the context instead of the &amp;cmd, we can</span>
<span class="cm">	 * always use 32bit context regardless of the architecture</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">max_cmd</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">cmd</span> <span class="o">=</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">cmd_list</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">frame</span> <span class="o">=</span> <span class="n">pci_pool_alloc</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">frame_dma_pool</span><span class="p">,</span>
					    <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">frame_phys_addr</span><span class="p">);</span>

		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sense</span> <span class="o">=</span> <span class="n">pci_pool_alloc</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">sense_dma_pool</span><span class="p">,</span>
					    <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sense_phys_addr</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * megasas_teardown_frame_pool() takes care of freeing</span>
<span class="cm">		 * whatever has been allocated</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">frame</span> <span class="o">||</span> <span class="o">!</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sense</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;megasas: pci_pool_alloc failed </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">megasas_teardown_frame_pool</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">memset</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">frame</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">total_sz</span><span class="p">);</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">context</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">pad_0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">!=</span> <span class="n">PCI_DEVICE_ID_LSI_FUSION</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">!=</span> <span class="n">PCI_DEVICE_ID_LSI_INVADER</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">reset_devices</span><span class="p">))</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">MFI_CMD_INVALID</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * megasas_free_cmds -	Free all the cmds in the free cmd pool</span>
<span class="cm"> * @instance:		Adapter soft state</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">megasas_free_cmds</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="cm">/* First free the MFI frame pool */</span>
	<span class="n">megasas_teardown_frame_pool</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>

	<span class="cm">/* Free all the commands in the cmd_list */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">max_mfi_cmds</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>

		<span class="n">kfree</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">cmd_list</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="cm">/* Free the cmd_list buffer itself */</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">cmd_list</span><span class="p">);</span>
	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">cmd_list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">cmd_pool</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * megasas_alloc_cmds -	Allocates the command packets</span>
<span class="cm"> * @instance:		Adapter soft state</span>
<span class="cm"> *</span>
<span class="cm"> * Each command that is issued to the FW, whether IO commands from the OS or</span>
<span class="cm"> * internal commands like IOCTLs, are wrapped in local data structure called</span>
<span class="cm"> * megasas_cmd. The frame embedded in this megasas_cmd is actually issued to</span>
<span class="cm"> * the FW.</span>
<span class="cm"> *</span>
<span class="cm"> * Each frame has a 32-bit field called context (tag). This context is used</span>
<span class="cm"> * to get back the megasas_cmd from the frame when a frame gets completed in</span>
<span class="cm"> * the ISR. Typically the address of the megasas_cmd itself would be used as</span>
<span class="cm"> * the context. But we wanted to keep the differences between 32 and 64 bit</span>
<span class="cm"> * systems to the mininum. We always use 32 bit integers for the context. In</span>
<span class="cm"> * this driver, the 32 bit values are the indices into an array cmd_list.</span>
<span class="cm"> * This array is used only to look up the megasas_cmd given the context. The</span>
<span class="cm"> * free commands themselves are maintained in a linked list called cmd_pool.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">megasas_alloc_cmds</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">max_cmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">megasas_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>

	<span class="n">max_cmd</span> <span class="o">=</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">max_mfi_cmds</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * instance-&gt;cmd_list is an array of struct megasas_cmd pointers.</span>
<span class="cm">	 * Allocate the dynamic array first and then allocate individual</span>
<span class="cm">	 * commands.</span>
<span class="cm">	 */</span>
	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">cmd_list</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">max_cmd</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_cmd</span><span class="o">*</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">cmd_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;megasas: out of memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">cmd_list</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_cmd</span> <span class="o">*</span><span class="p">)</span> <span class="o">*</span><span class="n">max_cmd</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">max_cmd</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">instance</span><span class="o">-&gt;</span><span class="n">cmd_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_cmd</span><span class="p">),</span>
						<span class="n">GFP_KERNEL</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">cmd_list</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>

			<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">cmd_list</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>

			<span class="n">kfree</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">cmd_list</span><span class="p">);</span>
			<span class="n">instance</span><span class="o">-&gt;</span><span class="n">cmd_list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Add all the commands to command pool (instance-&gt;cmd_pool)</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">max_cmd</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cmd</span> <span class="o">=</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">cmd_list</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_cmd</span><span class="p">));</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scmd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">instance</span> <span class="o">=</span> <span class="n">instance</span><span class="p">;</span>

		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">cmd_pool</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Create a frame pool and assign one frame to each cmd</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">megasas_create_frame_pool</span><span class="p">(</span><span class="n">instance</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;megasas: Error creating frame DMA pool</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">megasas_free_cmds</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * megasas_get_pd_list_info -	Returns FW&#39;s pd_list structure</span>
<span class="cm"> * @instance:				Adapter soft state</span>
<span class="cm"> * @pd_list:				pd_list structure</span>
<span class="cm"> *</span>
<span class="cm"> * Issues an internal command (DCMD) to get the FW&#39;s controller PD</span>
<span class="cm"> * list structure.  This information is mainly used to find out SYSTEM</span>
<span class="cm"> * supported by the FW.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">megasas_get_pd_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pd_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">megasas_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">megasas_dcmd_frame</span> <span class="o">*</span><span class="n">dcmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">MR_PD_LIST</span> <span class="o">*</span><span class="n">ci</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">MR_PD_ADDRESS</span> <span class="o">*</span><span class="n">pd_addr</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">ci_h</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">cmd</span> <span class="o">=</span> <span class="n">megasas_get_cmd</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;megasas (get_pd_list): Failed to get cmd</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dcmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">dcmd</span><span class="p">;</span>

	<span class="n">ci</span> <span class="o">=</span> <span class="n">pci_alloc_consistent</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
		  <span class="n">MEGASAS_MAX_PD</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">MR_PD_LIST</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">ci_h</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ci</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;Failed to alloc mem for pd_list</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">megasas_return_cmd</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ci</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">dcmd</span><span class="o">-&gt;</span><span class="n">mbox</span><span class="p">.</span><span class="n">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MFI_MBOX_SIZE</span><span class="p">);</span>

	<span class="n">dcmd</span><span class="o">-&gt;</span><span class="n">mbox</span><span class="p">.</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">MR_PD_QUERY_TYPE_EXPOSED_TO_HOST</span><span class="p">;</span>
	<span class="n">dcmd</span><span class="o">-&gt;</span><span class="n">mbox</span><span class="p">.</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dcmd</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">MFI_CMD_DCMD</span><span class="p">;</span>
	<span class="n">dcmd</span><span class="o">-&gt;</span><span class="n">cmd_status</span> <span class="o">=</span> <span class="mh">0xFF</span><span class="p">;</span>
	<span class="n">dcmd</span><span class="o">-&gt;</span><span class="n">sge_count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">dcmd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">MFI_FRAME_DIR_READ</span><span class="p">;</span>
	<span class="n">dcmd</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dcmd</span><span class="o">-&gt;</span><span class="n">pad_0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dcmd</span><span class="o">-&gt;</span><span class="n">data_xfer_len</span> <span class="o">=</span> <span class="n">MEGASAS_MAX_PD</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">MR_PD_LIST</span><span class="p">);</span>
	<span class="n">dcmd</span><span class="o">-&gt;</span><span class="n">opcode</span> <span class="o">=</span> <span class="n">MR_DCMD_PD_LIST_QUERY</span><span class="p">;</span>
	<span class="n">dcmd</span><span class="o">-&gt;</span><span class="n">sgl</span><span class="p">.</span><span class="n">sge32</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">phys_addr</span> <span class="o">=</span> <span class="n">ci_h</span><span class="p">;</span>
	<span class="n">dcmd</span><span class="o">-&gt;</span><span class="n">sgl</span><span class="p">.</span><span class="n">sge32</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">length</span> <span class="o">=</span> <span class="n">MEGASAS_MAX_PD</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">MR_PD_LIST</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">megasas_issue_polled</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">cmd</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	* the following function will get the instance PD LIST.</span>
<span class="cm">	*/</span>

	<span class="n">pd_addr</span> <span class="o">=</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">&lt;</span>
		  <span class="p">(</span><span class="n">MEGASAS_MAX_PD_CHANNELS</span> <span class="o">*</span> <span class="n">MEGASAS_MAX_DEV_PER_CHANNEL</span><span class="p">)))</span> <span class="p">{</span>

		<span class="n">memset</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pd_list</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			<span class="n">MEGASAS_MAX_PD</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_pd_list</span><span class="p">));</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">pd_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pd_index</span> <span class="o">&lt;</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span> <span class="n">pd_index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

			<span class="n">instance</span><span class="o">-&gt;</span><span class="n">pd_list</span><span class="p">[</span><span class="n">pd_addr</span><span class="o">-&gt;</span><span class="n">deviceId</span><span class="p">].</span><span class="n">tid</span>	<span class="o">=</span>
							<span class="n">pd_addr</span><span class="o">-&gt;</span><span class="n">deviceId</span><span class="p">;</span>
			<span class="n">instance</span><span class="o">-&gt;</span><span class="n">pd_list</span><span class="p">[</span><span class="n">pd_addr</span><span class="o">-&gt;</span><span class="n">deviceId</span><span class="p">].</span><span class="n">driveType</span>	<span class="o">=</span>
							<span class="n">pd_addr</span><span class="o">-&gt;</span><span class="n">scsiDevType</span><span class="p">;</span>
			<span class="n">instance</span><span class="o">-&gt;</span><span class="n">pd_list</span><span class="p">[</span><span class="n">pd_addr</span><span class="o">-&gt;</span><span class="n">deviceId</span><span class="p">].</span><span class="n">driveState</span>	<span class="o">=</span>
							<span class="n">MR_PD_STATE_SYSTEM</span><span class="p">;</span>
			<span class="n">pd_addr</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
				<span class="n">MEGASAS_MAX_PD</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">MR_PD_LIST</span><span class="p">),</span>
				<span class="n">ci</span><span class="p">,</span> <span class="n">ci_h</span><span class="p">);</span>
	<span class="n">megasas_return_cmd</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * megasas_get_ld_list_info -	Returns FW&#39;s ld_list structure</span>
<span class="cm"> * @instance:				Adapter soft state</span>
<span class="cm"> * @ld_list:				ld_list structure</span>
<span class="cm"> *</span>
<span class="cm"> * Issues an internal command (DCMD) to get the FW&#39;s controller PD</span>
<span class="cm"> * list structure.  This information is mainly used to find out SYSTEM</span>
<span class="cm"> * supported by the FW.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">megasas_get_ld_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ld_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ids</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">megasas_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">megasas_dcmd_frame</span> <span class="o">*</span><span class="n">dcmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">MR_LD_LIST</span> <span class="o">*</span><span class="n">ci</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">ci_h</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">cmd</span> <span class="o">=</span> <span class="n">megasas_get_cmd</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;megasas_get_ld_list: Failed to get cmd</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dcmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">dcmd</span><span class="p">;</span>

	<span class="n">ci</span> <span class="o">=</span> <span class="n">pci_alloc_consistent</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">MR_LD_LIST</span><span class="p">),</span>
				<span class="o">&amp;</span><span class="n">ci_h</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ci</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;Failed to alloc mem in get_ld_list</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">megasas_return_cmd</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ci</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">dcmd</span><span class="o">-&gt;</span><span class="n">mbox</span><span class="p">.</span><span class="n">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MFI_MBOX_SIZE</span><span class="p">);</span>

	<span class="n">dcmd</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">MFI_CMD_DCMD</span><span class="p">;</span>
	<span class="n">dcmd</span><span class="o">-&gt;</span><span class="n">cmd_status</span> <span class="o">=</span> <span class="mh">0xFF</span><span class="p">;</span>
	<span class="n">dcmd</span><span class="o">-&gt;</span><span class="n">sge_count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">dcmd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">MFI_FRAME_DIR_READ</span><span class="p">;</span>
	<span class="n">dcmd</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dcmd</span><span class="o">-&gt;</span><span class="n">data_xfer_len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">MR_LD_LIST</span><span class="p">);</span>
	<span class="n">dcmd</span><span class="o">-&gt;</span><span class="n">opcode</span> <span class="o">=</span> <span class="n">MR_DCMD_LD_GET_LIST</span><span class="p">;</span>
	<span class="n">dcmd</span><span class="o">-&gt;</span><span class="n">sgl</span><span class="p">.</span><span class="n">sge32</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">phys_addr</span> <span class="o">=</span> <span class="n">ci_h</span><span class="p">;</span>
	<span class="n">dcmd</span><span class="o">-&gt;</span><span class="n">sgl</span><span class="p">.</span><span class="n">sge32</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">length</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">MR_LD_LIST</span><span class="p">);</span>
	<span class="n">dcmd</span><span class="o">-&gt;</span><span class="n">pad_0</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">megasas_issue_polled</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">cmd</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* the following function will get the instance PD LIST */</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">ldCount</span> <span class="o">&lt;=</span> <span class="n">MAX_LOGICAL_DRIVES</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">ld_ids</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="n">MEGASAS_MAX_LD_IDS</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">ld_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ld_index</span> <span class="o">&lt;</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">ldCount</span><span class="p">;</span> <span class="n">ld_index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">ldList</span><span class="p">[</span><span class="n">ld_index</span><span class="p">].</span><span class="n">state</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ids</span> <span class="o">=</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">ldList</span><span class="p">[</span><span class="n">ld_index</span><span class="p">].</span><span class="n">ref</span><span class="p">.</span><span class="n">targetId</span><span class="p">;</span>
				<span class="n">instance</span><span class="o">-&gt;</span><span class="n">ld_ids</span><span class="p">[</span><span class="n">ids</span><span class="p">]</span> <span class="o">=</span>
					<span class="n">ci</span><span class="o">-&gt;</span><span class="n">ldList</span><span class="p">[</span><span class="n">ld_index</span><span class="p">].</span><span class="n">ref</span><span class="p">.</span><span class="n">targetId</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">MR_LD_LIST</span><span class="p">),</span>
				<span class="n">ci</span><span class="p">,</span>
				<span class="n">ci_h</span><span class="p">);</span>

	<span class="n">megasas_return_cmd</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * megasas_get_controller_info -	Returns FW&#39;s controller structure</span>
<span class="cm"> * @instance:				Adapter soft state</span>
<span class="cm"> * @ctrl_info:				Controller information structure</span>
<span class="cm"> *</span>
<span class="cm"> * Issues an internal command (DCMD) to get the FW&#39;s controller structure.</span>
<span class="cm"> * This information is mainly used to find out the maximum IO transfer per</span>
<span class="cm"> * command supported by the FW.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">megasas_get_ctrl_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">megasas_ctrl_info</span> <span class="o">*</span><span class="n">ctrl_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">megasas_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">megasas_dcmd_frame</span> <span class="o">*</span><span class="n">dcmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">megasas_ctrl_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">ci_h</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">cmd</span> <span class="o">=</span> <span class="n">megasas_get_cmd</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;megasas: Failed to get a free cmd</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dcmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">dcmd</span><span class="p">;</span>

	<span class="n">ci</span> <span class="o">=</span> <span class="n">pci_alloc_consistent</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
				  <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_ctrl_info</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">ci_h</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ci</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;Failed to alloc mem for ctrl info</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">megasas_return_cmd</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ci</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">dcmd</span><span class="o">-&gt;</span><span class="n">mbox</span><span class="p">.</span><span class="n">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MFI_MBOX_SIZE</span><span class="p">);</span>

	<span class="n">dcmd</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">MFI_CMD_DCMD</span><span class="p">;</span>
	<span class="n">dcmd</span><span class="o">-&gt;</span><span class="n">cmd_status</span> <span class="o">=</span> <span class="mh">0xFF</span><span class="p">;</span>
	<span class="n">dcmd</span><span class="o">-&gt;</span><span class="n">sge_count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">dcmd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">MFI_FRAME_DIR_READ</span><span class="p">;</span>
	<span class="n">dcmd</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dcmd</span><span class="o">-&gt;</span><span class="n">pad_0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dcmd</span><span class="o">-&gt;</span><span class="n">data_xfer_len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_ctrl_info</span><span class="p">);</span>
	<span class="n">dcmd</span><span class="o">-&gt;</span><span class="n">opcode</span> <span class="o">=</span> <span class="n">MR_DCMD_CTRL_GET_INFO</span><span class="p">;</span>
	<span class="n">dcmd</span><span class="o">-&gt;</span><span class="n">sgl</span><span class="p">.</span><span class="n">sge32</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">phys_addr</span> <span class="o">=</span> <span class="n">ci_h</span><span class="p">;</span>
	<span class="n">dcmd</span><span class="o">-&gt;</span><span class="n">sgl</span><span class="p">.</span><span class="n">sge32</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">length</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_ctrl_info</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">megasas_issue_polled</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">cmd</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">ctrl_info</span><span class="p">,</span> <span class="n">ci</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_ctrl_info</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_ctrl_info</span><span class="p">),</span>
			    <span class="n">ci</span><span class="p">,</span> <span class="n">ci_h</span><span class="p">);</span>

	<span class="n">megasas_return_cmd</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * megasas_issue_init_mfi -	Initializes the FW</span>
<span class="cm"> * @instance:		Adapter soft state</span>
<span class="cm"> *</span>
<span class="cm"> * Issues the INIT MFI cmd</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">megasas_issue_init_mfi</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">context</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">megasas_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">megasas_init_frame</span> <span class="o">*</span><span class="n">init_frame</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">megasas_init_queue_info</span> <span class="o">*</span><span class="n">initq_info</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">init_frame_h</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">initq_info_h</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Prepare a init frame. Note the init frame points to queue info</span>
<span class="cm">	 * structure. Each frame has SGL allocated after first 64 bytes. For</span>
<span class="cm">	 * this frame - since we don&#39;t need any SGL - we use SGL&#39;s space as</span>
<span class="cm">	 * queue info structure</span>
<span class="cm">	 *</span>
<span class="cm">	 * We will not get a NULL command below. We just created the pool.</span>
<span class="cm">	 */</span>
	<span class="n">cmd</span> <span class="o">=</span> <span class="n">megasas_get_cmd</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>

	<span class="n">init_frame</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">megasas_init_frame</span> <span class="o">*</span><span class="p">)</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">frame</span><span class="p">;</span>
	<span class="n">initq_info</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">megasas_init_queue_info</span> <span class="o">*</span><span class="p">)</span>
		<span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">init_frame</span> <span class="o">+</span> <span class="mi">64</span><span class="p">);</span>

	<span class="n">init_frame_h</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">frame_phys_addr</span><span class="p">;</span>
	<span class="n">initq_info_h</span> <span class="o">=</span> <span class="n">init_frame_h</span> <span class="o">+</span> <span class="mi">64</span><span class="p">;</span>

	<span class="n">context</span> <span class="o">=</span> <span class="n">init_frame</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">init_frame</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MEGAMFI_FRAME_SIZE</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">initq_info</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_init_queue_info</span><span class="p">));</span>
	<span class="n">init_frame</span><span class="o">-&gt;</span><span class="n">context</span> <span class="o">=</span> <span class="n">context</span><span class="p">;</span>

	<span class="n">initq_info</span><span class="o">-&gt;</span><span class="n">reply_queue_entries</span> <span class="o">=</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">max_fw_cmds</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">initq_info</span><span class="o">-&gt;</span><span class="n">reply_queue_start_phys_addr_lo</span> <span class="o">=</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">reply_queue_h</span><span class="p">;</span>

	<span class="n">initq_info</span><span class="o">-&gt;</span><span class="n">producer_index_phys_addr_lo</span> <span class="o">=</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">producer_h</span><span class="p">;</span>
	<span class="n">initq_info</span><span class="o">-&gt;</span><span class="n">consumer_index_phys_addr_lo</span> <span class="o">=</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">consumer_h</span><span class="p">;</span>

	<span class="n">init_frame</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">MFI_CMD_INIT</span><span class="p">;</span>
	<span class="n">init_frame</span><span class="o">-&gt;</span><span class="n">cmd_status</span> <span class="o">=</span> <span class="mh">0xFF</span><span class="p">;</span>
	<span class="n">init_frame</span><span class="o">-&gt;</span><span class="n">queue_info_new_phys_addr_lo</span> <span class="o">=</span> <span class="n">initq_info_h</span><span class="p">;</span>

	<span class="n">init_frame</span><span class="o">-&gt;</span><span class="n">data_xfer_len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_init_queue_info</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * disable the intr before firing the init frame to FW</span>
<span class="cm">	 */</span>
	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">instancet</span><span class="o">-&gt;</span><span class="n">disable_intr</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">reg_set</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Issue the init frame in polled mode</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">megasas_issue_polled</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">cmd</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;megasas: Failed to init firmware</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">megasas_return_cmd</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail_fw_init</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">megasas_return_cmd</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fail_fw_init:</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span>
<span class="nf">megasas_init_adapter_mfi</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">megasas_register_set</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">reg_set</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">context_sz</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reply_q_sz</span><span class="p">;</span>

	<span class="n">reg_set</span> <span class="o">=</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">reg_set</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Get various operational parameters from status register</span>
<span class="cm">	 */</span>
	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">max_fw_cmds</span> <span class="o">=</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">instancet</span><span class="o">-&gt;</span><span class="n">read_fw_status_reg</span><span class="p">(</span><span class="n">reg_set</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x00FFFF</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Reduce the max supported cmds by 1. This is to ensure that the</span>
<span class="cm">	 * reply_q_sz (1 more than the max cmd that driver may send)</span>
<span class="cm">	 * does not exceed max cmds that the FW can support</span>
<span class="cm">	 */</span>
	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">max_fw_cmds</span> <span class="o">=</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">max_fw_cmds</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">max_mfi_cmds</span> <span class="o">=</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">max_fw_cmds</span><span class="p">;</span>
	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">max_num_sge</span> <span class="o">=</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">instancet</span><span class="o">-&gt;</span><span class="n">read_fw_status_reg</span><span class="p">(</span><span class="n">reg_set</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF0000</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
					<span class="mh">0x10</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Create a pool of commands</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">megasas_alloc_cmds</span><span class="p">(</span><span class="n">instance</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">fail_alloc_cmds</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate memory for reply queue. Length of reply queue should</span>
<span class="cm">	 * be _one_ more than the maximum commands handled by the firmware.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note: When FW completes commands, it places corresponding contex</span>
<span class="cm">	 * values in this circular reply queue. This circular queue is a fairly</span>
<span class="cm">	 * typical producer-consumer queue. FW is the producer (of completed</span>
<span class="cm">	 * commands) and the driver is the consumer.</span>
<span class="cm">	 */</span>
	<span class="n">context_sz</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">);</span>
	<span class="n">reply_q_sz</span> <span class="o">=</span> <span class="n">context_sz</span> <span class="o">*</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">max_fw_cmds</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">reply_queue</span> <span class="o">=</span> <span class="n">pci_alloc_consistent</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
						     <span class="n">reply_q_sz</span><span class="p">,</span>
						     <span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">reply_queue_h</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">reply_queue</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;megasas: Out of DMA mem for reply queue</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail_reply_queue</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">megasas_issue_init_mfi</span><span class="p">(</span><span class="n">instance</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">fail_fw_init</span><span class="p">;</span>

	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">fw_support_ieee</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">fw_support_ieee</span> <span class="o">=</span>
		<span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">instancet</span><span class="o">-&gt;</span><span class="n">read_fw_status_reg</span><span class="p">(</span><span class="n">reg_set</span><span class="p">)</span> <span class="o">&amp;</span>
		<span class="mh">0x04000000</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;megasas_init_mfi: fw_support_ieee=%d&quot;</span><span class="p">,</span>
			<span class="n">instance</span><span class="o">-&gt;</span><span class="n">fw_support_ieee</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">fw_support_ieee</span><span class="p">)</span>
		<span class="n">instance</span><span class="o">-&gt;</span><span class="n">flag_ieee</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fail_fw_init:</span>

	<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">reply_q_sz</span><span class="p">,</span>
			    <span class="n">instance</span><span class="o">-&gt;</span><span class="n">reply_queue</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">reply_queue_h</span><span class="p">);</span>
<span class="nl">fail_reply_queue:</span>
	<span class="n">megasas_free_cmds</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>

<span class="nl">fail_alloc_cmds:</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * megasas_init_fw -	Initializes the FW</span>
<span class="cm"> * @instance:		Adapter soft state</span>
<span class="cm"> *</span>
<span class="cm"> * This is the main function for initializing firmware</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">megasas_init_fw</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">max_sectors_1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">max_sectors_2</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tmp_sectors</span><span class="p">,</span> <span class="n">msix_enable</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">megasas_register_set</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">reg_set</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">megasas_ctrl_info</span> <span class="o">*</span><span class="n">ctrl_info</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bar_list</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Find first memory bar */</span>
	<span class="n">bar_list</span> <span class="o">=</span> <span class="n">pci_select_bars</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">IORESOURCE_MEM</span><span class="p">);</span>
	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">bar</span> <span class="o">=</span> <span class="n">find_first_bit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bar_list</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">));</span>
	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">=</span> <span class="n">pci_resource_start</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">bar</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pci_request_selected_regions</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">bar</span><span class="p">,</span>
					 <span class="s">&quot;megasas: LSI&quot;</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;megasas: IO memory region busy!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">reg_set</span> <span class="o">=</span> <span class="n">ioremap_nocache</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">,</span> <span class="mi">8192</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">reg_set</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;megasas: Failed to map IO mem</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail_ioremap</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">reg_set</span> <span class="o">=</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">reg_set</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_LSI_FUSION</span>:
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_LSI_INVADER</span>:
		<span class="n">instance</span><span class="o">-&gt;</span><span class="n">instancet</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">megasas_instance_template_fusion</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_LSI_SAS1078R</span>:
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_LSI_SAS1078DE</span>:
		<span class="n">instance</span><span class="o">-&gt;</span><span class="n">instancet</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">megasas_instance_template_ppc</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_LSI_SAS1078GEN2</span>:
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_LSI_SAS0079GEN2</span>:
		<span class="n">instance</span><span class="o">-&gt;</span><span class="n">instancet</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">megasas_instance_template_gen2</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_LSI_SAS0073SKINNY</span>:
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_LSI_SAS0071SKINNY</span>:
		<span class="n">instance</span><span class="o">-&gt;</span><span class="n">instancet</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">megasas_instance_template_skinny</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_LSI_SAS1064R</span>:
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_DELL_PERC5</span>:
	<span class="nl">default:</span>
		<span class="n">instance</span><span class="o">-&gt;</span><span class="n">instancet</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">megasas_instance_template_xscale</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We expect the FW state to be READY</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">megasas_transition_to_ready</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">fail_ready_state</span><span class="p">;</span>

	<span class="cm">/* Check if MSI-X is supported while in ready state */</span>
	<span class="n">msix_enable</span> <span class="o">=</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">instancet</span><span class="o">-&gt;</span><span class="n">read_fw_status_reg</span><span class="p">(</span><span class="n">reg_set</span><span class="p">)</span> <span class="o">&amp;</span>
		       <span class="mh">0x4000000</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mh">0x1a</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">msix_enable</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">msix_disable</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Check max MSI-X vectors */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_LSI_FUSION</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_LSI_INVADER</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">instance</span><span class="o">-&gt;</span><span class="n">msix_vectors</span> <span class="o">=</span> <span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">reg_set</span><span class="o">-&gt;</span>
							<span class="n">outbound_scratch_pad_2</span>
							  <span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x1F</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">instance</span><span class="o">-&gt;</span><span class="n">msix_vectors</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* Don&#39;t bother allocating more MSI-X vectors than cpus */</span>
		<span class="n">instance</span><span class="o">-&gt;</span><span class="n">msix_vectors</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">msix_vectors</span><span class="p">,</span>
					     <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">num_online_cpus</span><span class="p">());</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">msix_vectors</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">instance</span><span class="o">-&gt;</span><span class="n">msixentry</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">entry</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">pci_enable_msix</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">msixentry</span><span class="p">,</span>
				    <span class="n">instance</span><span class="o">-&gt;</span><span class="n">msix_vectors</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pci_enable_msix</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
						     <span class="n">instance</span><span class="o">-&gt;</span><span class="n">msixentry</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
					<span class="n">instance</span><span class="o">-&gt;</span><span class="n">msix_vectors</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="n">instance</span><span class="o">-&gt;</span><span class="n">msix_vectors</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">instance</span><span class="o">-&gt;</span><span class="n">msix_vectors</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Get operational params, sge flags, send init cmd to controller */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">instancet</span><span class="o">-&gt;</span><span class="n">init_adapter</span><span class="p">(</span><span class="n">instance</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">fail_init_adapter</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;megasas: INIT adapter done</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/** for passthrough</span>
<span class="cm">	* the following function will get the PD LIST.</span>
<span class="cm">	*/</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pd_list</span><span class="p">,</span> <span class="mi">0</span> <span class="p">,</span>
		<span class="p">(</span><span class="n">MEGASAS_MAX_PD</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_pd_list</span><span class="p">)));</span>
	<span class="n">megasas_get_pd_list</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">ld_ids</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="n">MEGASAS_MAX_LD_IDS</span><span class="p">);</span>
	<span class="n">megasas_get_ld_list</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>

	<span class="n">ctrl_info</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_ctrl_info</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Compute the max allowed sectors per IO: The controller info has two</span>
<span class="cm">	 * limits on max sectors. Driver should use the minimum of these two.</span>
<span class="cm">	 *</span>
<span class="cm">	 * 1 &lt;&lt; stripe_sz_ops.min = max sectors per strip</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note that older firmwares ( &lt; FW ver 30) didn&#39;t report information</span>
<span class="cm">	 * to calculate max_sectors_1. So the number ended up as zero always.</span>
<span class="cm">	 */</span>
	<span class="n">tmp_sectors</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctrl_info</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">megasas_get_ctrl_info</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">ctrl_info</span><span class="p">))</span> <span class="p">{</span>

		<span class="n">max_sectors_1</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">ctrl_info</span><span class="o">-&gt;</span><span class="n">stripe_sz_ops</span><span class="p">.</span><span class="n">min</span><span class="p">)</span> <span class="o">*</span>
		    <span class="n">ctrl_info</span><span class="o">-&gt;</span><span class="n">max_strips_per_io</span><span class="p">;</span>
		<span class="n">max_sectors_2</span> <span class="o">=</span> <span class="n">ctrl_info</span><span class="o">-&gt;</span><span class="n">max_request_size</span><span class="p">;</span>

		<span class="n">tmp_sectors</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="n">u32</span><span class="p">,</span> <span class="n">max_sectors_1</span> <span class="p">,</span> <span class="n">max_sectors_2</span><span class="p">);</span>
		<span class="n">instance</span><span class="o">-&gt;</span><span class="n">disableOnlineCtrlReset</span> <span class="o">=</span>
		<span class="n">ctrl_info</span><span class="o">-&gt;</span><span class="n">properties</span><span class="p">.</span><span class="n">OnOffProperties</span><span class="p">.</span><span class="n">disableOnlineCtrlReset</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">max_sectors_per_req</span> <span class="o">=</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">max_num_sge</span> <span class="o">*</span>
						<span class="n">PAGE_SIZE</span> <span class="o">/</span> <span class="mi">512</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tmp_sectors</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">max_sectors_per_req</span> <span class="o">&gt;</span> <span class="n">tmp_sectors</span><span class="p">))</span>
		<span class="n">instance</span><span class="o">-&gt;</span><span class="n">max_sectors_per_req</span> <span class="o">=</span> <span class="n">tmp_sectors</span><span class="p">;</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">ctrl_info</span><span class="p">);</span>

        <span class="cm">/*</span>
<span class="cm">	* Setup tasklet for cmd completion</span>
<span class="cm">	*/</span>

	<span class="n">tasklet_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">isr_tasklet</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">instancet</span><span class="o">-&gt;</span><span class="n">tasklet</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">instance</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fail_init_adapter:</span>
<span class="nl">fail_ready_state:</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">reg_set</span><span class="p">);</span>

      <span class="nl">fail_ioremap:</span>
	<span class="n">pci_release_selected_regions</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">bar</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * megasas_release_mfi -	Reverses the FW initialization</span>
<span class="cm"> * @intance:			Adapter soft state</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">megasas_release_mfi</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">reply_q_sz</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="o">*</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">max_mfi_cmds</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">reply_queue</span><span class="p">)</span>
		<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">reply_q_sz</span><span class="p">,</span>
			    <span class="n">instance</span><span class="o">-&gt;</span><span class="n">reply_queue</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">reply_queue_h</span><span class="p">);</span>

	<span class="n">megasas_free_cmds</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>

	<span class="n">iounmap</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">reg_set</span><span class="p">);</span>

	<span class="n">pci_release_selected_regions</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">bar</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * megasas_get_seq_num -	Gets latest event sequence numbers</span>
<span class="cm"> * @instance:			Adapter soft state</span>
<span class="cm"> * @eli:			FW event log sequence numbers information</span>
<span class="cm"> *</span>
<span class="cm"> * FW maintains a log of all events in a non-volatile area. Upper layers would</span>
<span class="cm"> * usually find out the latest sequence number of the events, the seq number at</span>
<span class="cm"> * the boot etc. They would &quot;read&quot; all the events below the latest seq number</span>
<span class="cm"> * by issuing a direct fw cmd (DCMD). For the future events (beyond latest seq</span>
<span class="cm"> * number), they would subsribe to AEN (asynchronous event notification) and</span>
<span class="cm"> * wait for the events to happen.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">megasas_get_seq_num</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">megasas_evt_log_info</span> <span class="o">*</span><span class="n">eli</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">megasas_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">megasas_dcmd_frame</span> <span class="o">*</span><span class="n">dcmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">megasas_evt_log_info</span> <span class="o">*</span><span class="n">el_info</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">el_info_h</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">cmd</span> <span class="o">=</span> <span class="n">megasas_get_cmd</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dcmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">dcmd</span><span class="p">;</span>
	<span class="n">el_info</span> <span class="o">=</span> <span class="n">pci_alloc_consistent</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
				       <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_evt_log_info</span><span class="p">),</span>
				       <span class="o">&amp;</span><span class="n">el_info_h</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">el_info</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">megasas_return_cmd</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">el_info</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">el_info</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">dcmd</span><span class="o">-&gt;</span><span class="n">mbox</span><span class="p">.</span><span class="n">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MFI_MBOX_SIZE</span><span class="p">);</span>

	<span class="n">dcmd</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">MFI_CMD_DCMD</span><span class="p">;</span>
	<span class="n">dcmd</span><span class="o">-&gt;</span><span class="n">cmd_status</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>
	<span class="n">dcmd</span><span class="o">-&gt;</span><span class="n">sge_count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">dcmd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">MFI_FRAME_DIR_READ</span><span class="p">;</span>
	<span class="n">dcmd</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dcmd</span><span class="o">-&gt;</span><span class="n">pad_0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dcmd</span><span class="o">-&gt;</span><span class="n">data_xfer_len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_evt_log_info</span><span class="p">);</span>
	<span class="n">dcmd</span><span class="o">-&gt;</span><span class="n">opcode</span> <span class="o">=</span> <span class="n">MR_DCMD_CTRL_EVENT_GET_INFO</span><span class="p">;</span>
	<span class="n">dcmd</span><span class="o">-&gt;</span><span class="n">sgl</span><span class="p">.</span><span class="n">sge32</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">phys_addr</span> <span class="o">=</span> <span class="n">el_info_h</span><span class="p">;</span>
	<span class="n">dcmd</span><span class="o">-&gt;</span><span class="n">sgl</span><span class="p">.</span><span class="n">sge32</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">length</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_evt_log_info</span><span class="p">);</span>

	<span class="n">megasas_issue_blocked_cmd</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Copy the data back into callers buffer</span>
<span class="cm">	 */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">eli</span><span class="p">,</span> <span class="n">el_info</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_evt_log_info</span><span class="p">));</span>

	<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_evt_log_info</span><span class="p">),</span>
			    <span class="n">el_info</span><span class="p">,</span> <span class="n">el_info_h</span><span class="p">);</span>

	<span class="n">megasas_return_cmd</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * megasas_register_aen -	Registers for asynchronous event notification</span>
<span class="cm"> * @instance:			Adapter soft state</span>
<span class="cm"> * @seq_num:			The starting sequence number</span>
<span class="cm"> * @class_locale:		Class of the event</span>
<span class="cm"> *</span>
<span class="cm"> * This function subscribes for AEN for events beyond the @seq_num. It requests</span>
<span class="cm"> * to be notified if and only if the event is of type @class_locale</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">megasas_register_aen</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span> <span class="n">u32</span> <span class="n">seq_num</span><span class="p">,</span>
		     <span class="n">u32</span> <span class="n">class_locale_word</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">megasas_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">megasas_dcmd_frame</span> <span class="o">*</span><span class="n">dcmd</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">megasas_evt_class_locale</span> <span class="n">curr_aen</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">megasas_evt_class_locale</span> <span class="n">prev_aen</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If there an AEN pending already (aen_cmd), check if the</span>
<span class="cm">	 * class_locale of that pending AEN is inclusive of the new</span>
<span class="cm">	 * AEN request we currently have. If it is, then we don&#39;t have</span>
<span class="cm">	 * to do anything. In other words, whichever events the current</span>
<span class="cm">	 * AEN request is subscribing to, have already been subscribed</span>
<span class="cm">	 * to.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If the old_cmd is _not_ inclusive, then we have to abort</span>
<span class="cm">	 * that command, form a class_locale that is superset of both</span>
<span class="cm">	 * old and current and re-issue to the FW</span>
<span class="cm">	 */</span>

	<span class="n">curr_aen</span><span class="p">.</span><span class="n">word</span> <span class="o">=</span> <span class="n">class_locale_word</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">aen_cmd</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">prev_aen</span><span class="p">.</span><span class="n">word</span> <span class="o">=</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">aen_cmd</span><span class="o">-&gt;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">dcmd</span><span class="p">.</span><span class="n">mbox</span><span class="p">.</span><span class="n">w</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

		<span class="cm">/*</span>
<span class="cm">		 * A class whose enum value is smaller is inclusive of all</span>
<span class="cm">		 * higher values. If a PROGRESS (= -1) was previously</span>
<span class="cm">		 * registered, then a new registration requests for higher</span>
<span class="cm">		 * classes need not be sent to FW. They are automatically</span>
<span class="cm">		 * included.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Locale numbers don&#39;t have such hierarchy. They are bitmap</span>
<span class="cm">		 * values</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">prev_aen</span><span class="p">.</span><span class="n">members</span><span class="p">.</span><span class="n">class</span> <span class="o">&lt;=</span> <span class="n">curr_aen</span><span class="p">.</span><span class="n">members</span><span class="p">.</span><span class="n">class</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="p">((</span><span class="n">prev_aen</span><span class="p">.</span><span class="n">members</span><span class="p">.</span><span class="n">locale</span> <span class="o">&amp;</span> <span class="n">curr_aen</span><span class="p">.</span><span class="n">members</span><span class="p">.</span><span class="n">locale</span><span class="p">)</span> <span class="o">^</span>
		      <span class="n">curr_aen</span><span class="p">.</span><span class="n">members</span><span class="p">.</span><span class="n">locale</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Previously issued event registration includes</span>
<span class="cm">			 * current request. Nothing to do.</span>
<span class="cm">			 */</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">curr_aen</span><span class="p">.</span><span class="n">members</span><span class="p">.</span><span class="n">locale</span> <span class="o">|=</span> <span class="n">prev_aen</span><span class="p">.</span><span class="n">members</span><span class="p">.</span><span class="n">locale</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">prev_aen</span><span class="p">.</span><span class="n">members</span><span class="p">.</span><span class="n">class</span> <span class="o">&lt;</span> <span class="n">curr_aen</span><span class="p">.</span><span class="n">members</span><span class="p">.</span><span class="n">class</span><span class="p">)</span>
				<span class="n">curr_aen</span><span class="p">.</span><span class="n">members</span><span class="p">.</span><span class="n">class</span> <span class="o">=</span> <span class="n">prev_aen</span><span class="p">.</span><span class="n">members</span><span class="p">.</span><span class="n">class</span><span class="p">;</span>

			<span class="n">instance</span><span class="o">-&gt;</span><span class="n">aen_cmd</span><span class="o">-&gt;</span><span class="n">abort_aen</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="n">megasas_issue_blocked_abort_cmd</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span>
								  <span class="n">instance</span><span class="o">-&gt;</span>
								  <span class="n">aen_cmd</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;megasas: Failed to abort &quot;</span>
				       <span class="s">&quot;previous AEN command</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">cmd</span> <span class="o">=</span> <span class="n">megasas_get_cmd</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cmd</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">dcmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">dcmd</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">evt_detail</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_evt_detail</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Prepare DCMD for aen registration</span>
<span class="cm">	 */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">dcmd</span><span class="o">-&gt;</span><span class="n">mbox</span><span class="p">.</span><span class="n">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MFI_MBOX_SIZE</span><span class="p">);</span>

	<span class="n">dcmd</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">MFI_CMD_DCMD</span><span class="p">;</span>
	<span class="n">dcmd</span><span class="o">-&gt;</span><span class="n">cmd_status</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>
	<span class="n">dcmd</span><span class="o">-&gt;</span><span class="n">sge_count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">dcmd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">MFI_FRAME_DIR_READ</span><span class="p">;</span>
	<span class="n">dcmd</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dcmd</span><span class="o">-&gt;</span><span class="n">pad_0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">last_seq_num</span> <span class="o">=</span> <span class="n">seq_num</span><span class="p">;</span>
	<span class="n">dcmd</span><span class="o">-&gt;</span><span class="n">data_xfer_len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_evt_detail</span><span class="p">);</span>
	<span class="n">dcmd</span><span class="o">-&gt;</span><span class="n">opcode</span> <span class="o">=</span> <span class="n">MR_DCMD_CTRL_EVENT_WAIT</span><span class="p">;</span>
	<span class="n">dcmd</span><span class="o">-&gt;</span><span class="n">mbox</span><span class="p">.</span><span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">seq_num</span><span class="p">;</span>
	<span class="n">dcmd</span><span class="o">-&gt;</span><span class="n">mbox</span><span class="p">.</span><span class="n">w</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_aen</span><span class="p">.</span><span class="n">word</span><span class="p">;</span>
	<span class="n">dcmd</span><span class="o">-&gt;</span><span class="n">sgl</span><span class="p">.</span><span class="n">sge32</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">phys_addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">evt_detail_h</span><span class="p">;</span>
	<span class="n">dcmd</span><span class="o">-&gt;</span><span class="n">sgl</span><span class="p">.</span><span class="n">sge32</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">length</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_evt_detail</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">aen_cmd</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">megasas_return_cmd</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Store reference to the cmd used to register for AEN. When an</span>
<span class="cm">	 * application wants us to register for AEN, we have to abort this</span>
<span class="cm">	 * cmd and re-register with a new EVENT LOCALE supplied by that app</span>
<span class="cm">	 */</span>
	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">aen_cmd</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Issue the aen registration frame</span>
<span class="cm">	 */</span>
	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">instancet</span><span class="o">-&gt;</span><span class="n">issue_dcmd</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * megasas_start_aen -	Subscribes to AEN during driver load time</span>
<span class="cm"> * @instance:		Adapter soft state</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">megasas_start_aen</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">megasas_evt_log_info</span> <span class="n">eli</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">megasas_evt_class_locale</span> <span class="n">class_locale</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Get the latest sequence number from FW</span>
<span class="cm">	 */</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">eli</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">eli</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">megasas_get_seq_num</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eli</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Register AEN with FW for latest sequence number plus 1</span>
<span class="cm">	 */</span>
	<span class="n">class_locale</span><span class="p">.</span><span class="n">members</span><span class="p">.</span><span class="n">reserved</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">class_locale</span><span class="p">.</span><span class="n">members</span><span class="p">.</span><span class="n">locale</span> <span class="o">=</span> <span class="n">MR_EVT_LOCALE_ALL</span><span class="p">;</span>
	<span class="n">class_locale</span><span class="p">.</span><span class="n">members</span><span class="p">.</span><span class="n">class</span> <span class="o">=</span> <span class="n">MR_EVT_CLASS_DEBUG</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">megasas_register_aen</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">eli</span><span class="p">.</span><span class="n">newest_seq_num</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
				    <span class="n">class_locale</span><span class="p">.</span><span class="n">word</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * megasas_io_attach -	Attaches this driver to SCSI mid-layer</span>
<span class="cm"> * @instance:		Adapter soft state</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">megasas_io_attach</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">host</span> <span class="o">=</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Export parameters required by SCSI mid-layer</span>
<span class="cm">	 */</span>
	<span class="n">host</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>
	<span class="n">host</span><span class="o">-&gt;</span><span class="n">unique_id</span> <span class="o">=</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">unique_id</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_LSI_SAS0073SKINNY</span><span class="p">)</span> <span class="o">||</span>
		<span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_LSI_SAS0071SKINNY</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">host</span><span class="o">-&gt;</span><span class="n">can_queue</span> <span class="o">=</span>
			<span class="n">instance</span><span class="o">-&gt;</span><span class="n">max_fw_cmds</span> <span class="o">-</span> <span class="n">MEGASAS_SKINNY_INT_CMDS</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">host</span><span class="o">-&gt;</span><span class="n">can_queue</span> <span class="o">=</span>
			<span class="n">instance</span><span class="o">-&gt;</span><span class="n">max_fw_cmds</span> <span class="o">-</span> <span class="n">MEGASAS_INT_CMDS</span><span class="p">;</span>
	<span class="n">host</span><span class="o">-&gt;</span><span class="n">this_id</span> <span class="o">=</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">init_id</span><span class="p">;</span>
	<span class="n">host</span><span class="o">-&gt;</span><span class="n">sg_tablesize</span> <span class="o">=</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">max_num_sge</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">fw_support_ieee</span><span class="p">)</span>
		<span class="n">instance</span><span class="o">-&gt;</span><span class="n">max_sectors_per_req</span> <span class="o">=</span> <span class="n">MEGASAS_MAX_SECTORS_IEEE</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check if the module parameter value for max_sectors can be used</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">max_sectors</span> <span class="o">&amp;&amp;</span> <span class="n">max_sectors</span> <span class="o">&lt;</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">max_sectors_per_req</span><span class="p">)</span>
		<span class="n">instance</span><span class="o">-&gt;</span><span class="n">max_sectors_per_req</span> <span class="o">=</span> <span class="n">max_sectors</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">max_sectors</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(((</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span>
				<span class="n">PCI_DEVICE_ID_LSI_SAS1078GEN2</span><span class="p">)</span> <span class="o">||</span>
				<span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span>
				<span class="n">PCI_DEVICE_ID_LSI_SAS0079GEN2</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
				<span class="p">(</span><span class="n">max_sectors</span> <span class="o">&lt;=</span> <span class="n">MEGASAS_MAX_SECTORS</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">instance</span><span class="o">-&gt;</span><span class="n">max_sectors_per_req</span> <span class="o">=</span> <span class="n">max_sectors</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;megasas: max_sectors should be &gt; 0&quot;</span>
				<span class="s">&quot;and &lt;= %d (or &lt; 1MB for GEN2 controller)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">instance</span><span class="o">-&gt;</span><span class="n">max_sectors_per_req</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">host</span><span class="o">-&gt;</span><span class="n">max_sectors</span> <span class="o">=</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">max_sectors_per_req</span><span class="p">;</span>
	<span class="n">host</span><span class="o">-&gt;</span><span class="n">cmd_per_lun</span> <span class="o">=</span> <span class="n">MEGASAS_DEFAULT_CMD_PER_LUN</span><span class="p">;</span>
	<span class="n">host</span><span class="o">-&gt;</span><span class="n">max_channel</span> <span class="o">=</span> <span class="n">MEGASAS_MAX_CHANNELS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">host</span><span class="o">-&gt;</span><span class="n">max_id</span> <span class="o">=</span> <span class="n">MEGASAS_MAX_DEV_PER_CHANNEL</span><span class="p">;</span>
	<span class="n">host</span><span class="o">-&gt;</span><span class="n">max_lun</span> <span class="o">=</span> <span class="n">MEGASAS_MAX_LUN</span><span class="p">;</span>
	<span class="n">host</span><span class="o">-&gt;</span><span class="n">max_cmd_len</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>

	<span class="cm">/* Fusion only supports host reset */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_LSI_FUSION</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_LSI_INVADER</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">host</span><span class="o">-&gt;</span><span class="n">hostt</span><span class="o">-&gt;</span><span class="n">eh_device_reset_handler</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">host</span><span class="o">-&gt;</span><span class="n">hostt</span><span class="o">-&gt;</span><span class="n">eh_bus_reset_handler</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Notify the mid-layer about the new controller</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">scsi_add_host</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;megasas: scsi_add_host failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Trigger SCSI to scan our drives</span>
<span class="cm">	 */</span>
	<span class="n">scsi_scan_host</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">megasas_set_dma_mask</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * All our contollers are capable of performing 64-bit DMA</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_DMA64</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pci_set_dma_mask</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">64</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">pci_set_dma_mask</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">32</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">fail_set_dma_mask</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pci_set_dma_mask</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">32</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">fail_set_dma_mask</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fail_set_dma_mask:</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * megasas_probe_one -	PCI hotplug entry point</span>
<span class="cm"> * @pdev:		PCI device structure</span>
<span class="cm"> * @id:			PCI ids of supported hotplugged adapter</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span>
<span class="nf">megasas_probe_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rval</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">control</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Reset MSI-X in the kdump kernel */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reset_devices</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pos</span> <span class="o">=</span> <span class="n">pci_find_capability</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_CAP_ID_MSIX</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">msi_control_reg</span><span class="p">(</span><span class="n">pos</span><span class="p">),</span>
					     <span class="o">&amp;</span><span class="n">control</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">control</span> <span class="o">&amp;</span> <span class="n">PCI_MSIX_FLAGS_ENABLE</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;resetting MSI-X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span>
						      <span class="n">msi_control_reg</span><span class="p">(</span><span class="n">pos</span><span class="p">),</span>
						      <span class="n">control</span> <span class="o">&amp;</span>
						      <span class="o">~</span><span class="n">PCI_MSIX_FLAGS_ENABLE</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Announce PCI information</span>
<span class="cm">	 */</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;megasas: %#4.04x:%#4.04x:%#4.04x:%#4.04x: &quot;</span><span class="p">,</span>
	       <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">vendor</span><span class="p">,</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">subsystem_vendor</span><span class="p">,</span>
	       <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">subsystem_device</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;bus %d:slot %d:func %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">,</span> <span class="n">PCI_SLOT</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">),</span> <span class="n">PCI_FUNC</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * PCI prepping: enable device set bus mastering and dma mask</span>
<span class="cm">	 */</span>
	<span class="n">rval</span> <span class="o">=</span> <span class="n">pci_enable_device_mem</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rval</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">rval</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pci_set_master</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">megasas_set_dma_mask</span><span class="p">(</span><span class="n">pdev</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">fail_set_dma_mask</span><span class="p">;</span>

	<span class="n">host</span> <span class="o">=</span> <span class="n">scsi_host_alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">megasas_template</span><span class="p">,</span>
			       <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_instance</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">host</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;megasas: scsi_host_alloc failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail_alloc_instance</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">instance</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="p">)</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">instance</span><span class="p">));</span>
	<span class="n">atomic_set</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">fw_reset_no_pci_access</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">pdev</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_LSI_FUSION</span>:
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_LSI_INVADER</span>:
	<span class="p">{</span>
		<span class="k">struct</span> <span class="n">fusion_context</span> <span class="o">*</span><span class="n">fusion</span><span class="p">;</span>

		<span class="n">instance</span><span class="o">-&gt;</span><span class="n">ctrl_context</span> <span class="o">=</span>
			<span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fusion_context</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">ctrl_context</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;megasas: Failed to allocate &quot;</span>
			       <span class="s">&quot;memory for Fusion context info</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">fail_alloc_dma_buf</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">fusion</span> <span class="o">=</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">ctrl_context</span><span class="p">;</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fusion</span><span class="o">-&gt;</span><span class="n">cmd_pool</span><span class="p">);</span>
		<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fusion</span><span class="o">-&gt;</span><span class="n">cmd_pool_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span> <span class="cm">/* For all other supported controllers */</span>

		<span class="n">instance</span><span class="o">-&gt;</span><span class="n">producer</span> <span class="o">=</span>
			<span class="n">pci_alloc_consistent</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">),</span>
					     <span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">producer_h</span><span class="p">);</span>
		<span class="n">instance</span><span class="o">-&gt;</span><span class="n">consumer</span> <span class="o">=</span>
			<span class="n">pci_alloc_consistent</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">),</span>
					     <span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">consumer_h</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">producer</span> <span class="o">||</span> <span class="o">!</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">consumer</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;megasas: Failed to allocate&quot;</span>
			       <span class="s">&quot;memory for producer, consumer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">fail_alloc_dma_buf</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="o">*</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">producer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="o">*</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">consumer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">megasas_poll_wait_aen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">flag_ieee</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">ev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">issuepend_done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">adprecovery</span> <span class="o">=</span> <span class="n">MEGASAS_HBA_OPERATIONAL</span><span class="p">;</span>
	<span class="n">megasas_poll_wait_aen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">evt_detail</span> <span class="o">=</span> <span class="n">pci_alloc_consistent</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span>
						    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span>
							   <span class="n">megasas_evt_detail</span><span class="p">),</span>
						    <span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">evt_detail_h</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">evt_detail</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;megasas: Failed to allocate memory for &quot;</span>
		       <span class="s">&quot;event detail structure</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail_alloc_dma_buf</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialize locks and queues</span>
<span class="cm">	 */</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">cmd_pool</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">internal_reset_pending_q</span><span class="p">);</span>

	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">fw_outstanding</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>

	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">int_cmd_wait_q</span><span class="p">);</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">abort_cmd_wait_q</span><span class="p">);</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">cmd_pool_lock</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">hba_lock</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">completion_lock</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">poll_aen_lock</span><span class="p">);</span>

	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">aen_mutex</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">reset_mutex</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialize PCI related and misc parameters</span>
<span class="cm">	 */</span>
	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">host</span> <span class="o">=</span> <span class="n">host</span><span class="p">;</span>
	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">unique_id</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">number</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span> <span class="o">|</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">;</span>
	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">init_id</span> <span class="o">=</span> <span class="n">MEGASAS_DEFAULT_INIT_ID</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_LSI_SAS0073SKINNY</span><span class="p">)</span> <span class="o">||</span>
		<span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_LSI_SAS0071SKINNY</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">instance</span><span class="o">-&gt;</span><span class="n">flag_ieee</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">sema_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">ioctl_sem</span><span class="p">,</span> <span class="n">MEGASAS_SKINNY_INT_CMDS</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">sema_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">ioctl_sem</span><span class="p">,</span> <span class="n">MEGASAS_INT_CMDS</span><span class="p">);</span>

	<span class="n">megasas_dbg_lvl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">unload</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">last_time</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">disableOnlineCtrlReset</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_LSI_FUSION</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_LSI_INVADER</span><span class="p">))</span>
		<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">work_init</span><span class="p">,</span> <span class="n">megasas_fusion_ocr_wq</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">work_init</span><span class="p">,</span> <span class="n">process_fw_state_change_wq</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialize MFI Firmware</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">megasas_init_fw</span><span class="p">(</span><span class="n">instance</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">fail_init_mfi</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Register IRQ</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">msix_vectors</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">msix_vectors</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">instance</span><span class="o">-&gt;</span><span class="n">irq_context</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">instance</span> <span class="o">=</span> <span class="n">instance</span><span class="p">;</span>
			<span class="n">instance</span><span class="o">-&gt;</span><span class="n">irq_context</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">MSIxIndex</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">request_irq</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">msixentry</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vector</span><span class="p">,</span>
					<span class="n">instance</span><span class="o">-&gt;</span><span class="n">instancet</span><span class="o">-&gt;</span><span class="n">service_isr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					<span class="s">&quot;megasas&quot;</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">irq_context</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;megasas: Failed to &quot;</span>
				       <span class="s">&quot;register IRQ for vector %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
				<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span> <span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
					<span class="n">free_irq</span><span class="p">(</span>
						<span class="n">instance</span><span class="o">-&gt;</span><span class="n">msixentry</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">vector</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">irq_context</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
				<span class="k">goto</span> <span class="n">fail_irq</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">instance</span><span class="o">-&gt;</span><span class="n">irq_context</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">instance</span> <span class="o">=</span> <span class="n">instance</span><span class="p">;</span>
		<span class="n">instance</span><span class="o">-&gt;</span><span class="n">irq_context</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">MSIxIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">request_irq</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">instancet</span><span class="o">-&gt;</span><span class="n">service_isr</span><span class="p">,</span>
				<span class="n">IRQF_SHARED</span><span class="p">,</span> <span class="s">&quot;megasas&quot;</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">irq_context</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;megasas: Failed to register IRQ</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">fail_irq</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">instancet</span><span class="o">-&gt;</span><span class="n">enable_intr</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">reg_set</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Store instance in PCI softstate</span>
<span class="cm">	 */</span>
	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">instance</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Add this controller to megasas_mgmt_info structure so that it</span>
<span class="cm">	 * can be exported to management applications</span>
<span class="cm">	 */</span>
	<span class="n">megasas_mgmt_info</span><span class="p">.</span><span class="n">count</span><span class="o">++</span><span class="p">;</span>
	<span class="n">megasas_mgmt_info</span><span class="p">.</span><span class="n">instance</span><span class="p">[</span><span class="n">megasas_mgmt_info</span><span class="p">.</span><span class="n">max_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">instance</span><span class="p">;</span>
	<span class="n">megasas_mgmt_info</span><span class="p">.</span><span class="n">max_index</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Register with SCSI mid-layer</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">megasas_io_attach</span><span class="p">(</span><span class="n">instance</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">fail_io_attach</span><span class="p">;</span>

	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">unload</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initiate AEN (Asynchronous Event Notification)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">megasas_start_aen</span><span class="p">(</span><span class="n">instance</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;megasas: start aen failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail_start_aen</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

      <span class="nl">fail_start_aen:</span>
      <span class="nl">fail_io_attach:</span>
	<span class="n">megasas_mgmt_info</span><span class="p">.</span><span class="n">count</span><span class="o">--</span><span class="p">;</span>
	<span class="n">megasas_mgmt_info</span><span class="p">.</span><span class="n">instance</span><span class="p">[</span><span class="n">megasas_mgmt_info</span><span class="p">.</span><span class="n">max_index</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">megasas_mgmt_info</span><span class="p">.</span><span class="n">max_index</span><span class="o">--</span><span class="p">;</span>

	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">instancet</span><span class="o">-&gt;</span><span class="n">disable_intr</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">reg_set</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">msix_vectors</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">msix_vectors</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">free_irq</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">msixentry</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vector</span><span class="p">,</span>
				 <span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">irq_context</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="k">else</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">irq_context</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="nl">fail_irq:</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_LSI_FUSION</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_LSI_INVADER</span><span class="p">))</span>
		<span class="n">megasas_release_fusion</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">megasas_release_mfi</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>
      <span class="nl">fail_init_mfi:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">msix_vectors</span><span class="p">)</span>
		<span class="n">pci_disable_msix</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">);</span>
      <span class="nl">fail_alloc_dma_buf:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">evt_detail</span><span class="p">)</span>
		<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_evt_detail</span><span class="p">),</span>
				    <span class="n">instance</span><span class="o">-&gt;</span><span class="n">evt_detail</span><span class="p">,</span>
				    <span class="n">instance</span><span class="o">-&gt;</span><span class="n">evt_detail_h</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">producer</span><span class="p">)</span>
		<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">),</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">producer</span><span class="p">,</span>
				    <span class="n">instance</span><span class="o">-&gt;</span><span class="n">producer_h</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">consumer</span><span class="p">)</span>
		<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">),</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">consumer</span><span class="p">,</span>
				    <span class="n">instance</span><span class="o">-&gt;</span><span class="n">consumer_h</span><span class="p">);</span>
	<span class="n">scsi_host_put</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>

      <span class="nl">fail_alloc_instance:</span>
      <span class="nl">fail_set_dma_mask:</span>
	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * megasas_flush_cache -	Requests FW to flush all its caches</span>
<span class="cm"> * @instance:			Adapter soft state</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">megasas_flush_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">megasas_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">megasas_dcmd_frame</span> <span class="o">*</span><span class="n">dcmd</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">adprecovery</span> <span class="o">==</span> <span class="n">MEGASAS_HW_CRITICAL_ERROR</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">cmd</span> <span class="o">=</span> <span class="n">megasas_get_cmd</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cmd</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">dcmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">dcmd</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">dcmd</span><span class="o">-&gt;</span><span class="n">mbox</span><span class="p">.</span><span class="n">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MFI_MBOX_SIZE</span><span class="p">);</span>

	<span class="n">dcmd</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">MFI_CMD_DCMD</span><span class="p">;</span>
	<span class="n">dcmd</span><span class="o">-&gt;</span><span class="n">cmd_status</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>
	<span class="n">dcmd</span><span class="o">-&gt;</span><span class="n">sge_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dcmd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">MFI_FRAME_DIR_NONE</span><span class="p">;</span>
	<span class="n">dcmd</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dcmd</span><span class="o">-&gt;</span><span class="n">pad_0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dcmd</span><span class="o">-&gt;</span><span class="n">data_xfer_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dcmd</span><span class="o">-&gt;</span><span class="n">opcode</span> <span class="o">=</span> <span class="n">MR_DCMD_CTRL_CACHE_FLUSH</span><span class="p">;</span>
	<span class="n">dcmd</span><span class="o">-&gt;</span><span class="n">mbox</span><span class="p">.</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">MR_FLUSH_CTRL_CACHE</span> <span class="o">|</span> <span class="n">MR_FLUSH_DISK_CACHE</span><span class="p">;</span>

	<span class="n">megasas_issue_blocked_cmd</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>

	<span class="n">megasas_return_cmd</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * megasas_shutdown_controller -	Instructs FW to shutdown the controller</span>
<span class="cm"> * @instance:				Adapter soft state</span>
<span class="cm"> * @opcode:				Shutdown/Hibernate</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">megasas_shutdown_controller</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span>
					<span class="n">u32</span> <span class="n">opcode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">megasas_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">megasas_dcmd_frame</span> <span class="o">*</span><span class="n">dcmd</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">adprecovery</span> <span class="o">==</span> <span class="n">MEGASAS_HW_CRITICAL_ERROR</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">cmd</span> <span class="o">=</span> <span class="n">megasas_get_cmd</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cmd</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">aen_cmd</span><span class="p">)</span>
		<span class="n">megasas_issue_blocked_abort_cmd</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">aen_cmd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">map_update_cmd</span><span class="p">)</span>
		<span class="n">megasas_issue_blocked_abort_cmd</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span>
						<span class="n">instance</span><span class="o">-&gt;</span><span class="n">map_update_cmd</span><span class="p">);</span>
	<span class="n">dcmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">dcmd</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">dcmd</span><span class="o">-&gt;</span><span class="n">mbox</span><span class="p">.</span><span class="n">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MFI_MBOX_SIZE</span><span class="p">);</span>

	<span class="n">dcmd</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">MFI_CMD_DCMD</span><span class="p">;</span>
	<span class="n">dcmd</span><span class="o">-&gt;</span><span class="n">cmd_status</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>
	<span class="n">dcmd</span><span class="o">-&gt;</span><span class="n">sge_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dcmd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">MFI_FRAME_DIR_NONE</span><span class="p">;</span>
	<span class="n">dcmd</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dcmd</span><span class="o">-&gt;</span><span class="n">pad_0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dcmd</span><span class="o">-&gt;</span><span class="n">data_xfer_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dcmd</span><span class="o">-&gt;</span><span class="n">opcode</span> <span class="o">=</span> <span class="n">opcode</span><span class="p">;</span>

	<span class="n">megasas_issue_blocked_cmd</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>

	<span class="n">megasas_return_cmd</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PM</span>
<span class="cm">/**</span>
<span class="cm"> * megasas_suspend -	driver suspend entry point</span>
<span class="cm"> * @pdev:		PCI device structure</span>
<span class="cm"> * @state:		PCI power state to suspend routine</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">megasas_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">instance</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">host</span> <span class="o">=</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">unload</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">megasas_flush_cache</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>
	<span class="n">megasas_shutdown_controller</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">MR_DCMD_HIBERNATE_SHUTDOWN</span><span class="p">);</span>

	<span class="cm">/* cancel the delayed work if this work still in queue */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">ev</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">megasas_aen_event</span> <span class="o">*</span><span class="n">ev</span> <span class="o">=</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">ev</span><span class="p">;</span>
		<span class="n">cancel_delayed_work_sync</span><span class="p">(</span>
			<span class="p">(</span><span class="k">struct</span> <span class="n">delayed_work</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">hotplug_work</span><span class="p">);</span>
		<span class="n">instance</span><span class="o">-&gt;</span><span class="n">ev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tasklet_kill</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">isr_tasklet</span><span class="p">);</span>

	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">instance</span><span class="p">);</span>
	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">instancet</span><span class="o">-&gt;</span><span class="n">disable_intr</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">reg_set</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">msix_vectors</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">msix_vectors</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">free_irq</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">msixentry</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vector</span><span class="p">,</span>
				 <span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">irq_context</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="k">else</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">irq_context</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">msix_vectors</span><span class="p">)</span>
		<span class="n">pci_disable_msix</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">);</span>

	<span class="n">pci_save_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="n">pci_set_power_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">pci_choose_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">state</span><span class="p">));</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * megasas_resume-      driver resume entry point</span>
<span class="cm"> * @pdev:               PCI device structure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">megasas_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rval</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">;</span>

	<span class="n">instance</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">host</span> <span class="o">=</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="n">pci_set_power_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_D0</span><span class="p">);</span>
	<span class="n">pci_enable_wake</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_D0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">pci_restore_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * PCI prepping: enable device set bus mastering and dma mask</span>
<span class="cm">	 */</span>
	<span class="n">rval</span> <span class="o">=</span> <span class="n">pci_enable_device_mem</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rval</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;megasas: Enable device failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rval</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pci_set_master</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">megasas_set_dma_mask</span><span class="p">(</span><span class="n">pdev</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">fail_set_dma_mask</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialize MFI Firmware</span>
<span class="cm">	 */</span>

	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">fw_outstanding</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We expect the FW state to be READY</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">megasas_transition_to_ready</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">fail_ready_state</span><span class="p">;</span>

	<span class="cm">/* Now re-enable MSI-X */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">msix_vectors</span><span class="p">)</span>
		<span class="n">pci_enable_msix</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">msixentry</span><span class="p">,</span>
				<span class="n">instance</span><span class="o">-&gt;</span><span class="n">msix_vectors</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_LSI_FUSION</span>:
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_LSI_INVADER</span>:
	<span class="p">{</span>
		<span class="n">megasas_reset_reply_desc</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">megasas_ioc_init_fusion</span><span class="p">(</span><span class="n">instance</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">megasas_free_cmds</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>
			<span class="n">megasas_free_cmds_fusion</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">fail_init_mfi</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">megasas_get_map_info</span><span class="p">(</span><span class="n">instance</span><span class="p">))</span>
			<span class="n">megasas_sync_map_info</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="o">*</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">producer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="o">*</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">consumer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">megasas_issue_init_mfi</span><span class="p">(</span><span class="n">instance</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">fail_init_mfi</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tasklet_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">isr_tasklet</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">instancet</span><span class="o">-&gt;</span><span class="n">tasklet</span><span class="p">,</span>
		     <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">instance</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Register IRQ</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">msix_vectors</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">msix_vectors</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">instance</span><span class="o">-&gt;</span><span class="n">irq_context</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">instance</span> <span class="o">=</span> <span class="n">instance</span><span class="p">;</span>
			<span class="n">instance</span><span class="o">-&gt;</span><span class="n">irq_context</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">MSIxIndex</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">request_irq</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">msixentry</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vector</span><span class="p">,</span>
					<span class="n">instance</span><span class="o">-&gt;</span><span class="n">instancet</span><span class="o">-&gt;</span><span class="n">service_isr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					<span class="s">&quot;megasas&quot;</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">irq_context</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;megasas: Failed to &quot;</span>
				       <span class="s">&quot;register IRQ for vector %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
				<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span> <span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
					<span class="n">free_irq</span><span class="p">(</span>
						<span class="n">instance</span><span class="o">-&gt;</span><span class="n">msixentry</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">vector</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">irq_context</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
				<span class="k">goto</span> <span class="n">fail_irq</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">instance</span><span class="o">-&gt;</span><span class="n">irq_context</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">instance</span> <span class="o">=</span> <span class="n">instance</span><span class="p">;</span>
		<span class="n">instance</span><span class="o">-&gt;</span><span class="n">irq_context</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">MSIxIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">request_irq</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">instancet</span><span class="o">-&gt;</span><span class="n">service_isr</span><span class="p">,</span>
				<span class="n">IRQF_SHARED</span><span class="p">,</span> <span class="s">&quot;megasas&quot;</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">irq_context</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;megasas: Failed to register IRQ</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">fail_irq</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">instancet</span><span class="o">-&gt;</span><span class="n">enable_intr</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">reg_set</span><span class="p">);</span>
	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">unload</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initiate AEN (Asynchronous Event Notification)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">megasas_start_aen</span><span class="p">(</span><span class="n">instance</span><span class="p">))</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;megasas: Start AEN failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fail_irq:</span>
<span class="nl">fail_init_mfi:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">evt_detail</span><span class="p">)</span>
		<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_evt_detail</span><span class="p">),</span>
				<span class="n">instance</span><span class="o">-&gt;</span><span class="n">evt_detail</span><span class="p">,</span>
				<span class="n">instance</span><span class="o">-&gt;</span><span class="n">evt_detail_h</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">producer</span><span class="p">)</span>
		<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">),</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">producer</span><span class="p">,</span>
				<span class="n">instance</span><span class="o">-&gt;</span><span class="n">producer_h</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">consumer</span><span class="p">)</span>
		<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">),</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">consumer</span><span class="p">,</span>
				<span class="n">instance</span><span class="o">-&gt;</span><span class="n">consumer_h</span><span class="p">);</span>
	<span class="n">scsi_host_put</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>

<span class="nl">fail_set_dma_mask:</span>
<span class="nl">fail_ready_state:</span>

	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="cp">#define megasas_suspend	NULL</span>
<span class="cp">#define megasas_resume	NULL</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * megasas_detach_one -	PCI hot&quot;un&quot;plug entry point</span>
<span class="cm"> * @pdev:		PCI device structure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devexit</span> <span class="nf">megasas_detach_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fusion_context</span> <span class="o">*</span><span class="n">fusion</span><span class="p">;</span>

	<span class="n">instance</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">unload</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">host</span> <span class="o">=</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="n">fusion</span> <span class="o">=</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">ctrl_context</span><span class="p">;</span>

	<span class="n">scsi_remove_host</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>
	<span class="n">megasas_flush_cache</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>
	<span class="n">megasas_shutdown_controller</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">MR_DCMD_CTRL_SHUTDOWN</span><span class="p">);</span>

	<span class="cm">/* cancel the delayed work if this work still in queue*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">ev</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">megasas_aen_event</span> <span class="o">*</span><span class="n">ev</span> <span class="o">=</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">ev</span><span class="p">;</span>
		<span class="n">cancel_delayed_work_sync</span><span class="p">(</span>
			<span class="p">(</span><span class="k">struct</span> <span class="n">delayed_work</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">hotplug_work</span><span class="p">);</span>
		<span class="n">instance</span><span class="o">-&gt;</span><span class="n">ev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tasklet_kill</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">isr_tasklet</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Take the instance off the instance array. Note that we will not</span>
<span class="cm">	 * decrement the max_index. We let this array be sparse array</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">megasas_mgmt_info</span><span class="p">.</span><span class="n">max_index</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">megasas_mgmt_info</span><span class="p">.</span><span class="n">instance</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">instance</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">megasas_mgmt_info</span><span class="p">.</span><span class="n">count</span><span class="o">--</span><span class="p">;</span>
			<span class="n">megasas_mgmt_info</span><span class="p">.</span><span class="n">instance</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">instancet</span><span class="o">-&gt;</span><span class="n">disable_intr</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">reg_set</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">msix_vectors</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">msix_vectors</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">free_irq</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">msixentry</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vector</span><span class="p">,</span>
				 <span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">irq_context</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="k">else</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">irq_context</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">msix_vectors</span><span class="p">)</span>
		<span class="n">pci_disable_msix</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_LSI_FUSION</span>:
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_LSI_INVADER</span>:
		<span class="n">megasas_release_fusion</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">fusion</span><span class="o">-&gt;</span><span class="n">ld_map</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
				<span class="n">dma_free_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
						  <span class="n">fusion</span><span class="o">-&gt;</span><span class="n">map_sz</span><span class="p">,</span>
						  <span class="n">fusion</span><span class="o">-&gt;</span><span class="n">ld_map</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
						  <span class="n">fusion</span><span class="o">-&gt;</span>
						  <span class="n">ld_map_phys</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">ctrl_context</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">megasas_release_mfi</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>
		<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span>
				    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_evt_detail</span><span class="p">),</span>
				    <span class="n">instance</span><span class="o">-&gt;</span><span class="n">evt_detail</span><span class="p">,</span>
				    <span class="n">instance</span><span class="o">-&gt;</span><span class="n">evt_detail_h</span><span class="p">);</span>
		<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">),</span>
				    <span class="n">instance</span><span class="o">-&gt;</span><span class="n">producer</span><span class="p">,</span>
				    <span class="n">instance</span><span class="o">-&gt;</span><span class="n">producer_h</span><span class="p">);</span>
		<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">),</span>
				    <span class="n">instance</span><span class="o">-&gt;</span><span class="n">consumer</span><span class="p">,</span>
				    <span class="n">instance</span><span class="o">-&gt;</span><span class="n">consumer_h</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">scsi_host_put</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>

	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * megasas_shutdown -	Shutdown entry point</span>
<span class="cm"> * @device:		Generic device structure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">megasas_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">unload</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">megasas_flush_cache</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>
	<span class="n">megasas_shutdown_controller</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">MR_DCMD_CTRL_SHUTDOWN</span><span class="p">);</span>
	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">instancet</span><span class="o">-&gt;</span><span class="n">disable_intr</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">reg_set</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">msix_vectors</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">msix_vectors</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">free_irq</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">msixentry</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vector</span><span class="p">,</span>
				 <span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">irq_context</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="k">else</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">irq_context</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">msix_vectors</span><span class="p">)</span>
		<span class="n">pci_disable_msix</span><span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * megasas_mgmt_open -	char node &quot;open&quot; entry point</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">megasas_mgmt_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Allow only those users with admin rights</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * megasas_mgmt_fasync -	Async notifier registration from applications</span>
<span class="cm"> *</span>
<span class="cm"> * This function adds the calling process to a driver global queue. When an</span>
<span class="cm"> * event occurs, SIGIO will be sent to all processes in this queue.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">megasas_mgmt_fasync</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filep</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">megasas_async_queue_mutex</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">fasync_helper</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">filep</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">megasas_async_queue</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">megasas_async_queue_mutex</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* For sanity check when we get ioctl */</span>
		<span class="n">filep</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">filep</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;megasas: fasync_helper failed [%d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * megasas_mgmt_poll -  char node &quot;poll&quot; entry point</span>
<span class="cm"> * */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">megasas_mgmt_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">poll_table</span> <span class="o">*</span><span class="n">wait</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">poll_wait</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">megasas_poll_wait</span><span class="p">,</span> <span class="n">wait</span><span class="p">);</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">poll_aen_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">megasas_poll_wait_aen</span><span class="p">)</span>
		<span class="n">mask</span> <span class="o">=</span>   <span class="p">(</span><span class="n">POLLIN</span> <span class="o">|</span> <span class="n">POLLRDNORM</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">poll_aen_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">mask</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * megasas_mgmt_fw_ioctl -	Issues management ioctls to FW</span>
<span class="cm"> * @instance:			Adapter soft state</span>
<span class="cm"> * @argp:			User&#39;s ioctl packet</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">megasas_mgmt_fw_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">megasas_iocpacket</span> <span class="n">__user</span> <span class="o">*</span> <span class="n">user_ioc</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">megasas_iocpacket</span> <span class="o">*</span><span class="n">ioc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">megasas_sge32</span> <span class="o">*</span><span class="n">kern_sge32</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">megasas_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">kbuff_arr</span><span class="p">[</span><span class="n">MAX_IOCTL_SGE</span><span class="p">];</span>
	<span class="n">dma_addr_t</span> <span class="n">buf_handle</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">sense</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">sense_handle</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">sense_ptr</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">kbuff_arr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">kbuff_arr</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">sge_count</span> <span class="o">&gt;</span> <span class="n">MAX_IOCTL_SGE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;megasas: SGE count [%d] &gt;  max limit [%d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">sge_count</span><span class="p">,</span> <span class="n">MAX_IOCTL_SGE</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cmd</span> <span class="o">=</span> <span class="n">megasas_get_cmd</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;megasas: Failed to get a cmd packet</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * User&#39;s IOCTL packet has 2 frames (maximum). Copy those two</span>
<span class="cm">	 * frames into our cmd&#39;s frames. cmd-&gt;frame&#39;s context will get</span>
<span class="cm">	 * overwritten when we copy from user&#39;s frames. So set that value</span>
<span class="cm">	 * alone separately</span>
<span class="cm">	 */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">frame</span><span class="p">,</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">frame</span><span class="p">.</span><span class="n">raw</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">MEGAMFI_FRAME_SIZE</span><span class="p">);</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">context</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">pad_0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">MFI_FRAME_IEEE</span> <span class="o">|</span> <span class="n">MFI_FRAME_SGL64</span> <span class="o">|</span>
				   <span class="n">MFI_FRAME_SENSE64</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The management interface between applications and the fw uses</span>
<span class="cm">	 * MFI frames. E.g, RAID configuration changes, LD property changes</span>
<span class="cm">	 * etc are accomplishes through different kinds of MFI frames. The</span>
<span class="cm">	 * driver needs to care only about substituting user buffers with</span>
<span class="cm">	 * kernel buffers in SGLs. The location of SGL is embedded in the</span>
<span class="cm">	 * struct iocpacket itself.</span>
<span class="cm">	 */</span>
	<span class="n">kern_sge32</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">megasas_sge32</span> <span class="o">*</span><span class="p">)</span>
	    <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">frame</span> <span class="o">+</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">sgl_off</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * For each user buffer, create a mirror buffer and copy in</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">sge_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">sgl</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">iov_len</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">kbuff_arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
						    <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">sgl</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">iov_len</span><span class="p">,</span>
						    <span class="o">&amp;</span><span class="n">buf_handle</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kbuff_arr</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;megasas: Failed to alloc &quot;</span>
			       <span class="s">&quot;kernel SGL buffer for IOCTL </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * We don&#39;t change the dma_coherent_mask, so</span>
<span class="cm">		 * pci_alloc_consistent only returns 32bit addresses</span>
<span class="cm">		 */</span>
		<span class="n">kern_sge32</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">phys_addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">buf_handle</span><span class="p">;</span>
		<span class="n">kern_sge32</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">length</span> <span class="o">=</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">sgl</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">iov_len</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * We created a kernel buffer corresponding to the</span>
<span class="cm">		 * user buffer. Now copy in from the user buffer</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">kbuff_arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">sgl</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">iov_base</span><span class="p">,</span>
				   <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">sgl</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">iov_len</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">sense_len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sense</span> <span class="o">=</span> <span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">sense_len</span><span class="p">,</span>
					     <span class="o">&amp;</span><span class="n">sense_handle</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sense</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">sense_ptr</span> <span class="o">=</span>
		<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">frame</span> <span class="o">+</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">sense_off</span><span class="p">);</span>
		<span class="o">*</span><span class="n">sense_ptr</span> <span class="o">=</span> <span class="n">sense_handle</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set the sync_cmd flag so that the ISR knows not to complete this</span>
<span class="cm">	 * cmd to the SCSI mid-layer</span>
<span class="cm">	 */</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sync_cmd</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">megasas_issue_blocked_cmd</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sync_cmd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * copy out the kernel buffers to user buffers</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">sge_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">sgl</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">iov_base</span><span class="p">,</span> <span class="n">kbuff_arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
				 <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">sgl</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">iov_len</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * copy out the sense</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">sense_len</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * sense_ptr points to the location that has the user</span>
<span class="cm">		 * sense buffer address</span>
<span class="cm">		 */</span>
		<span class="n">sense_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">frame</span><span class="p">.</span><span class="n">raw</span> <span class="o">+</span>
				<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">sense_off</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">((</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="o">*</span><span class="n">sense_ptr</span><span class="p">)),</span>
				 <span class="n">sense</span><span class="p">,</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">sense_len</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;megasas: Failed to copy out to user &quot;</span>
					<span class="s">&quot;sense data</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * copy the status codes returned by the fw</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">user_ioc</span><span class="o">-&gt;</span><span class="n">frame</span><span class="p">.</span><span class="n">hdr</span><span class="p">.</span><span class="n">cmd_status</span><span class="p">,</span>
			 <span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">cmd_status</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u8</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;megasas: Error copying out cmd_status</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>

      <span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sense</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dma_free_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">sense_len</span><span class="p">,</span>
				    <span class="n">sense</span><span class="p">,</span> <span class="n">sense_handle</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">sge_count</span> <span class="o">&amp;&amp;</span> <span class="n">kbuff_arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dma_free_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				    <span class="n">kern_sge32</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">length</span><span class="p">,</span>
				    <span class="n">kbuff_arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">kern_sge32</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">phys_addr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">megasas_return_cmd</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">megasas_mgmt_ioctl_fw</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">megasas_iocpacket</span> <span class="n">__user</span> <span class="o">*</span><span class="n">user_ioc</span> <span class="o">=</span>
	    <span class="p">(</span><span class="k">struct</span> <span class="n">megasas_iocpacket</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">megasas_iocpacket</span> <span class="o">*</span><span class="n">ioc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">wait_time</span> <span class="o">=</span> <span class="n">MEGASAS_RESET_WAIT_TIME</span><span class="p">;</span>

	<span class="n">ioc</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ioc</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ioc</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">ioc</span><span class="p">,</span> <span class="n">user_ioc</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ioc</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_kfree_ioc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">instance</span> <span class="o">=</span> <span class="n">megasas_lookup_instance</span><span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">instance</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_kfree_ioc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">adprecovery</span> <span class="o">==</span> <span class="n">MEGASAS_HW_CRITICAL_ERROR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Controller in crit error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_kfree_ioc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">unload</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_kfree_ioc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We will allow only MEGASAS_INT_CMDS number of parallel ioctl cmds</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">down_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">ioctl_sem</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ERESTARTSYS</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_kfree_ioc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">wait_time</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">hba_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">adprecovery</span> <span class="o">==</span> <span class="n">MEGASAS_HBA_OPERATIONAL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">hba_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">hba_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="n">MEGASAS_RESET_NOTICE_INTERVAL</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;megasas: waiting&quot;</span>
				<span class="s">&quot;for controller reset to finish</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">msleep</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">hba_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">adprecovery</span> <span class="o">!=</span> <span class="n">MEGASAS_HBA_OPERATIONAL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">hba_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;megaraid_sas: timed out while&quot;</span>
			<span class="s">&quot;waiting for HBA to recover</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_kfree_ioc</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">hba_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">megasas_mgmt_fw_ioctl</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">user_ioc</span><span class="p">,</span> <span class="n">ioc</span><span class="p">);</span>
	<span class="n">up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">ioctl_sem</span><span class="p">);</span>

      <span class="nl">out_kfree_ioc:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ioc</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">megasas_mgmt_ioctl_aen</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">megasas_aen</span> <span class="n">aen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">wait_time</span> <span class="o">=</span> <span class="n">MEGASAS_RESET_WAIT_TIME</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">!=</span> <span class="n">file</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;megasas: fasync_helper was not &quot;</span>
		       <span class="s">&quot;called first</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aen</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">aen</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">instance</span> <span class="o">=</span> <span class="n">megasas_lookup_instance</span><span class="p">(</span><span class="n">aen</span><span class="p">.</span><span class="n">host_no</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">instance</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">adprecovery</span> <span class="o">==</span> <span class="n">MEGASAS_HW_CRITICAL_ERROR</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">unload</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">wait_time</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">hba_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">adprecovery</span> <span class="o">==</span> <span class="n">MEGASAS_HBA_OPERATIONAL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">hba_lock</span><span class="p">,</span>
						<span class="n">flags</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">hba_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="n">MEGASAS_RESET_NOTICE_INTERVAL</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;megasas: waiting for&quot;</span>
				<span class="s">&quot;controller reset to finish</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">msleep</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">hba_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">adprecovery</span> <span class="o">!=</span> <span class="n">MEGASAS_HBA_OPERATIONAL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">hba_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;megaraid_sas: timed out while waiting&quot;</span>
				<span class="s">&quot;for HBA to recover.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">hba_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">aen_mutex</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">megasas_register_aen</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">aen</span><span class="p">.</span><span class="n">seq_num</span><span class="p">,</span>
				     <span class="n">aen</span><span class="p">.</span><span class="n">class_locale_word</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">aen_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * megasas_mgmt_ioctl -	char node ioctl entry point</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">long</span>
<span class="nf">megasas_mgmt_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">MEGASAS_IOC_FIRMWARE</span>:
		<span class="k">return</span> <span class="n">megasas_mgmt_ioctl_fw</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>

	<span class="k">case</span> <span class="n">MEGASAS_IOC_GET_AEN</span>:
		<span class="k">return</span> <span class="n">megasas_mgmt_ioctl_aen</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_COMPAT</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">megasas_mgmt_compat_ioctl_fw</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">compat_megasas_iocpacket</span> <span class="n">__user</span> <span class="o">*</span><span class="n">cioc</span> <span class="o">=</span>
	    <span class="p">(</span><span class="k">struct</span> <span class="n">compat_megasas_iocpacket</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">megasas_iocpacket</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ioc</span> <span class="o">=</span>
	    <span class="n">compat_alloc_user_space</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">megasas_iocpacket</span><span class="p">));</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">compat_uptr_t</span> <span class="n">ptr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">clear_user</span><span class="p">(</span><span class="n">ioc</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ioc</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_in_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cioc</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u16</span><span class="p">))</span> <span class="o">||</span>
	    <span class="n">copy_in_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">sgl_off</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cioc</span><span class="o">-&gt;</span><span class="n">sgl_off</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">))</span> <span class="o">||</span>
	    <span class="n">copy_in_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">sense_off</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cioc</span><span class="o">-&gt;</span><span class="n">sense_off</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">))</span> <span class="o">||</span>
	    <span class="n">copy_in_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">sense_len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cioc</span><span class="o">-&gt;</span><span class="n">sense_len</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">))</span> <span class="o">||</span>
	    <span class="n">copy_in_user</span><span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">frame</span><span class="p">.</span><span class="n">raw</span><span class="p">,</span> <span class="n">cioc</span><span class="o">-&gt;</span><span class="n">frame</span><span class="p">.</span><span class="n">raw</span><span class="p">,</span> <span class="mi">128</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">copy_in_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">sge_count</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cioc</span><span class="o">-&gt;</span><span class="n">sge_count</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The sense_ptr is used in megasas_mgmt_fw_ioctl only when</span>
<span class="cm">	 * sense_len is not null, so prepare the 64bit value under</span>
<span class="cm">	 * the same condition.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">sense_len</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">void</span> <span class="n">__user</span> <span class="o">**</span><span class="n">sense_ioc_ptr</span> <span class="o">=</span>
			<span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">**</span><span class="p">)(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">frame</span><span class="p">.</span><span class="n">raw</span> <span class="o">+</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">sense_off</span><span class="p">);</span>
		<span class="n">compat_uptr_t</span> <span class="o">*</span><span class="n">sense_cioc_ptr</span> <span class="o">=</span>
			<span class="p">(</span><span class="n">compat_uptr_t</span> <span class="o">*</span><span class="p">)(</span><span class="n">cioc</span><span class="o">-&gt;</span><span class="n">frame</span><span class="p">.</span><span class="n">raw</span> <span class="o">+</span> <span class="n">cioc</span><span class="o">-&gt;</span><span class="n">sense_off</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">sense_cioc_ptr</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">put_user</span><span class="p">(</span><span class="n">compat_ptr</span><span class="p">(</span><span class="n">ptr</span><span class="p">),</span> <span class="n">sense_ioc_ptr</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_IOCTL_SGE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cioc</span><span class="o">-&gt;</span><span class="n">sgl</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">iov_base</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">put_user</span><span class="p">(</span><span class="n">compat_ptr</span><span class="p">(</span><span class="n">ptr</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">sgl</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">iov_base</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">copy_in_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">sgl</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">iov_len</span><span class="p">,</span>
				 <span class="o">&amp;</span><span class="n">cioc</span><span class="o">-&gt;</span><span class="n">sgl</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">iov_len</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">compat_size_t</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">megasas_mgmt_ioctl_fw</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ioc</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_in_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cioc</span><span class="o">-&gt;</span><span class="n">frame</span><span class="p">.</span><span class="n">hdr</span><span class="p">.</span><span class="n">cmd_status</span><span class="p">,</span>
			 <span class="o">&amp;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">frame</span><span class="p">.</span><span class="n">hdr</span><span class="p">.</span><span class="n">cmd_status</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u8</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;megasas: error copy_in_user cmd_status</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">long</span>
<span class="nf">megasas_mgmt_compat_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">MEGASAS_IOC_FIRMWARE32</span>:
		<span class="k">return</span> <span class="n">megasas_mgmt_compat_ioctl_fw</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">MEGASAS_IOC_GET_AEN</span>:
		<span class="k">return</span> <span class="n">megasas_mgmt_ioctl_aen</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * File operations structure for management interface</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">megasas_mgmt_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">megasas_mgmt_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fasync</span> <span class="o">=</span> <span class="n">megasas_mgmt_fasync</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unlocked_ioctl</span> <span class="o">=</span> <span class="n">megasas_mgmt_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">poll</span> <span class="o">=</span> <span class="n">megasas_mgmt_poll</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_COMPAT</span>
	<span class="p">.</span><span class="n">compat_ioctl</span> <span class="o">=</span> <span class="n">megasas_mgmt_compat_ioctl</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span> <span class="n">noop_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * PCI hotplug support registration structure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_driver</span> <span class="n">megasas_pci_driver</span> <span class="o">=</span> <span class="p">{</span>

	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;megaraid_sas&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_table</span> <span class="o">=</span> <span class="n">megasas_pci_table</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span> <span class="o">=</span> <span class="n">megasas_probe_one</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span> <span class="o">=</span> <span class="n">__devexit_p</span><span class="p">(</span><span class="n">megasas_detach_one</span><span class="p">),</span>
	<span class="p">.</span><span class="n">suspend</span> <span class="o">=</span> <span class="n">megasas_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span> <span class="o">=</span> <span class="n">megasas_resume</span><span class="p">,</span>
	<span class="p">.</span><span class="n">shutdown</span> <span class="o">=</span> <span class="n">megasas_shutdown</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Sysfs driver attributes</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">megasas_sysfs_show_version</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">MEGASAS_VERSION</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">MEGASAS_VERSION</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DRIVER_ATTR</span><span class="p">(</span><span class="n">version</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">megasas_sysfs_show_version</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">megasas_sysfs_show_release_date</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">MEGASAS_RELDATE</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">MEGASAS_RELDATE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DRIVER_ATTR</span><span class="p">(</span><span class="n">release_date</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">megasas_sysfs_show_release_date</span><span class="p">,</span>
		   <span class="nb">NULL</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">megasas_sysfs_show_support_poll_for_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">support_poll_for_event</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DRIVER_ATTR</span><span class="p">(</span><span class="n">support_poll_for_event</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span>
			<span class="n">megasas_sysfs_show_support_poll_for_event</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

 <span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">megasas_sysfs_show_support_device_change</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">support_device_change</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DRIVER_ATTR</span><span class="p">(</span><span class="n">support_device_change</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span>
			<span class="n">megasas_sysfs_show_support_device_change</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">megasas_sysfs_show_dbg_lvl</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">megasas_dbg_lvl</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">megasas_sysfs_set_dbg_lvl</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">sscanf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="s">&quot;%u&quot;</span><span class="p">,</span><span class="o">&amp;</span><span class="n">megasas_dbg_lvl</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">){</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;megasas: could not set dbg_lvl</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DRIVER_ATTR</span><span class="p">(</span><span class="n">dbg_lvl</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="o">|</span><span class="n">S_IWUSR</span><span class="p">,</span> <span class="n">megasas_sysfs_show_dbg_lvl</span><span class="p">,</span>
		<span class="n">megasas_sysfs_set_dbg_lvl</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">megasas_aen_polling</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">megasas_aen_event</span> <span class="o">*</span><span class="n">ev</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">megasas_aen_event</span><span class="p">,</span> <span class="n">hotplug_work</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">megasas_instance</span> <span class="o">*</span><span class="n">instance</span> <span class="o">=</span> <span class="n">ev</span><span class="o">-&gt;</span><span class="n">instance</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">megasas_evt_class_locale</span> <span class="n">class_locale</span><span class="p">;</span>
	<span class="k">struct</span>  <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span>  <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev1</span><span class="p">;</span>
	<span class="n">u16</span>     <span class="n">pd_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u16</span>	<span class="n">ld_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>     <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">doscan</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">seq_num</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">instance</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;invalid instance!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">ev</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">instance</span><span class="o">-&gt;</span><span class="n">ev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">host</span> <span class="o">=</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">evt_detail</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">evt_detail</span><span class="o">-&gt;</span><span class="n">code</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">MR_EVT_PD_INSERTED</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">megasas_get_pd_list</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MEGASAS_MAX_PD_CHANNELS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">j</span> <span class="o">&lt;</span> <span class="n">MEGASAS_MAX_DEV_PER_CHANNEL</span><span class="p">;</span>
				<span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

				<span class="n">pd_index</span> <span class="o">=</span>
				<span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">MEGASAS_MAX_DEV_PER_CHANNEL</span><span class="p">)</span> <span class="o">+</span> <span class="n">j</span><span class="p">;</span>

				<span class="n">sdev1</span> <span class="o">=</span>
				<span class="n">scsi_device_lookup</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pd_list</span><span class="p">[</span><span class="n">pd_index</span><span class="p">].</span><span class="n">driveState</span>
						<span class="o">==</span> <span class="n">MR_PD_STATE_SYSTEM</span><span class="p">)</span> <span class="p">{</span>
						<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sdev1</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">scsi_add_device</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
						<span class="p">}</span>

					<span class="k">if</span> <span class="p">(</span><span class="n">sdev1</span><span class="p">)</span>
						<span class="n">scsi_device_put</span><span class="p">(</span><span class="n">sdev1</span><span class="p">);</span>
					<span class="p">}</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="p">}</span>
			<span class="n">doscan</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">MR_EVT_PD_REMOVED</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">megasas_get_pd_list</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">megasas_get_pd_list</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MEGASAS_MAX_PD_CHANNELS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">j</span> <span class="o">&lt;</span> <span class="n">MEGASAS_MAX_DEV_PER_CHANNEL</span><span class="p">;</span>
				<span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

				<span class="n">pd_index</span> <span class="o">=</span>
				<span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">MEGASAS_MAX_DEV_PER_CHANNEL</span><span class="p">)</span> <span class="o">+</span> <span class="n">j</span><span class="p">;</span>

				<span class="n">sdev1</span> <span class="o">=</span>
				<span class="n">scsi_device_lookup</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pd_list</span><span class="p">[</span><span class="n">pd_index</span><span class="p">].</span><span class="n">driveState</span>
					<span class="o">==</span> <span class="n">MR_PD_STATE_SYSTEM</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">sdev1</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">scsi_device_put</span><span class="p">(</span><span class="n">sdev1</span><span class="p">);</span>
					<span class="p">}</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">sdev1</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">scsi_remove_device</span><span class="p">(</span><span class="n">sdev1</span><span class="p">);</span>
						<span class="n">scsi_device_put</span><span class="p">(</span><span class="n">sdev1</span><span class="p">);</span>
					<span class="p">}</span>
				<span class="p">}</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="p">}</span>
			<span class="n">doscan</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">MR_EVT_LD_OFFLINE</span>:
		<span class="k">case</span> <span class="n">MR_EVT_CFG_CLEARED</span>:
		<span class="k">case</span> <span class="n">MR_EVT_LD_DELETED</span>:
			<span class="n">megasas_get_ld_list</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MEGASAS_MAX_LD_CHANNELS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">j</span> <span class="o">&lt;</span> <span class="n">MEGASAS_MAX_DEV_PER_CHANNEL</span><span class="p">;</span>
				<span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

				<span class="n">ld_index</span> <span class="o">=</span>
				<span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">MEGASAS_MAX_DEV_PER_CHANNEL</span><span class="p">)</span> <span class="o">+</span> <span class="n">j</span><span class="p">;</span>

				<span class="n">sdev1</span> <span class="o">=</span> <span class="n">scsi_device_lookup</span><span class="p">(</span><span class="n">host</span><span class="p">,</span>
					<span class="n">i</span> <span class="o">+</span> <span class="n">MEGASAS_MAX_LD_CHANNELS</span><span class="p">,</span>
					<span class="n">j</span><span class="p">,</span>
					<span class="mi">0</span><span class="p">);</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">ld_ids</span><span class="p">[</span><span class="n">ld_index</span><span class="p">]</span> <span class="o">!=</span> <span class="mh">0xff</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">sdev1</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">scsi_device_put</span><span class="p">(</span><span class="n">sdev1</span><span class="p">);</span>
					<span class="p">}</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">sdev1</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">scsi_remove_device</span><span class="p">(</span><span class="n">sdev1</span><span class="p">);</span>
						<span class="n">scsi_device_put</span><span class="p">(</span><span class="n">sdev1</span><span class="p">);</span>
					<span class="p">}</span>
				<span class="p">}</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="n">doscan</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">MR_EVT_LD_CREATED</span>:
			<span class="n">megasas_get_ld_list</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MEGASAS_MAX_LD_CHANNELS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="n">j</span> <span class="o">&lt;</span> <span class="n">MEGASAS_MAX_DEV_PER_CHANNEL</span><span class="p">;</span>
					<span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">ld_index</span> <span class="o">=</span>
					<span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">MEGASAS_MAX_DEV_PER_CHANNEL</span><span class="p">)</span> <span class="o">+</span> <span class="n">j</span><span class="p">;</span>

					<span class="n">sdev1</span> <span class="o">=</span> <span class="n">scsi_device_lookup</span><span class="p">(</span><span class="n">host</span><span class="p">,</span>
						<span class="n">i</span><span class="o">+</span><span class="n">MEGASAS_MAX_LD_CHANNELS</span><span class="p">,</span>
						<span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

					<span class="k">if</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">ld_ids</span><span class="p">[</span><span class="n">ld_index</span><span class="p">]</span> <span class="o">!=</span>
								<span class="mh">0xff</span><span class="p">)</span> <span class="p">{</span>
						<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sdev1</span><span class="p">)</span> <span class="p">{</span>
							<span class="n">scsi_add_device</span><span class="p">(</span><span class="n">host</span><span class="p">,</span>
								<span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span>
								<span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
						<span class="p">}</span>
					<span class="p">}</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">sdev1</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">scsi_device_put</span><span class="p">(</span><span class="n">sdev1</span><span class="p">);</span>
					<span class="p">}</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="n">doscan</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">MR_EVT_CTRL_HOST_BUS_SCAN_REQUESTED</span>:
		<span class="k">case</span> <span class="n">MR_EVT_FOREIGN_CFG_IMPORTED</span>:
		<span class="k">case</span> <span class="n">MR_EVT_LD_STATE_CHANGE</span>:
			<span class="n">doscan</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">doscan</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;invalid evt_detail!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">ev</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">doscan</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;scanning ...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">megasas_get_pd_list</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MEGASAS_MAX_PD_CHANNELS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">MEGASAS_MAX_DEV_PER_CHANNEL</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pd_index</span> <span class="o">=</span> <span class="n">i</span><span class="o">*</span><span class="n">MEGASAS_MAX_DEV_PER_CHANNEL</span> <span class="o">+</span> <span class="n">j</span><span class="p">;</span>
				<span class="n">sdev1</span> <span class="o">=</span> <span class="n">scsi_device_lookup</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">pd_list</span><span class="p">[</span><span class="n">pd_index</span><span class="p">].</span><span class="n">driveState</span> <span class="o">==</span>
							<span class="n">MR_PD_STATE_SYSTEM</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sdev1</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">scsi_add_device</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
					<span class="p">}</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">sdev1</span><span class="p">)</span>
						<span class="n">scsi_device_put</span><span class="p">(</span><span class="n">sdev1</span><span class="p">);</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">sdev1</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">scsi_remove_device</span><span class="p">(</span><span class="n">sdev1</span><span class="p">);</span>
						<span class="n">scsi_device_put</span><span class="p">(</span><span class="n">sdev1</span><span class="p">);</span>
					<span class="p">}</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">megasas_get_ld_list</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MEGASAS_MAX_LD_CHANNELS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">MEGASAS_MAX_DEV_PER_CHANNEL</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ld_index</span> <span class="o">=</span>
				<span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">MEGASAS_MAX_DEV_PER_CHANNEL</span><span class="p">)</span> <span class="o">+</span> <span class="n">j</span><span class="p">;</span>

				<span class="n">sdev1</span> <span class="o">=</span> <span class="n">scsi_device_lookup</span><span class="p">(</span><span class="n">host</span><span class="p">,</span>
					<span class="n">i</span><span class="o">+</span><span class="n">MEGASAS_MAX_LD_CHANNELS</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">ld_ids</span><span class="p">[</span><span class="n">ld_index</span><span class="p">]</span> <span class="o">!=</span> <span class="mh">0xff</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sdev1</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">scsi_add_device</span><span class="p">(</span><span class="n">host</span><span class="p">,</span>
								<span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span>
								<span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
					<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
						<span class="n">scsi_device_put</span><span class="p">(</span><span class="n">sdev1</span><span class="p">);</span>
					<span class="p">}</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">sdev1</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">scsi_remove_device</span><span class="p">(</span><span class="n">sdev1</span><span class="p">);</span>
						<span class="n">scsi_device_put</span><span class="p">(</span><span class="n">sdev1</span><span class="p">);</span>
					<span class="p">}</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">aen_cmd</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">ev</span><span class="p">);</span>
		<span class="k">return</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="n">seq_num</span> <span class="o">=</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">evt_detail</span><span class="o">-&gt;</span><span class="n">seq_num</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Register AEN with FW for latest sequence number plus 1 */</span>
	<span class="n">class_locale</span><span class="p">.</span><span class="n">members</span><span class="p">.</span><span class="n">reserved</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">class_locale</span><span class="p">.</span><span class="n">members</span><span class="p">.</span><span class="n">locale</span> <span class="o">=</span> <span class="n">MR_EVT_LOCALE_ALL</span><span class="p">;</span>
	<span class="n">class_locale</span><span class="p">.</span><span class="n">members</span><span class="p">.</span><span class="n">class</span> <span class="o">=</span> <span class="n">MR_EVT_CLASS_DEBUG</span><span class="p">;</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">aen_mutex</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">megasas_register_aen</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">seq_num</span><span class="p">,</span>
					<span class="n">class_locale</span><span class="p">.</span><span class="n">word</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">aen_mutex</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;register aen failed error %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">ev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * megasas_init - Driver load entry point</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">megasas_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rval</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Announce driver version and other information</span>
<span class="cm">	 */</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;megasas: %s %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">MEGASAS_VERSION</span><span class="p">,</span>
	       <span class="n">MEGASAS_EXT_VERSION</span><span class="p">);</span>

	<span class="n">support_poll_for_event</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">support_device_change</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">megasas_mgmt_info</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">megasas_mgmt_info</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Register character device node</span>
<span class="cm">	 */</span>
	<span class="n">rval</span> <span class="o">=</span> <span class="n">register_chrdev</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;megaraid_sas_ioctl&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">megasas_mgmt_fops</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;megasas: failed to open device node</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rval</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">megasas_mgmt_majorno</span> <span class="o">=</span> <span class="n">rval</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Register ourselves as PCI hotplug module</span>
<span class="cm">	 */</span>
	<span class="n">rval</span> <span class="o">=</span> <span class="n">pci_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">megasas_pci_driver</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rval</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;megasas: PCI hotplug regisration failed </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_pcidrv</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rval</span> <span class="o">=</span> <span class="n">driver_create_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">megasas_pci_driver</span><span class="p">.</span><span class="n">driver</span><span class="p">,</span>
				  <span class="o">&amp;</span><span class="n">driver_attr_version</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_dcf_attr_ver</span><span class="p">;</span>
	<span class="n">rval</span> <span class="o">=</span> <span class="n">driver_create_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">megasas_pci_driver</span><span class="p">.</span><span class="n">driver</span><span class="p">,</span>
				  <span class="o">&amp;</span><span class="n">driver_attr_release_date</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_dcf_rel_date</span><span class="p">;</span>

	<span class="n">rval</span> <span class="o">=</span> <span class="n">driver_create_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">megasas_pci_driver</span><span class="p">.</span><span class="n">driver</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">driver_attr_support_poll_for_event</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_dcf_support_poll_for_event</span><span class="p">;</span>

	<span class="n">rval</span> <span class="o">=</span> <span class="n">driver_create_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">megasas_pci_driver</span><span class="p">.</span><span class="n">driver</span><span class="p">,</span>
				  <span class="o">&amp;</span><span class="n">driver_attr_dbg_lvl</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_dcf_dbg_lvl</span><span class="p">;</span>
	<span class="n">rval</span> <span class="o">=</span> <span class="n">driver_create_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">megasas_pci_driver</span><span class="p">.</span><span class="n">driver</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">driver_attr_support_device_change</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_dcf_support_device_change</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">rval</span><span class="p">;</span>

<span class="nl">err_dcf_support_device_change:</span>
	<span class="n">driver_remove_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">megasas_pci_driver</span><span class="p">.</span><span class="n">driver</span><span class="p">,</span>
			   <span class="o">&amp;</span><span class="n">driver_attr_dbg_lvl</span><span class="p">);</span>
<span class="nl">err_dcf_dbg_lvl:</span>
	<span class="n">driver_remove_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">megasas_pci_driver</span><span class="p">.</span><span class="n">driver</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">driver_attr_support_poll_for_event</span><span class="p">);</span>

<span class="nl">err_dcf_support_poll_for_event:</span>
	<span class="n">driver_remove_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">megasas_pci_driver</span><span class="p">.</span><span class="n">driver</span><span class="p">,</span>
			   <span class="o">&amp;</span><span class="n">driver_attr_release_date</span><span class="p">);</span>

<span class="nl">err_dcf_rel_date:</span>
	<span class="n">driver_remove_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">megasas_pci_driver</span><span class="p">.</span><span class="n">driver</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">driver_attr_version</span><span class="p">);</span>
<span class="nl">err_dcf_attr_ver:</span>
	<span class="n">pci_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">megasas_pci_driver</span><span class="p">);</span>
<span class="nl">err_pcidrv:</span>
	<span class="n">unregister_chrdev</span><span class="p">(</span><span class="n">megasas_mgmt_majorno</span><span class="p">,</span> <span class="s">&quot;megaraid_sas_ioctl&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * megasas_exit - Driver unload entry point</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">megasas_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">driver_remove_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">megasas_pci_driver</span><span class="p">.</span><span class="n">driver</span><span class="p">,</span>
			   <span class="o">&amp;</span><span class="n">driver_attr_dbg_lvl</span><span class="p">);</span>
	<span class="n">driver_remove_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">megasas_pci_driver</span><span class="p">.</span><span class="n">driver</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">driver_attr_support_poll_for_event</span><span class="p">);</span>
	<span class="n">driver_remove_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">megasas_pci_driver</span><span class="p">.</span><span class="n">driver</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">driver_attr_support_device_change</span><span class="p">);</span>
	<span class="n">driver_remove_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">megasas_pci_driver</span><span class="p">.</span><span class="n">driver</span><span class="p">,</span>
			   <span class="o">&amp;</span><span class="n">driver_attr_release_date</span><span class="p">);</span>
	<span class="n">driver_remove_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">megasas_pci_driver</span><span class="p">.</span><span class="n">driver</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">driver_attr_version</span><span class="p">);</span>

	<span class="n">pci_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">megasas_pci_driver</span><span class="p">);</span>
	<span class="n">unregister_chrdev</span><span class="p">(</span><span class="n">megasas_mgmt_majorno</span><span class="p">,</span> <span class="s">&quot;megaraid_sas_ioctl&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">megasas_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">megasas_exit</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
