<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › scsi › megaraid › megaraid_ioctl.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>megaraid_ioctl.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *</span>
<span class="cm"> *			Linux MegaRAID device driver</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2003-2004  LSI Logic Corporation.</span>
<span class="cm"> *</span>
<span class="cm"> *	   This program is free software; you can redistribute it and/or</span>
<span class="cm"> *	   modify it under the terms of the GNU General Public License</span>
<span class="cm"> *	   as published by the Free Software Foundation; either version</span>
<span class="cm"> *	   2 of the License, or (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * FILE		: megaraid_ioctl.h</span>
<span class="cm"> *</span>
<span class="cm"> * Definitions to interface with user level applications</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _MEGARAID_IOCTL_H_</span>
<span class="cp">#define _MEGARAID_IOCTL_H_</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/semaphore.h&gt;</span>

<span class="cp">#include &quot;mbox_defs.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * console messages debug levels</span>
<span class="cm"> */</span>
<span class="cp">#define	CL_ANN		0	</span><span class="cm">/* print unconditionally, announcements */</span><span class="cp"></span>
<span class="cp">#define CL_DLEVEL1	1	</span><span class="cm">/* debug level 1, informative */</span><span class="cp"></span>
<span class="cp">#define CL_DLEVEL2	2	</span><span class="cm">/* debug level 2, verbose */</span><span class="cp"></span>
<span class="cp">#define CL_DLEVEL3	3	</span><span class="cm">/* debug level 3, very verbose */</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> * con_log() - console log routine</span>
<span class="cm"> * @level		: indicates the severity of the message.</span>
<span class="cm"> * @fmt			: format string</span>
<span class="cm"> *</span>
<span class="cm"> * con_log displays the error messages on the console based on the current</span>
<span class="cm"> * debug level. Also it attaches the appropriate kernel severity level with</span>
<span class="cm"> * the message.</span>
<span class="cm"> */</span>
<span class="cp">#define	con_log(level, fmt) if (LSI_DBGLVL &gt;= level) printk fmt;</span>

<span class="cm">/*</span>
<span class="cm"> * Definitions &amp; Declarations needed to use common management module</span>
<span class="cm"> */</span>

<span class="cp">#define MEGAIOC_MAGIC		&#39;m&#39;</span>
<span class="cp">#define MEGAIOCCMD		_IOWR(MEGAIOC_MAGIC, 0, mimd_t)</span>

<span class="cp">#define MEGAIOC_QNADAP		&#39;m&#39;	</span><span class="cm">/* Query # of adapters		*/</span><span class="cp"></span>
<span class="cp">#define MEGAIOC_QDRVRVER	&#39;e&#39;	</span><span class="cm">/* Query driver version		*/</span><span class="cp"></span>
<span class="cp">#define MEGAIOC_QADAPINFO   	&#39;g&#39;	</span><span class="cm">/* Query adapter information	*/</span><span class="cp"></span>

<span class="cp">#define USCSICMD		0x80</span>
<span class="cp">#define UIOC_RD			0x00001</span>
<span class="cp">#define UIOC_WR			0x00002</span>

<span class="cp">#define MBOX_CMD		0x00000</span>
<span class="cp">#define GET_DRIVER_VER		0x10000</span>
<span class="cp">#define GET_N_ADAP		0x20000</span>
<span class="cp">#define GET_ADAP_INFO		0x30000</span>
<span class="cp">#define GET_CAP			0x40000</span>
<span class="cp">#define GET_STATS		0x50000</span>
<span class="cp">#define GET_IOCTL_VERSION	0x01</span>

<span class="cp">#define EXT_IOCTL_SIGN_SZ	16</span>
<span class="cp">#define EXT_IOCTL_SIGN		&quot;$$_EXTD_IOCTL_$$&quot;</span>

<span class="cp">#define	MBOX_LEGACY		0x00		</span><span class="cm">/* ioctl has legacy mbox*/</span><span class="cp"></span>
<span class="cp">#define MBOX_HPE		0x01		</span><span class="cm">/* ioctl has hpe mbox	*/</span><span class="cp"></span>

<span class="cp">#define	APPTYPE_MIMD		0x00		</span><span class="cm">/* old existing apps	*/</span><span class="cp"></span>
<span class="cp">#define APPTYPE_UIOC		0x01		</span><span class="cm">/* new apps using uioc	*/</span><span class="cp"></span>

<span class="cp">#define IOCTL_ISSUE		0x00000001	</span><span class="cm">/* Issue ioctl		*/</span><span class="cp"></span>
<span class="cp">#define IOCTL_ABORT		0x00000002	</span><span class="cm">/* Abort previous ioctl	*/</span><span class="cp"></span>

<span class="cp">#define DRVRTYPE_MBOX		0x00000001	</span><span class="cm">/* regular mbox driver	*/</span><span class="cp"></span>
<span class="cp">#define DRVRTYPE_HPE		0x00000002	</span><span class="cm">/* new hpe driver	*/</span><span class="cp"></span>

<span class="cp">#define MKADAP(adapno)	(MEGAIOC_MAGIC &lt;&lt; 8 | (adapno) )</span>
<span class="cp">#define GETADAP(mkadap)	((mkadap) ^ MEGAIOC_MAGIC &lt;&lt; 8)</span>

<span class="cp">#define MAX_DMA_POOLS		5		</span><span class="cm">/* 4k, 8k, 16k, 32k, 64k*/</span><span class="cp"></span>


<span class="cm">/**</span>
<span class="cm"> * struct uioc_t - the common ioctl packet structure</span>
<span class="cm"> *</span>
<span class="cm"> * @signature	: Must be &quot;$$_EXTD_IOCTL_$$&quot;</span>
<span class="cm"> * @mb_type	: Type of the mail box (MB_LEGACY or MB_HPE)</span>
<span class="cm"> * @app_type	: Type of the issuing application (existing or new)</span>
<span class="cm"> * @opcode	: Opcode of the command</span>
<span class="cm"> * @adapno	: Adapter number</span>
<span class="cm"> * @cmdbuf	: Pointer to buffer - can point to mbox or plain data buffer</span>
<span class="cm"> * @xferlen	: xferlen for DCMD and non mailbox commands</span>
<span class="cm"> * @data_dir	: Direction of the data transfer</span>
<span class="cm"> * @status	: Status from the driver</span>
<span class="cm"> * @reserved	: reserved bytes for future expansion</span>
<span class="cm"> *</span>
<span class="cm"> * @user_data	: user data transfer address is saved in this</span>
<span class="cm"> * @user_data_len: length of the data buffer sent by user app</span>
<span class="cm"> * @user_pthru	: user passthru address is saves in this (null if DCMD)</span>
<span class="cm"> * @pthru32	: kernel address passthru (allocated per kioc)</span>
<span class="cm"> * @pthru32_h	: physicall address of @pthru32</span>
<span class="cm"> * @list	: for kioc free pool list maintenance</span>
<span class="cm"> * @done	: call back routine for llds to call when kioc is completed</span>
<span class="cm"> * @buf_vaddr	: dma pool buffer attached to kioc for data transfer</span>
<span class="cm"> * @buf_paddr	: physical address of the dma pool buffer</span>
<span class="cm"> * @pool_index	: index of the dma pool that @buf_vaddr is taken from</span>
<span class="cm"> * @free_buf	: indicates if buffer needs to be freed after kioc completes</span>
<span class="cm"> *</span>
<span class="cm"> * Note		: All LSI drivers understand only this packet. Any other</span>
<span class="cm"> *		: format sent by applications would be converted to this.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">uioc</span> <span class="p">{</span>

<span class="cm">/* User Apps: */</span>

	<span class="kt">uint8_t</span>			<span class="n">signature</span><span class="p">[</span><span class="n">EXT_IOCTL_SIGN_SZ</span><span class="p">];</span>
	<span class="kt">uint16_t</span>		<span class="n">mb_type</span><span class="p">;</span>
	<span class="kt">uint16_t</span>		<span class="n">app_type</span><span class="p">;</span>
	<span class="kt">uint32_t</span>		<span class="n">opcode</span><span class="p">;</span>
	<span class="kt">uint32_t</span>		<span class="n">adapno</span><span class="p">;</span>
	<span class="kt">uint64_t</span>		<span class="n">cmdbuf</span><span class="p">;</span>
	<span class="kt">uint32_t</span>		<span class="n">xferlen</span><span class="p">;</span>
	<span class="kt">uint32_t</span>		<span class="n">data_dir</span><span class="p">;</span>
	<span class="kt">int32_t</span>			<span class="n">status</span><span class="p">;</span>
	<span class="kt">uint8_t</span>			<span class="n">reserved</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span>

<span class="cm">/* Driver Data: */</span>
	<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span>		<span class="n">user_data</span><span class="p">;</span>
	<span class="kt">uint32_t</span>		<span class="n">user_data_len</span><span class="p">;</span>

	<span class="cm">/* 64bit alignment */</span>
	<span class="kt">uint32_t</span>                <span class="n">pad_for_64bit_align</span><span class="p">;</span>

	<span class="n">mraid_passthru_t</span>	<span class="n">__user</span> <span class="o">*</span><span class="n">user_pthru</span><span class="p">;</span>

	<span class="n">mraid_passthru_t</span>	<span class="o">*</span><span class="n">pthru32</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>		<span class="n">pthru32_h</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">list</span><span class="p">;</span>
	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">done</span><span class="p">)(</span><span class="k">struct</span> <span class="n">uioc</span><span class="o">*</span><span class="p">);</span>

	<span class="n">caddr_t</span>			<span class="n">buf_vaddr</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>		<span class="n">buf_paddr</span><span class="p">;</span>
	<span class="kt">int8_t</span>			<span class="n">pool_index</span><span class="p">;</span>
	<span class="kt">uint8_t</span>			<span class="n">free_buf</span><span class="p">;</span>

	<span class="kt">uint8_t</span>			<span class="n">timedout</span><span class="p">;</span>

<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="mi">1024</span><span class="p">),</span><span class="n">packed</span><span class="p">))</span> <span class="n">uioc_t</span><span class="p">;</span>


<span class="cm">/**</span>
<span class="cm"> * struct mraid_hba_info - information about the controller</span>
<span class="cm"> *</span>
<span class="cm"> * @pci_vendor_id		: PCI vendor id</span>
<span class="cm"> * @pci_device_id		: PCI device id</span>
<span class="cm"> * @subsystem_vendor_id		: PCI subsystem vendor id</span>
<span class="cm"> * @subsystem_device_id		: PCI subsystem device id</span>
<span class="cm"> * @baseport			: base port of hba memory</span>
<span class="cm"> * @pci_bus			: PCI bus</span>
<span class="cm"> * @pci_dev_fn			: PCI device/function values</span>
<span class="cm"> * @irq				: interrupt vector for the device</span>
<span class="cm"> *</span>
<span class="cm"> * Extended information of 256 bytes about the controller. Align on the single</span>
<span class="cm"> * byte boundary so that 32-bit applications can be run on 64-bit platform</span>
<span class="cm"> * drivers withoug re-compilation.</span>
<span class="cm"> * NOTE: reduce the number of reserved bytes whenever new field are added, so</span>
<span class="cm"> * that total size of the structure remains 256 bytes.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">mraid_hba_info</span> <span class="p">{</span>

	<span class="kt">uint16_t</span>	<span class="n">pci_vendor_id</span><span class="p">;</span>
	<span class="kt">uint16_t</span>	<span class="n">pci_device_id</span><span class="p">;</span>
	<span class="kt">uint16_t</span>	<span class="n">subsys_vendor_id</span><span class="p">;</span>
	<span class="kt">uint16_t</span>	<span class="n">subsys_device_id</span><span class="p">;</span>

	<span class="kt">uint64_t</span>	<span class="n">baseport</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">pci_bus</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">pci_dev_fn</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">pci_slot</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">irq</span><span class="p">;</span>

	<span class="kt">uint32_t</span>	<span class="n">unique_id</span><span class="p">;</span>
	<span class="kt">uint32_t</span>	<span class="n">host_no</span><span class="p">;</span>

	<span class="kt">uint8_t</span>		<span class="n">num_ldrv</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="mi">256</span><span class="p">),</span> <span class="n">packed</span><span class="p">))</span> <span class="n">mraid_hba_info_t</span><span class="p">;</span>


<span class="cm">/**</span>
<span class="cm"> * mcontroller	: adapter info structure for old mimd_t apps</span>
<span class="cm"> *</span>
<span class="cm"> * @base	: base address</span>
<span class="cm"> * @irq		: irq number</span>
<span class="cm"> * @numldrv	: number of logical drives</span>
<span class="cm"> * @pcibus	: pci bus</span>
<span class="cm"> * @pcidev	: pci device</span>
<span class="cm"> * @pcifun	: pci function</span>
<span class="cm"> * @pciid	: pci id</span>
<span class="cm"> * @pcivendor	: vendor id</span>
<span class="cm"> * @pcislot	: slot number</span>
<span class="cm"> * @uid		: unique id</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">mcontroller</span> <span class="p">{</span>

	<span class="kt">uint64_t</span>	<span class="n">base</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">irq</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">numldrv</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">pcibus</span><span class="p">;</span>
	<span class="kt">uint16_t</span>	<span class="n">pcidev</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">pcifun</span><span class="p">;</span>
	<span class="kt">uint16_t</span>	<span class="n">pciid</span><span class="p">;</span>
	<span class="kt">uint16_t</span>	<span class="n">pcivendor</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">pcislot</span><span class="p">;</span>
	<span class="kt">uint32_t</span>	<span class="n">uid</span><span class="p">;</span>

<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">mcontroller_t</span><span class="p">;</span>


<span class="cm">/**</span>
<span class="cm"> * mm_dmapool_t	: Represents one dma pool with just one buffer</span>
<span class="cm"> *</span>
<span class="cm"> * @vaddr	: Virtual address</span>
<span class="cm"> * @paddr	: DMA physicall address</span>
<span class="cm"> * @bufsize	: In KB - 4 = 4k, 8 = 8k etc.</span>
<span class="cm"> * @handle	: Handle to the dma pool</span>
<span class="cm"> * @lock	: lock to synchronize access to the pool</span>
<span class="cm"> * @in_use	: If pool already in use, attach new block</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">mm_dmapool</span> <span class="p">{</span>
	<span class="n">caddr_t</span>		<span class="n">vaddr</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>	<span class="n">paddr</span><span class="p">;</span>
	<span class="kt">uint32_t</span>	<span class="n">buf_size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dma_pool</span>	<span class="o">*</span><span class="n">handle</span><span class="p">;</span>
	<span class="n">spinlock_t</span>	<span class="n">lock</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">in_use</span><span class="p">;</span>
<span class="p">}</span> <span class="n">mm_dmapool_t</span><span class="p">;</span>


<span class="cm">/**</span>
<span class="cm"> * mraid_mmadp_t: Structure that drivers pass during (un)registration</span>
<span class="cm"> *</span>
<span class="cm"> * @unique_id		: Any unique id (usually PCI bus+dev+fn)</span>
<span class="cm"> * @drvr_type		: megaraid or hpe (DRVRTYPE_MBOX or DRVRTYPE_HPE)</span>
<span class="cm"> * @drv_data		: Driver specific; not touched by the common module</span>
<span class="cm"> * @timeout		: timeout for issued kiocs</span>
<span class="cm"> * @max_kioc		: Maximum ioctl packets acceptable by the lld</span>
<span class="cm"> * @pdev		: pci dev; used for allocating dma&#39;ble memory</span>
<span class="cm"> * @issue_uioc		: Driver supplied routine to issue uioc_t commands</span>
<span class="cm"> *			: issue_uioc(drvr_data, kioc, ISSUE/ABORT, uioc_done)</span>
<span class="cm"> * @quiescent		: flag to indicate if ioctl can be issued to this adp</span>
<span class="cm"> * @list		: attach with the global list of adapters</span>
<span class="cm"> * @kioc_list		: block of mem for @max_kioc number of kiocs</span>
<span class="cm"> * @kioc_pool		: pool of free kiocs</span>
<span class="cm"> * @kioc_pool_lock	: protection for free pool</span>
<span class="cm"> * @kioc_semaphore	: so as not to exceed @max_kioc parallel ioctls</span>
<span class="cm"> * @mbox_list		: block of mem for @max_kioc number of mboxes</span>
<span class="cm"> * @pthru_dma_pool	: DMA pool to allocate passthru packets</span>
<span class="cm"> * @dma_pool_list	: array of dma pools</span>
<span class="cm"> */</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">mraid_mmadp</span> <span class="p">{</span>

<span class="cm">/* Filled by driver */</span>

	<span class="kt">uint32_t</span>		<span class="n">unique_id</span><span class="p">;</span>
	<span class="kt">uint32_t</span>		<span class="n">drvr_type</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">drvr_data</span><span class="p">;</span>
	<span class="kt">uint16_t</span>		<span class="n">timeout</span><span class="p">;</span>
	<span class="kt">uint8_t</span>			<span class="n">max_kioc</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">pci_dev</span>		<span class="o">*</span><span class="n">pdev</span><span class="p">;</span>

	<span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">issue_uioc</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">uioc_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">uint32_t</span><span class="p">);</span>

<span class="cm">/* Maintained by common module */</span>
	<span class="kt">uint32_t</span>		<span class="n">quiescent</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">list</span><span class="p">;</span>
	<span class="n">uioc_t</span>			<span class="o">*</span><span class="n">kioc_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">kioc_pool</span><span class="p">;</span>
	<span class="n">spinlock_t</span>		<span class="n">kioc_pool_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">semaphore</span>	<span class="n">kioc_semaphore</span><span class="p">;</span>

	<span class="n">mbox64_t</span>		<span class="o">*</span><span class="n">mbox_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dma_pool</span>		<span class="o">*</span><span class="n">pthru_dma_pool</span><span class="p">;</span>
	<span class="n">mm_dmapool_t</span>		<span class="n">dma_pool_list</span><span class="p">[</span><span class="n">MAX_DMA_POOLS</span><span class="p">];</span>

<span class="p">}</span> <span class="n">mraid_mmadp_t</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">mraid_mm_register_adp</span><span class="p">(</span><span class="n">mraid_mmadp_t</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">mraid_mm_unregister_adp</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span>
<span class="kt">uint32_t</span> <span class="n">mraid_mm_adapter_app_handle</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* _MEGARAID_IOCTL_H_ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
