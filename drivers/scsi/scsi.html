<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › scsi › scsi.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>scsi.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  scsi.c Copyright (C) 1992 Drew Eckhardt</span>
<span class="cm"> *         Copyright (C) 1993, 1994, 1995, 1999 Eric Youngdale</span>
<span class="cm"> *         Copyright (C) 2002, 2003 Christoph Hellwig</span>
<span class="cm"> *</span>
<span class="cm"> *  generic mid-level SCSI driver</span>
<span class="cm"> *      Initial versions: Drew Eckhardt</span>
<span class="cm"> *      Subsequent revisions: Eric Youngdale</span>
<span class="cm"> *</span>
<span class="cm"> *  &lt;drew@colorado.edu&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *  Bug correction thanks go to :</span>
<span class="cm"> *      Rik Faith &lt;faith@cs.unc.edu&gt;</span>
<span class="cm"> *      Tommy Thorn &lt;tthorn&gt;</span>
<span class="cm"> *      Thomas Wuensche &lt;tw@fgb1.fgb.mw.tu-muenchen.de&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *  Modified by Eric Youngdale eric@andante.org or ericy@gnu.ai.mit.edu to</span>
<span class="cm"> *  add scatter-gather, multiple outstanding request, and other</span>
<span class="cm"> *  enhancements.</span>
<span class="cm"> *</span>
<span class="cm"> *  Native multichannel, wide scsi, /proc/scsi and hot plugging</span>
<span class="cm"> *  support added by Michael Neuffer &lt;mike@i-connect.net&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *  Added request_module(&quot;scsi_hostadapter&quot;) for kerneld:</span>
<span class="cm"> *  (Put an &quot;alias scsi_hostadapter your_hostadapter&quot; in /etc/modprobe.conf)</span>
<span class="cm"> *  Bjorn Ekwall  &lt;bj0rn@blox.se&gt;</span>
<span class="cm"> *  (changed to kmod)</span>
<span class="cm"> *</span>
<span class="cm"> *  Major improvements to the timeout, abort, and reset processing,</span>
<span class="cm"> *  as well as performance modifications for large queue depths by</span>
<span class="cm"> *  Leonard N. Zubkoff &lt;lnz@dandelion.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *  Converted cli() code to spinlocks, Ingo Molnar</span>
<span class="cm"> *</span>
<span class="cm"> *  Jiffies wrap fixes (host-&gt;resetting), 3 Dec 1998 Andrea Arcangeli</span>
<span class="cm"> *</span>
<span class="cm"> *  out_of_space hacks, D. Gilbert (dpg) 990608</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/moduleparam.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/completion.h&gt;</span>
<span class="cp">#include &lt;linux/unistd.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/kmod.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/notifier.h&gt;</span>
<span class="cp">#include &lt;linux/cpu.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>

<span class="cp">#include &lt;scsi/scsi.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_cmnd.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_dbg.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_device.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_driver.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_eh.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_host.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_tcq.h&gt;</span>

<span class="cp">#include &quot;scsi_priv.h&quot;</span>
<span class="cp">#include &quot;scsi_logging.h&quot;</span>

<span class="cp">#define CREATE_TRACE_POINTS</span>
<span class="cp">#include &lt;trace/events/scsi.h&gt;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">scsi_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Definitions and constants.</span>
<span class="cm"> */</span>

<span class="cp">#define MIN_RESET_DELAY (2*HZ)</span>

<span class="cm">/* Do not call reset on error if we just did a reset within 15 sec. */</span>
<span class="cp">#define MIN_RESET_PERIOD (15*HZ)</span>

<span class="cm">/*</span>
<span class="cm"> * Note - the initial logging level can be set here to log events at boot time.</span>
<span class="cm"> * After the system is up, you may enable logging via the /proc interface.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">scsi_logging_level</span><span class="p">;</span>
<span class="cp">#if defined(CONFIG_SCSI_LOGGING)</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">scsi_logging_level</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/* sd, scsi core and power management need to coordinate flushing async actions */</span>
<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">scsi_sd_probe_domain</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">scsi_sd_probe_domain</span><span class="p">);</span>

<span class="cm">/* NB: These are exposed through /proc/scsi/scsi and form part of the ABI.</span>
<span class="cm"> * You may not alter any existing entry (although adding new ones is</span>
<span class="cm"> * encouraged once assigned by ANSI/INCITS T10</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="n">scsi_device_types</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="s">&quot;Direct-Access    &quot;</span><span class="p">,</span>
	<span class="s">&quot;Sequential-Access&quot;</span><span class="p">,</span>
	<span class="s">&quot;Printer          &quot;</span><span class="p">,</span>
	<span class="s">&quot;Processor        &quot;</span><span class="p">,</span>
	<span class="s">&quot;WORM             &quot;</span><span class="p">,</span>
	<span class="s">&quot;CD-ROM           &quot;</span><span class="p">,</span>
	<span class="s">&quot;Scanner          &quot;</span><span class="p">,</span>
	<span class="s">&quot;Optical Device   &quot;</span><span class="p">,</span>
	<span class="s">&quot;Medium Changer   &quot;</span><span class="p">,</span>
	<span class="s">&quot;Communications   &quot;</span><span class="p">,</span>
	<span class="s">&quot;ASC IT8          &quot;</span><span class="p">,</span>
	<span class="s">&quot;ASC IT8          &quot;</span><span class="p">,</span>
	<span class="s">&quot;RAID             &quot;</span><span class="p">,</span>
	<span class="s">&quot;Enclosure        &quot;</span><span class="p">,</span>
	<span class="s">&quot;Direct-Access-RBC&quot;</span><span class="p">,</span>
	<span class="s">&quot;Optical card     &quot;</span><span class="p">,</span>
	<span class="s">&quot;Bridge controller&quot;</span><span class="p">,</span>
	<span class="s">&quot;Object storage   &quot;</span><span class="p">,</span>
	<span class="s">&quot;Automation/Drive &quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * scsi_device_type - Return 17 char string indicating device type.</span>
<span class="cm"> * @type: type number to look up</span>
<span class="cm"> */</span>

<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="nf">scsi_device_type</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="mh">0x1e</span><span class="p">)</span>
		<span class="k">return</span> <span class="s">&quot;Well-known LUN   &quot;</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="mh">0x1f</span><span class="p">)</span>
		<span class="k">return</span> <span class="s">&quot;No Device        &quot;</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&gt;=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">scsi_device_types</span><span class="p">))</span>
		<span class="k">return</span> <span class="s">&quot;Unknown          &quot;</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">scsi_device_types</span><span class="p">[</span><span class="n">type</span><span class="p">];</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">scsi_device_type</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">scsi_host_cmd_pool</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">kmem_cache</span>	<span class="o">*</span><span class="n">cmd_slab</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kmem_cache</span>	<span class="o">*</span><span class="n">sense_slab</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">users</span><span class="p">;</span>
	<span class="kt">char</span>			<span class="o">*</span><span class="n">cmd_name</span><span class="p">;</span>
	<span class="kt">char</span>			<span class="o">*</span><span class="n">sense_name</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">slab_flags</span><span class="p">;</span>
	<span class="n">gfp_t</span>			<span class="n">gfp_mask</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">scsi_host_cmd_pool</span> <span class="n">scsi_cmd_pool</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">cmd_name</span>	<span class="o">=</span> <span class="s">&quot;scsi_cmd_cache&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sense_name</span>	<span class="o">=</span> <span class="s">&quot;scsi_sense_cache&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">slab_flags</span>	<span class="o">=</span> <span class="n">SLAB_HWCACHE_ALIGN</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">scsi_host_cmd_pool</span> <span class="n">scsi_cmd_dma_pool</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">cmd_name</span>	<span class="o">=</span> <span class="s">&quot;scsi_cmd_cache(DMA)&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sense_name</span>	<span class="o">=</span> <span class="s">&quot;scsi_sense_cache(DMA)&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">slab_flags</span>	<span class="o">=</span> <span class="n">SLAB_HWCACHE_ALIGN</span><span class="o">|</span><span class="n">SLAB_CACHE_DMA</span><span class="p">,</span>
	<span class="p">.</span><span class="n">gfp_mask</span>	<span class="o">=</span> <span class="n">__GFP_DMA</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">host_cmd_pool_mutex</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * scsi_pool_alloc_command - internal function to get a fully allocated command</span>
<span class="cm"> * @pool:	slab pool to allocate the command from</span>
<span class="cm"> * @gfp_mask:	mask for the allocation</span>
<span class="cm"> *</span>
<span class="cm"> * Returns a fully allocated command (with the allied sense buffer) or</span>
<span class="cm"> * NULL on failure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span>
<span class="nf">scsi_pool_alloc_command</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_host_cmd_pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>

	<span class="n">cmd</span> <span class="o">=</span> <span class="n">kmem_cache_zalloc</span><span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">cmd_slab</span><span class="p">,</span> <span class="n">gfp_mask</span> <span class="o">|</span> <span class="n">pool</span><span class="o">-&gt;</span><span class="n">gfp_mask</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cmd</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sense_buffer</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">sense_slab</span><span class="p">,</span>
					     <span class="n">gfp_mask</span> <span class="o">|</span> <span class="n">pool</span><span class="o">-&gt;</span><span class="n">gfp_mask</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">cmd_slab</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">cmd</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * scsi_pool_free_command - internal function to release a command</span>
<span class="cm"> * @pool:	slab pool to allocate the command from</span>
<span class="cm"> * @cmd:	command to release</span>
<span class="cm"> *</span>
<span class="cm"> * the command must previously have been allocated by</span>
<span class="cm"> * scsi_pool_alloc_command.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">scsi_pool_free_command</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_host_cmd_pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">prot_sdb</span><span class="p">)</span>
		<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">scsi_sdb_cache</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">prot_sdb</span><span class="p">);</span>

	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">sense_slab</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">);</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">cmd_slab</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * scsi_host_alloc_command - internal function to allocate command</span>
<span class="cm"> * @shost:	SCSI host whose pool to allocate from</span>
<span class="cm"> * @gfp_mask:	mask for the allocation</span>
<span class="cm"> *</span>
<span class="cm"> * Returns a fully allocated command with sense buffer and protection</span>
<span class="cm"> * data buffer (where applicable) or NULL on failure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span>
<span class="nf">scsi_host_alloc_command</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>

	<span class="n">cmd</span> <span class="o">=</span> <span class="n">scsi_pool_alloc_command</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">cmd_pool</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cmd</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">scsi_host_get_prot</span><span class="p">(</span><span class="n">shost</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">SHOST_DIX_TYPE0_PROTECTION</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">prot_sdb</span> <span class="o">=</span> <span class="n">kmem_cache_zalloc</span><span class="p">(</span><span class="n">scsi_sdb_cache</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">prot_sdb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">scsi_pool_free_command</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">cmd_pool</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">cmd</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __scsi_get_command - Allocate a struct scsi_cmnd</span>
<span class="cm"> * @shost: host to transmit command</span>
<span class="cm"> * @gfp_mask: allocation mask</span>
<span class="cm"> *</span>
<span class="cm"> * Description: allocate a struct scsi_cmd from host&#39;s slab, recycling from the</span>
<span class="cm"> *              host&#39;s free_list if necessary.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="nf">__scsi_get_command</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">scsi_host_alloc_command</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">cmd</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">free_list_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">free_list</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">cmd</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">free_list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">scsi_cmnd</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
			<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">free_list_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="o">*</span><span class="n">prot</span><span class="p">;</span>

			<span class="n">buf</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">;</span>
			<span class="n">prot</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">prot_sdb</span><span class="p">;</span>

			<span class="n">memset</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">cmd</span><span class="p">));</span>

			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sense_buffer</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">prot_sdb</span> <span class="o">=</span> <span class="n">prot</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">cmd</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">__scsi_get_command</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * scsi_get_command - Allocate and setup a scsi command block</span>
<span class="cm"> * @dev: parent scsi device</span>
<span class="cm"> * @gfp_mask: allocator flags</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:	The allocated scsi command structure.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="nf">scsi_get_command</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>

	<span class="cm">/* Bail if we can&#39;t get a reference to the device */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">get_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">sdev_gendev</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">cmd</span> <span class="o">=</span> <span class="n">__scsi_get_command</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">cmd</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">cmd_list</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">jiffies_at_alloc</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">put_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">sdev_gendev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">cmd</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">scsi_get_command</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * __scsi_put_command - Free a struct scsi_cmnd</span>
<span class="cm"> * @shost: dev-&gt;host</span>
<span class="cm"> * @cmd: Command to free</span>
<span class="cm"> * @dev: parent scsi device</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">__scsi_put_command</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* changing locks here, don&#39;t need to restore the irq state */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">free_list_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">free_list</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">free_list</span><span class="p">);</span>
		<span class="n">cmd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">free_list_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">cmd</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="n">scsi_pool_free_command</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">cmd_pool</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>

	<span class="n">put_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__scsi_put_command</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * scsi_put_command - Free a scsi command block</span>
<span class="cm"> * @cmd: command block to free</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:	Nothing.</span>
<span class="cm"> *</span>
<span class="cm"> * Notes:	The command must not belong to any lists.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">scsi_put_command</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* serious error if the command hasn&#39;t come from a device list */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">));</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">__scsi_put_command</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">sdev_gendev</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">scsi_put_command</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">scsi_host_cmd_pool</span> <span class="o">*</span><span class="nf">scsi_get_host_cmd_pool</span><span class="p">(</span><span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_host_cmd_pool</span> <span class="o">*</span><span class="n">retval</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">pool</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Select a command slab for this host and create it if not</span>
<span class="cm">	 * yet existent.</span>
<span class="cm">	 */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">host_cmd_pool_mutex</span><span class="p">);</span>
	<span class="n">pool</span> <span class="o">=</span> <span class="p">(</span><span class="n">gfp_mask</span> <span class="o">&amp;</span> <span class="n">__GFP_DMA</span><span class="p">)</span> <span class="o">?</span> <span class="o">&amp;</span><span class="n">scsi_cmd_dma_pool</span> <span class="o">:</span>
		<span class="o">&amp;</span><span class="n">scsi_cmd_pool</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">users</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pool</span><span class="o">-&gt;</span><span class="n">cmd_slab</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">cmd_name</span><span class="p">,</span>
						   <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
						   <span class="n">pool</span><span class="o">-&gt;</span><span class="n">slab_flags</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">cmd_slab</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

		<span class="n">pool</span><span class="o">-&gt;</span><span class="n">sense_slab</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">sense_name</span><span class="p">,</span>
						     <span class="n">SCSI_SENSE_BUFFERSIZE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
						     <span class="n">pool</span><span class="o">-&gt;</span><span class="n">slab_flags</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">sense_slab</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">cmd_slab</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">pool</span><span class="o">-&gt;</span><span class="n">users</span><span class="o">++</span><span class="p">;</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">pool</span><span class="p">;</span>
 <span class="nl">fail:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">host_cmd_pool_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">scsi_put_host_cmd_pool</span><span class="p">(</span><span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_host_cmd_pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">host_cmd_pool_mutex</span><span class="p">);</span>
	<span class="n">pool</span> <span class="o">=</span> <span class="p">(</span><span class="n">gfp_mask</span> <span class="o">&amp;</span> <span class="n">__GFP_DMA</span><span class="p">)</span> <span class="o">?</span> <span class="o">&amp;</span><span class="n">scsi_cmd_dma_pool</span> <span class="o">:</span>
		<span class="o">&amp;</span><span class="n">scsi_cmd_pool</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * This may happen if a driver has a mismatched get and put</span>
<span class="cm">	 * of the command pool; the driver should be implicated in</span>
<span class="cm">	 * the stack trace</span>
<span class="cm">	 */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">users</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!--</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">users</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">cmd_slab</span><span class="p">);</span>
		<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">sense_slab</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">host_cmd_pool_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * scsi_allocate_command - get a fully allocated SCSI command</span>
<span class="cm"> * @gfp_mask:	allocation mask</span>
<span class="cm"> *</span>
<span class="cm"> * This function is for use outside of the normal host based pools.</span>
<span class="cm"> * It allocates the relevant command and takes an additional reference</span>
<span class="cm"> * on the pool it used.  This function *must* be paired with</span>
<span class="cm"> * scsi_free_command which also has the identical mask, otherwise the</span>
<span class="cm"> * free pool counts will eventually go wrong and you&#39;ll trigger a bug.</span>
<span class="cm"> *</span>
<span class="cm"> * This function should *only* be used by drivers that need a static</span>
<span class="cm"> * command allocation at start of day for internal functions.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="nf">scsi_allocate_command</span><span class="p">(</span><span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_host_cmd_pool</span> <span class="o">*</span><span class="n">pool</span> <span class="o">=</span> <span class="n">scsi_get_host_cmd_pool</span><span class="p">(</span><span class="n">gfp_mask</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pool</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">scsi_pool_alloc_command</span><span class="p">(</span><span class="n">pool</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">scsi_allocate_command</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * scsi_free_command - free a command allocated by scsi_allocate_command</span>
<span class="cm"> * @gfp_mask:	mask used in the original allocation</span>
<span class="cm"> * @cmd:	command to free</span>
<span class="cm"> *</span>
<span class="cm"> * Note: using the original allocation mask is vital because that&#39;s</span>
<span class="cm"> * what determines which command pool we use to free the command.  Any</span>
<span class="cm"> * mismatch will cause the system to BUG eventually.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">scsi_free_command</span><span class="p">(</span><span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_host_cmd_pool</span> <span class="o">*</span><span class="n">pool</span> <span class="o">=</span> <span class="n">scsi_get_host_cmd_pool</span><span class="p">(</span><span class="n">gfp_mask</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * this could trigger if the mask to scsi_allocate_command</span>
<span class="cm">	 * doesn&#39;t match this mask.  Otherwise we&#39;re guaranteed that this</span>
<span class="cm">	 * succeeds because scsi_allocate_command must have taken a reference</span>
<span class="cm">	 * on the pool</span>
<span class="cm">	 */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">pool</span><span class="p">);</span>

	<span class="n">scsi_pool_free_command</span><span class="p">(</span><span class="n">pool</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * scsi_put_host_cmd_pool is called twice; once to release the</span>
<span class="cm">	 * reference we took above, and once to release the reference</span>
<span class="cm">	 * originally taken by scsi_allocate_command</span>
<span class="cm">	 */</span>
	<span class="n">scsi_put_host_cmd_pool</span><span class="p">(</span><span class="n">gfp_mask</span><span class="p">);</span>
	<span class="n">scsi_put_host_cmd_pool</span><span class="p">(</span><span class="n">gfp_mask</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">scsi_free_command</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * scsi_setup_command_freelist - Setup the command freelist for a scsi host.</span>
<span class="cm"> * @shost: host to allocate the freelist for.</span>
<span class="cm"> *</span>
<span class="cm"> * Description: The command freelist protects against system-wide out of memory</span>
<span class="cm"> * deadlock by preallocating one SCSI command structure for each host, so the</span>
<span class="cm"> * system can always write to a swap file on a device associated with that host.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:	Nothing.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">scsi_setup_command_freelist</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span> <span class="o">=</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">unchecked_isa_dma</span> <span class="o">?</span> <span class="n">GFP_DMA</span> <span class="o">:</span> <span class="n">GFP_KERNEL</span><span class="p">;</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">free_list_lock</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">free_list</span><span class="p">);</span>

	<span class="n">shost</span><span class="o">-&gt;</span><span class="n">cmd_pool</span> <span class="o">=</span> <span class="n">scsi_get_host_cmd_pool</span><span class="p">(</span><span class="n">gfp_mask</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">cmd_pool</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Get one backup command for this host.</span>
<span class="cm">	 */</span>
	<span class="n">cmd</span> <span class="o">=</span> <span class="n">scsi_host_alloc_command</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">scsi_put_host_cmd_pool</span><span class="p">(</span><span class="n">gfp_mask</span><span class="p">);</span>
		<span class="n">shost</span><span class="o">-&gt;</span><span class="n">cmd_pool</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">free_list</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * scsi_destroy_command_freelist - Release the command freelist for a scsi host.</span>
<span class="cm"> * @shost: host whose freelist is going to be destroyed</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">scsi_destroy_command_freelist</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * If cmd_pool is NULL the free list was not initialized, so</span>
<span class="cm">	 * do not attempt to release resources.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">cmd_pool</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">free_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>

		<span class="n">cmd</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">free_list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">scsi_pool_free_command</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">cmd_pool</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">shost</span><span class="o">-&gt;</span><span class="n">cmd_pool</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">scsi_put_host_cmd_pool</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">unchecked_isa_dma</span> <span class="o">?</span> <span class="n">GFP_DMA</span> <span class="o">:</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_SCSI_LOGGING</span>
<span class="kt">void</span> <span class="nf">scsi_log_send</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">level</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If ML QUEUE log level is greater than or equal to:</span>
<span class="cm">	 *</span>
<span class="cm">	 * 1: nothing (match completion)</span>
<span class="cm">	 *</span>
<span class="cm">	 * 2: log opcode + command of all commands</span>
<span class="cm">	 *</span>
<span class="cm">	 * 3: same as 2 plus dump cmd address</span>
<span class="cm">	 *</span>
<span class="cm">	 * 4: same as 3 plus dump extra junk</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">scsi_logging_level</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">level</span> <span class="o">=</span> <span class="n">SCSI_LOG_LEVEL</span><span class="p">(</span><span class="n">SCSI_LOG_MLQUEUE_SHIFT</span><span class="p">,</span>
				       <span class="n">SCSI_LOG_MLQUEUE_BITS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">scmd_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="s">&quot;Send: &quot;</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;0x%p &quot;</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">scsi_print_command</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;buffer = 0x%p, bufflen = %d,&quot;</span>
				       <span class="s">&quot; queuecommand 0x%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">scsi_sglist</span><span class="p">(</span><span class="n">cmd</span><span class="p">),</span> <span class="n">scsi_bufflen</span><span class="p">(</span><span class="n">cmd</span><span class="p">),</span>
					<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">hostt</span><span class="o">-&gt;</span><span class="n">queuecommand</span><span class="p">);</span>

			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">scsi_log_completion</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">disposition</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">level</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If ML COMPLETE log level is greater than or equal to:</span>
<span class="cm">	 *</span>
<span class="cm">	 * 1: log disposition, result, opcode + command, and conditionally</span>
<span class="cm">	 * sense data for failures or non SUCCESS dispositions.</span>
<span class="cm">	 *</span>
<span class="cm">	 * 2: same as 1 but for all command completions.</span>
<span class="cm">	 *</span>
<span class="cm">	 * 3: same as 2 plus dump cmd address</span>
<span class="cm">	 *</span>
<span class="cm">	 * 4: same as 3 plus dump extra junk</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">scsi_logging_level</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">level</span> <span class="o">=</span> <span class="n">SCSI_LOG_LEVEL</span><span class="p">(</span><span class="n">SCSI_LOG_MLCOMPLETE_SHIFT</span><span class="p">,</span>
				       <span class="n">SCSI_LOG_MLCOMPLETE_BITS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(((</span><span class="n">level</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">||</span> <span class="n">disposition</span> <span class="o">!=</span> <span class="n">SUCCESS</span><span class="p">))</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">level</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">scmd_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="s">&quot;Done: &quot;</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;0x%p &quot;</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * Dump truncated values, so we usually fit within</span>
<span class="cm">			 * 80 chars.</span>
<span class="cm">			 */</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">disposition</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">SUCCESS</span>:
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;SUCCESS</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">NEEDS_RETRY</span>:
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;RETRY</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">ADD_TO_MLQUEUE</span>:
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;MLQUEUE</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">FAILED</span>:
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;FAILED</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">TIMEOUT_ERROR</span>:
				<span class="cm">/* </span>
<span class="cm">				 * If called via scsi_times_out.</span>
<span class="cm">				 */</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;TIMEOUT</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="nl">default:</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;UNKNOWN</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">scsi_print_result</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
			<span class="n">scsi_print_command</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status_byte</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">CHECK_CONDITION</span><span class="p">)</span>
				<span class="n">scsi_print_sense</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span>
				<span class="n">scmd_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span>
					    <span class="s">&quot;scsi host busy %d failed %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					    <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_busy</span><span class="p">,</span>
					    <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_failed</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * scsi_cmd_get_serial - Assign a serial number to a command</span>
<span class="cm"> * @host: the scsi host</span>
<span class="cm"> * @cmd: command to assign serial number to</span>
<span class="cm"> *</span>
<span class="cm"> * Description: a serial number identifies a request for error recovery</span>
<span class="cm"> * and debugging purposes.  Protected by the Host_Lock of host.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">scsi_cmd_get_serial</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">host</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">serial_number</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">cmd_serial_number</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">serial_number</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> 
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">serial_number</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">cmd_serial_number</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">scsi_cmd_get_serial</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * scsi_dispatch_command - Dispatch a command to the low-level driver.</span>
<span class="cm"> * @cmd: command block we are dispatching.</span>
<span class="cm"> *</span>
<span class="cm"> * Return: nonzero return request was rejected and device&#39;s queue needs to be</span>
<span class="cm"> * plugged.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">scsi_dispatch_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">host</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rtn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">iorequest_cnt</span><span class="p">);</span>

	<span class="cm">/* check if the device is still usable */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">sdev_state</span> <span class="o">==</span> <span class="n">SDEV_DEL</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* in SDEV_DEL we error all commands. DID_NO_CONNECT</span>
<span class="cm">		 * returns an immediate error upwards, and signals</span>
<span class="cm">		 * that the device is no longer present */</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_NO_CONNECT</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="n">scsi_done</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
		<span class="cm">/* return 0 (because the command has been processed) */</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Check to see if the scsi lld made this device blocked. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">scsi_device_blocked</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">)))</span> <span class="p">{</span>
		<span class="cm">/* </span>
<span class="cm">		 * in blocked state, the command is just put back on</span>
<span class="cm">		 * the device queue.  The suspend state has already</span>
<span class="cm">		 * blocked the queue so future requests should not</span>
<span class="cm">		 * occur until the device transitions out of the</span>
<span class="cm">		 * suspend state.</span>
<span class="cm">		 */</span>

		<span class="n">scsi_queue_insert</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">SCSI_MLQUEUE_DEVICE_BUSY</span><span class="p">);</span>

		<span class="n">SCSI_LOG_MLQUEUE</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">printk</span><span class="p">(</span><span class="s">&quot;queuecommand : device blocked </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>

		<span class="cm">/*</span>
<span class="cm">		 * NOTE: rtn is still zero here because we don&#39;t need the</span>
<span class="cm">		 * queue to be plugged on return (it&#39;s already stopped)</span>
<span class="cm">		 */</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* </span>
<span class="cm">	 * If SCSI-2 or lower, store the LUN value in cmnd.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">scsi_level</span> <span class="o">&lt;=</span> <span class="n">SCSI_2</span> <span class="o">&amp;&amp;</span>
	    <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">scsi_level</span> <span class="o">!=</span> <span class="n">SCSI_UNKNOWN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">)</span> <span class="o">|</span>
			       <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span> <span class="o">&amp;</span> <span class="mh">0xe0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We will wait MIN_RESET_DELAY clock ticks after the last reset so</span>
<span class="cm">	 * we can avoid the drive not being ready.</span>
<span class="cm">	 */</span>
	<span class="n">timeout</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">last_reset</span> <span class="o">+</span> <span class="n">MIN_RESET_DELAY</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">resetting</span> <span class="o">&amp;&amp;</span> <span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">timeout</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">ticks_remaining</span> <span class="o">=</span> <span class="n">timeout</span> <span class="o">-</span> <span class="n">jiffies</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * NOTE: This may be executed from within an interrupt</span>
<span class="cm">		 * handler!  This is bad, but for now, it&#39;ll do.  The irq</span>
<span class="cm">		 * level of the interrupt handler has been masked out by the</span>
<span class="cm">		 * platform dependent interrupt handling code already, so the</span>
<span class="cm">		 * sti() here will not cause another call to the SCSI host&#39;s</span>
<span class="cm">		 * interrupt handler (assuming there is one irq-level per</span>
<span class="cm">		 * host).</span>
<span class="cm">		 */</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">ticks_remaining</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">mdelay</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">999</span> <span class="o">/</span> <span class="n">HZ</span><span class="p">);</span>
		<span class="n">host</span><span class="o">-&gt;</span><span class="n">resetting</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">scsi_log_send</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Before we queue this command, check if the command</span>
<span class="cm">	 * length exceeds what the host adapter can handle.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmd_len</span> <span class="o">&gt;</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">max_cmd_len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">SCSI_LOG_MLQUEUE</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;queuecommand : command too long. &quot;</span>
			       <span class="s">&quot;cdb_size=%d host-&gt;max_cmd_len=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmd_len</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">max_cmd_len</span><span class="p">));</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DID_ABORT</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>

		<span class="n">scsi_done</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">shost_state</span> <span class="o">==</span> <span class="n">SHOST_DEL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DID_NO_CONNECT</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
		<span class="n">scsi_done</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">trace_scsi_dispatch_cmd_start</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_done</span> <span class="o">=</span> <span class="n">scsi_done</span><span class="p">;</span>
		<span class="n">rtn</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">hostt</span><span class="o">-&gt;</span><span class="n">queuecommand</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rtn</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">trace_scsi_dispatch_cmd_error</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">rtn</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rtn</span> <span class="o">!=</span> <span class="n">SCSI_MLQUEUE_DEVICE_BUSY</span> <span class="o">&amp;&amp;</span>
		    <span class="n">rtn</span> <span class="o">!=</span> <span class="n">SCSI_MLQUEUE_TARGET_BUSY</span><span class="p">)</span>
			<span class="n">rtn</span> <span class="o">=</span> <span class="n">SCSI_MLQUEUE_HOST_BUSY</span><span class="p">;</span>

		<span class="n">scsi_queue_insert</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">rtn</span><span class="p">);</span>

		<span class="n">SCSI_LOG_MLQUEUE</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span>
		    <span class="n">printk</span><span class="p">(</span><span class="s">&quot;queuecommand : request rejected</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
	<span class="p">}</span>

 <span class="nl">out:</span>
	<span class="n">SCSI_LOG_MLQUEUE</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">printk</span><span class="p">(</span><span class="s">&quot;leaving scsi_dispatch_cmnd()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">rtn</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * scsi_done - Enqueue the finished SCSI command into the done queue.</span>
<span class="cm"> * @cmd: The SCSI Command for which a low-level device driver (LLDD) gives</span>
<span class="cm"> * ownership back to SCSI Core -- i.e. the LLDD has finished with it.</span>
<span class="cm"> *</span>
<span class="cm"> * Description: This function is the mid-level&#39;s (SCSI Core) interrupt routine,</span>
<span class="cm"> * which regains ownership of the SCSI command (de facto) from a LLDD, and</span>
<span class="cm"> * enqueues the command to the done queue for further processing.</span>
<span class="cm"> *</span>
<span class="cm"> * This is the producer of the done queue who enqueues at the tail.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is interrupt context safe.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">scsi_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">trace_scsi_dispatch_cmd_done</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="n">blk_complete_request</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">request</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * scsi_finish_command - cleanup and pass command back to upper layer</span>
<span class="cm"> * @cmd: the command</span>
<span class="cm"> *</span>
<span class="cm"> * Description: Pass command off to upper layer for finishing of I/O</span>
<span class="cm"> *              request, waking processes that are waiting on results,</span>
<span class="cm"> *              etc.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">scsi_finish_command</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="n">starget</span> <span class="o">=</span> <span class="n">scsi_target</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">good_bytes</span><span class="p">;</span>

	<span class="n">scsi_device_unbusy</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>

        <span class="cm">/*</span>
<span class="cm">         * Clear the flags which say that the device/host is no longer</span>
<span class="cm">         * capable of accepting new commands.  These are set in scsi_queue.c</span>
<span class="cm">         * for both the queue full condition on a device, and for a</span>
<span class="cm">         * host full condition on the host.</span>
<span class="cm">	 *</span>
<span class="cm">	 * XXX(hch): What about locking?</span>
<span class="cm">         */</span>
        <span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_blocked</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">starget</span><span class="o">-&gt;</span><span class="n">target_blocked</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">device_blocked</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we have valid sense information, then some kind of recovery</span>
<span class="cm">	 * must have taken place.  Make a note of this.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">SCSI_SENSE_VALID</span><span class="p">(</span><span class="n">cmd</span><span class="p">))</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">|=</span> <span class="p">(</span><span class="n">DRIVER_SENSE</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">);</span>

	<span class="n">SCSI_LOG_MLCOMPLETE</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">sdev_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">sdev</span><span class="p">,</span>
				<span class="s">&quot;Notifying upper driver of completion &quot;</span>
				<span class="s">&quot;(result %x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span><span class="p">));</span>

	<span class="n">good_bytes</span> <span class="o">=</span> <span class="n">scsi_bufflen</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">cmd_type</span> <span class="o">!=</span> <span class="n">REQ_TYPE_BLOCK_PC</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">old_good_bytes</span> <span class="o">=</span> <span class="n">good_bytes</span><span class="p">;</span>
		<span class="n">drv</span> <span class="o">=</span> <span class="n">scsi_cmd_to_driver</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">)</span>
			<span class="n">good_bytes</span> <span class="o">=</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * USB may not give sense identifying bad sector and</span>
<span class="cm">		 * simply return a residue instead, so subtract off the</span>
<span class="cm">		 * residue if drv-&gt;done() error processing indicates no</span>
<span class="cm">		 * change to the completion length.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">good_bytes</span> <span class="o">==</span> <span class="n">old_good_bytes</span><span class="p">)</span>
			<span class="n">good_bytes</span> <span class="o">-=</span> <span class="n">scsi_get_resid</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">scsi_io_completion</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">good_bytes</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">scsi_finish_command</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * scsi_adjust_queue_depth - Let low level drivers change a device&#39;s queue depth</span>
<span class="cm"> * @sdev: SCSI Device in question</span>
<span class="cm"> * @tagged: Do we use tagged queueing (non-0) or do we treat</span>
<span class="cm"> *          this device as an untagged device (0)</span>
<span class="cm"> * @tags: Number of tags allowed if tagged queueing enabled,</span>
<span class="cm"> *        or number of commands the low level driver can</span>
<span class="cm"> *        queue up in non-tagged mode (as per cmd_per_lun).</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:	Nothing</span>
<span class="cm"> *</span>
<span class="cm"> * Lock Status:	None held on entry</span>
<span class="cm"> *</span>
<span class="cm"> * Notes:	Low level drivers may call this at any time and we will do</span>
<span class="cm"> * 		the right thing depending on whether or not the device is</span>
<span class="cm"> * 		currently active and whether or not it even has the</span>
<span class="cm"> * 		command blocks built yet.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">scsi_adjust_queue_depth</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tagged</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * refuse to set tagged depth to an unworkable size</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tags</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check to see if the queue is managed by the block layer.</span>
<span class="cm">	 * If it is, and we fail to adjust the depth, exit.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Do not resize the tag map if it is a host wide share bqt,</span>
<span class="cm">	 * because the size should be the hosts&#39;s can_queue. If there</span>
<span class="cm">	 * is more IO than the LLD&#39;s can_queue (so there are not enuogh</span>
<span class="cm">	 * tags) request_fn&#39;s host queue ready check will handle it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">bqt</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">blk_queue_tagged</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">blk_queue_resize_tags</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="p">,</span> <span class="n">tags</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">queue_depth</span> <span class="o">=</span> <span class="n">tags</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">tagged</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">MSG_ORDERED_TAG</span>:
			<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">ordered_tags</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">simple_tags</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">MSG_SIMPLE_TAG</span>:
			<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">ordered_tags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">simple_tags</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">sdev_printk</span><span class="p">(</span><span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">sdev</span><span class="p">,</span>
				    <span class="s">&quot;scsi_adjust_queue_depth, bad queue type, &quot;</span>
				    <span class="s">&quot;disabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">case</span> <span class="mi">0</span>:
			<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">ordered_tags</span> <span class="o">=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">simple_tags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">queue_depth</span> <span class="o">=</span> <span class="n">tags</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
 <span class="nl">out:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">scsi_adjust_queue_depth</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * scsi_track_queue_full - track QUEUE_FULL events to adjust queue depth</span>
<span class="cm"> * @sdev: SCSI Device in question</span>
<span class="cm"> * @depth: Current number of outstanding SCSI commands on this device,</span>
<span class="cm"> *         not counting the one returned as QUEUE_FULL.</span>
<span class="cm"> *</span>
<span class="cm"> * Description:	This function will track successive QUEUE_FULL events on a</span>
<span class="cm"> * 		specific SCSI device to determine if and when there is a</span>
<span class="cm"> * 		need to adjust the queue depth on the device.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:	0 - No change needed, &gt;0 - Adjust queue depth to this new depth,</span>
<span class="cm"> * 		-1 - Drop back to untagged operation using host-&gt;cmd_per_lun</span>
<span class="cm"> * 			as the untagged command depth</span>
<span class="cm"> *</span>
<span class="cm"> * Lock Status:	None held on entry</span>
<span class="cm"> *</span>
<span class="cm"> * Notes:	Low level drivers may call this at any time and we will do</span>
<span class="cm"> * 		&quot;The Right Thing.&quot;  We are interrupt context safe.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">scsi_track_queue_full</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">depth</span><span class="p">)</span>
<span class="p">{</span>

	<span class="cm">/*</span>
<span class="cm">	 * Don&#39;t let QUEUE_FULLs on the same</span>
<span class="cm">	 * jiffies count, they could all be from</span>
<span class="cm">	 * same event.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">jiffies</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">last_queue_full_time</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">last_queue_full_time</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">last_queue_full_depth</span> <span class="o">!=</span> <span class="n">depth</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">last_queue_full_count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">last_queue_full_depth</span> <span class="o">=</span> <span class="n">depth</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">last_queue_full_count</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">last_queue_full_count</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">last_queue_full_depth</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Drop back to untagged */</span>
		<span class="n">scsi_adjust_queue_depth</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">cmd_per_lun</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">ordered_tags</span><span class="p">)</span>
		<span class="n">scsi_adjust_queue_depth</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">MSG_ORDERED_TAG</span><span class="p">,</span> <span class="n">depth</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">scsi_adjust_queue_depth</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">MSG_SIMPLE_TAG</span><span class="p">,</span> <span class="n">depth</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">depth</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">scsi_track_queue_full</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * scsi_vpd_inquiry - Request a device provide us with a VPD page</span>
<span class="cm"> * @sdev: The device to ask</span>
<span class="cm"> * @buffer: Where to put the result</span>
<span class="cm"> * @page: Which Vital Product Data to return</span>
<span class="cm"> * @len: The length of the buffer</span>
<span class="cm"> *</span>
<span class="cm"> * This is an internal helper function.  You probably want to use</span>
<span class="cm"> * scsi_get_vpd_page instead.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success or a negative error number.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">scsi_vpd_inquiry</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
							<span class="n">u8</span> <span class="n">page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">cmd</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>

	<span class="n">cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">INQUIRY</span><span class="p">;</span>
	<span class="n">cmd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>		<span class="cm">/* EVPD */</span>
	<span class="n">cmd</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
	<span class="n">cmd</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">len</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">cmd</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">len</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">cmd</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>		<span class="cm">/* Control byte */</span>

	<span class="cm">/*</span>
<span class="cm">	 * I&#39;m not convinced we need to try quite this hard to get VPD, but</span>
<span class="cm">	 * all the existing users tried this hard.</span>
<span class="cm">	 */</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">scsi_execute_req</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span>
				  <span class="n">len</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">30</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">result</span><span class="p">;</span>

	<span class="cm">/* Sanity check that we got the page back that we asked for */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buffer</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">page</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * scsi_get_vpd_page - Get Vital Product Data from a SCSI device</span>
<span class="cm"> * @sdev: The device to ask</span>
<span class="cm"> * @page: Which Vital Product Data to return</span>
<span class="cm"> * @buf: where to store the VPD</span>
<span class="cm"> * @buf_len: number of bytes in the VPD buffer area</span>
<span class="cm"> *</span>
<span class="cm"> * SCSI devices may optionally supply Vital Product Data.  Each &#39;page&#39;</span>
<span class="cm"> * of VPD is defined in the appropriate SCSI document (eg SPC, SBC).</span>
<span class="cm"> * If the device supports this VPD page, this routine returns a pointer</span>
<span class="cm"> * to a buffer containing the data from that page.  The caller is</span>
<span class="cm"> * responsible for calling kfree() on this pointer when it is no longer</span>
<span class="cm"> * needed.  If we cannot retrieve the VPD page this routine returns %NULL.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">scsi_get_vpd_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">,</span> <span class="n">u8</span> <span class="n">page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
		      <span class="kt">int</span> <span class="n">buf_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">result</span><span class="p">;</span>

	<span class="cm">/* Ask for all the pages supported by this device */</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">scsi_vpd_inquiry</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">buf_len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="cm">/* If the user actually wanted this page, we can skip the rest */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">min</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">buf</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">buf_len</span> <span class="o">-</span> <span class="mi">4</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="n">page</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">buf</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">buf_len</span> <span class="o">-</span> <span class="mi">4</span><span class="p">)</span>
		<span class="cm">/* ran off the end of the buffer, give us benefit of doubt */</span>
		<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>
	<span class="cm">/* The device claims it doesn&#39;t support the requested page */</span>
	<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

 <span class="nl">found:</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">scsi_vpd_inquiry</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">buf_len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">fail:</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">scsi_get_vpd_page</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * scsi_device_get  -  get an additional reference to a scsi_device</span>
<span class="cm"> * @sdev:	device to get a reference to</span>
<span class="cm"> *</span>
<span class="cm"> * Description: Gets a reference to the scsi_device and increments the use count</span>
<span class="cm"> * of the underlying LLDD module.  You must hold host_lock of the</span>
<span class="cm"> * parent Scsi_Host or already have a reference when calling this.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">scsi_device_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">sdev_state</span> <span class="o">==</span> <span class="n">SDEV_DEL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">get_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">sdev_gendev</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
	<span class="cm">/* We can fail this if we&#39;re doing SCSI operations</span>
<span class="cm">	 * from module exit (like cache flush) */</span>
	<span class="n">try_module_get</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">hostt</span><span class="o">-&gt;</span><span class="n">module</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">scsi_device_get</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * scsi_device_put  -  release a reference to a scsi_device</span>
<span class="cm"> * @sdev:	device to release a reference on.</span>
<span class="cm"> *</span>
<span class="cm"> * Description: Release a reference to the scsi_device and decrements the use</span>
<span class="cm"> * count of the underlying LLDD module.  The device is freed once the last</span>
<span class="cm"> * user vanishes.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">scsi_device_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_MODULE_UNLOAD</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">module</span> <span class="o">=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">hostt</span><span class="o">-&gt;</span><span class="n">module</span><span class="p">;</span>

	<span class="cm">/* The module refcount will be zero if scsi_device_get()</span>
<span class="cm">	 * was called from a module removal routine */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">module</span> <span class="o">&amp;&amp;</span> <span class="n">module_refcount</span><span class="p">(</span><span class="n">module</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">module_put</span><span class="p">(</span><span class="n">module</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">put_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">sdev_gendev</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">scsi_device_put</span><span class="p">);</span>

<span class="cm">/* helper for shost_for_each_device, see that for documentation */</span>
<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="nf">__scsi_iterate_devices</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">prev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">list</span> <span class="o">=</span> <span class="p">(</span><span class="n">prev</span> <span class="o">?</span> <span class="o">&amp;</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">siblings</span> <span class="o">:</span> <span class="o">&amp;</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">__devices</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">__devices</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_device</span><span class="p">,</span> <span class="n">siblings</span><span class="p">);</span>
		<span class="cm">/* skip devices that we can&#39;t get a reference to */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">scsi_device_get</span><span class="p">(</span><span class="n">next</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">list</span> <span class="o">=</span> <span class="n">list</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">prev</span><span class="p">)</span>
		<span class="n">scsi_device_put</span><span class="p">(</span><span class="n">prev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">next</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__scsi_iterate_devices</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * starget_for_each_device  -  helper to walk all devices of a target</span>
<span class="cm"> * @starget:	target whose devices we want to iterate over.</span>
<span class="cm"> * @data:	Opaque passed to each function call.</span>
<span class="cm"> * @fn:		Function to call on each device</span>
<span class="cm"> *</span>
<span class="cm"> * This traverses over each device of @starget.  The devices have</span>
<span class="cm"> * a reference that must be released by scsi_host_put when breaking</span>
<span class="cm"> * out of the loop.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">starget_for_each_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="n">starget</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
		     <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">dev_to_shost</span><span class="p">(</span><span class="n">starget</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">;</span>

	<span class="n">shost_for_each_device</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">shost</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">channel</span> <span class="o">==</span> <span class="n">starget</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">==</span> <span class="n">starget</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">))</span>
			<span class="n">fn</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">starget_for_each_device</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * __starget_for_each_device - helper to walk all devices of a target (UNLOCKED)</span>
<span class="cm"> * @starget:	target whose devices we want to iterate over.</span>
<span class="cm"> * @data:	parameter for callback @fn()</span>
<span class="cm"> * @fn:		callback function that is invoked for each device</span>
<span class="cm"> *</span>
<span class="cm"> * This traverses over each device of @starget.  It does _not_</span>
<span class="cm"> * take a reference on the scsi_device, so the whole loop must be</span>
<span class="cm"> * protected by shost-&gt;host_lock.</span>
<span class="cm"> *</span>
<span class="cm"> * Note:  The only reason why drivers would want to use this is because</span>
<span class="cm"> * they need to access the device list in irq context.  Otherwise you</span>
<span class="cm"> * really want to use starget_for_each_device instead.</span>
<span class="cm"> **/</span>
<span class="kt">void</span> <span class="nf">__starget_for_each_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="n">starget</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			       <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">dev_to_shost</span><span class="p">(</span><span class="n">starget</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">;</span>

	<span class="n">__shost_for_each_device</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">shost</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">channel</span> <span class="o">==</span> <span class="n">starget</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">==</span> <span class="n">starget</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">))</span>
			<span class="n">fn</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__starget_for_each_device</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * __scsi_device_lookup_by_target - find a device given the target (UNLOCKED)</span>
<span class="cm"> * @starget:	SCSI target pointer</span>
<span class="cm"> * @lun:	SCSI Logical Unit Number</span>
<span class="cm"> *</span>
<span class="cm"> * Description: Looks up the scsi_device with the specified @lun for a given</span>
<span class="cm"> * @starget.  The returned scsi_device does not have an additional</span>
<span class="cm"> * reference.  You must hold the host&#39;s host_lock over this call and</span>
<span class="cm"> * any access to the returned scsi_device. A scsi_device in state</span>
<span class="cm"> * SDEV_DEL is skipped.</span>
<span class="cm"> *</span>
<span class="cm"> * Note:  The only reason why drivers should use this is because</span>
<span class="cm"> * they need to access the device list in irq context.  Otherwise you</span>
<span class="cm"> * really want to use scsi_device_lookup_by_target instead.</span>
<span class="cm"> **/</span>
<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="nf">__scsi_device_lookup_by_target</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="n">starget</span><span class="p">,</span>
						   <span class="n">uint</span> <span class="n">lun</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">starget</span><span class="o">-&gt;</span><span class="n">devices</span><span class="p">,</span> <span class="n">same_target_siblings</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">sdev_state</span> <span class="o">==</span> <span class="n">SDEV_DEL</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">lun</span> <span class="o">==</span><span class="n">lun</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">sdev</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__scsi_device_lookup_by_target</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * scsi_device_lookup_by_target - find a device given the target</span>
<span class="cm"> * @starget:	SCSI target pointer</span>
<span class="cm"> * @lun:	SCSI Logical Unit Number</span>
<span class="cm"> *</span>
<span class="cm"> * Description: Looks up the scsi_device with the specified @lun for a given</span>
<span class="cm"> * @starget.  The returned scsi_device has an additional reference that</span>
<span class="cm"> * needs to be released with scsi_device_put once you&#39;re done with it.</span>
<span class="cm"> **/</span>
<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="nf">scsi_device_lookup_by_target</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="n">starget</span><span class="p">,</span>
						 <span class="n">uint</span> <span class="n">lun</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">dev_to_shost</span><span class="p">(</span><span class="n">starget</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">sdev</span> <span class="o">=</span> <span class="n">__scsi_device_lookup_by_target</span><span class="p">(</span><span class="n">starget</span><span class="p">,</span> <span class="n">lun</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sdev</span> <span class="o">&amp;&amp;</span> <span class="n">scsi_device_get</span><span class="p">(</span><span class="n">sdev</span><span class="p">))</span>
		<span class="n">sdev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">sdev</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">scsi_device_lookup_by_target</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * __scsi_device_lookup - find a device given the host (UNLOCKED)</span>
<span class="cm"> * @shost:	SCSI host pointer</span>
<span class="cm"> * @channel:	SCSI channel (zero if only one channel)</span>
<span class="cm"> * @id:		SCSI target number (physical unit number)</span>
<span class="cm"> * @lun:	SCSI Logical Unit Number</span>
<span class="cm"> *</span>
<span class="cm"> * Description: Looks up the scsi_device with the specified @channel, @id, @lun</span>
<span class="cm"> * for a given host. The returned scsi_device does not have an additional</span>
<span class="cm"> * reference.  You must hold the host&#39;s host_lock over this call and any access</span>
<span class="cm"> * to the returned scsi_device.</span>
<span class="cm"> *</span>
<span class="cm"> * Note:  The only reason why drivers would want to use this is because</span>
<span class="cm"> * they need to access the device list in irq context.  Otherwise you</span>
<span class="cm"> * really want to use scsi_device_lookup instead.</span>
<span class="cm"> **/</span>
<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="nf">__scsi_device_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">,</span>
		<span class="n">uint</span> <span class="n">channel</span><span class="p">,</span> <span class="n">uint</span> <span class="n">id</span><span class="p">,</span> <span class="n">uint</span> <span class="n">lun</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">__devices</span><span class="p">,</span> <span class="n">siblings</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">channel</span> <span class="o">==</span> <span class="n">channel</span> <span class="o">&amp;&amp;</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">==</span> <span class="n">id</span> <span class="o">&amp;&amp;</span>
				<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">lun</span> <span class="o">==</span><span class="n">lun</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">sdev</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__scsi_device_lookup</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * scsi_device_lookup - find a device given the host</span>
<span class="cm"> * @shost:	SCSI host pointer</span>
<span class="cm"> * @channel:	SCSI channel (zero if only one channel)</span>
<span class="cm"> * @id:		SCSI target number (physical unit number)</span>
<span class="cm"> * @lun:	SCSI Logical Unit Number</span>
<span class="cm"> *</span>
<span class="cm"> * Description: Looks up the scsi_device with the specified @channel, @id, @lun</span>
<span class="cm"> * for a given host.  The returned scsi_device has an additional reference that</span>
<span class="cm"> * needs to be released with scsi_device_put once you&#39;re done with it.</span>
<span class="cm"> **/</span>
<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="nf">scsi_device_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">,</span>
		<span class="n">uint</span> <span class="n">channel</span><span class="p">,</span> <span class="n">uint</span> <span class="n">id</span><span class="p">,</span> <span class="n">uint</span> <span class="n">lun</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">sdev</span> <span class="o">=</span> <span class="n">__scsi_device_lookup</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="n">lun</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sdev</span> <span class="o">&amp;&amp;</span> <span class="n">scsi_device_get</span><span class="p">(</span><span class="n">sdev</span><span class="p">))</span>
		<span class="n">sdev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">sdev</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">scsi_device_lookup</span><span class="p">);</span>

<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;SCSI core&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

<span class="n">module_param</span><span class="p">(</span><span class="n">scsi_logging_level</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="o">|</span><span class="n">S_IWUSR</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">scsi_logging_level</span><span class="p">,</span> <span class="s">&quot;a bit mask of logging levels&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">init_scsi</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">scsi_init_queue</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">scsi_init_procfs</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">cleanup_queue</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">scsi_init_devinfo</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">cleanup_procfs</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">scsi_init_hosts</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">cleanup_devlist</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">scsi_init_sysctl</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">cleanup_hosts</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">scsi_sysfs_register</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">cleanup_sysctl</span><span class="p">;</span>

	<span class="n">scsi_netlink_init</span><span class="p">();</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;SCSI subsystem initialized</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">cleanup_sysctl:</span>
	<span class="n">scsi_exit_sysctl</span><span class="p">();</span>
<span class="nl">cleanup_hosts:</span>
	<span class="n">scsi_exit_hosts</span><span class="p">();</span>
<span class="nl">cleanup_devlist:</span>
	<span class="n">scsi_exit_devinfo</span><span class="p">();</span>
<span class="nl">cleanup_procfs:</span>
	<span class="n">scsi_exit_procfs</span><span class="p">();</span>
<span class="nl">cleanup_queue:</span>
	<span class="n">scsi_exit_queue</span><span class="p">();</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;SCSI subsystem failed to initialize, error = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="o">-</span><span class="n">error</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">exit_scsi</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">scsi_netlink_exit</span><span class="p">();</span>
	<span class="n">scsi_sysfs_unregister</span><span class="p">();</span>
	<span class="n">scsi_exit_sysctl</span><span class="p">();</span>
	<span class="n">scsi_exit_hosts</span><span class="p">();</span>
	<span class="n">scsi_exit_devinfo</span><span class="p">();</span>
	<span class="n">scsi_exit_procfs</span><span class="p">();</span>
	<span class="n">scsi_exit_queue</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">subsys_initcall</span><span class="p">(</span><span class="n">init_scsi</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">exit_scsi</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
