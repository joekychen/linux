<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › scsi › aacraid › commsup.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>commsup.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *	Adaptec AAC series RAID controller driver</span>
<span class="cm"> *	(c) Copyright 2001 Red Hat Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * based on the old aacraid driver that is..</span>
<span class="cm"> * Adaptec aacraid device driver for Linux.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2000-2010 Adaptec, Inc.</span>
<span class="cm"> *               2010 PMC-Sierra, Inc. (aacraid@pmc-sierra.com)</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2, or (at your option)</span>
<span class="cm"> * any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; see the file COPYING.  If not, write to</span>
<span class="cm"> * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.</span>
<span class="cm"> *</span>
<span class="cm"> * Module Name:</span>
<span class="cm"> *  commsup.c</span>
<span class="cm"> *</span>
<span class="cm"> * Abstract: Contain all routines that are required for FSA host/adapter</span>
<span class="cm"> *    communication.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/completion.h&gt;</span>
<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/kthread.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/semaphore.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_host.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_device.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_cmnd.h&gt;</span>

<span class="cp">#include &quot;aacraid.h&quot;</span>

<span class="cm">/**</span>
<span class="cm"> *	fib_map_alloc		-	allocate the fib objects</span>
<span class="cm"> *	@dev: Adapter to allocate for</span>
<span class="cm"> *</span>
<span class="cm"> *	Allocate and map the shared PCI space for the FIB blocks used to</span>
<span class="cm"> *	talk to the Adaptec firmware.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fib_map_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">aac_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dprintk</span><span class="p">((</span><span class="n">KERN_INFO</span>
	  <span class="s">&quot;allocate hardware fibs pci_alloc_consistent(%p, %d * (%d + %d), %p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	  <span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">max_fib_size</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">scsi_host_ptr</span><span class="o">-&gt;</span><span class="n">can_queue</span><span class="p">,</span>
	  <span class="n">AAC_NUM_MGT_FIB</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">hw_fib_pa</span><span class="p">));</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">hw_fib_va</span> <span class="o">=</span> <span class="n">pci_alloc_consistent</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
		<span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">max_fib_size</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">aac_fib_xporthdr</span><span class="p">))</span>
		<span class="o">*</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">scsi_host_ptr</span><span class="o">-&gt;</span><span class="n">can_queue</span> <span class="o">+</span> <span class="n">AAC_NUM_MGT_FIB</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">ALIGN32</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>
		<span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">hw_fib_pa</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">hw_fib_va</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	aac_fib_map_free		-	free the fib objects</span>
<span class="cm"> *	@dev: Adapter to free</span>
<span class="cm"> *</span>
<span class="cm"> *	Free the PCI mappings and the memory allocated for FIB blocks</span>
<span class="cm"> *	on this adapter.</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">aac_fib_map_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">aac_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
	  <span class="n">dev</span><span class="o">-&gt;</span><span class="n">max_fib_size</span> <span class="o">*</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">scsi_host_ptr</span><span class="o">-&gt;</span><span class="n">can_queue</span> <span class="o">+</span> <span class="n">AAC_NUM_MGT_FIB</span><span class="p">),</span>
	  <span class="n">dev</span><span class="o">-&gt;</span><span class="n">hw_fib_va</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">hw_fib_pa</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">hw_fib_va</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">hw_fib_pa</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	aac_fib_setup	-	setup the fibs</span>
<span class="cm"> *	@dev: Adapter to set up</span>
<span class="cm"> *</span>
<span class="cm"> *	Allocate the PCI space for the fibs, map it and then initialise the</span>
<span class="cm"> *	fib area, the unmapped fib data and also the free list</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">aac_fib_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">aac_dev</span> <span class="o">*</span> <span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fib</span> <span class="o">*</span><span class="n">fibptr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hw_fib</span> <span class="o">*</span><span class="n">hw_fib</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">hw_fib_pa</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(((</span><span class="n">i</span> <span class="o">=</span> <span class="n">fib_map_alloc</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">)</span>
	 <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">scsi_host_ptr</span><span class="o">-&gt;</span><span class="n">can_queue</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">64</span> <span class="o">-</span> <span class="n">AAC_NUM_MGT_FIB</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">init</span><span class="o">-&gt;</span><span class="n">MaxIoCommands</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">((</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">scsi_host_ptr</span><span class="o">-&gt;</span><span class="n">can_queue</span> <span class="o">+</span> <span class="n">AAC_NUM_MGT_FIB</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">scsi_host_ptr</span><span class="o">-&gt;</span><span class="n">can_queue</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">init</span><span class="o">-&gt;</span><span class="n">MaxIoCommands</span><span class="p">)</span> <span class="o">-</span> <span class="n">AAC_NUM_MGT_FIB</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* 32 byte alignment for PMC */</span>
	<span class="n">hw_fib_pa</span> <span class="o">=</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">hw_fib_pa</span> <span class="o">+</span> <span class="p">(</span><span class="n">ALIGN32</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">ALIGN32</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">hw_fib_va</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">hw_fib</span> <span class="o">*</span><span class="p">)((</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">hw_fib_va</span> <span class="o">+</span>
		<span class="p">(</span><span class="n">hw_fib_pa</span> <span class="o">-</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">hw_fib_pa</span><span class="p">));</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">hw_fib_pa</span> <span class="o">=</span> <span class="n">hw_fib_pa</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">hw_fib_va</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
		<span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">max_fib_size</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">aac_fib_xporthdr</span><span class="p">))</span> <span class="o">*</span>
		<span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">scsi_host_ptr</span><span class="o">-&gt;</span><span class="n">can_queue</span> <span class="o">+</span> <span class="n">AAC_NUM_MGT_FIB</span><span class="p">));</span>

	<span class="cm">/* add Xport header */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">hw_fib_va</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">hw_fib</span> <span class="o">*</span><span class="p">)((</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">hw_fib_va</span> <span class="o">+</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">aac_fib_xporthdr</span><span class="p">));</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">hw_fib_pa</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">aac_fib_xporthdr</span><span class="p">);</span>

	<span class="n">hw_fib</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">hw_fib_va</span><span class="p">;</span>
	<span class="n">hw_fib_pa</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">hw_fib_pa</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 *	Initialise the fibs</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">fibptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">fibs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">scsi_host_ptr</span><span class="o">-&gt;</span><span class="n">can_queue</span> <span class="o">+</span> <span class="n">AAC_NUM_MGT_FIB</span><span class="p">);</span>
		<span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">fibptr</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">fibptr</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
		<span class="n">fibptr</span><span class="o">-&gt;</span><span class="n">hw_fib_va</span> <span class="o">=</span> <span class="n">hw_fib</span><span class="p">;</span>
		<span class="n">fibptr</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">fibptr</span><span class="o">-&gt;</span><span class="n">hw_fib_va</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
		<span class="n">fibptr</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">fibptr</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Forward chain the fibs */</span>
		<span class="n">sema_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fibptr</span><span class="o">-&gt;</span><span class="n">event_wait</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fibptr</span><span class="o">-&gt;</span><span class="n">event_lock</span><span class="p">);</span>
		<span class="n">hw_fib</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">XferState</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0xffffffff</span><span class="p">);</span>
		<span class="n">hw_fib</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">SenderSize</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">max_fib_size</span><span class="p">);</span>
		<span class="n">fibptr</span><span class="o">-&gt;</span><span class="n">hw_fib_pa</span> <span class="o">=</span> <span class="n">hw_fib_pa</span><span class="p">;</span>
		<span class="n">hw_fib</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">hw_fib</span> <span class="o">*</span><span class="p">)((</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">hw_fib</span> <span class="o">+</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">max_fib_size</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">aac_fib_xporthdr</span><span class="p">));</span>
		<span class="n">hw_fib_pa</span> <span class="o">=</span> <span class="n">hw_fib_pa</span> <span class="o">+</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">max_fib_size</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">aac_fib_xporthdr</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 *	Add the fib chain to the free list</span>
<span class="cm">	 */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">fibs</span><span class="p">[</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">scsi_host_ptr</span><span class="o">-&gt;</span><span class="n">can_queue</span> <span class="o">+</span> <span class="n">AAC_NUM_MGT_FIB</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 *	Enable this to debug out of queue space</span>
<span class="cm">	 */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">free_fib</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">fibs</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	aac_fib_alloc	-	allocate a fib</span>
<span class="cm"> *	@dev: Adapter to allocate the fib for</span>
<span class="cm"> *</span>
<span class="cm"> *	Allocate a fib from the adapter fib pool. If the pool is empty we</span>
<span class="cm"> *	return NULL.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">fib</span> <span class="o">*</span><span class="nf">aac_fib_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">aac_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fib</span> <span class="o">*</span> <span class="n">fibptr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">fib_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">fibptr</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">free_fib</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">fibptr</span><span class="p">){</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">fib_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">fibptr</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">free_fib</span> <span class="o">=</span> <span class="n">fibptr</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">fib_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 *	Set the proper node type code and node byte size</span>
<span class="cm">	 */</span>
	<span class="n">fibptr</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">FSAFS_NTC_FIB_CONTEXT</span><span class="p">;</span>
	<span class="n">fibptr</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fib</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 *	Null out fields that depend on being zero at the start of</span>
<span class="cm">	 *	each I/O</span>
<span class="cm">	 */</span>
	<span class="n">fibptr</span><span class="o">-&gt;</span><span class="n">hw_fib_va</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">XferState</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">fibptr</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">fibptr</span><span class="o">-&gt;</span><span class="n">callback</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">fibptr</span><span class="o">-&gt;</span><span class="n">callback_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">fibptr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	aac_fib_free	-	free a fib</span>
<span class="cm"> *	@fibptr: fib to free up</span>
<span class="cm"> *</span>
<span class="cm"> *	Frees up a fib and places it on the appropriate queue</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">aac_fib_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">fib</span> <span class="o">*</span><span class="n">fibptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="n">flagsv</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fibptr</span><span class="o">-&gt;</span><span class="n">event_lock</span><span class="p">,</span> <span class="n">flagsv</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fibptr</span><span class="o">-&gt;</span><span class="n">done</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fibptr</span><span class="o">-&gt;</span><span class="n">event_lock</span><span class="p">,</span> <span class="n">flagsv</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fibptr</span><span class="o">-&gt;</span><span class="n">event_lock</span><span class="p">,</span> <span class="n">flagsv</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fibptr</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">fib_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">fibptr</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FIB_CONTEXT_FLAG_TIMED_OUT</span><span class="p">))</span>
		<span class="n">aac_config</span><span class="p">.</span><span class="n">fib_timeouts</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fibptr</span><span class="o">-&gt;</span><span class="n">hw_fib_va</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">XferState</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;aac_fib_free, XferState != 0, fibptr = 0x%p, XferState = 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">fibptr</span><span class="p">,</span>
			 <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">fibptr</span><span class="o">-&gt;</span><span class="n">hw_fib_va</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">XferState</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">fibptr</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">fibptr</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">free_fib</span><span class="p">;</span>
	<span class="n">fibptr</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">free_fib</span> <span class="o">=</span> <span class="n">fibptr</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fibptr</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">fib_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	aac_fib_init	-	initialise a fib</span>
<span class="cm"> *	@fibptr: The fib to initialize</span>
<span class="cm"> *</span>
<span class="cm"> *	Set up the generic fib fields ready for use</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">aac_fib_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">fib</span> <span class="o">*</span><span class="n">fibptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hw_fib</span> <span class="o">*</span><span class="n">hw_fib</span> <span class="o">=</span> <span class="n">fibptr</span><span class="o">-&gt;</span><span class="n">hw_fib_va</span><span class="p">;</span>

	<span class="n">hw_fib</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">StructType</span> <span class="o">=</span> <span class="n">FIB_MAGIC</span><span class="p">;</span>
	<span class="n">hw_fib</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">Size</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">fibptr</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">max_fib_size</span><span class="p">);</span>
	<span class="n">hw_fib</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">XferState</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">HostOwned</span> <span class="o">|</span> <span class="n">FibInitialized</span> <span class="o">|</span> <span class="n">FibEmpty</span> <span class="o">|</span> <span class="n">FastResponseCapable</span><span class="p">);</span>
	<span class="n">hw_fib</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">SenderFibAddress</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* Filled in later if needed */</span>
	<span class="n">hw_fib</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">ReceiverFibAddress</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">fibptr</span><span class="o">-&gt;</span><span class="n">hw_fib_pa</span><span class="p">);</span>
	<span class="n">hw_fib</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">SenderSize</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">fibptr</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">max_fib_size</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	fib_deallocate		-	deallocate a fib</span>
<span class="cm"> *	@fibptr: fib to deallocate</span>
<span class="cm"> *</span>
<span class="cm"> *	Will deallocate and return to the free pool the FIB pointed to by the</span>
<span class="cm"> *	caller.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fib_dealloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">fib</span> <span class="o">*</span> <span class="n">fibptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hw_fib</span> <span class="o">*</span><span class="n">hw_fib</span> <span class="o">=</span> <span class="n">fibptr</span><span class="o">-&gt;</span><span class="n">hw_fib_va</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">hw_fib</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">StructType</span> <span class="o">!=</span> <span class="n">FIB_MAGIC</span><span class="p">);</span>
	<span class="n">hw_fib</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">XferState</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	Commuication primitives define and support the queuing method we use to</span>
<span class="cm"> *	support host to adapter commuication. All queue accesses happen through</span>
<span class="cm"> *	these routines and are the only routines which have a knowledge of the</span>
<span class="cm"> *	 how these queues are implemented.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> *	aac_get_entry		-	get a queue entry</span>
<span class="cm"> *	@dev: Adapter</span>
<span class="cm"> *	@qid: Queue Number</span>
<span class="cm"> *	@entry: Entry return</span>
<span class="cm"> *	@index: Index return</span>
<span class="cm"> *	@nonotify: notification control</span>
<span class="cm"> *</span>
<span class="cm"> *	With a priority the routine returns a queue entry if the queue has free entries. If the queue</span>
<span class="cm"> *	is full(no free entries) than no entry is returned and the function returns 0 otherwise 1 is</span>
<span class="cm"> *	returned.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">aac_get_entry</span> <span class="p">(</span><span class="k">struct</span> <span class="n">aac_dev</span> <span class="o">*</span> <span class="n">dev</span><span class="p">,</span> <span class="n">u32</span> <span class="n">qid</span><span class="p">,</span> <span class="k">struct</span> <span class="n">aac_entry</span> <span class="o">**</span><span class="n">entry</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span> <span class="n">index</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">nonotify</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">aac_queue</span> <span class="o">*</span> <span class="n">q</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">idx</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *	All of the queues wrap when they reach the end, so we check</span>
<span class="cm">	 *	to see if they have reached the end and if they have we just</span>
<span class="cm">	 *	set the index back to zero. This is a wrap. You could or off</span>
<span class="cm">	 *	the high bits in all updates but this is a bit faster I think.</span>
<span class="cm">	 */</span>

	<span class="n">q</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">queues</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">[</span><span class="n">qid</span><span class="p">];</span>

	<span class="n">idx</span> <span class="o">=</span> <span class="o">*</span><span class="n">index</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">headers</span><span class="p">.</span><span class="n">producer</span><span class="p">));</span>
	<span class="cm">/* Interrupt Moderation, only interrupt for first two entries */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">!=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">headers</span><span class="p">.</span><span class="n">consumer</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">idx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">qid</span> <span class="o">==</span> <span class="n">AdapNormCmdQueue</span><span class="p">)</span>
				<span class="n">idx</span> <span class="o">=</span> <span class="n">ADAP_NORM_CMD_ENTRIES</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">idx</span> <span class="o">=</span> <span class="n">ADAP_NORM_RESP_ENTRIES</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">!=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">headers</span><span class="p">.</span><span class="n">consumer</span><span class="p">)))</span>
			<span class="o">*</span><span class="n">nonotify</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">qid</span> <span class="o">==</span> <span class="n">AdapNormCmdQueue</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">ADAP_NORM_CMD_ENTRIES</span><span class="p">)</span>
			<span class="o">*</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* Wrap to front of the Producer Queue. */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">ADAP_NORM_RESP_ENTRIES</span><span class="p">)</span>
			<span class="o">*</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* Wrap to front of the Producer Queue. */</span>
	<span class="p">}</span>

	<span class="cm">/* Queue is full */</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">headers</span><span class="p">.</span><span class="n">consumer</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;Queue %d full, %u outstanding.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">qid</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">numpending</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">entry</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="o">*</span><span class="n">index</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	aac_queue_get		-	get the next free QE</span>
<span class="cm"> *	@dev: Adapter</span>
<span class="cm"> *	@index: Returned index</span>
<span class="cm"> *	@priority: Priority of fib</span>
<span class="cm"> *	@fib: Fib to associate with the queue entry</span>
<span class="cm"> *	@wait: Wait if queue full</span>
<span class="cm"> *	@fibptr: Driver fib object to go with fib</span>
<span class="cm"> *	@nonotify: Don&#39;t notify the adapter</span>
<span class="cm"> *</span>
<span class="cm"> *	Gets the next free QE off the requested priorty adapter command</span>
<span class="cm"> *	queue and associates the Fib with the QE. The QE represented by</span>
<span class="cm"> *	index is ready to insert on the queue when this routine returns</span>
<span class="cm"> *	success.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">aac_queue_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">aac_dev</span> <span class="o">*</span> <span class="n">dev</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span> <span class="n">index</span><span class="p">,</span> <span class="n">u32</span> <span class="n">qid</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hw_fib</span> <span class="o">*</span> <span class="n">hw_fib</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wait</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fib</span> <span class="o">*</span> <span class="n">fibptr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">nonotify</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">aac_entry</span> <span class="o">*</span> <span class="n">entry</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">map</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">qid</span> <span class="o">==</span> <span class="n">AdapNormCmdQueue</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*  if no entries wait for some if caller wants to */</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">aac_get_entry</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">qid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">entry</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">nonotify</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;GetEntries failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 *	Setup queue entry with a command, status and fib mapped</span>
<span class="cm">		 */</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">hw_fib</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">Size</span><span class="p">));</span>
		<span class="n">map</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">aac_get_entry</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">qid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">entry</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">nonotify</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* if no entries wait for some if caller wants to */</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 *	Setup queue entry with command, status and fib mapped</span>
<span class="cm">		 */</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">hw_fib</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">Size</span><span class="p">));</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span> <span class="n">hw_fib</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">SenderFibAddress</span><span class="p">;</span>
			<span class="cm">/* Restore adapters pointer to the FIB */</span>
		<span class="n">hw_fib</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">ReceiverFibAddress</span> <span class="o">=</span> <span class="n">hw_fib</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">SenderFibAddress</span><span class="p">;</span>	<span class="cm">/* Let the adapter now where to find its data */</span>
		<span class="n">map</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 *	If MapFib is true than we need to map the Fib and put pointers</span>
<span class="cm">	 *	in the queue entry.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="p">)</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">fibptr</span><span class="o">-&gt;</span><span class="n">hw_fib_pa</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	Define the highest level of host to adapter communication routines.</span>
<span class="cm"> *	These routines will support host to adapter FS commuication. These</span>
<span class="cm"> *	routines have no knowledge of the commuication method used. This level</span>
<span class="cm"> *	sends and receives FIBs. This level has no knowledge of how these FIBs</span>
<span class="cm"> *	get passed back and forth.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> *	aac_fib_send	-	send a fib to the adapter</span>
<span class="cm"> *	@command: Command to send</span>
<span class="cm"> *	@fibptr: The fib</span>
<span class="cm"> *	@size: Size of fib data area</span>
<span class="cm"> *	@priority: Priority of Fib</span>
<span class="cm"> *	@wait: Async/sync select</span>
<span class="cm"> *	@reply: True if a reply is wanted</span>
<span class="cm"> *	@callback: Called with reply</span>
<span class="cm"> *	@callback_data: Passed to callback</span>
<span class="cm"> *</span>
<span class="cm"> *	Sends the requested FIB to the adapter and optionally will wait for a</span>
<span class="cm"> *	response FIB. If the caller does not wish to wait for a response than</span>
<span class="cm"> *	an event to wait on must be supplied. This event will be set when a</span>
<span class="cm"> *	response FIB is received from the adapter.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">aac_fib_send</span><span class="p">(</span><span class="n">u16</span> <span class="n">command</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fib</span> <span class="o">*</span><span class="n">fibptr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">priority</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wait</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reply</span><span class="p">,</span> <span class="n">fib_callback</span> <span class="n">callback</span><span class="p">,</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">callback_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">aac_dev</span> <span class="o">*</span> <span class="n">dev</span> <span class="o">=</span> <span class="n">fibptr</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hw_fib</span> <span class="o">*</span> <span class="n">hw_fib</span> <span class="o">=</span> <span class="n">fibptr</span><span class="o">-&gt;</span><span class="n">hw_fib_va</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">qflags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mflags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sflags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>


	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">hw_fib</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">XferState</span> <span class="o">&amp;</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">HostOwned</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 *	There are 5 cases with the wait and response requested flags.</span>
<span class="cm">	 *	The only invalid cases are if the caller requests to wait and</span>
<span class="cm">	 *	does not request a response and if the caller does not want a</span>
<span class="cm">	 *	response and the Fib is not allocated from pool. If a response</span>
<span class="cm">	 *	is not requesed the Fib will just be deallocaed by the DPC</span>
<span class="cm">	 *	routine when the response comes back from the adapter. No</span>
<span class="cm">	 *	further processing will be done besides deleting the Fib. We</span>
<span class="cm">	 *	will have a debug mode where the adapter can notify the host</span>
<span class="cm">	 *	it had a problem and the host can log that fact.</span>
<span class="cm">	 */</span>
	<span class="n">fibptr</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wait</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">reply</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wait</span> <span class="o">&amp;&amp;</span> <span class="n">reply</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hw_fib</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">XferState</span> <span class="o">|=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">Async</span> <span class="o">|</span> <span class="n">ResponseExpected</span><span class="p">);</span>
		<span class="n">FIB_COUNTER_INCREMENT</span><span class="p">(</span><span class="n">aac_config</span><span class="p">.</span><span class="n">AsyncSent</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wait</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">reply</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hw_fib</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">XferState</span> <span class="o">|=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">NoResponseExpected</span><span class="p">);</span>
		<span class="n">FIB_COUNTER_INCREMENT</span><span class="p">(</span><span class="n">aac_config</span><span class="p">.</span><span class="n">NoResponseSent</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">wait</span> <span class="o">&amp;&amp;</span> <span class="n">reply</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hw_fib</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">XferState</span> <span class="o">|=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">ResponseExpected</span><span class="p">);</span>
		<span class="n">FIB_COUNTER_INCREMENT</span><span class="p">(</span><span class="n">aac_config</span><span class="p">.</span><span class="n">NormalSent</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 *	Map the fib into 32bits by using the fib number</span>
<span class="cm">	 */</span>

	<span class="n">hw_fib</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">SenderFibAddress</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(((</span><span class="n">u32</span><span class="p">)(</span><span class="n">fibptr</span> <span class="o">-</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">fibs</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">);</span>
	<span class="n">hw_fib</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">SenderData</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)(</span><span class="n">fibptr</span> <span class="o">-</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">fibs</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 *	Set FIB state to indicate where it came from and if we want a</span>
<span class="cm">	 *	response from the adapter. Also load the command from the</span>
<span class="cm">	 *	caller.</span>
<span class="cm">	 *</span>
<span class="cm">	 *	Map the hw fib pointer as a 32bit value</span>
<span class="cm">	 */</span>
	<span class="n">hw_fib</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">Command</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">command</span><span class="p">);</span>
	<span class="n">hw_fib</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">XferState</span> <span class="o">|=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">SentFromHost</span><span class="p">);</span>
	<span class="n">fibptr</span><span class="o">-&gt;</span><span class="n">hw_fib_va</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">Flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* 0 the flags field - internal only*/</span>
	<span class="cm">/*</span>
<span class="cm">	 *	Set the size of the Fib we want to send to the adapter</span>
<span class="cm">	 */</span>
	<span class="n">hw_fib</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">Size</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">aac_fibhdr</span><span class="p">)</span> <span class="o">+</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">hw_fib</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">Size</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">hw_fib</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">SenderSize</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EMSGSIZE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 *	Get a queue entry connect the FIB to it and send an notify</span>
<span class="cm">	 *	the adapter a command is ready.</span>
<span class="cm">	 */</span>
	<span class="n">hw_fib</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">XferState</span> <span class="o">|=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">NormalPriority</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *	Fill in the Callback and CallbackContext if we are not</span>
<span class="cm">	 *	going to wait.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wait</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fibptr</span><span class="o">-&gt;</span><span class="n">callback</span> <span class="o">=</span> <span class="n">callback</span><span class="p">;</span>
		<span class="n">fibptr</span><span class="o">-&gt;</span><span class="n">callback_data</span> <span class="o">=</span> <span class="n">callback_data</span><span class="p">;</span>
		<span class="n">fibptr</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">FIB_CONTEXT_FLAG</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">fibptr</span><span class="o">-&gt;</span><span class="n">done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">FIB_COUNTER_INCREMENT</span><span class="p">(</span><span class="n">aac_config</span><span class="p">.</span><span class="n">FibsSent</span><span class="p">);</span>

	<span class="n">dprintk</span><span class="p">((</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;Fib contents:.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
	<span class="n">dprintk</span><span class="p">((</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;  Command =               %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">hw_fib</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">Command</span><span class="p">)));</span>
	<span class="n">dprintk</span><span class="p">((</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;  SubCommand =            %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">le32_to_cpu</span><span class="p">(((</span><span class="k">struct</span> <span class="n">aac_query_mount</span> <span class="o">*</span><span class="p">)</span><span class="n">fib_data</span><span class="p">(</span><span class="n">fibptr</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">)));</span>
	<span class="n">dprintk</span><span class="p">((</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;  XferState  =            %x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">hw_fib</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">XferState</span><span class="p">)));</span>
	<span class="n">dprintk</span><span class="p">((</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;  hw_fib va being sent=%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">fibptr</span><span class="o">-&gt;</span><span class="n">hw_fib_va</span><span class="p">));</span>
	<span class="n">dprintk</span><span class="p">((</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;  hw_fib pa being sent=%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,(</span><span class="n">ulong</span><span class="p">)</span><span class="n">fibptr</span><span class="o">-&gt;</span><span class="n">hw_fib_pa</span><span class="p">));</span>
	<span class="n">dprintk</span><span class="p">((</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;  fib being sent=%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">fibptr</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">queues</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wait</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">manage_lock</span><span class="p">,</span> <span class="n">mflags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">management_fib_count</span> <span class="o">&gt;=</span> <span class="n">AAC_NUM_MGT_FIB</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;No management Fibs Available:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">dev</span><span class="o">-&gt;</span><span class="n">management_fib_count</span><span class="p">);</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">manage_lock</span><span class="p">,</span> <span class="n">mflags</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">management_fib_count</span><span class="o">++</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">manage_lock</span><span class="p">,</span> <span class="n">mflags</span><span class="p">);</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fibptr</span><span class="o">-&gt;</span><span class="n">event_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">sync_mode</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wait</span><span class="p">)</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fibptr</span><span class="o">-&gt;</span><span class="n">event_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">sync_lock</span><span class="p">,</span> <span class="n">sflags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">sync_fib</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fibptr</span><span class="o">-&gt;</span><span class="n">fiblink</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">sync_fib_list</span><span class="p">);</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">sync_lock</span><span class="p">,</span> <span class="n">sflags</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">sync_fib</span> <span class="o">=</span> <span class="n">fibptr</span><span class="p">;</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">sync_lock</span><span class="p">,</span> <span class="n">sflags</span><span class="p">);</span>
			<span class="n">aac_adapter_sync_cmd</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">SEND_SYNCHRONOUS_FIB</span><span class="p">,</span>
				<span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">fibptr</span><span class="o">-&gt;</span><span class="n">hw_fib_pa</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				<span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wait</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">fibptr</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">FIB_CONTEXT_FLAG_WAIT</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">down_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fibptr</span><span class="o">-&gt;</span><span class="n">event_wait</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">fibptr</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FIB_CONTEXT_FLAG_WAIT</span><span class="p">;</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">aac_adapter_deliver</span><span class="p">(</span><span class="n">fibptr</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;aac_fib_send: returned -EBUSY</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wait</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fibptr</span><span class="o">-&gt;</span><span class="n">event_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">manage_lock</span><span class="p">,</span> <span class="n">mflags</span><span class="p">);</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">management_fib_count</span><span class="o">--</span><span class="p">;</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">manage_lock</span><span class="p">,</span> <span class="n">mflags</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>


	<span class="cm">/*</span>
<span class="cm">	 *	If the caller wanted us to wait for response wait now.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wait</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fibptr</span><span class="o">-&gt;</span><span class="n">event_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="cm">/* Only set for first known interruptable command */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wait</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * *VERY* Dangerous to time out a command, the</span>
<span class="cm">			 * assumption is made that we have no hope of</span>
<span class="cm">			 * functioning because an interrupt routing or other</span>
<span class="cm">			 * hardware failure has occurred.</span>
<span class="cm">			 */</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">36000000L</span><span class="p">;</span> <span class="cm">/* 3 minutes */</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">down_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fibptr</span><span class="o">-&gt;</span><span class="n">event_wait</span><span class="p">))</span> <span class="p">{</span>
				<span class="kt">int</span> <span class="n">blink</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">struct</span> <span class="n">aac_queue</span> <span class="o">*</span> <span class="n">q</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">queues</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">[</span><span class="n">AdapNormCmdQueue</span><span class="p">];</span>
					<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">qflags</span><span class="p">);</span>
					<span class="n">q</span><span class="o">-&gt;</span><span class="n">numpending</span><span class="o">--</span><span class="p">;</span>
					<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">qflags</span><span class="p">);</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">wait</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
	        				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;aacraid: aac_fib_send: first asynchronous command timed out.</span><span class="se">\n</span><span class="s">&quot;</span>
						  <span class="s">&quot;Usually a result of a PCI interrupt routing problem;</span><span class="se">\n</span><span class="s">&quot;</span>
						  <span class="s">&quot;update mother board BIOS or consider utilizing one of</span><span class="se">\n</span><span class="s">&quot;</span>
						  <span class="s">&quot;the SAFE mode kernel options (acpi, apic etc)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
					<span class="p">}</span>
					<span class="k">return</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">blink</span> <span class="o">=</span> <span class="n">aac_adapter_check_health</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">wait</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
	        				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;aacraid: aac_fib_send: adapter blinkLED 0x%x.</span><span class="se">\n</span><span class="s">&quot;</span>
						  <span class="s">&quot;Usually a result of a serious unrecoverable hardware problem</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						  <span class="n">blink</span><span class="p">);</span>
					<span class="p">}</span>
					<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">udelay</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">down_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fibptr</span><span class="o">-&gt;</span><span class="n">event_wait</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Do nothing ... satisfy</span>
<span class="cm">			 * down_interruptible must_check */</span>
		<span class="p">}</span>

		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fibptr</span><span class="o">-&gt;</span><span class="n">event_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fibptr</span><span class="o">-&gt;</span><span class="n">done</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">fibptr</span><span class="o">-&gt;</span><span class="n">done</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="cm">/* Tell interrupt we aborted */</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fibptr</span><span class="o">-&gt;</span><span class="n">event_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ERESTARTSYS</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fibptr</span><span class="o">-&gt;</span><span class="n">event_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">fibptr</span><span class="o">-&gt;</span><span class="n">done</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

		<span class="k">if</span><span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">fibptr</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FIB_CONTEXT_FLAG_TIMED_OUT</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 *	If the user does not want a response than return success otherwise</span>
<span class="cm">	 *	return pending</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reply</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	aac_consumer_get	-	get the top of the queue</span>
<span class="cm"> *	@dev: Adapter</span>
<span class="cm"> *	@q: Queue</span>
<span class="cm"> *	@entry: Return entry</span>
<span class="cm"> *</span>
<span class="cm"> *	Will return a pointer to the entry on the top of the queue requested that</span>
<span class="cm"> *	we are a consumer of, and return the address of the queue entry. It does</span>
<span class="cm"> *	not change the state of the queue.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">aac_consumer_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">aac_dev</span> <span class="o">*</span> <span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">aac_queue</span> <span class="o">*</span> <span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">aac_entry</span> <span class="o">**</span><span class="n">entry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">index</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">headers</span><span class="p">.</span><span class="n">producer</span><span class="p">)</span> <span class="o">==</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">headers</span><span class="p">.</span><span class="n">consumer</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 *	The consumer index must be wrapped if we have reached</span>
<span class="cm">		 *	the end of the queue, else we just use the entry</span>
<span class="cm">		 *	pointed to by the header index</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">headers</span><span class="p">.</span><span class="n">consumer</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">)</span>
			<span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">index</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">headers</span><span class="p">.</span><span class="n">consumer</span><span class="p">);</span>
		<span class="o">*</span><span class="n">entry</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">index</span><span class="p">;</span>
		<span class="n">status</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span><span class="p">(</span><span class="n">status</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	aac_consumer_free	-	free consumer entry</span>
<span class="cm"> *	@dev: Adapter</span>
<span class="cm"> *	@q: Queue</span>
<span class="cm"> *	@qid: Queue ident</span>
<span class="cm"> *</span>
<span class="cm"> *	Frees up the current top of the queue we are a consumer of. If the</span>
<span class="cm"> *	queue was full notify the producer that the queue is no longer full.</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">aac_consumer_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">aac_dev</span> <span class="o">*</span> <span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">aac_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="n">u32</span> <span class="n">qid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">wasfull</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">notify</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">headers</span><span class="p">.</span><span class="n">producer</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">headers</span><span class="p">.</span><span class="n">consumer</span><span class="p">))</span>
		<span class="n">wasfull</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">headers</span><span class="p">.</span><span class="n">consumer</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">)</span>
		<span class="o">*</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">headers</span><span class="p">.</span><span class="n">consumer</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">le32_add_cpu</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">headers</span><span class="p">.</span><span class="n">consumer</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wasfull</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">qid</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">case</span> <span class="n">HostNormCmdQueue</span>:
			<span class="n">notify</span> <span class="o">=</span> <span class="n">HostNormCmdNotFull</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">HostNormRespQueue</span>:
			<span class="n">notify</span> <span class="o">=</span> <span class="n">HostNormRespNotFull</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">BUG</span><span class="p">();</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">aac_adapter_notify</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">notify</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	aac_fib_adapter_complete	-	complete adapter issued fib</span>
<span class="cm"> *	@fibptr: fib to complete</span>
<span class="cm"> *	@size: size of fib</span>
<span class="cm"> *</span>
<span class="cm"> *	Will do all necessary work to complete a FIB that was sent from</span>
<span class="cm"> *	the adapter.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">aac_fib_adapter_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">fib</span> <span class="o">*</span><span class="n">fibptr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hw_fib</span> <span class="o">*</span> <span class="n">hw_fib</span> <span class="o">=</span> <span class="n">fibptr</span><span class="o">-&gt;</span><span class="n">hw_fib_va</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">aac_dev</span> <span class="o">*</span> <span class="n">dev</span> <span class="o">=</span> <span class="n">fibptr</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">aac_queue</span> <span class="o">*</span> <span class="n">q</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nointr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">qflags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">comm_interface</span> <span class="o">==</span> <span class="n">AAC_COMM_MESSAGE_TYPE1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">hw_fib</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw_fib</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">XferState</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">comm_interface</span> <span class="o">==</span> <span class="n">AAC_COMM_MESSAGE</span><span class="p">)</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">hw_fib</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 *	If we plan to do anything check the structure type first.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw_fib</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">StructType</span> <span class="o">!=</span> <span class="n">FIB_MAGIC</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">comm_interface</span> <span class="o">==</span> <span class="n">AAC_COMM_MESSAGE</span><span class="p">)</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">hw_fib</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 *	This block handles the case where the adapter had sent us a</span>
<span class="cm">	 *	command and we have finished processing the command. We</span>
<span class="cm">	 *	call completeFib when we are done processing the command</span>
<span class="cm">	 *	and want to send a response back to the adapter. This will</span>
<span class="cm">	 *	send the completed cdb to the adapter.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw_fib</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">XferState</span> <span class="o">&amp;</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">SentFromAdapter</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">comm_interface</span> <span class="o">==</span> <span class="n">AAC_COMM_MESSAGE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kfree</span> <span class="p">(</span><span class="n">hw_fib</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">u32</span> <span class="n">index</span><span class="p">;</span>
			<span class="n">hw_fib</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">XferState</span> <span class="o">|=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">HostProcessed</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">size</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">aac_fibhdr</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">hw_fib</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">SenderSize</span><span class="p">))</span>
					<span class="k">return</span> <span class="o">-</span><span class="n">EMSGSIZE</span><span class="p">;</span>
				<span class="n">hw_fib</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">Size</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">q</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">queues</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">[</span><span class="n">AdapNormRespQueue</span><span class="p">];</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">qflags</span><span class="p">);</span>
			<span class="n">aac_queue_get</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">index</span><span class="p">,</span> <span class="n">AdapNormRespQueue</span><span class="p">,</span> <span class="n">hw_fib</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nointr</span><span class="p">);</span>
			<span class="o">*</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">headers</span><span class="p">.</span><span class="n">producer</span><span class="p">)</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">qflags</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">nointr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">aac_config</span><span class="p">.</span><span class="n">irq_mod</span><span class="p">))</span>
				<span class="n">aac_adapter_notify</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">AdapNormRespQueue</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;aac_fib_adapter_complete: &quot;</span>
			<span class="s">&quot;Unknown xferstate detected.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	aac_fib_complete	-	fib completion handler</span>
<span class="cm"> *	@fib: FIB to complete</span>
<span class="cm"> *</span>
<span class="cm"> *	Will do all necessary work to complete a FIB.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">aac_fib_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">fib</span> <span class="o">*</span><span class="n">fibptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hw_fib</span> <span class="o">*</span> <span class="n">hw_fib</span> <span class="o">=</span> <span class="n">fibptr</span><span class="o">-&gt;</span><span class="n">hw_fib_va</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *	Check for a fib which has already been completed</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw_fib</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">XferState</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 *	If we plan to do anything check the structure type first.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw_fib</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">StructType</span> <span class="o">!=</span> <span class="n">FIB_MAGIC</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 *	This block completes a cdb which orginated on the host and we</span>
<span class="cm">	 *	just need to deallocate the cdb or reinit it. At this point the</span>
<span class="cm">	 *	command is complete that we had sent to the adapter and this</span>
<span class="cm">	 *	cdb could be reused.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fibptr</span><span class="o">-&gt;</span><span class="n">event_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fibptr</span><span class="o">-&gt;</span><span class="n">done</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fibptr</span><span class="o">-&gt;</span><span class="n">event_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fibptr</span><span class="o">-&gt;</span><span class="n">event_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span><span class="p">((</span><span class="n">hw_fib</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">XferState</span> <span class="o">&amp;</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">SentFromHost</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="n">hw_fib</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">XferState</span> <span class="o">&amp;</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">AdapterProcessed</span><span class="p">)))</span>
	<span class="p">{</span>
		<span class="n">fib_dealloc</span><span class="p">(</span><span class="n">fibptr</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">hw_fib</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">XferState</span> <span class="o">&amp;</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">SentFromHost</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 *	This handles the case when the host has aborted the I/O</span>
<span class="cm">		 *	to the adapter because the adapter is not responding</span>
<span class="cm">		 */</span>
		<span class="n">fib_dealloc</span><span class="p">(</span><span class="n">fibptr</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">hw_fib</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">XferState</span> <span class="o">&amp;</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">HostOwned</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">fib_dealloc</span><span class="p">(</span><span class="n">fibptr</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	aac_printf	-	handle printf from firmware</span>
<span class="cm"> *	@dev: Adapter</span>
<span class="cm"> *	@val: Message info</span>
<span class="cm"> *</span>
<span class="cm"> *	Print a message passed to us by the controller firmware on the</span>
<span class="cm"> *	Adaptec board</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">aac_printf</span><span class="p">(</span><span class="k">struct</span> <span class="n">aac_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">cp</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">printfbuf</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">printf_enabled</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">val</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">level</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 *	The size of the printfbuf is set in port.c</span>
<span class="cm">		 *	There is no variable or define for it</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">&gt;</span> <span class="mi">255</span><span class="p">)</span>
			<span class="n">length</span> <span class="o">=</span> <span class="mi">255</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="p">[</span><span class="n">length</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">cp</span><span class="p">[</span><span class="n">length</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">==</span> <span class="n">LOG_AAC_HIGH_ERROR</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s:%s&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">cp</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s:%s&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">cp</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">256</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> *	aac_handle_aif		-	Handle a message from the firmware</span>
<span class="cm"> *	@dev: Which adapter this fib is from</span>
<span class="cm"> *	@fibptr: Pointer to fibptr from adapter</span>
<span class="cm"> *</span>
<span class="cm"> *	This routine handles a driver notify fib from the adapter and</span>
<span class="cm"> *	dispatches it to the appropriate routine for handling.</span>
<span class="cm"> */</span>

<span class="cp">#define AIF_SNIFF_TIMEOUT	(30*HZ)</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">aac_handle_aif</span><span class="p">(</span><span class="k">struct</span> <span class="n">aac_dev</span> <span class="o">*</span> <span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fib</span> <span class="o">*</span> <span class="n">fibptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hw_fib</span> <span class="o">*</span> <span class="n">hw_fib</span> <span class="o">=</span> <span class="n">fibptr</span><span class="o">-&gt;</span><span class="n">hw_fib_va</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">aac_aifcmd</span> <span class="o">*</span> <span class="n">aifcmd</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">aac_aifcmd</span> <span class="o">*</span><span class="p">)</span><span class="n">hw_fib</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">channel</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="n">lun</span><span class="p">,</span> <span class="n">container</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">device</span><span class="p">;</span>
	<span class="k">enum</span> <span class="p">{</span>
		<span class="n">NOTHING</span><span class="p">,</span>
		<span class="n">DELETE</span><span class="p">,</span>
		<span class="n">ADD</span><span class="p">,</span>
		<span class="n">CHANGE</span>
	<span class="p">}</span> <span class="n">device_config_needed</span> <span class="o">=</span> <span class="n">NOTHING</span><span class="p">;</span>

	<span class="cm">/* Sniff for container changes */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span> <span class="o">||</span> <span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">fsa_dev</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">container</span> <span class="o">=</span> <span class="n">channel</span> <span class="o">=</span> <span class="n">id</span> <span class="o">=</span> <span class="n">lun</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *	We have set this up to try and minimize the number of</span>
<span class="cm">	 * re-configures that take place. As a result of this when</span>
<span class="cm">	 * certain AIF&#39;s come in we will set a flag waiting for another</span>
<span class="cm">	 * type of AIF before setting the re-config flag.</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">aifcmd</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">AifCmdDriverNotify</span>:
		<span class="k">switch</span> <span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(((</span><span class="n">__le32</span> <span class="o">*</span><span class="p">)</span><span class="n">aifcmd</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)[</span><span class="mi">0</span><span class="p">]))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 *	Morph or Expand complete</span>
<span class="cm">		 */</span>
		<span class="k">case</span> <span class="n">AifDenMorphComplete</span>:
		<span class="k">case</span> <span class="n">AifDenVolumeExtendComplete</span>:
			<span class="n">container</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(((</span><span class="n">__le32</span> <span class="o">*</span><span class="p">)</span><span class="n">aifcmd</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)[</span><span class="mi">1</span><span class="p">]);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">container</span> <span class="o">&gt;=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">maximum_num_containers</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 *	Find the scsi_device associated with the SCSI</span>
<span class="cm">			 * address. Make sure we have the right array, and if</span>
<span class="cm">			 * so set the flag to initiate a new re-config once we</span>
<span class="cm">			 * see an AifEnConfigChange AIF come through.</span>
<span class="cm">			 */</span>

			<span class="k">if</span> <span class="p">((</span><span class="n">dev</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">scsi_host_ptr</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">device</span> <span class="o">=</span> <span class="n">scsi_device_lookup</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">scsi_host_ptr</span><span class="p">,</span>
					<span class="n">CONTAINER_TO_CHANNEL</span><span class="p">(</span><span class="n">container</span><span class="p">),</span>
					<span class="n">CONTAINER_TO_ID</span><span class="p">(</span><span class="n">container</span><span class="p">),</span>
					<span class="n">CONTAINER_TO_LUN</span><span class="p">(</span><span class="n">container</span><span class="p">));</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">device</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">dev</span><span class="o">-&gt;</span><span class="n">fsa_dev</span><span class="p">[</span><span class="n">container</span><span class="p">].</span><span class="n">config_needed</span> <span class="o">=</span> <span class="n">CHANGE</span><span class="p">;</span>
					<span class="n">dev</span><span class="o">-&gt;</span><span class="n">fsa_dev</span><span class="p">[</span><span class="n">container</span><span class="p">].</span><span class="n">config_waiting_on</span> <span class="o">=</span> <span class="n">AifEnConfigChange</span><span class="p">;</span>
					<span class="n">dev</span><span class="o">-&gt;</span><span class="n">fsa_dev</span><span class="p">[</span><span class="n">container</span><span class="p">].</span><span class="n">config_waiting_stamp</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
					<span class="n">scsi_device_put</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 *	If we are waiting on something and this happens to be</span>
<span class="cm">		 * that thing then set the re-configure flag.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">container</span> <span class="o">!=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">container</span> <span class="o">&gt;=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">maximum_num_containers</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">fsa_dev</span><span class="p">[</span><span class="n">container</span><span class="p">].</span><span class="n">config_waiting_on</span> <span class="o">==</span>
			    <span class="n">le32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">__le32</span> <span class="o">*</span><span class="p">)</span><span class="n">aifcmd</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
			 <span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">fsa_dev</span><span class="p">[</span><span class="n">container</span><span class="p">].</span><span class="n">config_waiting_stamp</span> <span class="o">+</span> <span class="n">AIF_SNIFF_TIMEOUT</span><span class="p">))</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">fsa_dev</span><span class="p">[</span><span class="n">container</span><span class="p">].</span><span class="n">config_waiting_on</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">for</span> <span class="p">(</span><span class="n">container</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		    <span class="n">container</span> <span class="o">&lt;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">maximum_num_containers</span><span class="p">;</span> <span class="o">++</span><span class="n">container</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">fsa_dev</span><span class="p">[</span><span class="n">container</span><span class="p">].</span><span class="n">config_waiting_on</span> <span class="o">==</span>
			    <span class="n">le32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">__le32</span> <span class="o">*</span><span class="p">)</span><span class="n">aifcmd</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
			 <span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">fsa_dev</span><span class="p">[</span><span class="n">container</span><span class="p">].</span><span class="n">config_waiting_stamp</span> <span class="o">+</span> <span class="n">AIF_SNIFF_TIMEOUT</span><span class="p">))</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">fsa_dev</span><span class="p">[</span><span class="n">container</span><span class="p">].</span><span class="n">config_waiting_on</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">AifCmdEventNotify</span>:
		<span class="k">switch</span> <span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(((</span><span class="n">__le32</span> <span class="o">*</span><span class="p">)</span><span class="n">aifcmd</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)[</span><span class="mi">0</span><span class="p">]))</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">AifEnBatteryEvent</span>:
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">cache_protected</span> <span class="o">=</span>
				<span class="p">(((</span><span class="n">__le32</span> <span class="o">*</span><span class="p">)</span><span class="n">aifcmd</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 *	Add an Array.</span>
<span class="cm">		 */</span>
		<span class="k">case</span> <span class="n">AifEnAddContainer</span>:
			<span class="n">container</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(((</span><span class="n">__le32</span> <span class="o">*</span><span class="p">)</span><span class="n">aifcmd</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)[</span><span class="mi">1</span><span class="p">]);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">container</span> <span class="o">&gt;=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">maximum_num_containers</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">fsa_dev</span><span class="p">[</span><span class="n">container</span><span class="p">].</span><span class="n">config_needed</span> <span class="o">=</span> <span class="n">ADD</span><span class="p">;</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">fsa_dev</span><span class="p">[</span><span class="n">container</span><span class="p">].</span><span class="n">config_waiting_on</span> <span class="o">=</span>
				<span class="n">AifEnConfigChange</span><span class="p">;</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">fsa_dev</span><span class="p">[</span><span class="n">container</span><span class="p">].</span><span class="n">config_waiting_stamp</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 *	Delete an Array.</span>
<span class="cm">		 */</span>
		<span class="k">case</span> <span class="n">AifEnDeleteContainer</span>:
			<span class="n">container</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(((</span><span class="n">__le32</span> <span class="o">*</span><span class="p">)</span><span class="n">aifcmd</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)[</span><span class="mi">1</span><span class="p">]);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">container</span> <span class="o">&gt;=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">maximum_num_containers</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">fsa_dev</span><span class="p">[</span><span class="n">container</span><span class="p">].</span><span class="n">config_needed</span> <span class="o">=</span> <span class="n">DELETE</span><span class="p">;</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">fsa_dev</span><span class="p">[</span><span class="n">container</span><span class="p">].</span><span class="n">config_waiting_on</span> <span class="o">=</span>
				<span class="n">AifEnConfigChange</span><span class="p">;</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">fsa_dev</span><span class="p">[</span><span class="n">container</span><span class="p">].</span><span class="n">config_waiting_stamp</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 *	Container change detected. If we currently are not</span>
<span class="cm">		 * waiting on something else, setup to wait on a Config Change.</span>
<span class="cm">		 */</span>
		<span class="k">case</span> <span class="n">AifEnContainerChange</span>:
			<span class="n">container</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(((</span><span class="n">__le32</span> <span class="o">*</span><span class="p">)</span><span class="n">aifcmd</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)[</span><span class="mi">1</span><span class="p">]);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">container</span> <span class="o">&gt;=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">maximum_num_containers</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">fsa_dev</span><span class="p">[</span><span class="n">container</span><span class="p">].</span><span class="n">config_waiting_on</span> <span class="o">&amp;&amp;</span>
			 <span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">fsa_dev</span><span class="p">[</span><span class="n">container</span><span class="p">].</span><span class="n">config_waiting_stamp</span> <span class="o">+</span> <span class="n">AIF_SNIFF_TIMEOUT</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">fsa_dev</span><span class="p">[</span><span class="n">container</span><span class="p">].</span><span class="n">config_needed</span> <span class="o">=</span> <span class="n">CHANGE</span><span class="p">;</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">fsa_dev</span><span class="p">[</span><span class="n">container</span><span class="p">].</span><span class="n">config_waiting_on</span> <span class="o">=</span>
				<span class="n">AifEnConfigChange</span><span class="p">;</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">fsa_dev</span><span class="p">[</span><span class="n">container</span><span class="p">].</span><span class="n">config_waiting_stamp</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">AifEnConfigChange</span>:
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">AifEnAddJBOD</span>:
		<span class="k">case</span> <span class="n">AifEnDeleteJBOD</span>:
			<span class="n">container</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(((</span><span class="n">__le32</span> <span class="o">*</span><span class="p">)</span><span class="n">aifcmd</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)[</span><span class="mi">1</span><span class="p">]);</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">container</span> <span class="o">&gt;&gt;</span> <span class="mi">28</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">container</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">channel</span> <span class="o">=</span> <span class="p">(</span><span class="n">container</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">channel</span> <span class="o">&gt;=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">maximum_num_channels</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">container</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">id</span> <span class="o">=</span> <span class="n">container</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">&gt;=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">maximum_num_physicals</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">container</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">lun</span> <span class="o">=</span> <span class="p">(</span><span class="n">container</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>
			<span class="n">container</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="n">channel</span> <span class="o">=</span> <span class="n">aac_phys_to_logical</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>
			<span class="n">device_config_needed</span> <span class="o">=</span>
			  <span class="p">(((</span><span class="n">__le32</span> <span class="o">*</span><span class="p">)</span><span class="n">aifcmd</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span>
			    <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">AifEnAddJBOD</span><span class="p">))</span> <span class="o">?</span> <span class="n">ADD</span> <span class="o">:</span> <span class="n">DELETE</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">device_config_needed</span> <span class="o">==</span> <span class="n">ADD</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">device</span> <span class="o">=</span> <span class="n">scsi_device_lookup</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">scsi_host_ptr</span><span class="p">,</span>
					<span class="n">channel</span><span class="p">,</span>
					<span class="n">id</span><span class="p">,</span>
					<span class="n">lun</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">device</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">scsi_remove_device</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
					<span class="n">scsi_device_put</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">AifEnEnclosureManagement</span>:
			<span class="cm">/*</span>
<span class="cm">			 * If in JBOD mode, automatic exposure of new</span>
<span class="cm">			 * physical target to be suppressed until configured.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">jbod</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(((</span><span class="n">__le32</span> <span class="o">*</span><span class="p">)</span><span class="n">aifcmd</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)[</span><span class="mi">3</span><span class="p">]))</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">EM_DRIVE_INSERTION</span>:
			<span class="k">case</span> <span class="n">EM_DRIVE_REMOVAL</span>:
				<span class="n">container</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span>
					<span class="p">((</span><span class="n">__le32</span> <span class="o">*</span><span class="p">)</span><span class="n">aifcmd</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)[</span><span class="mi">2</span><span class="p">]);</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">container</span> <span class="o">&gt;&gt;</span> <span class="mi">28</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">container</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">channel</span> <span class="o">=</span> <span class="p">(</span><span class="n">container</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">channel</span> <span class="o">&gt;=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">maximum_num_channels</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">container</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">id</span> <span class="o">=</span> <span class="n">container</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="p">;</span>
				<span class="n">lun</span> <span class="o">=</span> <span class="p">(</span><span class="n">container</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>
				<span class="n">container</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">&gt;=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">maximum_num_physicals</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* legacy dev_t ? */</span>
					<span class="k">if</span> <span class="p">((</span><span class="mh">0x2000</span> <span class="o">&lt;=</span> <span class="n">id</span><span class="p">)</span> <span class="o">||</span> <span class="n">lun</span> <span class="o">||</span> <span class="n">channel</span> <span class="o">||</span>
					  <span class="p">((</span><span class="n">channel</span> <span class="o">=</span> <span class="p">(</span><span class="n">id</span> <span class="o">&gt;&gt;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3F</span><span class="p">)</span> <span class="o">&gt;=</span>
					  <span class="n">dev</span><span class="o">-&gt;</span><span class="n">maximum_num_channels</span><span class="p">))</span>
						<span class="k">break</span><span class="p">;</span>
					<span class="n">lun</span> <span class="o">=</span> <span class="p">(</span><span class="n">id</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">;</span>
					<span class="n">id</span> <span class="o">&amp;=</span> <span class="mh">0xF</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">channel</span> <span class="o">=</span> <span class="n">aac_phys_to_logical</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>
				<span class="n">device_config_needed</span> <span class="o">=</span>
				  <span class="p">(((</span><span class="n">__le32</span> <span class="o">*</span><span class="p">)</span><span class="n">aifcmd</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)[</span><span class="mi">3</span><span class="p">]</span>
				    <span class="o">==</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">EM_DRIVE_INSERTION</span><span class="p">))</span> <span class="o">?</span>
				  <span class="n">ADD</span> <span class="o">:</span> <span class="n">DELETE</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 *	If we are waiting on something and this happens to be</span>
<span class="cm">		 * that thing then set the re-configure flag.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">container</span> <span class="o">!=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">container</span> <span class="o">&gt;=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">maximum_num_containers</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">fsa_dev</span><span class="p">[</span><span class="n">container</span><span class="p">].</span><span class="n">config_waiting_on</span> <span class="o">==</span>
			    <span class="n">le32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">__le32</span> <span class="o">*</span><span class="p">)</span><span class="n">aifcmd</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
			 <span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">fsa_dev</span><span class="p">[</span><span class="n">container</span><span class="p">].</span><span class="n">config_waiting_stamp</span> <span class="o">+</span> <span class="n">AIF_SNIFF_TIMEOUT</span><span class="p">))</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">fsa_dev</span><span class="p">[</span><span class="n">container</span><span class="p">].</span><span class="n">config_waiting_on</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">for</span> <span class="p">(</span><span class="n">container</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		    <span class="n">container</span> <span class="o">&lt;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">maximum_num_containers</span><span class="p">;</span> <span class="o">++</span><span class="n">container</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">fsa_dev</span><span class="p">[</span><span class="n">container</span><span class="p">].</span><span class="n">config_waiting_on</span> <span class="o">==</span>
			    <span class="n">le32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">__le32</span> <span class="o">*</span><span class="p">)</span><span class="n">aifcmd</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
			 <span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">fsa_dev</span><span class="p">[</span><span class="n">container</span><span class="p">].</span><span class="n">config_waiting_stamp</span> <span class="o">+</span> <span class="n">AIF_SNIFF_TIMEOUT</span><span class="p">))</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">fsa_dev</span><span class="p">[</span><span class="n">container</span><span class="p">].</span><span class="n">config_waiting_on</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">AifCmdJobProgress</span>:
		<span class="cm">/*</span>
<span class="cm">		 *	These are job progress AIF&#39;s. When a Clear is being</span>
<span class="cm">		 * done on a container it is initially created then hidden from</span>
<span class="cm">		 * the OS. When the clear completes we don&#39;t get a config</span>
<span class="cm">		 * change so we monitor the job status complete on a clear then</span>
<span class="cm">		 * wait for a container change.</span>
<span class="cm">		 */</span>

		<span class="k">if</span> <span class="p">(((</span><span class="n">__le32</span> <span class="o">*</span><span class="p">)</span><span class="n">aifcmd</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">AifJobCtrZero</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(((</span><span class="n">__le32</span> <span class="o">*</span><span class="p">)</span><span class="n">aifcmd</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)[</span><span class="mi">6</span><span class="p">]</span> <span class="o">==</span> <span class="p">((</span><span class="n">__le32</span> <span class="o">*</span><span class="p">)</span><span class="n">aifcmd</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)[</span><span class="mi">5</span><span class="p">]</span> <span class="o">||</span>
		     <span class="p">((</span><span class="n">__le32</span> <span class="o">*</span><span class="p">)</span><span class="n">aifcmd</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)[</span><span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">AifJobStsSuccess</span><span class="p">)))</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">container</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			    <span class="n">container</span> <span class="o">&lt;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">maximum_num_containers</span><span class="p">;</span>
			    <span class="o">++</span><span class="n">container</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Stomp on all config sequencing for all</span>
<span class="cm">				 * containers?</span>
<span class="cm">				 */</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">fsa_dev</span><span class="p">[</span><span class="n">container</span><span class="p">].</span><span class="n">config_waiting_on</span> <span class="o">=</span>
					<span class="n">AifEnContainerChange</span><span class="p">;</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">fsa_dev</span><span class="p">[</span><span class="n">container</span><span class="p">].</span><span class="n">config_needed</span> <span class="o">=</span> <span class="n">ADD</span><span class="p">;</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">fsa_dev</span><span class="p">[</span><span class="n">container</span><span class="p">].</span><span class="n">config_waiting_stamp</span> <span class="o">=</span>
					<span class="n">jiffies</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(((</span><span class="n">__le32</span> <span class="o">*</span><span class="p">)</span><span class="n">aifcmd</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">AifJobCtrZero</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">((</span><span class="n">__le32</span> <span class="o">*</span><span class="p">)</span><span class="n">aifcmd</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)[</span><span class="mi">6</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
		    <span class="p">((</span><span class="n">__le32</span> <span class="o">*</span><span class="p">)</span><span class="n">aifcmd</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)[</span><span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">AifJobStsRunning</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">container</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			    <span class="n">container</span> <span class="o">&lt;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">maximum_num_containers</span><span class="p">;</span>
			    <span class="o">++</span><span class="n">container</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Stomp on all config sequencing for all</span>
<span class="cm">				 * containers?</span>
<span class="cm">				 */</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">fsa_dev</span><span class="p">[</span><span class="n">container</span><span class="p">].</span><span class="n">config_waiting_on</span> <span class="o">=</span>
					<span class="n">AifEnContainerChange</span><span class="p">;</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">fsa_dev</span><span class="p">[</span><span class="n">container</span><span class="p">].</span><span class="n">config_needed</span> <span class="o">=</span> <span class="n">DELETE</span><span class="p">;</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">fsa_dev</span><span class="p">[</span><span class="n">container</span><span class="p">].</span><span class="n">config_waiting_stamp</span> <span class="o">=</span>
					<span class="n">jiffies</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">container</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">retry_next:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">device_config_needed</span> <span class="o">==</span> <span class="n">NOTHING</span><span class="p">)</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">container</span> <span class="o">&lt;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">maximum_num_containers</span><span class="p">;</span> <span class="o">++</span><span class="n">container</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">fsa_dev</span><span class="p">[</span><span class="n">container</span><span class="p">].</span><span class="n">config_waiting_on</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">fsa_dev</span><span class="p">[</span><span class="n">container</span><span class="p">].</span><span class="n">config_needed</span> <span class="o">!=</span> <span class="n">NOTHING</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">fsa_dev</span><span class="p">[</span><span class="n">container</span><span class="p">].</span><span class="n">config_waiting_stamp</span> <span class="o">+</span> <span class="n">AIF_SNIFF_TIMEOUT</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">device_config_needed</span> <span class="o">=</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">fsa_dev</span><span class="p">[</span><span class="n">container</span><span class="p">].</span><span class="n">config_needed</span><span class="p">;</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">fsa_dev</span><span class="p">[</span><span class="n">container</span><span class="p">].</span><span class="n">config_needed</span> <span class="o">=</span> <span class="n">NOTHING</span><span class="p">;</span>
			<span class="n">channel</span> <span class="o">=</span> <span class="n">CONTAINER_TO_CHANNEL</span><span class="p">(</span><span class="n">container</span><span class="p">);</span>
			<span class="n">id</span> <span class="o">=</span> <span class="n">CONTAINER_TO_ID</span><span class="p">(</span><span class="n">container</span><span class="p">);</span>
			<span class="n">lun</span> <span class="o">=</span> <span class="n">CONTAINER_TO_LUN</span><span class="p">(</span><span class="n">container</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">device_config_needed</span> <span class="o">==</span> <span class="n">NOTHING</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *	If we decided that a re-configuration needs to be done,</span>
<span class="cm">	 * schedule it here on the way out the door, please close the door</span>
<span class="cm">	 * behind you.</span>
<span class="cm">	 */</span>

	<span class="cm">/*</span>
<span class="cm">	 *	Find the scsi_device associated with the SCSI address,</span>
<span class="cm">	 * and mark it as changed, invalidating the cache. This deals</span>
<span class="cm">	 * with changes to existing device IDs.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span> <span class="o">||</span> <span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">scsi_host_ptr</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * force reload of disk info via aac_probe_container</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">channel</span> <span class="o">==</span> <span class="n">CONTAINER_CHANNEL</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	  <span class="p">(</span><span class="n">device_config_needed</span> <span class="o">!=</span> <span class="n">NOTHING</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">fsa_dev</span><span class="p">[</span><span class="n">container</span><span class="p">].</span><span class="n">valid</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">fsa_dev</span><span class="p">[</span><span class="n">container</span><span class="p">].</span><span class="n">valid</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">aac_probe_container</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">container</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">device</span> <span class="o">=</span> <span class="n">scsi_device_lookup</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">scsi_host_ptr</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="n">lun</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">device</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">device_config_needed</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">DELETE</span>:
<span class="cp">#if (defined(AAC_DEBUG_INSTRUMENT_AIF_DELETE))</span>
			<span class="n">scsi_remove_device</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
<span class="cp">#else</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">scsi_device_online</span><span class="p">(</span><span class="n">device</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">scsi_device_set_state</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">SDEV_OFFLINE</span><span class="p">);</span>
				<span class="n">sdev_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span>
					<span class="s">&quot;Device offlined - %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="p">(</span><span class="n">channel</span> <span class="o">==</span> <span class="n">CONTAINER_CHANNEL</span><span class="p">)</span> <span class="o">?</span>
						<span class="s">&quot;array deleted&quot;</span> <span class="o">:</span>
						<span class="s">&quot;enclosure services event&quot;</span><span class="p">);</span>
			<span class="p">}</span>
<span class="cp">#endif</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">ADD</span>:
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">scsi_device_online</span><span class="p">(</span><span class="n">device</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">sdev_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span>
					<span class="s">&quot;Device online - %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="p">(</span><span class="n">channel</span> <span class="o">==</span> <span class="n">CONTAINER_CHANNEL</span><span class="p">)</span> <span class="o">?</span>
						<span class="s">&quot;array created&quot;</span> <span class="o">:</span>
						<span class="s">&quot;enclosure services event&quot;</span><span class="p">);</span>
				<span class="n">scsi_device_set_state</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">SDEV_RUNNING</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="cm">/* FALLTHRU */</span>
		<span class="k">case</span> <span class="n">CHANGE</span>:
			<span class="k">if</span> <span class="p">((</span><span class="n">channel</span> <span class="o">==</span> <span class="n">CONTAINER_CHANNEL</span><span class="p">)</span>
			 <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">fsa_dev</span><span class="p">[</span><span class="n">container</span><span class="p">].</span><span class="n">valid</span><span class="p">))</span> <span class="p">{</span>
<span class="cp">#if (defined(AAC_DEBUG_INSTRUMENT_AIF_DELETE))</span>
				<span class="n">scsi_remove_device</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
<span class="cp">#else</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">scsi_device_online</span><span class="p">(</span><span class="n">device</span><span class="p">))</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="n">scsi_device_set_state</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">SDEV_OFFLINE</span><span class="p">);</span>
				<span class="n">sdev_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span>
					<span class="s">&quot;Device offlined - %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="s">&quot;array failed&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">scsi_rescan_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">sdev_gendev</span><span class="p">);</span>

		<span class="nl">default:</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">scsi_device_put</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
		<span class="n">device_config_needed</span> <span class="o">=</span> <span class="n">NOTHING</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">device_config_needed</span> <span class="o">==</span> <span class="n">ADD</span><span class="p">)</span>
		<span class="n">scsi_add_device</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">scsi_host_ptr</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="n">lun</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">channel</span> <span class="o">==</span> <span class="n">CONTAINER_CHANNEL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">container</span><span class="o">++</span><span class="p">;</span>
		<span class="n">device_config_needed</span> <span class="o">=</span> <span class="n">NOTHING</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">retry_next</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">_aac_reset_adapter</span><span class="p">(</span><span class="k">struct</span> <span class="n">aac_dev</span> <span class="o">*</span><span class="n">aac</span><span class="p">,</span> <span class="kt">int</span> <span class="n">forced</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="n">quirks</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">command</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">command_list</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">jafo</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Assumptions:</span>
<span class="cm">	 *	- host is locked, unless called by the aacraid thread.</span>
<span class="cm">	 *	  (a matter of convenience, due to legacy issues surrounding</span>
<span class="cm">	 *	  eh_host_adapter_reset).</span>
<span class="cm">	 *	- in_reset is asserted, so no new i/o is getting to the</span>
<span class="cm">	 *	  card.</span>
<span class="cm">	 *	- The card is dead, or will be very shortly ;-/ so no new</span>
<span class="cm">	 *	  commands are completing in the interrupt service.</span>
<span class="cm">	 */</span>
	<span class="n">host</span> <span class="o">=</span> <span class="n">aac</span><span class="o">-&gt;</span><span class="n">scsi_host_ptr</span><span class="p">;</span>
	<span class="n">scsi_block_requests</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>
	<span class="n">aac_adapter_disable_int</span><span class="p">(</span><span class="n">aac</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">aac</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">!=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="n">kthread_stop</span><span class="p">(</span><span class="n">aac</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">);</span>
		<span class="n">jafo</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *	If a positive health, means in a known DEAD PANIC</span>
<span class="cm">	 * state and the adapter could be reset to `try again&#39;.</span>
<span class="cm">	 */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">aac_adapter_restart</span><span class="p">(</span><span class="n">aac</span><span class="p">,</span> <span class="n">forced</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">aac_adapter_check_health</span><span class="p">(</span><span class="n">aac</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *	Loop through the fibs, close the synchronous FIBS</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">retval</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">aac</span><span class="o">-&gt;</span><span class="n">scsi_host_ptr</span><span class="o">-&gt;</span><span class="n">can_queue</span> <span class="o">+</span> <span class="n">AAC_NUM_MGT_FIB</span><span class="p">);</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">fib</span> <span class="o">*</span><span class="n">fib</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">aac</span><span class="o">-&gt;</span><span class="n">fibs</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">fib</span><span class="o">-&gt;</span><span class="n">hw_fib_va</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">XferState</span> <span class="o">&amp;</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">NoResponseExpected</span> <span class="o">|</span> <span class="n">Async</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
		  <span class="p">(</span><span class="n">fib</span><span class="o">-&gt;</span><span class="n">hw_fib_va</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">XferState</span> <span class="o">&amp;</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">ResponseExpected</span><span class="p">)))</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flagv</span><span class="p">;</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fib</span><span class="o">-&gt;</span><span class="n">event_lock</span><span class="p">,</span> <span class="n">flagv</span><span class="p">);</span>
			<span class="n">up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fib</span><span class="o">-&gt;</span><span class="n">event_wait</span><span class="p">);</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fib</span><span class="o">-&gt;</span><span class="n">event_lock</span><span class="p">,</span> <span class="n">flagv</span><span class="p">);</span>
			<span class="n">schedule</span><span class="p">();</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* Give some extra time for ioctls to complete. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ssleep</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
	<span class="n">index</span> <span class="o">=</span> <span class="n">aac</span><span class="o">-&gt;</span><span class="n">cardtype</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Re-initialize the adapter, first free resources, then carefully</span>
<span class="cm">	 * apply the initialization sequence to come back again. Only risk</span>
<span class="cm">	 * is a change in Firmware dropping cache, it is assumed the caller</span>
<span class="cm">	 * will ensure that i/o is queisced and the card is flushed in that</span>
<span class="cm">	 * case.</span>
<span class="cm">	 */</span>
	<span class="n">aac_fib_map_free</span><span class="p">(</span><span class="n">aac</span><span class="p">);</span>
	<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">aac</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">aac</span><span class="o">-&gt;</span><span class="n">comm_size</span><span class="p">,</span> <span class="n">aac</span><span class="o">-&gt;</span><span class="n">comm_addr</span><span class="p">,</span> <span class="n">aac</span><span class="o">-&gt;</span><span class="n">comm_phys</span><span class="p">);</span>
	<span class="n">aac</span><span class="o">-&gt;</span><span class="n">comm_addr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">aac</span><span class="o">-&gt;</span><span class="n">comm_phys</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">aac</span><span class="o">-&gt;</span><span class="n">queues</span><span class="p">);</span>
	<span class="n">aac</span><span class="o">-&gt;</span><span class="n">queues</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">aac</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">aac</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">aac</span><span class="o">-&gt;</span><span class="n">msi</span><span class="p">)</span>
		<span class="n">pci_disable_msi</span><span class="p">(</span><span class="n">aac</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">aac</span><span class="o">-&gt;</span><span class="n">fsa_dev</span><span class="p">);</span>
	<span class="n">aac</span><span class="o">-&gt;</span><span class="n">fsa_dev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">quirks</span> <span class="o">=</span> <span class="n">aac_get_driver_ident</span><span class="p">(</span><span class="n">index</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">quirks</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">AAC_QUIRK_31BIT</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(((</span><span class="n">retval</span> <span class="o">=</span> <span class="n">pci_set_dma_mask</span><span class="p">(</span><span class="n">aac</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">31</span><span class="p">))))</span> <span class="o">||</span>
		  <span class="p">((</span><span class="n">retval</span> <span class="o">=</span> <span class="n">pci_set_consistent_dma_mask</span><span class="p">(</span><span class="n">aac</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">31</span><span class="p">)))))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(((</span><span class="n">retval</span> <span class="o">=</span> <span class="n">pci_set_dma_mask</span><span class="p">(</span><span class="n">aac</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">32</span><span class="p">))))</span> <span class="o">||</span>
		  <span class="p">((</span><span class="n">retval</span> <span class="o">=</span> <span class="n">pci_set_consistent_dma_mask</span><span class="p">(</span><span class="n">aac</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">32</span><span class="p">)))))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">retval</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">aac_get_driver_ident</span><span class="p">(</span><span class="n">index</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">))(</span><span class="n">aac</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">AAC_QUIRK_31BIT</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">retval</span> <span class="o">=</span> <span class="n">pci_set_dma_mask</span><span class="p">(</span><span class="n">aac</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">32</span><span class="p">))))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">jafo</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">aac</span><span class="o">-&gt;</span><span class="kr">thread</span> <span class="o">=</span> <span class="n">kthread_run</span><span class="p">(</span><span class="n">aac_command_thread</span><span class="p">,</span> <span class="n">aac</span><span class="p">,</span> <span class="n">aac</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">aac</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">aac</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">aac_get_adapter_info</span><span class="p">(</span><span class="n">aac</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">AAC_QUIRK_34SG</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">sg_tablesize</span> <span class="o">&gt;</span> <span class="mi">34</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">host</span><span class="o">-&gt;</span><span class="n">sg_tablesize</span> <span class="o">=</span> <span class="mi">34</span><span class="p">;</span>
		<span class="n">host</span><span class="o">-&gt;</span><span class="n">max_sectors</span> <span class="o">=</span> <span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">sg_tablesize</span> <span class="o">*</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="mi">112</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">AAC_QUIRK_17SG</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">sg_tablesize</span> <span class="o">&gt;</span> <span class="mi">17</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">host</span><span class="o">-&gt;</span><span class="n">sg_tablesize</span> <span class="o">=</span> <span class="mi">17</span><span class="p">;</span>
		<span class="n">host</span><span class="o">-&gt;</span><span class="n">max_sectors</span> <span class="o">=</span> <span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">sg_tablesize</span> <span class="o">*</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="mi">112</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">aac_get_config_status</span><span class="p">(</span><span class="n">aac</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">aac_get_containers</span><span class="p">(</span><span class="n">aac</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * This is where the assumption that the Adapter is quiesced</span>
<span class="cm">	 * is important.</span>
<span class="cm">	 */</span>
	<span class="n">command_list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">__shost_for_each_device</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">host</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">cmd_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">command</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">phase</span> <span class="o">==</span> <span class="n">AAC_OWNER_FIRMWARE</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">command</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">buffer</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="p">)</span><span class="n">command_list</span><span class="p">;</span>
				<span class="n">command_list</span> <span class="o">=</span> <span class="n">command</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">command</span> <span class="o">=</span> <span class="n">command_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">command_list</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="p">)</span><span class="n">command</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">buffer</span><span class="p">;</span>
		<span class="n">command</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">buffer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">command</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_OK</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span>
		  <span class="o">|</span> <span class="n">COMMAND_COMPLETE</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span>
		  <span class="o">|</span> <span class="n">SAM_STAT_TASK_SET_FULL</span><span class="p">;</span>
		<span class="n">command</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">phase</span> <span class="o">=</span> <span class="n">AAC_OWNER_ERROR_HANDLER</span><span class="p">;</span>
		<span class="n">command</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">(</span><span class="n">command</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">aac</span><span class="o">-&gt;</span><span class="n">in_reset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">scsi_unblock_requests</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">jafo</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">aac_reset_adapter</span><span class="p">(</span><span class="k">struct</span> <span class="n">aac_dev</span> <span class="o">*</span> <span class="n">aac</span><span class="p">,</span> <span class="kt">int</span> <span class="n">forced</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flagv</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span> <span class="n">host</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">spin_trylock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aac</span><span class="o">-&gt;</span><span class="n">fib_lock</span><span class="p">,</span> <span class="n">flagv</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">aac</span><span class="o">-&gt;</span><span class="n">in_reset</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aac</span><span class="o">-&gt;</span><span class="n">fib_lock</span><span class="p">,</span> <span class="n">flagv</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">aac</span><span class="o">-&gt;</span><span class="n">in_reset</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aac</span><span class="o">-&gt;</span><span class="n">fib_lock</span><span class="p">,</span> <span class="n">flagv</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Wait for all commands to complete to this specific</span>
<span class="cm">	 * target (block maximum 60 seconds). Although not necessary,</span>
<span class="cm">	 * it does make us a good storage citizen.</span>
<span class="cm">	 */</span>
	<span class="n">host</span> <span class="o">=</span> <span class="n">aac</span><span class="o">-&gt;</span><span class="n">scsi_host_ptr</span><span class="p">;</span>
	<span class="n">scsi_block_requests</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">forced</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">retval</span> <span class="o">=</span> <span class="mi">60</span><span class="p">;</span> <span class="n">retval</span><span class="p">;</span> <span class="o">--</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span> <span class="n">dev</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span> <span class="n">command</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">active</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">__shost_for_each_device</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">host</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">,</span> <span class="n">flagv</span><span class="p">);</span>
			<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">cmd_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">command</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">phase</span> <span class="o">==</span> <span class="n">AAC_OWNER_FIRMWARE</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">active</span><span class="o">++</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">,</span> <span class="n">flagv</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">active</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * We can exit If all the commands are complete</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">active</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">ssleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Quiesce build, flush cache, write through mode */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">forced</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">aac_send_shutdown</span><span class="p">(</span><span class="n">aac</span><span class="p">);</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flagv</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">_aac_reset_adapter</span><span class="p">(</span><span class="n">aac</span><span class="p">,</span> <span class="n">forced</span> <span class="o">?</span> <span class="n">forced</span> <span class="o">:</span> <span class="p">((</span><span class="n">aac_check_reset</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">aac_check_reset</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)));</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flagv</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">forced</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Unwind aac_send_shutdown() IOP_RESET unsupported/disabled */</span>
		<span class="k">struct</span> <span class="n">fib</span> <span class="o">*</span> <span class="n">fibctx</span> <span class="o">=</span> <span class="n">aac_fib_alloc</span><span class="p">(</span><span class="n">aac</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fibctx</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">aac_pause</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

			<span class="n">aac_fib_init</span><span class="p">(</span><span class="n">fibctx</span><span class="p">);</span>

			<span class="n">cmd</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">aac_pause</span> <span class="o">*</span><span class="p">)</span> <span class="n">fib_data</span><span class="p">(</span><span class="n">fibctx</span><span class="p">);</span>

			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">command</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">VM_ContainerConfig</span><span class="p">);</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">CT_PAUSE_IO</span><span class="p">);</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">min</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">noRescan</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

			<span class="n">status</span> <span class="o">=</span> <span class="n">aac_fib_send</span><span class="p">(</span><span class="n">ContainerCommand</span><span class="p">,</span>
			  <span class="n">fibctx</span><span class="p">,</span>
			  <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">aac_pause</span><span class="p">),</span>
			  <span class="n">FsaNormal</span><span class="p">,</span>
			  <span class="o">-</span><span class="mi">2</span> <span class="cm">/* Timeout silently */</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
			  <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">aac_fib_complete</span><span class="p">(</span><span class="n">fibctx</span><span class="p">);</span>
			<span class="cm">/* FIB should be freed only after getting</span>
<span class="cm">			 * the response from the F/W */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ERESTARTSYS</span><span class="p">)</span>
				<span class="n">aac_fib_free</span><span class="p">(</span><span class="n">fibctx</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">aac_check_health</span><span class="p">(</span><span class="k">struct</span> <span class="n">aac_dev</span> <span class="o">*</span> <span class="n">aac</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">BlinkLED</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">time_now</span><span class="p">,</span> <span class="n">flagv</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span> <span class="n">entry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span> <span class="n">host</span><span class="p">;</span>

	<span class="cm">/* Extending the scope of fib_lock slightly to protect aac-&gt;in_reset */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">spin_trylock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aac</span><span class="o">-&gt;</span><span class="n">fib_lock</span><span class="p">,</span> <span class="n">flagv</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">aac</span><span class="o">-&gt;</span><span class="n">in_reset</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">BlinkLED</span> <span class="o">=</span> <span class="n">aac_adapter_check_health</span><span class="p">(</span><span class="n">aac</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aac</span><span class="o">-&gt;</span><span class="n">fib_lock</span><span class="p">,</span> <span class="n">flagv</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* OK */</span>
	<span class="p">}</span>

	<span class="n">aac</span><span class="o">-&gt;</span><span class="n">in_reset</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Fake up an AIF:</span>
<span class="cm">	 *	aac_aifcmd.command = AifCmdEventNotify = 1</span>
<span class="cm">	 *	aac_aifcmd.seqnum = 0xFFFFFFFF</span>
<span class="cm">	 *	aac_aifcmd.data[0] = AifEnExpEvent = 23</span>
<span class="cm">	 *	aac_aifcmd.data[1] = AifExeFirmwarePanic = 3</span>
<span class="cm">	 *	aac.aifcmd.data[2] = AifHighPriority = 3</span>
<span class="cm">	 *	aac.aifcmd.data[3] = BlinkLED</span>
<span class="cm">	 */</span>

	<span class="n">time_now</span> <span class="o">=</span> <span class="n">jiffies</span><span class="o">/</span><span class="n">HZ</span><span class="p">;</span>
	<span class="n">entry</span> <span class="o">=</span> <span class="n">aac</span><span class="o">-&gt;</span><span class="n">fib_list</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * For each Context that is on the</span>
<span class="cm">	 * fibctxList, make a copy of the</span>
<span class="cm">	 * fib, and then set the event to wake up the</span>
<span class="cm">	 * thread that is waiting for it.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">entry</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">aac</span><span class="o">-&gt;</span><span class="n">fib_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Extract the fibctx</span>
<span class="cm">		 */</span>
		<span class="k">struct</span> <span class="n">aac_fib_context</span> <span class="o">*</span><span class="n">fibctx</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">aac_fib_context</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">hw_fib</span> <span class="o">*</span> <span class="n">hw_fib</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">fib</span> <span class="o">*</span> <span class="n">fib</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Check if the queue is getting</span>
<span class="cm">		 * backlogged</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fibctx</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">20</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * It&#39;s *not* jiffies folks,</span>
<span class="cm">			 * but jiffies / HZ, so do not</span>
<span class="cm">			 * panic ...</span>
<span class="cm">			 */</span>
			<span class="n">u32</span> <span class="n">time_last</span> <span class="o">=</span> <span class="n">fibctx</span><span class="o">-&gt;</span><span class="n">jiffies</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * Has it been &gt; 2 minutes</span>
<span class="cm">			 * since the last read off</span>
<span class="cm">			 * the queue?</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">time_now</span> <span class="o">-</span> <span class="n">time_last</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">aif_timeout</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">entry</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
				<span class="n">aac_close_fib_context</span><span class="p">(</span><span class="n">aac</span><span class="p">,</span> <span class="n">fibctx</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * Warning: no sleep allowed while</span>
<span class="cm">		 * holding spinlock</span>
<span class="cm">		 */</span>
		<span class="n">hw_fib</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hw_fib</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="n">fib</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fib</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fib</span> <span class="o">&amp;&amp;</span> <span class="n">hw_fib</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">aac_aifcmd</span> <span class="o">*</span> <span class="n">aif</span><span class="p">;</span>

			<span class="n">fib</span><span class="o">-&gt;</span><span class="n">hw_fib_va</span> <span class="o">=</span> <span class="n">hw_fib</span><span class="p">;</span>
			<span class="n">fib</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">aac</span><span class="p">;</span>
			<span class="n">aac_fib_init</span><span class="p">(</span><span class="n">fib</span><span class="p">);</span>
			<span class="n">fib</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">FSAFS_NTC_FIB_CONTEXT</span><span class="p">;</span>
			<span class="n">fib</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">fib</span><span class="p">);</span>
			<span class="n">fib</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">hw_fib</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
			<span class="n">aif</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">aac_aifcmd</span> <span class="o">*</span><span class="p">)</span><span class="n">hw_fib</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
			<span class="n">aif</span><span class="o">-&gt;</span><span class="n">command</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">AifCmdEventNotify</span><span class="p">);</span>
			<span class="n">aif</span><span class="o">-&gt;</span><span class="n">seqnum</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0xFFFFFFFF</span><span class="p">);</span>
			<span class="p">((</span><span class="n">__le32</span> <span class="o">*</span><span class="p">)</span><span class="n">aif</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">AifEnExpEvent</span><span class="p">);</span>
			<span class="p">((</span><span class="n">__le32</span> <span class="o">*</span><span class="p">)</span><span class="n">aif</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">AifExeFirmwarePanic</span><span class="p">);</span>
			<span class="p">((</span><span class="n">__le32</span> <span class="o">*</span><span class="p">)</span><span class="n">aif</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">AifHighPriority</span><span class="p">);</span>
			<span class="p">((</span><span class="n">__le32</span> <span class="o">*</span><span class="p">)</span><span class="n">aif</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">BlinkLED</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * Put the FIB onto the</span>
<span class="cm">			 * fibctx&#39;s fibs</span>
<span class="cm">			 */</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fib</span><span class="o">-&gt;</span><span class="n">fiblink</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fibctx</span><span class="o">-&gt;</span><span class="n">fib_list</span><span class="p">);</span>
			<span class="n">fibctx</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">++</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * Set the event to wake up the</span>
<span class="cm">			 * thread that will waiting.</span>
<span class="cm">			 */</span>
			<span class="n">up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fibctx</span><span class="o">-&gt;</span><span class="n">wait_sem</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;aifd: didn&#39;t allocate NewFib.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">fib</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">hw_fib</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aac</span><span class="o">-&gt;</span><span class="n">fib_lock</span><span class="p">,</span> <span class="n">flagv</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">BlinkLED</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: Host adapter dead %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">aac</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">BlinkLED</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: Host adapter BLINK LED 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">aac</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">BlinkLED</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">aac_check_reset</span> <span class="o">||</span> <span class="p">((</span><span class="n">aac_check_reset</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="n">aac</span><span class="o">-&gt;</span><span class="n">supplement_adapter_info</span><span class="p">.</span><span class="n">SupportedOptions2</span> <span class="o">&amp;</span>
			<span class="n">AAC_OPTION_IGNORE_RESET</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">host</span> <span class="o">=</span> <span class="n">aac</span><span class="o">-&gt;</span><span class="n">scsi_host_ptr</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">aac</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">!=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">)</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flagv</span><span class="p">);</span>
	<span class="n">BlinkLED</span> <span class="o">=</span> <span class="n">_aac_reset_adapter</span><span class="p">(</span><span class="n">aac</span><span class="p">,</span> <span class="n">aac_check_reset</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">aac</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">!=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">)</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flagv</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">BlinkLED</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">aac</span><span class="o">-&gt;</span><span class="n">in_reset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">BlinkLED</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> *	aac_command_thread	-	command processing thread</span>
<span class="cm"> *	@dev: Adapter to monitor</span>
<span class="cm"> *</span>
<span class="cm"> *	Waits on the commandready event in it&#39;s queue. When the event gets set</span>
<span class="cm"> *	it will pull FIBs off it&#39;s queue. It will continue to pull FIBs off</span>
<span class="cm"> *	until the queue is empty. When the queue is empty it will wait for</span>
<span class="cm"> *	more FIBs.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">aac_command_thread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">aac_dev</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hw_fib</span> <span class="o">*</span><span class="n">hw_fib</span><span class="p">,</span> <span class="o">*</span><span class="n">hw_newfib</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fib</span> <span class="o">*</span><span class="n">fib</span><span class="p">,</span> <span class="o">*</span><span class="n">newfib</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">aac_fib_context</span> <span class="o">*</span><span class="n">fibctx</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">DECLARE_WAITQUEUE</span><span class="p">(</span><span class="n">wait</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">next_jiffies</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">HZ</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">next_check_jiffies</span> <span class="o">=</span> <span class="n">next_jiffies</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">difference</span> <span class="o">=</span> <span class="n">HZ</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *	We can only have one thread per adapter for AIF&#39;s.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">aif_thread</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *	Let the DPC know it has a place to send the AIF&#39;s to.</span>
<span class="cm">	 */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">aif_thread</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">add_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">queues</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">[</span><span class="n">HostNormCmdQueue</span><span class="p">].</span><span class="n">cmdready</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
	<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
	<span class="n">dprintk</span> <span class="p">((</span><span class="n">KERN_INFO</span> <span class="s">&quot;aac_command_thread start</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">queues</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">[</span><span class="n">HostNormCmdQueue</span><span class="p">].</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">queues</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">[</span><span class="n">HostNormCmdQueue</span><span class="p">].</span><span class="n">cmdq</span><span class="p">)))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">aac_aifcmd</span> <span class="o">*</span> <span class="n">aifcmd</span><span class="p">;</span>

			<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span>

			<span class="n">entry</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">queues</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">[</span><span class="n">HostNormCmdQueue</span><span class="p">].</span><span class="n">cmdq</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
			<span class="n">list_del</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>

			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">queues</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">[</span><span class="n">HostNormCmdQueue</span><span class="p">].</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">fib</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fib</span><span class="p">,</span> <span class="n">fiblink</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 *	We will process the FIB here or pass it to a</span>
<span class="cm">			 *	worker thread that is TBD. We Really can&#39;t</span>
<span class="cm">			 *	do anything at this point since we don&#39;t have</span>
<span class="cm">			 *	anything defined for this thread to do.</span>
<span class="cm">			 */</span>
			<span class="n">hw_fib</span> <span class="o">=</span> <span class="n">fib</span><span class="o">-&gt;</span><span class="n">hw_fib_va</span><span class="p">;</span>
			<span class="n">memset</span><span class="p">(</span><span class="n">fib</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fib</span><span class="p">));</span>
			<span class="n">fib</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">FSAFS_NTC_FIB_CONTEXT</span><span class="p">;</span>
			<span class="n">fib</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fib</span><span class="p">);</span>
			<span class="n">fib</span><span class="o">-&gt;</span><span class="n">hw_fib_va</span> <span class="o">=</span> <span class="n">hw_fib</span><span class="p">;</span>
			<span class="n">fib</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">hw_fib</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
			<span class="n">fib</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 *	We only handle AifRequest fibs from the adapter.</span>
<span class="cm">			 */</span>
			<span class="n">aifcmd</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">aac_aifcmd</span> <span class="o">*</span><span class="p">)</span> <span class="n">hw_fib</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">aifcmd</span><span class="o">-&gt;</span><span class="n">command</span> <span class="o">==</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">AifCmdDriverNotify</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* Handle Driver Notify Events */</span>
				<span class="n">aac_handle_aif</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">fib</span><span class="p">);</span>
				<span class="o">*</span><span class="p">(</span><span class="n">__le32</span> <span class="o">*</span><span class="p">)</span><span class="n">hw_fib</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">ST_OK</span><span class="p">);</span>
				<span class="n">aac_fib_adapter_complete</span><span class="p">(</span><span class="n">fib</span><span class="p">,</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">));</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* The u32 here is important and intended. We are using</span>
<span class="cm">				   32bit wrapping time to fit the adapter field */</span>

				<span class="n">u32</span> <span class="n">time_now</span><span class="p">,</span> <span class="n">time_last</span><span class="p">;</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flagv</span><span class="p">;</span>
				<span class="kt">unsigned</span> <span class="n">num</span><span class="p">;</span>
				<span class="k">struct</span> <span class="n">hw_fib</span> <span class="o">**</span> <span class="n">hw_fib_pool</span><span class="p">,</span> <span class="o">**</span> <span class="n">hw_fib_p</span><span class="p">;</span>
				<span class="k">struct</span> <span class="n">fib</span> <span class="o">**</span> <span class="n">fib_pool</span><span class="p">,</span> <span class="o">**</span> <span class="n">fib_p</span><span class="p">;</span>

				<span class="cm">/* Sniff events */</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">aifcmd</span><span class="o">-&gt;</span><span class="n">command</span> <span class="o">==</span>
				     <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">AifCmdEventNotify</span><span class="p">))</span> <span class="o">||</span>
				    <span class="p">(</span><span class="n">aifcmd</span><span class="o">-&gt;</span><span class="n">command</span> <span class="o">==</span>
				     <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">AifCmdJobProgress</span><span class="p">)))</span> <span class="p">{</span>
					<span class="n">aac_handle_aif</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">fib</span><span class="p">);</span>
				<span class="p">}</span>

				<span class="n">time_now</span> <span class="o">=</span> <span class="n">jiffies</span><span class="o">/</span><span class="n">HZ</span><span class="p">;</span>

				<span class="cm">/*</span>
<span class="cm">				 * Warning: no sleep allowed while</span>
<span class="cm">				 * holding spinlock. We take the estimate</span>
<span class="cm">				 * and pre-allocate a set of fibs outside the</span>
<span class="cm">				 * lock.</span>
<span class="cm">				 */</span>
				<span class="n">num</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">init</span><span class="o">-&gt;</span><span class="n">AdapterFibsSize</span><span class="p">)</span>
				    <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hw_fib</span><span class="p">);</span> <span class="cm">/* some extra */</span>
				<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">fib_lock</span><span class="p">,</span> <span class="n">flagv</span><span class="p">);</span>
				<span class="n">entry</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">fib_list</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
				<span class="k">while</span> <span class="p">(</span><span class="n">entry</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">fib_list</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">entry</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
					<span class="o">++</span><span class="n">num</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">fib_lock</span><span class="p">,</span> <span class="n">flagv</span><span class="p">);</span>
				<span class="n">hw_fib_pool</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="n">fib_pool</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">num</span>
				 <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">hw_fib_pool</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hw_fib</span> <span class="o">*</span><span class="p">)</span> <span class="o">*</span> <span class="n">num</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">)))</span>
				 <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">fib_pool</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fib</span> <span class="o">*</span><span class="p">)</span> <span class="o">*</span> <span class="n">num</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))))</span> <span class="p">{</span>
					<span class="n">hw_fib_p</span> <span class="o">=</span> <span class="n">hw_fib_pool</span><span class="p">;</span>
					<span class="n">fib_p</span> <span class="o">=</span> <span class="n">fib_pool</span><span class="p">;</span>
					<span class="k">while</span> <span class="p">(</span><span class="n">hw_fib_p</span> <span class="o">&lt;</span> <span class="o">&amp;</span><span class="n">hw_fib_pool</span><span class="p">[</span><span class="n">num</span><span class="p">])</span> <span class="p">{</span>
						<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">hw_fib_p</span><span class="o">++</span><span class="p">)</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hw_fib</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">)))</span> <span class="p">{</span>
							<span class="o">--</span><span class="n">hw_fib_p</span><span class="p">;</span>
							<span class="k">break</span><span class="p">;</span>
						<span class="p">}</span>
						<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">fib_p</span><span class="o">++</span><span class="p">)</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fib</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">)))</span> <span class="p">{</span>
							<span class="n">kfree</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="o">--</span><span class="n">hw_fib_p</span><span class="p">));</span>
							<span class="k">break</span><span class="p">;</span>
						<span class="p">}</span>
					<span class="p">}</span>
					<span class="k">if</span> <span class="p">((</span><span class="n">num</span> <span class="o">=</span> <span class="n">hw_fib_p</span> <span class="o">-</span> <span class="n">hw_fib_pool</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">kfree</span><span class="p">(</span><span class="n">fib_pool</span><span class="p">);</span>
						<span class="n">fib_pool</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
						<span class="n">kfree</span><span class="p">(</span><span class="n">hw_fib_pool</span><span class="p">);</span>
						<span class="n">hw_fib_pool</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
					<span class="p">}</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">kfree</span><span class="p">(</span><span class="n">hw_fib_pool</span><span class="p">);</span>
					<span class="n">hw_fib_pool</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">fib_lock</span><span class="p">,</span> <span class="n">flagv</span><span class="p">);</span>
				<span class="n">entry</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">fib_list</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
				<span class="cm">/*</span>
<span class="cm">				 * For each Context that is on the</span>
<span class="cm">				 * fibctxList, make a copy of the</span>
<span class="cm">				 * fib, and then set the event to wake up the</span>
<span class="cm">				 * thread that is waiting for it.</span>
<span class="cm">				 */</span>
				<span class="n">hw_fib_p</span> <span class="o">=</span> <span class="n">hw_fib_pool</span><span class="p">;</span>
				<span class="n">fib_p</span> <span class="o">=</span> <span class="n">fib_pool</span><span class="p">;</span>
				<span class="k">while</span> <span class="p">(</span><span class="n">entry</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">fib_list</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/*</span>
<span class="cm">					 * Extract the fibctx</span>
<span class="cm">					 */</span>
					<span class="n">fibctx</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">aac_fib_context</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
					<span class="cm">/*</span>
<span class="cm">					 * Check if the queue is getting</span>
<span class="cm">					 * backlogged</span>
<span class="cm">					 */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">fibctx</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">20</span><span class="p">)</span>
					<span class="p">{</span>
						<span class="cm">/*</span>
<span class="cm">						 * It&#39;s *not* jiffies folks,</span>
<span class="cm">						 * but jiffies / HZ so do not</span>
<span class="cm">						 * panic ...</span>
<span class="cm">						 */</span>
						<span class="n">time_last</span> <span class="o">=</span> <span class="n">fibctx</span><span class="o">-&gt;</span><span class="n">jiffies</span><span class="p">;</span>
						<span class="cm">/*</span>
<span class="cm">						 * Has it been &gt; 2 minutes</span>
<span class="cm">						 * since the last read off</span>
<span class="cm">						 * the queue?</span>
<span class="cm">						 */</span>
						<span class="k">if</span> <span class="p">((</span><span class="n">time_now</span> <span class="o">-</span> <span class="n">time_last</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">aif_timeout</span><span class="p">)</span> <span class="p">{</span>
							<span class="n">entry</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
							<span class="n">aac_close_fib_context</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">fibctx</span><span class="p">);</span>
							<span class="k">continue</span><span class="p">;</span>
						<span class="p">}</span>
					<span class="p">}</span>
					<span class="cm">/*</span>
<span class="cm">					 * Warning: no sleep allowed while</span>
<span class="cm">					 * holding spinlock</span>
<span class="cm">					 */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">hw_fib_p</span> <span class="o">&lt;</span> <span class="o">&amp;</span><span class="n">hw_fib_pool</span><span class="p">[</span><span class="n">num</span><span class="p">])</span> <span class="p">{</span>
						<span class="n">hw_newfib</span> <span class="o">=</span> <span class="o">*</span><span class="n">hw_fib_p</span><span class="p">;</span>
						<span class="o">*</span><span class="p">(</span><span class="n">hw_fib_p</span><span class="o">++</span><span class="p">)</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
						<span class="n">newfib</span> <span class="o">=</span> <span class="o">*</span><span class="n">fib_p</span><span class="p">;</span>
						<span class="o">*</span><span class="p">(</span><span class="n">fib_p</span><span class="o">++</span><span class="p">)</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
						<span class="cm">/*</span>
<span class="cm">						 * Make the copy of the FIB</span>
<span class="cm">						 */</span>
						<span class="n">memcpy</span><span class="p">(</span><span class="n">hw_newfib</span><span class="p">,</span> <span class="n">hw_fib</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hw_fib</span><span class="p">));</span>
						<span class="n">memcpy</span><span class="p">(</span><span class="n">newfib</span><span class="p">,</span> <span class="n">fib</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fib</span><span class="p">));</span>
						<span class="n">newfib</span><span class="o">-&gt;</span><span class="n">hw_fib_va</span> <span class="o">=</span> <span class="n">hw_newfib</span><span class="p">;</span>
						<span class="cm">/*</span>
<span class="cm">						 * Put the FIB onto the</span>
<span class="cm">						 * fibctx&#39;s fibs</span>
<span class="cm">						 */</span>
						<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newfib</span><span class="o">-&gt;</span><span class="n">fiblink</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fibctx</span><span class="o">-&gt;</span><span class="n">fib_list</span><span class="p">);</span>
						<span class="n">fibctx</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">++</span><span class="p">;</span>
						<span class="cm">/*</span>
<span class="cm">						 * Set the event to wake up the</span>
<span class="cm">						 * thread that is waiting.</span>
<span class="cm">						 */</span>
						<span class="n">up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fibctx</span><span class="o">-&gt;</span><span class="n">wait_sem</span><span class="p">);</span>
					<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
						<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;aifd: didn&#39;t allocate NewFib.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
					<span class="p">}</span>
					<span class="n">entry</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="cm">/*</span>
<span class="cm">				 *	Set the status of this FIB</span>
<span class="cm">				 */</span>
				<span class="o">*</span><span class="p">(</span><span class="n">__le32</span> <span class="o">*</span><span class="p">)</span><span class="n">hw_fib</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">ST_OK</span><span class="p">);</span>
				<span class="n">aac_fib_adapter_complete</span><span class="p">(</span><span class="n">fib</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">));</span>
				<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">fib_lock</span><span class="p">,</span> <span class="n">flagv</span><span class="p">);</span>
				<span class="cm">/* Free up the remaining resources */</span>
				<span class="n">hw_fib_p</span> <span class="o">=</span> <span class="n">hw_fib_pool</span><span class="p">;</span>
				<span class="n">fib_p</span> <span class="o">=</span> <span class="n">fib_pool</span><span class="p">;</span>
				<span class="k">while</span> <span class="p">(</span><span class="n">hw_fib_p</span> <span class="o">&lt;</span> <span class="o">&amp;</span><span class="n">hw_fib_pool</span><span class="p">[</span><span class="n">num</span><span class="p">])</span> <span class="p">{</span>
					<span class="n">kfree</span><span class="p">(</span><span class="o">*</span><span class="n">hw_fib_p</span><span class="p">);</span>
					<span class="n">kfree</span><span class="p">(</span><span class="o">*</span><span class="n">fib_p</span><span class="p">);</span>
					<span class="o">++</span><span class="n">fib_p</span><span class="p">;</span>
					<span class="o">++</span><span class="n">hw_fib_p</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">hw_fib_pool</span><span class="p">);</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">fib_pool</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">fib</span><span class="p">);</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">queues</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">[</span><span class="n">HostNormCmdQueue</span><span class="p">].</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 *	There are no more AIF&#39;s</span>
<span class="cm">		 */</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">queues</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">[</span><span class="n">HostNormCmdQueue</span><span class="p">].</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 *	Background activity</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">time_before</span><span class="p">(</span><span class="n">next_check_jiffies</span><span class="p">,</span><span class="n">next_jiffies</span><span class="p">))</span>
		 <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">difference</span> <span class="o">=</span> <span class="n">next_check_jiffies</span> <span class="o">-</span> <span class="n">jiffies</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">next_check_jiffies</span> <span class="o">=</span> <span class="n">next_jiffies</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">aac_check_health</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">difference</span> <span class="o">=</span> <span class="p">((</span><span class="kt">long</span><span class="p">)(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">check_interval</span><span class="p">)</span>
					   <span class="o">*</span> <span class="n">HZ</span><span class="p">;</span>
				<span class="n">next_check_jiffies</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">difference</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">queues</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">time_before</span><span class="p">(</span><span class="n">next_check_jiffies</span><span class="p">,</span><span class="n">next_jiffies</span><span class="p">)</span>
		 <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">difference</span> <span class="o">=</span> <span class="n">next_jiffies</span> <span class="o">-</span> <span class="n">jiffies</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">timeval</span> <span class="n">now</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

			<span class="cm">/* Don&#39;t even try to talk to adapter if its sick */</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">aac_check_health</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">queues</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">next_check_jiffies</span> <span class="o">=</span> <span class="n">jiffies</span>
					   <span class="o">+</span> <span class="p">((</span><span class="kt">long</span><span class="p">)(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">check_interval</span><span class="p">)</span>
					   <span class="o">*</span> <span class="n">HZ</span><span class="p">;</span>
			<span class="n">do_gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">now</span><span class="p">);</span>

			<span class="cm">/* Synchronize our watches */</span>
			<span class="k">if</span> <span class="p">(((</span><span class="mi">1000000</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1000000</span> <span class="o">/</span> <span class="n">HZ</span><span class="p">))</span> <span class="o">&gt;</span> <span class="n">now</span><span class="p">.</span><span class="n">tv_usec</span><span class="p">)</span>
			 <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">now</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">1000000</span> <span class="o">/</span> <span class="n">HZ</span><span class="p">)))</span>
				<span class="n">difference</span> <span class="o">=</span> <span class="p">(((</span><span class="mi">1000000</span> <span class="o">-</span> <span class="n">now</span><span class="p">.</span><span class="n">tv_usec</span><span class="p">)</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">)</span>
				  <span class="o">+</span> <span class="mi">500000</span><span class="p">)</span> <span class="o">/</span> <span class="mi">1000000</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">struct</span> <span class="n">fib</span> <span class="o">*</span><span class="n">fibptr</span><span class="p">;</span>

				<span class="k">if</span> <span class="p">((</span><span class="n">fibptr</span> <span class="o">=</span> <span class="n">aac_fib_alloc</span><span class="p">(</span><span class="n">dev</span><span class="p">)))</span> <span class="p">{</span>
					<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
					<span class="n">__le32</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>

					<span class="n">aac_fib_init</span><span class="p">(</span><span class="n">fibptr</span><span class="p">);</span>

					<span class="n">info</span> <span class="o">=</span> <span class="p">(</span><span class="n">__le32</span> <span class="o">*</span><span class="p">)</span> <span class="n">fib_data</span><span class="p">(</span><span class="n">fibptr</span><span class="p">);</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">now</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">&gt;</span> <span class="mi">500000</span><span class="p">)</span>
						<span class="o">++</span><span class="n">now</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">;</span>

					<span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">now</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">);</span>

					<span class="n">status</span> <span class="o">=</span> <span class="n">aac_fib_send</span><span class="p">(</span><span class="n">SendHostTime</span><span class="p">,</span>
						<span class="n">fibptr</span><span class="p">,</span>
						<span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">info</span><span class="p">),</span>
						<span class="n">FsaNormal</span><span class="p">,</span>
						<span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
						<span class="nb">NULL</span><span class="p">,</span>
						<span class="nb">NULL</span><span class="p">);</span>
					<span class="cm">/* Do not set XferState to zero unless</span>
<span class="cm">					 * receives a response from F/W */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
						<span class="n">aac_fib_complete</span><span class="p">(</span><span class="n">fibptr</span><span class="p">);</span>
					<span class="cm">/* FIB should be freed only after</span>
<span class="cm">					 * getting the response from the F/W */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ERESTARTSYS</span><span class="p">)</span>
						<span class="n">aac_fib_free</span><span class="p">(</span><span class="n">fibptr</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="n">difference</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">update_interval</span><span class="o">*</span><span class="n">HZ</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* retry shortly */</span>
				<span class="n">difference</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">next_jiffies</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">difference</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">time_before</span><span class="p">(</span><span class="n">next_check_jiffies</span><span class="p">,</span><span class="n">next_jiffies</span><span class="p">))</span>
				<span class="n">difference</span> <span class="o">=</span> <span class="n">next_check_jiffies</span> <span class="o">-</span> <span class="n">jiffies</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">difference</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">difference</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
		<span class="n">schedule_timeout</span><span class="p">(</span><span class="n">difference</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">kthread_should_stop</span><span class="p">())</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">queues</span><span class="p">)</span>
		<span class="n">remove_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">queues</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">[</span><span class="n">HostNormCmdQueue</span><span class="p">].</span><span class="n">cmdready</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">aif_thread</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
