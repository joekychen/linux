<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › scsi › aacraid › aacraid.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>aacraid.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef dprintk</span>
<span class="cp"># define dprintk(x)</span>
<span class="cp">#endif</span>
<span class="cm">/* eg: if (nblank(dprintk(x))) */</span>
<span class="cp">#define _nblank(x) #x</span>
<span class="cp">#define nblank(x) _nblank(x)[0]</span>

<span class="cp">#include &lt;linux/interrupt.h&gt;</span>

<span class="cm">/*------------------------------------------------------------------------------</span>
<span class="cm"> *              D E F I N E S</span>
<span class="cm"> *----------------------------------------------------------------------------*/</span>

<span class="cp">#ifndef AAC_DRIVER_BUILD</span>
<span class="cp"># define AAC_DRIVER_BUILD 28900</span>
<span class="cp"># define AAC_DRIVER_BRANCH &quot;-ms&quot;</span>
<span class="cp">#endif</span>
<span class="cp">#define MAXIMUM_NUM_CONTAINERS	32</span>

<span class="cp">#define AAC_NUM_MGT_FIB         8</span>
<span class="cp">#define AAC_NUM_IO_FIB		(512 - AAC_NUM_MGT_FIB)</span>
<span class="cp">#define AAC_NUM_FIB		(AAC_NUM_IO_FIB + AAC_NUM_MGT_FIB)</span>

<span class="cp">#define AAC_MAX_LUN		(8)</span>

<span class="cp">#define AAC_MAX_HOSTPHYSMEMPAGES (0xfffff)</span>
<span class="cp">#define AAC_MAX_32BIT_SGBCOUNT	((unsigned short)256)</span>

<span class="cp">#define AAC_DEBUG_INSTRUMENT_AIF_DELETE</span>

<span class="cm">/*</span>
<span class="cm"> * These macros convert from physical channels to virtual channels</span>
<span class="cm"> */</span>
<span class="cp">#define CONTAINER_CHANNEL		(0)</span>
<span class="cp">#define CONTAINER_TO_CHANNEL(cont)	(CONTAINER_CHANNEL)</span>
<span class="cp">#define CONTAINER_TO_ID(cont)		(cont)</span>
<span class="cp">#define CONTAINER_TO_LUN(cont)		(0)</span>

<span class="cp">#define aac_phys_to_logical(x)  ((x)+1)</span>
<span class="cp">#define aac_logical_to_phys(x)  ((x)?(x)-1:0)</span>

<span class="cm">/* #define AAC_DETAILED_STATUS_INFO */</span>

<span class="k">struct</span> <span class="n">diskparm</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">heads</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sectors</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cylinders</span><span class="p">;</span>
<span class="p">};</span>


<span class="cm">/*</span>
<span class="cm"> *	Firmware constants</span>
<span class="cm"> */</span>

<span class="cp">#define		CT_NONE			0</span>
<span class="cp">#define		CT_OK			218</span>
<span class="cp">#define		FT_FILESYS	8	</span><span class="cm">/* ADAPTEC&#39;s &quot;FSA&quot;(tm) filesystem */</span><span class="cp"></span>
<span class="cp">#define		FT_DRIVE	9	</span><span class="cm">/* physical disk - addressable in scsi by bus/id/lun */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> *	Host side memory scatter gather list</span>
<span class="cm"> *	Used by the adapter for read, write, and readdirplus operations</span>
<span class="cm"> *	We have separate 32 and 64 bit version because even</span>
<span class="cm"> *	on 64 bit systems not all cards support the 64 bit version</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sgentry</span> <span class="p">{</span>
	<span class="n">__le32</span>	<span class="n">addr</span><span class="p">;</span>	<span class="cm">/* 32-bit address. */</span>
	<span class="n">__le32</span>	<span class="n">count</span><span class="p">;</span>	<span class="cm">/* Length. */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">user_sgentry</span> <span class="p">{</span>
	<span class="n">u32</span>	<span class="n">addr</span><span class="p">;</span>	<span class="cm">/* 32-bit address. */</span>
	<span class="n">u32</span>	<span class="n">count</span><span class="p">;</span>	<span class="cm">/* Length. */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">sgentry64</span> <span class="p">{</span>
	<span class="n">__le32</span>	<span class="n">addr</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>	<span class="cm">/* 64-bit addr. 2 pieces for data alignment */</span>
	<span class="n">__le32</span>	<span class="n">count</span><span class="p">;</span>	<span class="cm">/* Length. */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">user_sgentry64</span> <span class="p">{</span>
	<span class="n">u32</span>	<span class="n">addr</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>	<span class="cm">/* 64-bit addr. 2 pieces for data alignment */</span>
	<span class="n">u32</span>	<span class="n">count</span><span class="p">;</span>	<span class="cm">/* Length. */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">sgentryraw</span> <span class="p">{</span>
	<span class="n">__le32</span>		<span class="n">next</span><span class="p">;</span>	<span class="cm">/* reserved for F/W use */</span>
	<span class="n">__le32</span>		<span class="n">prev</span><span class="p">;</span>	<span class="cm">/* reserved for F/W use */</span>
	<span class="n">__le32</span>		<span class="n">addr</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="n">__le32</span>		<span class="n">count</span><span class="p">;</span>
	<span class="n">__le32</span>		<span class="n">flags</span><span class="p">;</span>	<span class="cm">/* reserved for F/W use */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">user_sgentryraw</span> <span class="p">{</span>
	<span class="n">u32</span>		<span class="n">next</span><span class="p">;</span>	<span class="cm">/* reserved for F/W use */</span>
	<span class="n">u32</span>		<span class="n">prev</span><span class="p">;</span>	<span class="cm">/* reserved for F/W use */</span>
	<span class="n">u32</span>		<span class="n">addr</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="n">u32</span>		<span class="n">count</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="n">flags</span><span class="p">;</span>	<span class="cm">/* reserved for F/W use */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *	SGMAP</span>
<span class="cm"> *</span>
<span class="cm"> *	This is the SGMAP structure for all commands that use</span>
<span class="cm"> *	32-bit addressing.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">sgmap</span> <span class="p">{</span>
	<span class="n">__le32</span>		<span class="n">count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sgentry</span>	<span class="n">sg</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">user_sgmap</span> <span class="p">{</span>
	<span class="n">u32</span>		<span class="n">count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">user_sgentry</span>	<span class="n">sg</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">sgmap64</span> <span class="p">{</span>
	<span class="n">__le32</span>		<span class="n">count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sgentry64</span> <span class="n">sg</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">user_sgmap64</span> <span class="p">{</span>
	<span class="n">u32</span>		<span class="n">count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">user_sgentry64</span> <span class="n">sg</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">sgmapraw</span> <span class="p">{</span>
	<span class="n">__le32</span>		  <span class="n">count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sgentryraw</span> <span class="n">sg</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">user_sgmapraw</span> <span class="p">{</span>
	<span class="n">u32</span>		  <span class="n">count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">user_sgentryraw</span> <span class="n">sg</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">creation_info</span>
<span class="p">{</span>
	<span class="n">u8</span>		<span class="n">buildnum</span><span class="p">;</span>		<span class="cm">/* e.g., 588 */</span>
	<span class="n">u8</span>		<span class="n">usec</span><span class="p">;</span>			<span class="cm">/* e.g., 588 */</span>
	<span class="n">u8</span>		<span class="n">via</span><span class="p">;</span>			<span class="cm">/* e.g., 1 = FSU,</span>
<span class="cm">						 *	 2 = API</span>
<span class="cm">						 */</span>
	<span class="n">u8</span>		<span class="n">year</span><span class="p">;</span>			<span class="cm">/* e.g., 1997 = 97 */</span>
	<span class="n">__le32</span>		<span class="n">date</span><span class="p">;</span>			<span class="cm">/*</span>
<span class="cm">						 * unsigned	Month		:4;	// 1 - 12</span>
<span class="cm">						 * unsigned	Day		:6;	// 1 - 32</span>
<span class="cm">						 * unsigned	Hour		:6;	// 0 - 23</span>
<span class="cm">						 * unsigned	Minute		:6;	// 0 - 60</span>
<span class="cm">						 * unsigned	Second		:6;	// 0 - 60</span>
<span class="cm">						 */</span>
	<span class="n">__le32</span>		<span class="n">serial</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>			<span class="cm">/* e.g., 0x1DEADB0BFAFAF001 */</span>
<span class="p">};</span>


<span class="cm">/*</span>
<span class="cm"> *	Define all the constants needed for the communication interface</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> *	Define how many queue entries each queue will have and the total</span>
<span class="cm"> *	number of entries for the entire communication interface. Also define</span>
<span class="cm"> *	how many queues we support.</span>
<span class="cm"> *</span>
<span class="cm"> *	This has to match the controller</span>
<span class="cm"> */</span>

<span class="cp">#define NUMBER_OF_COMM_QUEUES  8   </span><span class="c1">// 4 command; 4 response</span>
<span class="cp">#define HOST_HIGH_CMD_ENTRIES  4</span>
<span class="cp">#define HOST_NORM_CMD_ENTRIES  8</span>
<span class="cp">#define ADAP_HIGH_CMD_ENTRIES  4</span>
<span class="cp">#define ADAP_NORM_CMD_ENTRIES  512</span>
<span class="cp">#define HOST_HIGH_RESP_ENTRIES 4</span>
<span class="cp">#define HOST_NORM_RESP_ENTRIES 512</span>
<span class="cp">#define ADAP_HIGH_RESP_ENTRIES 4</span>
<span class="cp">#define ADAP_NORM_RESP_ENTRIES 8</span>

<span class="cp">#define TOTAL_QUEUE_ENTRIES  \</span>
<span class="cp">    (HOST_NORM_CMD_ENTRIES + HOST_HIGH_CMD_ENTRIES + ADAP_NORM_CMD_ENTRIES + ADAP_HIGH_CMD_ENTRIES + \</span>
<span class="cp">	    HOST_NORM_RESP_ENTRIES + HOST_HIGH_RESP_ENTRIES + ADAP_NORM_RESP_ENTRIES + ADAP_HIGH_RESP_ENTRIES)</span>


<span class="cm">/*</span>
<span class="cm"> *	Set the queues on a 16 byte alignment</span>
<span class="cm"> */</span>

<span class="cp">#define QUEUE_ALIGNMENT		16</span>

<span class="cm">/*</span>
<span class="cm"> *	The queue headers define the Communication Region queues. These</span>
<span class="cm"> *	are physically contiguous and accessible by both the adapter and the</span>
<span class="cm"> *	host. Even though all queue headers are in the same contiguous block</span>
<span class="cm"> *	they will be represented as individual units in the data structures.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">aac_entry</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">size</span><span class="p">;</span> <span class="cm">/* Size in bytes of Fib which this QE points to */</span>
	<span class="n">__le32</span> <span class="n">addr</span><span class="p">;</span> <span class="cm">/* Receiver address of the FIB */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *	The adapter assumes the ProducerIndex and ConsumerIndex are grouped</span>
<span class="cm"> *	adjacently and in that order.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">aac_qhdr</span> <span class="p">{</span>
	<span class="n">__le64</span> <span class="n">header_addr</span><span class="p">;</span><span class="cm">/* Address to hand the adapter to access</span>
<span class="cm">			      to this queue head */</span>
	<span class="n">__le32</span> <span class="o">*</span><span class="n">producer</span><span class="p">;</span> <span class="cm">/* The producer index for this queue (host address) */</span>
	<span class="n">__le32</span> <span class="o">*</span><span class="n">consumer</span><span class="p">;</span> <span class="cm">/* The consumer index for this queue (host address) */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *	Define all the events which the adapter would like to notify</span>
<span class="cm"> *	the host of.</span>
<span class="cm"> */</span>

<span class="cp">#define		HostNormCmdQue		1	</span><span class="cm">/* Change in host normal priority command queue */</span><span class="cp"></span>
<span class="cp">#define		HostHighCmdQue		2	</span><span class="cm">/* Change in host high priority command queue */</span><span class="cp"></span>
<span class="cp">#define		HostNormRespQue		3	</span><span class="cm">/* Change in host normal priority response queue */</span><span class="cp"></span>
<span class="cp">#define		HostHighRespQue		4	</span><span class="cm">/* Change in host high priority response queue */</span><span class="cp"></span>
<span class="cp">#define		AdapNormRespNotFull	5</span>
<span class="cp">#define		AdapHighRespNotFull	6</span>
<span class="cp">#define		AdapNormCmdNotFull	7</span>
<span class="cp">#define		AdapHighCmdNotFull	8</span>
<span class="cp">#define		SynchCommandComplete	9</span>
<span class="cp">#define		AdapInternalError	0xfe    </span><span class="cm">/* The adapter detected an internal error shutting down */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> *	Define all the events the host wishes to notify the</span>
<span class="cm"> *	adapter of. The first four values much match the Qid the</span>
<span class="cm"> *	corresponding queue.</span>
<span class="cm"> */</span>

<span class="cp">#define		AdapNormCmdQue		2</span>
<span class="cp">#define		AdapHighCmdQue		3</span>
<span class="cp">#define		AdapNormRespQue		6</span>
<span class="cp">#define		AdapHighRespQue		7</span>
<span class="cp">#define		HostShutdown		8</span>
<span class="cp">#define		HostPowerFail		9</span>
<span class="cp">#define		FatalCommError		10</span>
<span class="cp">#define		HostNormRespNotFull	11</span>
<span class="cp">#define		HostHighRespNotFull	12</span>
<span class="cp">#define		HostNormCmdNotFull	13</span>
<span class="cp">#define		HostHighCmdNotFull	14</span>
<span class="cp">#define		FastIo			15</span>
<span class="cp">#define		AdapPrintfDone		16</span>

<span class="cm">/*</span>
<span class="cm"> *	Define all the queues that the adapter and host use to communicate</span>
<span class="cm"> *	Number them to match the physical queue layout.</span>
<span class="cm"> */</span>

<span class="k">enum</span> <span class="n">aac_queue_types</span> <span class="p">{</span>
        <span class="n">HostNormCmdQueue</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>	<span class="cm">/* Adapter to host normal priority command traffic */</span>
        <span class="n">HostHighCmdQueue</span><span class="p">,</span>	<span class="cm">/* Adapter to host high priority command traffic */</span>
        <span class="n">AdapNormCmdQueue</span><span class="p">,</span>	<span class="cm">/* Host to adapter normal priority command traffic */</span>
        <span class="n">AdapHighCmdQueue</span><span class="p">,</span>	<span class="cm">/* Host to adapter high priority command traffic */</span>
        <span class="n">HostNormRespQueue</span><span class="p">,</span>	<span class="cm">/* Adapter to host normal priority response traffic */</span>
        <span class="n">HostHighRespQueue</span><span class="p">,</span>	<span class="cm">/* Adapter to host high priority response traffic */</span>
        <span class="n">AdapNormRespQueue</span><span class="p">,</span>	<span class="cm">/* Host to adapter normal priority response traffic */</span>
        <span class="n">AdapHighRespQueue</span>	<span class="cm">/* Host to adapter high priority response traffic */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *	Assign type values to the FSA communication data structures</span>
<span class="cm"> */</span>

<span class="cp">#define		FIB_MAGIC	0x0001</span>

<span class="cm">/*</span>
<span class="cm"> *	Define the priority levels the FSA communication routines support.</span>
<span class="cm"> */</span>

<span class="cp">#define		FsaNormal	1</span>

<span class="cm">/* transport FIB header (PMC) */</span>
<span class="k">struct</span> <span class="n">aac_fib_xporthdr</span> <span class="p">{</span>
	<span class="n">u64</span>	<span class="n">HostAddress</span><span class="p">;</span>	<span class="cm">/* FIB host address w/o xport header */</span>
	<span class="n">u32</span>	<span class="n">Size</span><span class="p">;</span>		<span class="cm">/* FIB size excluding xport header */</span>
	<span class="n">u32</span>	<span class="n">Handle</span><span class="p">;</span>		<span class="cm">/* driver handle to reference the FIB */</span>
	<span class="n">u64</span>	<span class="n">Reserved</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="p">};</span>

<span class="cp">#define		ALIGN32		32</span>

<span class="cm">/*</span>
<span class="cm"> * Define the FIB. The FIB is the where all the requested data and</span>
<span class="cm"> * command information are put to the application on the FSA adapter.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">aac_fibhdr</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">XferState</span><span class="p">;</span>	<span class="cm">/* Current transfer state for this CCB */</span>
	<span class="n">__le16</span> <span class="n">Command</span><span class="p">;</span>		<span class="cm">/* Routing information for the destination */</span>
	<span class="n">u8</span> <span class="n">StructType</span><span class="p">;</span>		<span class="cm">/* Type FIB */</span>
	<span class="n">u8</span> <span class="n">Flags</span><span class="p">;</span>		<span class="cm">/* Flags for FIB */</span>
	<span class="n">__le16</span> <span class="n">Size</span><span class="p">;</span>		<span class="cm">/* Size of this FIB in bytes */</span>
	<span class="n">__le16</span> <span class="n">SenderSize</span><span class="p">;</span>	<span class="cm">/* Size of the FIB in the sender</span>
<span class="cm">				   (for response sizing) */</span>
	<span class="n">__le32</span> <span class="n">SenderFibAddress</span><span class="p">;</span>  <span class="cm">/* Host defined data in the FIB */</span>
	<span class="n">__le32</span> <span class="n">ReceiverFibAddress</span><span class="p">;</span><span class="cm">/* Logical address of this FIB for</span>
<span class="cm">				     the adapter */</span>
	<span class="n">u32</span> <span class="n">SenderData</span><span class="p">;</span>		<span class="cm">/* Place holder for the sender to store data */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
		    <span class="n">__le32</span> <span class="n">_ReceiverTimeStart</span><span class="p">;</span>	<span class="cm">/* Timestamp for</span>
<span class="cm">						   receipt of fib */</span>
		    <span class="n">__le32</span> <span class="n">_ReceiverTimeDone</span><span class="p">;</span>	<span class="cm">/* Timestamp for</span>
<span class="cm">						   completion of fib */</span>
		<span class="p">}</span> <span class="n">_s</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">_u</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">hw_fib</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">aac_fibhdr</span> <span class="n">header</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">data</span><span class="p">[</span><span class="mi">512</span><span class="o">-</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">aac_fibhdr</span><span class="p">)];</span>	<span class="c1">// Command specific data</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *	FIB commands</span>
<span class="cm"> */</span>

<span class="cp">#define		TestCommandResponse		1</span>
<span class="cp">#define		TestAdapterCommand		2</span>
<span class="cm">/*</span>
<span class="cm"> *	Lowlevel and comm commands</span>
<span class="cm"> */</span>
<span class="cp">#define		LastTestCommand			100</span>
<span class="cp">#define		ReinitHostNormCommandQueue	101</span>
<span class="cp">#define		ReinitHostHighCommandQueue	102</span>
<span class="cp">#define		ReinitHostHighRespQueue		103</span>
<span class="cp">#define		ReinitHostNormRespQueue		104</span>
<span class="cp">#define		ReinitAdapNormCommandQueue	105</span>
<span class="cp">#define		ReinitAdapHighCommandQueue	107</span>
<span class="cp">#define		ReinitAdapHighRespQueue		108</span>
<span class="cp">#define		ReinitAdapNormRespQueue		109</span>
<span class="cp">#define		InterfaceShutdown		110</span>
<span class="cp">#define		DmaCommandFib			120</span>
<span class="cp">#define		StartProfile			121</span>
<span class="cp">#define		TermProfile			122</span>
<span class="cp">#define		SpeedTest			123</span>
<span class="cp">#define		TakeABreakPt			124</span>
<span class="cp">#define		RequestPerfData			125</span>
<span class="cp">#define		SetInterruptDefTimer		126</span>
<span class="cp">#define		SetInterruptDefCount		127</span>
<span class="cp">#define		GetInterruptDefStatus		128</span>
<span class="cp">#define		LastCommCommand			129</span>
<span class="cm">/*</span>
<span class="cm"> *	Filesystem commands</span>
<span class="cm"> */</span>
<span class="cp">#define		NuFileSystem			300</span>
<span class="cp">#define		UFS				301</span>
<span class="cp">#define		HostFileSystem			302</span>
<span class="cp">#define		LastFileSystemCommand		303</span>
<span class="cm">/*</span>
<span class="cm"> *	Container Commands</span>
<span class="cm"> */</span>
<span class="cp">#define		ContainerCommand		500</span>
<span class="cp">#define		ContainerCommand64		501</span>
<span class="cp">#define		ContainerRawIo			502</span>
<span class="cm">/*</span>
<span class="cm"> *	Scsi Port commands (scsi passthrough)</span>
<span class="cm"> */</span>
<span class="cp">#define		ScsiPortCommand			600</span>
<span class="cp">#define		ScsiPortCommand64		601</span>
<span class="cm">/*</span>
<span class="cm"> *	Misc house keeping and generic adapter initiated commands</span>
<span class="cm"> */</span>
<span class="cp">#define		AifRequest			700</span>
<span class="cp">#define		CheckRevision			701</span>
<span class="cp">#define		FsaHostShutdown			702</span>
<span class="cp">#define		RequestAdapterInfo		703</span>
<span class="cp">#define		IsAdapterPaused			704</span>
<span class="cp">#define		SendHostTime			705</span>
<span class="cp">#define		RequestSupplementAdapterInfo	706</span>
<span class="cp">#define		LastMiscCommand			707</span>

<span class="cm">/*</span>
<span class="cm"> * Commands that will target the failover level on the FSA adapter</span>
<span class="cm"> */</span>

<span class="k">enum</span> <span class="n">fib_xfer_state</span> <span class="p">{</span>
	<span class="n">HostOwned</span>			<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">0</span><span class="p">),</span>
	<span class="n">AdapterOwned</span>			<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">),</span>
	<span class="n">FibInitialized</span>			<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">),</span>
	<span class="n">FibEmpty</span>			<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">),</span>
	<span class="n">AllocatedFromPool</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="p">),</span>
	<span class="n">SentFromHost</span>			<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">5</span><span class="p">),</span>
	<span class="n">SentFromAdapter</span>			<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">6</span><span class="p">),</span>
	<span class="n">ResponseExpected</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">7</span><span class="p">),</span>
	<span class="n">NoResponseExpected</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">8</span><span class="p">),</span>
	<span class="n">AdapterProcessed</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">9</span><span class="p">),</span>
	<span class="n">HostProcessed</span>			<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">10</span><span class="p">),</span>
	<span class="n">HighPriority</span>			<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">11</span><span class="p">),</span>
	<span class="n">NormalPriority</span>			<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">12</span><span class="p">),</span>
	<span class="n">Async</span>				<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">13</span><span class="p">),</span>
	<span class="n">AsyncIo</span>				<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">13</span><span class="p">),</span>	<span class="c1">// rpbfix: remove with new regime</span>
	<span class="n">PageFileIo</span>			<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">14</span><span class="p">),</span>	<span class="c1">// rpbfix: remove with new regime</span>
	<span class="n">ShutdownRequest</span>			<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">15</span><span class="p">),</span>
	<span class="n">LazyWrite</span>			<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">16</span><span class="p">),</span>	<span class="c1">// rpbfix: remove with new regime</span>
	<span class="n">AdapterMicroFib</span>			<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">17</span><span class="p">),</span>
	<span class="n">BIOSFibPath</span>			<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">18</span><span class="p">),</span>
	<span class="n">FastResponseCapable</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">19</span><span class="p">),</span>
	<span class="n">ApiFib</span>				<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">20</span><span class="p">),</span>	<span class="cm">/* Its an API Fib */</span>
	<span class="cm">/* PMC NEW COMM: There is no more AIF data pending */</span>
	<span class="n">NoMoreAifDataAvailable</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">21</span><span class="p">)</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *	The following defines needs to be updated any time there is an</span>
<span class="cm"> *	incompatible change made to the aac_init structure.</span>
<span class="cm"> */</span>

<span class="cp">#define ADAPTER_INIT_STRUCT_REVISION		3</span>
<span class="cp">#define ADAPTER_INIT_STRUCT_REVISION_4		4 </span><span class="c1">// rocket science</span>
<span class="cp">#define ADAPTER_INIT_STRUCT_REVISION_6		6 </span><span class="cm">/* PMC src */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">aac_init</span>
<span class="p">{</span>
	<span class="n">__le32</span>	<span class="n">InitStructRevision</span><span class="p">;</span>
	<span class="n">__le32</span>	<span class="n">MiniPortRevision</span><span class="p">;</span>
	<span class="n">__le32</span>	<span class="n">fsrev</span><span class="p">;</span>
	<span class="n">__le32</span>	<span class="n">CommHeaderAddress</span><span class="p">;</span>
	<span class="n">__le32</span>	<span class="n">FastIoCommAreaAddress</span><span class="p">;</span>
	<span class="n">__le32</span>	<span class="n">AdapterFibsPhysicalAddress</span><span class="p">;</span>
	<span class="n">__le32</span>	<span class="n">AdapterFibsVirtualAddress</span><span class="p">;</span>
	<span class="n">__le32</span>	<span class="n">AdapterFibsSize</span><span class="p">;</span>
	<span class="n">__le32</span>	<span class="n">AdapterFibAlign</span><span class="p">;</span>
	<span class="n">__le32</span>	<span class="n">printfbuf</span><span class="p">;</span>
	<span class="n">__le32</span>	<span class="n">printfbufsiz</span><span class="p">;</span>
	<span class="n">__le32</span>	<span class="n">HostPhysMemPages</span><span class="p">;</span>   <span class="cm">/* number of 4k pages of host</span>
<span class="cm">				       physical memory */</span>
	<span class="n">__le32</span>	<span class="n">HostElapsedSeconds</span><span class="p">;</span> <span class="cm">/* number of seconds since 1970. */</span>
	<span class="cm">/*</span>
<span class="cm">	 * ADAPTER_INIT_STRUCT_REVISION_4 begins here</span>
<span class="cm">	 */</span>
	<span class="n">__le32</span>	<span class="n">InitFlags</span><span class="p">;</span>	<span class="cm">/* flags for supported features */</span>
<span class="cp">#define INITFLAGS_NEW_COMM_SUPPORTED	0x00000001</span>
<span class="cp">#define INITFLAGS_DRIVER_USES_UTC_TIME	0x00000010</span>
<span class="cp">#define INITFLAGS_DRIVER_SUPPORTS_PM	0x00000020</span>
<span class="cp">#define INITFLAGS_NEW_COMM_TYPE1_SUPPORTED	0x00000041</span>
	<span class="n">__le32</span>	<span class="n">MaxIoCommands</span><span class="p">;</span>	<span class="cm">/* max outstanding commands */</span>
	<span class="n">__le32</span>	<span class="n">MaxIoSize</span><span class="p">;</span>	<span class="cm">/* largest I/O command */</span>
	<span class="n">__le32</span>	<span class="n">MaxFibSize</span><span class="p">;</span>	<span class="cm">/* largest FIB to adapter */</span>
	<span class="cm">/* ADAPTER_INIT_STRUCT_REVISION_5 begins here */</span>
	<span class="n">__le32</span>	<span class="n">MaxNumAif</span><span class="p">;</span>	<span class="cm">/* max number of aif */</span>
	<span class="cm">/* ADAPTER_INIT_STRUCT_REVISION_6 begins here */</span>
	<span class="n">__le32</span>	<span class="n">HostRRQ_AddrLow</span><span class="p">;</span>
	<span class="n">__le32</span>	<span class="n">HostRRQ_AddrHigh</span><span class="p">;</span>	<span class="cm">/* Host RRQ (response queue) for SRC */</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">aac_log_level</span> <span class="p">{</span>
	<span class="n">LOG_AAC_INIT</span>			<span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
	<span class="n">LOG_AAC_INFORMATIONAL</span>		<span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
	<span class="n">LOG_AAC_WARNING</span>			<span class="o">=</span> <span class="mi">30</span><span class="p">,</span>
	<span class="n">LOG_AAC_LOW_ERROR</span>		<span class="o">=</span> <span class="mi">40</span><span class="p">,</span>
	<span class="n">LOG_AAC_MEDIUM_ERROR</span>		<span class="o">=</span> <span class="mi">50</span><span class="p">,</span>
	<span class="n">LOG_AAC_HIGH_ERROR</span>		<span class="o">=</span> <span class="mi">60</span><span class="p">,</span>
	<span class="n">LOG_AAC_PANIC</span>			<span class="o">=</span> <span class="mi">70</span><span class="p">,</span>
	<span class="n">LOG_AAC_DEBUG</span>			<span class="o">=</span> <span class="mi">80</span><span class="p">,</span>
	<span class="n">LOG_AAC_WINDBG_PRINT</span>		<span class="o">=</span> <span class="mi">90</span>
<span class="p">};</span>

<span class="cp">#define FSAFS_NTC_GET_ADAPTER_FIB_CONTEXT	0x030b</span>
<span class="cp">#define FSAFS_NTC_FIB_CONTEXT			0x030c</span>

<span class="k">struct</span> <span class="n">aac_dev</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">fib</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">scsi_cmnd</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">adapter_ops</span>
<span class="p">{</span>
	<span class="cm">/* Low level operations */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">adapter_interrupt</span><span class="p">)(</span><span class="k">struct</span> <span class="n">aac_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">adapter_notify</span><span class="p">)(</span><span class="k">struct</span> <span class="n">aac_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u32</span> <span class="n">event</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">adapter_disable_int</span><span class="p">)(</span><span class="k">struct</span> <span class="n">aac_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">adapter_enable_int</span><span class="p">)(</span><span class="k">struct</span> <span class="n">aac_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span>  <span class="p">(</span><span class="o">*</span><span class="n">adapter_sync_cmd</span><span class="p">)(</span><span class="k">struct</span> <span class="n">aac_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u32</span> <span class="n">command</span><span class="p">,</span> <span class="n">u32</span> <span class="n">p1</span><span class="p">,</span> <span class="n">u32</span> <span class="n">p2</span><span class="p">,</span> <span class="n">u32</span> <span class="n">p3</span><span class="p">,</span> <span class="n">u32</span> <span class="n">p4</span><span class="p">,</span> <span class="n">u32</span> <span class="n">p5</span><span class="p">,</span> <span class="n">u32</span> <span class="n">p6</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">status</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">r1</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">r2</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">r3</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">r4</span><span class="p">);</span>
	<span class="kt">int</span>  <span class="p">(</span><span class="o">*</span><span class="n">adapter_check_health</span><span class="p">)(</span><span class="k">struct</span> <span class="n">aac_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span>  <span class="p">(</span><span class="o">*</span><span class="n">adapter_restart</span><span class="p">)(</span><span class="k">struct</span> <span class="n">aac_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bled</span><span class="p">);</span>
	<span class="cm">/* Transport operations */</span>
	<span class="kt">int</span>  <span class="p">(</span><span class="o">*</span><span class="n">adapter_ioremap</span><span class="p">)(</span><span class="k">struct</span> <span class="n">aac_dev</span> <span class="o">*</span> <span class="n">dev</span><span class="p">,</span> <span class="n">u32</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">irq_handler_t</span> <span class="n">adapter_intr</span><span class="p">;</span>
	<span class="cm">/* Packet operations */</span>
	<span class="kt">int</span>  <span class="p">(</span><span class="o">*</span><span class="n">adapter_deliver</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fib</span> <span class="o">*</span> <span class="n">fib</span><span class="p">);</span>
	<span class="kt">int</span>  <span class="p">(</span><span class="o">*</span><span class="n">adapter_bounds</span><span class="p">)(</span><span class="k">struct</span> <span class="n">aac_dev</span> <span class="o">*</span> <span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">u64</span> <span class="n">lba</span><span class="p">);</span>
	<span class="kt">int</span>  <span class="p">(</span><span class="o">*</span><span class="n">adapter_read</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fib</span> <span class="o">*</span> <span class="n">fib</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">u64</span> <span class="n">lba</span><span class="p">,</span> <span class="n">u32</span> <span class="n">count</span><span class="p">);</span>
	<span class="kt">int</span>  <span class="p">(</span><span class="o">*</span><span class="n">adapter_write</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fib</span> <span class="o">*</span> <span class="n">fib</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">u64</span> <span class="n">lba</span><span class="p">,</span> <span class="n">u32</span> <span class="n">count</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fua</span><span class="p">);</span>
	<span class="kt">int</span>  <span class="p">(</span><span class="o">*</span><span class="n">adapter_scsi</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fib</span> <span class="o">*</span> <span class="n">fib</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span> <span class="n">cmd</span><span class="p">);</span>
	<span class="cm">/* Administrative operations */</span>
	<span class="kt">int</span>  <span class="p">(</span><span class="o">*</span><span class="n">adapter_comm</span><span class="p">)(</span><span class="k">struct</span> <span class="n">aac_dev</span> <span class="o">*</span> <span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">comm</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *	Define which interrupt handler needs to be installed</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">aac_driver_ident</span>
<span class="p">{</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">init</span><span class="p">)(</span><span class="k">struct</span> <span class="n">aac_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">char</span> <span class="o">*</span>	<span class="n">name</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span>	<span class="n">vname</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span>	<span class="n">model</span><span class="p">;</span>
	<span class="n">u16</span>	<span class="n">channels</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">quirks</span><span class="p">;</span>
<span class="p">};</span>
<span class="cm">/*</span>
<span class="cm"> * Some adapter firmware needs communication memory</span>
<span class="cm"> * below 2gig. This tells the init function to set the</span>
<span class="cm"> * dma mask such that fib memory will be allocated where the</span>
<span class="cm"> * adapter firmware can get to it.</span>
<span class="cm"> */</span>
<span class="cp">#define AAC_QUIRK_31BIT	0x0001</span>

<span class="cm">/*</span>
<span class="cm"> * Some adapter firmware, when the raid card&#39;s cache is turned off, can not</span>
<span class="cm"> * split up scatter gathers in order to deal with the limits of the</span>
<span class="cm"> * underlying CHIM. This limit is 34 scatter gather elements.</span>
<span class="cm"> */</span>
<span class="cp">#define AAC_QUIRK_34SG	0x0002</span>

<span class="cm">/*</span>
<span class="cm"> * This adapter is a slave (no Firmware)</span>
<span class="cm"> */</span>
<span class="cp">#define AAC_QUIRK_SLAVE 0x0004</span>

<span class="cm">/*</span>
<span class="cm"> * This adapter is a master.</span>
<span class="cm"> */</span>
<span class="cp">#define AAC_QUIRK_MASTER 0x0008</span>

<span class="cm">/*</span>
<span class="cm"> * Some adapter firmware perform poorly when it must split up scatter gathers</span>
<span class="cm"> * in order to deal with the limits of the underlying CHIM. This limit in this</span>
<span class="cm"> * class of adapters is 17 scatter gather elements.</span>
<span class="cm"> */</span>
<span class="cp">#define AAC_QUIRK_17SG	0x0010</span>

<span class="cm">/*</span>
<span class="cm"> *	Some adapter firmware does not support 64 bit scsi passthrough</span>
<span class="cm"> * commands.</span>
<span class="cm"> */</span>
<span class="cp">#define AAC_QUIRK_SCSI_32	0x0020</span>

<span class="cm">/*</span>
<span class="cm"> *	The adapter interface specs all queues to be located in the same</span>
<span class="cm"> *	physically contiguous block. The host structure that defines the</span>
<span class="cm"> *	commuication queues will assume they are each a separate physically</span>
<span class="cm"> *	contiguous memory region that will support them all being one big</span>
<span class="cm"> *	contiguous block.</span>
<span class="cm"> *	There is a command and response queue for each level and direction of</span>
<span class="cm"> *	commuication. These regions are accessed by both the host and adapter.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">aac_queue</span> <span class="p">{</span>
	<span class="n">u64</span>			<span class="n">logical</span><span class="p">;</span>	<span class="cm">/*address we give the adapter */</span>
	<span class="k">struct</span> <span class="n">aac_entry</span>	<span class="o">*</span><span class="n">base</span><span class="p">;</span>		<span class="cm">/*system virtual address */</span>
	<span class="k">struct</span> <span class="n">aac_qhdr</span>		<span class="n">headers</span><span class="p">;</span>	<span class="cm">/*producer,consumer q headers*/</span>
	<span class="n">u32</span>			<span class="n">entries</span><span class="p">;</span>	<span class="cm">/*Number of queue entries */</span>
	<span class="n">wait_queue_head_t</span>	<span class="n">qfull</span><span class="p">;</span>		<span class="cm">/*Event to wait on if q full */</span>
	<span class="n">wait_queue_head_t</span>	<span class="n">cmdready</span><span class="p">;</span>	<span class="cm">/*Cmd ready from the adapter */</span>
		<span class="cm">/* This is only valid for adapter to host command queues. */</span>
	<span class="n">spinlock_t</span>		<span class="o">*</span><span class="n">lock</span><span class="p">;</span>		<span class="cm">/* Spinlock for this queue must take this lock before accessing the lock */</span>
	<span class="n">spinlock_t</span>		<span class="n">lockdata</span><span class="p">;</span>	<span class="cm">/* Actual lock (used only on one side of the lock) */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">cmdq</span><span class="p">;</span>		<span class="cm">/* A queue of FIBs which need to be prcessed by the FS thread. This is */</span>
						<span class="cm">/* only valid for command queues which receive entries from the adapter. */</span>
	<span class="n">u32</span>			<span class="n">numpending</span><span class="p">;</span>	<span class="cm">/* Number of entries on outstanding queue. */</span>
	<span class="k">struct</span> <span class="n">aac_dev</span> <span class="o">*</span>	<span class="n">dev</span><span class="p">;</span>		<span class="cm">/* Back pointer to adapter structure */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *	Message queues. The order here is important, see also the</span>
<span class="cm"> *	queue type ordering</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">aac_queue_block</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">aac_queue</span> <span class="n">queue</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *	SaP1 Message Unit Registers</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">sa_drawbridge_CSR</span> <span class="p">{</span>
				<span class="cm">/*	Offset	|  Name */</span>
	<span class="n">__le32</span>	<span class="n">reserved</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>	<span class="cm">/*	00h-27h |  Reserved */</span>
	<span class="n">u8</span>	<span class="n">LUT_Offset</span><span class="p">;</span>	<span class="cm">/*	28h	|  Lookup Table Offset */</span>
	<span class="n">u8</span>	<span class="n">reserved1</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>	<span class="cm">/*	29h-2bh	|  Reserved */</span>
	<span class="n">__le32</span>	<span class="n">LUT_Data</span><span class="p">;</span>	<span class="cm">/*	2ch	|  Looup Table Data */</span>
	<span class="n">__le32</span>	<span class="n">reserved2</span><span class="p">[</span><span class="mi">26</span><span class="p">];</span>	<span class="cm">/*	30h-97h	|  Reserved */</span>
	<span class="n">__le16</span>	<span class="n">PRICLEARIRQ</span><span class="p">;</span>	<span class="cm">/*	98h	|  Primary Clear Irq */</span>
	<span class="n">__le16</span>	<span class="n">SECCLEARIRQ</span><span class="p">;</span>	<span class="cm">/*	9ah	|  Secondary Clear Irq */</span>
	<span class="n">__le16</span>	<span class="n">PRISETIRQ</span><span class="p">;</span>	<span class="cm">/*	9ch	|  Primary Set Irq */</span>
	<span class="n">__le16</span>	<span class="n">SECSETIRQ</span><span class="p">;</span>	<span class="cm">/*	9eh	|  Secondary Set Irq */</span>
	<span class="n">__le16</span>	<span class="n">PRICLEARIRQMASK</span><span class="p">;</span><span class="cm">/*	a0h	|  Primary Clear Irq Mask */</span>
	<span class="n">__le16</span>	<span class="n">SECCLEARIRQMASK</span><span class="p">;</span><span class="cm">/*	a2h	|  Secondary Clear Irq Mask */</span>
	<span class="n">__le16</span>	<span class="n">PRISETIRQMASK</span><span class="p">;</span>	<span class="cm">/*	a4h	|  Primary Set Irq Mask */</span>
	<span class="n">__le16</span>	<span class="n">SECSETIRQMASK</span><span class="p">;</span>	<span class="cm">/*	a6h	|  Secondary Set Irq Mask */</span>
	<span class="n">__le32</span>	<span class="n">MAILBOX0</span><span class="p">;</span>	<span class="cm">/*	a8h	|  Scratchpad 0 */</span>
	<span class="n">__le32</span>	<span class="n">MAILBOX1</span><span class="p">;</span>	<span class="cm">/*	ach	|  Scratchpad 1 */</span>
	<span class="n">__le32</span>	<span class="n">MAILBOX2</span><span class="p">;</span>	<span class="cm">/*	b0h	|  Scratchpad 2 */</span>
	<span class="n">__le32</span>	<span class="n">MAILBOX3</span><span class="p">;</span>	<span class="cm">/*	b4h	|  Scratchpad 3 */</span>
	<span class="n">__le32</span>	<span class="n">MAILBOX4</span><span class="p">;</span>	<span class="cm">/*	b8h	|  Scratchpad 4 */</span>
	<span class="n">__le32</span>	<span class="n">MAILBOX5</span><span class="p">;</span>	<span class="cm">/*	bch	|  Scratchpad 5 */</span>
	<span class="n">__le32</span>	<span class="n">MAILBOX6</span><span class="p">;</span>	<span class="cm">/*	c0h	|  Scratchpad 6 */</span>
	<span class="n">__le32</span>	<span class="n">MAILBOX7</span><span class="p">;</span>	<span class="cm">/*	c4h	|  Scratchpad 7 */</span>
	<span class="n">__le32</span>	<span class="n">ROM_Setup_Data</span><span class="p">;</span>	<span class="cm">/*	c8h	|  Rom Setup and Data */</span>
	<span class="n">__le32</span>	<span class="n">ROM_Control_Addr</span><span class="p">;</span><span class="cm">/*	cch	|  Rom Control and Address */</span>
	<span class="n">__le32</span>	<span class="n">reserved3</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>	<span class="cm">/*	d0h-ffh	|  reserved */</span>
	<span class="n">__le32</span>	<span class="n">LUT</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>	<span class="cm">/*    100h-1ffh	|  Lookup Table Entries */</span>
<span class="p">};</span>

<span class="cp">#define Mailbox0	SaDbCSR.MAILBOX0</span>
<span class="cp">#define Mailbox1	SaDbCSR.MAILBOX1</span>
<span class="cp">#define Mailbox2	SaDbCSR.MAILBOX2</span>
<span class="cp">#define Mailbox3	SaDbCSR.MAILBOX3</span>
<span class="cp">#define Mailbox4	SaDbCSR.MAILBOX4</span>
<span class="cp">#define Mailbox5	SaDbCSR.MAILBOX5</span>
<span class="cp">#define Mailbox6	SaDbCSR.MAILBOX6</span>
<span class="cp">#define Mailbox7	SaDbCSR.MAILBOX7</span>

<span class="cp">#define DoorbellReg_p SaDbCSR.PRISETIRQ</span>
<span class="cp">#define DoorbellReg_s SaDbCSR.SECSETIRQ</span>
<span class="cp">#define DoorbellClrReg_p SaDbCSR.PRICLEARIRQ</span>


<span class="cp">#define	DOORBELL_0	0x0001</span>
<span class="cp">#define DOORBELL_1	0x0002</span>
<span class="cp">#define DOORBELL_2	0x0004</span>
<span class="cp">#define DOORBELL_3	0x0008</span>
<span class="cp">#define DOORBELL_4	0x0010</span>
<span class="cp">#define DOORBELL_5	0x0020</span>
<span class="cp">#define DOORBELL_6	0x0040</span>


<span class="cp">#define PrintfReady	DOORBELL_5</span>
<span class="cp">#define PrintfDone	DOORBELL_5</span>

<span class="k">struct</span> <span class="n">sa_registers</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">sa_drawbridge_CSR</span>	<span class="n">SaDbCSR</span><span class="p">;</span>			<span class="cm">/* 98h - c4h */</span>
<span class="p">};</span>


<span class="cp">#define Sa_MINIPORT_REVISION			1</span>

<span class="cp">#define sa_readw(AEP, CSR)		readl(&amp;((AEP)-&gt;regs.sa-&gt;CSR))</span>
<span class="cp">#define sa_readl(AEP, CSR)		readl(&amp;((AEP)-&gt;regs.sa-&gt;CSR))</span>
<span class="cp">#define sa_writew(AEP, CSR, value)	writew(value, &amp;((AEP)-&gt;regs.sa-&gt;CSR))</span>
<span class="cp">#define sa_writel(AEP, CSR, value)	writel(value, &amp;((AEP)-&gt;regs.sa-&gt;CSR))</span>

<span class="cm">/*</span>
<span class="cm"> *	Rx Message Unit Registers</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">rx_mu_registers</span> <span class="p">{</span>
			    <span class="cm">/*	Local  | PCI*| Name */</span>
	<span class="n">__le32</span>	<span class="n">ARSR</span><span class="p">;</span>	    <span class="cm">/*	1300h  | 00h | APIC Register Select Register */</span>
	<span class="n">__le32</span>	<span class="n">reserved0</span><span class="p">;</span>  <span class="cm">/*	1304h  | 04h | Reserved */</span>
	<span class="n">__le32</span>	<span class="n">AWR</span><span class="p">;</span>	    <span class="cm">/*	1308h  | 08h | APIC Window Register */</span>
	<span class="n">__le32</span>	<span class="n">reserved1</span><span class="p">;</span>  <span class="cm">/*	130Ch  | 0Ch | Reserved */</span>
	<span class="n">__le32</span>	<span class="n">IMRx</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>    <span class="cm">/*	1310h  | 10h | Inbound Message Registers */</span>
	<span class="n">__le32</span>	<span class="n">OMRx</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>    <span class="cm">/*	1318h  | 18h | Outbound Message Registers */</span>
	<span class="n">__le32</span>	<span class="n">IDR</span><span class="p">;</span>	    <span class="cm">/*	1320h  | 20h | Inbound Doorbell Register */</span>
	<span class="n">__le32</span>	<span class="n">IISR</span><span class="p">;</span>	    <span class="cm">/*	1324h  | 24h | Inbound Interrupt</span>
<span class="cm">						Status Register */</span>
	<span class="n">__le32</span>	<span class="n">IIMR</span><span class="p">;</span>	    <span class="cm">/*	1328h  | 28h | Inbound Interrupt</span>
<span class="cm">						Mask Register */</span>
	<span class="n">__le32</span>	<span class="n">ODR</span><span class="p">;</span>	    <span class="cm">/*	132Ch  | 2Ch | Outbound Doorbell Register */</span>
	<span class="n">__le32</span>	<span class="n">OISR</span><span class="p">;</span>	    <span class="cm">/*	1330h  | 30h | Outbound Interrupt</span>
<span class="cm">						Status Register */</span>
	<span class="n">__le32</span>	<span class="n">OIMR</span><span class="p">;</span>	    <span class="cm">/*	1334h  | 34h | Outbound Interrupt</span>
<span class="cm">						Mask Register */</span>
	<span class="n">__le32</span>	<span class="n">reserved2</span><span class="p">;</span>  <span class="cm">/*	1338h  | 38h | Reserved */</span>
	<span class="n">__le32</span>	<span class="n">reserved3</span><span class="p">;</span>  <span class="cm">/*	133Ch  | 3Ch | Reserved */</span>
	<span class="n">__le32</span>	<span class="n">InboundQueue</span><span class="p">;</span><span class="cm">/*	1340h  | 40h | Inbound Queue Port relative to firmware */</span>
	<span class="n">__le32</span>	<span class="n">OutboundQueue</span><span class="p">;</span><span class="cm">/*1344h  | 44h | Outbound Queue Port relative to firmware */</span>
			    <span class="cm">/* * Must access through ATU Inbound</span>
<span class="cm">				 Translation Window */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">rx_inbound</span> <span class="p">{</span>
	<span class="n">__le32</span>	<span class="n">Mailbox</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
<span class="p">};</span>

<span class="cp">#define	INBOUNDDOORBELL_0	0x00000001</span>
<span class="cp">#define INBOUNDDOORBELL_1	0x00000002</span>
<span class="cp">#define INBOUNDDOORBELL_2	0x00000004</span>
<span class="cp">#define INBOUNDDOORBELL_3	0x00000008</span>
<span class="cp">#define INBOUNDDOORBELL_4	0x00000010</span>
<span class="cp">#define INBOUNDDOORBELL_5	0x00000020</span>
<span class="cp">#define INBOUNDDOORBELL_6	0x00000040</span>

<span class="cp">#define	OUTBOUNDDOORBELL_0	0x00000001</span>
<span class="cp">#define OUTBOUNDDOORBELL_1	0x00000002</span>
<span class="cp">#define OUTBOUNDDOORBELL_2	0x00000004</span>
<span class="cp">#define OUTBOUNDDOORBELL_3	0x00000008</span>
<span class="cp">#define OUTBOUNDDOORBELL_4	0x00000010</span>

<span class="cp">#define InboundDoorbellReg	MUnit.IDR</span>
<span class="cp">#define OutboundDoorbellReg	MUnit.ODR</span>

<span class="k">struct</span> <span class="n">rx_registers</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">rx_mu_registers</span>		<span class="n">MUnit</span><span class="p">;</span>		<span class="cm">/* 1300h - 1347h */</span>
	<span class="n">__le32</span>				<span class="n">reserved1</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>	<span class="cm">/* 1348h - 134ch */</span>
	<span class="k">struct</span> <span class="n">rx_inbound</span>		<span class="n">IndexRegs</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define rx_readb(AEP, CSR)		readb(&amp;((AEP)-&gt;regs.rx-&gt;CSR))</span>
<span class="cp">#define rx_readl(AEP, CSR)		readl(&amp;((AEP)-&gt;regs.rx-&gt;CSR))</span>
<span class="cp">#define rx_writeb(AEP, CSR, value)	writeb(value, &amp;((AEP)-&gt;regs.rx-&gt;CSR))</span>
<span class="cp">#define rx_writel(AEP, CSR, value)	writel(value, &amp;((AEP)-&gt;regs.rx-&gt;CSR))</span>

<span class="cm">/*</span>
<span class="cm"> *	Rkt Message Unit Registers (same as Rx, except a larger reserve region)</span>
<span class="cm"> */</span>

<span class="cp">#define rkt_mu_registers rx_mu_registers</span>
<span class="cp">#define rkt_inbound rx_inbound</span>

<span class="k">struct</span> <span class="n">rkt_registers</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">rkt_mu_registers</span>		<span class="n">MUnit</span><span class="p">;</span>		 <span class="cm">/* 1300h - 1347h */</span>
	<span class="n">__le32</span>				<span class="n">reserved1</span><span class="p">[</span><span class="mi">1006</span><span class="p">];</span> <span class="cm">/* 1348h - 22fch */</span>
	<span class="k">struct</span> <span class="n">rkt_inbound</span>		<span class="n">IndexRegs</span><span class="p">;</span>	 <span class="cm">/* 2300h - */</span>
<span class="p">};</span>

<span class="cp">#define rkt_readb(AEP, CSR)		readb(&amp;((AEP)-&gt;regs.rkt-&gt;CSR))</span>
<span class="cp">#define rkt_readl(AEP, CSR)		readl(&amp;((AEP)-&gt;regs.rkt-&gt;CSR))</span>
<span class="cp">#define rkt_writeb(AEP, CSR, value)	writeb(value, &amp;((AEP)-&gt;regs.rkt-&gt;CSR))</span>
<span class="cp">#define rkt_writel(AEP, CSR, value)	writel(value, &amp;((AEP)-&gt;regs.rkt-&gt;CSR))</span>

<span class="cm">/*</span>
<span class="cm"> * PMC SRC message unit registers</span>
<span class="cm"> */</span>

<span class="cp">#define src_inbound rx_inbound</span>

<span class="k">struct</span> <span class="n">src_mu_registers</span> <span class="p">{</span>
				<span class="cm">/*	PCI*| Name */</span>
	<span class="n">__le32</span>	<span class="n">reserved0</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>	<span class="cm">/*	00h | Reserved */</span>
	<span class="n">__le32</span>	<span class="n">IDR</span><span class="p">;</span>		<span class="cm">/*	20h | Inbound Doorbell Register */</span>
	<span class="n">__le32</span>	<span class="n">IISR</span><span class="p">;</span>		<span class="cm">/*	24h | Inbound Int. Status Register */</span>
	<span class="n">__le32</span>	<span class="n">reserved1</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>	<span class="cm">/*	28h | Reserved */</span>
	<span class="n">__le32</span>	<span class="n">OIMR</span><span class="p">;</span>		<span class="cm">/*	34h | Outbound Int. Mask Register */</span>
	<span class="n">__le32</span>	<span class="n">reserved2</span><span class="p">[</span><span class="mi">25</span><span class="p">];</span>	<span class="cm">/*	38h | Reserved */</span>
	<span class="n">__le32</span>	<span class="n">ODR_R</span><span class="p">;</span>		<span class="cm">/*	9ch | Outbound Doorbell Read */</span>
	<span class="n">__le32</span>	<span class="n">ODR_C</span><span class="p">;</span>		<span class="cm">/*	a0h | Outbound Doorbell Clear */</span>
	<span class="n">__le32</span>	<span class="n">reserved3</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>	<span class="cm">/*	a4h | Reserved */</span>
	<span class="n">__le32</span>	<span class="n">OMR</span><span class="p">;</span>		<span class="cm">/*	bch | Outbound Message Register */</span>
	<span class="n">__le32</span>	<span class="n">IQ_L</span><span class="p">;</span>		<span class="cm">/*  c0h | Inbound Queue (Low address) */</span>
	<span class="n">__le32</span>	<span class="n">IQ_H</span><span class="p">;</span>		<span class="cm">/*  c4h | Inbound Queue (High address) */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">src_registers</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">src_mu_registers</span> <span class="n">MUnit</span><span class="p">;</span>	<span class="cm">/* 00h - c7h */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">__le32</span> <span class="n">reserved1</span><span class="p">[</span><span class="mi">130790</span><span class="p">];</span>	<span class="cm">/* c8h - 7fc5fh */</span>
			<span class="k">struct</span> <span class="n">src_inbound</span> <span class="n">IndexRegs</span><span class="p">;</span>	<span class="cm">/* 7fc60h */</span>
		<span class="p">}</span> <span class="n">tupelo</span><span class="p">;</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">__le32</span> <span class="n">reserved1</span><span class="p">[</span><span class="mi">974</span><span class="p">];</span>		<span class="cm">/* c8h - fffh */</span>
			<span class="k">struct</span> <span class="n">src_inbound</span> <span class="n">IndexRegs</span><span class="p">;</span>	<span class="cm">/* 1000h */</span>
		<span class="p">}</span> <span class="n">denali</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">u</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define src_readb(AEP, CSR)		readb(&amp;((AEP)-&gt;regs.src.bar0-&gt;CSR))</span>
<span class="cp">#define src_readl(AEP, CSR)		readl(&amp;((AEP)-&gt;regs.src.bar0-&gt;CSR))</span>
<span class="cp">#define src_writeb(AEP, CSR, value)	writeb(value, \</span>
<span class="cp">						&amp;((AEP)-&gt;regs.src.bar0-&gt;CSR))</span>
<span class="cp">#define src_writel(AEP, CSR, value)	writel(value, \</span>
<span class="cp">						&amp;((AEP)-&gt;regs.src.bar0-&gt;CSR))</span>

<span class="cp">#define SRC_ODR_SHIFT		12</span>
<span class="cp">#define SRC_IDR_SHIFT		9</span>

<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">fib_callback</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fib</span> <span class="o">*</span><span class="n">fibctx</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">aac_fib_context</span> <span class="p">{</span>
	<span class="n">s16</span>			<span class="n">type</span><span class="p">;</span>		<span class="c1">// used for verification of structure</span>
	<span class="n">s16</span>			<span class="n">size</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">unique</span><span class="p">;</span>		<span class="c1">// unique value representing this context</span>
	<span class="n">ulong</span>			<span class="n">jiffies</span><span class="p">;</span>	<span class="c1">// used for cleanup - dmb changed to ulong</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">next</span><span class="p">;</span>		<span class="c1">// used to link context&#39;s into a linked list</span>
	<span class="k">struct</span> <span class="n">semaphore</span>	<span class="n">wait_sem</span><span class="p">;</span>	<span class="c1">// this is used to wait for the next fib to arrive.</span>
	<span class="kt">int</span>			<span class="n">wait</span><span class="p">;</span>		<span class="c1">// Set to true when thread is in WaitForSingleObject</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">count</span><span class="p">;</span>		<span class="c1">// total number of FIBs on FibList</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">fib_list</span><span class="p">;</span>	<span class="c1">// this holds fibs and their attachd hw_fibs</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">sense_data</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">error_code</span><span class="p">;</span>		<span class="cm">/* 70h (current errors), 71h(deferred errors) */</span>
	<span class="n">u8</span> <span class="n">valid</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>		<span class="cm">/* A valid bit of one indicates that the information  */</span>
				<span class="cm">/* field contains valid information as defined in the</span>
<span class="cm">				 * SCSI-2 Standard.</span>
<span class="cm">				 */</span>
	<span class="n">u8</span> <span class="n">segment_number</span><span class="p">;</span>	<span class="cm">/* Only used for COPY, COMPARE, or COPY AND VERIFY Commands */</span>
	<span class="n">u8</span> <span class="n">sense_key</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>		<span class="cm">/* Sense Key */</span>
	<span class="n">u8</span> <span class="n">reserved</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ILI</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>		<span class="cm">/* Incorrect Length Indicator */</span>
	<span class="n">u8</span> <span class="n">EOM</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>		<span class="cm">/* End Of Medium - reserved for random access devices */</span>
	<span class="n">u8</span> <span class="n">filemark</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>		<span class="cm">/* Filemark - reserved for random access devices */</span>

	<span class="n">u8</span> <span class="n">information</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>	<span class="cm">/* for direct-access devices, contains the unsigned</span>
<span class="cm">				 * logical block address or residue associated with</span>
<span class="cm">				 * the sense key</span>
<span class="cm">				 */</span>
	<span class="n">u8</span> <span class="n">add_sense_len</span><span class="p">;</span>	<span class="cm">/* number of additional sense bytes to follow this field */</span>
	<span class="n">u8</span> <span class="n">cmnd_info</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>	<span class="cm">/* not used */</span>
	<span class="n">u8</span> <span class="n">ASC</span><span class="p">;</span>			<span class="cm">/* Additional Sense Code */</span>
	<span class="n">u8</span> <span class="n">ASCQ</span><span class="p">;</span>		<span class="cm">/* Additional Sense Code Qualifier */</span>
	<span class="n">u8</span> <span class="n">FRUC</span><span class="p">;</span>		<span class="cm">/* Field Replaceable Unit Code - not used */</span>
	<span class="n">u8</span> <span class="n">bit_ptr</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>		<span class="cm">/* indicates which byte of the CDB or parameter data</span>
<span class="cm">				 * was in error</span>
<span class="cm">				 */</span>
	<span class="n">u8</span> <span class="n">BPV</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>		<span class="cm">/* bit pointer valid (BPV): 1- indicates that</span>
<span class="cm">				 * the bit_ptr field has valid value</span>
<span class="cm">				 */</span>
	<span class="n">u8</span> <span class="n">reserved2</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">CD</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>		<span class="cm">/* command data bit: 1- illegal parameter in CDB.</span>
<span class="cm">				 * 0- illegal parameter in data.</span>
<span class="cm">				 */</span>
	<span class="n">u8</span> <span class="n">SKSV</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">field_ptr</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>	<span class="cm">/* byte of the CDB or parameter data in error */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">fsa_dev_info</span> <span class="p">{</span>
	<span class="n">u64</span>		<span class="n">last</span><span class="p">;</span>
	<span class="n">u64</span>		<span class="n">size</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="n">type</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="n">config_waiting_on</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">config_waiting_stamp</span><span class="p">;</span>
	<span class="n">u16</span>		<span class="n">queue_depth</span><span class="p">;</span>
	<span class="n">u8</span>		<span class="n">config_needed</span><span class="p">;</span>
	<span class="n">u8</span>		<span class="n">valid</span><span class="p">;</span>
	<span class="n">u8</span>		<span class="n">ro</span><span class="p">;</span>
	<span class="n">u8</span>		<span class="n">locked</span><span class="p">;</span>
	<span class="n">u8</span>		<span class="n">deleted</span><span class="p">;</span>
	<span class="kt">char</span>		<span class="n">devname</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">sense_data</span> <span class="n">sense_data</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">fib</span> <span class="p">{</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">next</span><span class="p">;</span>	<span class="cm">/* this is used by the allocator */</span>
	<span class="n">s16</span>			<span class="n">type</span><span class="p">;</span>
	<span class="n">s16</span>			<span class="n">size</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 *	The Adapter that this I/O is destined for.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">aac_dev</span>		<span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 *	This is the event the sendfib routine will wait on if the</span>
<span class="cm">	 *	caller did not pass one and this is synch io.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">semaphore</span>	<span class="n">event_wait</span><span class="p">;</span>
	<span class="n">spinlock_t</span>		<span class="n">event_lock</span><span class="p">;</span>

	<span class="n">u32</span>			<span class="n">done</span><span class="p">;</span>	<span class="cm">/* gets set to 1 when fib is complete */</span>
	<span class="n">fib_callback</span>		<span class="n">callback</span><span class="p">;</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">callback_data</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">flags</span><span class="p">;</span> <span class="c1">// u32 dmb was ulong</span>
	<span class="cm">/*</span>
<span class="cm">	 *	And for the internal issue/reply queues (we may be able</span>
<span class="cm">	 *	to merge these two)</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">fiblink</span><span class="p">;</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hw_fib</span>		<span class="o">*</span><span class="n">hw_fib_va</span><span class="p">;</span>		<span class="cm">/* Actual shared object */</span>
	<span class="n">dma_addr_t</span>		<span class="n">hw_fib_pa</span><span class="p">;</span>		<span class="cm">/* physical address of hw_fib*/</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *	Adapter Information Block</span>
<span class="cm"> *</span>
<span class="cm"> *	This is returned by the RequestAdapterInfo block</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">aac_adapter_info</span>
<span class="p">{</span>
	<span class="n">__le32</span>	<span class="n">platform</span><span class="p">;</span>
	<span class="n">__le32</span>	<span class="n">cpu</span><span class="p">;</span>
	<span class="n">__le32</span>	<span class="n">subcpu</span><span class="p">;</span>
	<span class="n">__le32</span>	<span class="n">clock</span><span class="p">;</span>
	<span class="n">__le32</span>	<span class="n">execmem</span><span class="p">;</span>
	<span class="n">__le32</span>	<span class="n">buffermem</span><span class="p">;</span>
	<span class="n">__le32</span>	<span class="n">totalmem</span><span class="p">;</span>
	<span class="n">__le32</span>	<span class="n">kernelrev</span><span class="p">;</span>
	<span class="n">__le32</span>	<span class="n">kernelbuild</span><span class="p">;</span>
	<span class="n">__le32</span>	<span class="n">monitorrev</span><span class="p">;</span>
	<span class="n">__le32</span>	<span class="n">monitorbuild</span><span class="p">;</span>
	<span class="n">__le32</span>	<span class="n">hwrev</span><span class="p">;</span>
	<span class="n">__le32</span>	<span class="n">hwbuild</span><span class="p">;</span>
	<span class="n">__le32</span>	<span class="n">biosrev</span><span class="p">;</span>
	<span class="n">__le32</span>	<span class="n">biosbuild</span><span class="p">;</span>
	<span class="n">__le32</span>	<span class="n">cluster</span><span class="p">;</span>
	<span class="n">__le32</span>	<span class="n">clusterchannelmask</span><span class="p">;</span>
	<span class="n">__le32</span>	<span class="n">serial</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="n">__le32</span>	<span class="n">battery</span><span class="p">;</span>
	<span class="n">__le32</span>	<span class="n">options</span><span class="p">;</span>
	<span class="n">__le32</span>	<span class="n">OEM</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">aac_supplement_adapter_info</span>
<span class="p">{</span>
	<span class="n">u8</span>	<span class="n">AdapterTypeText</span><span class="p">[</span><span class="mi">17</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">u8</span>	<span class="n">Pad</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="n">__le32</span>	<span class="n">FlashMemoryByteSize</span><span class="p">;</span>
	<span class="n">__le32</span>	<span class="n">FlashImageId</span><span class="p">;</span>
	<span class="n">__le32</span>	<span class="n">MaxNumberPorts</span><span class="p">;</span>
	<span class="n">__le32</span>	<span class="n">Version</span><span class="p">;</span>
	<span class="n">__le32</span>	<span class="n">FeatureBits</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">SlotNumber</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">ReservedPad0</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="n">u8</span>	<span class="n">BuildDate</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>
	<span class="n">__le32</span>	<span class="n">CurrentNumberPorts</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u8</span>	<span class="n">AssemblyPn</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
		<span class="n">u8</span>	<span class="n">FruPn</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
		<span class="n">u8</span>	<span class="n">BatteryFruPn</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
		<span class="n">u8</span>	<span class="n">EcVersionString</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
		<span class="n">u8</span>	<span class="n">Tsid</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>
	<span class="p">}</span>	<span class="n">VpdInfo</span><span class="p">;</span>
	<span class="n">__le32</span>	<span class="n">FlashFirmwareRevision</span><span class="p">;</span>
	<span class="n">__le32</span>	<span class="n">FlashFirmwareBuild</span><span class="p">;</span>
	<span class="n">__le32</span>	<span class="n">RaidTypeMorphOptions</span><span class="p">;</span>
	<span class="n">__le32</span>	<span class="n">FlashFirmwareBootRevision</span><span class="p">;</span>
	<span class="n">__le32</span>	<span class="n">FlashFirmwareBootBuild</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">MfgPcbaSerialNo</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>
	<span class="n">u8</span>	<span class="n">MfgWWNName</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="n">__le32</span>	<span class="n">SupportedOptions2</span><span class="p">;</span>
	<span class="n">__le32</span>	<span class="n">StructExpansion</span><span class="p">;</span>
	<span class="cm">/* StructExpansion == 1 */</span>
	<span class="n">__le32</span>	<span class="n">FeatureBits3</span><span class="p">;</span>
	<span class="n">__le32</span>	<span class="n">SupportedPerformanceModes</span><span class="p">;</span>
	<span class="n">__le32</span>	<span class="n">ReservedForFutureGrowth</span><span class="p">[</span><span class="mi">80</span><span class="p">];</span>
<span class="p">};</span>
<span class="cp">#define AAC_FEATURE_FALCON	cpu_to_le32(0x00000010)</span>
<span class="cp">#define AAC_FEATURE_JBOD	cpu_to_le32(0x08000000)</span>
<span class="cm">/* SupportedOptions2 */</span>
<span class="cp">#define AAC_OPTION_MU_RESET		cpu_to_le32(0x00000001)</span>
<span class="cp">#define AAC_OPTION_IGNORE_RESET		cpu_to_le32(0x00000002)</span>
<span class="cp">#define AAC_OPTION_POWER_MANAGEMENT	cpu_to_le32(0x00000004)</span>
<span class="cp">#define AAC_OPTION_DOORBELL_RESET	cpu_to_le32(0x00004000)</span>
<span class="cp">#define AAC_SIS_VERSION_V3	3</span>
<span class="cp">#define AAC_SIS_SLOT_UNKNOWN	0xFF</span>

<span class="cp">#define GetBusInfo 0x00000009</span>
<span class="k">struct</span> <span class="n">aac_bus_info</span> <span class="p">{</span>
	<span class="n">__le32</span>	<span class="n">Command</span><span class="p">;</span>	<span class="cm">/* VM_Ioctl */</span>
	<span class="n">__le32</span>	<span class="n">ObjType</span><span class="p">;</span>	<span class="cm">/* FT_DRIVE */</span>
	<span class="n">__le32</span>	<span class="n">MethodId</span><span class="p">;</span>	<span class="cm">/* 1 = SCSI Layer */</span>
	<span class="n">__le32</span>	<span class="n">ObjectId</span><span class="p">;</span>	<span class="cm">/* Handle */</span>
	<span class="n">__le32</span>	<span class="n">CtlCmd</span><span class="p">;</span>		<span class="cm">/* GetBusInfo */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">aac_bus_info_response</span> <span class="p">{</span>
	<span class="n">__le32</span>	<span class="n">Status</span><span class="p">;</span>		<span class="cm">/* ST_OK */</span>
	<span class="n">__le32</span>	<span class="n">ObjType</span><span class="p">;</span>
	<span class="n">__le32</span>	<span class="n">MethodId</span><span class="p">;</span>	<span class="cm">/* unused */</span>
	<span class="n">__le32</span>	<span class="n">ObjectId</span><span class="p">;</span>	<span class="cm">/* unused */</span>
	<span class="n">__le32</span>	<span class="n">CtlCmd</span><span class="p">;</span>		<span class="cm">/* unused */</span>
	<span class="n">__le32</span>	<span class="n">ProbeComplete</span><span class="p">;</span>
	<span class="n">__le32</span>	<span class="n">BusCount</span><span class="p">;</span>
	<span class="n">__le32</span>	<span class="n">TargetsPerBus</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">InitiatorBusId</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
	<span class="n">u8</span>	<span class="n">BusValid</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Battery platforms</span>
<span class="cm"> */</span>
<span class="cp">#define AAC_BAT_REQ_PRESENT	(1)</span>
<span class="cp">#define AAC_BAT_REQ_NOTPRESENT	(2)</span>
<span class="cp">#define AAC_BAT_OPT_PRESENT	(3)</span>
<span class="cp">#define AAC_BAT_OPT_NOTPRESENT	(4)</span>
<span class="cp">#define AAC_BAT_NOT_SUPPORTED	(5)</span>
<span class="cm">/*</span>
<span class="cm"> * cpu types</span>
<span class="cm"> */</span>
<span class="cp">#define AAC_CPU_SIMULATOR	(1)</span>
<span class="cp">#define AAC_CPU_I960		(2)</span>
<span class="cp">#define AAC_CPU_STRONGARM	(3)</span>

<span class="cm">/*</span>
<span class="cm"> * Supported Options</span>
<span class="cm"> */</span>
<span class="cp">#define AAC_OPT_SNAPSHOT		cpu_to_le32(1)</span>
<span class="cp">#define AAC_OPT_CLUSTERS		cpu_to_le32(1&lt;&lt;1)</span>
<span class="cp">#define AAC_OPT_WRITE_CACHE		cpu_to_le32(1&lt;&lt;2)</span>
<span class="cp">#define AAC_OPT_64BIT_DATA		cpu_to_le32(1&lt;&lt;3)</span>
<span class="cp">#define AAC_OPT_HOST_TIME_FIB		cpu_to_le32(1&lt;&lt;4)</span>
<span class="cp">#define AAC_OPT_RAID50			cpu_to_le32(1&lt;&lt;5)</span>
<span class="cp">#define AAC_OPT_4GB_WINDOW		cpu_to_le32(1&lt;&lt;6)</span>
<span class="cp">#define AAC_OPT_SCSI_UPGRADEABLE	cpu_to_le32(1&lt;&lt;7)</span>
<span class="cp">#define AAC_OPT_SOFT_ERR_REPORT		cpu_to_le32(1&lt;&lt;8)</span>
<span class="cp">#define AAC_OPT_SUPPORTED_RECONDITION	cpu_to_le32(1&lt;&lt;9)</span>
<span class="cp">#define AAC_OPT_SGMAP_HOST64		cpu_to_le32(1&lt;&lt;10)</span>
<span class="cp">#define AAC_OPT_ALARM			cpu_to_le32(1&lt;&lt;11)</span>
<span class="cp">#define AAC_OPT_NONDASD			cpu_to_le32(1&lt;&lt;12)</span>
<span class="cp">#define AAC_OPT_SCSI_MANAGED		cpu_to_le32(1&lt;&lt;13)</span>
<span class="cp">#define AAC_OPT_RAID_SCSI_MODE		cpu_to_le32(1&lt;&lt;14)</span>
<span class="cp">#define AAC_OPT_SUPPLEMENT_ADAPTER_INFO	cpu_to_le32(1&lt;&lt;16)</span>
<span class="cp">#define AAC_OPT_NEW_COMM		cpu_to_le32(1&lt;&lt;17)</span>
<span class="cp">#define AAC_OPT_NEW_COMM_64		cpu_to_le32(1&lt;&lt;18)</span>
<span class="cp">#define AAC_OPT_NEW_COMM_TYPE1		cpu_to_le32(1&lt;&lt;28)</span>
<span class="cp">#define AAC_OPT_NEW_COMM_TYPE2		cpu_to_le32(1&lt;&lt;29)</span>
<span class="cp">#define AAC_OPT_NEW_COMM_TYPE3		cpu_to_le32(1&lt;&lt;30)</span>
<span class="cp">#define AAC_OPT_NEW_COMM_TYPE4		cpu_to_le32(1&lt;&lt;31)</span>


<span class="k">struct</span> <span class="n">aac_dev</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">entry</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span>		<span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">id</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *	negotiated FIB settings</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span>		<span class="n">max_fib_size</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">sg_tablesize</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">max_num_aif</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *	Map for 128 fib objects (64k)</span>
<span class="cm">	 */</span>
	<span class="n">dma_addr_t</span>		<span class="n">hw_fib_pa</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hw_fib</span>		<span class="o">*</span><span class="n">hw_fib_va</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hw_fib</span>		<span class="o">*</span><span class="n">aif_base_va</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 *	Fib Headers</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">fib</span>              <span class="o">*</span><span class="n">fibs</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">fib</span>		<span class="o">*</span><span class="n">free_fib</span><span class="p">;</span>
	<span class="n">spinlock_t</span>		<span class="n">fib_lock</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">aac_queue_block</span> <span class="o">*</span><span class="n">queues</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 *	The user API will use an IOCTL to register itself to receive</span>
<span class="cm">	 *	FIBs from the adapter.  The following list is used to keep</span>
<span class="cm">	 *	track of all the threads that have requested these FIBs.  The</span>
<span class="cm">	 *	mutex is used to synchronize access to all data associated</span>
<span class="cm">	 *	with the adapter fibs.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">fib_list</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">adapter_ops</span>	<span class="n">a_ops</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">fsrev</span><span class="p">;</span>		<span class="cm">/* Main driver&#39;s revision number */</span>

	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">dbg_base</span><span class="p">;</span>	<span class="cm">/* address of UART</span>
<span class="cm">						 * debug buffer */</span>

	<span class="kt">unsigned</span>		<span class="n">base_size</span><span class="p">,</span> <span class="n">dbg_size</span><span class="p">;</span>	<span class="cm">/* Size of</span>
<span class="cm">							 *  mapped in region */</span>

	<span class="k">struct</span> <span class="n">aac_init</span>		<span class="o">*</span><span class="n">init</span><span class="p">;</span>		<span class="cm">/* Holds initialization info to communicate with adapter */</span>
	<span class="n">dma_addr_t</span>		<span class="n">init_pa</span><span class="p">;</span>	<span class="cm">/* Holds physical address of the init struct */</span>

	<span class="n">u32</span>			<span class="o">*</span><span class="n">host_rrq</span><span class="p">;</span>	<span class="cm">/* response queue</span>
<span class="cm">						 * if AAC_COMM_MESSAGE_TYPE1 */</span>

	<span class="n">dma_addr_t</span>		<span class="n">host_rrq_pa</span><span class="p">;</span>	<span class="cm">/* phys. address */</span>
	<span class="n">u32</span>			<span class="n">host_rrq_idx</span><span class="p">;</span>	<span class="cm">/* index into rrq buffer */</span>

	<span class="k">struct</span> <span class="n">pci_dev</span>		<span class="o">*</span><span class="n">pdev</span><span class="p">;</span>		<span class="cm">/* Our PCI interface */</span>
	<span class="kt">void</span> <span class="o">*</span>			<span class="n">printfbuf</span><span class="p">;</span>	<span class="cm">/* pointer to buffer used for printf&#39;s from the adapter */</span>
	<span class="kt">void</span> <span class="o">*</span>			<span class="n">comm_addr</span><span class="p">;</span>	<span class="cm">/* Base address of Comm area */</span>
	<span class="n">dma_addr_t</span>		<span class="n">comm_phys</span><span class="p">;</span>	<span class="cm">/* Physical Address of Comm area */</span>
	<span class="kt">size_t</span>			<span class="n">comm_size</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">Scsi_Host</span>	<span class="o">*</span><span class="n">scsi_host_ptr</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">maximum_num_containers</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">maximum_num_physicals</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">maximum_num_channels</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fsa_dev_info</span>	<span class="o">*</span><span class="n">fsa_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span>	<span class="o">*</span><span class="kr">thread</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">cardtype</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *	The following is the device specific extension.</span>
<span class="cm">	 */</span>
<span class="cp">#ifndef AAC_MIN_FOOTPRINT_SIZE</span>
<span class="cp">#	define AAC_MIN_FOOTPRINT_SIZE 8192</span>
<span class="cp">#	define AAC_MIN_SRC_BAR0_SIZE 0x400000</span>
<span class="cp">#	define AAC_MIN_SRC_BAR1_SIZE 0x800</span>
<span class="cp">#	define AAC_MIN_SRCV_BAR0_SIZE 0x100000</span>
<span class="cp">#	define AAC_MIN_SRCV_BAR1_SIZE 0x400</span>
<span class="cp">#endif</span>
	<span class="k">union</span>
	<span class="p">{</span>
		<span class="k">struct</span> <span class="n">sa_registers</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">sa</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">rx_registers</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">rx</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">rkt_registers</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">rkt</span><span class="p">;</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">src_registers</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">bar0</span><span class="p">;</span>
			<span class="kt">char</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">bar1</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">src</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">regs</span><span class="p">;</span>
	<span class="k">volatile</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span> <span class="o">*</span><span class="n">dbg_base_mapped</span><span class="p">;</span>
	<span class="k">volatile</span> <span class="k">struct</span> <span class="n">rx_inbound</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">IndexRegs</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">OIMR</span><span class="p">;</span> <span class="cm">/* Mask Register Cache */</span>
	<span class="cm">/*</span>
<span class="cm">	 *	AIF thread states</span>
<span class="cm">	 */</span>
	<span class="n">u32</span>			<span class="n">aif_thread</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">aac_adapter_info</span> <span class="n">adapter_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">aac_supplement_adapter_info</span> <span class="n">supplement_adapter_info</span><span class="p">;</span>
	<span class="cm">/* These are in adapter info but they are in the io flow so</span>
<span class="cm">	 * lets break them out so we don&#39;t have to do an AND to check them</span>
<span class="cm">	 */</span>
	<span class="n">u8</span>			<span class="n">nondasd_support</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">jbod</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">cache_protected</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">dac_support</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">needs_dac</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">raid_scsi_mode</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">comm_interface</span><span class="p">;</span>
<span class="cp">#	define AAC_COMM_PRODUCER 0</span>
<span class="cp">#	define AAC_COMM_MESSAGE  1</span>
<span class="cp">#	define AAC_COMM_MESSAGE_TYPE1	3</span>
	<span class="n">u8</span>			<span class="n">raw_io_interface</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">raw_io_64</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">printf_enabled</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">in_reset</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">msi</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">management_fib_count</span><span class="p">;</span>
	<span class="n">spinlock_t</span>		<span class="n">manage_lock</span><span class="p">;</span>
	<span class="n">spinlock_t</span>		<span class="n">sync_lock</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">sync_mode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fib</span>		<span class="o">*</span><span class="n">sync_fib</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">sync_fib_list</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define aac_adapter_interrupt(dev) \</span>
<span class="cp">	(dev)-&gt;a_ops.adapter_interrupt(dev)</span>

<span class="cp">#define aac_adapter_notify(dev, event) \</span>
<span class="cp">	(dev)-&gt;a_ops.adapter_notify(dev, event)</span>

<span class="cp">#define aac_adapter_disable_int(dev) \</span>
<span class="cp">	(dev)-&gt;a_ops.adapter_disable_int(dev)</span>

<span class="cp">#define aac_adapter_enable_int(dev) \</span>
<span class="cp">	(dev)-&gt;a_ops.adapter_enable_int(dev)</span>

<span class="cp">#define aac_adapter_sync_cmd(dev, command, p1, p2, p3, p4, p5, p6, status, r1, r2, r3, r4) \</span>
<span class="cp">	(dev)-&gt;a_ops.adapter_sync_cmd(dev, command, p1, p2, p3, p4, p5, p6, status, r1, r2, r3, r4)</span>

<span class="cp">#define aac_adapter_check_health(dev) \</span>
<span class="cp">	(dev)-&gt;a_ops.adapter_check_health(dev)</span>

<span class="cp">#define aac_adapter_restart(dev,bled) \</span>
<span class="cp">	(dev)-&gt;a_ops.adapter_restart(dev,bled)</span>

<span class="cp">#define aac_adapter_ioremap(dev, size) \</span>
<span class="cp">	(dev)-&gt;a_ops.adapter_ioremap(dev, size)</span>

<span class="cp">#define aac_adapter_deliver(fib) \</span>
<span class="cp">	((fib)-&gt;dev)-&gt;a_ops.adapter_deliver(fib)</span>

<span class="cp">#define aac_adapter_bounds(dev,cmd,lba) \</span>
<span class="cp">	dev-&gt;a_ops.adapter_bounds(dev,cmd,lba)</span>

<span class="cp">#define aac_adapter_read(fib,cmd,lba,count) \</span>
<span class="cp">	((fib)-&gt;dev)-&gt;a_ops.adapter_read(fib,cmd,lba,count)</span>

<span class="cp">#define aac_adapter_write(fib,cmd,lba,count,fua) \</span>
<span class="cp">	((fib)-&gt;dev)-&gt;a_ops.adapter_write(fib,cmd,lba,count,fua)</span>

<span class="cp">#define aac_adapter_scsi(fib,cmd) \</span>
<span class="cp">	((fib)-&gt;dev)-&gt;a_ops.adapter_scsi(fib,cmd)</span>

<span class="cp">#define aac_adapter_comm(dev,comm) \</span>
<span class="cp">	(dev)-&gt;a_ops.adapter_comm(dev, comm)</span>

<span class="cp">#define FIB_CONTEXT_FLAG_TIMED_OUT		(0x00000001)</span>
<span class="cp">#define FIB_CONTEXT_FLAG			(0x00000002)</span>
<span class="cp">#define FIB_CONTEXT_FLAG_WAIT			(0x00000004)</span>

<span class="cm">/*</span>
<span class="cm"> *	Define the command values</span>
<span class="cm"> */</span>

<span class="cp">#define		Null			0</span>
<span class="cp">#define		GetAttributes		1</span>
<span class="cp">#define		SetAttributes		2</span>
<span class="cp">#define		Lookup			3</span>
<span class="cp">#define		ReadLink		4</span>
<span class="cp">#define		Read			5</span>
<span class="cp">#define		Write			6</span>
<span class="cp">#define		Create			7</span>
<span class="cp">#define		MakeDirectory		8</span>
<span class="cp">#define		SymbolicLink		9</span>
<span class="cp">#define		MakeNode		10</span>
<span class="cp">#define		Removex			11</span>
<span class="cp">#define		RemoveDirectoryx	12</span>
<span class="cp">#define		Rename			13</span>
<span class="cp">#define		Link			14</span>
<span class="cp">#define		ReadDirectory		15</span>
<span class="cp">#define		ReadDirectoryPlus	16</span>
<span class="cp">#define		FileSystemStatus	17</span>
<span class="cp">#define		FileSystemInfo		18</span>
<span class="cp">#define		PathConfigure		19</span>
<span class="cp">#define		Commit			20</span>
<span class="cp">#define		Mount			21</span>
<span class="cp">#define		UnMount			22</span>
<span class="cp">#define		Newfs			23</span>
<span class="cp">#define		FsCheck			24</span>
<span class="cp">#define		FsSync			25</span>
<span class="cp">#define		SimReadWrite		26</span>
<span class="cp">#define		SetFileSystemStatus	27</span>
<span class="cp">#define		BlockRead		28</span>
<span class="cp">#define		BlockWrite		29</span>
<span class="cp">#define		NvramIoctl		30</span>
<span class="cp">#define		FsSyncWait		31</span>
<span class="cp">#define		ClearArchiveBit		32</span>
<span class="cp">#define		SetAcl			33</span>
<span class="cp">#define		GetAcl			34</span>
<span class="cp">#define		AssignAcl		35</span>
<span class="cp">#define		FaultInsertion		36	</span><span class="cm">/* Fault Insertion Command */</span><span class="cp"></span>
<span class="cp">#define		CrazyCache		37	</span><span class="cm">/* Crazycache */</span><span class="cp"></span>

<span class="cp">#define		MAX_FSACOMMAND_NUM	38</span>


<span class="cm">/*</span>
<span class="cm"> *	Define the status returns. These are very unixlike although</span>
<span class="cm"> *	most are not in fact used</span>
<span class="cm"> */</span>

<span class="cp">#define		ST_OK		0</span>
<span class="cp">#define		ST_PERM		1</span>
<span class="cp">#define		ST_NOENT	2</span>
<span class="cp">#define		ST_IO		5</span>
<span class="cp">#define		ST_NXIO		6</span>
<span class="cp">#define		ST_E2BIG	7</span>
<span class="cp">#define		ST_ACCES	13</span>
<span class="cp">#define		ST_EXIST	17</span>
<span class="cp">#define		ST_XDEV		18</span>
<span class="cp">#define		ST_NODEV	19</span>
<span class="cp">#define		ST_NOTDIR	20</span>
<span class="cp">#define		ST_ISDIR	21</span>
<span class="cp">#define		ST_INVAL	22</span>
<span class="cp">#define		ST_FBIG		27</span>
<span class="cp">#define		ST_NOSPC	28</span>
<span class="cp">#define		ST_ROFS		30</span>
<span class="cp">#define		ST_MLINK	31</span>
<span class="cp">#define		ST_WOULDBLOCK	35</span>
<span class="cp">#define		ST_NAMETOOLONG	63</span>
<span class="cp">#define		ST_NOTEMPTY	66</span>
<span class="cp">#define		ST_DQUOT	69</span>
<span class="cp">#define		ST_STALE	70</span>
<span class="cp">#define		ST_REMOTE	71</span>
<span class="cp">#define		ST_NOT_READY	72</span>
<span class="cp">#define		ST_BADHANDLE	10001</span>
<span class="cp">#define		ST_NOT_SYNC	10002</span>
<span class="cp">#define		ST_BAD_COOKIE	10003</span>
<span class="cp">#define		ST_NOTSUPP	10004</span>
<span class="cp">#define		ST_TOOSMALL	10005</span>
<span class="cp">#define		ST_SERVERFAULT	10006</span>
<span class="cp">#define		ST_BADTYPE	10007</span>
<span class="cp">#define		ST_JUKEBOX	10008</span>
<span class="cp">#define		ST_NOTMOUNTED	10009</span>
<span class="cp">#define		ST_MAINTMODE	10010</span>
<span class="cp">#define		ST_STALEACL	10011</span>

<span class="cm">/*</span>
<span class="cm"> *	On writes how does the client want the data written.</span>
<span class="cm"> */</span>

<span class="cp">#define	CACHE_CSTABLE		1</span>
<span class="cp">#define CACHE_UNSTABLE		2</span>

<span class="cm">/*</span>
<span class="cm"> *	Lets the client know at which level the data was committed on</span>
<span class="cm"> *	a write request</span>
<span class="cm"> */</span>

<span class="cp">#define	CMFILE_SYNCH_NVRAM	1</span>
<span class="cp">#define	CMDATA_SYNCH_NVRAM	2</span>
<span class="cp">#define	CMFILE_SYNCH		3</span>
<span class="cp">#define CMDATA_SYNCH		4</span>
<span class="cp">#define CMUNSTABLE		5</span>

<span class="k">struct</span> <span class="n">aac_read</span>
<span class="p">{</span>
	<span class="n">__le32</span>		<span class="n">command</span><span class="p">;</span>
	<span class="n">__le32</span>		<span class="n">cid</span><span class="p">;</span>
	<span class="n">__le32</span>		<span class="n">block</span><span class="p">;</span>
	<span class="n">__le32</span>		<span class="n">count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sgmap</span>	<span class="n">sg</span><span class="p">;</span>	<span class="c1">// Must be last in struct because it is variable</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">aac_read64</span>
<span class="p">{</span>
	<span class="n">__le32</span>		<span class="n">command</span><span class="p">;</span>
	<span class="n">__le16</span>		<span class="n">cid</span><span class="p">;</span>
	<span class="n">__le16</span>		<span class="n">sector_count</span><span class="p">;</span>
	<span class="n">__le32</span>		<span class="n">block</span><span class="p">;</span>
	<span class="n">__le16</span>		<span class="n">pad</span><span class="p">;</span>
	<span class="n">__le16</span>		<span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sgmap64</span>	<span class="n">sg</span><span class="p">;</span>	<span class="c1">// Must be last in struct because it is variable</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">aac_read_reply</span>
<span class="p">{</span>
	<span class="n">__le32</span>		<span class="n">status</span><span class="p">;</span>
	<span class="n">__le32</span>		<span class="n">count</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">aac_write</span>
<span class="p">{</span>
	<span class="n">__le32</span>		<span class="n">command</span><span class="p">;</span>
	<span class="n">__le32</span>		<span class="n">cid</span><span class="p">;</span>
	<span class="n">__le32</span>		<span class="n">block</span><span class="p">;</span>
	<span class="n">__le32</span>		<span class="n">count</span><span class="p">;</span>
	<span class="n">__le32</span>		<span class="n">stable</span><span class="p">;</span>	<span class="c1">// Not used</span>
	<span class="k">struct</span> <span class="n">sgmap</span>	<span class="n">sg</span><span class="p">;</span>	<span class="c1">// Must be last in struct because it is variable</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">aac_write64</span>
<span class="p">{</span>
	<span class="n">__le32</span>		<span class="n">command</span><span class="p">;</span>
	<span class="n">__le16</span>		<span class="n">cid</span><span class="p">;</span>
	<span class="n">__le16</span>		<span class="n">sector_count</span><span class="p">;</span>
	<span class="n">__le32</span>		<span class="n">block</span><span class="p">;</span>
	<span class="n">__le16</span>		<span class="n">pad</span><span class="p">;</span>
	<span class="n">__le16</span>		<span class="n">flags</span><span class="p">;</span>
<span class="cp">#define	IO_TYPE_WRITE 0x00000000</span>
<span class="cp">#define	IO_TYPE_READ  0x00000001</span>
<span class="cp">#define	IO_SUREWRITE  0x00000008</span>
	<span class="k">struct</span> <span class="n">sgmap64</span>	<span class="n">sg</span><span class="p">;</span>	<span class="c1">// Must be last in struct because it is variable</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">aac_write_reply</span>
<span class="p">{</span>
	<span class="n">__le32</span>		<span class="n">status</span><span class="p">;</span>
	<span class="n">__le32</span>		<span class="n">count</span><span class="p">;</span>
	<span class="n">__le32</span>		<span class="n">committed</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">aac_raw_io</span>
<span class="p">{</span>
	<span class="n">__le32</span>		<span class="n">block</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="n">__le32</span>		<span class="n">count</span><span class="p">;</span>
	<span class="n">__le16</span>		<span class="n">cid</span><span class="p">;</span>
	<span class="n">__le16</span>		<span class="n">flags</span><span class="p">;</span>		<span class="cm">/* 00 W, 01 R */</span>
	<span class="n">__le16</span>		<span class="n">bpTotal</span><span class="p">;</span>	<span class="cm">/* reserved for F/W use */</span>
	<span class="n">__le16</span>		<span class="n">bpComplete</span><span class="p">;</span>	<span class="cm">/* reserved for F/W use */</span>
	<span class="k">struct</span> <span class="n">sgmapraw</span>	<span class="n">sg</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define CT_FLUSH_CACHE 129</span>
<span class="k">struct</span> <span class="n">aac_synchronize</span> <span class="p">{</span>
	<span class="n">__le32</span>		<span class="n">command</span><span class="p">;</span>	<span class="cm">/* VM_ContainerConfig */</span>
	<span class="n">__le32</span>		<span class="n">type</span><span class="p">;</span>		<span class="cm">/* CT_FLUSH_CACHE */</span>
	<span class="n">__le32</span>		<span class="n">cid</span><span class="p">;</span>
	<span class="n">__le32</span>		<span class="n">parm1</span><span class="p">;</span>
	<span class="n">__le32</span>		<span class="n">parm2</span><span class="p">;</span>
	<span class="n">__le32</span>		<span class="n">parm3</span><span class="p">;</span>
	<span class="n">__le32</span>		<span class="n">parm4</span><span class="p">;</span>
	<span class="n">__le32</span>		<span class="n">count</span><span class="p">;</span>	<span class="cm">/* sizeof(((struct aac_synchronize_reply *)NULL)-&gt;data) */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">aac_synchronize_reply</span> <span class="p">{</span>
	<span class="n">__le32</span>		<span class="n">dummy0</span><span class="p">;</span>
	<span class="n">__le32</span>		<span class="n">dummy1</span><span class="p">;</span>
	<span class="n">__le32</span>		<span class="n">status</span><span class="p">;</span>	<span class="cm">/* CT_OK */</span>
	<span class="n">__le32</span>		<span class="n">parm1</span><span class="p">;</span>
	<span class="n">__le32</span>		<span class="n">parm2</span><span class="p">;</span>
	<span class="n">__le32</span>		<span class="n">parm3</span><span class="p">;</span>
	<span class="n">__le32</span>		<span class="n">parm4</span><span class="p">;</span>
	<span class="n">__le32</span>		<span class="n">parm5</span><span class="p">;</span>
	<span class="n">u8</span>		<span class="n">data</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
<span class="p">};</span>

<span class="cp">#define CT_POWER_MANAGEMENT	245</span>
<span class="cp">#define CT_PM_START_UNIT	2</span>
<span class="cp">#define CT_PM_STOP_UNIT		3</span>
<span class="cp">#define CT_PM_UNIT_IMMEDIATE	1</span>
<span class="k">struct</span> <span class="n">aac_power_management</span> <span class="p">{</span>
	<span class="n">__le32</span>		<span class="n">command</span><span class="p">;</span>	<span class="cm">/* VM_ContainerConfig */</span>
	<span class="n">__le32</span>		<span class="n">type</span><span class="p">;</span>		<span class="cm">/* CT_POWER_MANAGEMENT */</span>
	<span class="n">__le32</span>		<span class="n">sub</span><span class="p">;</span>		<span class="cm">/* CT_PM_* */</span>
	<span class="n">__le32</span>		<span class="n">cid</span><span class="p">;</span>
	<span class="n">__le32</span>		<span class="n">parm</span><span class="p">;</span>		<span class="cm">/* CT_PM_sub_* */</span>
<span class="p">};</span>

<span class="cp">#define CT_PAUSE_IO    65</span>
<span class="cp">#define CT_RELEASE_IO  66</span>
<span class="k">struct</span> <span class="n">aac_pause</span> <span class="p">{</span>
	<span class="n">__le32</span>		<span class="n">command</span><span class="p">;</span>	<span class="cm">/* VM_ContainerConfig */</span>
	<span class="n">__le32</span>		<span class="n">type</span><span class="p">;</span>		<span class="cm">/* CT_PAUSE_IO */</span>
	<span class="n">__le32</span>		<span class="n">timeout</span><span class="p">;</span>	<span class="cm">/* 10ms ticks */</span>
	<span class="n">__le32</span>		<span class="n">min</span><span class="p">;</span>
	<span class="n">__le32</span>		<span class="n">noRescan</span><span class="p">;</span>
	<span class="n">__le32</span>		<span class="n">parm3</span><span class="p">;</span>
	<span class="n">__le32</span>		<span class="n">parm4</span><span class="p">;</span>
	<span class="n">__le32</span>		<span class="n">count</span><span class="p">;</span>	<span class="cm">/* sizeof(((struct aac_pause_reply *)NULL)-&gt;data) */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">aac_srb</span>
<span class="p">{</span>
	<span class="n">__le32</span>		<span class="n">function</span><span class="p">;</span>
	<span class="n">__le32</span>		<span class="n">channel</span><span class="p">;</span>
	<span class="n">__le32</span>		<span class="n">id</span><span class="p">;</span>
	<span class="n">__le32</span>		<span class="n">lun</span><span class="p">;</span>
	<span class="n">__le32</span>		<span class="n">timeout</span><span class="p">;</span>
	<span class="n">__le32</span>		<span class="n">flags</span><span class="p">;</span>
	<span class="n">__le32</span>		<span class="n">count</span><span class="p">;</span>		<span class="c1">// Data xfer size</span>
	<span class="n">__le32</span>		<span class="n">retry_limit</span><span class="p">;</span>
	<span class="n">__le32</span>		<span class="n">cdb_size</span><span class="p">;</span>
	<span class="n">u8</span>		<span class="n">cdb</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
	<span class="k">struct</span>	<span class="n">sgmap</span>	<span class="n">sg</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * This and associated data structs are used by the</span>
<span class="cm"> * ioctl caller and are in cpu order.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">user_aac_srb</span>
<span class="p">{</span>
	<span class="n">u32</span>		<span class="n">function</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="n">channel</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="n">id</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="n">lun</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="n">timeout</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="n">flags</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="n">count</span><span class="p">;</span>		<span class="c1">// Data xfer size</span>
	<span class="n">u32</span>		<span class="n">retry_limit</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="n">cdb_size</span><span class="p">;</span>
	<span class="n">u8</span>		<span class="n">cdb</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
	<span class="k">struct</span>	<span class="n">user_sgmap</span>	<span class="n">sg</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define		AAC_SENSE_BUFFERSIZE	 30</span>

<span class="k">struct</span> <span class="n">aac_srb_reply</span>
<span class="p">{</span>
	<span class="n">__le32</span>		<span class="n">status</span><span class="p">;</span>
	<span class="n">__le32</span>		<span class="n">srb_status</span><span class="p">;</span>
	<span class="n">__le32</span>		<span class="n">scsi_status</span><span class="p">;</span>
	<span class="n">__le32</span>		<span class="n">data_xfer_length</span><span class="p">;</span>
	<span class="n">__le32</span>		<span class="n">sense_data_size</span><span class="p">;</span>
	<span class="n">u8</span>		<span class="n">sense_data</span><span class="p">[</span><span class="n">AAC_SENSE_BUFFERSIZE</span><span class="p">];</span> <span class="c1">// Can this be SCSI_SENSE_BUFFERSIZE</span>
<span class="p">};</span>
<span class="cm">/*</span>
<span class="cm"> * SRB Flags</span>
<span class="cm"> */</span>
<span class="cp">#define		SRB_NoDataXfer		 0x0000</span>
<span class="cp">#define		SRB_DisableDisconnect	 0x0004</span>
<span class="cp">#define		SRB_DisableSynchTransfer 0x0008</span>
<span class="cp">#define		SRB_BypassFrozenQueue	 0x0010</span>
<span class="cp">#define		SRB_DisableAutosense	 0x0020</span>
<span class="cp">#define		SRB_DataIn		 0x0040</span>
<span class="cp">#define		SRB_DataOut		 0x0080</span>

<span class="cm">/*</span>
<span class="cm"> * SRB Functions - set in aac_srb-&gt;function</span>
<span class="cm"> */</span>
<span class="cp">#define	SRBF_ExecuteScsi	0x0000</span>
<span class="cp">#define	SRBF_ClaimDevice	0x0001</span>
<span class="cp">#define	SRBF_IO_Control		0x0002</span>
<span class="cp">#define	SRBF_ReceiveEvent	0x0003</span>
<span class="cp">#define	SRBF_ReleaseQueue	0x0004</span>
<span class="cp">#define	SRBF_AttachDevice	0x0005</span>
<span class="cp">#define	SRBF_ReleaseDevice	0x0006</span>
<span class="cp">#define	SRBF_Shutdown		0x0007</span>
<span class="cp">#define	SRBF_Flush		0x0008</span>
<span class="cp">#define	SRBF_AbortCommand	0x0010</span>
<span class="cp">#define	SRBF_ReleaseRecovery	0x0011</span>
<span class="cp">#define	SRBF_ResetBus		0x0012</span>
<span class="cp">#define	SRBF_ResetDevice	0x0013</span>
<span class="cp">#define	SRBF_TerminateIO	0x0014</span>
<span class="cp">#define	SRBF_FlushQueue		0x0015</span>
<span class="cp">#define	SRBF_RemoveDevice	0x0016</span>
<span class="cp">#define	SRBF_DomainValidation	0x0017</span>

<span class="cm">/*</span>
<span class="cm"> * SRB SCSI Status - set in aac_srb-&gt;scsi_status</span>
<span class="cm"> */</span>
<span class="cp">#define SRB_STATUS_PENDING                  0x00</span>
<span class="cp">#define SRB_STATUS_SUCCESS                  0x01</span>
<span class="cp">#define SRB_STATUS_ABORTED                  0x02</span>
<span class="cp">#define SRB_STATUS_ABORT_FAILED             0x03</span>
<span class="cp">#define SRB_STATUS_ERROR                    0x04</span>
<span class="cp">#define SRB_STATUS_BUSY                     0x05</span>
<span class="cp">#define SRB_STATUS_INVALID_REQUEST          0x06</span>
<span class="cp">#define SRB_STATUS_INVALID_PATH_ID          0x07</span>
<span class="cp">#define SRB_STATUS_NO_DEVICE                0x08</span>
<span class="cp">#define SRB_STATUS_TIMEOUT                  0x09</span>
<span class="cp">#define SRB_STATUS_SELECTION_TIMEOUT        0x0A</span>
<span class="cp">#define SRB_STATUS_COMMAND_TIMEOUT          0x0B</span>
<span class="cp">#define SRB_STATUS_MESSAGE_REJECTED         0x0D</span>
<span class="cp">#define SRB_STATUS_BUS_RESET                0x0E</span>
<span class="cp">#define SRB_STATUS_PARITY_ERROR             0x0F</span>
<span class="cp">#define SRB_STATUS_REQUEST_SENSE_FAILED     0x10</span>
<span class="cp">#define SRB_STATUS_NO_HBA                   0x11</span>
<span class="cp">#define SRB_STATUS_DATA_OVERRUN             0x12</span>
<span class="cp">#define SRB_STATUS_UNEXPECTED_BUS_FREE      0x13</span>
<span class="cp">#define SRB_STATUS_PHASE_SEQUENCE_FAILURE   0x14</span>
<span class="cp">#define SRB_STATUS_BAD_SRB_BLOCK_LENGTH     0x15</span>
<span class="cp">#define SRB_STATUS_REQUEST_FLUSHED          0x16</span>
<span class="cp">#define SRB_STATUS_DELAYED_RETRY	    0x17</span>
<span class="cp">#define SRB_STATUS_INVALID_LUN              0x20</span>
<span class="cp">#define SRB_STATUS_INVALID_TARGET_ID        0x21</span>
<span class="cp">#define SRB_STATUS_BAD_FUNCTION             0x22</span>
<span class="cp">#define SRB_STATUS_ERROR_RECOVERY           0x23</span>
<span class="cp">#define SRB_STATUS_NOT_STARTED		    0x24</span>
<span class="cp">#define SRB_STATUS_NOT_IN_USE		    0x30</span>
<span class="cp">#define SRB_STATUS_FORCE_ABORT		    0x31</span>
<span class="cp">#define SRB_STATUS_DOMAIN_VALIDATION_FAIL   0x32</span>

<span class="cm">/*</span>
<span class="cm"> * Object-Server / Volume-Manager Dispatch Classes</span>
<span class="cm"> */</span>

<span class="cp">#define		VM_Null			0</span>
<span class="cp">#define		VM_NameServe		1</span>
<span class="cp">#define		VM_ContainerConfig	2</span>
<span class="cp">#define		VM_Ioctl		3</span>
<span class="cp">#define		VM_FilesystemIoctl	4</span>
<span class="cp">#define		VM_CloseAll		5</span>
<span class="cp">#define		VM_CtBlockRead		6</span>
<span class="cp">#define		VM_CtBlockWrite		7</span>
<span class="cp">#define		VM_SliceBlockRead	8	</span><span class="cm">/* raw access to configured &quot;storage objects&quot; */</span><span class="cp"></span>
<span class="cp">#define		VM_SliceBlockWrite	9</span>
<span class="cp">#define		VM_DriveBlockRead	10	</span><span class="cm">/* raw access to physical devices */</span><span class="cp"></span>
<span class="cp">#define		VM_DriveBlockWrite	11</span>
<span class="cp">#define		VM_EnclosureMgt		12	</span><span class="cm">/* enclosure management */</span><span class="cp"></span>
<span class="cp">#define		VM_Unused		13	</span><span class="cm">/* used to be diskset management */</span><span class="cp"></span>
<span class="cp">#define		VM_CtBlockVerify	14</span>
<span class="cp">#define		VM_CtPerf		15	</span><span class="cm">/* performance test */</span><span class="cp"></span>
<span class="cp">#define		VM_CtBlockRead64	16</span>
<span class="cp">#define		VM_CtBlockWrite64	17</span>
<span class="cp">#define		VM_CtBlockVerify64	18</span>
<span class="cp">#define		VM_CtHostRead64		19</span>
<span class="cp">#define		VM_CtHostWrite64	20</span>
<span class="cp">#define		VM_DrvErrTblLog		21</span>
<span class="cp">#define		VM_NameServe64		22</span>

<span class="cp">#define		MAX_VMCOMMAND_NUM	23	</span><span class="cm">/* used for sizing stats array - leave last */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> *	Descriptive information (eg, vital stats)</span>
<span class="cm"> *	that a content manager might report.  The</span>
<span class="cm"> *	FileArray filesystem component is one example</span>
<span class="cm"> *	of a content manager.  Raw mode might be</span>
<span class="cm"> *	another.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">aac_fsinfo</span> <span class="p">{</span>
	<span class="n">__le32</span>  <span class="n">fsTotalSize</span><span class="p">;</span>	<span class="cm">/* Consumed by fs, incl. metadata */</span>
	<span class="n">__le32</span>  <span class="n">fsBlockSize</span><span class="p">;</span>
	<span class="n">__le32</span>  <span class="n">fsFragSize</span><span class="p">;</span>
	<span class="n">__le32</span>  <span class="n">fsMaxExtendSize</span><span class="p">;</span>
	<span class="n">__le32</span>  <span class="n">fsSpaceUnits</span><span class="p">;</span>
	<span class="n">__le32</span>  <span class="n">fsMaxNumFiles</span><span class="p">;</span>
	<span class="n">__le32</span>  <span class="n">fsNumFreeFiles</span><span class="p">;</span>
	<span class="n">__le32</span>  <span class="n">fsInodeDensity</span><span class="p">;</span>
<span class="p">};</span>	<span class="cm">/* valid iff ObjType == FT_FILESYS &amp;&amp; !(ContentState &amp; FSCS_NOTCLEAN) */</span>

<span class="k">union</span> <span class="n">aac_contentinfo</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">aac_fsinfo</span> <span class="n">filesys</span><span class="p">;</span>	<span class="cm">/* valid iff ObjType == FT_FILESYS &amp;&amp; !(ContentState &amp; FSCS_NOTCLEAN) */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *	Query for Container Configuration Status</span>
<span class="cm"> */</span>

<span class="cp">#define CT_GET_CONFIG_STATUS 147</span>
<span class="k">struct</span> <span class="n">aac_get_config_status</span> <span class="p">{</span>
	<span class="n">__le32</span>		<span class="n">command</span><span class="p">;</span>	<span class="cm">/* VM_ContainerConfig */</span>
	<span class="n">__le32</span>		<span class="n">type</span><span class="p">;</span>		<span class="cm">/* CT_GET_CONFIG_STATUS */</span>
	<span class="n">__le32</span>		<span class="n">parm1</span><span class="p">;</span>
	<span class="n">__le32</span>		<span class="n">parm2</span><span class="p">;</span>
	<span class="n">__le32</span>		<span class="n">parm3</span><span class="p">;</span>
	<span class="n">__le32</span>		<span class="n">parm4</span><span class="p">;</span>
	<span class="n">__le32</span>		<span class="n">parm5</span><span class="p">;</span>
	<span class="n">__le32</span>		<span class="n">count</span><span class="p">;</span>	<span class="cm">/* sizeof(((struct aac_get_config_status_resp *)NULL)-&gt;data) */</span>
<span class="p">};</span>

<span class="cp">#define CFACT_CONTINUE 0</span>
<span class="cp">#define CFACT_PAUSE    1</span>
<span class="cp">#define CFACT_ABORT    2</span>
<span class="k">struct</span> <span class="n">aac_get_config_status_resp</span> <span class="p">{</span>
	<span class="n">__le32</span>		<span class="n">response</span><span class="p">;</span> <span class="cm">/* ST_OK */</span>
	<span class="n">__le32</span>		<span class="n">dummy0</span><span class="p">;</span>
	<span class="n">__le32</span>		<span class="n">status</span><span class="p">;</span>	<span class="cm">/* CT_OK */</span>
	<span class="n">__le32</span>		<span class="n">parm1</span><span class="p">;</span>
	<span class="n">__le32</span>		<span class="n">parm2</span><span class="p">;</span>
	<span class="n">__le32</span>		<span class="n">parm3</span><span class="p">;</span>
	<span class="n">__le32</span>		<span class="n">parm4</span><span class="p">;</span>
	<span class="n">__le32</span>		<span class="n">parm5</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">__le32</span>	<span class="n">action</span><span class="p">;</span> <span class="cm">/* CFACT_CONTINUE, CFACT_PAUSE or CFACT_ABORT */</span>
		<span class="n">__le16</span>	<span class="n">flags</span><span class="p">;</span>
		<span class="n">__le16</span>	<span class="n">count</span><span class="p">;</span>
	<span class="p">}</span>		<span class="n">data</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *	Accept the configuration as-is</span>
<span class="cm"> */</span>

<span class="cp">#define CT_COMMIT_CONFIG 152</span>

<span class="k">struct</span> <span class="n">aac_commit_config</span> <span class="p">{</span>
	<span class="n">__le32</span>		<span class="n">command</span><span class="p">;</span>	<span class="cm">/* VM_ContainerConfig */</span>
	<span class="n">__le32</span>		<span class="n">type</span><span class="p">;</span>		<span class="cm">/* CT_COMMIT_CONFIG */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *	Query for Container Configuration Status</span>
<span class="cm"> */</span>

<span class="cp">#define CT_GET_CONTAINER_COUNT 4</span>
<span class="k">struct</span> <span class="n">aac_get_container_count</span> <span class="p">{</span>
	<span class="n">__le32</span>		<span class="n">command</span><span class="p">;</span>	<span class="cm">/* VM_ContainerConfig */</span>
	<span class="n">__le32</span>		<span class="n">type</span><span class="p">;</span>		<span class="cm">/* CT_GET_CONTAINER_COUNT */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">aac_get_container_count_resp</span> <span class="p">{</span>
	<span class="n">__le32</span>		<span class="n">response</span><span class="p">;</span> <span class="cm">/* ST_OK */</span>
	<span class="n">__le32</span>		<span class="n">dummy0</span><span class="p">;</span>
	<span class="n">__le32</span>		<span class="n">MaxContainers</span><span class="p">;</span>
	<span class="n">__le32</span>		<span class="n">ContainerSwitchEntries</span><span class="p">;</span>
	<span class="n">__le32</span>		<span class="n">MaxPartitions</span><span class="p">;</span>
<span class="p">};</span>


<span class="cm">/*</span>
<span class="cm"> *	Query for &quot;mountable&quot; objects, ie, objects that are typically</span>
<span class="cm"> *	associated with a drive letter on the client (host) side.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">aac_mntent</span> <span class="p">{</span>
	<span class="n">__le32</span>			<span class="n">oid</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">name</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>	<span class="cm">/* if applicable */</span>
	<span class="k">struct</span> <span class="n">creation_info</span>	<span class="n">create_info</span><span class="p">;</span>	<span class="cm">/* if applicable */</span>
	<span class="n">__le32</span>			<span class="n">capacity</span><span class="p">;</span>
	<span class="n">__le32</span>			<span class="n">vol</span><span class="p">;</span>		<span class="cm">/* substrate structure */</span>
	<span class="n">__le32</span>			<span class="n">obj</span><span class="p">;</span>		<span class="cm">/* FT_FILESYS, etc. */</span>
	<span class="n">__le32</span>			<span class="n">state</span><span class="p">;</span>		<span class="cm">/* unready for mounting,</span>
<span class="cm">						   readonly, etc. */</span>
	<span class="k">union</span> <span class="n">aac_contentinfo</span>	<span class="n">fileinfo</span><span class="p">;</span>	<span class="cm">/* Info specific to content</span>
<span class="cm">						   manager (eg, filesystem) */</span>
	<span class="n">__le32</span>			<span class="n">altoid</span><span class="p">;</span>		<span class="cm">/* != oid &lt;==&gt; snapshot or</span>
<span class="cm">						   broken mirror exists */</span>
	<span class="n">__le32</span>			<span class="n">capacityhigh</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define FSCS_NOTCLEAN	0x0001  </span><span class="cm">/* fsck is necessary before mounting */</span><span class="cp"></span>
<span class="cp">#define FSCS_READONLY	0x0002	</span><span class="cm">/* possible result of broken mirror */</span><span class="cp"></span>
<span class="cp">#define FSCS_HIDDEN	0x0004	</span><span class="cm">/* should be ignored - set during a clear */</span><span class="cp"></span>
<span class="cp">#define FSCS_NOT_READY	0x0008	</span><span class="cm">/* Array spinning up to fulfil request */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">aac_query_mount</span> <span class="p">{</span>
	<span class="n">__le32</span>		<span class="n">command</span><span class="p">;</span>
	<span class="n">__le32</span>		<span class="n">type</span><span class="p">;</span>
	<span class="n">__le32</span>		<span class="n">count</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">aac_mount</span> <span class="p">{</span>
	<span class="n">__le32</span>		<span class="n">status</span><span class="p">;</span>
	<span class="n">__le32</span>		<span class="n">type</span><span class="p">;</span>           <span class="cm">/* should be same as that requested */</span>
	<span class="n">__le32</span>		<span class="n">count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">aac_mntent</span> <span class="n">mnt</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">};</span>

<span class="cp">#define CT_READ_NAME 130</span>
<span class="k">struct</span> <span class="n">aac_get_name</span> <span class="p">{</span>
	<span class="n">__le32</span>		<span class="n">command</span><span class="p">;</span>	<span class="cm">/* VM_ContainerConfig */</span>
	<span class="n">__le32</span>		<span class="n">type</span><span class="p">;</span>		<span class="cm">/* CT_READ_NAME */</span>
	<span class="n">__le32</span>		<span class="n">cid</span><span class="p">;</span>
	<span class="n">__le32</span>		<span class="n">parm1</span><span class="p">;</span>
	<span class="n">__le32</span>		<span class="n">parm2</span><span class="p">;</span>
	<span class="n">__le32</span>		<span class="n">parm3</span><span class="p">;</span>
	<span class="n">__le32</span>		<span class="n">parm4</span><span class="p">;</span>
	<span class="n">__le32</span>		<span class="n">count</span><span class="p">;</span>	<span class="cm">/* sizeof(((struct aac_get_name_resp *)NULL)-&gt;data) */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">aac_get_name_resp</span> <span class="p">{</span>
	<span class="n">__le32</span>		<span class="n">dummy0</span><span class="p">;</span>
	<span class="n">__le32</span>		<span class="n">dummy1</span><span class="p">;</span>
	<span class="n">__le32</span>		<span class="n">status</span><span class="p">;</span>	<span class="cm">/* CT_OK */</span>
	<span class="n">__le32</span>		<span class="n">parm1</span><span class="p">;</span>
	<span class="n">__le32</span>		<span class="n">parm2</span><span class="p">;</span>
	<span class="n">__le32</span>		<span class="n">parm3</span><span class="p">;</span>
	<span class="n">__le32</span>		<span class="n">parm4</span><span class="p">;</span>
	<span class="n">__le32</span>		<span class="n">parm5</span><span class="p">;</span>
	<span class="n">u8</span>		<span class="n">data</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
<span class="p">};</span>

<span class="cp">#define CT_CID_TO_32BITS_UID 165</span>
<span class="k">struct</span> <span class="n">aac_get_serial</span> <span class="p">{</span>
	<span class="n">__le32</span>		<span class="n">command</span><span class="p">;</span>	<span class="cm">/* VM_ContainerConfig */</span>
	<span class="n">__le32</span>		<span class="n">type</span><span class="p">;</span>		<span class="cm">/* CT_CID_TO_32BITS_UID */</span>
	<span class="n">__le32</span>		<span class="n">cid</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">aac_get_serial_resp</span> <span class="p">{</span>
	<span class="n">__le32</span>		<span class="n">dummy0</span><span class="p">;</span>
	<span class="n">__le32</span>		<span class="n">dummy1</span><span class="p">;</span>
	<span class="n">__le32</span>		<span class="n">status</span><span class="p">;</span>	<span class="cm">/* CT_OK */</span>
	<span class="n">__le32</span>		<span class="n">uid</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * The following command is sent to shut down each container.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">aac_close</span> <span class="p">{</span>
	<span class="n">__le32</span>	<span class="n">command</span><span class="p">;</span>
	<span class="n">__le32</span>	<span class="n">cid</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">aac_query_disk</span>
<span class="p">{</span>
	<span class="n">s32</span>	<span class="n">cnum</span><span class="p">;</span>
	<span class="n">s32</span>	<span class="n">bus</span><span class="p">;</span>
	<span class="n">s32</span>	<span class="n">id</span><span class="p">;</span>
	<span class="n">s32</span>	<span class="n">lun</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">valid</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">locked</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">deleted</span><span class="p">;</span>
	<span class="n">s32</span>	<span class="n">instance</span><span class="p">;</span>
	<span class="n">s8</span>	<span class="n">name</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
	<span class="n">u32</span>	<span class="n">unmapped</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">aac_delete_disk</span> <span class="p">{</span>
	<span class="n">u32</span>	<span class="n">disknum</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">cnum</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">fib_ioctl</span>
<span class="p">{</span>
	<span class="n">u32</span>	<span class="n">fibctx</span><span class="p">;</span>
	<span class="n">s32</span>	<span class="n">wait</span><span class="p">;</span>
	<span class="kt">char</span>	<span class="n">__user</span> <span class="o">*</span><span class="n">fib</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">revision</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">compat</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">version</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">build</span><span class="p">;</span>
<span class="p">};</span>


<span class="cm">/*</span>
<span class="cm"> *	Ugly - non Linux like ioctl coding for back compat.</span>
<span class="cm"> */</span>

<span class="cp">#define CTL_CODE(function, method) (                 \</span>
<span class="cp">    (4&lt;&lt; 16) | ((function) &lt;&lt; 2) | (method) \</span>
<span class="cp">)</span>

<span class="cm">/*</span>
<span class="cm"> *	Define the method codes for how buffers are passed for I/O and FS</span>
<span class="cm"> *	controls</span>
<span class="cm"> */</span>

<span class="cp">#define METHOD_BUFFERED                 0</span>
<span class="cp">#define METHOD_NEITHER                  3</span>

<span class="cm">/*</span>
<span class="cm"> *	Filesystem ioctls</span>
<span class="cm"> */</span>

<span class="cp">#define FSACTL_SENDFIB				CTL_CODE(2050, METHOD_BUFFERED)</span>
<span class="cp">#define FSACTL_SEND_RAW_SRB			CTL_CODE(2067, METHOD_BUFFERED)</span>
<span class="cp">#define FSACTL_DELETE_DISK			0x163</span>
<span class="cp">#define FSACTL_QUERY_DISK			0x173</span>
<span class="cp">#define FSACTL_OPEN_GET_ADAPTER_FIB		CTL_CODE(2100, METHOD_BUFFERED)</span>
<span class="cp">#define FSACTL_GET_NEXT_ADAPTER_FIB		CTL_CODE(2101, METHOD_BUFFERED)</span>
<span class="cp">#define FSACTL_CLOSE_GET_ADAPTER_FIB		CTL_CODE(2102, METHOD_BUFFERED)</span>
<span class="cp">#define FSACTL_MINIPORT_REV_CHECK               CTL_CODE(2107, METHOD_BUFFERED)</span>
<span class="cp">#define FSACTL_GET_PCI_INFO			CTL_CODE(2119, METHOD_BUFFERED)</span>
<span class="cp">#define FSACTL_FORCE_DELETE_DISK		CTL_CODE(2120, METHOD_NEITHER)</span>
<span class="cp">#define FSACTL_GET_CONTAINERS			2131</span>
<span class="cp">#define FSACTL_SEND_LARGE_FIB			CTL_CODE(2138, METHOD_BUFFERED)</span>


<span class="k">struct</span> <span class="n">aac_common</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 *	If this value is set to 1 then interrupt moderation will occur</span>
<span class="cm">	 *	in the base commuication support.</span>
<span class="cm">	 */</span>
	<span class="n">u32</span> <span class="n">irq_mod</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">peak_fibs</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">zero_fibs</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">fib_timeouts</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 *	Statistical counters in debug mode</span>
<span class="cm">	 */</span>
<span class="cp">#ifdef DBG</span>
	<span class="n">u32</span> <span class="n">FibsSent</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">FibRecved</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">NoResponseSent</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">NoResponseRecved</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">AsyncSent</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">AsyncRecved</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">NormalSent</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">NormalRecved</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">aac_common</span> <span class="n">aac_config</span><span class="p">;</span>


<span class="cm">/*</span>
<span class="cm"> *	The following macro is used when sending and receiving FIBs. It is</span>
<span class="cm"> *	only used for debugging.</span>
<span class="cm"> */</span>

<span class="cp">#ifdef DBG</span>
<span class="cp">#define	FIB_COUNTER_INCREMENT(counter)		(counter)++</span>
<span class="cp">#else</span>
<span class="cp">#define	FIB_COUNTER_INCREMENT(counter)</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> *	Adapter direct commands</span>
<span class="cm"> *	Monitor/Kernel API</span>
<span class="cm"> */</span>

<span class="cp">#define	BREAKPOINT_REQUEST		0x00000004</span>
<span class="cp">#define	INIT_STRUCT_BASE_ADDRESS	0x00000005</span>
<span class="cp">#define READ_PERMANENT_PARAMETERS	0x0000000a</span>
<span class="cp">#define WRITE_PERMANENT_PARAMETERS	0x0000000b</span>
<span class="cp">#define HOST_CRASHING			0x0000000d</span>
<span class="cp">#define	SEND_SYNCHRONOUS_FIB		0x0000000c</span>
<span class="cp">#define COMMAND_POST_RESULTS		0x00000014</span>
<span class="cp">#define GET_ADAPTER_PROPERTIES		0x00000019</span>
<span class="cp">#define GET_DRIVER_BUFFER_PROPERTIES	0x00000023</span>
<span class="cp">#define RCV_TEMP_READINGS		0x00000025</span>
<span class="cp">#define GET_COMM_PREFERRED_SETTINGS	0x00000026</span>
<span class="cp">#define IOP_RESET			0x00001000</span>
<span class="cp">#define IOP_RESET_ALWAYS		0x00001001</span>
<span class="cp">#define RE_INIT_ADAPTER			0x000000ee</span>

<span class="cm">/*</span>
<span class="cm"> *	Adapter Status Register</span>
<span class="cm"> *</span>
<span class="cm"> *  Phase Staus mailbox is 32bits:</span>
<span class="cm"> *	&lt;31:16&gt; = Phase Status</span>
<span class="cm"> *	&lt;15:0&gt;  = Phase</span>
<span class="cm"> *</span>
<span class="cm"> *	The adapter reports is present state through the phase.  Only</span>
<span class="cm"> *	a single phase should be ever be set.  Each phase can have multiple</span>
<span class="cm"> *	phase status bits to provide more detailed information about the</span>
<span class="cm"> *	state of the board.  Care should be taken to ensure that any phase</span>
<span class="cm"> *	status bits that are set when changing the phase are also valid</span>
<span class="cm"> *	for the new phase or be cleared out.  Adapter software (monitor,</span>
<span class="cm"> *	iflash, kernel) is responsible for properly maintining the phase</span>
<span class="cm"> *	status mailbox when it is running.</span>
<span class="cm"> *</span>
<span class="cm"> *	MONKER_API Phases</span>
<span class="cm"> *</span>
<span class="cm"> *	Phases are bit oriented.  It is NOT valid  to have multiple bits set</span>
<span class="cm"> */</span>

<span class="cp">#define	SELF_TEST_FAILED		0x00000004</span>
<span class="cp">#define	MONITOR_PANIC			0x00000020</span>
<span class="cp">#define	KERNEL_UP_AND_RUNNING		0x00000080</span>
<span class="cp">#define	KERNEL_PANIC			0x00000100</span>

<span class="cm">/*</span>
<span class="cm"> *	Doorbell bit defines</span>
<span class="cm"> */</span>

<span class="cp">#define DoorBellSyncCmdAvailable	(1&lt;&lt;0)	</span><span class="cm">/* Host -&gt; Adapter */</span><span class="cp"></span>
<span class="cp">#define DoorBellPrintfDone		(1&lt;&lt;5)	</span><span class="cm">/* Host -&gt; Adapter */</span><span class="cp"></span>
<span class="cp">#define DoorBellAdapterNormCmdReady	(1&lt;&lt;1)	</span><span class="cm">/* Adapter -&gt; Host */</span><span class="cp"></span>
<span class="cp">#define DoorBellAdapterNormRespReady	(1&lt;&lt;2)	</span><span class="cm">/* Adapter -&gt; Host */</span><span class="cp"></span>
<span class="cp">#define DoorBellAdapterNormCmdNotFull	(1&lt;&lt;3)	</span><span class="cm">/* Adapter -&gt; Host */</span><span class="cp"></span>
<span class="cp">#define DoorBellAdapterNormRespNotFull	(1&lt;&lt;4)	</span><span class="cm">/* Adapter -&gt; Host */</span><span class="cp"></span>
<span class="cp">#define DoorBellPrintfReady		(1&lt;&lt;5)	</span><span class="cm">/* Adapter -&gt; Host */</span><span class="cp"></span>
<span class="cp">#define DoorBellAifPending		(1&lt;&lt;6)	</span><span class="cm">/* Adapter -&gt; Host */</span><span class="cp"></span>

<span class="cm">/* PMC specific outbound doorbell bits */</span>
<span class="cp">#define PmDoorBellResponseSent		(1&lt;&lt;1)	</span><span class="cm">/* Adapter -&gt; Host */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> *	For FIB communication, we need all of the following things</span>
<span class="cm"> *	to send back to the user.</span>
<span class="cm"> */</span>

<span class="cp">#define		AifCmdEventNotify	1	</span><span class="cm">/* Notify of event */</span><span class="cp"></span>
<span class="cp">#define			AifEnConfigChange	3	</span><span class="cm">/* Adapter configuration change */</span><span class="cp"></span>
<span class="cp">#define			AifEnContainerChange	4	</span><span class="cm">/* Container configuration change */</span><span class="cp"></span>
<span class="cp">#define			AifEnDeviceFailure	5	</span><span class="cm">/* SCSI device failed */</span><span class="cp"></span>
<span class="cp">#define			AifEnEnclosureManagement 13	</span><span class="cm">/* EM_DRIVE_* */</span><span class="cp"></span>
<span class="cp">#define				EM_DRIVE_INSERTION	31</span>
<span class="cp">#define				EM_DRIVE_REMOVAL	32</span>
<span class="cp">#define			AifEnBatteryEvent	14	</span><span class="cm">/* Change in Battery State */</span><span class="cp"></span>
<span class="cp">#define			AifEnAddContainer	15	</span><span class="cm">/* A new array was created */</span><span class="cp"></span>
<span class="cp">#define			AifEnDeleteContainer	16	</span><span class="cm">/* A container was deleted */</span><span class="cp"></span>
<span class="cp">#define			AifEnExpEvent		23	</span><span class="cm">/* Firmware Event Log */</span><span class="cp"></span>
<span class="cp">#define			AifExeFirmwarePanic	3	</span><span class="cm">/* Firmware Event Panic */</span><span class="cp"></span>
<span class="cp">#define			AifHighPriority		3	</span><span class="cm">/* Highest Priority Event */</span><span class="cp"></span>
<span class="cp">#define			AifEnAddJBOD		30	</span><span class="cm">/* JBOD created */</span><span class="cp"></span>
<span class="cp">#define			AifEnDeleteJBOD		31	</span><span class="cm">/* JBOD deleted */</span><span class="cp"></span>

<span class="cp">#define		AifCmdJobProgress	2	</span><span class="cm">/* Progress report */</span><span class="cp"></span>
<span class="cp">#define			AifJobCtrZero	101	</span><span class="cm">/* Array Zero progress */</span><span class="cp"></span>
<span class="cp">#define			AifJobStsSuccess 1	</span><span class="cm">/* Job completes */</span><span class="cp"></span>
<span class="cp">#define			AifJobStsRunning 102	</span><span class="cm">/* Job running */</span><span class="cp"></span>
<span class="cp">#define		AifCmdAPIReport		3	</span><span class="cm">/* Report from other user of API */</span><span class="cp"></span>
<span class="cp">#define		AifCmdDriverNotify	4	</span><span class="cm">/* Notify host driver of event */</span><span class="cp"></span>
<span class="cp">#define			AifDenMorphComplete 200	</span><span class="cm">/* A morph operation completed */</span><span class="cp"></span>
<span class="cp">#define			AifDenVolumeExtendComplete 201 </span><span class="cm">/* A volume extend completed */</span><span class="cp"></span>
<span class="cp">#define		AifReqJobList		100	</span><span class="cm">/* Gets back complete job list */</span><span class="cp"></span>
<span class="cp">#define		AifReqJobsForCtr	101	</span><span class="cm">/* Gets back jobs for specific container */</span><span class="cp"></span>
<span class="cp">#define		AifReqJobsForScsi	102	</span><span class="cm">/* Gets back jobs for specific SCSI device */</span><span class="cp"></span>
<span class="cp">#define		AifReqJobReport		103	</span><span class="cm">/* Gets back a specific job report or list of them */</span><span class="cp"></span>
<span class="cp">#define		AifReqTerminateJob	104	</span><span class="cm">/* Terminates job */</span><span class="cp"></span>
<span class="cp">#define		AifReqSuspendJob	105	</span><span class="cm">/* Suspends a job */</span><span class="cp"></span>
<span class="cp">#define		AifReqResumeJob		106	</span><span class="cm">/* Resumes a job */</span><span class="cp"></span>
<span class="cp">#define		AifReqSendAPIReport	107	</span><span class="cm">/* API generic report requests */</span><span class="cp"></span>
<span class="cp">#define		AifReqAPIJobStart	108	</span><span class="cm">/* Start a job from the API */</span><span class="cp"></span>
<span class="cp">#define		AifReqAPIJobUpdate	109	</span><span class="cm">/* Update a job report from the API */</span><span class="cp"></span>
<span class="cp">#define		AifReqAPIJobFinish	110	</span><span class="cm">/* Finish a job from the API */</span><span class="cp"></span>

<span class="cm">/* PMC NEW COMM: Request the event data */</span>
<span class="cp">#define		AifReqEvent		200</span>

<span class="cm">/*</span>
<span class="cm"> *	Adapter Initiated FIB command structures. Start with the adapter</span>
<span class="cm"> *	initiated FIBs that really come from the adapter, and get responded</span>
<span class="cm"> *	to by the host.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">aac_aifcmd</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">command</span><span class="p">;</span>		<span class="cm">/* Tell host what type of notify this is */</span>
	<span class="n">__le32</span> <span class="n">seqnum</span><span class="p">;</span>		<span class="cm">/* To allow ordering of reports (if necessary) */</span>
	<span class="n">u8</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>		<span class="cm">/* Undefined length (from kernel viewpoint) */</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> *	Convert capacity to cylinders</span>
<span class="cm"> *	accounting for the fact capacity could be a 64 bit value</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">cap_to_cyls</span><span class="p">(</span><span class="n">sector_t</span> <span class="n">capacity</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">divisor</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sector_div</span><span class="p">(</span><span class="n">capacity</span><span class="p">,</span> <span class="n">divisor</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">capacity</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* SCp.phase values */</span>
<span class="cp">#define AAC_OWNER_MIDLEVEL	0x101</span>
<span class="cp">#define AAC_OWNER_LOWLEVEL	0x102</span>
<span class="cp">#define AAC_OWNER_ERROR_HANDLER	0x103</span>
<span class="cp">#define AAC_OWNER_FIRMWARE	0x106</span>

<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">aac_driverinfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">fib</span> <span class="o">*</span><span class="n">aac_fib_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">aac_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">aac_fib_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">aac_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">aac_fib_map_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">aac_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">aac_fib_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">fib</span> <span class="o">*</span> <span class="n">context</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">aac_fib_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">fib</span> <span class="o">*</span> <span class="n">context</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">aac_printf</span><span class="p">(</span><span class="k">struct</span> <span class="n">aac_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">aac_fib_send</span><span class="p">(</span><span class="n">u16</span> <span class="n">command</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fib</span> <span class="o">*</span> <span class="n">context</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">priority</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wait</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reply</span><span class="p">,</span> <span class="n">fib_callback</span> <span class="n">callback</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">aac_consumer_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">aac_dev</span> <span class="o">*</span> <span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">aac_queue</span> <span class="o">*</span> <span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">aac_entry</span> <span class="o">**</span><span class="n">entry</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">aac_consumer_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">aac_dev</span> <span class="o">*</span> <span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">aac_queue</span> <span class="o">*</span> <span class="n">q</span><span class="p">,</span> <span class="n">u32</span> <span class="n">qnum</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">aac_fib_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">fib</span> <span class="o">*</span> <span class="n">context</span><span class="p">);</span>
<span class="cp">#define fib_data(fibctx) ((void *)(fibctx)-&gt;hw_fib_va-&gt;data)</span>
<span class="k">struct</span> <span class="n">aac_dev</span> <span class="o">*</span><span class="n">aac_init_adapter</span><span class="p">(</span><span class="k">struct</span> <span class="n">aac_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">aac_get_config_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">aac_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">commit_flag</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">aac_get_containers</span><span class="p">(</span><span class="k">struct</span> <span class="n">aac_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">aac_scsi_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">aac_dev_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">aac_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">arg</span><span class="p">);</span>
<span class="cp">#ifndef shost_to_class</span>
<span class="cp">#define shost_to_class(shost) &amp;shost-&gt;shost_dev</span>
<span class="cp">#endif</span>
<span class="kt">ssize_t</span> <span class="n">aac_get_serial_number</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">aac_do_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">aac_dev</span> <span class="o">*</span> <span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">arg</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">aac_rx_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">aac_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">aac_rkt_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">aac_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">aac_nark_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">aac_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">aac_sa_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">aac_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">aac_src_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">aac_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">aac_srcv_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">aac_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">aac_queue_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">aac_dev</span> <span class="o">*</span> <span class="n">dev</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span> <span class="n">index</span><span class="p">,</span> <span class="n">u32</span> <span class="n">qid</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hw_fib</span> <span class="o">*</span> <span class="n">hw_fib</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wait</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fib</span> <span class="o">*</span> <span class="n">fibptr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">nonotify</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">aac_response_normal</span><span class="p">(</span><span class="k">struct</span> <span class="n">aac_queue</span> <span class="o">*</span> <span class="n">q</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">aac_command_normal</span><span class="p">(</span><span class="k">struct</span> <span class="n">aac_queue</span> <span class="o">*</span> <span class="n">q</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">aac_intr_normal</span><span class="p">(</span><span class="k">struct</span> <span class="n">aac_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u32</span> <span class="n">Index</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">isAif</span><span class="p">,</span> <span class="kt">int</span> <span class="n">isFastResponse</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">hw_fib</span> <span class="o">*</span><span class="n">aif_fib</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">aac_reset_adapter</span><span class="p">(</span><span class="k">struct</span> <span class="n">aac_dev</span> <span class="o">*</span> <span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">forced</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">aac_check_health</span><span class="p">(</span><span class="k">struct</span> <span class="n">aac_dev</span> <span class="o">*</span> <span class="n">dev</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">aac_command_thread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">aac_close_fib_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">aac_dev</span> <span class="o">*</span> <span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">aac_fib_context</span> <span class="o">*</span><span class="n">fibctx</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">aac_fib_adapter_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">fib</span> <span class="o">*</span> <span class="n">fibptr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">size</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">aac_driver_ident</span><span class="o">*</span> <span class="n">aac_get_driver_ident</span><span class="p">(</span><span class="kt">int</span> <span class="n">devtype</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">aac_get_adapter_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">aac_dev</span><span class="o">*</span> <span class="n">dev</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">aac_send_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">aac_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">aac_probe_container</span><span class="p">(</span><span class="k">struct</span> <span class="n">aac_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cid</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">_aac_rx_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">aac_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">aac_rx_select_comm</span><span class="p">(</span><span class="k">struct</span> <span class="n">aac_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">comm</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">aac_rx_deliver_producer</span><span class="p">(</span><span class="k">struct</span> <span class="n">fib</span> <span class="o">*</span> <span class="n">fib</span><span class="p">);</span>
<span class="kt">char</span> <span class="o">*</span> <span class="n">get_container_type</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">type</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">numacb</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">acbsize</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">char</span> <span class="n">aac_driver_version</span><span class="p">[];</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">startup_timeout</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">aif_timeout</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">expose_physicals</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">aac_reset_devices</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">aac_msi</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">aac_commit</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">update_interval</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">check_interval</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">aac_check_reset</span><span class="p">;</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
