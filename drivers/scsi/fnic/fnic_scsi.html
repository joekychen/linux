<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › scsi › fnic › fnic_scsi.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>fnic_scsi.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright 2008 Cisco Systems, Inc.  All rights reserved.</span>
<span class="cm"> * Copyright 2007 Nuova Systems, Inc.  All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you may redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; version 2 of the License.</span>
<span class="cm"> *</span>
<span class="cm"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,</span>
<span class="cm"> * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span>
<span class="cm"> * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND</span>
<span class="cm"> * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS</span>
<span class="cm"> * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN</span>
<span class="cm"> * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN</span>
<span class="cm"> * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE</span>
<span class="cm"> * SOFTWARE.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/mempool.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/scatterlist.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/if_ether.h&gt;</span>
<span class="cp">#include &lt;linux/if_vlan.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/gfp.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_host.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_device.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_cmnd.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_tcq.h&gt;</span>
<span class="cp">#include &lt;scsi/fc/fc_els.h&gt;</span>
<span class="cp">#include &lt;scsi/fc/fc_fcoe.h&gt;</span>
<span class="cp">#include &lt;scsi/libfc.h&gt;</span>
<span class="cp">#include &lt;scsi/fc_frame.h&gt;</span>
<span class="cp">#include &quot;fnic_io.h&quot;</span>
<span class="cp">#include &quot;fnic.h&quot;</span>

<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fnic_state_str</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">FNIC_IN_FC_MODE</span><span class="p">]</span> <span class="o">=</span>           <span class="s">&quot;FNIC_IN_FC_MODE&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">FNIC_IN_FC_TRANS_ETH_MODE</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;FNIC_IN_FC_TRANS_ETH_MODE&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">FNIC_IN_ETH_MODE</span><span class="p">]</span> <span class="o">=</span>          <span class="s">&quot;FNIC_IN_ETH_MODE&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">FNIC_IN_ETH_TRANS_FC_MODE</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;FNIC_IN_ETH_TRANS_FC_MODE&quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fnic_ioreq_state_str</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">FNIC_IOREQ_CMD_PENDING</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;FNIC_IOREQ_CMD_PENDING&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">FNIC_IOREQ_ABTS_PENDING</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;FNIC_IOREQ_ABTS_PENDING&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">FNIC_IOREQ_ABTS_COMPLETE</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;FNIC_IOREQ_ABTS_COMPLETE&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">FNIC_IOREQ_CMD_COMPLETE</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;FNIC_IOREQ_CMD_COMPLETE&quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fcpio_status_str</span><span class="p">[]</span> <span class="o">=</span>  <span class="p">{</span>
	<span class="p">[</span><span class="n">FCPIO_SUCCESS</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;FCPIO_SUCCESS&quot;</span><span class="p">,</span> <span class="cm">/*0x0*/</span>
	<span class="p">[</span><span class="n">FCPIO_INVALID_HEADER</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;FCPIO_INVALID_HEADER&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">FCPIO_OUT_OF_RESOURCE</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;FCPIO_OUT_OF_RESOURCE&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">FCPIO_INVALID_PARAM</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;FCPIO_INVALID_PARAM]&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">FCPIO_REQ_NOT_SUPPORTED</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;FCPIO_REQ_NOT_SUPPORTED&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">FCPIO_IO_NOT_FOUND</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;FCPIO_IO_NOT_FOUND&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">FCPIO_ABORTED</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;FCPIO_ABORTED&quot;</span><span class="p">,</span> <span class="cm">/*0x41*/</span>
	<span class="p">[</span><span class="n">FCPIO_TIMEOUT</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;FCPIO_TIMEOUT&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">FCPIO_SGL_INVALID</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;FCPIO_SGL_INVALID&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">FCPIO_MSS_INVALID</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;FCPIO_MSS_INVALID&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">FCPIO_DATA_CNT_MISMATCH</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;FCPIO_DATA_CNT_MISMATCH&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">FCPIO_FW_ERR</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;FCPIO_FW_ERR&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">FCPIO_ITMF_REJECTED</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;FCPIO_ITMF_REJECTED&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">FCPIO_ITMF_FAILED</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;FCPIO_ITMF_FAILED&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">FCPIO_ITMF_INCORRECT_LUN</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;FCPIO_ITMF_INCORRECT_LUN&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">FCPIO_CMND_REJECTED</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;FCPIO_CMND_REJECTED&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">FCPIO_NO_PATH_AVAIL</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;FCPIO_NO_PATH_AVAIL&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">FCPIO_PATH_FAILED</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;FCPIO_PATH_FAILED&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">FCPIO_LUNMAP_CHNG_PEND</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;FCPIO_LUNHMAP_CHNG_PEND&quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">fnic_state_to_str</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">&gt;=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">fnic_state_str</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">fnic_state_str</span><span class="p">[</span><span class="n">state</span><span class="p">])</span>
		<span class="k">return</span> <span class="s">&quot;unknown&quot;</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">fnic_state_str</span><span class="p">[</span><span class="n">state</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">fnic_ioreq_state_to_str</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">&gt;=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">fnic_ioreq_state_str</span><span class="p">)</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">fnic_ioreq_state_str</span><span class="p">[</span><span class="n">state</span><span class="p">])</span>
		<span class="k">return</span> <span class="s">&quot;unknown&quot;</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">fnic_ioreq_state_str</span><span class="p">[</span><span class="n">state</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">fnic_fcpio_status_to_str</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&gt;=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">fcpio_status_str</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">fcpio_status_str</span><span class="p">[</span><span class="n">status</span><span class="p">])</span>
		<span class="k">return</span> <span class="s">&quot;unknown&quot;</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">fcpio_status_str</span><span class="p">[</span><span class="n">status</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">fnic_cleanup_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">fnic</span> <span class="o">*</span><span class="n">fnic</span><span class="p">,</span> <span class="kt">int</span> <span class="n">exclude_id</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">spinlock_t</span> <span class="o">*</span><span class="nf">fnic_io_lock_hash</span><span class="p">(</span><span class="k">struct</span> <span class="n">fnic</span> <span class="o">*</span><span class="n">fnic</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">sc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">hash</span> <span class="o">=</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">tag</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">FNIC_IO_LOCKS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">&amp;</span><span class="n">fnic</span><span class="o">-&gt;</span><span class="n">io_req_lock</span><span class="p">[</span><span class="n">hash</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Unmap the data buffer and sense buffer for an io_req,</span>
<span class="cm"> * also unmap and free the device-private scatter/gather list.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fnic_release_ioreq_buf</span><span class="p">(</span><span class="k">struct</span> <span class="n">fnic</span> <span class="o">*</span><span class="n">fnic</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">fnic_io_req</span> <span class="o">*</span><span class="n">io_req</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">sc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">io_req</span><span class="o">-&gt;</span><span class="n">sgl_list_pa</span><span class="p">)</span>
		<span class="n">pci_unmap_single</span><span class="p">(</span><span class="n">fnic</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">io_req</span><span class="o">-&gt;</span><span class="n">sgl_list_pa</span><span class="p">,</span>
				 <span class="k">sizeof</span><span class="p">(</span><span class="n">io_req</span><span class="o">-&gt;</span><span class="n">sgl_list</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">io_req</span><span class="o">-&gt;</span><span class="n">sgl_cnt</span><span class="p">,</span>
				 <span class="n">PCI_DMA_TODEVICE</span><span class="p">);</span>
	<span class="n">scsi_dma_unmap</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">io_req</span><span class="o">-&gt;</span><span class="n">sgl_cnt</span><span class="p">)</span>
		<span class="n">mempool_free</span><span class="p">(</span><span class="n">io_req</span><span class="o">-&gt;</span><span class="n">sgl_list_alloc</span><span class="p">,</span>
			     <span class="n">fnic</span><span class="o">-&gt;</span><span class="n">io_sgl_pool</span><span class="p">[</span><span class="n">io_req</span><span class="o">-&gt;</span><span class="n">sgl_type</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">io_req</span><span class="o">-&gt;</span><span class="n">sense_buf_pa</span><span class="p">)</span>
		<span class="n">pci_unmap_single</span><span class="p">(</span><span class="n">fnic</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">io_req</span><span class="o">-&gt;</span><span class="n">sense_buf_pa</span><span class="p">,</span>
				 <span class="n">SCSI_SENSE_BUFFERSIZE</span><span class="p">,</span> <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Free up Copy Wq descriptors. Called with copy_wq lock held */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">free_wq_copy_descs</span><span class="p">(</span><span class="k">struct</span> <span class="n">fnic</span> <span class="o">*</span><span class="n">fnic</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vnic_wq_copy</span> <span class="o">*</span><span class="n">wq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* if no Ack received from firmware, then nothing to clean */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fnic</span><span class="o">-&gt;</span><span class="n">fw_ack_recd</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Update desc_available count based on number of freed descriptors</span>
<span class="cm">	 * Account for wraparound</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">to_clean_index</span> <span class="o">&lt;=</span> <span class="n">fnic</span><span class="o">-&gt;</span><span class="n">fw_ack_index</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
		<span class="n">wq</span><span class="o">-&gt;</span><span class="n">ring</span><span class="p">.</span><span class="n">desc_avail</span> <span class="o">+=</span> <span class="p">(</span><span class="n">fnic</span><span class="o">-&gt;</span><span class="n">fw_ack_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
					<span class="o">-</span> <span class="n">wq</span><span class="o">-&gt;</span><span class="n">to_clean_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">wq</span><span class="o">-&gt;</span><span class="n">ring</span><span class="p">.</span><span class="n">desc_avail</span> <span class="o">+=</span> <span class="p">(</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">ring</span><span class="p">.</span><span class="n">desc_count</span>
					<span class="o">-</span> <span class="n">wq</span><span class="o">-&gt;</span><span class="n">to_clean_index</span>
					<span class="o">+</span> <span class="n">fnic</span><span class="o">-&gt;</span><span class="n">fw_ack_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * just bump clean index to ack_index+1 accounting for wraparound</span>
<span class="cm">	 * this will essentially free up all descriptors between</span>
<span class="cm">	 * to_clean_index and fw_ack_index, both inclusive</span>
<span class="cm">	 */</span>
	<span class="n">wq</span><span class="o">-&gt;</span><span class="n">to_clean_index</span> <span class="o">=</span>
		<span class="p">(</span><span class="n">fnic</span><span class="o">-&gt;</span><span class="n">fw_ack_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">wq</span><span class="o">-&gt;</span><span class="n">ring</span><span class="p">.</span><span class="n">desc_count</span><span class="p">;</span>

	<span class="cm">/* we have processed the acks received so far */</span>
	<span class="n">fnic</span><span class="o">-&gt;</span><span class="n">fw_ack_recd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * fnic_fw_reset_handler</span>
<span class="cm"> * Routine to send reset msg to fw</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">fnic_fw_reset_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">fnic</span> <span class="o">*</span><span class="n">fnic</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vnic_wq_copy</span> <span class="o">*</span><span class="n">wq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fnic</span><span class="o">-&gt;</span><span class="n">wq_copy</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">skb_queue_purge</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fnic</span><span class="o">-&gt;</span><span class="n">frame_queue</span><span class="p">);</span>
	<span class="n">skb_queue_purge</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fnic</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fnic</span><span class="o">-&gt;</span><span class="n">wq_copy_lock</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vnic_wq_copy_desc_avail</span><span class="p">(</span><span class="n">wq</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">fnic</span><span class="o">-&gt;</span><span class="n">wq_copy_desc_low</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
		<span class="n">free_wq_copy_descs</span><span class="p">(</span><span class="n">fnic</span><span class="p">,</span> <span class="n">wq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vnic_wq_copy_desc_avail</span><span class="p">(</span><span class="n">wq</span><span class="p">))</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">fnic_queue_wq_copy_desc_fw_reset</span><span class="p">(</span><span class="n">wq</span><span class="p">,</span> <span class="n">SCSI_NO_TAG</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fnic</span><span class="o">-&gt;</span><span class="n">wq_copy_lock</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">FNIC_SCSI_DBG</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="n">fnic</span><span class="o">-&gt;</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span>
			      <span class="s">&quot;Issued fw reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">FNIC_SCSI_DBG</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="n">fnic</span><span class="o">-&gt;</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span>
			      <span class="s">&quot;Failed to issue fw reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * fnic_flogi_reg_handler</span>
<span class="cm"> * Routine to send flogi register msg to fw</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">fnic_flogi_reg_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">fnic</span> <span class="o">*</span><span class="n">fnic</span><span class="p">,</span> <span class="n">u32</span> <span class="n">fc_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vnic_wq_copy</span> <span class="o">*</span><span class="n">wq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fnic</span><span class="o">-&gt;</span><span class="n">wq_copy</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">enum</span> <span class="n">fcpio_flogi_reg_format_type</span> <span class="n">format</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">fnic</span><span class="o">-&gt;</span><span class="n">lport</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">gw_mac</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fnic</span><span class="o">-&gt;</span><span class="n">wq_copy_lock</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vnic_wq_copy_desc_avail</span><span class="p">(</span><span class="n">wq</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">fnic</span><span class="o">-&gt;</span><span class="n">wq_copy_desc_low</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
		<span class="n">free_wq_copy_descs</span><span class="p">(</span><span class="n">fnic</span><span class="p">,</span> <span class="n">wq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vnic_wq_copy_desc_avail</span><span class="p">(</span><span class="n">wq</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">flogi_reg_ioreq_end</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fnic</span><span class="o">-&gt;</span><span class="n">ctlr</span><span class="p">.</span><span class="n">map_dest</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">gw_mac</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
		<span class="n">format</span> <span class="o">=</span> <span class="n">FCPIO_FLOGI_REG_DEF_DEST</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">gw_mac</span><span class="p">,</span> <span class="n">fnic</span><span class="o">-&gt;</span><span class="n">ctlr</span><span class="p">.</span><span class="n">dest_addr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
		<span class="n">format</span> <span class="o">=</span> <span class="n">FCPIO_FLOGI_REG_GW_DEST</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">fnic</span><span class="o">-&gt;</span><span class="n">config</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">VFCF_FIP_CAPABLE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">fnic</span><span class="o">-&gt;</span><span class="n">ctlr</span><span class="p">.</span><span class="n">map_dest</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fnic_queue_wq_copy_desc_fip_reg</span><span class="p">(</span><span class="n">wq</span><span class="p">,</span> <span class="n">SCSI_NO_TAG</span><span class="p">,</span>
						<span class="n">fc_id</span><span class="p">,</span> <span class="n">gw_mac</span><span class="p">,</span>
						<span class="n">fnic</span><span class="o">-&gt;</span><span class="n">data_src_addr</span><span class="p">,</span>
						<span class="n">lp</span><span class="o">-&gt;</span><span class="n">r_a_tov</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">e_d_tov</span><span class="p">);</span>
		<span class="n">FNIC_SCSI_DBG</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="n">fnic</span><span class="o">-&gt;</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span>
			      <span class="s">&quot;FLOGI FIP reg issued fcid %x src %pM dest %pM</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			      <span class="n">fc_id</span><span class="p">,</span> <span class="n">fnic</span><span class="o">-&gt;</span><span class="n">data_src_addr</span><span class="p">,</span> <span class="n">gw_mac</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">fnic_queue_wq_copy_desc_flogi_reg</span><span class="p">(</span><span class="n">wq</span><span class="p">,</span> <span class="n">SCSI_NO_TAG</span><span class="p">,</span>
						  <span class="n">format</span><span class="p">,</span> <span class="n">fc_id</span><span class="p">,</span> <span class="n">gw_mac</span><span class="p">);</span>
		<span class="n">FNIC_SCSI_DBG</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="n">fnic</span><span class="o">-&gt;</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span>
			      <span class="s">&quot;FLOGI reg issued fcid %x map %d dest %pM</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			      <span class="n">fc_id</span><span class="p">,</span> <span class="n">fnic</span><span class="o">-&gt;</span><span class="n">ctlr</span><span class="p">.</span><span class="n">map_dest</span><span class="p">,</span> <span class="n">gw_mac</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">flogi_reg_ioreq_end:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fnic</span><span class="o">-&gt;</span><span class="n">wq_copy_lock</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * fnic_queue_wq_copy_desc</span>
<span class="cm"> * Routine to enqueue a wq copy desc</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">fnic_queue_wq_copy_desc</span><span class="p">(</span><span class="k">struct</span> <span class="n">fnic</span> <span class="o">*</span><span class="n">fnic</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">vnic_wq_copy</span> <span class="o">*</span><span class="n">wq</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">fnic_io_req</span> <span class="o">*</span><span class="n">io_req</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span>
					  <span class="kt">int</span> <span class="n">sg_count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_rport</span> <span class="o">*</span><span class="n">rport</span> <span class="o">=</span> <span class="n">starget_to_rport</span><span class="p">(</span><span class="n">scsi_target</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">));</span>
	<span class="k">struct</span> <span class="n">fc_rport_libfc_priv</span> <span class="o">*</span><span class="n">rp</span> <span class="o">=</span> <span class="n">rport</span><span class="o">-&gt;</span><span class="n">dd_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">host_sg_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">pri_tag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">intr_flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">exch_flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_lun</span> <span class="n">fc_lun</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">msg</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sg_count</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* For each SGE, create a device desc entry */</span>
		<span class="n">desc</span> <span class="o">=</span> <span class="n">io_req</span><span class="o">-&gt;</span><span class="n">sgl_list</span><span class="p">;</span>
		<span class="n">for_each_sg</span><span class="p">(</span><span class="n">scsi_sglist</span><span class="p">(</span><span class="n">sc</span><span class="p">),</span> <span class="n">sg</span><span class="p">,</span> <span class="n">sg_count</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">desc</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">sg_dma_address</span><span class="p">(</span><span class="n">sg</span><span class="p">));</span>
			<span class="n">desc</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">sg_dma_len</span><span class="p">(</span><span class="n">sg</span><span class="p">));</span>
			<span class="n">desc</span><span class="o">-&gt;</span><span class="n">_resvd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">desc</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">io_req</span><span class="o">-&gt;</span><span class="n">sgl_list_pa</span> <span class="o">=</span> <span class="n">pci_map_single</span>
			<span class="p">(</span><span class="n">fnic</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
			 <span class="n">io_req</span><span class="o">-&gt;</span><span class="n">sgl_list</span><span class="p">,</span>
			 <span class="k">sizeof</span><span class="p">(</span><span class="n">io_req</span><span class="o">-&gt;</span><span class="n">sgl_list</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">sg_count</span><span class="p">,</span>
			 <span class="n">PCI_DMA_TODEVICE</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">io_req</span><span class="o">-&gt;</span><span class="n">sense_buf_pa</span> <span class="o">=</span> <span class="n">pci_map_single</span><span class="p">(</span><span class="n">fnic</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
					      <span class="n">sc</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">,</span>
					      <span class="n">SCSI_SENSE_BUFFERSIZE</span><span class="p">,</span>
					      <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>

	<span class="n">int_to_scsilun</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fc_lun</span><span class="p">);</span>

	<span class="n">pri_tag</span> <span class="o">=</span> <span class="n">FCPIO_ICMND_PTA_SIMPLE</span><span class="p">;</span>
	<span class="n">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">MSG_SIMPLE_TAG</span><span class="p">;</span>
	<span class="n">scsi_populate_tag_msg</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">MSG_ORDERED_TAG</span><span class="p">)</span>
		<span class="n">pri_tag</span> <span class="o">=</span> <span class="n">FCPIO_ICMND_PTA_ORDERED</span><span class="p">;</span>

	<span class="cm">/* Enqueue the descriptor in the Copy WQ */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fnic</span><span class="o">-&gt;</span><span class="n">wq_copy_lock</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">intr_flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vnic_wq_copy_desc_avail</span><span class="p">(</span><span class="n">wq</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">fnic</span><span class="o">-&gt;</span><span class="n">wq_copy_desc_low</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
		<span class="n">free_wq_copy_descs</span><span class="p">(</span><span class="n">fnic</span><span class="p">,</span> <span class="n">wq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">vnic_wq_copy_desc_avail</span><span class="p">(</span><span class="n">wq</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fnic</span><span class="o">-&gt;</span><span class="n">wq_copy_lock</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">intr_flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">SCSI_MLQUEUE_HOST_BUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_data_direction</span> <span class="o">==</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">)</span>
		<span class="n">flags</span> <span class="o">=</span> <span class="n">FCPIO_ICMND_RDDATA</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_data_direction</span> <span class="o">==</span> <span class="n">DMA_TO_DEVICE</span><span class="p">)</span>
		<span class="n">flags</span> <span class="o">=</span> <span class="n">FCPIO_ICMND_WRDATA</span><span class="p">;</span>

	<span class="n">exch_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">fnic</span><span class="o">-&gt;</span><span class="n">config</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">VFCF_FCP_SEQ_LVL_ERR</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FC_RP_FLAGS_RETRY</span><span class="p">))</span>
		<span class="n">exch_flags</span> <span class="o">|=</span> <span class="n">FCPIO_ICMND_SRFLAG_RETRY</span><span class="p">;</span>

	<span class="n">fnic_queue_wq_copy_desc_icmnd_16</span><span class="p">(</span><span class="n">wq</span><span class="p">,</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">tag</span><span class="p">,</span>
					 <span class="mi">0</span><span class="p">,</span> <span class="n">exch_flags</span><span class="p">,</span> <span class="n">io_req</span><span class="o">-&gt;</span><span class="n">sgl_cnt</span><span class="p">,</span>
					 <span class="n">SCSI_SENSE_BUFFERSIZE</span><span class="p">,</span>
					 <span class="n">io_req</span><span class="o">-&gt;</span><span class="n">sgl_list_pa</span><span class="p">,</span>
					 <span class="n">io_req</span><span class="o">-&gt;</span><span class="n">sense_buf_pa</span><span class="p">,</span>
					 <span class="mi">0</span><span class="p">,</span> <span class="cm">/* scsi cmd ref, always 0 */</span>
					 <span class="n">pri_tag</span><span class="p">,</span> <span class="cm">/* scsi pri and tag */</span>
					 <span class="n">flags</span><span class="p">,</span>	<span class="cm">/* command flags */</span>
					 <span class="n">sc</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">,</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">cmd_len</span><span class="p">,</span>
					 <span class="n">scsi_bufflen</span><span class="p">(</span><span class="n">sc</span><span class="p">),</span>
					 <span class="n">fc_lun</span><span class="p">.</span><span class="n">scsi_lun</span><span class="p">,</span> <span class="n">io_req</span><span class="o">-&gt;</span><span class="n">port_id</span><span class="p">,</span>
					 <span class="n">rport</span><span class="o">-&gt;</span><span class="n">maxframe_size</span><span class="p">,</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">r_a_tov</span><span class="p">,</span>
					 <span class="n">rp</span><span class="o">-&gt;</span><span class="n">e_d_tov</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fnic</span><span class="o">-&gt;</span><span class="n">wq_copy_lock</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">intr_flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * fnic_queuecommand</span>
<span class="cm"> * Routine to send a scsi cdb</span>
<span class="cm"> * Called with host_lock held and interrupts disabled.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fnic_queuecommand_lck</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">done</span><span class="p">)(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_rport</span> <span class="o">*</span><span class="n">rport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fnic_io_req</span> <span class="o">*</span><span class="n">io_req</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fnic</span> <span class="o">*</span><span class="n">fnic</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vnic_wq_copy</span> <span class="o">*</span><span class="n">wq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sg_count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ptr</span><span class="p">;</span>

	<span class="n">rport</span> <span class="o">=</span> <span class="n">starget_to_rport</span><span class="p">(</span><span class="n">scsi_target</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">));</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">fc_remote_port_chkready</span><span class="p">(</span><span class="n">rport</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sc</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
		<span class="n">done</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lp</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">LPORT_ST_READY</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">link_up</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">SCSI_MLQUEUE_HOST_BUSY</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Release host lock, use driver resource specific locks from here.</span>
<span class="cm">	 * Don&#39;t re-enable interrupts in case they were disabled prior to the</span>
<span class="cm">	 * caller disabling them.</span>
<span class="cm">	 */</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>

	<span class="cm">/* Get a new io_req for this SCSI IO */</span>
	<span class="n">fnic</span> <span class="o">=</span> <span class="n">lport_priv</span><span class="p">(</span><span class="n">lp</span><span class="p">);</span>

	<span class="n">io_req</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">fnic</span><span class="o">-&gt;</span><span class="n">io_req_pool</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">io_req</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">SCSI_MLQUEUE_HOST_BUSY</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">io_req</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">io_req</span><span class="p">));</span>

	<span class="cm">/* Map the data buffer */</span>
	<span class="n">sg_count</span> <span class="o">=</span> <span class="n">scsi_dma_map</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sg_count</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mempool_free</span><span class="p">(</span><span class="n">io_req</span><span class="p">,</span> <span class="n">fnic</span><span class="o">-&gt;</span><span class="n">io_req_pool</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Determine the type of scatter/gather list we need */</span>
	<span class="n">io_req</span><span class="o">-&gt;</span><span class="n">sgl_cnt</span> <span class="o">=</span> <span class="n">sg_count</span><span class="p">;</span>
	<span class="n">io_req</span><span class="o">-&gt;</span><span class="n">sgl_type</span> <span class="o">=</span> <span class="n">FNIC_SGL_CACHE_DFLT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sg_count</span> <span class="o">&gt;</span> <span class="n">FNIC_DFLT_SG_DESC_CNT</span><span class="p">)</span>
		<span class="n">io_req</span><span class="o">-&gt;</span><span class="n">sgl_type</span> <span class="o">=</span> <span class="n">FNIC_SGL_CACHE_MAX</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sg_count</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">io_req</span><span class="o">-&gt;</span><span class="n">sgl_list</span> <span class="o">=</span>
			<span class="n">mempool_alloc</span><span class="p">(</span><span class="n">fnic</span><span class="o">-&gt;</span><span class="n">io_sgl_pool</span><span class="p">[</span><span class="n">io_req</span><span class="o">-&gt;</span><span class="n">sgl_type</span><span class="p">],</span>
				      <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">io_req</span><span class="o">-&gt;</span><span class="n">sgl_list</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">SCSI_MLQUEUE_HOST_BUSY</span><span class="p">;</span>
			<span class="n">scsi_dma_unmap</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
			<span class="n">mempool_free</span><span class="p">(</span><span class="n">io_req</span><span class="p">,</span> <span class="n">fnic</span><span class="o">-&gt;</span><span class="n">io_req_pool</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Cache sgl list allocated address before alignment */</span>
		<span class="n">io_req</span><span class="o">-&gt;</span><span class="n">sgl_list_alloc</span> <span class="o">=</span> <span class="n">io_req</span><span class="o">-&gt;</span><span class="n">sgl_list</span><span class="p">;</span>
		<span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">io_req</span><span class="o">-&gt;</span><span class="n">sgl_list</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ptr</span> <span class="o">%</span> <span class="n">FNIC_SG_DESC_ALIGN</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">io_req</span><span class="o">-&gt;</span><span class="n">sgl_list</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">host_sg_desc</span> <span class="o">*</span><span class="p">)</span>
				<span class="p">(((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ptr</span>
				  <span class="o">+</span> <span class="n">FNIC_SG_DESC_ALIGN</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
				 <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">FNIC_SG_DESC_ALIGN</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* initialize rest of io_req */</span>
	<span class="n">io_req</span><span class="o">-&gt;</span><span class="n">port_id</span> <span class="o">=</span> <span class="n">rport</span><span class="o">-&gt;</span><span class="n">port_id</span><span class="p">;</span>
	<span class="n">CMD_STATE</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span> <span class="o">=</span> <span class="n">FNIC_IOREQ_CMD_PENDING</span><span class="p">;</span>
	<span class="n">CMD_SP</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">io_req</span><span class="p">;</span>
	<span class="n">sc</span><span class="o">-&gt;</span><span class="n">scsi_done</span> <span class="o">=</span> <span class="n">done</span><span class="p">;</span>

	<span class="cm">/* create copy wq desc and enqueue it */</span>
	<span class="n">wq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fnic</span><span class="o">-&gt;</span><span class="n">wq_copy</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">fnic_queue_wq_copy_desc</span><span class="p">(</span><span class="n">fnic</span><span class="p">,</span> <span class="n">wq</span><span class="p">,</span> <span class="n">io_req</span><span class="p">,</span> <span class="n">sc</span><span class="p">,</span> <span class="n">sg_count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * In case another thread cancelled the request,</span>
<span class="cm">		 * refetch the pointer under the lock.</span>
<span class="cm">		 */</span>
		<span class="n">spinlock_t</span> <span class="o">*</span><span class="n">io_lock</span> <span class="o">=</span> <span class="n">fnic_io_lock_hash</span><span class="p">(</span><span class="n">fnic</span><span class="p">,</span> <span class="n">sc</span><span class="p">);</span>

		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">io_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">io_req</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">fnic_io_req</span> <span class="o">*</span><span class="p">)</span><span class="n">CMD_SP</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
		<span class="n">CMD_SP</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">CMD_STATE</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span> <span class="o">=</span> <span class="n">FNIC_IOREQ_CMD_COMPLETE</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">io_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">io_req</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">fnic_release_ioreq_buf</span><span class="p">(</span><span class="n">fnic</span><span class="p">,</span> <span class="n">io_req</span><span class="p">,</span> <span class="n">sc</span><span class="p">);</span>
			<span class="n">mempool_free</span><span class="p">(</span><span class="n">io_req</span><span class="p">,</span> <span class="n">fnic</span><span class="o">-&gt;</span><span class="n">io_req_pool</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="cm">/* acquire host lock before returning to SCSI */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">DEF_SCSI_QCMD</span><span class="p">(</span><span class="n">fnic_queuecommand</span><span class="p">)</span>

<span class="cm">/*</span>
<span class="cm"> * fnic_fcpio_fw_reset_cmpl_handler</span>
<span class="cm"> * Routine to handle fw reset completion</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">fnic_fcpio_fw_reset_cmpl_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">fnic</span> <span class="o">*</span><span class="n">fnic</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">fcpio_fw_req</span> <span class="o">*</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">hdr_status</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcpio_tag</span> <span class="n">tag</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">fcpio_header_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hdr_status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tag</span><span class="p">);</span>

	<span class="cm">/* Clean up all outstanding io requests */</span>
	<span class="n">fnic_cleanup_io</span><span class="p">(</span><span class="n">fnic</span><span class="p">,</span> <span class="n">SCSI_NO_TAG</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fnic</span><span class="o">-&gt;</span><span class="n">fnic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* fnic should be in FC_TRANS_ETH_MODE */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fnic</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">FNIC_IN_FC_TRANS_ETH_MODE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Check status of reset completion */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hdr_status</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">FNIC_SCSI_DBG</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="n">fnic</span><span class="o">-&gt;</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span>
				      <span class="s">&quot;reset cmpl success</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="cm">/* Ready to send flogi out */</span>
			<span class="n">fnic</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">FNIC_IN_ETH_MODE</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">FNIC_SCSI_DBG</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="p">,</span>
				      <span class="n">fnic</span><span class="o">-&gt;</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span>
				      <span class="s">&quot;fnic fw_reset : failed %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				      <span class="n">fnic_fcpio_status_to_str</span><span class="p">(</span><span class="n">hdr_status</span><span class="p">));</span>

			<span class="cm">/*</span>
<span class="cm">			 * Unable to change to eth mode, cannot send out flogi</span>
<span class="cm">			 * Change state to fc mode, so that subsequent Flogi</span>
<span class="cm">			 * requests from libFC will cause more attempts to</span>
<span class="cm">			 * reset the firmware. Free the cached flogi</span>
<span class="cm">			 */</span>
			<span class="n">fnic</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">FNIC_IN_FC_MODE</span><span class="p">;</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">FNIC_SCSI_DBG</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="p">,</span>
			      <span class="n">fnic</span><span class="o">-&gt;</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span>
			      <span class="s">&quot;Unexpected state %s while processing&quot;</span>
			      <span class="s">&quot; reset cmpl</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fnic_state_to_str</span><span class="p">(</span><span class="n">fnic</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">));</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Thread removing device blocks till firmware reset is complete */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fnic</span><span class="o">-&gt;</span><span class="n">remove_wait</span><span class="p">)</span>
		<span class="n">complete</span><span class="p">(</span><span class="n">fnic</span><span class="o">-&gt;</span><span class="n">remove_wait</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If fnic is being removed, or fw reset failed</span>
<span class="cm">	 * free the flogi frame. Else, send it out</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fnic</span><span class="o">-&gt;</span><span class="n">remove_wait</span> <span class="o">||</span> <span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fnic</span><span class="o">-&gt;</span><span class="n">fnic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">skb_queue_purge</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fnic</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">reset_cmpl_handler_end</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fnic</span><span class="o">-&gt;</span><span class="n">fnic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">fnic_flush_tx</span><span class="p">(</span><span class="n">fnic</span><span class="p">);</span>

 <span class="nl">reset_cmpl_handler_end:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * fnic_fcpio_flogi_reg_cmpl_handler</span>
<span class="cm"> * Routine to handle flogi register completion</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">fnic_fcpio_flogi_reg_cmpl_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">fnic</span> <span class="o">*</span><span class="n">fnic</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">fcpio_fw_req</span> <span class="o">*</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">hdr_status</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcpio_tag</span> <span class="n">tag</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">fcpio_header_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hdr_status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tag</span><span class="p">);</span>

	<span class="cm">/* Update fnic state based on status of flogi reg completion */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fnic</span><span class="o">-&gt;</span><span class="n">fnic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fnic</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">FNIC_IN_ETH_TRANS_FC_MODE</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* Check flogi registration completion status */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hdr_status</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">FNIC_SCSI_DBG</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="n">fnic</span><span class="o">-&gt;</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span>
				      <span class="s">&quot;flog reg succeeded</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">fnic</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">FNIC_IN_FC_MODE</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">FNIC_SCSI_DBG</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="p">,</span>
				      <span class="n">fnic</span><span class="o">-&gt;</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span>
				      <span class="s">&quot;fnic flogi reg :failed %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				      <span class="n">fnic_fcpio_status_to_str</span><span class="p">(</span><span class="n">hdr_status</span><span class="p">));</span>
			<span class="n">fnic</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">FNIC_IN_ETH_MODE</span><span class="p">;</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">FNIC_SCSI_DBG</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="n">fnic</span><span class="o">-&gt;</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span>
			      <span class="s">&quot;Unexpected fnic state %s while&quot;</span>
			      <span class="s">&quot; processing flogi reg completion</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			      <span class="n">fnic_state_to_str</span><span class="p">(</span><span class="n">fnic</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">));</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fnic</span><span class="o">-&gt;</span><span class="n">stop_rx_link_events</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fnic</span><span class="o">-&gt;</span><span class="n">fnic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">reg_cmpl_handler_end</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fnic</span><span class="o">-&gt;</span><span class="n">fnic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="n">fnic_flush_tx</span><span class="p">(</span><span class="n">fnic</span><span class="p">);</span>
		<span class="n">queue_work</span><span class="p">(</span><span class="n">fnic_event_queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fnic</span><span class="o">-&gt;</span><span class="n">frame_work</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fnic</span><span class="o">-&gt;</span><span class="n">fnic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">reg_cmpl_handler_end:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">is_ack_index_in_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">vnic_wq_copy</span> <span class="o">*</span><span class="n">wq</span><span class="p">,</span>
					<span class="n">u16</span> <span class="n">request_out</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">to_clean_index</span> <span class="o">&lt;=</span> <span class="n">wq</span><span class="o">-&gt;</span><span class="n">to_use_index</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* out of range, stale request_out index */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">request_out</span> <span class="o">&lt;</span> <span class="n">wq</span><span class="o">-&gt;</span><span class="n">to_clean_index</span> <span class="o">||</span>
		    <span class="n">request_out</span> <span class="o">&gt;=</span> <span class="n">wq</span><span class="o">-&gt;</span><span class="n">to_use_index</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* out of range, stale request_out index */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">request_out</span> <span class="o">&lt;</span> <span class="n">wq</span><span class="o">-&gt;</span><span class="n">to_clean_index</span> <span class="o">&amp;&amp;</span>
		    <span class="n">request_out</span> <span class="o">&gt;=</span> <span class="n">wq</span><span class="o">-&gt;</span><span class="n">to_use_index</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* request_out index is in range */</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Mark that ack received and store the Ack index. If there are multiple</span>
<span class="cm"> * acks received before Tx thread cleans it up, the latest value will be</span>
<span class="cm"> * used which is correct behavior. This state should be in the copy Wq</span>
<span class="cm"> * instead of in the fnic</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">fnic_fcpio_ack_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">fnic</span> <span class="o">*</span><span class="n">fnic</span><span class="p">,</span>
					  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cq_index</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">fcpio_fw_req</span> <span class="o">*</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vnic_wq_copy</span> <span class="o">*</span><span class="n">wq</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">request_out</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">ack</span><span class="p">.</span><span class="n">request_out</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* mark the ack state */</span>
	<span class="n">wq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fnic</span><span class="o">-&gt;</span><span class="n">wq_copy</span><span class="p">[</span><span class="n">cq_index</span> <span class="o">-</span> <span class="n">fnic</span><span class="o">-&gt;</span><span class="n">raw_wq_count</span> <span class="o">-</span> <span class="n">fnic</span><span class="o">-&gt;</span><span class="n">rq_count</span><span class="p">];</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fnic</span><span class="o">-&gt;</span><span class="n">wq_copy_lock</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_ack_index_in_range</span><span class="p">(</span><span class="n">wq</span><span class="p">,</span> <span class="n">request_out</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">fnic</span><span class="o">-&gt;</span><span class="n">fw_ack_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">request_out</span><span class="p">;</span>
		<span class="n">fnic</span><span class="o">-&gt;</span><span class="n">fw_ack_recd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fnic</span><span class="o">-&gt;</span><span class="n">wq_copy_lock</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * fnic_fcpio_icmnd_cmpl_handler</span>
<span class="cm"> * Routine to handle icmnd completions</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">fnic_fcpio_icmnd_cmpl_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">fnic</span> <span class="o">*</span><span class="n">fnic</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">fcpio_fw_req</span> <span class="o">*</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">hdr_status</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcpio_tag</span> <span class="n">tag</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">id</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">xfer_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcpio_icmnd_cmpl</span> <span class="o">*</span><span class="n">icmnd_cmpl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fnic_io_req</span> <span class="o">*</span><span class="n">io_req</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">sc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="o">*</span><span class="n">io_lock</span><span class="p">;</span>

	<span class="cm">/* Decode the cmpl description to get the io_req id */</span>
	<span class="n">fcpio_header_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hdr_status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tag</span><span class="p">);</span>
	<span class="n">fcpio_tag_id_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tag</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">id</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">&gt;=</span> <span class="n">FNIC_MAX_IO_REQ</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">sc</span> <span class="o">=</span> <span class="n">scsi_host_find_tag</span><span class="p">(</span><span class="n">fnic</span><span class="o">-&gt;</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="o">!</span><span class="n">sc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sc</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">io_lock</span> <span class="o">=</span> <span class="n">fnic_io_lock_hash</span><span class="p">(</span><span class="n">fnic</span><span class="p">,</span> <span class="n">sc</span><span class="p">);</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">io_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">io_req</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">fnic_io_req</span> <span class="o">*</span><span class="p">)</span><span class="n">CMD_SP</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="o">!</span><span class="n">io_req</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">io_req</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">io_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* firmware completed the io */</span>
	<span class="n">io_req</span><span class="o">-&gt;</span><span class="n">io_completed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  if SCSI-ML has already issued abort on this command,</span>
<span class="cm">	 * ignore completion of the IO. The abts path will clean it up</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">CMD_STATE</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span> <span class="o">==</span> <span class="n">FNIC_IOREQ_ABTS_PENDING</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">io_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Mark the IO as complete */</span>
	<span class="n">CMD_STATE</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span> <span class="o">=</span> <span class="n">FNIC_IOREQ_CMD_COMPLETE</span><span class="p">;</span>

	<span class="n">icmnd_cmpl</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">icmnd_cmpl</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">hdr_status</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">FCPIO_SUCCESS</span>:
		<span class="n">sc</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DID_OK</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="n">icmnd_cmpl</span><span class="o">-&gt;</span><span class="n">scsi_status</span><span class="p">;</span>
		<span class="n">xfer_len</span> <span class="o">=</span> <span class="n">scsi_bufflen</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
		<span class="n">scsi_set_resid</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">icmnd_cmpl</span><span class="o">-&gt;</span><span class="n">residual</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">icmnd_cmpl</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FCPIO_ICMND_CMPL_RESID_UNDER</span><span class="p">)</span>
			<span class="n">xfer_len</span> <span class="o">-=</span> <span class="n">icmnd_cmpl</span><span class="o">-&gt;</span><span class="n">residual</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * If queue_full, then try to reduce queue depth for all</span>
<span class="cm">		 * LUNS on the target. Todo: this should be accompanied</span>
<span class="cm">		 * by a periodic queue_depth rampup based on successful</span>
<span class="cm">		 * IO completion.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">icmnd_cmpl</span><span class="o">-&gt;</span><span class="n">scsi_status</span> <span class="o">==</span> <span class="n">QUEUE_FULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">t_sdev</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">qd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="n">shost_for_each_device</span><span class="p">(</span><span class="n">t_sdev</span><span class="p">,</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">t_sdev</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">!=</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">)</span>
					<span class="k">continue</span><span class="p">;</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">t_sdev</span><span class="o">-&gt;</span><span class="n">queue_depth</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">qd</span> <span class="o">=</span> <span class="n">scsi_track_queue_full</span>
						<span class="p">(</span><span class="n">t_sdev</span><span class="p">,</span>
						 <span class="n">t_sdev</span><span class="o">-&gt;</span><span class="n">queue_depth</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">qd</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
						<span class="n">qd</span> <span class="o">=</span> <span class="n">t_sdev</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">cmd_per_lun</span><span class="p">;</span>
					<span class="n">shost_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span>
						     <span class="n">fnic</span><span class="o">-&gt;</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span>
						     <span class="s">&quot;scsi[%d:%d:%d:%d&quot;</span>
						     <span class="s">&quot;] queue full detected,&quot;</span>
						     <span class="s">&quot;new depth = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						     <span class="n">t_sdev</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">,</span>
						     <span class="n">t_sdev</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span>
						     <span class="n">t_sdev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">t_sdev</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">,</span>
						     <span class="n">t_sdev</span><span class="o">-&gt;</span><span class="n">queue_depth</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">FCPIO_TIMEOUT</span>:          <span class="cm">/* request was timed out */</span>
		<span class="n">sc</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DID_TIME_OUT</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="n">icmnd_cmpl</span><span class="o">-&gt;</span><span class="n">scsi_status</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">FCPIO_ABORTED</span>:          <span class="cm">/* request was aborted */</span>
		<span class="n">sc</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DID_ERROR</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="n">icmnd_cmpl</span><span class="o">-&gt;</span><span class="n">scsi_status</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">FCPIO_DATA_CNT_MISMATCH</span>: <span class="cm">/* recv/sent more/less data than exp. */</span>
		<span class="n">scsi_set_resid</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">icmnd_cmpl</span><span class="o">-&gt;</span><span class="n">residual</span><span class="p">);</span>
		<span class="n">sc</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DID_ERROR</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="n">icmnd_cmpl</span><span class="o">-&gt;</span><span class="n">scsi_status</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">FCPIO_OUT_OF_RESOURCE</span>:  <span class="cm">/* out of resources to complete request */</span>
		<span class="n">sc</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DID_REQUEUE</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="n">icmnd_cmpl</span><span class="o">-&gt;</span><span class="n">scsi_status</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">FCPIO_INVALID_HEADER</span>:   <span class="cm">/* header contains invalid data */</span>
	<span class="k">case</span> <span class="n">FCPIO_INVALID_PARAM</span>:    <span class="cm">/* some parameter in request invalid */</span>
	<span class="k">case</span> <span class="n">FCPIO_REQ_NOT_SUPPORTED</span>:<span class="cm">/* request type is not supported */</span>
	<span class="k">case</span> <span class="n">FCPIO_IO_NOT_FOUND</span>:     <span class="cm">/* requested I/O was not found */</span>
	<span class="k">case</span> <span class="n">FCPIO_SGL_INVALID</span>:      <span class="cm">/* request was aborted due to sgl error */</span>
	<span class="k">case</span> <span class="n">FCPIO_MSS_INVALID</span>:      <span class="cm">/* request was aborted due to mss error */</span>
	<span class="k">case</span> <span class="n">FCPIO_FW_ERR</span>:           <span class="cm">/* request was terminated due fw error */</span>
	<span class="nl">default:</span>
		<span class="n">shost_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">fnic</span><span class="o">-&gt;</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span> <span class="s">&quot;hdr status = %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">fnic_fcpio_status_to_str</span><span class="p">(</span><span class="n">hdr_status</span><span class="p">));</span>
		<span class="n">sc</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DID_ERROR</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="n">icmnd_cmpl</span><span class="o">-&gt;</span><span class="n">scsi_status</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Break link with the SCSI command */</span>
	<span class="n">CMD_SP</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">io_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">fnic_release_ioreq_buf</span><span class="p">(</span><span class="n">fnic</span><span class="p">,</span> <span class="n">io_req</span><span class="p">,</span> <span class="n">sc</span><span class="p">);</span>

	<span class="n">mempool_free</span><span class="p">(</span><span class="n">io_req</span><span class="p">,</span> <span class="n">fnic</span><span class="o">-&gt;</span><span class="n">io_req_pool</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_data_direction</span> <span class="o">==</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fnic</span><span class="o">-&gt;</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">host_stats</span><span class="p">.</span><span class="n">fcp_input_requests</span><span class="o">++</span><span class="p">;</span>
		<span class="n">fnic</span><span class="o">-&gt;</span><span class="n">fcp_input_bytes</span> <span class="o">+=</span> <span class="n">xfer_len</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_data_direction</span> <span class="o">==</span> <span class="n">DMA_TO_DEVICE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fnic</span><span class="o">-&gt;</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">host_stats</span><span class="p">.</span><span class="n">fcp_output_requests</span><span class="o">++</span><span class="p">;</span>
		<span class="n">fnic</span><span class="o">-&gt;</span><span class="n">fcp_output_bytes</span> <span class="o">+=</span> <span class="n">xfer_len</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">fnic</span><span class="o">-&gt;</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">host_stats</span><span class="p">.</span><span class="n">fcp_control_requests</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* Call SCSI completion function to complete the IO */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">)</span>
		<span class="n">sc</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>

<span class="p">}</span>

<span class="cm">/* fnic_fcpio_itmf_cmpl_handler</span>
<span class="cm"> * Routine to handle itmf completions</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">fnic_fcpio_itmf_cmpl_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">fnic</span> <span class="o">*</span><span class="n">fnic</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">fcpio_fw_req</span> <span class="o">*</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">hdr_status</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcpio_tag</span> <span class="n">tag</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">sc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fnic_io_req</span> <span class="o">*</span><span class="n">io_req</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="o">*</span><span class="n">io_lock</span><span class="p">;</span>

	<span class="n">fcpio_header_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hdr_status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tag</span><span class="p">);</span>
	<span class="n">fcpio_tag_id_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tag</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">id</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">id</span> <span class="o">&amp;</span> <span class="n">FNIC_TAG_MASK</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">FNIC_MAX_IO_REQ</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">sc</span> <span class="o">=</span> <span class="n">scsi_host_find_tag</span><span class="p">(</span><span class="n">fnic</span><span class="o">-&gt;</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span> <span class="n">id</span> <span class="o">&amp;</span> <span class="n">FNIC_TAG_MASK</span><span class="p">);</span>
	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="o">!</span><span class="n">sc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sc</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">io_lock</span> <span class="o">=</span> <span class="n">fnic_io_lock_hash</span><span class="p">(</span><span class="n">fnic</span><span class="p">,</span> <span class="n">sc</span><span class="p">);</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">io_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">io_req</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">fnic_io_req</span> <span class="o">*</span><span class="p">)</span><span class="n">CMD_SP</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="o">!</span><span class="n">io_req</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">io_req</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">io_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">&amp;</span> <span class="n">FNIC_TAG_ABORT</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Completion of abort cmd */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">CMD_STATE</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span> <span class="o">!=</span> <span class="n">FNIC_IOREQ_ABTS_PENDING</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* This is a late completion. Ignore it */</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">io_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">CMD_STATE</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span> <span class="o">=</span> <span class="n">FNIC_IOREQ_ABTS_COMPLETE</span><span class="p">;</span>
		<span class="n">CMD_ABTS_STATUS</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span> <span class="o">=</span> <span class="n">hdr_status</span><span class="p">;</span>

		<span class="n">FNIC_SCSI_DBG</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="n">fnic</span><span class="o">-&gt;</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span>
			      <span class="s">&quot;abts cmpl recd. id %d status %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			      <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">id</span> <span class="o">&amp;</span> <span class="n">FNIC_TAG_MASK</span><span class="p">),</span>
			      <span class="n">fnic_fcpio_status_to_str</span><span class="p">(</span><span class="n">hdr_status</span><span class="p">));</span>

		<span class="cm">/*</span>
<span class="cm">		 * If scsi_eh thread is blocked waiting for abts to complete,</span>
<span class="cm">		 * signal completion to it. IO will be cleaned in the thread</span>
<span class="cm">		 * else clean it in this context</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">io_req</span><span class="o">-&gt;</span><span class="n">abts_done</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">complete</span><span class="p">(</span><span class="n">io_req</span><span class="o">-&gt;</span><span class="n">abts_done</span><span class="p">);</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">io_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">FNIC_SCSI_DBG</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="n">fnic</span><span class="o">-&gt;</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span>
				      <span class="s">&quot;abts cmpl, completing IO</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">CMD_SP</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">sc</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DID_ERROR</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>

			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">io_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

			<span class="n">fnic_release_ioreq_buf</span><span class="p">(</span><span class="n">fnic</span><span class="p">,</span> <span class="n">io_req</span><span class="p">,</span> <span class="n">sc</span><span class="p">);</span>
			<span class="n">mempool_free</span><span class="p">(</span><span class="n">io_req</span><span class="p">,</span> <span class="n">fnic</span><span class="o">-&gt;</span><span class="n">io_req_pool</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">)</span>
				<span class="n">sc</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
		<span class="p">}</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">&amp;</span> <span class="n">FNIC_TAG_DEV_RST</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Completion of device reset */</span>
		<span class="n">CMD_LR_STATUS</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span> <span class="o">=</span> <span class="n">hdr_status</span><span class="p">;</span>
		<span class="n">CMD_STATE</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span> <span class="o">=</span> <span class="n">FNIC_IOREQ_CMD_COMPLETE</span><span class="p">;</span>
		<span class="n">FNIC_SCSI_DBG</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="n">fnic</span><span class="o">-&gt;</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span>
			      <span class="s">&quot;dev reset cmpl recd. id %d status %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			      <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">id</span> <span class="o">&amp;</span> <span class="n">FNIC_TAG_MASK</span><span class="p">),</span>
			      <span class="n">fnic_fcpio_status_to_str</span><span class="p">(</span><span class="n">hdr_status</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">io_req</span><span class="o">-&gt;</span><span class="n">dr_done</span><span class="p">)</span>
			<span class="n">complete</span><span class="p">(</span><span class="n">io_req</span><span class="o">-&gt;</span><span class="n">dr_done</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">io_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">shost_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">fnic</span><span class="o">-&gt;</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span>
			     <span class="s">&quot;Unexpected itmf io state %s tag %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">fnic_ioreq_state_to_str</span><span class="p">(</span><span class="n">CMD_STATE</span><span class="p">(</span><span class="n">sc</span><span class="p">)),</span> <span class="n">id</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">io_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * fnic_fcpio_cmpl_handler</span>
<span class="cm"> * Routine to service the cq for wq_copy</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">fnic_fcpio_cmpl_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">vnic_dev</span> <span class="o">*</span><span class="n">vdev</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cq_index</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">fcpio_fw_req</span> <span class="o">*</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fnic</span> <span class="o">*</span><span class="n">fnic</span> <span class="o">=</span> <span class="n">vnic_dev_priv</span><span class="p">(</span><span class="n">vdev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">FCPIO_ACK</span>: <span class="cm">/* fw copied copy wq desc to its queue */</span>
		<span class="n">fnic_fcpio_ack_handler</span><span class="p">(</span><span class="n">fnic</span><span class="p">,</span> <span class="n">cq_index</span><span class="p">,</span> <span class="n">desc</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">FCPIO_ICMND_CMPL</span>: <span class="cm">/* fw completed a command */</span>
		<span class="n">fnic_fcpio_icmnd_cmpl_handler</span><span class="p">(</span><span class="n">fnic</span><span class="p">,</span> <span class="n">desc</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">FCPIO_ITMF_CMPL</span>: <span class="cm">/* fw completed itmf (abort cmd, lun reset)*/</span>
		<span class="n">fnic_fcpio_itmf_cmpl_handler</span><span class="p">(</span><span class="n">fnic</span><span class="p">,</span> <span class="n">desc</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">FCPIO_FLOGI_REG_CMPL</span>: <span class="cm">/* fw completed flogi_reg */</span>
	<span class="k">case</span> <span class="n">FCPIO_FLOGI_FIP_REG_CMPL</span>: <span class="cm">/* fw completed flogi_fip_reg */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">fnic_fcpio_flogi_reg_cmpl_handler</span><span class="p">(</span><span class="n">fnic</span><span class="p">,</span> <span class="n">desc</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">FCPIO_RESET_CMPL</span>: <span class="cm">/* fw completed reset */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">fnic_fcpio_fw_reset_cmpl_handler</span><span class="p">(</span><span class="n">fnic</span><span class="p">,</span> <span class="n">desc</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">FNIC_SCSI_DBG</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="n">fnic</span><span class="o">-&gt;</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span>
			      <span class="s">&quot;firmware completion type %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			      <span class="n">desc</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">type</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * fnic_wq_copy_cmpl_handler</span>
<span class="cm"> * Routine to process wq copy</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">fnic_wq_copy_cmpl_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">fnic</span> <span class="o">*</span><span class="n">fnic</span><span class="p">,</span> <span class="kt">int</span> <span class="n">copy_work_to_do</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">wq_work_done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">cq_index</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cur_work_done</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">fnic</span><span class="o">-&gt;</span><span class="n">wq_copy_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cq_index</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">fnic</span><span class="o">-&gt;</span><span class="n">raw_wq_count</span> <span class="o">+</span> <span class="n">fnic</span><span class="o">-&gt;</span><span class="n">rq_count</span><span class="p">;</span>
		<span class="n">cur_work_done</span> <span class="o">=</span> <span class="n">vnic_cq_copy_service</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fnic</span><span class="o">-&gt;</span><span class="n">cq</span><span class="p">[</span><span class="n">cq_index</span><span class="p">],</span>
						     <span class="n">fnic_fcpio_cmpl_handler</span><span class="p">,</span>
						     <span class="n">copy_work_to_do</span><span class="p">);</span>
		<span class="n">wq_work_done</span> <span class="o">+=</span> <span class="n">cur_work_done</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">wq_work_done</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">fnic_cleanup_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">fnic</span> <span class="o">*</span><span class="n">fnic</span><span class="p">,</span> <span class="kt">int</span> <span class="n">exclude_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fnic_io_req</span> <span class="o">*</span><span class="n">io_req</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">sc</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="o">*</span><span class="n">io_lock</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">FNIC_MAX_IO_REQ</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">exclude_id</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">sc</span> <span class="o">=</span> <span class="n">scsi_host_find_tag</span><span class="p">(</span><span class="n">fnic</span><span class="o">-&gt;</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sc</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">io_lock</span> <span class="o">=</span> <span class="n">fnic_io_lock_hash</span><span class="p">(</span><span class="n">fnic</span><span class="p">,</span> <span class="n">sc</span><span class="p">);</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">io_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">io_req</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">fnic_io_req</span> <span class="o">*</span><span class="p">)</span><span class="n">CMD_SP</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">io_req</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">io_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">cleanup_scsi_cmd</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">CMD_SP</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">io_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * If there is a scsi_cmnd associated with this io_req, then</span>
<span class="cm">		 * free the corresponding state</span>
<span class="cm">		 */</span>
		<span class="n">fnic_release_ioreq_buf</span><span class="p">(</span><span class="n">fnic</span><span class="p">,</span> <span class="n">io_req</span><span class="p">,</span> <span class="n">sc</span><span class="p">);</span>
		<span class="n">mempool_free</span><span class="p">(</span><span class="n">io_req</span><span class="p">,</span> <span class="n">fnic</span><span class="o">-&gt;</span><span class="n">io_req_pool</span><span class="p">);</span>

<span class="nl">cleanup_scsi_cmd:</span>
		<span class="n">sc</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_TRANSPORT_DISRUPTED</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="n">FNIC_SCSI_DBG</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="n">fnic</span><span class="o">-&gt;</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span> <span class="s">&quot;fnic_cleanup_io:&quot;</span>
			      <span class="s">&quot; DID_TRANSPORT_DISRUPTED</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="cm">/* Complete the command to SCSI */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">)</span>
			<span class="n">sc</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">fnic_wq_copy_cleanup_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">vnic_wq_copy</span> <span class="o">*</span><span class="n">wq</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">fcpio_host_req</span> <span class="o">*</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fnic</span> <span class="o">*</span><span class="n">fnic</span> <span class="o">=</span> <span class="n">vnic_dev_priv</span><span class="p">(</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fnic_io_req</span> <span class="o">*</span><span class="n">io_req</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">sc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="o">*</span><span class="n">io_lock</span><span class="p">;</span>

	<span class="cm">/* get the tag reference */</span>
	<span class="n">fcpio_tag_id_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">tag</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">id</span><span class="p">);</span>
	<span class="n">id</span> <span class="o">&amp;=</span> <span class="n">FNIC_TAG_MASK</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">&gt;=</span> <span class="n">FNIC_MAX_IO_REQ</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">sc</span> <span class="o">=</span> <span class="n">scsi_host_find_tag</span><span class="p">(</span><span class="n">fnic</span><span class="o">-&gt;</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sc</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">io_lock</span> <span class="o">=</span> <span class="n">fnic_io_lock_hash</span><span class="p">(</span><span class="n">fnic</span><span class="p">,</span> <span class="n">sc</span><span class="p">);</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">io_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Get the IO context which this desc refers to */</span>
	<span class="n">io_req</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">fnic_io_req</span> <span class="o">*</span><span class="p">)</span><span class="n">CMD_SP</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>

	<span class="cm">/* fnic interrupts are turned off by now */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">io_req</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">io_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">wq_copy_cleanup_scsi_cmd</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">CMD_SP</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">io_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">fnic_release_ioreq_buf</span><span class="p">(</span><span class="n">fnic</span><span class="p">,</span> <span class="n">io_req</span><span class="p">,</span> <span class="n">sc</span><span class="p">);</span>
	<span class="n">mempool_free</span><span class="p">(</span><span class="n">io_req</span><span class="p">,</span> <span class="n">fnic</span><span class="o">-&gt;</span><span class="n">io_req_pool</span><span class="p">);</span>

<span class="nl">wq_copy_cleanup_scsi_cmd:</span>
	<span class="n">sc</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_NO_CONNECT</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
	<span class="n">FNIC_SCSI_DBG</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="n">fnic</span><span class="o">-&gt;</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span> <span class="s">&quot;wq_copy_cleanup_handler:&quot;</span>
		      <span class="s">&quot; DID_NO_CONNECT</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">)</span>
		<span class="n">sc</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">fnic_queue_abort_io_req</span><span class="p">(</span><span class="k">struct</span> <span class="n">fnic</span> <span class="o">*</span><span class="n">fnic</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tag</span><span class="p">,</span>
					  <span class="n">u32</span> <span class="n">task_req</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">fc_lun</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">fnic_io_req</span> <span class="o">*</span><span class="n">io_req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vnic_wq_copy</span> <span class="o">*</span><span class="n">wq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fnic</span><span class="o">-&gt;</span><span class="n">wq_copy</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fnic</span><span class="o">-&gt;</span><span class="n">wq_copy_lock</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vnic_wq_copy_desc_avail</span><span class="p">(</span><span class="n">wq</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">fnic</span><span class="o">-&gt;</span><span class="n">wq_copy_desc_low</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
		<span class="n">free_wq_copy_descs</span><span class="p">(</span><span class="n">fnic</span><span class="p">,</span> <span class="n">wq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vnic_wq_copy_desc_avail</span><span class="p">(</span><span class="n">wq</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fnic</span><span class="o">-&gt;</span><span class="n">wq_copy_lock</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">fnic_queue_wq_copy_desc_itmf</span><span class="p">(</span><span class="n">wq</span><span class="p">,</span> <span class="n">tag</span> <span class="o">|</span> <span class="n">FNIC_TAG_ABORT</span><span class="p">,</span>
				     <span class="mi">0</span><span class="p">,</span> <span class="n">task_req</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="n">fc_lun</span><span class="p">,</span> <span class="n">io_req</span><span class="o">-&gt;</span><span class="n">port_id</span><span class="p">,</span>
				     <span class="n">fnic</span><span class="o">-&gt;</span><span class="n">config</span><span class="p">.</span><span class="n">ra_tov</span><span class="p">,</span> <span class="n">fnic</span><span class="o">-&gt;</span><span class="n">config</span><span class="p">.</span><span class="n">ed_tov</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fnic</span><span class="o">-&gt;</span><span class="n">wq_copy_lock</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">fnic_rport_exch_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">fnic</span> <span class="o">*</span><span class="n">fnic</span><span class="p">,</span> <span class="n">u32</span> <span class="n">port_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">tag</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fnic_io_req</span> <span class="o">*</span><span class="n">io_req</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="o">*</span><span class="n">io_lock</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">sc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_lun</span> <span class="n">fc_lun</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">fnic_ioreq_state</span> <span class="n">old_ioreq_state</span><span class="p">;</span>

	<span class="n">FNIC_SCSI_DBG</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="p">,</span>
		      <span class="n">fnic</span><span class="o">-&gt;</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span>
		      <span class="s">&quot;fnic_rport_reset_exch called portid 0x%06x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		      <span class="n">port_id</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fnic</span><span class="o">-&gt;</span><span class="n">in_remove</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">tag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">tag</span> <span class="o">&lt;</span> <span class="n">FNIC_MAX_IO_REQ</span><span class="p">;</span> <span class="n">tag</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sc</span> <span class="o">=</span> <span class="n">scsi_host_find_tag</span><span class="p">(</span><span class="n">fnic</span><span class="o">-&gt;</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span> <span class="n">tag</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sc</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">io_lock</span> <span class="o">=</span> <span class="n">fnic_io_lock_hash</span><span class="p">(</span><span class="n">fnic</span><span class="p">,</span> <span class="n">sc</span><span class="p">);</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">io_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="n">io_req</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">fnic_io_req</span> <span class="o">*</span><span class="p">)</span><span class="n">CMD_SP</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">io_req</span> <span class="o">||</span> <span class="n">io_req</span><span class="o">-&gt;</span><span class="n">port_id</span> <span class="o">!=</span> <span class="n">port_id</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">io_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Found IO that is still pending with firmware and</span>
<span class="cm">		 * belongs to rport that went away</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">CMD_STATE</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span> <span class="o">==</span> <span class="n">FNIC_IOREQ_ABTS_PENDING</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">io_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">old_ioreq_state</span> <span class="o">=</span> <span class="n">CMD_STATE</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
		<span class="n">CMD_STATE</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span> <span class="o">=</span> <span class="n">FNIC_IOREQ_ABTS_PENDING</span><span class="p">;</span>
		<span class="n">CMD_ABTS_STATUS</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span> <span class="o">=</span> <span class="n">FCPIO_INVALID_CODE</span><span class="p">;</span>

		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">io_req</span><span class="o">-&gt;</span><span class="n">abts_done</span><span class="p">);</span>

		<span class="n">FNIC_SCSI_DBG</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="n">fnic</span><span class="o">-&gt;</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span>
			      <span class="s">&quot;fnic_rport_reset_exch: Issuing abts</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">io_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="cm">/* Now queue the abort command to firmware */</span>
		<span class="n">int_to_scsilun</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fc_lun</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">fnic_queue_abort_io_req</span><span class="p">(</span><span class="n">fnic</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span>
					    <span class="n">FCPIO_ITMF_ABT_TASK_TERM</span><span class="p">,</span>
					    <span class="n">fc_lun</span><span class="p">.</span><span class="n">scsi_lun</span><span class="p">,</span> <span class="n">io_req</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Revert the cmd state back to old state, if</span>
<span class="cm">			 * it hasn&#39;t changed in between. This cmd will get</span>
<span class="cm">			 * aborted later by scsi_eh, or cleaned up during</span>
<span class="cm">			 * lun reset</span>
<span class="cm">			 */</span>
			<span class="n">io_lock</span> <span class="o">=</span> <span class="n">fnic_io_lock_hash</span><span class="p">(</span><span class="n">fnic</span><span class="p">,</span> <span class="n">sc</span><span class="p">);</span>

			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">io_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">CMD_STATE</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span> <span class="o">==</span> <span class="n">FNIC_IOREQ_ABTS_PENDING</span><span class="p">)</span>
				<span class="n">CMD_STATE</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span> <span class="o">=</span> <span class="n">old_ioreq_state</span><span class="p">;</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">io_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="p">}</span>

<span class="kt">void</span> <span class="n">fnic_terminate_rport_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_rport</span> <span class="o">*</span><span class="n">rport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">tag</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fnic_io_req</span> <span class="o">*</span><span class="n">io_req</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="o">*</span><span class="n">io_lock</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">sc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_lun</span> <span class="n">fc_lun</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_rport_libfc_priv</span> <span class="o">*</span><span class="n">rdata</span> <span class="o">=</span> <span class="n">rport</span><span class="o">-&gt;</span><span class="n">dd_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lport</span> <span class="o">=</span> <span class="n">rdata</span><span class="o">-&gt;</span><span class="n">local_port</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fnic</span> <span class="o">*</span><span class="n">fnic</span> <span class="o">=</span> <span class="n">lport_priv</span><span class="p">(</span><span class="n">lport</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fc_rport</span> <span class="o">*</span><span class="n">cmd_rport</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">fnic_ioreq_state</span> <span class="n">old_ioreq_state</span><span class="p">;</span>

	<span class="n">FNIC_SCSI_DBG</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="p">,</span>
		      <span class="n">fnic</span><span class="o">-&gt;</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span> <span class="s">&quot;fnic_terminate_rport_io called&quot;</span>
		      <span class="s">&quot; wwpn 0x%llx, wwnn0x%llx, portid 0x%06x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		      <span class="n">rport</span><span class="o">-&gt;</span><span class="n">port_name</span><span class="p">,</span> <span class="n">rport</span><span class="o">-&gt;</span><span class="n">node_name</span><span class="p">,</span>
		      <span class="n">rport</span><span class="o">-&gt;</span><span class="n">port_id</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fnic</span><span class="o">-&gt;</span><span class="n">in_remove</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">tag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">tag</span> <span class="o">&lt;</span> <span class="n">FNIC_MAX_IO_REQ</span><span class="p">;</span> <span class="n">tag</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sc</span> <span class="o">=</span> <span class="n">scsi_host_find_tag</span><span class="p">(</span><span class="n">fnic</span><span class="o">-&gt;</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span> <span class="n">tag</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sc</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">cmd_rport</span> <span class="o">=</span> <span class="n">starget_to_rport</span><span class="p">(</span><span class="n">scsi_target</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rport</span> <span class="o">!=</span> <span class="n">cmd_rport</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">io_lock</span> <span class="o">=</span> <span class="n">fnic_io_lock_hash</span><span class="p">(</span><span class="n">fnic</span><span class="p">,</span> <span class="n">sc</span><span class="p">);</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">io_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="n">io_req</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">fnic_io_req</span> <span class="o">*</span><span class="p">)</span><span class="n">CMD_SP</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">io_req</span> <span class="o">||</span> <span class="n">rport</span> <span class="o">!=</span> <span class="n">cmd_rport</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">io_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Found IO that is still pending with firmware and</span>
<span class="cm">		 * belongs to rport that went away</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">CMD_STATE</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span> <span class="o">==</span> <span class="n">FNIC_IOREQ_ABTS_PENDING</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">io_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">old_ioreq_state</span> <span class="o">=</span> <span class="n">CMD_STATE</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
		<span class="n">CMD_STATE</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span> <span class="o">=</span> <span class="n">FNIC_IOREQ_ABTS_PENDING</span><span class="p">;</span>
		<span class="n">CMD_ABTS_STATUS</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span> <span class="o">=</span> <span class="n">FCPIO_INVALID_CODE</span><span class="p">;</span>

		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">io_req</span><span class="o">-&gt;</span><span class="n">abts_done</span><span class="p">);</span>

		<span class="n">FNIC_SCSI_DBG</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="p">,</span>
			      <span class="n">fnic</span><span class="o">-&gt;</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span>
			      <span class="s">&quot;fnic_terminate_rport_io: Issuing abts</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">io_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="cm">/* Now queue the abort command to firmware */</span>
		<span class="n">int_to_scsilun</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fc_lun</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">fnic_queue_abort_io_req</span><span class="p">(</span><span class="n">fnic</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span>
					    <span class="n">FCPIO_ITMF_ABT_TASK_TERM</span><span class="p">,</span>
					    <span class="n">fc_lun</span><span class="p">.</span><span class="n">scsi_lun</span><span class="p">,</span> <span class="n">io_req</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Revert the cmd state back to old state, if</span>
<span class="cm">			 * it hasn&#39;t changed in between. This cmd will get</span>
<span class="cm">			 * aborted later by scsi_eh, or cleaned up during</span>
<span class="cm">			 * lun reset</span>
<span class="cm">			 */</span>
			<span class="n">io_lock</span> <span class="o">=</span> <span class="n">fnic_io_lock_hash</span><span class="p">(</span><span class="n">fnic</span><span class="p">,</span> <span class="n">sc</span><span class="p">);</span>

			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">io_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">CMD_STATE</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span> <span class="o">==</span> <span class="n">FNIC_IOREQ_ABTS_PENDING</span><span class="p">)</span>
				<span class="n">CMD_STATE</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span> <span class="o">=</span> <span class="n">old_ioreq_state</span><span class="p">;</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">io_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This function is exported to SCSI for sending abort cmnds.</span>
<span class="cm"> * A SCSI IO is represented by a io_req in the driver.</span>
<span class="cm"> * The ioreq is linked to the SCSI Cmd, thus a link with the ULP&#39;s IO.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">fnic_abort_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">sc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fnic</span> <span class="o">*</span><span class="n">fnic</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fnic_io_req</span> <span class="o">*</span><span class="n">io_req</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_rport</span> <span class="o">*</span><span class="n">rport</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="o">*</span><span class="n">io_lock</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">SUCCESS</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">task_req</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_lun</span> <span class="n">fc_lun</span><span class="p">;</span>
	<span class="n">DECLARE_COMPLETION_ONSTACK</span><span class="p">(</span><span class="n">tm_done</span><span class="p">);</span>

	<span class="cm">/* Wait for rport to unblock */</span>
	<span class="n">fc_block_scsi_eh</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>

	<span class="cm">/* Get local-port, check ready and link up */</span>
	<span class="n">lp</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>

	<span class="n">fnic</span> <span class="o">=</span> <span class="n">lport_priv</span><span class="p">(</span><span class="n">lp</span><span class="p">);</span>
	<span class="n">rport</span> <span class="o">=</span> <span class="n">starget_to_rport</span><span class="p">(</span><span class="n">scsi_target</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">));</span>
	<span class="n">FNIC_SCSI_DBG</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="n">fnic</span><span class="o">-&gt;</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span>
			<span class="s">&quot;Abort Cmd called FCID 0x%x, LUN 0x%x TAG %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">rport</span><span class="o">-&gt;</span><span class="n">port_id</span><span class="p">,</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">,</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">tag</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">LPORT_ST_READY</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">link_up</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">FAILED</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fnic_abort_cmd_end</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Avoid a race between SCSI issuing the abort and the device</span>
<span class="cm">	 * completing the command.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If the command is already completed by the fw cmpl code,</span>
<span class="cm">	 * we just return SUCCESS from here. This means that the abort</span>
<span class="cm">	 * succeeded. In the SCSI ML, since the timeout for command has</span>
<span class="cm">	 * happened, the completion wont actually complete the command</span>
<span class="cm">	 * and it will be considered as an aborted command</span>
<span class="cm">	 *</span>
<span class="cm">	 * The CMD_SP will not be cleared except while holding io_req_lock.</span>
<span class="cm">	 */</span>
	<span class="n">io_lock</span> <span class="o">=</span> <span class="n">fnic_io_lock_hash</span><span class="p">(</span><span class="n">fnic</span><span class="p">,</span> <span class="n">sc</span><span class="p">);</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">io_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">io_req</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">fnic_io_req</span> <span class="o">*</span><span class="p">)</span><span class="n">CMD_SP</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">io_req</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">io_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fnic_abort_cmd_end</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">io_req</span><span class="o">-&gt;</span><span class="n">abts_done</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tm_done</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">CMD_STATE</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span> <span class="o">==</span> <span class="n">FNIC_IOREQ_ABTS_PENDING</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">io_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">wait_pending</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Command is still pending, need to abort it</span>
<span class="cm">	 * If the firmware completes the command after this point,</span>
<span class="cm">	 * the completion wont be done till mid-layer, since abort</span>
<span class="cm">	 * has already started.</span>
<span class="cm">	 */</span>
	<span class="n">CMD_STATE</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span> <span class="o">=</span> <span class="n">FNIC_IOREQ_ABTS_PENDING</span><span class="p">;</span>
	<span class="n">CMD_ABTS_STATUS</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span> <span class="o">=</span> <span class="n">FCPIO_INVALID_CODE</span><span class="p">;</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">io_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check readiness of the remote port. If the path to remote</span>
<span class="cm">	 * port is up, then send abts to the remote port to terminate</span>
<span class="cm">	 * the IO. Else, just locally terminate the IO in the firmware</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fc_remote_port_chkready</span><span class="p">(</span><span class="n">rport</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">task_req</span> <span class="o">=</span> <span class="n">FCPIO_ITMF_ABT_TASK</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">task_req</span> <span class="o">=</span> <span class="n">FCPIO_ITMF_ABT_TASK_TERM</span><span class="p">;</span>

	<span class="cm">/* Now queue the abort command to firmware */</span>
	<span class="n">int_to_scsilun</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fc_lun</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fnic_queue_abort_io_req</span><span class="p">(</span><span class="n">fnic</span><span class="p">,</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">tag</span><span class="p">,</span> <span class="n">task_req</span><span class="p">,</span>
				    <span class="n">fc_lun</span><span class="p">.</span><span class="n">scsi_lun</span><span class="p">,</span> <span class="n">io_req</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">io_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">io_req</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">fnic_io_req</span> <span class="o">*</span><span class="p">)</span><span class="n">CMD_SP</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">io_req</span><span class="p">)</span>
			<span class="n">io_req</span><span class="o">-&gt;</span><span class="n">abts_done</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">io_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">FAILED</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fnic_abort_cmd_end</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We queued an abort IO, wait for its completion.</span>
<span class="cm">	 * Once the firmware completes the abort command, it will</span>
<span class="cm">	 * wake up this thread.</span>
<span class="cm">	 */</span>
 <span class="nl">wait_pending:</span>
	<span class="n">wait_for_completion_timeout</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tm_done</span><span class="p">,</span>
				    <span class="n">msecs_to_jiffies</span>
				    <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">fnic</span><span class="o">-&gt;</span><span class="n">config</span><span class="p">.</span><span class="n">ra_tov</span> <span class="o">+</span>
				     <span class="n">fnic</span><span class="o">-&gt;</span><span class="n">config</span><span class="p">.</span><span class="n">ed_tov</span><span class="p">));</span>

	<span class="cm">/* Check the abort status */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">io_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">io_req</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">fnic_io_req</span> <span class="o">*</span><span class="p">)</span><span class="n">CMD_SP</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">io_req</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">io_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">FAILED</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fnic_abort_cmd_end</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">io_req</span><span class="o">-&gt;</span><span class="n">abts_done</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* fw did not complete abort, timed out */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">CMD_STATE</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span> <span class="o">==</span> <span class="n">FNIC_IOREQ_ABTS_PENDING</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">io_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">FAILED</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fnic_abort_cmd_end</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * firmware completed the abort, check the status,</span>
<span class="cm">	 * free the io_req irrespective of failure or success</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">CMD_ABTS_STATUS</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span> <span class="o">!=</span> <span class="n">FCPIO_SUCCESS</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">FAILED</span><span class="p">;</span>

	<span class="n">CMD_SP</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">io_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">fnic_release_ioreq_buf</span><span class="p">(</span><span class="n">fnic</span><span class="p">,</span> <span class="n">io_req</span><span class="p">,</span> <span class="n">sc</span><span class="p">);</span>
	<span class="n">mempool_free</span><span class="p">(</span><span class="n">io_req</span><span class="p">,</span> <span class="n">fnic</span><span class="o">-&gt;</span><span class="n">io_req_pool</span><span class="p">);</span>

<span class="nl">fnic_abort_cmd_end:</span>
	<span class="n">FNIC_SCSI_DBG</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="n">fnic</span><span class="o">-&gt;</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span>
		      <span class="s">&quot;Returning from abort cmd %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		      <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">SUCCESS</span><span class="p">)</span> <span class="o">?</span>
		      <span class="s">&quot;SUCCESS&quot;</span> <span class="o">:</span> <span class="s">&quot;FAILED&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">fnic_queue_dr_io_req</span><span class="p">(</span><span class="k">struct</span> <span class="n">fnic</span> <span class="o">*</span><span class="n">fnic</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">fnic_io_req</span> <span class="o">*</span><span class="n">io_req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vnic_wq_copy</span> <span class="o">*</span><span class="n">wq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fnic</span><span class="o">-&gt;</span><span class="n">wq_copy</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">scsi_lun</span> <span class="n">fc_lun</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">intr_flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fnic</span><span class="o">-&gt;</span><span class="n">wq_copy_lock</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">intr_flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vnic_wq_copy_desc_avail</span><span class="p">(</span><span class="n">wq</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">fnic</span><span class="o">-&gt;</span><span class="n">wq_copy_desc_low</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
		<span class="n">free_wq_copy_descs</span><span class="p">(</span><span class="n">fnic</span><span class="p">,</span> <span class="n">wq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vnic_wq_copy_desc_avail</span><span class="p">(</span><span class="n">wq</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">lr_io_req_end</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* fill in the lun info */</span>
	<span class="n">int_to_scsilun</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fc_lun</span><span class="p">);</span>

	<span class="n">fnic_queue_wq_copy_desc_itmf</span><span class="p">(</span><span class="n">wq</span><span class="p">,</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">tag</span> <span class="o">|</span> <span class="n">FNIC_TAG_DEV_RST</span><span class="p">,</span>
				     <span class="mi">0</span><span class="p">,</span> <span class="n">FCPIO_ITMF_LUN_RESET</span><span class="p">,</span> <span class="n">SCSI_NO_TAG</span><span class="p">,</span>
				     <span class="n">fc_lun</span><span class="p">.</span><span class="n">scsi_lun</span><span class="p">,</span> <span class="n">io_req</span><span class="o">-&gt;</span><span class="n">port_id</span><span class="p">,</span>
				     <span class="n">fnic</span><span class="o">-&gt;</span><span class="n">config</span><span class="p">.</span><span class="n">ra_tov</span><span class="p">,</span> <span class="n">fnic</span><span class="o">-&gt;</span><span class="n">config</span><span class="p">.</span><span class="n">ed_tov</span><span class="p">);</span>

<span class="nl">lr_io_req_end:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fnic</span><span class="o">-&gt;</span><span class="n">wq_copy_lock</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">intr_flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Clean up any pending aborts on the lun</span>
<span class="cm"> * For each outstanding IO on this lun, whose abort is not completed by fw,</span>
<span class="cm"> * issue a local abort. Wait for abort to complete. Return 0 if all commands</span>
<span class="cm"> * successfully aborted, 1 otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">fnic_clean_pending_aborts</span><span class="p">(</span><span class="k">struct</span> <span class="n">fnic</span> <span class="o">*</span><span class="n">fnic</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">lr_sc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">tag</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fnic_io_req</span> <span class="o">*</span><span class="n">io_req</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="o">*</span><span class="n">io_lock</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">sc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_lun</span> <span class="n">fc_lun</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">lun_dev</span> <span class="o">=</span> <span class="n">lr_sc</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">;</span>
	<span class="n">DECLARE_COMPLETION_ONSTACK</span><span class="p">(</span><span class="n">tm_done</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">tag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">tag</span> <span class="o">&lt;</span> <span class="n">FNIC_MAX_IO_REQ</span><span class="p">;</span> <span class="n">tag</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sc</span> <span class="o">=</span> <span class="n">scsi_host_find_tag</span><span class="p">(</span><span class="n">fnic</span><span class="o">-&gt;</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span> <span class="n">tag</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * ignore this lun reset cmd or cmds that do not belong to</span>
<span class="cm">		 * this lun</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sc</span> <span class="o">||</span> <span class="n">sc</span> <span class="o">==</span> <span class="n">lr_sc</span> <span class="o">||</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">!=</span> <span class="n">lun_dev</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">io_lock</span> <span class="o">=</span> <span class="n">fnic_io_lock_hash</span><span class="p">(</span><span class="n">fnic</span><span class="p">,</span> <span class="n">sc</span><span class="p">);</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">io_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="n">io_req</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">fnic_io_req</span> <span class="o">*</span><span class="p">)</span><span class="n">CMD_SP</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">io_req</span> <span class="o">||</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">!=</span> <span class="n">lun_dev</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">io_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Found IO that is still pending with firmware and</span>
<span class="cm">		 * belongs to the LUN that we are resetting</span>
<span class="cm">		 */</span>
		<span class="n">FNIC_SCSI_DBG</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="n">fnic</span><span class="o">-&gt;</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span>
			      <span class="s">&quot;Found IO in %s on lun</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			      <span class="n">fnic_ioreq_state_to_str</span><span class="p">(</span><span class="n">CMD_STATE</span><span class="p">(</span><span class="n">sc</span><span class="p">)));</span>

		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">CMD_STATE</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span> <span class="o">!=</span> <span class="n">FNIC_IOREQ_ABTS_PENDING</span><span class="p">);</span>

		<span class="n">CMD_ABTS_STATUS</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span> <span class="o">=</span> <span class="n">FCPIO_INVALID_CODE</span><span class="p">;</span>
		<span class="n">io_req</span><span class="o">-&gt;</span><span class="n">abts_done</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tm_done</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">io_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="cm">/* Now queue the abort command to firmware */</span>
		<span class="n">int_to_scsilun</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fc_lun</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">fnic_queue_abort_io_req</span><span class="p">(</span><span class="n">fnic</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span>
					    <span class="n">FCPIO_ITMF_ABT_TASK_TERM</span><span class="p">,</span>
					    <span class="n">fc_lun</span><span class="p">.</span><span class="n">scsi_lun</span><span class="p">,</span> <span class="n">io_req</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">io_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">io_req</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">fnic_io_req</span> <span class="o">*</span><span class="p">)</span><span class="n">CMD_SP</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">io_req</span><span class="p">)</span>
				<span class="n">io_req</span><span class="o">-&gt;</span><span class="n">abts_done</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">io_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">clean_pending_aborts_end</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">wait_for_completion_timeout</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tm_done</span><span class="p">,</span>
					    <span class="n">msecs_to_jiffies</span>
					    <span class="p">(</span><span class="n">fnic</span><span class="o">-&gt;</span><span class="n">config</span><span class="p">.</span><span class="n">ed_tov</span><span class="p">));</span>

		<span class="cm">/* Recheck cmd state to check if it is now aborted */</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">io_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">io_req</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">fnic_io_req</span> <span class="o">*</span><span class="p">)</span><span class="n">CMD_SP</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">io_req</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">io_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">clean_pending_aborts_end</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">io_req</span><span class="o">-&gt;</span><span class="n">abts_done</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="cm">/* if abort is still pending with fw, fail */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">CMD_STATE</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span> <span class="o">==</span> <span class="n">FNIC_IOREQ_ABTS_PENDING</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">io_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">clean_pending_aborts_end</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">CMD_SP</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">io_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="n">fnic_release_ioreq_buf</span><span class="p">(</span><span class="n">fnic</span><span class="p">,</span> <span class="n">io_req</span><span class="p">,</span> <span class="n">sc</span><span class="p">);</span>
		<span class="n">mempool_free</span><span class="p">(</span><span class="n">io_req</span><span class="p">,</span> <span class="n">fnic</span><span class="o">-&gt;</span><span class="n">io_req_pool</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">clean_pending_aborts_end:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * SCSI Eh thread issues a Lun Reset when one or more commands on a LUN</span>
<span class="cm"> * fail to get aborted. It calls driver&#39;s eh_device_reset with a SCSI command</span>
<span class="cm"> * on the LUN.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">fnic_device_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">sc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fnic</span> <span class="o">*</span><span class="n">fnic</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fnic_io_req</span> <span class="o">*</span><span class="n">io_req</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_rport</span> <span class="o">*</span><span class="n">rport</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">FAILED</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="o">*</span><span class="n">io_lock</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">DECLARE_COMPLETION_ONSTACK</span><span class="p">(</span><span class="n">tm_done</span><span class="p">);</span>

	<span class="cm">/* Wait for rport to unblock */</span>
	<span class="n">fc_block_scsi_eh</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>

	<span class="cm">/* Get local-port, check ready and link up */</span>
	<span class="n">lp</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>

	<span class="n">fnic</span> <span class="o">=</span> <span class="n">lport_priv</span><span class="p">(</span><span class="n">lp</span><span class="p">);</span>

	<span class="n">rport</span> <span class="o">=</span> <span class="n">starget_to_rport</span><span class="p">(</span><span class="n">scsi_target</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">));</span>
	<span class="n">FNIC_SCSI_DBG</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="n">fnic</span><span class="o">-&gt;</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span>
			<span class="s">&quot;Device reset called FCID 0x%x, LUN 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">rport</span><span class="o">-&gt;</span><span class="n">port_id</span><span class="p">,</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">LPORT_ST_READY</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">link_up</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">fnic_device_reset_end</span><span class="p">;</span>

	<span class="cm">/* Check if remote port up */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fc_remote_port_chkready</span><span class="p">(</span><span class="n">rport</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">fnic_device_reset_end</span><span class="p">;</span>

	<span class="n">io_lock</span> <span class="o">=</span> <span class="n">fnic_io_lock_hash</span><span class="p">(</span><span class="n">fnic</span><span class="p">,</span> <span class="n">sc</span><span class="p">);</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">io_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">io_req</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">fnic_io_req</span> <span class="o">*</span><span class="p">)</span><span class="n">CMD_SP</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If there is a io_req attached to this command, then use it,</span>
<span class="cm">	 * else allocate a new one.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">io_req</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">io_req</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">fnic</span><span class="o">-&gt;</span><span class="n">io_req_pool</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">io_req</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">io_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">fnic_device_reset_end</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">io_req</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">io_req</span><span class="p">));</span>
		<span class="n">io_req</span><span class="o">-&gt;</span><span class="n">port_id</span> <span class="o">=</span> <span class="n">rport</span><span class="o">-&gt;</span><span class="n">port_id</span><span class="p">;</span>
		<span class="n">CMD_SP</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">io_req</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">io_req</span><span class="o">-&gt;</span><span class="n">dr_done</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tm_done</span><span class="p">;</span>
	<span class="n">CMD_STATE</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span> <span class="o">=</span> <span class="n">FNIC_IOREQ_CMD_PENDING</span><span class="p">;</span>
	<span class="n">CMD_LR_STATUS</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span> <span class="o">=</span> <span class="n">FCPIO_INVALID_CODE</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">io_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">FNIC_SCSI_DBG</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="n">fnic</span><span class="o">-&gt;</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span> <span class="s">&quot;TAG %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		      <span class="n">sc</span><span class="o">-&gt;</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">tag</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * issue the device reset, if enqueue failed, clean up the ioreq</span>
<span class="cm">	 * and break assoc with scsi cmd</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fnic_queue_dr_io_req</span><span class="p">(</span><span class="n">fnic</span><span class="p">,</span> <span class="n">sc</span><span class="p">,</span> <span class="n">io_req</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">io_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">io_req</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">fnic_io_req</span> <span class="o">*</span><span class="p">)</span><span class="n">CMD_SP</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">io_req</span><span class="p">)</span>
			<span class="n">io_req</span><span class="o">-&gt;</span><span class="n">dr_done</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fnic_device_reset_clean</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Wait on the local completion for LUN reset.  The io_req may be</span>
<span class="cm">	 * freed while we wait since we hold no lock.</span>
<span class="cm">	 */</span>
	<span class="n">wait_for_completion_timeout</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tm_done</span><span class="p">,</span>
				    <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">FNIC_LUN_RESET_TIMEOUT</span><span class="p">));</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">io_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">io_req</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">fnic_io_req</span> <span class="o">*</span><span class="p">)</span><span class="n">CMD_SP</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">io_req</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">io_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fnic_device_reset_end</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">io_req</span><span class="o">-&gt;</span><span class="n">dr_done</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">CMD_LR_STATUS</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">io_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If lun reset not completed, bail out with failed. io_req</span>
<span class="cm">	 * gets cleaned up during higher levels of EH</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">FCPIO_INVALID_CODE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">FNIC_SCSI_DBG</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="n">fnic</span><span class="o">-&gt;</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span>
			      <span class="s">&quot;Device reset timed out</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fnic_device_reset_end</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Completed, but not successful, clean up the io_req, return fail */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">FCPIO_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">io_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">FNIC_SCSI_DBG</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="p">,</span>
			      <span class="n">fnic</span><span class="o">-&gt;</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span>
			      <span class="s">&quot;Device reset completed - failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">io_req</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">fnic_io_req</span> <span class="o">*</span><span class="p">)</span><span class="n">CMD_SP</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fnic_device_reset_clean</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Clean up any aborts on this lun that have still not</span>
<span class="cm">	 * completed. If any of these fail, then LUN reset fails.</span>
<span class="cm">	 * clean_pending_aborts cleans all cmds on this lun except</span>
<span class="cm">	 * the lun reset cmd. If all cmds get cleaned, the lun reset</span>
<span class="cm">	 * succeeds</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fnic_clean_pending_aborts</span><span class="p">(</span><span class="n">fnic</span><span class="p">,</span> <span class="n">sc</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">io_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">io_req</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">fnic_io_req</span> <span class="o">*</span><span class="p">)</span><span class="n">CMD_SP</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
		<span class="n">FNIC_SCSI_DBG</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="n">fnic</span><span class="o">-&gt;</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span>
			      <span class="s">&quot;Device reset failed&quot;</span>
			      <span class="s">&quot; since could not abort all IOs</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fnic_device_reset_clean</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Clean lun reset command */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">io_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">io_req</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">fnic_io_req</span> <span class="o">*</span><span class="p">)</span><span class="n">CMD_SP</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">io_req</span><span class="p">)</span>
		<span class="cm">/* Completed, and successful */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">SUCCESS</span><span class="p">;</span>

<span class="nl">fnic_device_reset_clean:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">io_req</span><span class="p">)</span>
		<span class="n">CMD_SP</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">io_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">io_req</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fnic_release_ioreq_buf</span><span class="p">(</span><span class="n">fnic</span><span class="p">,</span> <span class="n">io_req</span><span class="p">,</span> <span class="n">sc</span><span class="p">);</span>
		<span class="n">mempool_free</span><span class="p">(</span><span class="n">io_req</span><span class="p">,</span> <span class="n">fnic</span><span class="o">-&gt;</span><span class="n">io_req_pool</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">fnic_device_reset_end:</span>
	<span class="n">FNIC_SCSI_DBG</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="n">fnic</span><span class="o">-&gt;</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span>
		      <span class="s">&quot;Returning from device reset %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		      <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">SUCCESS</span><span class="p">)</span> <span class="o">?</span>
		      <span class="s">&quot;SUCCESS&quot;</span> <span class="o">:</span> <span class="s">&quot;FAILED&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Clean up all IOs, clean up libFC local port */</span>
<span class="kt">int</span> <span class="n">fnic_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fnic</span> <span class="o">*</span><span class="n">fnic</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">SUCCESS</span><span class="p">;</span>

	<span class="n">lp</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="n">fnic</span> <span class="o">=</span> <span class="n">lport_priv</span><span class="p">(</span><span class="n">lp</span><span class="p">);</span>

	<span class="n">FNIC_SCSI_DBG</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="n">fnic</span><span class="o">-&gt;</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span>
		      <span class="s">&quot;fnic_reset called</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Reset local port, this will clean up libFC exchanges,</span>
<span class="cm">	 * reset remote port sessions, and if link is up, begin flogi</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">tt</span><span class="p">.</span><span class="n">lport_reset</span><span class="p">(</span><span class="n">lp</span><span class="p">))</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">FAILED</span><span class="p">;</span>

	<span class="n">FNIC_SCSI_DBG</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="n">fnic</span><span class="o">-&gt;</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span>
		      <span class="s">&quot;Returning from fnic reset %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		      <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">SUCCESS</span><span class="p">)</span> <span class="o">?</span>
		      <span class="s">&quot;SUCCESS&quot;</span> <span class="o">:</span> <span class="s">&quot;FAILED&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * SCSI Error handling calls driver&#39;s eh_host_reset if all prior</span>
<span class="cm"> * error handling levels return FAILED. If host reset completes</span>
<span class="cm"> * successfully, and if link is up, then Fabric login begins.</span>
<span class="cm"> *</span>
<span class="cm"> * Host Reset is the highest level of error recovery. If this fails, then</span>
<span class="cm"> * host is offlined by SCSI.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">fnic_host_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">sc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">wait_host_tmo</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If fnic_reset is successful, wait for fabric login to complete</span>
<span class="cm">	 * scsi-ml tries to send a TUR to every device if host reset is</span>
<span class="cm">	 * successful, so before returning to scsi, fabric should be up</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">fnic_reset</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">SUCCESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">wait_host_tmo</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">FNIC_HOST_RESET_SETTLE_TIME</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">FAILED</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">wait_host_tmo</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">LPORT_ST_READY</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">link_up</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">SUCCESS</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">ssleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This fxn is called from libFC when host is removed</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">fnic_scsi_abort_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">fnic_state</span> <span class="n">old_state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fnic</span> <span class="o">*</span><span class="n">fnic</span> <span class="o">=</span> <span class="n">lport_priv</span><span class="p">(</span><span class="n">lp</span><span class="p">);</span>
	<span class="n">DECLARE_COMPLETION_ONSTACK</span><span class="p">(</span><span class="n">remove_wait</span><span class="p">);</span>

	<span class="cm">/* Issue firmware reset for fnic, wait for reset to complete */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fnic</span><span class="o">-&gt;</span><span class="n">fnic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">fnic</span><span class="o">-&gt;</span><span class="n">remove_wait</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">remove_wait</span><span class="p">;</span>
	<span class="n">old_state</span> <span class="o">=</span> <span class="n">fnic</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>
	<span class="n">fnic</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">FNIC_IN_FC_TRANS_ETH_MODE</span><span class="p">;</span>
	<span class="n">fnic_update_mac_locked</span><span class="p">(</span><span class="n">fnic</span><span class="p">,</span> <span class="n">fnic</span><span class="o">-&gt;</span><span class="n">ctlr</span><span class="p">.</span><span class="n">ctl_src_addr</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fnic</span><span class="o">-&gt;</span><span class="n">fnic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">fnic_fw_reset_handler</span><span class="p">(</span><span class="n">fnic</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fnic</span><span class="o">-&gt;</span><span class="n">fnic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fnic</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">FNIC_IN_FC_TRANS_ETH_MODE</span><span class="p">)</span>
			<span class="n">fnic</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">old_state</span><span class="p">;</span>
		<span class="n">fnic</span><span class="o">-&gt;</span><span class="n">remove_wait</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fnic</span><span class="o">-&gt;</span><span class="n">fnic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Wait for firmware reset to complete */</span>
	<span class="n">wait_for_completion_timeout</span><span class="p">(</span><span class="o">&amp;</span><span class="n">remove_wait</span><span class="p">,</span>
				    <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">FNIC_RMDEVICE_TIMEOUT</span><span class="p">));</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fnic</span><span class="o">-&gt;</span><span class="n">fnic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">fnic</span><span class="o">-&gt;</span><span class="n">remove_wait</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">FNIC_SCSI_DBG</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="n">fnic</span><span class="o">-&gt;</span><span class="n">lport</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span>
		      <span class="s">&quot;fnic_scsi_abort_io %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		      <span class="p">(</span><span class="n">fnic</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">FNIC_IN_ETH_MODE</span><span class="p">)</span> <span class="o">?</span>
		      <span class="s">&quot;SUCCESS&quot;</span> <span class="o">:</span> <span class="s">&quot;FAILED&quot;</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fnic</span><span class="o">-&gt;</span><span class="n">fnic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This fxn called from libFC to clean up driver IO state on link down</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">fnic_scsi_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">fnic_state</span> <span class="n">old_state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fnic</span> <span class="o">*</span><span class="n">fnic</span> <span class="o">=</span> <span class="n">lport_priv</span><span class="p">(</span><span class="n">lp</span><span class="p">);</span>

	<span class="cm">/* issue fw reset */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fnic</span><span class="o">-&gt;</span><span class="n">fnic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">old_state</span> <span class="o">=</span> <span class="n">fnic</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>
	<span class="n">fnic</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">FNIC_IN_FC_TRANS_ETH_MODE</span><span class="p">;</span>
	<span class="n">fnic_update_mac_locked</span><span class="p">(</span><span class="n">fnic</span><span class="p">,</span> <span class="n">fnic</span><span class="o">-&gt;</span><span class="n">ctlr</span><span class="p">.</span><span class="n">ctl_src_addr</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fnic</span><span class="o">-&gt;</span><span class="n">fnic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fnic_fw_reset_handler</span><span class="p">(</span><span class="n">fnic</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fnic</span><span class="o">-&gt;</span><span class="n">fnic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fnic</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">FNIC_IN_FC_TRANS_ETH_MODE</span><span class="p">)</span>
			<span class="n">fnic</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">old_state</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fnic</span><span class="o">-&gt;</span><span class="n">fnic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

<span class="p">}</span>

<span class="kt">void</span> <span class="n">fnic_empty_scsi_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lp</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">fnic_exch_mgr_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_lport</span> <span class="o">*</span><span class="n">lp</span><span class="p">,</span> <span class="n">u32</span> <span class="n">sid</span><span class="p">,</span> <span class="n">u32</span> <span class="n">did</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fnic</span> <span class="o">*</span><span class="n">fnic</span> <span class="o">=</span> <span class="n">lport_priv</span><span class="p">(</span><span class="n">lp</span><span class="p">);</span>

	<span class="cm">/* Non-zero sid, nothing to do */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sid</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">call_fc_exch_mgr_reset</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">did</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fnic_rport_exch_reset</span><span class="p">(</span><span class="n">fnic</span><span class="p">,</span> <span class="n">did</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">call_fc_exch_mgr_reset</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * sid = 0, did = 0</span>
<span class="cm">	 * link down or device being removed</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fnic</span><span class="o">-&gt;</span><span class="n">in_remove</span><span class="p">)</span>
		<span class="n">fnic_scsi_cleanup</span><span class="p">(</span><span class="n">lp</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">fnic_scsi_abort_io</span><span class="p">(</span><span class="n">lp</span><span class="p">);</span>

	<span class="cm">/* call libFC exch mgr reset to reset its exchanges */</span>
<span class="nl">call_fc_exch_mgr_reset:</span>
	<span class="n">fc_exch_mgr_reset</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="n">sid</span><span class="p">,</span> <span class="n">did</span><span class="p">);</span>

<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
