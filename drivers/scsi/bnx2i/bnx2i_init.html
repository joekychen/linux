<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › scsi › bnx2i › bnx2i_init.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>bnx2i_init.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* bnx2i.c: Broadcom NetXtreme II iSCSI driver.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2006 - 2012 Broadcom Corporation</span>
<span class="cm"> * Copyright (c) 2007, 2008 Red Hat, Inc.  All rights reserved.</span>
<span class="cm"> * Copyright (c) 2007, 2008 Mike Christie</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * Written by: Anil Veerabhadrappa (anilgv@broadcom.com)</span>
<span class="cm"> * Maintained by: Eddie Wai (eddie.wai@broadcom.com)</span>
<span class="cm"> */</span>

<span class="cp">#include &quot;bnx2i.h&quot;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="n">adapter_list</span> <span class="o">=</span> <span class="n">LIST_HEAD_INIT</span><span class="p">(</span><span class="n">adapter_list</span><span class="p">);</span>
<span class="k">static</span> <span class="n">u32</span> <span class="n">adapter_count</span><span class="p">;</span>

<span class="cp">#define DRV_MODULE_NAME		&quot;bnx2i&quot;</span>
<span class="cp">#define DRV_MODULE_VERSION	&quot;2.7.2.2&quot;</span>
<span class="cp">#define DRV_MODULE_RELDATE	&quot;Apr 25, 2012&quot;</span>

<span class="k">static</span> <span class="kt">char</span> <span class="n">version</span><span class="p">[]</span> <span class="n">__devinitdata</span> <span class="o">=</span>
		<span class="s">&quot;Broadcom NetXtreme II iSCSI Driver &quot;</span> <span class="n">DRV_MODULE_NAME</span> \
		<span class="s">&quot; v&quot;</span> <span class="n">DRV_MODULE_VERSION</span> <span class="s">&quot; (&quot;</span> <span class="n">DRV_MODULE_RELDATE</span> <span class="s">&quot;)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>


<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Anil Veerabhadrappa &lt;anilgv@broadcom.com&gt; and &quot;</span>
	      <span class="s">&quot;Eddie Wai &lt;eddie.wai@broadcom.com&gt;&quot;</span><span class="p">);</span>

<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Broadcom NetXtreme II BCM5706/5708/5709/57710/57711/57712&quot;</span>
		   <span class="s">&quot;/57800/57810/57840 iSCSI Driver&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_VERSION</span><span class="p">(</span><span class="n">DRV_MODULE_VERSION</span><span class="p">);</span>

<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">bnx2i_dev_lock</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">event_coal_min</span> <span class="o">=</span> <span class="mi">24</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">event_coal_min</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0664</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">event_coal_min</span><span class="p">,</span> <span class="s">&quot;Event Coalescing Minimum Commands&quot;</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">event_coal_div</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">event_coal_div</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0664</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">event_coal_div</span><span class="p">,</span> <span class="s">&quot;Event Coalescing Divide Factor&quot;</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">en_tcp_dack</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">en_tcp_dack</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0664</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">en_tcp_dack</span><span class="p">,</span> <span class="s">&quot;Enable TCP Delayed ACK&quot;</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">error_mask1</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">error_mask1</span><span class="p">,</span> <span class="n">uint</span><span class="p">,</span> <span class="mo">0664</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">error_mask1</span><span class="p">,</span> <span class="s">&quot;Config FW iSCSI Error Mask #1&quot;</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">error_mask2</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">error_mask2</span><span class="p">,</span> <span class="n">uint</span><span class="p">,</span> <span class="mo">0664</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">error_mask2</span><span class="p">,</span> <span class="s">&quot;Config FW iSCSI Error Mask #2&quot;</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sq_size</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">sq_size</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0664</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">sq_size</span><span class="p">,</span> <span class="s">&quot;Configure SQ size&quot;</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rq_size</span> <span class="o">=</span> <span class="n">BNX2I_RQ_WQES_DEFAULT</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">rq_size</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0664</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">rq_size</span><span class="p">,</span> <span class="s">&quot;Configure RQ size&quot;</span><span class="p">);</span>

<span class="n">u64</span> <span class="n">iscsi_error_mask</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>

<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2i_percpu_s</span><span class="p">,</span> <span class="n">bnx2i_percpu</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">bnx2i_cpu_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nfb</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">action</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">hcpu</span><span class="p">);</span>
<span class="cm">/* notification function for CPU hotplug events */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">bnx2i_cpu_notifier</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">notifier_call</span> <span class="o">=</span> <span class="n">bnx2i_cpu_callback</span><span class="p">,</span>
<span class="p">};</span>


<span class="cm">/**</span>
<span class="cm"> * bnx2i_identify_device - identifies NetXtreme II device type</span>
<span class="cm"> * @hba: 		Adapter structure pointer</span>
<span class="cm"> *</span>
<span class="cm"> * This function identifies the NX2 device type and sets appropriate</span>
<span class="cm"> *	queue mailbox register access method, 5709 requires driver to</span>
<span class="cm"> *	access MBOX regs using *bin* mode</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">bnx2i_identify_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2i_hba</span> <span class="o">*</span><span class="n">hba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hba</span><span class="o">-&gt;</span><span class="n">cnic_dev_type</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">pci_did</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_NX2_5706</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">pci_did</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_NX2_5706S</span><span class="p">))</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">BNX2I_NX2_DEV_5706</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">cnic_dev_type</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">pci_did</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_NX2_5708</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">pci_did</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_NX2_5708S</span><span class="p">))</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">BNX2I_NX2_DEV_5708</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">cnic_dev_type</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">pci_did</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_NX2_5709</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">pci_did</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_NX2_5709S</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">BNX2I_NX2_DEV_5709</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">cnic_dev_type</span><span class="p">);</span>
		<span class="n">hba</span><span class="o">-&gt;</span><span class="n">mail_queue_access</span> <span class="o">=</span> <span class="n">BNX2I_MQ_BIN_MODE</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">pci_did</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_NX2_57710</span>    <span class="o">||</span>
		   <span class="n">hba</span><span class="o">-&gt;</span><span class="n">pci_did</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_NX2_57711</span>    <span class="o">||</span>
		   <span class="n">hba</span><span class="o">-&gt;</span><span class="n">pci_did</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_NX2_57711E</span>   <span class="o">||</span>
		   <span class="n">hba</span><span class="o">-&gt;</span><span class="n">pci_did</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_NX2_57712</span>    <span class="o">||</span>
		   <span class="n">hba</span><span class="o">-&gt;</span><span class="n">pci_did</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_NX2_57712E</span>   <span class="o">||</span>
		   <span class="n">hba</span><span class="o">-&gt;</span><span class="n">pci_did</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_NX2_57800</span>    <span class="o">||</span>
		   <span class="n">hba</span><span class="o">-&gt;</span><span class="n">pci_did</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_NX2_57800_MF</span> <span class="o">||</span>
		   <span class="n">hba</span><span class="o">-&gt;</span><span class="n">pci_did</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_NX2_57800_VF</span> <span class="o">||</span>
		   <span class="n">hba</span><span class="o">-&gt;</span><span class="n">pci_did</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_NX2_57810</span>    <span class="o">||</span>
		   <span class="n">hba</span><span class="o">-&gt;</span><span class="n">pci_did</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_NX2_57810_MF</span> <span class="o">||</span>
		   <span class="n">hba</span><span class="o">-&gt;</span><span class="n">pci_did</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_NX2_57810_VF</span> <span class="o">||</span>
		   <span class="n">hba</span><span class="o">-&gt;</span><span class="n">pci_did</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_NX2_57840</span>    <span class="o">||</span>
		   <span class="n">hba</span><span class="o">-&gt;</span><span class="n">pci_did</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_NX2_57840_MF</span> <span class="o">||</span>
		   <span class="n">hba</span><span class="o">-&gt;</span><span class="n">pci_did</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_NX2_57840_VF</span><span class="p">)</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">BNX2I_NX2_DEV_57710</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">cnic_dev_type</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ALERT</span> <span class="s">&quot;bnx2i: unknown device, 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">hba</span><span class="o">-&gt;</span><span class="n">pci_did</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * get_adapter_list_head - returns head of adapter list</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">bnx2i_hba</span> <span class="o">*</span><span class="nf">get_adapter_list_head</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bnx2i_hba</span> <span class="o">*</span><span class="n">hba</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bnx2i_hba</span> <span class="o">*</span><span class="n">tmp_hba</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">adapter_count</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">hba_not_found</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bnx2i_dev_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">tmp_hba</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter_list</span><span class="p">,</span> <span class="n">link</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmp_hba</span><span class="o">-&gt;</span><span class="n">cnic</span> <span class="o">&amp;&amp;</span> <span class="n">tmp_hba</span><span class="o">-&gt;</span><span class="n">cnic</span><span class="o">-&gt;</span><span class="n">cm_select_dev</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">hba</span> <span class="o">=</span> <span class="n">tmp_hba</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bnx2i_dev_lock</span><span class="p">);</span>
<span class="nl">hba_not_found:</span>
	<span class="k">return</span> <span class="n">hba</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * bnx2i_find_hba_for_cnic - maps cnic device instance to bnx2i adapter instance</span>
<span class="cm"> * @cnic:	pointer to cnic device instance</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">bnx2i_hba</span> <span class="o">*</span><span class="nf">bnx2i_find_hba_for_cnic</span><span class="p">(</span><span class="k">struct</span> <span class="n">cnic_dev</span> <span class="o">*</span><span class="n">cnic</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bnx2i_hba</span> <span class="o">*</span><span class="n">hba</span><span class="p">,</span> <span class="o">*</span><span class="n">temp</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bnx2i_dev_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">hba</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter_list</span><span class="p">,</span> <span class="n">link</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">cnic</span> <span class="o">==</span> <span class="n">cnic</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bnx2i_dev_lock</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">hba</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bnx2i_dev_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * bnx2i_start - cnic callback to initialize &amp; start adapter instance</span>
<span class="cm"> * @handle:	transparent handle pointing to adapter structure</span>
<span class="cm"> *</span>
<span class="cm"> * This function maps adapter structure to pcidev structure and initiates</span>
<span class="cm"> *	firmware handshake to enable/initialize on chip iscsi components</span>
<span class="cm"> * 	This bnx2i - cnic interface api callback is issued after following</span>
<span class="cm"> *	2 conditions are met -</span>
<span class="cm"> *	  a) underlying network interface is up (marked by event &#39;NETDEV_UP&#39;</span>
<span class="cm"> *		from netdev</span>
<span class="cm"> *	  b) bnx2i adapter instance is registered</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">bnx2i_start</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">handle</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#define BNX2I_INIT_POLL_TIME	(1000 / HZ)</span>
	<span class="k">struct</span> <span class="n">bnx2i_hba</span> <span class="o">*</span><span class="n">hba</span> <span class="o">=</span> <span class="n">handle</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">HZ</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We should never register devices that don&#39;t support iSCSI</span>
<span class="cm">	 * (see bnx2i_init_one), so something is wrong if we try to</span>
<span class="cm">	 * start a iSCSI adapter on hardware with 0 supported iSCSI</span>
<span class="cm">	 * connections</span>
<span class="cm">	 */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">cnic</span><span class="o">-&gt;</span><span class="n">max_iscsi_conn</span><span class="p">);</span>

	<span class="n">bnx2i_send_fw_iscsi_init_msg</span><span class="p">(</span><span class="n">hba</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">ADAPTER_STATE_UP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">adapter_state</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
		<span class="n">msleep</span><span class="p">(</span><span class="n">BNX2I_INIT_POLL_TIME</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * bnx2i_chip_cleanup - local routine to handle chip cleanup</span>
<span class="cm"> * @hba:	Adapter instance to register</span>
<span class="cm"> *</span>
<span class="cm"> * Driver checks if adapter still has any active connections before</span>
<span class="cm"> *	executing the cleanup process</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">bnx2i_chip_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2i_hba</span> <span class="o">*</span><span class="n">hba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bnx2i_endpoint</span> <span class="o">*</span><span class="n">bnx2i_ep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">pos</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">ofld_conns_active</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Stage to force the disconnection</span>
<span class="cm">		 * This is the case where the daemon is either slow or</span>
<span class="cm">		 * not present</span>
<span class="cm">		 */</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ALERT</span> <span class="s">&quot;bnx2i: (%s) chip cleanup for %d active &quot;</span>
			<span class="s">&quot;connections</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">hba</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
			<span class="n">hba</span><span class="o">-&gt;</span><span class="n">ofld_conns_active</span><span class="p">);</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">net_dev_lock</span><span class="p">);</span>
		<span class="n">list_for_each_safe</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">ep_active_list</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">bnx2i_ep</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bnx2i_endpoint</span><span class="p">,</span> <span class="n">link</span><span class="p">);</span>
			<span class="cm">/* Clean up the chip only */</span>
			<span class="n">bnx2i_hw_ep_disconnect</span><span class="p">(</span><span class="n">bnx2i_ep</span><span class="p">);</span>
			<span class="n">bnx2i_ep</span><span class="o">-&gt;</span><span class="n">cm_sk</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">net_dev_lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * bnx2i_stop - cnic callback to shutdown adapter instance</span>
<span class="cm"> * @handle:	transparent handle pointing to adapter structure</span>
<span class="cm"> *</span>
<span class="cm"> * driver checks if adapter is already in shutdown mode, if not start</span>
<span class="cm"> *	the shutdown process</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">bnx2i_stop</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">handle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bnx2i_hba</span> <span class="o">*</span><span class="n">hba</span> <span class="o">=</span> <span class="n">handle</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">conns_active</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">wait_delay</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">;</span>

	<span class="cm">/* check if cleanup happened in GOING_DOWN context */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">ADAPTER_STATE_GOING_DOWN</span><span class="p">,</span>
			      <span class="o">&amp;</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">adapter_state</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">iscsi_host_for_each_session</span><span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">shost</span><span class="p">,</span>
					    <span class="n">bnx2i_drop_session</span><span class="p">);</span>
		<span class="n">wait_delay</span> <span class="o">=</span> <span class="n">hba</span><span class="o">-&gt;</span><span class="n">hba_shutdown_tmo</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Wait for inflight offload connection tasks to complete before</span>
<span class="cm">	 * proceeding. Forcefully terminate all connection recovery in</span>
<span class="cm">	 * progress at the earliest, either in bind(), send_pdu(LOGIN),</span>
<span class="cm">	 * or conn_start()</span>
<span class="cm">	 */</span>
	<span class="n">wait_event_interruptible_timeout</span><span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">eh_wait</span><span class="p">,</span>
					 <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">ep_ofld_list</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
					 <span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">ep_destroy_list</span><span class="p">)),</span>
					 <span class="mi">2</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">);</span>
	<span class="cm">/* Wait for all endpoints to be torn down, Chip will be reset once</span>
<span class="cm">	 *  control returns to network driver. So it is required to cleanup and</span>
<span class="cm">	 * release all connection resources before returning from this routine.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">ofld_conns_active</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">conns_active</span> <span class="o">=</span> <span class="n">hba</span><span class="o">-&gt;</span><span class="n">ofld_conns_active</span><span class="p">;</span>
		<span class="n">wait_event_interruptible_timeout</span><span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">eh_wait</span><span class="p">,</span>
				<span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">ofld_conns_active</span> <span class="o">!=</span> <span class="n">conns_active</span><span class="p">),</span>
				<span class="n">wait_delay</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">ofld_conns_active</span> <span class="o">==</span> <span class="n">conns_active</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">bnx2i_chip_cleanup</span><span class="p">(</span><span class="n">hba</span><span class="p">);</span>

	<span class="cm">/* This flag should be cleared last so that ep_disconnect() gracefully</span>
<span class="cm">	 * cleans up connection context</span>
<span class="cm">	 */</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">ADAPTER_STATE_GOING_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">adapter_state</span><span class="p">);</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">ADAPTER_STATE_UP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">adapter_state</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * bnx2i_init_one - initialize an adapter instance and allocate memory resources</span>
<span class="cm"> * @hba:	bnx2i adapter instance</span>
<span class="cm"> * @cnic:	cnic device handle</span>
<span class="cm"> *</span>
<span class="cm"> * Global resource lock is held during critical sections below. This routine is</span>
<span class="cm"> *	called from either cnic_register_driver() or device hot plug context and</span>
<span class="cm"> *	and does majority of device specific initialization</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">bnx2i_init_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">bnx2i_hba</span> <span class="o">*</span><span class="n">hba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cnic_dev</span> <span class="o">*</span><span class="n">cnic</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bnx2i_dev_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cnic</span><span class="o">-&gt;</span><span class="n">max_iscsi_conn</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ALERT</span> <span class="s">&quot;bnx2i: dev %s does not support &quot;</span>
			<span class="s">&quot;iSCSI</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">hba</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">hba</span><span class="o">-&gt;</span><span class="n">cnic</span> <span class="o">=</span> <span class="n">cnic</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">cnic</span><span class="o">-&gt;</span><span class="n">register_device</span><span class="p">(</span><span class="n">cnic</span><span class="p">,</span> <span class="n">CNIC_ULP_ISCSI</span><span class="p">,</span> <span class="n">hba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hba</span><span class="o">-&gt;</span><span class="n">age</span><span class="o">++</span><span class="p">;</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">BNX2I_CNIC_REGISTERED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">reg_with_cnic</span><span class="p">);</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter_list</span><span class="p">);</span>
		<span class="n">adapter_count</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">)</span> 	<span class="cm">/* duplicate registration */</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ALERT</span> <span class="s">&quot;bnx2i, duplicate registration&quot;</span>
				  <span class="s">&quot;hba=%p, cnic=%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">hba</span><span class="p">,</span> <span class="n">cnic</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;bnx2i, driver not registered</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;bnx2i, invalid type %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">CNIC_ULP_ISCSI</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;bnx2i dev reg, unknown error, %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bnx2i_dev_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * bnx2i_ulp_init - initialize an adapter instance</span>
<span class="cm"> * @dev:	cnic device handle</span>
<span class="cm"> *</span>
<span class="cm"> * Called from cnic_register_driver() context to initialize all enumerated</span>
<span class="cm"> *	cnic devices. This routine allocate adapter structure and other</span>
<span class="cm"> *	device specific resources.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">bnx2i_ulp_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">cnic_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bnx2i_hba</span> <span class="o">*</span><span class="n">hba</span><span class="p">;</span>

	<span class="cm">/* Allocate a HBA structure for this device */</span>
	<span class="n">hba</span> <span class="o">=</span> <span class="n">bnx2i_alloc_hba</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hba</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;bnx2i init: hba initialization failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Get PCI related information and update hba struct members */</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">BNX2I_CNIC_REGISTERED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">reg_with_cnic</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bnx2i_init_one</span><span class="p">(</span><span class="n">hba</span><span class="p">,</span> <span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;bnx2i - hba %p init failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">hba</span><span class="p">);</span>
		<span class="n">bnx2i_free_hba</span><span class="p">(</span><span class="n">hba</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * bnx2i_ulp_exit - shuts down adapter instance and frees all resources</span>
<span class="cm"> * @dev:	cnic device handle</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">bnx2i_ulp_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">cnic_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bnx2i_hba</span> <span class="o">*</span><span class="n">hba</span><span class="p">;</span>

	<span class="n">hba</span> <span class="o">=</span> <span class="n">bnx2i_find_hba_for_cnic</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hba</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;bnx2i_ulp_exit: hba not &quot;</span>
				 <span class="s">&quot;found, dev 0x%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bnx2i_dev_lock</span><span class="p">);</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">);</span>
	<span class="n">adapter_count</span><span class="o">--</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">BNX2I_CNIC_REGISTERED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">reg_with_cnic</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">hba</span><span class="o">-&gt;</span><span class="n">cnic</span><span class="o">-&gt;</span><span class="n">unregister_device</span><span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">cnic</span><span class="p">,</span> <span class="n">CNIC_ULP_ISCSI</span><span class="p">);</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">BNX2I_CNIC_REGISTERED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">reg_with_cnic</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bnx2i_dev_lock</span><span class="p">);</span>

	<span class="n">bnx2i_free_hba</span><span class="p">(</span><span class="n">hba</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * bnx2i_percpu_thread_create - Create a receive thread for an</span>
<span class="cm"> *				online CPU</span>
<span class="cm"> *</span>
<span class="cm"> * @cpu:	cpu index for the online cpu</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">bnx2i_percpu_thread_create</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bnx2i_percpu_s</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="kr">thread</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">bnx2i_percpu</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>

	<span class="kr">thread</span> <span class="o">=</span> <span class="n">kthread_create_on_node</span><span class="p">(</span><span class="n">bnx2i_percpu_io_thread</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="p">,</span>
					<span class="n">cpu_to_node</span><span class="p">(</span><span class="n">cpu</span><span class="p">),</span>
					<span class="s">&quot;bnx2i_thread/%d&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="cm">/* bind thread to the cpu */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="kr">thread</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">kthread_bind</span><span class="p">(</span><span class="kr">thread</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">iothread</span> <span class="o">=</span> <span class="kr">thread</span><span class="p">;</span>
		<span class="n">wake_up_process</span><span class="p">(</span><span class="kr">thread</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">bnx2i_percpu_thread_destroy</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bnx2i_percpu_s</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="kr">thread</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bnx2i_work</span> <span class="o">*</span><span class="n">work</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="cm">/* Prevent any new work from being queued for this CPU */</span>
	<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">bnx2i_percpu</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">p_work_lock</span><span class="p">);</span>
	<span class="kr">thread</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">iothread</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">iothread</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Free all work in the list */</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">work_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">bnx2i_process_scsi_cmd_resp</span><span class="p">(</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">,</span>
					    <span class="n">work</span><span class="o">-&gt;</span><span class="n">bnx2i_conn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">cqe</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">work</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">p_work_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="kr">thread</span><span class="p">)</span>
		<span class="n">kthread_stop</span><span class="p">(</span><span class="kr">thread</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * bnx2i_cpu_callback - Handler for CPU hotplug events</span>
<span class="cm"> *</span>
<span class="cm"> * @nfb:	The callback data block</span>
<span class="cm"> * @action:	The event triggering the callback</span>
<span class="cm"> * @hcpu:	The index of the CPU that the event is for</span>
<span class="cm"> *</span>
<span class="cm"> * This creates or destroys per-CPU data for iSCSI</span>
<span class="cm"> *</span>
<span class="cm"> * Returns NOTIFY_OK always.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">bnx2i_cpu_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nfb</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">action</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">hcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">cpu</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">hcpu</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">action</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CPU_ONLINE</span>:
	<span class="k">case</span> <span class="n">CPU_ONLINE_FROZEN</span>:
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;bnx2i: CPU %x online: Create Rx thread</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">cpu</span><span class="p">);</span>
		<span class="n">bnx2i_percpu_thread_create</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CPU_DEAD</span>:
	<span class="k">case</span> <span class="n">CPU_DEAD_FROZEN</span>:
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;CPU %x offline: Remove Rx thread</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="n">bnx2i_percpu_thread_destroy</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">NOTIFY_OK</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * bnx2i_mod_init - module init entry point</span>
<span class="cm"> *</span>
<span class="cm"> * initialize any driver wide global data structures such as endpoint pool,</span>
<span class="cm"> *	tcp port manager/queue, sysfs. finally driver will register itself</span>
<span class="cm"> *	with the cnic module</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">bnx2i_mod_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">cpu</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bnx2i_percpu_s</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">version</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sq_size</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">is_power_of_2</span><span class="p">(</span><span class="n">sq_size</span><span class="p">))</span>
		<span class="n">sq_size</span> <span class="o">=</span> <span class="n">roundup_pow_of_two</span><span class="p">(</span><span class="n">sq_size</span><span class="p">);</span>

	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bnx2i_dev_lock</span><span class="p">);</span>

	<span class="n">bnx2i_scsi_xport_template</span> <span class="o">=</span>
			<span class="n">iscsi_register_transport</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bnx2i_iscsi_transport</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bnx2i_scsi_xport_template</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Could not register bnx2i transport.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">cnic_register_driver</span><span class="p">(</span><span class="n">CNIC_ULP_ISCSI</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bnx2i_cnic_cb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Could not register bnx2i cnic driver.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">unreg_xport</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Create percpu kernel threads to handle iSCSI I/O completions */</span>
	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">bnx2i_percpu</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">work_list</span><span class="p">);</span>
		<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">p_work_lock</span><span class="p">);</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">iothread</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span>
		<span class="n">bnx2i_percpu_thread_create</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>

	<span class="cm">/* Initialize per CPU interrupt thread */</span>
	<span class="n">register_hotcpu_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bnx2i_cpu_notifier</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">unreg_xport:</span>
	<span class="n">iscsi_unregister_transport</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bnx2i_iscsi_transport</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * bnx2i_mod_exit - module cleanup/exit entry point</span>
<span class="cm"> *</span>
<span class="cm"> * Global resource lock and host adapter lock is held during critical sections</span>
<span class="cm"> *	in this function. Driver will browse through the adapter list, cleans-up</span>
<span class="cm"> *	each instance, unregisters iscsi transport name and finally driver will</span>
<span class="cm"> *	unregister itself with the cnic module</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">bnx2i_mod_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bnx2i_hba</span> <span class="o">*</span><span class="n">hba</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">cpu</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bnx2i_dev_lock</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">hba</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">adapter_list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bnx2i_hba</span><span class="p">,</span> <span class="n">link</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">);</span>
		<span class="n">adapter_count</span><span class="o">--</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">BNX2I_CNIC_REGISTERED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">reg_with_cnic</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">bnx2i_chip_cleanup</span><span class="p">(</span><span class="n">hba</span><span class="p">);</span>
			<span class="n">hba</span><span class="o">-&gt;</span><span class="n">cnic</span><span class="o">-&gt;</span><span class="n">unregister_device</span><span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">cnic</span><span class="p">,</span> <span class="n">CNIC_ULP_ISCSI</span><span class="p">);</span>
			<span class="n">clear_bit</span><span class="p">(</span><span class="n">BNX2I_CNIC_REGISTERED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">reg_with_cnic</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">bnx2i_free_hba</span><span class="p">(</span><span class="n">hba</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bnx2i_dev_lock</span><span class="p">);</span>

	<span class="n">unregister_hotcpu_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bnx2i_cpu_notifier</span><span class="p">);</span>

	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span>
		<span class="n">bnx2i_percpu_thread_destroy</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>

	<span class="n">iscsi_unregister_transport</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bnx2i_iscsi_transport</span><span class="p">);</span>
	<span class="n">cnic_unregister_driver</span><span class="p">(</span><span class="n">CNIC_ULP_ISCSI</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">bnx2i_mod_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">bnx2i_mod_exit</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
