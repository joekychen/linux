<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › scsi › pmcraid.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>pmcraid.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * pmcraid.c -- driver for PMC Sierra MaxRAID controller adapters</span>
<span class="cm"> *</span>
<span class="cm"> * Written By: Anil Ravindranath&lt;anil_ravindranath@pmc-sierra.com&gt;</span>
<span class="cm"> *             PMC-Sierra Inc</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2008, 2009 PMC Sierra Inc</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307,</span>
<span class="cm"> * USA</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/ioport.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/wait.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;linux/firmware.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/moduleparam.h&gt;</span>
<span class="cp">#include &lt;linux/hdreg.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;asm/irq.h&gt;</span>
<span class="cp">#include &lt;asm/processor.h&gt;</span>
<span class="cp">#include &lt;linux/libata.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_host.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_device.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_tcq.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_eh.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_cmnd.h&gt;</span>
<span class="cp">#include &lt;scsi/scsicam.h&gt;</span>

<span class="cp">#include &quot;pmcraid.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> *   Module configuration parameters</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pmcraid_debug_log</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pmcraid_disable_aen</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pmcraid_log_level</span> <span class="o">=</span> <span class="n">IOASC_LOG_LEVEL_MUST</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pmcraid_enable_msix</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Data structures to support multiple adapters by the LLD.</span>
<span class="cm"> * pmcraid_adapter_count - count of configured adapters</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">pmcraid_adapter_count</span> <span class="o">=</span> <span class="n">ATOMIC_INIT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Supporting user-level control interface through IOCTL commands.</span>
<span class="cm"> * pmcraid_major - major number to use</span>
<span class="cm"> * pmcraid_minor - minor number(s) to use</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pmcraid_major</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">class</span> <span class="o">*</span><span class="n">pmcraid_class</span><span class="p">;</span>
<span class="n">DECLARE_BITMAP</span><span class="p">(</span><span class="n">pmcraid_minor</span><span class="p">,</span> <span class="n">PMCRAID_MAX_ADAPTERS</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Module parameters</span>
<span class="cm"> */</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Anil Ravindranath&lt;anil_ravindranath@pmc-sierra.com&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;PMC Sierra MaxRAID Controller Driver&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_VERSION</span><span class="p">(</span><span class="n">PMCRAID_DRIVER_VERSION</span><span class="p">);</span>

<span class="n">module_param_named</span><span class="p">(</span><span class="n">log_level</span><span class="p">,</span> <span class="n">pmcraid_log_level</span><span class="p">,</span> <span class="n">uint</span><span class="p">,</span> <span class="p">(</span><span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">));</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">log_level</span><span class="p">,</span>
		 <span class="s">&quot;Enables firmware error code logging, default :1 high-severity&quot;</span>
		 <span class="s">&quot; errors, 2: all errors including high-severity errors,&quot;</span>
		 <span class="s">&quot; 0: disables logging&quot;</span><span class="p">);</span>

<span class="n">module_param_named</span><span class="p">(</span><span class="n">debug</span><span class="p">,</span> <span class="n">pmcraid_debug_log</span><span class="p">,</span> <span class="n">uint</span><span class="p">,</span> <span class="p">(</span><span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">));</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">debug</span><span class="p">,</span>
		 <span class="s">&quot;Enable driver verbose message logging. Set 1 to enable.&quot;</span>
		 <span class="s">&quot;(default: 0)&quot;</span><span class="p">);</span>

<span class="n">module_param_named</span><span class="p">(</span><span class="n">disable_aen</span><span class="p">,</span> <span class="n">pmcraid_disable_aen</span><span class="p">,</span> <span class="n">uint</span><span class="p">,</span> <span class="p">(</span><span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">));</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">disable_aen</span><span class="p">,</span>
		 <span class="s">&quot;Disable driver aen notifications to apps. Set 1 to disable.&quot;</span>
		 <span class="s">&quot;(default: 0)&quot;</span><span class="p">);</span>

<span class="cm">/* chip specific constants for PMC MaxRAID controllers (same for</span>
<span class="cm"> * 0x5220 and 0x8010</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">pmcraid_chip_details</span> <span class="n">pmcraid_chip_cfg</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span>
	 <span class="p">.</span><span class="n">ioastatus</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">ioarrin</span> <span class="o">=</span> <span class="mh">0x00040</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">mailbox</span> <span class="o">=</span> <span class="mh">0x7FC30</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">global_intr_mask</span> <span class="o">=</span> <span class="mh">0x00034</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">ioa_host_intr</span> <span class="o">=</span> <span class="mh">0x0009C</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">ioa_host_intr_clr</span> <span class="o">=</span> <span class="mh">0x000A0</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">ioa_host_msix_intr</span> <span class="o">=</span> <span class="mh">0x7FC40</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">ioa_host_mask</span> <span class="o">=</span> <span class="mh">0x7FC28</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">ioa_host_mask_clr</span> <span class="o">=</span> <span class="mh">0x7FC28</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">host_ioa_intr</span> <span class="o">=</span> <span class="mh">0x00020</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">host_ioa_intr_clr</span> <span class="o">=</span> <span class="mh">0x00020</span><span class="p">,</span>
	 <span class="p">.</span><span class="n">transop_timeout</span> <span class="o">=</span> <span class="mi">300</span>
	 <span class="p">}</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * PCI device ids supported by pmcraid driver</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="n">pmcraid_pci_table</span><span class="p">[]</span> <span class="n">__devinitdata</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_PMC</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_PMC_MAXRAID</span><span class="p">),</span>
	  <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">kernel_ulong_t</span><span class="p">)</span><span class="o">&amp;</span><span class="n">pmcraid_chip_cfg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="p">},</span>
	<span class="p">{}</span>
<span class="p">};</span>

<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">pmcraid_pci_table</span><span class="p">);</span>



<span class="cm">/**</span>
<span class="cm"> * pmcraid_slave_alloc - Prepare for commands to a device</span>
<span class="cm"> * @scsi_dev: scsi device struct</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called by mid-layer prior to sending any command to the new</span>
<span class="cm"> * device. Stores resource entry details of the device in scsi_device struct.</span>
<span class="cm"> * Queuecommand uses the resource handle and other details to fill up IOARCB</span>
<span class="cm"> * while sending commands to the device.</span>
<span class="cm"> *</span>
<span class="cm"> * Return value:</span>
<span class="cm"> *	  0 on success / -ENXIO if device does not exist</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pmcraid_slave_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">scsi_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pmcraid_resource_entry</span> <span class="o">*</span><span class="n">temp</span><span class="p">,</span> <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">target</span><span class="p">,</span> <span class="n">bus</span><span class="p">,</span> <span class="n">lun</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lock_flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">fw_version</span><span class="p">;</span>

	<span class="n">pinstance</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">scsi_dev</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>

	<span class="n">fw_version</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">inq_data</span><span class="o">-&gt;</span><span class="n">fw_version</span><span class="p">);</span>

	<span class="cm">/* Driver exposes VSET and GSCSI resources only; all other device types</span>
<span class="cm">	 * are not exposed. Resource list is synchronized using resource lock</span>
<span class="cm">	 * so any traversal or modifications to the list should be done inside</span>
<span class="cm">	 * this lock</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">resource_lock</span><span class="p">,</span> <span class="n">lock_flags</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">used_res_q</span><span class="p">,</span> <span class="n">queue</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* do not expose VSETs with order-ids &gt; MAX_VSET_TARGETS */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">RES_IS_VSET</span><span class="p">(</span><span class="n">temp</span><span class="o">-&gt;</span><span class="n">cfg_entry</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">fw_version</span> <span class="o">&lt;=</span> <span class="n">PMCRAID_FW_VERSION_1</span><span class="p">)</span>
				<span class="n">target</span> <span class="o">=</span> <span class="n">temp</span><span class="o">-&gt;</span><span class="n">cfg_entry</span><span class="p">.</span><span class="n">unique_flags1</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">target</span> <span class="o">=</span> <span class="n">temp</span><span class="o">-&gt;</span><span class="n">cfg_entry</span><span class="p">.</span><span class="n">array_id</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">target</span> <span class="o">&gt;</span> <span class="n">PMCRAID_MAX_VSET_TARGETS</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">bus</span> <span class="o">=</span> <span class="n">PMCRAID_VSET_BUS_ID</span><span class="p">;</span>
			<span class="n">lun</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">RES_IS_GSCSI</span><span class="p">(</span><span class="n">temp</span><span class="o">-&gt;</span><span class="n">cfg_entry</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">target</span> <span class="o">=</span> <span class="n">RES_TARGET</span><span class="p">(</span><span class="n">temp</span><span class="o">-&gt;</span><span class="n">cfg_entry</span><span class="p">.</span><span class="n">resource_address</span><span class="p">);</span>
			<span class="n">bus</span> <span class="o">=</span> <span class="n">PMCRAID_PHYS_BUS_ID</span><span class="p">;</span>
			<span class="n">lun</span> <span class="o">=</span> <span class="n">RES_LUN</span><span class="p">(</span><span class="n">temp</span><span class="o">-&gt;</span><span class="n">cfg_entry</span><span class="p">.</span><span class="n">resource_address</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">bus</span> <span class="o">==</span> <span class="n">scsi_dev</span><span class="o">-&gt;</span><span class="n">channel</span> <span class="o">&amp;&amp;</span>
		    <span class="n">target</span> <span class="o">==</span> <span class="n">scsi_dev</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">&amp;&amp;</span>
		    <span class="n">lun</span> <span class="o">==</span> <span class="n">scsi_dev</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">res</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">res</span><span class="o">-&gt;</span><span class="n">scsi_dev</span> <span class="o">=</span> <span class="n">scsi_dev</span><span class="p">;</span>
		<span class="n">scsi_dev</span><span class="o">-&gt;</span><span class="n">hostdata</span> <span class="o">=</span> <span class="n">res</span><span class="p">;</span>
		<span class="n">res</span><span class="o">-&gt;</span><span class="n">change_detected</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">read_failures</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">write_failures</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">resource_lock</span><span class="p">,</span> <span class="n">lock_flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_slave_configure - Configures a SCSI device</span>
<span class="cm"> * @scsi_dev: scsi device struct</span>
<span class="cm"> *</span>
<span class="cm"> * This function is executed by SCSI mid layer just after a device is first</span>
<span class="cm"> * scanned (i.e. it has responded to an INQUIRY). For VSET resources, the</span>
<span class="cm"> * timeout value (default 30s) will be over-written to a higher value (60s)</span>
<span class="cm"> * and max_sectors value will be over-written to 512. It also sets queue depth</span>
<span class="cm"> * to host-&gt;cmd_per_lun value</span>
<span class="cm"> *</span>
<span class="cm"> * Return value:</span>
<span class="cm"> *	  0 on success</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pmcraid_slave_configure</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">scsi_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pmcraid_resource_entry</span> <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="n">scsi_dev</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">res</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* LLD exposes VSETs and Enclosure devices only */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">RES_IS_GSCSI</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">cfg_entry</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">scsi_dev</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">TYPE_ENCLOSURE</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>

	<span class="n">pmcraid_info</span><span class="p">(</span><span class="s">&quot;configuring %x:%x:%x:%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">scsi_dev</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">unique_id</span><span class="p">,</span>
		     <span class="n">scsi_dev</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span>
		     <span class="n">scsi_dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span>
		     <span class="n">scsi_dev</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">RES_IS_GSCSI</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">cfg_entry</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">scsi_dev</span><span class="o">-&gt;</span><span class="n">allow_restart</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">RES_IS_VSET</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">cfg_entry</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">scsi_dev</span><span class="o">-&gt;</span><span class="n">allow_restart</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">blk_queue_rq_timeout</span><span class="p">(</span><span class="n">scsi_dev</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="p">,</span>
				     <span class="n">PMCRAID_VSET_IO_TIMEOUT</span><span class="p">);</span>
		<span class="n">blk_queue_max_hw_sectors</span><span class="p">(</span><span class="n">scsi_dev</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="p">,</span>
				      <span class="n">PMCRAID_VSET_MAX_SECTORS</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">scsi_dev</span><span class="o">-&gt;</span><span class="n">tagged_supported</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">RES_IS_GSCSI</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">cfg_entry</span><span class="p">)</span> <span class="o">||</span> <span class="n">RES_IS_VSET</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">cfg_entry</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">scsi_activate_tcq</span><span class="p">(</span><span class="n">scsi_dev</span><span class="p">,</span> <span class="n">scsi_dev</span><span class="o">-&gt;</span><span class="n">queue_depth</span><span class="p">);</span>
		<span class="n">scsi_adjust_queue_depth</span><span class="p">(</span><span class="n">scsi_dev</span><span class="p">,</span> <span class="n">MSG_SIMPLE_TAG</span><span class="p">,</span>
					<span class="n">scsi_dev</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">cmd_per_lun</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">scsi_adjust_queue_depth</span><span class="p">(</span><span class="n">scsi_dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					<span class="n">scsi_dev</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">cmd_per_lun</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_slave_destroy - Unconfigure a SCSI device before removing it</span>
<span class="cm"> *</span>
<span class="cm"> * @scsi_dev: scsi device struct</span>
<span class="cm"> *</span>
<span class="cm"> * This is called by mid-layer before removing a device. Pointer assignments</span>
<span class="cm"> * done in pmcraid_slave_alloc will be reset to NULL here.</span>
<span class="cm"> *</span>
<span class="cm"> * Return value</span>
<span class="cm"> *   none</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pmcraid_slave_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">scsi_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pmcraid_resource_entry</span> <span class="o">*</span><span class="n">res</span><span class="p">;</span>

	<span class="n">res</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_resource_entry</span> <span class="o">*</span><span class="p">)</span><span class="n">scsi_dev</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span>
		<span class="n">res</span><span class="o">-&gt;</span><span class="n">scsi_dev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">scsi_dev</span><span class="o">-&gt;</span><span class="n">hostdata</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_change_queue_depth - Change the device&#39;s queue depth</span>
<span class="cm"> * @scsi_dev: scsi device struct</span>
<span class="cm"> * @depth: depth to set</span>
<span class="cm"> * @reason: calling context</span>
<span class="cm"> *</span>
<span class="cm"> * Return value</span>
<span class="cm"> *	actual depth set</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pmcraid_change_queue_depth</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">scsi_dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">depth</span><span class="p">,</span>
				      <span class="kt">int</span> <span class="n">reason</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reason</span> <span class="o">!=</span> <span class="n">SCSI_QDEPTH_DEFAULT</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">depth</span> <span class="o">&gt;</span> <span class="n">PMCRAID_MAX_CMD_PER_LUN</span><span class="p">)</span>
		<span class="n">depth</span> <span class="o">=</span> <span class="n">PMCRAID_MAX_CMD_PER_LUN</span><span class="p">;</span>

	<span class="n">scsi_adjust_queue_depth</span><span class="p">(</span><span class="n">scsi_dev</span><span class="p">,</span> <span class="n">scsi_get_tag_type</span><span class="p">(</span><span class="n">scsi_dev</span><span class="p">),</span> <span class="n">depth</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">scsi_dev</span><span class="o">-&gt;</span><span class="n">queue_depth</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_change_queue_type - Change the device&#39;s queue type</span>
<span class="cm"> * @scsi_dev: scsi device struct</span>
<span class="cm"> * @tag: type of tags to use</span>
<span class="cm"> *</span>
<span class="cm"> * Return value:</span>
<span class="cm"> *	actual queue type set</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pmcraid_change_queue_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">scsi_dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pmcraid_resource_entry</span> <span class="o">*</span><span class="n">res</span><span class="p">;</span>

	<span class="n">res</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_resource_entry</span> <span class="o">*</span><span class="p">)</span><span class="n">scsi_dev</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">res</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">scsi_dev</span><span class="o">-&gt;</span><span class="n">tagged_supported</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">RES_IS_GSCSI</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">cfg_entry</span><span class="p">)</span> <span class="o">||</span> <span class="n">RES_IS_VSET</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">cfg_entry</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">scsi_set_tag_type</span><span class="p">(</span><span class="n">scsi_dev</span><span class="p">,</span> <span class="n">tag</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tag</span><span class="p">)</span>
			<span class="n">scsi_activate_tcq</span><span class="p">(</span><span class="n">scsi_dev</span><span class="p">,</span> <span class="n">scsi_dev</span><span class="o">-&gt;</span><span class="n">queue_depth</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">scsi_deactivate_tcq</span><span class="p">(</span><span class="n">scsi_dev</span><span class="p">,</span> <span class="n">scsi_dev</span><span class="o">-&gt;</span><span class="n">queue_depth</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">tag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">tag</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * pmcraid_init_cmdblk - initializes a command block</span>
<span class="cm"> *</span>
<span class="cm"> * @cmd: pointer to struct pmcraid_cmd to be initialized</span>
<span class="cm"> * @index: if &gt;=0 first time initialization; otherwise reinitialization</span>
<span class="cm"> *</span>
<span class="cm"> * Return Value</span>
<span class="cm"> *	 None</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">pmcraid_init_cmdblk</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pmcraid_ioarcb</span> <span class="o">*</span><span class="n">ioarcb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ioa_cb</span><span class="o">-&gt;</span><span class="n">ioarcb</span><span class="p">);</span>
	<span class="n">dma_addr_t</span> <span class="n">dma_addr</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ioa_cb_bus_addr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* first time initialization (called from  probe) */</span>
		<span class="n">u32</span> <span class="n">ioasa_offset</span> <span class="o">=</span>
			<span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_control_block</span><span class="p">,</span> <span class="n">ioasa</span><span class="p">);</span>

		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>
		<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">response_handle</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">index</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">);</span>
		<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">ioarcb_bus_addr</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">dma_addr</span><span class="p">);</span>
		<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">ioasa_bus_addr</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">dma_addr</span> <span class="o">+</span> <span class="n">ioasa_offset</span><span class="p">);</span>
		<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">ioasa_len</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_ioasa</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* re-initialization of various lengths, called once command is</span>
<span class="cm">		 * processed by IOA</span>
<span class="cm">		 */</span>
		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ioa_cb</span><span class="o">-&gt;</span><span class="n">ioarcb</span><span class="p">.</span><span class="n">cdb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PMCRAID_MAX_CDB_LEN</span><span class="p">);</span>
		<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">hrrq_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">request_flags0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">request_flags1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">cmd_timeout</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">ioarcb_bus_addr</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="o">~</span><span class="mh">0x1FULL</span><span class="p">);</span>
		<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">ioadl_bus_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">ioadl_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">data_transfer_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">add_cmd_param_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">add_cmd_param_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ioa_cb</span><span class="o">-&gt;</span><span class="n">ioasa</span><span class="p">.</span><span class="n">ioasc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ioa_cb</span><span class="o">-&gt;</span><span class="n">ioasa</span><span class="p">.</span><span class="n">residual_data_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">time_left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmd_done</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_cmd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">release</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">completion_req</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sense_buffer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sense_buffer_dma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">dma_handle</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_reinit_cmdblk - reinitialize a command block</span>
<span class="cm"> *</span>
<span class="cm"> * @cmd: pointer to struct pmcraid_cmd to be reinitialized</span>
<span class="cm"> *</span>
<span class="cm"> * Return Value</span>
<span class="cm"> *	 None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pmcraid_reinit_cmdblk</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pmcraid_init_cmdblk</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_get_free_cmd - get a free cmd block from command block pool</span>
<span class="cm"> * @pinstance: adapter instance structure</span>
<span class="cm"> *</span>
<span class="cm"> * Return Value:</span>
<span class="cm"> *	returns pointer to cmd block or NULL if no blocks are available</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">pmcraid_cmd</span> <span class="o">*</span><span class="nf">pmcraid_get_free_cmd</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span>
<span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pmcraid_cmd</span> <span class="o">*</span><span class="n">cmd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lock_flags</span><span class="p">;</span>

	<span class="cm">/* free cmd block list is protected by free_pool_lock */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">free_pool_lock</span><span class="p">,</span> <span class="n">lock_flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">free_cmd_pool</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cmd</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">free_cmd_pool</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">pmcraid_cmd</span><span class="p">,</span> <span class="n">free_list</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">free_list</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">free_pool_lock</span><span class="p">,</span> <span class="n">lock_flags</span><span class="p">);</span>

	<span class="cm">/* Initialize the command block before giving it the caller */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">pmcraid_reinit_cmdblk</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">cmd</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_return_cmd - return a completed command block back into free pool</span>
<span class="cm"> * @cmd: pointer to the command block</span>
<span class="cm"> *</span>
<span class="cm"> * Return Value:</span>
<span class="cm"> *	nothing</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">pmcraid_return_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">drv_inst</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lock_flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">free_pool_lock</span><span class="p">,</span> <span class="n">lock_flags</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">free_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">free_cmd_pool</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">free_pool_lock</span><span class="p">,</span> <span class="n">lock_flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_read_interrupts -  reads IOA interrupts</span>
<span class="cm"> *</span>
<span class="cm"> * @pinstance: pointer to adapter instance structure</span>
<span class="cm"> *</span>
<span class="cm"> * Return value</span>
<span class="cm"> *	 interrupts read from IOA</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="nf">pmcraid_read_interrupts</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">interrupt_mode</span><span class="p">)</span> <span class="o">?</span>
		<span class="n">ioread32</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">int_regs</span><span class="p">.</span><span class="n">ioa_host_msix_interrupt_reg</span><span class="p">)</span> <span class="o">:</span>
		<span class="n">ioread32</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">int_regs</span><span class="p">.</span><span class="n">ioa_host_interrupt_reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_disable_interrupts - Masks and clears all specified interrupts</span>
<span class="cm"> *</span>
<span class="cm"> * @pinstance: pointer to per adapter instance structure</span>
<span class="cm"> * @intrs: interrupts to disable</span>
<span class="cm"> *</span>
<span class="cm"> * Return Value</span>
<span class="cm"> *	 None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pmcraid_disable_interrupts</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span><span class="p">,</span>
	<span class="n">u32</span> <span class="n">intrs</span>
<span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">gmask</span> <span class="o">=</span> <span class="n">ioread32</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">int_regs</span><span class="p">.</span><span class="n">global_interrupt_mask_reg</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">nmask</span> <span class="o">=</span> <span class="n">gmask</span> <span class="o">|</span> <span class="n">GLOBAL_INTERRUPT_MASK</span><span class="p">;</span>

	<span class="n">iowrite32</span><span class="p">(</span><span class="n">intrs</span><span class="p">,</span> <span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">int_regs</span><span class="p">.</span><span class="n">ioa_host_interrupt_clr_reg</span><span class="p">);</span>
	<span class="n">iowrite32</span><span class="p">(</span><span class="n">nmask</span><span class="p">,</span> <span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">int_regs</span><span class="p">.</span><span class="n">global_interrupt_mask_reg</span><span class="p">);</span>
	<span class="n">ioread32</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">int_regs</span><span class="p">.</span><span class="n">global_interrupt_mask_reg</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">interrupt_mode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iowrite32</span><span class="p">(</span><span class="n">intrs</span><span class="p">,</span>
			<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">int_regs</span><span class="p">.</span><span class="n">ioa_host_interrupt_mask_reg</span><span class="p">);</span>
		<span class="n">ioread32</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">int_regs</span><span class="p">.</span><span class="n">ioa_host_interrupt_mask_reg</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_enable_interrupts - Enables specified interrupts</span>
<span class="cm"> *</span>
<span class="cm"> * @pinstance: pointer to per adapter instance structure</span>
<span class="cm"> * @intr: interrupts to enable</span>
<span class="cm"> *</span>
<span class="cm"> * Return Value</span>
<span class="cm"> *	 None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pmcraid_enable_interrupts</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span><span class="p">,</span>
	<span class="n">u32</span> <span class="n">intrs</span>
<span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">gmask</span> <span class="o">=</span> <span class="n">ioread32</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">int_regs</span><span class="p">.</span><span class="n">global_interrupt_mask_reg</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">nmask</span> <span class="o">=</span> <span class="n">gmask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">GLOBAL_INTERRUPT_MASK</span><span class="p">);</span>

	<span class="n">iowrite32</span><span class="p">(</span><span class="n">nmask</span><span class="p">,</span> <span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">int_regs</span><span class="p">.</span><span class="n">global_interrupt_mask_reg</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">interrupt_mode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iowrite32</span><span class="p">(</span><span class="o">~</span><span class="n">intrs</span><span class="p">,</span>
			 <span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">int_regs</span><span class="p">.</span><span class="n">ioa_host_interrupt_mask_reg</span><span class="p">);</span>
		<span class="n">ioread32</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">int_regs</span><span class="p">.</span><span class="n">ioa_host_interrupt_mask_reg</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">pmcraid_info</span><span class="p">(</span><span class="s">&quot;enabled interrupts global mask = %x intr_mask = %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">ioread32</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">int_regs</span><span class="p">.</span><span class="n">global_interrupt_mask_reg</span><span class="p">),</span>
		<span class="n">ioread32</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">int_regs</span><span class="p">.</span><span class="n">ioa_host_interrupt_mask_reg</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_clr_trans_op - clear trans to op interrupt</span>
<span class="cm"> *</span>
<span class="cm"> * @pinstance: pointer to per adapter instance structure</span>
<span class="cm"> *</span>
<span class="cm"> * Return Value</span>
<span class="cm"> *	 None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pmcraid_clr_trans_op</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span>
<span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lock_flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">interrupt_mode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iowrite32</span><span class="p">(</span><span class="n">INTRS_TRANSITION_TO_OPERATIONAL</span><span class="p">,</span>
			<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">int_regs</span><span class="p">.</span><span class="n">ioa_host_interrupt_mask_reg</span><span class="p">);</span>
		<span class="n">ioread32</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">int_regs</span><span class="p">.</span><span class="n">ioa_host_interrupt_mask_reg</span><span class="p">);</span>
		<span class="n">iowrite32</span><span class="p">(</span><span class="n">INTRS_TRANSITION_TO_OPERATIONAL</span><span class="p">,</span>
			<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">int_regs</span><span class="p">.</span><span class="n">ioa_host_interrupt_clr_reg</span><span class="p">);</span>
		<span class="n">ioread32</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">int_regs</span><span class="p">.</span><span class="n">ioa_host_interrupt_clr_reg</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">reset_cmd</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">reset_cmd</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span>
			<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">lock_flags</span><span class="p">);</span>
		<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">reset_cmd</span><span class="o">-&gt;</span><span class="n">cmd_done</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">reset_cmd</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span>
			<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">lock_flags</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_reset_type - Determine the required reset type</span>
<span class="cm"> * @pinstance: pointer to adapter instance structure</span>
<span class="cm"> *</span>
<span class="cm"> * IOA requires hard reset if any of the following conditions is true.</span>
<span class="cm"> * 1. If HRRQ valid interrupt is not masked</span>
<span class="cm"> * 2. IOA reset alert doorbell is set</span>
<span class="cm"> * 3. If there are any error interrupts</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pmcraid_reset_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">mask</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">intrs</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">alerts</span><span class="p">;</span>

	<span class="n">mask</span> <span class="o">=</span> <span class="n">ioread32</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">int_regs</span><span class="p">.</span><span class="n">ioa_host_interrupt_mask_reg</span><span class="p">);</span>
	<span class="n">intrs</span> <span class="o">=</span> <span class="n">ioread32</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">int_regs</span><span class="p">.</span><span class="n">ioa_host_interrupt_reg</span><span class="p">);</span>
	<span class="n">alerts</span> <span class="o">=</span> <span class="n">ioread32</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">int_regs</span><span class="p">.</span><span class="n">host_ioa_interrupt_reg</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">INTRS_HRRQ_VALID</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">alerts</span> <span class="o">&amp;</span> <span class="n">DOORBELL_IOA_RESET_ALERT</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">intrs</span> <span class="o">&amp;</span> <span class="n">PMCRAID_ERROR_INTERRUPTS</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pmcraid_info</span><span class="p">(</span><span class="s">&quot;IOA requires hard reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ioa_hard_reset</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If unit check is active, trigger the dump */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">intrs</span> <span class="o">&amp;</span> <span class="n">INTRS_IOA_UNIT_CHECK</span><span class="p">)</span>
		<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ioa_unit_check</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_bist_done - completion function for PCI BIST</span>
<span class="cm"> * @cmd: pointer to reset command</span>
<span class="cm"> * Return Value</span>
<span class="cm"> *	none</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">pmcraid_ioa_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_cmd</span> <span class="o">*</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pmcraid_bist_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">drv_inst</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lock_flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">pci_reg</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_COMMAND</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pci_reg</span><span class="p">);</span>

	<span class="cm">/* If PCI config space can&#39;t be accessed wait for another two secs */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">PCIBIOS_SUCCESSFUL</span> <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">pci_reg</span> <span class="o">&amp;</span> <span class="n">PCI_COMMAND_MEMORY</span><span class="p">)))</span> <span class="o">&amp;&amp;</span>
	    <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">time_left</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pmcraid_info</span><span class="p">(</span><span class="s">&quot;BIST not complete, waiting another 2 secs</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">.</span><span class="n">expires</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">time_left</span><span class="p">;</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">time_left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">cmd</span><span class="p">;</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span>
			<span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">))</span><span class="n">pmcraid_bist_done</span><span class="p">;</span>
		<span class="n">add_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">time_left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">pmcraid_info</span><span class="p">(</span><span class="s">&quot;BIST is complete, proceeding with reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">lock_flags</span><span class="p">);</span>
		<span class="n">pmcraid_ioa_reset</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">lock_flags</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_start_bist - starts BIST</span>
<span class="cm"> * @cmd: pointer to reset cmd</span>
<span class="cm"> * Return Value</span>
<span class="cm"> *   none</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pmcraid_start_bist</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">drv_inst</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">doorbells</span><span class="p">,</span> <span class="n">intrs</span><span class="p">;</span>

	<span class="cm">/* proceed with bist and wait for 2 seconds */</span>
	<span class="n">iowrite32</span><span class="p">(</span><span class="n">DOORBELL_IOA_START_BIST</span><span class="p">,</span>
		<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">int_regs</span><span class="p">.</span><span class="n">host_ioa_interrupt_reg</span><span class="p">);</span>
	<span class="n">doorbells</span> <span class="o">=</span> <span class="n">ioread32</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">int_regs</span><span class="p">.</span><span class="n">host_ioa_interrupt_reg</span><span class="p">);</span>
	<span class="n">intrs</span> <span class="o">=</span> <span class="n">ioread32</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">int_regs</span><span class="p">.</span><span class="n">ioa_host_interrupt_reg</span><span class="p">);</span>
	<span class="n">pmcraid_info</span><span class="p">(</span><span class="s">&quot;doorbells after start bist: %x intrs: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		      <span class="n">doorbells</span><span class="p">,</span> <span class="n">intrs</span><span class="p">);</span>

	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">time_left</span> <span class="o">=</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">PMCRAID_BIST_TIMEOUT</span><span class="p">);</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">cmd</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">.</span><span class="n">expires</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">PMCRAID_BIST_TIMEOUT</span><span class="p">);</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">))</span><span class="n">pmcraid_bist_done</span><span class="p">;</span>
	<span class="n">add_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_reset_alert_done - completion routine for reset_alert</span>
<span class="cm"> * @cmd: pointer to command block used in reset sequence</span>
<span class="cm"> * Return value</span>
<span class="cm"> *  None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pmcraid_reset_alert_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">drv_inst</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">status</span> <span class="o">=</span> <span class="n">ioread32</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ioa_status</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lock_flags</span><span class="p">;</span>

	<span class="cm">/* if the critical operation in progress bit is set or the wait times</span>
<span class="cm">	 * out, invoke reset engine to proceed with hard reset. If there is</span>
<span class="cm">	 * some more time to wait, restart the timer</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(((</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">INTRS_CRITICAL_OP_IN_PROGRESS</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">time_left</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pmcraid_info</span><span class="p">(</span><span class="s">&quot;critical op is reset proceeding with reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">lock_flags</span><span class="p">);</span>
		<span class="n">pmcraid_ioa_reset</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">lock_flags</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pmcraid_info</span><span class="p">(</span><span class="s">&quot;critical op is not yet reset waiting again</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="cm">/* restart timer if some more time is available to wait */</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">time_left</span> <span class="o">-=</span> <span class="n">PMCRAID_CHECK_FOR_RESET_TIMEOUT</span><span class="p">;</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">cmd</span><span class="p">;</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">.</span><span class="n">expires</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">PMCRAID_CHECK_FOR_RESET_TIMEOUT</span><span class="p">;</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span>
			<span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">))</span><span class="n">pmcraid_reset_alert_done</span><span class="p">;</span>
		<span class="n">add_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_reset_alert - alerts IOA for a possible reset</span>
<span class="cm"> * @cmd : command block to be used for reset sequence.</span>
<span class="cm"> *</span>
<span class="cm"> * Return Value</span>
<span class="cm"> *	returns 0 if pci config-space is accessible and RESET_DOORBELL is</span>
<span class="cm"> *	successfully written to IOA. Returns non-zero in case pci_config_space</span>
<span class="cm"> *	is not accessible</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">pmcraid_notify_ioastate</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="p">,</span> <span class="n">u32</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pmcraid_reset_alert</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">drv_inst</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">doorbells</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">pci_reg</span><span class="p">;</span>

	<span class="cm">/* If we are able to access IOA PCI config space, alert IOA that we are</span>
<span class="cm">	 * going to reset it soon. This enables IOA to preserv persistent error</span>
<span class="cm">	 * data if any. In case memory space is not accessible, proceed with</span>
<span class="cm">	 * BIST or slot_reset</span>
<span class="cm">	 */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_COMMAND</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pci_reg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">==</span> <span class="n">PCIBIOS_SUCCESSFUL</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">pci_reg</span> <span class="o">&amp;</span> <span class="n">PCI_COMMAND_MEMORY</span><span class="p">))</span> <span class="p">{</span>

		<span class="cm">/* wait for IOA permission i.e until CRITICAL_OPERATION bit is</span>
<span class="cm">		 * reset IOA doesn&#39;t generate any interrupts when CRITICAL</span>
<span class="cm">		 * OPERATION bit is reset. A timer is started to wait for this</span>
<span class="cm">		 * bit to be reset.</span>
<span class="cm">		 */</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">time_left</span> <span class="o">=</span> <span class="n">PMCRAID_RESET_TIMEOUT</span><span class="p">;</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">cmd</span><span class="p">;</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">.</span><span class="n">expires</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">PMCRAID_CHECK_FOR_RESET_TIMEOUT</span><span class="p">;</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span>
			<span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">))</span><span class="n">pmcraid_reset_alert_done</span><span class="p">;</span>
		<span class="n">add_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>

		<span class="n">iowrite32</span><span class="p">(</span><span class="n">DOORBELL_IOA_RESET_ALERT</span><span class="p">,</span>
			<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">int_regs</span><span class="p">.</span><span class="n">host_ioa_interrupt_reg</span><span class="p">);</span>
		<span class="n">doorbells</span> <span class="o">=</span>
			<span class="n">ioread32</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">int_regs</span><span class="p">.</span><span class="n">host_ioa_interrupt_reg</span><span class="p">);</span>
		<span class="n">pmcraid_info</span><span class="p">(</span><span class="s">&quot;doorbells after reset alert: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">doorbells</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pmcraid_info</span><span class="p">(</span><span class="s">&quot;PCI config is not accessible starting BIST</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ioa_state</span> <span class="o">=</span> <span class="n">IOA_STATE_IN_HARD_RESET</span><span class="p">;</span>
		<span class="n">pmcraid_start_bist</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_timeout_handler -  Timeout handler for internally generated ops</span>
<span class="cm"> *</span>
<span class="cm"> * @cmd : pointer to command structure, that got timedout</span>
<span class="cm"> *</span>
<span class="cm"> * This function blocks host requests and initiates an adapter reset.</span>
<span class="cm"> *</span>
<span class="cm"> * Return value:</span>
<span class="cm"> *   None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pmcraid_timeout_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">drv_inst</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lock_flags</span><span class="p">;</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;Adapter being reset due to cmd(CDB[0] = %x) timeout</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ioa_cb</span><span class="o">-&gt;</span><span class="n">ioarcb</span><span class="p">.</span><span class="n">cdb</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

	<span class="cm">/* Command timeouts result in hard reset sequence. The command that got</span>
<span class="cm">	 * timed out may be the one used as part of reset sequence. In this</span>
<span class="cm">	 * case restart reset sequence using the same command block even if</span>
<span class="cm">	 * reset is in progress. Otherwise fail this command and get a free</span>
<span class="cm">	 * command block to restart the reset sequence.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">lock_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ioa_reset_in_progress</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ioa_reset_attempts</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">cmd</span> <span class="o">=</span> <span class="n">pmcraid_get_free_cmd</span><span class="p">(</span><span class="n">pinstance</span><span class="p">);</span>

		<span class="cm">/* If we are out of command blocks, just return here itself.</span>
<span class="cm">		 * Some other command&#39;s timeout handler can do the reset job</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span>
					       <span class="n">lock_flags</span><span class="p">);</span>
			<span class="n">pmcraid_err</span><span class="p">(</span><span class="s">&quot;no free cmnd block for timeout handler</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">reset_cmd</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">;</span>
		<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ioa_reset_in_progress</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pmcraid_info</span><span class="p">(</span><span class="s">&quot;reset is already in progress</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">reset_cmd</span> <span class="o">!=</span> <span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* This command should have been given to IOA, this</span>
<span class="cm">			 * command will be completed by fail_outstanding_cmds</span>
<span class="cm">			 * anyway</span>
<span class="cm">			 */</span>
			<span class="n">pmcraid_err</span><span class="p">(</span><span class="s">&quot;cmd is pending but reset in progress</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* If this command was being used as part of the reset</span>
<span class="cm">		 * sequence, set cmd_done pointer to pmcraid_ioa_reset. This</span>
<span class="cm">		 * causes fail_outstanding_commands not to return the command</span>
<span class="cm">		 * block back to free pool</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">reset_cmd</span><span class="p">)</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmd_done</span> <span class="o">=</span> <span class="n">pmcraid_ioa_reset</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Notify apps of important IOA bringup/bringdown sequences */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">scn</span><span class="p">.</span><span class="n">ioa_state</span> <span class="o">!=</span> <span class="n">PMC_DEVICE_EVENT_RESET_START</span> <span class="o">&amp;&amp;</span>
	    <span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">scn</span><span class="p">.</span><span class="n">ioa_state</span> <span class="o">!=</span> <span class="n">PMC_DEVICE_EVENT_SHUTDOWN_START</span><span class="p">)</span>
		<span class="n">pmcraid_notify_ioastate</span><span class="p">(</span><span class="n">pinstance</span><span class="p">,</span>
					<span class="n">PMC_DEVICE_EVENT_RESET_START</span><span class="p">);</span>

	<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ioa_state</span> <span class="o">=</span> <span class="n">IOA_STATE_IN_RESET_ALERT</span><span class="p">;</span>
	<span class="n">scsi_block_requests</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>
	<span class="n">pmcraid_reset_alert</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">lock_flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_internal_done - completion routine for internally generated cmds</span>
<span class="cm"> *</span>
<span class="cm"> * @cmd: command that got response from IOA</span>
<span class="cm"> *</span>
<span class="cm"> * Return Value:</span>
<span class="cm"> *	 none</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pmcraid_internal_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pmcraid_info</span><span class="p">(</span><span class="s">&quot;response internal cmd CDB[0] = %x ioasc = %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ioa_cb</span><span class="o">-&gt;</span><span class="n">ioarcb</span><span class="p">.</span><span class="n">cdb</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
		     <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ioa_cb</span><span class="o">-&gt;</span><span class="n">ioasa</span><span class="p">.</span><span class="n">ioasc</span><span class="p">));</span>

	<span class="cm">/* Some of the internal commands are sent with callers blocking for the</span>
<span class="cm">	 * response. Same will be indicated as part of cmd-&gt;completion_req</span>
<span class="cm">	 * field. Response path needs to wake up any waiters waiting for cmd</span>
<span class="cm">	 * completion if this flag is set.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">completion_req</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">completion_req</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">wait_for_completion</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* most of the internal commands are completed by caller itself, so</span>
<span class="cm">	 * no need to return the command block back to free pool until we are</span>
<span class="cm">	 * required to do so (e.g once done with initialization).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">release</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">release</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">pmcraid_return_cmd</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_reinit_cfgtable_done - done function for cfg table reinitialization</span>
<span class="cm"> *</span>
<span class="cm"> * @cmd: command that got response from IOA</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is called after driver re-reads configuration table due to a</span>
<span class="cm"> * lost CCN. It returns the command block back to free pool and schedules</span>
<span class="cm"> * worker thread to add/delete devices into the system.</span>
<span class="cm"> *</span>
<span class="cm"> * Return Value:</span>
<span class="cm"> *	 none</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pmcraid_reinit_cfgtable_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pmcraid_info</span><span class="p">(</span><span class="s">&quot;response internal cmd CDB[0] = %x ioasc = %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ioa_cb</span><span class="o">-&gt;</span><span class="n">ioarcb</span><span class="p">.</span><span class="n">cdb</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
		     <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ioa_cb</span><span class="o">-&gt;</span><span class="n">ioasa</span><span class="p">.</span><span class="n">ioasc</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">release</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">release</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">pmcraid_return_cmd</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">pmcraid_info</span><span class="p">(</span><span class="s">&quot;scheduling worker for config table reinitialization</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">drv_inst</span><span class="o">-&gt;</span><span class="n">worker_q</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_erp_done - Process completion of SCSI error response from device</span>
<span class="cm"> * @cmd: pmcraid_command</span>
<span class="cm"> *</span>
<span class="cm"> * This function copies the sense buffer into the scsi_cmd struct and completes</span>
<span class="cm"> * scsi_cmd by calling scsi_done function.</span>
<span class="cm"> *</span>
<span class="cm"> * Return value:</span>
<span class="cm"> *  none</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pmcraid_erp_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">scsi_cmd</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_cmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">drv_inst</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ioasc</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ioa_cb</span><span class="o">-&gt;</span><span class="n">ioasa</span><span class="p">.</span><span class="n">ioasc</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">PMCRAID_IOASC_SENSE_KEY</span><span class="p">(</span><span class="n">ioasc</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">scsi_cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">|=</span> <span class="p">(</span><span class="n">DID_ERROR</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
		<span class="n">scmd_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">scsi_cmd</span><span class="p">,</span>
			    <span class="s">&quot;command CDB[0] = %x failed with IOASC: 0x%08X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			    <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ioa_cb</span><span class="o">-&gt;</span><span class="n">ioarcb</span><span class="p">.</span><span class="n">cdb</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ioasc</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* if we had allocated sense buffers for request sense, copy the sense</span>
<span class="cm">	 * release the buffers</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sense_buffer</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">scsi_cmd</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">,</span>
		       <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">,</span>
		       <span class="n">SCSI_SENSE_BUFFERSIZE</span><span class="p">);</span>
		<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
				    <span class="n">SCSI_SENSE_BUFFERSIZE</span><span class="p">,</span>
				    <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sense_buffer_dma</span><span class="p">);</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sense_buffer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sense_buffer_dma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">scsi_dma_unmap</span><span class="p">(</span><span class="n">scsi_cmd</span><span class="p">);</span>
	<span class="n">pmcraid_return_cmd</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="n">scsi_cmd</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">(</span><span class="n">scsi_cmd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_fire_command - sends an IOA command to adapter</span>
<span class="cm"> *</span>
<span class="cm"> * This function adds the given block into pending command list</span>
<span class="cm"> * and returns without waiting</span>
<span class="cm"> *</span>
<span class="cm"> * @cmd : command to be sent to the device</span>
<span class="cm"> *</span>
<span class="cm"> * Return Value</span>
<span class="cm"> *	None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">_pmcraid_fire_command</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">drv_inst</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lock_flags</span><span class="p">;</span>

	<span class="cm">/* Add this command block to pending cmd pool. We do this prior to</span>
<span class="cm">	 * writting IOARCB to ioarrin because IOA might complete the command</span>
<span class="cm">	 * by the time we are about to add it to the list. Response handler</span>
<span class="cm">	 * (isr/tasklet) looks for cmd block in the pending pending list.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">pending_pool_lock</span><span class="p">,</span> <span class="n">lock_flags</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">free_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">pending_cmd_pool</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">pending_pool_lock</span><span class="p">,</span> <span class="n">lock_flags</span><span class="p">);</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">outstanding_cmds</span><span class="p">);</span>

	<span class="cm">/* driver writes lower 32-bit value of IOARCB address only */</span>
	<span class="n">mb</span><span class="p">();</span>
	<span class="n">iowrite32</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ioa_cb</span><span class="o">-&gt;</span><span class="n">ioarcb</span><span class="p">.</span><span class="n">ioarcb_bus_addr</span><span class="p">),</span>
		  <span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ioarrin</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_send_cmd - fires a command to IOA</span>
<span class="cm"> *</span>
<span class="cm"> * This function also sets up timeout function, and command completion</span>
<span class="cm"> * function</span>
<span class="cm"> *</span>
<span class="cm"> * @cmd: pointer to the command block to be fired to IOA</span>
<span class="cm"> * @cmd_done: command completion function, called once IOA responds</span>
<span class="cm"> * @timeout: timeout to wait for this command completion</span>
<span class="cm"> * @timeout_func: timeout handler</span>
<span class="cm"> *</span>
<span class="cm"> * Return value</span>
<span class="cm"> *   none</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pmcraid_send_cmd</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">pmcraid_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">cmd_done</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_cmd</span> <span class="o">*</span><span class="p">),</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">,</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">timeout_func</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_cmd</span> <span class="o">*</span><span class="p">)</span>
<span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* initialize done function */</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmd_done</span> <span class="o">=</span> <span class="n">cmd_done</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">timeout_func</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* setup timeout handler */</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">cmd</span><span class="p">;</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">.</span><span class="n">expires</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">timeout</span><span class="p">;</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">))</span><span class="n">timeout_func</span><span class="p">;</span>
		<span class="n">add_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* fire the command to IOA */</span>
	<span class="n">_pmcraid_fire_command</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_ioa_shutdown_done - completion function for IOA shutdown command</span>
<span class="cm"> * @cmd: pointer to the command block used for sending IOA shutdown command</span>
<span class="cm"> *</span>
<span class="cm"> * Return value</span>
<span class="cm"> *  None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pmcraid_ioa_shutdown_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">drv_inst</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lock_flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">lock_flags</span><span class="p">);</span>
	<span class="n">pmcraid_ioa_reset</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">lock_flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_ioa_shutdown - sends SHUTDOWN command to ioa</span>
<span class="cm"> *</span>
<span class="cm"> * @cmd: pointer to the command block used as part of reset sequence</span>
<span class="cm"> *</span>
<span class="cm"> * Return Value</span>
<span class="cm"> *  None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pmcraid_ioa_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pmcraid_info</span><span class="p">(</span><span class="s">&quot;response for Cancel CCN CDB[0] = %x ioasc = %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ioa_cb</span><span class="o">-&gt;</span><span class="n">ioarcb</span><span class="p">.</span><span class="n">cdb</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
		     <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ioa_cb</span><span class="o">-&gt;</span><span class="n">ioasa</span><span class="p">.</span><span class="n">ioasc</span><span class="p">));</span>

	<span class="cm">/* Note that commands sent during reset require next command to be sent</span>
<span class="cm">	 * to IOA. Hence reinit the done function as well as timeout function</span>
<span class="cm">	 */</span>
	<span class="n">pmcraid_reinit_cmdblk</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ioa_cb</span><span class="o">-&gt;</span><span class="n">ioarcb</span><span class="p">.</span><span class="n">request_type</span> <span class="o">=</span> <span class="n">REQ_TYPE_IOACMD</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ioa_cb</span><span class="o">-&gt;</span><span class="n">ioarcb</span><span class="p">.</span><span class="n">resource_handle</span> <span class="o">=</span>
		<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">PMCRAID_IOA_RES_HANDLE</span><span class="p">);</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ioa_cb</span><span class="o">-&gt;</span><span class="n">ioarcb</span><span class="p">.</span><span class="n">cdb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">PMCRAID_IOA_SHUTDOWN</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ioa_cb</span><span class="o">-&gt;</span><span class="n">ioarcb</span><span class="p">.</span><span class="n">cdb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">PMCRAID_SHUTDOWN_NORMAL</span><span class="p">;</span>

	<span class="cm">/* fire shutdown command to hardware. */</span>
	<span class="n">pmcraid_info</span><span class="p">(</span><span class="s">&quot;firing normal shutdown command (%d) to IOA</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ioa_cb</span><span class="o">-&gt;</span><span class="n">ioarcb</span><span class="p">.</span><span class="n">response_handle</span><span class="p">));</span>

	<span class="n">pmcraid_notify_ioastate</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">drv_inst</span><span class="p">,</span> <span class="n">PMC_DEVICE_EVENT_SHUTDOWN_START</span><span class="p">);</span>

	<span class="n">pmcraid_send_cmd</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">pmcraid_ioa_shutdown_done</span><span class="p">,</span>
			 <span class="n">PMCRAID_SHUTDOWN_TIMEOUT</span><span class="p">,</span>
			 <span class="n">pmcraid_timeout_handler</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_get_fwversion_done - completion function for get_fwversion</span>
<span class="cm"> *</span>
<span class="cm"> * @cmd: pointer to command block used to send INQUIRY command</span>
<span class="cm"> *</span>
<span class="cm"> * Return Value</span>
<span class="cm"> *	none</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">pmcraid_querycfg</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_cmd</span> <span class="o">*</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pmcraid_get_fwversion_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">drv_inst</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ioasc</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ioa_cb</span><span class="o">-&gt;</span><span class="n">ioasa</span><span class="p">.</span><span class="n">ioasc</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lock_flags</span><span class="p">;</span>

	<span class="cm">/* configuration table entry size depends on firmware version. If fw</span>
<span class="cm">	 * version is not known, it is not possible to interpret IOA config</span>
<span class="cm">	 * table</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ioasc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pmcraid_err</span><span class="p">(</span><span class="s">&quot;IOA Inquiry failed with %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ioasc</span><span class="p">);</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">lock_flags</span><span class="p">);</span>
		<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ioa_state</span> <span class="o">=</span> <span class="n">IOA_STATE_IN_RESET_ALERT</span><span class="p">;</span>
		<span class="n">pmcraid_reset_alert</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">lock_flags</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>  <span class="p">{</span>
		<span class="n">pmcraid_querycfg</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_get_fwversion - reads firmware version information</span>
<span class="cm"> *</span>
<span class="cm"> * @cmd: pointer to command block used to send INQUIRY command</span>
<span class="cm"> *</span>
<span class="cm"> * Return Value</span>
<span class="cm"> *	none</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pmcraid_get_fwversion</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pmcraid_ioarcb</span> <span class="o">*</span><span class="n">ioarcb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ioa_cb</span><span class="o">-&gt;</span><span class="n">ioarcb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pmcraid_ioadl_desc</span> <span class="o">*</span><span class="n">ioadl</span> <span class="o">=</span> <span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">add_data</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">ioadl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">drv_inst</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">data_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_inquiry_data</span><span class="p">);</span>

	<span class="n">pmcraid_reinit_cmdblk</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">request_type</span> <span class="o">=</span> <span class="n">REQ_TYPE_SCSI</span><span class="p">;</span>
	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">resource_handle</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">PMCRAID_IOA_RES_HANDLE</span><span class="p">);</span>
	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">cdb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">INQUIRY</span><span class="p">;</span>
	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">cdb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">cdb</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xD0</span><span class="p">;</span>
	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">cdb</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">data_size</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>
	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">cdb</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_size</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>

	<span class="cm">/* Since entire inquiry data it can be part of IOARCB itself</span>
<span class="cm">	 */</span>
	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">ioadl_bus_addr</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">((</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ioa_cb_bus_addr</span><span class="p">)</span> <span class="o">+</span>
					<span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_ioarcb</span><span class="p">,</span>
						<span class="n">add_data</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">ioadl</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">ioadl_length</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_ioadl_desc</span><span class="p">));</span>
	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">ioarcb_bus_addr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mh">0x1FULL</span><span class="p">);</span>

	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">request_flags0</span> <span class="o">|=</span> <span class="n">NO_LINK_DESCS</span><span class="p">;</span>
	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">data_transfer_length</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">data_size</span><span class="p">);</span>
	<span class="n">ioadl</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">add_data</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">ioadl</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">ioadl</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">IOADL_FLAGS_LAST_DESC</span><span class="p">;</span>
	<span class="n">ioadl</span><span class="o">-&gt;</span><span class="n">address</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">inq_data_baddr</span><span class="p">);</span>
	<span class="n">ioadl</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">data_size</span><span class="p">);</span>

	<span class="n">pmcraid_send_cmd</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">pmcraid_get_fwversion_done</span><span class="p">,</span>
			 <span class="n">PMCRAID_INTERNAL_TIMEOUT</span><span class="p">,</span> <span class="n">pmcraid_timeout_handler</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_identify_hrrq - registers host rrq buffers with IOA</span>
<span class="cm"> * @cmd: pointer to command block to be used for identify hrrq</span>
<span class="cm"> *</span>
<span class="cm"> * Return Value</span>
<span class="cm"> *	 none</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pmcraid_identify_hrrq</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">drv_inst</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pmcraid_ioarcb</span> <span class="o">*</span><span class="n">ioarcb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ioa_cb</span><span class="o">-&gt;</span><span class="n">ioarcb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">hrrq_index</span><span class="p">;</span>
	<span class="n">__be64</span> <span class="n">hrrq_addr</span> <span class="o">=</span> <span class="n">cpu_to_be64</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">hrrq_start_bus_addr</span><span class="p">[</span><span class="n">index</span><span class="p">]);</span>
	<span class="n">u32</span> <span class="n">hrrq_size</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="o">*</span> <span class="n">PMCRAID_MAX_CMD</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">done_function</span><span class="p">)(</span><span class="k">struct</span> <span class="n">pmcraid_cmd</span> <span class="o">*</span><span class="p">);</span>

	<span class="n">pmcraid_reinit_cmdblk</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">hrrq_index</span> <span class="o">=</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">hrrq_index</span> <span class="o">&lt;</span> <span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">num_hrrq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">done_function</span> <span class="o">=</span> <span class="n">pmcraid_identify_hrrq</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">hrrq_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">done_function</span> <span class="o">=</span> <span class="n">pmcraid_get_fwversion</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Initialize ioarcb */</span>
	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">request_type</span> <span class="o">=</span> <span class="n">REQ_TYPE_IOACMD</span><span class="p">;</span>
	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">resource_handle</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">PMCRAID_IOA_RES_HANDLE</span><span class="p">);</span>

	<span class="cm">/* initialize the hrrq number where IOA will respond to this command */</span>
	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">hrrq_id</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>
	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">cdb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">PMCRAID_IDENTIFY_HRRQ</span><span class="p">;</span>
	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">cdb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>

	<span class="cm">/* IOA expects 64-bit pci address to be written in B.E format</span>
<span class="cm">	 * (i.e cdb[2]=MSByte..cdb[9]=LSB.</span>
<span class="cm">	 */</span>
	<span class="n">pmcraid_info</span><span class="p">(</span><span class="s">&quot;HRRQ_IDENTIFY with hrrq:ioarcb:index =&gt; %llx:%llx:%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">hrrq_addr</span><span class="p">,</span> <span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">ioarcb_bus_addr</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">cdb</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="o">&amp;</span><span class="n">hrrq_addr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">hrrq_addr</span><span class="p">));</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">cdb</span><span class="p">[</span><span class="mi">10</span><span class="p">]),</span> <span class="o">&amp;</span><span class="n">hrrq_size</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">hrrq_size</span><span class="p">));</span>

	<span class="cm">/* Subsequent commands require HRRQ identification to be successful.</span>
<span class="cm">	 * Note that this gets called even during reset from SCSI mid-layer</span>
<span class="cm">	 * or tasklet</span>
<span class="cm">	 */</span>
	<span class="n">pmcraid_send_cmd</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">done_function</span><span class="p">,</span>
			 <span class="n">PMCRAID_INTERNAL_TIMEOUT</span><span class="p">,</span>
			 <span class="n">pmcraid_timeout_handler</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">pmcraid_process_ccn</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">pmcraid_process_ldn</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_send_hcam_cmd - send an initialized command block(HCAM) to IOA</span>
<span class="cm"> *</span>
<span class="cm"> * @cmd: initialized command block pointer</span>
<span class="cm"> *</span>
<span class="cm"> * Return Value</span>
<span class="cm"> *   none</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pmcraid_send_hcam_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ioa_cb</span><span class="o">-&gt;</span><span class="n">ioarcb</span><span class="p">.</span><span class="n">cdb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">PMCRAID_HCAM_CODE_CONFIG_CHANGE</span><span class="p">)</span>
		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">drv_inst</span><span class="o">-&gt;</span><span class="n">ccn</span><span class="p">.</span><span class="n">ignore</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">drv_inst</span><span class="o">-&gt;</span><span class="n">ldn</span><span class="p">.</span><span class="n">ignore</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">pmcraid_send_cmd</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmd_done</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_init_hcam - send an initialized command block(HCAM) to IOA</span>
<span class="cm"> *</span>
<span class="cm"> * @pinstance: pointer to adapter instance structure</span>
<span class="cm"> * @type: HCAM type</span>
<span class="cm"> *</span>
<span class="cm"> * Return Value</span>
<span class="cm"> *   pointer to initialized pmcraid_cmd structure or NULL</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">pmcraid_cmd</span> <span class="o">*</span><span class="nf">pmcraid_init_hcam</span>
<span class="p">(</span>
	<span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span><span class="p">,</span>
	<span class="n">u8</span> <span class="n">type</span>
<span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pmcraid_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pmcraid_ioarcb</span> <span class="o">*</span><span class="n">ioarcb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pmcraid_ioadl_desc</span> <span class="o">*</span><span class="n">ioadl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pmcraid_hostrcb</span> <span class="o">*</span><span class="n">hcam</span><span class="p">;</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">cmd_done</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_cmd</span> <span class="o">*</span><span class="p">);</span>
	<span class="n">dma_addr_t</span> <span class="n">dma</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rcb_size</span><span class="p">;</span>

	<span class="n">cmd</span> <span class="o">=</span> <span class="n">pmcraid_get_free_cmd</span><span class="p">(</span><span class="n">pinstance</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pmcraid_err</span><span class="p">(</span><span class="s">&quot;no free command blocks for hcam</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">cmd</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">PMCRAID_HCAM_CODE_CONFIG_CHANGE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rcb_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_hcam_ccn_ext</span><span class="p">);</span>
		<span class="n">cmd_done</span> <span class="o">=</span> <span class="n">pmcraid_process_ccn</span><span class="p">;</span>
		<span class="n">dma</span> <span class="o">=</span> <span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ccn</span><span class="p">.</span><span class="n">baddr</span> <span class="o">+</span> <span class="n">PMCRAID_AEN_HDR_SIZE</span><span class="p">;</span>
		<span class="n">hcam</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ccn</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">rcb_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_hcam_ldn</span><span class="p">);</span>
		<span class="n">cmd_done</span> <span class="o">=</span> <span class="n">pmcraid_process_ldn</span><span class="p">;</span>
		<span class="n">dma</span> <span class="o">=</span> <span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ldn</span><span class="p">.</span><span class="n">baddr</span> <span class="o">+</span> <span class="n">PMCRAID_AEN_HDR_SIZE</span><span class="p">;</span>
		<span class="n">hcam</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ldn</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* initialize command pointer used for HCAM registration */</span>
	<span class="n">hcam</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">;</span>

	<span class="n">ioarcb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ioa_cb</span><span class="o">-&gt;</span><span class="n">ioarcb</span><span class="p">;</span>
	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">ioadl_bus_addr</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">((</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ioa_cb_bus_addr</span><span class="p">)</span> <span class="o">+</span>
					<span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_ioarcb</span><span class="p">,</span>
						<span class="n">add_data</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">ioadl</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">ioadl_length</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_ioadl_desc</span><span class="p">));</span>
	<span class="n">ioadl</span> <span class="o">=</span> <span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">add_data</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">ioadl</span><span class="p">;</span>

	<span class="cm">/* Initialize ioarcb */</span>
	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">request_type</span> <span class="o">=</span> <span class="n">REQ_TYPE_HCAM</span><span class="p">;</span>
	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">resource_handle</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">PMCRAID_IOA_RES_HANDLE</span><span class="p">);</span>
	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">cdb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">PMCRAID_HOST_CONTROLLED_ASYNC</span><span class="p">;</span>
	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">cdb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">cdb</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">rcb_size</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>
	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">cdb</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">rcb_size</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>

	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">data_transfer_length</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">rcb_size</span><span class="p">);</span>

	<span class="n">ioadl</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">IOADL_FLAGS_READ_LAST</span><span class="p">;</span>
	<span class="n">ioadl</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">data_len</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">rcb_size</span><span class="p">);</span>
	<span class="n">ioadl</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">address</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">dma</span><span class="p">);</span>

	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmd_done</span> <span class="o">=</span> <span class="n">cmd_done</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">cmd</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_send_hcam - Send an HCAM to IOA</span>
<span class="cm"> * @pinstance: ioa config struct</span>
<span class="cm"> * @type: HCAM type</span>
<span class="cm"> *</span>
<span class="cm"> * This function will send a Host Controlled Async command to IOA.</span>
<span class="cm"> *</span>
<span class="cm"> * Return value:</span>
<span class="cm"> *	none</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pmcraid_send_hcam</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span><span class="p">,</span> <span class="n">u8</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pmcraid_cmd</span> <span class="o">*</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">pmcraid_init_hcam</span><span class="p">(</span><span class="n">pinstance</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
	<span class="n">pmcraid_send_hcam_cmd</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * pmcraid_prepare_cancel_cmd - prepares a command block to abort another</span>
<span class="cm"> *</span>
<span class="cm"> * @cmd: pointer to cmd that is used as cancelling command</span>
<span class="cm"> * @cmd_to_cancel: pointer to the command that needs to be cancelled</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pmcraid_prepare_cancel_cmd</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">pmcraid_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">pmcraid_cmd</span> <span class="o">*</span><span class="n">cmd_to_cancel</span>
<span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pmcraid_ioarcb</span> <span class="o">*</span><span class="n">ioarcb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ioa_cb</span><span class="o">-&gt;</span><span class="n">ioarcb</span><span class="p">;</span>
	<span class="n">__be64</span> <span class="n">ioarcb_addr</span> <span class="o">=</span> <span class="n">cmd_to_cancel</span><span class="o">-&gt;</span><span class="n">ioa_cb</span><span class="o">-&gt;</span><span class="n">ioarcb</span><span class="p">.</span><span class="n">ioarcb_bus_addr</span><span class="p">;</span>

	<span class="cm">/* Get the resource handle to where the command to be aborted has been</span>
<span class="cm">	 * sent.</span>
<span class="cm">	 */</span>
	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">resource_handle</span> <span class="o">=</span> <span class="n">cmd_to_cancel</span><span class="o">-&gt;</span><span class="n">ioa_cb</span><span class="o">-&gt;</span><span class="n">ioarcb</span><span class="p">.</span><span class="n">resource_handle</span><span class="p">;</span>
	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">request_type</span> <span class="o">=</span> <span class="n">REQ_TYPE_IOACMD</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">cdb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PMCRAID_MAX_CDB_LEN</span><span class="p">);</span>
	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">cdb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">PMCRAID_ABORT_CMD</span><span class="p">;</span>

	<span class="cm">/* IOARCB address of the command to be cancelled is given in</span>
<span class="cm">	 * cdb[2]..cdb[9] is Big-Endian format. Note that length bits in</span>
<span class="cm">	 * IOARCB address are not masked.</span>
<span class="cm">	 */</span>
	<span class="n">ioarcb_addr</span> <span class="o">=</span> <span class="n">cpu_to_be64</span><span class="p">(</span><span class="n">ioarcb_addr</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">cdb</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="o">&amp;</span><span class="n">ioarcb_addr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ioarcb_addr</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_cancel_hcam - sends ABORT task to abort a given HCAM</span>
<span class="cm"> *</span>
<span class="cm"> * @cmd: command to be used as cancelling command</span>
<span class="cm"> * @type: HCAM type</span>
<span class="cm"> * @cmd_done: op done function for the cancelling command</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pmcraid_cancel_hcam</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">pmcraid_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span>
	<span class="n">u8</span> <span class="n">type</span><span class="p">,</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">cmd_done</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_cmd</span> <span class="o">*</span><span class="p">)</span>
<span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pmcraid_hostrcb</span>  <span class="o">*</span><span class="n">hcam</span><span class="p">;</span>

	<span class="n">pinstance</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">drv_inst</span><span class="p">;</span>
	<span class="n">hcam</span> <span class="o">=</span>  <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">PMCRAID_HCAM_CODE_LOG_DATA</span><span class="p">)</span> <span class="o">?</span>
		<span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ldn</span> <span class="o">:</span> <span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ccn</span><span class="p">;</span>

	<span class="cm">/* prepare for cancelling previous hcam command. If the HCAM is</span>
<span class="cm">	 * currently not pending with IOA, we would have hcam-&gt;cmd as non-null</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hcam</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">pmcraid_prepare_cancel_cmd</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">hcam</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">);</span>

	<span class="cm">/* writing to IOARRIN must be protected by host_lock, as mid-layer</span>
<span class="cm">	 * schedule queuecommand while we are doing this</span>
<span class="cm">	 */</span>
	<span class="n">pmcraid_send_cmd</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">cmd_done</span><span class="p">,</span>
			 <span class="n">PMCRAID_INTERNAL_TIMEOUT</span><span class="p">,</span>
			 <span class="n">pmcraid_timeout_handler</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_cancel_ccn - cancel CCN HCAM already registered with IOA</span>
<span class="cm"> *</span>
<span class="cm"> * @cmd: command block to be used for cancelling the HCAM</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pmcraid_cancel_ccn</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pmcraid_info</span><span class="p">(</span><span class="s">&quot;response for Cancel LDN CDB[0] = %x ioasc = %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ioa_cb</span><span class="o">-&gt;</span><span class="n">ioarcb</span><span class="p">.</span><span class="n">cdb</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
		     <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ioa_cb</span><span class="o">-&gt;</span><span class="n">ioasa</span><span class="p">.</span><span class="n">ioasc</span><span class="p">));</span>

	<span class="n">pmcraid_reinit_cmdblk</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>

	<span class="n">pmcraid_cancel_hcam</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span>
			    <span class="n">PMCRAID_HCAM_CODE_CONFIG_CHANGE</span><span class="p">,</span>
			    <span class="n">pmcraid_ioa_shutdown</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_cancel_ldn - cancel LDN HCAM already registered with IOA</span>
<span class="cm"> *</span>
<span class="cm"> * @cmd: command block to be used for cancelling the HCAM</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pmcraid_cancel_ldn</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pmcraid_cancel_hcam</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span>
			    <span class="n">PMCRAID_HCAM_CODE_LOG_DATA</span><span class="p">,</span>
			    <span class="n">pmcraid_cancel_ccn</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_expose_resource - check if the resource can be exposed to OS</span>
<span class="cm"> *</span>
<span class="cm"> * @fw_version: firmware version code</span>
<span class="cm"> * @cfgte: pointer to configuration table entry of the resource</span>
<span class="cm"> *</span>
<span class="cm"> * Return value:</span>
<span class="cm"> *	true if resource can be added to midlayer, false(0) otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pmcraid_expose_resource</span><span class="p">(</span><span class="n">u16</span> <span class="n">fw_version</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">pmcraid_config_table_entry</span> <span class="o">*</span><span class="n">cfgte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cfgte</span><span class="o">-&gt;</span><span class="n">resource_type</span> <span class="o">==</span> <span class="n">RES_TYPE_VSET</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fw_version</span> <span class="o">&lt;=</span> <span class="n">PMCRAID_FW_VERSION_1</span><span class="p">)</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="p">((</span><span class="n">cfgte</span><span class="o">-&gt;</span><span class="n">unique_flags1</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="p">((</span><span class="n">cfgte</span><span class="o">-&gt;</span><span class="n">unique_flags0</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
				  <span class="p">(</span><span class="n">cfgte</span><span class="o">-&gt;</span><span class="n">unique_flags1</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cfgte</span><span class="o">-&gt;</span><span class="n">resource_type</span> <span class="o">==</span> <span class="n">RES_TYPE_GSCSI</span><span class="p">)</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="p">(</span><span class="n">RES_BUS</span><span class="p">(</span><span class="n">cfgte</span><span class="o">-&gt;</span><span class="n">resource_address</span><span class="p">)</span> <span class="o">!=</span>
				<span class="n">PMCRAID_VIRTUAL_ENCL_BUS_ID</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* attributes supported by pmcraid_event_family */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">PMCRAID_AEN_ATTR_UNSPEC</span><span class="p">,</span>
	<span class="n">PMCRAID_AEN_ATTR_EVENT</span><span class="p">,</span>
	<span class="n">__PMCRAID_AEN_ATTR_MAX</span><span class="p">,</span>
<span class="p">};</span>
<span class="cp">#define PMCRAID_AEN_ATTR_MAX (__PMCRAID_AEN_ATTR_MAX - 1)</span>

<span class="cm">/* commands supported by pmcraid_event_family */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">PMCRAID_AEN_CMD_UNSPEC</span><span class="p">,</span>
	<span class="n">PMCRAID_AEN_CMD_EVENT</span><span class="p">,</span>
	<span class="n">__PMCRAID_AEN_CMD_MAX</span><span class="p">,</span>
<span class="p">};</span>
<span class="cp">#define PMCRAID_AEN_CMD_MAX (__PMCRAID_AEN_CMD_MAX - 1)</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">genl_family</span> <span class="n">pmcraid_event_family</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">GENL_ID_GENERATE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;pmcraid&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">version</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">maxattr</span> <span class="o">=</span> <span class="n">PMCRAID_AEN_ATTR_MAX</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_netlink_init - registers pmcraid_event_family</span>
<span class="cm"> *</span>
<span class="cm"> * Return value:</span>
<span class="cm"> *	0 if the pmcraid_event_family is successfully registered</span>
<span class="cm"> *	with netlink generic, non-zero otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pmcraid_netlink_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">genl_register_family</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pmcraid_event_family</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">pmcraid_info</span><span class="p">(</span><span class="s">&quot;registered NETLINK GENERIC group: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">pmcraid_event_family</span><span class="p">.</span><span class="n">id</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_netlink_release - unregisters pmcraid_event_family</span>
<span class="cm"> *</span>
<span class="cm"> * Return value:</span>
<span class="cm"> *	none</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pmcraid_netlink_release</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">genl_unregister_family</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pmcraid_event_family</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_notify_aen - sends event msg to user space application</span>
<span class="cm"> * @pinstance: pointer to adapter instance structure</span>
<span class="cm"> * @type: HCAM type</span>
<span class="cm"> *</span>
<span class="cm"> * Return value:</span>
<span class="cm"> *	0 if success, error value in case of any failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pmcraid_notify_aen</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">pmcraid_aen_msg</span>  <span class="o">*</span><span class="n">aen_msg</span><span class="p">,</span>
	<span class="n">u32</span>    <span class="n">data_size</span>
<span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">msg_header</span><span class="p">;</span>
	<span class="n">u32</span>  <span class="n">total_size</span><span class="p">,</span> <span class="n">nla_genl_hdr_total_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">aen_msg</span><span class="o">-&gt;</span><span class="n">hostno</span> <span class="o">=</span> <span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">unique_id</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span> <span class="o">|</span>
			   <span class="n">MINOR</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">.</span><span class="n">dev</span><span class="p">));</span>
	<span class="n">aen_msg</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">data_size</span><span class="p">;</span>

	<span class="n">data_size</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">aen_msg</span><span class="p">);</span>

	<span class="n">total_size</span> <span class="o">=</span> <span class="n">nla_total_size</span><span class="p">(</span><span class="n">data_size</span><span class="p">);</span>
	<span class="cm">/* Add GENL_HDR to total_size */</span>
	<span class="n">nla_genl_hdr_total_size</span> <span class="o">=</span>
		<span class="p">(</span><span class="n">total_size</span> <span class="o">+</span> <span class="p">(</span><span class="n">GENL_HDRLEN</span> <span class="o">+</span>
		<span class="p">((</span><span class="k">struct</span> <span class="n">genl_family</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">pmcraid_event_family</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">hdrsize</span><span class="p">)</span>
		 <span class="o">+</span> <span class="n">NLMSG_HDRLEN</span><span class="p">);</span>
	<span class="n">skb</span> <span class="o">=</span> <span class="n">genlmsg_new</span><span class="p">(</span><span class="n">nla_genl_hdr_total_size</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>


	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pmcraid_err</span><span class="p">(</span><span class="s">&quot;Failed to allocate aen data SKB of size: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">total_size</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* add the genetlink message header */</span>
	<span class="n">msg_header</span> <span class="o">=</span> <span class="n">genlmsg_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				 <span class="o">&amp;</span><span class="n">pmcraid_event_family</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				 <span class="n">PMCRAID_AEN_CMD_EVENT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">msg_header</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pmcraid_err</span><span class="p">(</span><span class="s">&quot;failed to copy command details</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">nlmsg_free</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">nla_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">PMCRAID_AEN_ATTR_EVENT</span><span class="p">,</span> <span class="n">data_size</span><span class="p">,</span> <span class="n">aen_msg</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pmcraid_err</span><span class="p">(</span><span class="s">&quot;failed to copy AEN attribute data</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">nlmsg_free</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* send genetlink multicast message to notify appplications */</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">genlmsg_end</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">msg_header</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pmcraid_err</span><span class="p">(</span><span class="s">&quot;genlmsg_end failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">nlmsg_free</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">result</span> <span class="o">=</span>
		<span class="n">genlmsg_multicast</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pmcraid_event_family</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>

	<span class="cm">/* If there are no listeners, genlmsg_multicast may return non-zero</span>
<span class="cm">	 * value.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>
		<span class="n">pmcraid_info</span><span class="p">(</span><span class="s">&quot;error (%x) sending aen event message</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_notify_ccn - notifies about CCN event msg to user space</span>
<span class="cm"> * @pinstance: pointer adapter instance structure</span>
<span class="cm"> *</span>
<span class="cm"> * Return value:</span>
<span class="cm"> *	0 if success, error value in case of any failure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pmcraid_notify_ccn</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pmcraid_notify_aen</span><span class="p">(</span><span class="n">pinstance</span><span class="p">,</span>
				<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ccn</span><span class="p">.</span><span class="n">msg</span><span class="p">,</span>
				<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ccn</span><span class="p">.</span><span class="n">hcam</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">+</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_hcam_hdr</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_notify_ldn - notifies about CCN event msg to user space</span>
<span class="cm"> * @pinstance: pointer adapter instance structure</span>
<span class="cm"> *</span>
<span class="cm"> * Return value:</span>
<span class="cm"> *	0 if success, error value in case of any failure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pmcraid_notify_ldn</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pmcraid_notify_aen</span><span class="p">(</span><span class="n">pinstance</span><span class="p">,</span>
				<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ldn</span><span class="p">.</span><span class="n">msg</span><span class="p">,</span>
				<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ldn</span><span class="p">.</span><span class="n">hcam</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">+</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_hcam_hdr</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_notify_ioastate - sends IOA state event msg to user space</span>
<span class="cm"> * @pinstance: pointer adapter instance structure</span>
<span class="cm"> * @evt: controller state event to be sent</span>
<span class="cm"> *</span>
<span class="cm"> * Return value:</span>
<span class="cm"> *	0 if success, error value in case of any failure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pmcraid_notify_ioastate</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span><span class="p">,</span> <span class="n">u32</span> <span class="n">evt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">scn</span><span class="p">.</span><span class="n">ioa_state</span> <span class="o">=</span> <span class="n">evt</span><span class="p">;</span>
	<span class="n">pmcraid_notify_aen</span><span class="p">(</span><span class="n">pinstance</span><span class="p">,</span>
			  <span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">scn</span><span class="p">.</span><span class="n">msg</span><span class="p">,</span>
			  <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_handle_config_change - Handle a config change from the adapter</span>
<span class="cm"> * @pinstance: pointer to per adapter instance structure</span>
<span class="cm"> *</span>
<span class="cm"> * Return value:</span>
<span class="cm"> *  none</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pmcraid_handle_config_change</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pmcraid_config_table_entry</span> <span class="o">*</span><span class="n">cfg_entry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pmcraid_hcam_ccn</span> <span class="o">*</span><span class="n">ccn_hcam</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pmcraid_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pmcraid_cmd</span> <span class="o">*</span><span class="n">cfgcmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pmcraid_resource_entry</span> <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lock_flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">host_lock_flags</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">new_entry</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">hidden_entry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">fw_version</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">ccn_hcam</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_hcam_ccn</span> <span class="o">*</span><span class="p">)</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ccn</span><span class="p">.</span><span class="n">hcam</span><span class="p">;</span>
	<span class="n">cfg_entry</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ccn_hcam</span><span class="o">-&gt;</span><span class="n">cfg_entry</span><span class="p">;</span>
	<span class="n">fw_version</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">inq_data</span><span class="o">-&gt;</span><span class="n">fw_version</span><span class="p">);</span>

	<span class="n">pmcraid_info</span><span class="p">(</span><span class="s">&quot;CCN(%x): %x timestamp: %llx type: %x lost: %x flags: %x \</span>
<span class="s">		 res: %x:%x:%x:%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ccn</span><span class="p">.</span><span class="n">hcam</span><span class="o">-&gt;</span><span class="n">ilid</span><span class="p">,</span>
		 <span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ccn</span><span class="p">.</span><span class="n">hcam</span><span class="o">-&gt;</span><span class="n">op_code</span><span class="p">,</span>
		<span class="p">((</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ccn</span><span class="p">.</span><span class="n">hcam</span><span class="o">-&gt;</span><span class="n">timestamp1</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">((</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ccn</span><span class="p">.</span><span class="n">hcam</span><span class="o">-&gt;</span><span class="n">timestamp2</span> <span class="o">&amp;</span> <span class="mh">0xffffffffLL</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">)),</span>
		 <span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ccn</span><span class="p">.</span><span class="n">hcam</span><span class="o">-&gt;</span><span class="n">notification_type</span><span class="p">,</span>
		 <span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ccn</span><span class="p">.</span><span class="n">hcam</span><span class="o">-&gt;</span><span class="n">notification_lost</span><span class="p">,</span>
		 <span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ccn</span><span class="p">.</span><span class="n">hcam</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span>
		 <span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">unique_id</span><span class="p">,</span>
		 <span class="n">RES_IS_VSET</span><span class="p">(</span><span class="o">*</span><span class="n">cfg_entry</span><span class="p">)</span> <span class="o">?</span> <span class="n">PMCRAID_VSET_BUS_ID</span> <span class="o">:</span>
		 <span class="p">(</span><span class="n">RES_IS_GSCSI</span><span class="p">(</span><span class="o">*</span><span class="n">cfg_entry</span><span class="p">)</span> <span class="o">?</span> <span class="n">PMCRAID_PHYS_BUS_ID</span> <span class="o">:</span>
			<span class="n">RES_BUS</span><span class="p">(</span><span class="n">cfg_entry</span><span class="o">-&gt;</span><span class="n">resource_address</span><span class="p">)),</span>
		 <span class="n">RES_IS_VSET</span><span class="p">(</span><span class="o">*</span><span class="n">cfg_entry</span><span class="p">)</span> <span class="o">?</span>
			<span class="p">(</span><span class="n">fw_version</span> <span class="o">&lt;=</span> <span class="n">PMCRAID_FW_VERSION_1</span> <span class="o">?</span>
				<span class="n">cfg_entry</span><span class="o">-&gt;</span><span class="n">unique_flags1</span> <span class="o">:</span>
					<span class="n">cfg_entry</span><span class="o">-&gt;</span><span class="n">array_id</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">)</span> <span class="o">:</span>
			<span class="n">RES_TARGET</span><span class="p">(</span><span class="n">cfg_entry</span><span class="o">-&gt;</span><span class="n">resource_address</span><span class="p">),</span>
		 <span class="n">RES_LUN</span><span class="p">(</span><span class="n">cfg_entry</span><span class="o">-&gt;</span><span class="n">resource_address</span><span class="p">));</span>


	<span class="cm">/* If this HCAM indicates a lost notification, read the config table */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ccn</span><span class="p">.</span><span class="n">hcam</span><span class="o">-&gt;</span><span class="n">notification_lost</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cfgcmd</span> <span class="o">=</span> <span class="n">pmcraid_get_free_cmd</span><span class="p">(</span><span class="n">pinstance</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cfgcmd</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pmcraid_info</span><span class="p">(</span><span class="s">&quot;lost CCN, reading config table</span><span class="se">\b</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">reinit_cfg_table</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">pmcraid_querycfg</span><span class="p">(</span><span class="n">cfgcmd</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">pmcraid_err</span><span class="p">(</span><span class="s">&quot;lost CCN, no free cmd for querycfg</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">goto</span> <span class="n">out_notify_apps</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If this resource is not going to be added to mid-layer, just notify</span>
<span class="cm">	 * applications and return. If this notification is about hiding a VSET</span>
<span class="cm">	 * resource, check if it was exposed already.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ccn</span><span class="p">.</span><span class="n">hcam</span><span class="o">-&gt;</span><span class="n">notification_type</span> <span class="o">==</span>
	    <span class="n">NOTIFICATION_TYPE_ENTRY_CHANGED</span> <span class="o">&amp;&amp;</span>
	    <span class="n">cfg_entry</span><span class="o">-&gt;</span><span class="n">resource_type</span> <span class="o">==</span> <span class="n">RES_TYPE_VSET</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">fw_version</span> <span class="o">&lt;=</span> <span class="n">PMCRAID_FW_VERSION_1</span><span class="p">)</span>
			<span class="n">hidden_entry</span> <span class="o">=</span> <span class="p">(</span><span class="n">cfg_entry</span><span class="o">-&gt;</span><span class="n">unique_flags1</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">hidden_entry</span> <span class="o">=</span> <span class="p">(</span><span class="n">cfg_entry</span><span class="o">-&gt;</span><span class="n">unique_flags1</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pmcraid_expose_resource</span><span class="p">(</span><span class="n">fw_version</span><span class="p">,</span> <span class="n">cfg_entry</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">goto</span> <span class="n">out_notify_apps</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">resource_lock</span><span class="p">,</span> <span class="n">lock_flags</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">used_res_q</span><span class="p">,</span> <span class="n">queue</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">memcmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">cfg_entry</span><span class="p">.</span><span class="n">resource_address</span><span class="p">,</span>
			    <span class="o">&amp;</span><span class="n">cfg_entry</span><span class="o">-&gt;</span><span class="n">resource_address</span><span class="p">,</span>
			    <span class="k">sizeof</span><span class="p">(</span><span class="n">cfg_entry</span><span class="o">-&gt;</span><span class="n">resource_address</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">new_entry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">new_entry</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">hidden_entry</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">resource_lock</span><span class="p">,</span>
						<span class="n">lock_flags</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_notify_apps</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* If there are more number of resources than what driver can</span>
<span class="cm">		 * manage, do not notify the applications about the CCN. Just</span>
<span class="cm">		 * ignore this notifications and re-register the same HCAM</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">free_res_q</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">resource_lock</span><span class="p">,</span>
						<span class="n">lock_flags</span><span class="p">);</span>
			<span class="n">pmcraid_err</span><span class="p">(</span><span class="s">&quot;too many resources attached</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span>
					  <span class="n">host_lock_flags</span><span class="p">);</span>
			<span class="n">pmcraid_send_hcam</span><span class="p">(</span><span class="n">pinstance</span><span class="p">,</span>
					  <span class="n">PMCRAID_HCAM_CODE_CONFIG_CHANGE</span><span class="p">);</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span>
					       <span class="n">host_lock_flags</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">res</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">free_res_q</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">pmcraid_resource_entry</span><span class="p">,</span> <span class="n">queue</span><span class="p">);</span>

		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>
		<span class="n">res</span><span class="o">-&gt;</span><span class="n">scsi_dev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">res</span><span class="o">-&gt;</span><span class="n">reset_progress</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">used_res_q</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">cfg_entry</span><span class="p">,</span> <span class="n">cfg_entry</span><span class="p">,</span> <span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">config_table_entry_size</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ccn</span><span class="p">.</span><span class="n">hcam</span><span class="o">-&gt;</span><span class="n">notification_type</span> <span class="o">==</span>
	    <span class="n">NOTIFICATION_TYPE_ENTRY_DELETED</span> <span class="o">||</span> <span class="n">hidden_entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">scsi_dev</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">fw_version</span> <span class="o">&lt;=</span> <span class="n">PMCRAID_FW_VERSION_1</span><span class="p">)</span>
				<span class="n">res</span><span class="o">-&gt;</span><span class="n">cfg_entry</span><span class="p">.</span><span class="n">unique_flags1</span> <span class="o">&amp;=</span> <span class="mh">0x7F</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">res</span><span class="o">-&gt;</span><span class="n">cfg_entry</span><span class="p">.</span><span class="n">array_id</span> <span class="o">&amp;=</span> <span class="mh">0xFF</span><span class="p">;</span>
			<span class="n">res</span><span class="o">-&gt;</span><span class="n">change_detected</span> <span class="o">=</span> <span class="n">RES_CHANGE_DEL</span><span class="p">;</span>
			<span class="n">res</span><span class="o">-&gt;</span><span class="n">cfg_entry</span><span class="p">.</span><span class="n">resource_handle</span> <span class="o">=</span>
				<span class="n">PMCRAID_INVALID_RES_HANDLE</span><span class="p">;</span>
			<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">worker_q</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* This may be one of the non-exposed resources */</span>
			<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">free_res_q</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">scsi_dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">res</span><span class="o">-&gt;</span><span class="n">change_detected</span> <span class="o">=</span> <span class="n">RES_CHANGE_ADD</span><span class="p">;</span>
		<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">worker_q</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">resource_lock</span><span class="p">,</span> <span class="n">lock_flags</span><span class="p">);</span>

<span class="nl">out_notify_apps:</span>

	<span class="cm">/* Notify configuration changes to registered applications.*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pmcraid_disable_aen</span><span class="p">)</span>
		<span class="n">pmcraid_notify_ccn</span><span class="p">(</span><span class="n">pinstance</span><span class="p">);</span>

	<span class="n">cmd</span> <span class="o">=</span> <span class="n">pmcraid_init_hcam</span><span class="p">(</span><span class="n">pinstance</span><span class="p">,</span> <span class="n">PMCRAID_HCAM_CODE_CONFIG_CHANGE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span>
		<span class="n">pmcraid_send_hcam_cmd</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_get_error_info - return error string for an ioasc</span>
<span class="cm"> * @ioasc: ioasc code</span>
<span class="cm"> * Return Value</span>
<span class="cm"> *	 none</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">pmcraid_ioasc_error</span> <span class="o">*</span><span class="nf">pmcraid_get_error_info</span><span class="p">(</span><span class="n">u32</span> <span class="n">ioasc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">pmcraid_ioasc_error_table</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pmcraid_ioasc_error_table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">ioasc_code</span> <span class="o">==</span> <span class="n">ioasc</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">&amp;</span><span class="n">pmcraid_ioasc_error_table</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_ioasc_logger - log IOASC information based user-settings</span>
<span class="cm"> * @ioasc: ioasc code</span>
<span class="cm"> * @cmd: pointer to command that resulted in &#39;ioasc&#39;</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">pmcraid_ioasc_logger</span><span class="p">(</span><span class="n">u32</span> <span class="n">ioasc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pmcraid_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pmcraid_ioasc_error</span> <span class="o">*</span><span class="n">error_info</span> <span class="o">=</span> <span class="n">pmcraid_get_error_info</span><span class="p">(</span><span class="n">ioasc</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error_info</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">drv_inst</span><span class="o">-&gt;</span><span class="n">current_log_level</span> <span class="o">&lt;</span> <span class="n">error_info</span><span class="o">-&gt;</span><span class="n">log_level</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* log the error string */</span>
	<span class="n">pmcraid_err</span><span class="p">(</span><span class="s">&quot;cmd [%x] for resource %x failed with %x(%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ioa_cb</span><span class="o">-&gt;</span><span class="n">ioarcb</span><span class="p">.</span><span class="n">cdb</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ioa_cb</span><span class="o">-&gt;</span><span class="n">ioarcb</span><span class="p">.</span><span class="n">resource_handle</span><span class="p">,</span>
		<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ioasc</span><span class="p">),</span> <span class="n">error_info</span><span class="o">-&gt;</span><span class="n">error_string</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_handle_error_log - Handle a config change (error log) from the IOA</span>
<span class="cm"> *</span>
<span class="cm"> * @pinstance: pointer to per adapter instance structure</span>
<span class="cm"> *</span>
<span class="cm"> * Return value:</span>
<span class="cm"> *  none</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pmcraid_handle_error_log</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pmcraid_hcam_ldn</span> <span class="o">*</span><span class="n">hcam_ldn</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ioasc</span><span class="p">;</span>

	<span class="n">hcam_ldn</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_hcam_ldn</span> <span class="o">*</span><span class="p">)</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ldn</span><span class="p">.</span><span class="n">hcam</span><span class="p">;</span>

	<span class="n">pmcraid_info</span>
		<span class="p">(</span><span class="s">&quot;LDN(%x): %x type: %x lost: %x flags: %x overlay id: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ldn</span><span class="p">.</span><span class="n">hcam</span><span class="o">-&gt;</span><span class="n">ilid</span><span class="p">,</span>
		 <span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ldn</span><span class="p">.</span><span class="n">hcam</span><span class="o">-&gt;</span><span class="n">op_code</span><span class="p">,</span>
		 <span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ldn</span><span class="p">.</span><span class="n">hcam</span><span class="o">-&gt;</span><span class="n">notification_type</span><span class="p">,</span>
		 <span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ldn</span><span class="p">.</span><span class="n">hcam</span><span class="o">-&gt;</span><span class="n">notification_lost</span><span class="p">,</span>
		 <span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ldn</span><span class="p">.</span><span class="n">hcam</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span>
		 <span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ldn</span><span class="p">.</span><span class="n">hcam</span><span class="o">-&gt;</span><span class="n">overlay_id</span><span class="p">);</span>

	<span class="cm">/* log only the errors, no need to log informational log entries */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ldn</span><span class="p">.</span><span class="n">hcam</span><span class="o">-&gt;</span><span class="n">notification_type</span> <span class="o">!=</span>
	    <span class="n">NOTIFICATION_TYPE_ERROR_LOG</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ldn</span><span class="p">.</span><span class="n">hcam</span><span class="o">-&gt;</span><span class="n">notification_lost</span> <span class="o">==</span>
	    <span class="n">HOSTRCB_NOTIFICATIONS_LOST</span><span class="p">)</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Error notifications lost</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">ioasc</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">hcam_ldn</span><span class="o">-&gt;</span><span class="n">error_log</span><span class="p">.</span><span class="n">fd_ioasc</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ioasc</span> <span class="o">==</span> <span class="n">PMCRAID_IOASC_UA_BUS_WAS_RESET</span> <span class="o">||</span>
		<span class="n">ioasc</span> <span class="o">==</span> <span class="n">PMCRAID_IOASC_UA_BUS_WAS_RESET_BY_OTHER</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;UnitAttention due to IOA Bus Reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">scsi_report_bus_reset</span><span class="p">(</span>
			<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span>
			<span class="n">RES_BUS</span><span class="p">(</span><span class="n">hcam_ldn</span><span class="o">-&gt;</span><span class="n">error_log</span><span class="p">.</span><span class="n">fd_ra</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_process_ccn - Op done function for a CCN.</span>
<span class="cm"> * @cmd: pointer to command struct</span>
<span class="cm"> *</span>
<span class="cm"> * This function is the op done function for a configuration</span>
<span class="cm"> * change notification</span>
<span class="cm"> *</span>
<span class="cm"> * Return value:</span>
<span class="cm"> * none</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pmcraid_process_ccn</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">drv_inst</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ioasc</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ioa_cb</span><span class="o">-&gt;</span><span class="n">ioasa</span><span class="p">.</span><span class="n">ioasc</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lock_flags</span><span class="p">;</span>

	<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ccn</span><span class="p">.</span><span class="n">cmd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">pmcraid_return_cmd</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>

	<span class="cm">/* If driver initiated IOA reset happened while this hcam was pending</span>
<span class="cm">	 * with IOA, or IOA bringdown sequence is in progress, no need to</span>
<span class="cm">	 * re-register the hcam</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ioasc</span> <span class="o">==</span> <span class="n">PMCRAID_IOASC_IOA_WAS_RESET</span> <span class="o">||</span>
	    <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ccn</span><span class="p">.</span><span class="n">ignore</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ioasc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;Host RCB (CCN) failed with IOASC: 0x%08X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ioasc</span><span class="p">);</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">lock_flags</span><span class="p">);</span>
		<span class="n">pmcraid_send_hcam</span><span class="p">(</span><span class="n">pinstance</span><span class="p">,</span> <span class="n">PMCRAID_HCAM_CODE_CONFIG_CHANGE</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">lock_flags</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pmcraid_handle_config_change</span><span class="p">(</span><span class="n">pinstance</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_process_ldn - op done function for an LDN</span>
<span class="cm"> * @cmd: pointer to command block</span>
<span class="cm"> *</span>
<span class="cm"> * Return value</span>
<span class="cm"> *   none</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">pmcraid_initiate_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">pmcraid_set_timestamp</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pmcraid_process_ldn</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">drv_inst</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pmcraid_hcam_ldn</span> <span class="o">*</span><span class="n">ldn_hcam</span> <span class="o">=</span>
			<span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_hcam_ldn</span> <span class="o">*</span><span class="p">)</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ldn</span><span class="p">.</span><span class="n">hcam</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ioasc</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ioa_cb</span><span class="o">-&gt;</span><span class="n">ioasa</span><span class="p">.</span><span class="n">ioasc</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">fd_ioasc</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ldn_hcam</span><span class="o">-&gt;</span><span class="n">error_log</span><span class="p">.</span><span class="n">fd_ioasc</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lock_flags</span><span class="p">;</span>

	<span class="cm">/* return the command block back to freepool */</span>
	<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ldn</span><span class="p">.</span><span class="n">cmd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">pmcraid_return_cmd</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>

	<span class="cm">/* If driver initiated IOA reset happened while this hcam was pending</span>
<span class="cm">	 * with IOA, no need to re-register the hcam as reset engine will do it</span>
<span class="cm">	 * once reset sequence is complete</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ioasc</span> <span class="o">==</span> <span class="n">PMCRAID_IOASC_IOA_WAS_RESET</span> <span class="o">||</span>
	    <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ccn</span><span class="p">.</span><span class="n">ignore</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ioasc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pmcraid_handle_error_log</span><span class="p">(</span><span class="n">pinstance</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fd_ioasc</span> <span class="o">==</span> <span class="n">PMCRAID_IOASC_NR_IOA_RESET_REQUIRED</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span>
					  <span class="n">lock_flags</span><span class="p">);</span>
			<span class="n">pmcraid_initiate_reset</span><span class="p">(</span><span class="n">pinstance</span><span class="p">);</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span>
					       <span class="n">lock_flags</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fd_ioasc</span> <span class="o">==</span> <span class="n">PMCRAID_IOASC_TIME_STAMP_OUT_OF_SYNC</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">timestamp_error</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">pmcraid_set_timestamp</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;Host RCB(LDN) failed with IOASC: 0x%08X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ioasc</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* send netlink message for HCAM notification if enabled */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pmcraid_disable_aen</span><span class="p">)</span>
		<span class="n">pmcraid_notify_ldn</span><span class="p">(</span><span class="n">pinstance</span><span class="p">);</span>

	<span class="n">cmd</span> <span class="o">=</span> <span class="n">pmcraid_init_hcam</span><span class="p">(</span><span class="n">pinstance</span><span class="p">,</span> <span class="n">PMCRAID_HCAM_CODE_LOG_DATA</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span>
		<span class="n">pmcraid_send_hcam_cmd</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_register_hcams - register HCAMs for CCN and LDN</span>
<span class="cm"> *</span>
<span class="cm"> * @pinstance: pointer per adapter instance structure</span>
<span class="cm"> *</span>
<span class="cm"> * Return Value</span>
<span class="cm"> *   none</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pmcraid_register_hcams</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pmcraid_send_hcam</span><span class="p">(</span><span class="n">pinstance</span><span class="p">,</span> <span class="n">PMCRAID_HCAM_CODE_CONFIG_CHANGE</span><span class="p">);</span>
	<span class="n">pmcraid_send_hcam</span><span class="p">(</span><span class="n">pinstance</span><span class="p">,</span> <span class="n">PMCRAID_HCAM_CODE_LOG_DATA</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_unregister_hcams - cancel HCAMs registered already</span>
<span class="cm"> * @cmd: pointer to command used as part of reset sequence</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pmcraid_unregister_hcams</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">drv_inst</span><span class="p">;</span>

	<span class="cm">/* During IOA bringdown, HCAM gets fired and tasklet proceeds with</span>
<span class="cm">	 * handling hcam response though it is not necessary. In order to</span>
<span class="cm">	 * prevent this, set &#39;ignore&#39;, so that bring-down sequence doesn&#39;t</span>
<span class="cm">	 * re-send any more hcams</span>
<span class="cm">	 */</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ccn</span><span class="p">.</span><span class="n">ignore</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ldn</span><span class="p">.</span><span class="n">ignore</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* If adapter reset was forced as part of runtime reset sequence,</span>
<span class="cm">	 * start the reset sequence. Reset will be triggered even in case</span>
<span class="cm">	 * IOA unit_check.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">force_ioa_reset</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ioa_bringdown</span><span class="p">)</span> <span class="o">||</span>
	     <span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ioa_unit_check</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">force_ioa_reset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ioa_unit_check</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ioa_state</span> <span class="o">=</span> <span class="n">IOA_STATE_IN_RESET_ALERT</span><span class="p">;</span>
		<span class="n">pmcraid_reset_alert</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Driver tries to cancel HCAMs by sending ABORT TASK for each HCAM</span>
<span class="cm">	 * one after the other. So CCN cancellation will be triggered by</span>
<span class="cm">	 * pmcraid_cancel_ldn itself.</span>
<span class="cm">	 */</span>
	<span class="n">pmcraid_cancel_ldn</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_reset_enable_ioa - re-enable IOA after a hard reset</span>
<span class="cm"> * @pinstance: pointer to adapter instance structure</span>
<span class="cm"> * Return Value</span>
<span class="cm"> *  1 if TRANSITION_TO_OPERATIONAL is active, otherwise 0</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">pmcraid_reinit_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pmcraid_reset_enable_ioa</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">intrs</span><span class="p">;</span>

	<span class="n">pmcraid_reinit_buffers</span><span class="p">(</span><span class="n">pinstance</span><span class="p">);</span>
	<span class="n">intrs</span> <span class="o">=</span> <span class="n">pmcraid_read_interrupts</span><span class="p">(</span><span class="n">pinstance</span><span class="p">);</span>

	<span class="n">pmcraid_enable_interrupts</span><span class="p">(</span><span class="n">pinstance</span><span class="p">,</span> <span class="n">PMCRAID_PCI_INTERRUPTS</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">intrs</span> <span class="o">&amp;</span> <span class="n">INTRS_TRANSITION_TO_OPERATIONAL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">interrupt_mode</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">iowrite32</span><span class="p">(</span><span class="n">INTRS_TRANSITION_TO_OPERATIONAL</span><span class="p">,</span>
				<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">int_regs</span><span class="p">.</span>
				<span class="n">ioa_host_interrupt_mask_reg</span><span class="p">);</span>
			<span class="n">iowrite32</span><span class="p">(</span><span class="n">INTRS_TRANSITION_TO_OPERATIONAL</span><span class="p">,</span>
				<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">int_regs</span><span class="p">.</span><span class="n">ioa_host_interrupt_clr_reg</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_soft_reset - performs a soft reset and makes IOA become ready</span>
<span class="cm"> * @cmd : pointer to reset command block</span>
<span class="cm"> *</span>
<span class="cm"> * Return Value</span>
<span class="cm"> *	none</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pmcraid_soft_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">drv_inst</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">int_reg</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">doorbell</span><span class="p">;</span>

	<span class="cm">/* There will be an interrupt when Transition to Operational bit is</span>
<span class="cm">	 * set so tasklet would execute next reset task. The timeout handler</span>
<span class="cm">	 * would re-initiate a reset</span>
<span class="cm">	 */</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmd_done</span> <span class="o">=</span> <span class="n">pmcraid_ioa_reset</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">cmd</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">.</span><span class="n">expires</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span>
			     <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">PMCRAID_TRANSOP_TIMEOUT</span><span class="p">);</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">))</span><span class="n">pmcraid_timeout_handler</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">timer_pending</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">))</span>
		<span class="n">add_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>

	<span class="cm">/* Enable destructive diagnostics on IOA if it is not yet in</span>
<span class="cm">	 * operational state</span>
<span class="cm">	 */</span>
	<span class="n">doorbell</span> <span class="o">=</span> <span class="n">DOORBELL_RUNTIME_RESET</span> <span class="o">|</span>
		   <span class="n">DOORBELL_ENABLE_DESTRUCTIVE_DIAGS</span><span class="p">;</span>

	<span class="cm">/* Since we do RESET_ALERT and Start BIST we have to again write</span>
<span class="cm">	 * MSIX Doorbell to indicate the interrupt mode</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">interrupt_mode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iowrite32</span><span class="p">(</span><span class="n">DOORBELL_INTR_MODE_MSIX</span><span class="p">,</span>
			  <span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">int_regs</span><span class="p">.</span><span class="n">host_ioa_interrupt_reg</span><span class="p">);</span>
		<span class="n">ioread32</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">int_regs</span><span class="p">.</span><span class="n">host_ioa_interrupt_reg</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">iowrite32</span><span class="p">(</span><span class="n">doorbell</span><span class="p">,</span> <span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">int_regs</span><span class="p">.</span><span class="n">host_ioa_interrupt_reg</span><span class="p">);</span>
	<span class="n">ioread32</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">int_regs</span><span class="p">.</span><span class="n">host_ioa_interrupt_reg</span><span class="p">),</span>
	<span class="n">int_reg</span> <span class="o">=</span> <span class="n">ioread32</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">int_regs</span><span class="p">.</span><span class="n">ioa_host_interrupt_reg</span><span class="p">);</span>

	<span class="n">pmcraid_info</span><span class="p">(</span><span class="s">&quot;Waiting for IOA to become operational %x:%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">ioread32</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">int_regs</span><span class="p">.</span><span class="n">host_ioa_interrupt_reg</span><span class="p">),</span>
		     <span class="n">int_reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_get_dump - retrieves IOA dump in case of Unit Check interrupt</span>
<span class="cm"> *</span>
<span class="cm"> * @pinstance: pointer to adapter instance structure</span>
<span class="cm"> *</span>
<span class="cm"> * Return Value</span>
<span class="cm"> *	none</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pmcraid_get_dump</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pmcraid_info</span><span class="p">(</span><span class="s">&quot;%s is not yet implemented</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_fail_outstanding_cmds - Fails all outstanding ops.</span>
<span class="cm"> * @pinstance: pointer to adapter instance structure</span>
<span class="cm"> *</span>
<span class="cm"> * This function fails all outstanding ops. If they are submitted to IOA</span>
<span class="cm"> * already, it sends cancel all messages if IOA is still accepting IOARCBs,</span>
<span class="cm"> * otherwise just completes the commands and returns the cmd blocks to free</span>
<span class="cm"> * pool.</span>
<span class="cm"> *</span>
<span class="cm"> * Return value:</span>
<span class="cm"> *	 none</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pmcraid_fail_outstanding_cmds</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pmcraid_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="o">*</span><span class="n">temp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lock_flags</span><span class="p">;</span>

	<span class="cm">/* pending command list is protected by pending_pool_lock. Its</span>
<span class="cm">	 * traversal must be done as within this lock</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">pending_pool_lock</span><span class="p">,</span> <span class="n">lock_flags</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">pending_cmd_pool</span><span class="p">,</span>
				 <span class="n">free_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">free_list</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">pending_pool_lock</span><span class="p">,</span>
					<span class="n">lock_flags</span><span class="p">);</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ioa_cb</span><span class="o">-&gt;</span><span class="n">ioasa</span><span class="p">.</span><span class="n">ioasc</span> <span class="o">=</span>
			<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">PMCRAID_IOASC_IOA_WAS_RESET</span><span class="p">);</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ioa_cb</span><span class="o">-&gt;</span><span class="n">ioasa</span><span class="p">.</span><span class="n">ilid</span> <span class="o">=</span>
			<span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">PMCRAID_DRIVER_ILID</span><span class="p">);</span>

		<span class="cm">/* In case the command timer is still running */</span>
		<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>

		<span class="cm">/* If this is an IO command, complete it by invoking scsi_done</span>
<span class="cm">		 * function. If this is one of the internal commands other</span>
<span class="cm">		 * than pmcraid_ioa_reset and HCAM commands invoke cmd_done to</span>
<span class="cm">		 * complete it</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_cmd</span><span class="p">)</span> <span class="p">{</span>

			<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">scsi_cmd</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_cmd</span><span class="p">;</span>
			<span class="n">__le32</span> <span class="n">resp</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ioa_cb</span><span class="o">-&gt;</span><span class="n">ioarcb</span><span class="p">.</span><span class="n">response_handle</span><span class="p">;</span>

			<span class="n">scsi_cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">|=</span> <span class="n">DID_ERROR</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>

			<span class="n">scsi_dma_unmap</span><span class="p">(</span><span class="n">scsi_cmd</span><span class="p">);</span>
			<span class="n">pmcraid_return_cmd</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>

			<span class="n">pmcraid_info</span><span class="p">(</span><span class="s">&quot;failing(%d) CDB[0] = %x result: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">resp</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">,</span>
				     <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ioa_cb</span><span class="o">-&gt;</span><span class="n">ioarcb</span><span class="p">.</span><span class="n">cdb</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
				     <span class="n">scsi_cmd</span><span class="o">-&gt;</span><span class="n">result</span><span class="p">);</span>
			<span class="n">scsi_cmd</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">(</span><span class="n">scsi_cmd</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmd_done</span> <span class="o">==</span> <span class="n">pmcraid_internal_done</span> <span class="o">||</span>
			   <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmd_done</span> <span class="o">==</span> <span class="n">pmcraid_erp_done</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmd_done</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmd_done</span> <span class="o">!=</span> <span class="n">pmcraid_ioa_reset</span> <span class="o">&amp;&amp;</span>
			   <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmd_done</span> <span class="o">!=</span> <span class="n">pmcraid_ioa_shutdown_done</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pmcraid_return_cmd</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">outstanding_cmds</span><span class="p">);</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">pending_pool_lock</span><span class="p">,</span> <span class="n">lock_flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">pending_pool_lock</span><span class="p">,</span> <span class="n">lock_flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_ioa_reset - Implementation of IOA reset logic</span>
<span class="cm"> *</span>
<span class="cm"> * @cmd: pointer to the cmd block to be used for entire reset process</span>
<span class="cm"> *</span>
<span class="cm"> * This function executes most of the steps required for IOA reset. This gets</span>
<span class="cm"> * called by user threads (modprobe/insmod/rmmod) timer, tasklet and midlayer&#39;s</span>
<span class="cm"> * &#39;eh_&#39; thread. Access to variables used for controlling the reset sequence is</span>
<span class="cm"> * synchronized using host lock. Various functions called during reset process</span>
<span class="cm"> * would make use of a single command block, pointer to which is also stored in</span>
<span class="cm"> * adapter instance structure.</span>
<span class="cm"> *</span>
<span class="cm"> * Return Value</span>
<span class="cm"> *	 None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pmcraid_ioa_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">drv_inst</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">reset_complete</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ioa_reset_in_progress</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">reset_cmd</span> <span class="o">!=</span> <span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pmcraid_err</span><span class="p">(</span><span class="s">&quot;reset is called with different command block</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">reset_cmd</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pmcraid_info</span><span class="p">(</span><span class="s">&quot;reset_engine: state = %d, command = %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		      <span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ioa_state</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ioa_state</span><span class="p">)</span> <span class="p">{</span>

	<span class="k">case</span> <span class="n">IOA_STATE_DEAD</span>:
		<span class="cm">/* If IOA is offline, whatever may be the reset reason, just</span>
<span class="cm">		 * return. callers might be waiting on the reset wait_q, wake</span>
<span class="cm">		 * up them</span>
<span class="cm">		 */</span>
		<span class="n">pmcraid_err</span><span class="p">(</span><span class="s">&quot;IOA is offline no reset is possible</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">reset_complete</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">IOA_STATE_IN_BRINGDOWN</span>:
		<span class="cm">/* we enter here, once ioa shutdown command is processed by IOA</span>
<span class="cm">		 * Alert IOA for a possible reset. If reset alert fails, IOA</span>
<span class="cm">		 * goes through hard-reset</span>
<span class="cm">		 */</span>
		<span class="n">pmcraid_disable_interrupts</span><span class="p">(</span><span class="n">pinstance</span><span class="p">,</span> <span class="o">~</span><span class="mi">0</span><span class="p">);</span>
		<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ioa_state</span> <span class="o">=</span> <span class="n">IOA_STATE_IN_RESET_ALERT</span><span class="p">;</span>
		<span class="n">pmcraid_reset_alert</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">IOA_STATE_UNKNOWN</span>:
		<span class="cm">/* We may be called during probe or resume. Some pre-processing</span>
<span class="cm">		 * is required for prior to reset</span>
<span class="cm">		 */</span>
		<span class="n">scsi_block_requests</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>

		<span class="cm">/* If asked to reset while IOA was processing responses or</span>
<span class="cm">		 * there are any error responses then IOA may require</span>
<span class="cm">		 * hard-reset.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ioa_hard_reset</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ioread32</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ioa_status</span><span class="p">)</span> <span class="o">&amp;</span>
			    <span class="n">INTRS_TRANSITION_TO_OPERATIONAL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pmcraid_info</span><span class="p">(</span><span class="s">&quot;sticky bit set, bring-up</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ioa_state</span> <span class="o">=</span> <span class="n">IOA_STATE_IN_BRINGUP</span><span class="p">;</span>
				<span class="n">pmcraid_reinit_cmdblk</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
				<span class="n">pmcraid_identify_hrrq</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ioa_state</span> <span class="o">=</span> <span class="n">IOA_STATE_IN_SOFT_RESET</span><span class="p">;</span>
				<span class="n">pmcraid_soft_reset</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Alert IOA of a possible reset and wait for critical</span>
<span class="cm">			 * operation in progress bit to reset</span>
<span class="cm">			 */</span>
			<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ioa_state</span> <span class="o">=</span> <span class="n">IOA_STATE_IN_RESET_ALERT</span><span class="p">;</span>
			<span class="n">pmcraid_reset_alert</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">IOA_STATE_IN_RESET_ALERT</span>:
		<span class="cm">/* If critical operation in progress bit is reset or wait gets</span>
<span class="cm">		 * timed out, reset proceeds with starting BIST on the IOA.</span>
<span class="cm">		 * pmcraid_ioa_hard_reset keeps a count of reset attempts. If</span>
<span class="cm">		 * they are 3 or more, reset engine marks IOA dead and returns</span>
<span class="cm">		 */</span>
		<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ioa_state</span> <span class="o">=</span> <span class="n">IOA_STATE_IN_HARD_RESET</span><span class="p">;</span>
		<span class="n">pmcraid_start_bist</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">IOA_STATE_IN_HARD_RESET</span>:
		<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ioa_reset_attempts</span><span class="o">++</span><span class="p">;</span>

		<span class="cm">/* retry reset if we haven&#39;t reached maximum allowed limit */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ioa_reset_attempts</span> <span class="o">&gt;</span> <span class="n">PMCRAID_RESET_ATTEMPTS</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ioa_reset_attempts</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">pmcraid_err</span><span class="p">(</span><span class="s">&quot;IOA didn&#39;t respond marking it as dead</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ioa_state</span> <span class="o">=</span> <span class="n">IOA_STATE_DEAD</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ioa_bringdown</span><span class="p">)</span>
				<span class="n">pmcraid_notify_ioastate</span><span class="p">(</span><span class="n">pinstance</span><span class="p">,</span>
					<span class="n">PMC_DEVICE_EVENT_SHUTDOWN_FAILED</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">pmcraid_notify_ioastate</span><span class="p">(</span><span class="n">pinstance</span><span class="p">,</span>
						<span class="n">PMC_DEVICE_EVENT_RESET_FAILED</span><span class="p">);</span>
			<span class="n">reset_complete</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Once either bist or pci reset is done, restore PCI config</span>
<span class="cm">		 * space. If this fails, proceed with hard reset again</span>
<span class="cm">		 */</span>
		<span class="n">pci_restore_state</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">);</span>

		<span class="cm">/* fail all pending commands */</span>
		<span class="n">pmcraid_fail_outstanding_cmds</span><span class="p">(</span><span class="n">pinstance</span><span class="p">);</span>

		<span class="cm">/* check if unit check is active, if so extract dump */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ioa_unit_check</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pmcraid_info</span><span class="p">(</span><span class="s">&quot;unit check is active</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ioa_unit_check</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">pmcraid_get_dump</span><span class="p">(</span><span class="n">pinstance</span><span class="p">);</span>
			<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ioa_reset_attempts</span><span class="o">--</span><span class="p">;</span>
			<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ioa_state</span> <span class="o">=</span> <span class="n">IOA_STATE_IN_RESET_ALERT</span><span class="p">;</span>
			<span class="n">pmcraid_reset_alert</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* if the reset reason is to bring-down the ioa, we might be</span>
<span class="cm">		 * done with the reset restore pci_config_space and complete</span>
<span class="cm">		 * the reset</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ioa_bringdown</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pmcraid_info</span><span class="p">(</span><span class="s">&quot;bringing down the adapter</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ioa_shutdown_type</span> <span class="o">=</span> <span class="n">SHUTDOWN_NONE</span><span class="p">;</span>
			<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ioa_bringdown</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ioa_state</span> <span class="o">=</span> <span class="n">IOA_STATE_UNKNOWN</span><span class="p">;</span>
			<span class="n">pmcraid_notify_ioastate</span><span class="p">(</span><span class="n">pinstance</span><span class="p">,</span>
					<span class="n">PMC_DEVICE_EVENT_SHUTDOWN_SUCCESS</span><span class="p">);</span>
			<span class="n">reset_complete</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* bring-up IOA, so proceed with soft reset</span>
<span class="cm">			 * Reinitialize hrrq_buffers and their indices also</span>
<span class="cm">			 * enable interrupts after a pci_restore_state</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pmcraid_reset_enable_ioa</span><span class="p">(</span><span class="n">pinstance</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ioa_state</span> <span class="o">=</span> <span class="n">IOA_STATE_IN_BRINGUP</span><span class="p">;</span>
				<span class="n">pmcraid_info</span><span class="p">(</span><span class="s">&quot;bringing up the adapter</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">pmcraid_reinit_cmdblk</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
				<span class="n">pmcraid_identify_hrrq</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ioa_state</span> <span class="o">=</span> <span class="n">IOA_STATE_IN_SOFT_RESET</span><span class="p">;</span>
				<span class="n">pmcraid_soft_reset</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">IOA_STATE_IN_SOFT_RESET</span>:
		<span class="cm">/* TRANSITION TO OPERATIONAL is on so start initialization</span>
<span class="cm">		 * sequence</span>
<span class="cm">		 */</span>
		<span class="n">pmcraid_info</span><span class="p">(</span><span class="s">&quot;In softreset proceeding with bring-up</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ioa_state</span> <span class="o">=</span> <span class="n">IOA_STATE_IN_BRINGUP</span><span class="p">;</span>

		<span class="cm">/* Initialization commands start with HRRQ identification. From</span>
<span class="cm">		 * now on tasklet completes most of the commands as IOA is up</span>
<span class="cm">		 * and intrs are enabled</span>
<span class="cm">		 */</span>
		<span class="n">pmcraid_identify_hrrq</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">IOA_STATE_IN_BRINGUP</span>:
		<span class="cm">/* we are done with bringing up of IOA, change the ioa_state to</span>
<span class="cm">		 * operational and wake up any waiters</span>
<span class="cm">		 */</span>
		<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ioa_state</span> <span class="o">=</span> <span class="n">IOA_STATE_OPERATIONAL</span><span class="p">;</span>
		<span class="n">reset_complete</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">IOA_STATE_OPERATIONAL</span>:
	<span class="nl">default:</span>
		<span class="cm">/* When IOA is operational and a reset is requested, check for</span>
<span class="cm">		 * the reset reason. If reset is to bring down IOA, unregister</span>
<span class="cm">		 * HCAMs and initiate shutdown; if adapter reset is forced then</span>
<span class="cm">		 * restart reset sequence again</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ioa_shutdown_type</span> <span class="o">==</span> <span class="n">SHUTDOWN_NONE</span> <span class="o">&amp;&amp;</span>
		    <span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">force_ioa_reset</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pmcraid_notify_ioastate</span><span class="p">(</span><span class="n">pinstance</span><span class="p">,</span>
						<span class="n">PMC_DEVICE_EVENT_RESET_SUCCESS</span><span class="p">);</span>
			<span class="n">reset_complete</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ioa_shutdown_type</span> <span class="o">!=</span> <span class="n">SHUTDOWN_NONE</span><span class="p">)</span>
				<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ioa_state</span> <span class="o">=</span> <span class="n">IOA_STATE_IN_BRINGDOWN</span><span class="p">;</span>
			<span class="n">pmcraid_reinit_cmdblk</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
			<span class="n">pmcraid_unregister_hcams</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* reset will be completed if ioa_state is either DEAD or UNKNOWN or</span>
<span class="cm">	 * OPERATIONAL. Reset all control variables used during reset, wake up</span>
<span class="cm">	 * any waiting threads and let the SCSI mid-layer send commands. Note</span>
<span class="cm">	 * that host_lock must be held before invoking scsi_report_bus_reset.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reset_complete</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ioa_reset_in_progress</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ioa_reset_attempts</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">reset_cmd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ioa_shutdown_type</span> <span class="o">=</span> <span class="n">SHUTDOWN_NONE</span><span class="p">;</span>
		<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ioa_bringdown</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">pmcraid_return_cmd</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>

		<span class="cm">/* If target state is to bring up the adapter, proceed with</span>
<span class="cm">		 * hcam registration and resource exposure to mid-layer.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ioa_state</span> <span class="o">==</span> <span class="n">IOA_STATE_OPERATIONAL</span><span class="p">)</span>
			<span class="n">pmcraid_register_hcams</span><span class="p">(</span><span class="n">pinstance</span><span class="p">);</span>

		<span class="n">wake_up_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">reset_wait_q</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_initiate_reset - initiates reset sequence. This is called from</span>
<span class="cm"> * ISR/tasklet during error interrupts including IOA unit check. If reset</span>
<span class="cm"> * is already in progress, it just returns, otherwise initiates IOA reset</span>
<span class="cm"> * to bring IOA up to operational state.</span>
<span class="cm"> *</span>
<span class="cm"> * @pinstance: pointer to adapter instance structure</span>
<span class="cm"> *</span>
<span class="cm"> * Return value</span>
<span class="cm"> *	 none</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pmcraid_initiate_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pmcraid_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>

	<span class="cm">/* If the reset is already in progress, just return, otherwise start</span>
<span class="cm">	 * reset sequence and return</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ioa_reset_in_progress</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">scsi_block_requests</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>
		<span class="n">cmd</span> <span class="o">=</span> <span class="n">pmcraid_get_free_cmd</span><span class="p">(</span><span class="n">pinstance</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pmcraid_err</span><span class="p">(</span><span class="s">&quot;no cmnd blocks for initiate_reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ioa_shutdown_type</span> <span class="o">=</span> <span class="n">SHUTDOWN_NONE</span><span class="p">;</span>
		<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">reset_cmd</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">;</span>
		<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">force_ioa_reset</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">pmcraid_notify_ioastate</span><span class="p">(</span><span class="n">pinstance</span><span class="p">,</span>
					<span class="n">PMC_DEVICE_EVENT_RESET_START</span><span class="p">);</span>
		<span class="n">pmcraid_ioa_reset</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_reset_reload - utility routine for doing IOA reset either to bringup</span>
<span class="cm"> *			  or bringdown IOA</span>
<span class="cm"> * @pinstance: pointer adapter instance structure</span>
<span class="cm"> * @shutdown_type: shutdown type to be used NONE, NORMAL or ABRREV</span>
<span class="cm"> * @target_state: expected target state after reset</span>
<span class="cm"> *</span>
<span class="cm"> * Note: This command initiates reset and waits for its completion. Hence this</span>
<span class="cm"> * should not be called from isr/timer/tasklet functions (timeout handlers,</span>
<span class="cm"> * error response handlers and interrupt handlers).</span>
<span class="cm"> *</span>
<span class="cm"> * Return Value</span>
<span class="cm"> *	 1 in case ioa_state is not target_state, 0 otherwise.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pmcraid_reset_reload</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span><span class="p">,</span>
	<span class="n">u8</span> <span class="n">shutdown_type</span><span class="p">,</span>
	<span class="n">u8</span> <span class="n">target_state</span>
<span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pmcraid_cmd</span> <span class="o">*</span><span class="n">reset_cmd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lock_flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">reset</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">lock_flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ioa_reset_in_progress</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pmcraid_info</span><span class="p">(</span><span class="s">&quot;reset_reload: reset is already in progress</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">lock_flags</span><span class="p">);</span>

		<span class="n">wait_event</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">reset_wait_q</span><span class="p">,</span>
			   <span class="o">!</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ioa_reset_in_progress</span><span class="p">);</span>

		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">lock_flags</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ioa_state</span> <span class="o">==</span> <span class="n">IOA_STATE_DEAD</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span>
					       <span class="n">lock_flags</span><span class="p">);</span>
			<span class="n">pmcraid_info</span><span class="p">(</span><span class="s">&quot;reset_reload: IOA is dead</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">reset</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ioa_state</span> <span class="o">==</span> <span class="n">target_state</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">reset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">reset</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pmcraid_info</span><span class="p">(</span><span class="s">&quot;reset_reload: proceeding with reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">scsi_block_requests</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>
		<span class="n">reset_cmd</span> <span class="o">=</span> <span class="n">pmcraid_get_free_cmd</span><span class="p">(</span><span class="n">pinstance</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">reset_cmd</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pmcraid_err</span><span class="p">(</span><span class="s">&quot;no free cmnd for reset_reload</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span>
					       <span class="n">lock_flags</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">reset</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">shutdown_type</span> <span class="o">==</span> <span class="n">SHUTDOWN_NORMAL</span><span class="p">)</span>
			<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ioa_bringdown</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ioa_shutdown_type</span> <span class="o">=</span> <span class="n">shutdown_type</span><span class="p">;</span>
		<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">reset_cmd</span> <span class="o">=</span> <span class="n">reset_cmd</span><span class="p">;</span>
		<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">force_ioa_reset</span> <span class="o">=</span> <span class="n">reset</span><span class="p">;</span>
		<span class="n">pmcraid_info</span><span class="p">(</span><span class="s">&quot;reset_reload: initiating reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">pmcraid_ioa_reset</span><span class="p">(</span><span class="n">reset_cmd</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">lock_flags</span><span class="p">);</span>
		<span class="n">pmcraid_info</span><span class="p">(</span><span class="s">&quot;reset_reload: waiting for reset to complete</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">wait_event</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">reset_wait_q</span><span class="p">,</span>
			   <span class="o">!</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ioa_reset_in_progress</span><span class="p">);</span>

		<span class="n">pmcraid_info</span><span class="p">(</span><span class="s">&quot;reset_reload: reset is complete !!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">scsi_unblock_requests</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ioa_state</span> <span class="o">==</span> <span class="n">target_state</span><span class="p">)</span>
			<span class="n">reset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">reset</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_reset_bringdown - wrapper over pmcraid_reset_reload to bringdown IOA</span>
<span class="cm"> *</span>
<span class="cm"> * @pinstance: pointer to adapter instance structure</span>
<span class="cm"> *</span>
<span class="cm"> * Return Value</span>
<span class="cm"> *	 whatever is returned from pmcraid_reset_reload</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pmcraid_reset_bringdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pmcraid_reset_reload</span><span class="p">(</span><span class="n">pinstance</span><span class="p">,</span>
				    <span class="n">SHUTDOWN_NORMAL</span><span class="p">,</span>
				    <span class="n">IOA_STATE_UNKNOWN</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_reset_bringup - wrapper over pmcraid_reset_reload to bring up IOA</span>
<span class="cm"> *</span>
<span class="cm"> * @pinstance: pointer to adapter instance structure</span>
<span class="cm"> *</span>
<span class="cm"> * Return Value</span>
<span class="cm"> *	 whatever is returned from pmcraid_reset_reload</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pmcraid_reset_bringup</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pmcraid_notify_ioastate</span><span class="p">(</span><span class="n">pinstance</span><span class="p">,</span> <span class="n">PMC_DEVICE_EVENT_RESET_START</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">pmcraid_reset_reload</span><span class="p">(</span><span class="n">pinstance</span><span class="p">,</span>
				    <span class="n">SHUTDOWN_NONE</span><span class="p">,</span>
				    <span class="n">IOA_STATE_OPERATIONAL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_request_sense - Send request sense to a device</span>
<span class="cm"> * @cmd: pmcraid command struct</span>
<span class="cm"> *</span>
<span class="cm"> * This function sends a request sense to a device as a result of a check</span>
<span class="cm"> * condition. This method re-uses the same command block that failed earlier.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pmcraid_request_sense</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pmcraid_ioarcb</span> <span class="o">*</span><span class="n">ioarcb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ioa_cb</span><span class="o">-&gt;</span><span class="n">ioarcb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pmcraid_ioadl_desc</span> <span class="o">*</span><span class="n">ioadl</span> <span class="o">=</span> <span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">add_data</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">ioadl</span><span class="p">;</span>

	<span class="cm">/* allocate DMAable memory for sense buffers */</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sense_buffer</span> <span class="o">=</span> <span class="n">pci_alloc_consistent</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">drv_inst</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
						 <span class="n">SCSI_SENSE_BUFFERSIZE</span><span class="p">,</span>
						 <span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sense_buffer_dma</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sense_buffer</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pmcraid_err</span>
			<span class="p">(</span><span class="s">&quot;couldn&#39;t allocate sense buffer for request sense</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">pmcraid_erp_done</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* re-use the command block */</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ioa_cb</span><span class="o">-&gt;</span><span class="n">ioasa</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_ioasa</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">cdb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PMCRAID_MAX_CDB_LEN</span><span class="p">);</span>
	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">request_flags0</span> <span class="o">=</span> <span class="p">(</span><span class="n">SYNC_COMPLETE</span> <span class="o">|</span>
				  <span class="n">NO_LINK_DESCS</span> <span class="o">|</span>
				  <span class="n">INHIBIT_UL_CHECK</span><span class="p">);</span>
	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">request_type</span> <span class="o">=</span> <span class="n">REQ_TYPE_SCSI</span><span class="p">;</span>
	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">cdb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">REQUEST_SENSE</span><span class="p">;</span>
	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">cdb</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">SCSI_SENSE_BUFFERSIZE</span><span class="p">;</span>

	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">ioadl_bus_addr</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">((</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ioa_cb_bus_addr</span><span class="p">)</span> <span class="o">+</span>
					<span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_ioarcb</span><span class="p">,</span>
						<span class="n">add_data</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">ioadl</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">ioadl_length</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_ioadl_desc</span><span class="p">));</span>

	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">data_transfer_length</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">SCSI_SENSE_BUFFERSIZE</span><span class="p">);</span>

	<span class="n">ioadl</span><span class="o">-&gt;</span><span class="n">address</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sense_buffer_dma</span><span class="p">);</span>
	<span class="n">ioadl</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">SCSI_SENSE_BUFFERSIZE</span><span class="p">);</span>
	<span class="n">ioadl</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">IOADL_FLAGS_LAST_DESC</span><span class="p">;</span>

	<span class="cm">/* request sense might be called as part of error response processing</span>
<span class="cm">	 * which runs in tasklets context. It is possible that mid-layer might</span>
<span class="cm">	 * schedule queuecommand during this time, hence, writting to IOARRIN</span>
<span class="cm">	 * must be protect by host_lock</span>
<span class="cm">	 */</span>
	<span class="n">pmcraid_send_cmd</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">pmcraid_erp_done</span><span class="p">,</span>
			 <span class="n">PMCRAID_REQUEST_SENSE_TIMEOUT</span><span class="p">,</span>
			 <span class="n">pmcraid_timeout_handler</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_cancel_all - cancel all outstanding IOARCBs as part of error recovery</span>
<span class="cm"> * @cmd: command that failed</span>
<span class="cm"> * @sense: true if request_sense is required after cancel all</span>
<span class="cm"> *</span>
<span class="cm"> * This function sends a cancel all to a device to clear the queue.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pmcraid_cancel_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="n">u32</span> <span class="n">sense</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">scsi_cmd</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_cmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pmcraid_ioarcb</span> <span class="o">*</span><span class="n">ioarcb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ioa_cb</span><span class="o">-&gt;</span><span class="n">ioarcb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pmcraid_resource_entry</span> <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="n">scsi_cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">cmd_done</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_cmd</span> <span class="o">*</span><span class="p">)</span> <span class="o">=</span> <span class="n">sense</span> <span class="o">?</span> <span class="n">pmcraid_erp_done</span>
							<span class="o">:</span> <span class="n">pmcraid_request_sense</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">cdb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PMCRAID_MAX_CDB_LEN</span><span class="p">);</span>
	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">request_flags0</span> <span class="o">=</span> <span class="n">SYNC_OVERRIDE</span><span class="p">;</span>
	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">request_type</span> <span class="o">=</span> <span class="n">REQ_TYPE_IOACMD</span><span class="p">;</span>
	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">cdb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">PMCRAID_CANCEL_ALL_REQUESTS</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">RES_IS_GSCSI</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">cfg_entry</span><span class="p">))</span>
		<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">cdb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">PMCRAID_SYNC_COMPLETE_AFTER_CANCEL</span><span class="p">;</span>

	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">ioadl_bus_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">ioadl_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">data_transfer_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">ioarcb_bus_addr</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="o">~</span><span class="mh">0x1FULL</span><span class="p">);</span>

	<span class="cm">/* writing to IOARRIN must be protected by host_lock, as mid-layer</span>
<span class="cm">	 * schedule queuecommand while we are doing this</span>
<span class="cm">	 */</span>
	<span class="n">pmcraid_send_cmd</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">cmd_done</span><span class="p">,</span>
			 <span class="n">PMCRAID_REQUEST_SENSE_TIMEOUT</span><span class="p">,</span>
			 <span class="n">pmcraid_timeout_handler</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_frame_auto_sense: frame fixed format sense information</span>
<span class="cm"> *</span>
<span class="cm"> * @cmd: pointer to failing command block</span>
<span class="cm"> *</span>
<span class="cm"> * Return value</span>
<span class="cm"> *  none</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pmcraid_frame_auto_sense</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">sense_buf</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_cmd</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pmcraid_resource_entry</span> <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pmcraid_ioasa</span> <span class="o">*</span><span class="n">ioasa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ioa_cb</span><span class="o">-&gt;</span><span class="n">ioasa</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ioasc</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ioasa</span><span class="o">-&gt;</span><span class="n">ioasc</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">failing_lba</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">sense_buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SCSI_SENSE_BUFFERSIZE</span><span class="p">);</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">SAM_STAT_CHECK_CONDITION</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">RES_IS_VSET</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">cfg_entry</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">ioasc</span> <span class="o">==</span> <span class="n">PMCRAID_IOASC_ME_READ_ERROR_NO_REALLOC</span> <span class="o">&amp;&amp;</span>
	    <span class="n">ioasa</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">vset</span><span class="p">.</span><span class="n">failing_lba_hi</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">sense_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x72</span><span class="p">;</span>
		<span class="n">sense_buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">PMCRAID_IOASC_SENSE_KEY</span><span class="p">(</span><span class="n">ioasc</span><span class="p">);</span>
		<span class="n">sense_buf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">PMCRAID_IOASC_SENSE_CODE</span><span class="p">(</span><span class="n">ioasc</span><span class="p">);</span>
		<span class="n">sense_buf</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">PMCRAID_IOASC_SENSE_QUAL</span><span class="p">(</span><span class="n">ioasc</span><span class="p">);</span>

		<span class="n">sense_buf</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
		<span class="n">sense_buf</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">sense_buf</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0A</span><span class="p">;</span>
		<span class="n">sense_buf</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x80</span><span class="p">;</span>

		<span class="n">failing_lba</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ioasa</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">vset</span><span class="p">.</span><span class="n">failing_lba_hi</span><span class="p">);</span>

		<span class="n">sense_buf</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">failing_lba</span> <span class="o">&amp;</span> <span class="mh">0xff000000</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">;</span>
		<span class="n">sense_buf</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">failing_lba</span> <span class="o">&amp;</span> <span class="mh">0x00ff0000</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="n">sense_buf</span><span class="p">[</span><span class="mi">14</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">failing_lba</span> <span class="o">&amp;</span> <span class="mh">0x0000ff00</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">sense_buf</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span> <span class="o">=</span> <span class="n">failing_lba</span> <span class="o">&amp;</span> <span class="mh">0x000000ff</span><span class="p">;</span>

		<span class="n">failing_lba</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ioasa</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">vset</span><span class="p">.</span><span class="n">failing_lba_lo</span><span class="p">);</span>

		<span class="n">sense_buf</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">failing_lba</span> <span class="o">&amp;</span> <span class="mh">0xff000000</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">;</span>
		<span class="n">sense_buf</span><span class="p">[</span><span class="mi">17</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">failing_lba</span> <span class="o">&amp;</span> <span class="mh">0x00ff0000</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="n">sense_buf</span><span class="p">[</span><span class="mi">18</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">failing_lba</span> <span class="o">&amp;</span> <span class="mh">0x0000ff00</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">sense_buf</span><span class="p">[</span><span class="mi">19</span><span class="p">]</span> <span class="o">=</span> <span class="n">failing_lba</span> <span class="o">&amp;</span> <span class="mh">0x000000ff</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">sense_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x70</span><span class="p">;</span>
		<span class="n">sense_buf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">PMCRAID_IOASC_SENSE_KEY</span><span class="p">(</span><span class="n">ioasc</span><span class="p">);</span>
		<span class="n">sense_buf</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="n">PMCRAID_IOASC_SENSE_CODE</span><span class="p">(</span><span class="n">ioasc</span><span class="p">);</span>
		<span class="n">sense_buf</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span> <span class="o">=</span> <span class="n">PMCRAID_IOASC_SENSE_QUAL</span><span class="p">(</span><span class="n">ioasc</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ioasc</span> <span class="o">==</span> <span class="n">PMCRAID_IOASC_ME_READ_ERROR_NO_REALLOC</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">RES_IS_VSET</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">cfg_entry</span><span class="p">))</span>
				<span class="n">failing_lba</span> <span class="o">=</span>
					<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ioasa</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span>
						 <span class="n">vset</span><span class="p">.</span><span class="n">failing_lba_lo</span><span class="p">);</span>
			<span class="n">sense_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|=</span> <span class="mh">0x80</span><span class="p">;</span>
			<span class="n">sense_buf</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">failing_lba</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
			<span class="n">sense_buf</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">failing_lba</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
			<span class="n">sense_buf</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">failing_lba</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
			<span class="n">sense_buf</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">failing_lba</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">sense_buf</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span> <span class="cm">/* additional length */</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_error_handler - Error response handlers for a SCSI op</span>
<span class="cm"> * @cmd: pointer to pmcraid_cmd that has failed</span>
<span class="cm"> *</span>
<span class="cm"> * This function determines whether or not to initiate ERP on the affected</span>
<span class="cm"> * device. This is called from a tasklet, which doesn&#39;t hold any locks.</span>
<span class="cm"> *</span>
<span class="cm"> * Return value:</span>
<span class="cm"> *	 0 it caller can complete the request, otherwise 1 where in error</span>
<span class="cm"> *	 handler itself completes the request and returns the command block</span>
<span class="cm"> *	 back to free-pool</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pmcraid_error_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">scsi_cmd</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_cmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pmcraid_resource_entry</span> <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="n">scsi_cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">drv_inst</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pmcraid_ioasa</span> <span class="o">*</span><span class="n">ioasa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ioa_cb</span><span class="o">-&gt;</span><span class="n">ioasa</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ioasc</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ioasa</span><span class="o">-&gt;</span><span class="n">ioasc</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">masked_ioasc</span> <span class="o">=</span> <span class="n">ioasc</span> <span class="o">&amp;</span> <span class="n">PMCRAID_IOASC_SENSE_MASK</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sense_copied</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pmcraid_info</span><span class="p">(</span><span class="s">&quot;resource pointer is NULL</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If this was a SCSI read/write command keep count of errors */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">SCSI_CMD_TYPE</span><span class="p">(</span><span class="n">scsi_cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="n">SCSI_READ_CMD</span><span class="p">)</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">read_failures</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">SCSI_CMD_TYPE</span><span class="p">(</span><span class="n">scsi_cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="n">SCSI_WRITE_CMD</span><span class="p">)</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">write_failures</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">RES_IS_GSCSI</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">cfg_entry</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="n">masked_ioasc</span> <span class="o">!=</span> <span class="n">PMCRAID_IOASC_HW_DEVICE_BUS_STATUS_ERROR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pmcraid_frame_auto_sense</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Log IOASC/IOASA information based on user settings */</span>
	<span class="n">pmcraid_ioasc_logger</span><span class="p">(</span><span class="n">ioasc</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">masked_ioasc</span><span class="p">)</span> <span class="p">{</span>

	<span class="k">case</span> <span class="n">PMCRAID_IOASC_AC_TERMINATED_BY_HOST</span>:
		<span class="n">scsi_cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">|=</span> <span class="p">(</span><span class="n">DID_ABORT</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">PMCRAID_IOASC_IR_INVALID_RESOURCE_HANDLE</span>:
	<span class="k">case</span> <span class="n">PMCRAID_IOASC_HW_CANNOT_COMMUNICATE</span>:
		<span class="n">scsi_cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">|=</span> <span class="p">(</span><span class="n">DID_NO_CONNECT</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">PMCRAID_IOASC_NR_SYNC_REQUIRED</span>:
		<span class="n">res</span><span class="o">-&gt;</span><span class="n">sync_reqd</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">scsi_cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">|=</span> <span class="p">(</span><span class="n">DID_IMM_RETRY</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">PMCRAID_IOASC_ME_READ_ERROR_NO_REALLOC</span>:
		<span class="n">scsi_cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">|=</span> <span class="p">(</span><span class="n">DID_PASSTHROUGH</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">PMCRAID_IOASC_UA_BUS_WAS_RESET</span>:
	<span class="k">case</span> <span class="n">PMCRAID_IOASC_UA_BUS_WAS_RESET_BY_OTHER</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">reset_progress</span><span class="p">)</span>
			<span class="n">scsi_report_bus_reset</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span>
					      <span class="n">scsi_cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">);</span>
		<span class="n">scsi_cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">|=</span> <span class="p">(</span><span class="n">DID_ERROR</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">PMCRAID_IOASC_HW_DEVICE_BUS_STATUS_ERROR</span>:
		<span class="n">scsi_cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">|=</span> <span class="n">PMCRAID_IOASC_SENSE_STATUS</span><span class="p">(</span><span class="n">ioasc</span><span class="p">);</span>
		<span class="n">res</span><span class="o">-&gt;</span><span class="n">sync_reqd</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* if check_condition is not active return with error otherwise</span>
<span class="cm">		 * get/frame the sense buffer</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">PMCRAID_IOASC_SENSE_STATUS</span><span class="p">(</span><span class="n">ioasc</span><span class="p">)</span> <span class="o">!=</span>
		    <span class="n">SAM_STAT_CHECK_CONDITION</span> <span class="o">&amp;&amp;</span>
		    <span class="n">PMCRAID_IOASC_SENSE_STATUS</span><span class="p">(</span><span class="n">ioasc</span><span class="p">)</span> <span class="o">!=</span> <span class="n">SAM_STAT_ACA_ACTIVE</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* If we have auto sense data as part of IOASA pass it to</span>
<span class="cm">		 * mid-layer</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ioasa</span><span class="o">-&gt;</span><span class="n">auto_sense_length</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">short</span> <span class="n">sense_len</span> <span class="o">=</span> <span class="n">ioasa</span><span class="o">-&gt;</span><span class="n">auto_sense_length</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">data_size</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="n">u16</span><span class="p">,</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">sense_len</span><span class="p">),</span>
					      <span class="n">SCSI_SENSE_BUFFERSIZE</span><span class="p">);</span>

			<span class="n">memcpy</span><span class="p">(</span><span class="n">scsi_cmd</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">,</span>
			       <span class="n">ioasa</span><span class="o">-&gt;</span><span class="n">sense_data</span><span class="p">,</span>
			       <span class="n">data_size</span><span class="p">);</span>
			<span class="n">sense_copied</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">RES_IS_GSCSI</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">cfg_entry</span><span class="p">))</span>
			<span class="n">pmcraid_cancel_all</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">sense_copied</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sense_copied</span><span class="p">)</span>
			<span class="n">pmcraid_erp_done</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">pmcraid_request_sense</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>

		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">PMCRAID_IOASC_NR_INIT_CMD_REQUIRED</span>:
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">PMCRAID_IOASC_SENSE_KEY</span><span class="p">(</span><span class="n">ioasc</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">RECOVERED_ERROR</span><span class="p">)</span>
			<span class="n">scsi_cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">|=</span> <span class="p">(</span><span class="n">DID_ERROR</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_reset_device - device reset handler functions</span>
<span class="cm"> *</span>
<span class="cm"> * @scsi_cmd: scsi command struct</span>
<span class="cm"> * @modifier: reset modifier indicating the reset sequence to be performed</span>
<span class="cm"> *</span>
<span class="cm"> * This function issues a device reset to the affected device.</span>
<span class="cm"> * A LUN reset will be sent to the device first. If that does</span>
<span class="cm"> * not work, a target reset will be sent.</span>
<span class="cm"> *</span>
<span class="cm"> * Return value:</span>
<span class="cm"> *	SUCCESS / FAILED</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pmcraid_reset_device</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">scsi_cmd</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">,</span>
	<span class="n">u8</span> <span class="n">modifier</span>
<span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pmcraid_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pmcraid_resource_entry</span> <span class="o">*</span><span class="n">res</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pmcraid_ioarcb</span> <span class="o">*</span><span class="n">ioarcb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lock_flags</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ioasc</span><span class="p">;</span>

	<span class="n">pinstance</span> <span class="o">=</span>
		<span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="p">)</span><span class="n">scsi_cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">scsi_cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sdev_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">scsi_cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span>
			    <span class="s">&quot;reset_device: NULL resource pointer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">FAILED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If adapter is currently going through reset/reload, return failed.</span>
<span class="cm">	 * This will force the mid-layer to call _eh_bus/host reset, which</span>
<span class="cm">	 * will then go to sleep and wait for the reset to complete</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">lock_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ioa_reset_in_progress</span> <span class="o">||</span>
	    <span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ioa_state</span> <span class="o">==</span> <span class="n">IOA_STATE_DEAD</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">lock_flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">FAILED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">res</span><span class="o">-&gt;</span><span class="n">reset_progress</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">pmcraid_info</span><span class="p">(</span><span class="s">&quot;Resetting %s resource with addr %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="p">((</span><span class="n">modifier</span> <span class="o">&amp;</span> <span class="n">RESET_DEVICE_LUN</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;LUN&quot;</span> <span class="o">:</span>
		     <span class="p">((</span><span class="n">modifier</span> <span class="o">&amp;</span> <span class="n">RESET_DEVICE_TARGET</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;TARGET&quot;</span> <span class="o">:</span> <span class="s">&quot;BUS&quot;</span><span class="p">)),</span>
		     <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">cfg_entry</span><span class="p">.</span><span class="n">resource_address</span><span class="p">));</span>

	<span class="cm">/* get a free cmd block */</span>
	<span class="n">cmd</span> <span class="o">=</span> <span class="n">pmcraid_get_free_cmd</span><span class="p">(</span><span class="n">pinstance</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">lock_flags</span><span class="p">);</span>
		<span class="n">pmcraid_err</span><span class="p">(</span><span class="s">&quot;%s: no cmd blocks are available</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">FAILED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ioarcb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ioa_cb</span><span class="o">-&gt;</span><span class="n">ioarcb</span><span class="p">;</span>
	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">resource_handle</span> <span class="o">=</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">cfg_entry</span><span class="p">.</span><span class="n">resource_handle</span><span class="p">;</span>
	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">request_type</span> <span class="o">=</span> <span class="n">REQ_TYPE_IOACMD</span><span class="p">;</span>
	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">cdb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">PMCRAID_RESET_DEVICE</span><span class="p">;</span>

	<span class="cm">/* Initialize reset modifier bits */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">modifier</span><span class="p">)</span>
		<span class="n">modifier</span> <span class="o">=</span> <span class="n">ENABLE_RESET_MODIFIER</span> <span class="o">|</span> <span class="n">modifier</span><span class="p">;</span>

	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">cdb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">modifier</span><span class="p">;</span>

	<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">wait_for_completion</span><span class="p">);</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">completion_req</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">pmcraid_info</span><span class="p">(</span><span class="s">&quot;cmd(CDB[0] = %x) for %x with index = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ioa_cb</span><span class="o">-&gt;</span><span class="n">ioarcb</span><span class="p">.</span><span class="n">cdb</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
		     <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ioa_cb</span><span class="o">-&gt;</span><span class="n">ioarcb</span><span class="p">.</span><span class="n">resource_handle</span><span class="p">),</span>
		     <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ioa_cb</span><span class="o">-&gt;</span><span class="n">ioarcb</span><span class="p">.</span><span class="n">response_handle</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">);</span>

	<span class="n">pmcraid_send_cmd</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span>
			 <span class="n">pmcraid_internal_done</span><span class="p">,</span>
			 <span class="n">timeout</span><span class="p">,</span>
			 <span class="n">pmcraid_timeout_handler</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">lock_flags</span><span class="p">);</span>

	<span class="cm">/* RESET_DEVICE command completes after all pending IOARCBs are</span>
<span class="cm">	 * completed. Once this command is completed, pmcraind_internal_done</span>
<span class="cm">	 * will wake up the &#39;completion&#39; queue.</span>
<span class="cm">	 */</span>
	<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">wait_for_completion</span><span class="p">);</span>

	<span class="cm">/* complete the command here itself and return the command block</span>
<span class="cm">	 * to free list</span>
<span class="cm">	 */</span>
	<span class="n">pmcraid_return_cmd</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="n">res</span><span class="o">-&gt;</span><span class="n">reset_progress</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ioasc</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ioa_cb</span><span class="o">-&gt;</span><span class="n">ioasa</span><span class="p">.</span><span class="n">ioasc</span><span class="p">);</span>

	<span class="cm">/* set the return value based on the returned ioasc */</span>
	<span class="k">return</span> <span class="n">PMCRAID_IOASC_SENSE_KEY</span><span class="p">(</span><span class="n">ioasc</span><span class="p">)</span> <span class="o">?</span> <span class="n">FAILED</span> <span class="o">:</span> <span class="n">SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * _pmcraid_io_done - helper for pmcraid_io_done function</span>
<span class="cm"> *</span>
<span class="cm"> * @cmd: pointer to pmcraid command struct</span>
<span class="cm"> * @reslen: residual data length to be set in the ioasa</span>
<span class="cm"> * @ioasc: ioasc either returned by IOA or set by driver itself.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is invoked by pmcraid_io_done to complete mid-layer</span>
<span class="cm"> * scsi ops.</span>
<span class="cm"> *</span>
<span class="cm"> * Return value:</span>
<span class="cm"> *	  0 if caller is required to return it to free_pool. Returns 1 if</span>
<span class="cm"> *	  caller need not worry about freeing command block as error handler</span>
<span class="cm"> *	  will take care of that.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">_pmcraid_io_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reslen</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ioasc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">scsi_cmd</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_cmd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">scsi_set_resid</span><span class="p">(</span><span class="n">scsi_cmd</span><span class="p">,</span> <span class="n">reslen</span><span class="p">);</span>

	<span class="n">pmcraid_info</span><span class="p">(</span><span class="s">&quot;response(%d) CDB[0] = %x ioasc:result: %x:%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ioa_cb</span><span class="o">-&gt;</span><span class="n">ioarcb</span><span class="p">.</span><span class="n">response_handle</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">,</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ioa_cb</span><span class="o">-&gt;</span><span class="n">ioarcb</span><span class="p">.</span><span class="n">cdb</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
		<span class="n">ioasc</span><span class="p">,</span> <span class="n">scsi_cmd</span><span class="o">-&gt;</span><span class="n">result</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">PMCRAID_IOASC_SENSE_KEY</span><span class="p">(</span><span class="n">ioasc</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">pmcraid_error_handler</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">scsi_dma_unmap</span><span class="p">(</span><span class="n">scsi_cmd</span><span class="p">);</span>
		<span class="n">scsi_cmd</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">(</span><span class="n">scsi_cmd</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_io_done - SCSI completion function</span>
<span class="cm"> *</span>
<span class="cm"> * @cmd: pointer to pmcraid command struct</span>
<span class="cm"> *</span>
<span class="cm"> * This function is invoked by tasklet/mid-layer error handler to completing</span>
<span class="cm"> * the SCSI ops sent from mid-layer.</span>
<span class="cm"> *</span>
<span class="cm"> * Return value</span>
<span class="cm"> *	  none</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pmcraid_io_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">ioasc</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ioa_cb</span><span class="o">-&gt;</span><span class="n">ioasa</span><span class="p">.</span><span class="n">ioasc</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">reslen</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ioa_cb</span><span class="o">-&gt;</span><span class="n">ioasa</span><span class="p">.</span><span class="n">residual_data_length</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">_pmcraid_io_done</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">reslen</span><span class="p">,</span> <span class="n">ioasc</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">pmcraid_return_cmd</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_abort_cmd - Aborts a single IOARCB already submitted to IOA</span>
<span class="cm"> *</span>
<span class="cm"> * @cmd: command block of the command to be aborted</span>
<span class="cm"> *</span>
<span class="cm"> * Return Value:</span>
<span class="cm"> *	 returns pointer to command structure used as cancelling cmd</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">pmcraid_cmd</span> <span class="o">*</span><span class="nf">pmcraid_abort_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pmcraid_cmd</span> <span class="o">*</span><span class="n">cancel_cmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pmcraid_resource_entry</span> <span class="o">*</span><span class="n">res</span><span class="p">;</span>

	<span class="n">pinstance</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="p">)</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">drv_inst</span><span class="p">;</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>

	<span class="n">cancel_cmd</span> <span class="o">=</span> <span class="n">pmcraid_get_free_cmd</span><span class="p">(</span><span class="n">pinstance</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cancel_cmd</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pmcraid_err</span><span class="p">(</span><span class="s">&quot;%s: no cmd blocks are available</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pmcraid_prepare_cancel_cmd</span><span class="p">(</span><span class="n">cancel_cmd</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>

	<span class="n">pmcraid_info</span><span class="p">(</span><span class="s">&quot;aborting command CDB[0]= %x with index = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ioa_cb</span><span class="o">-&gt;</span><span class="n">ioarcb</span><span class="p">.</span><span class="n">cdb</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ioa_cb</span><span class="o">-&gt;</span><span class="n">ioarcb</span><span class="p">.</span><span class="n">response_handle</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">);</span>

	<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cancel_cmd</span><span class="o">-&gt;</span><span class="n">wait_for_completion</span><span class="p">);</span>
	<span class="n">cancel_cmd</span><span class="o">-&gt;</span><span class="n">completion_req</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">pmcraid_info</span><span class="p">(</span><span class="s">&quot;command (%d) CDB[0] = %x for %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">cancel_cmd</span><span class="o">-&gt;</span><span class="n">ioa_cb</span><span class="o">-&gt;</span><span class="n">ioarcb</span><span class="p">.</span><span class="n">response_handle</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">,</span>
		<span class="n">cancel_cmd</span><span class="o">-&gt;</span><span class="n">ioa_cb</span><span class="o">-&gt;</span><span class="n">ioarcb</span><span class="p">.</span><span class="n">cdb</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
		<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">cancel_cmd</span><span class="o">-&gt;</span><span class="n">ioa_cb</span><span class="o">-&gt;</span><span class="n">ioarcb</span><span class="p">.</span><span class="n">resource_handle</span><span class="p">));</span>

	<span class="n">pmcraid_send_cmd</span><span class="p">(</span><span class="n">cancel_cmd</span><span class="p">,</span>
			 <span class="n">pmcraid_internal_done</span><span class="p">,</span>
			 <span class="n">PMCRAID_INTERNAL_TIMEOUT</span><span class="p">,</span>
			 <span class="n">pmcraid_timeout_handler</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">cancel_cmd</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_abort_complete - Waits for ABORT TASK completion</span>
<span class="cm"> *</span>
<span class="cm"> * @cancel_cmd: command block use as cancelling command</span>
<span class="cm"> *</span>
<span class="cm"> * Return Value:</span>
<span class="cm"> *	 returns SUCCESS if ABORT TASK has good completion</span>
<span class="cm"> *	 otherwise FAILED</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pmcraid_abort_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_cmd</span> <span class="o">*</span><span class="n">cancel_cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pmcraid_resource_entry</span> <span class="o">*</span><span class="n">res</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ioasc</span><span class="p">;</span>

	<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cancel_cmd</span><span class="o">-&gt;</span><span class="n">wait_for_completion</span><span class="p">);</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">cancel_cmd</span><span class="o">-&gt;</span><span class="n">res</span><span class="p">;</span>
	<span class="n">cancel_cmd</span><span class="o">-&gt;</span><span class="n">res</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ioasc</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">cancel_cmd</span><span class="o">-&gt;</span><span class="n">ioa_cb</span><span class="o">-&gt;</span><span class="n">ioasa</span><span class="p">.</span><span class="n">ioasc</span><span class="p">);</span>

	<span class="cm">/* If the abort task is not timed out we will get a Good completion</span>
<span class="cm">	 * as sense_key, otherwise we may get one the following responses</span>
<span class="cm">	 * due to subsequent bus reset or device reset. In case IOASC is</span>
<span class="cm">	 * NR_SYNC_REQUIRED, set sync_reqd flag for the corresponding resource</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ioasc</span> <span class="o">==</span> <span class="n">PMCRAID_IOASC_UA_BUS_WAS_RESET</span> <span class="o">||</span>
	    <span class="n">ioasc</span> <span class="o">==</span> <span class="n">PMCRAID_IOASC_NR_SYNC_REQUIRED</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ioasc</span> <span class="o">==</span> <span class="n">PMCRAID_IOASC_NR_SYNC_REQUIRED</span><span class="p">)</span>
			<span class="n">res</span><span class="o">-&gt;</span><span class="n">sync_reqd</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">ioasc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* complete the command here itself */</span>
	<span class="n">pmcraid_return_cmd</span><span class="p">(</span><span class="n">cancel_cmd</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">PMCRAID_IOASC_SENSE_KEY</span><span class="p">(</span><span class="n">ioasc</span><span class="p">)</span> <span class="o">?</span> <span class="n">FAILED</span> <span class="o">:</span> <span class="n">SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_eh_abort_handler - entry point for aborting a single task on errors</span>
<span class="cm"> *</span>
<span class="cm"> * @scsi_cmd:   scsi command struct given by mid-layer. When this is called</span>
<span class="cm"> *		mid-layer ensures that no other commands are queued. This</span>
<span class="cm"> *		never gets called under interrupt, but a separate eh thread.</span>
<span class="cm"> *</span>
<span class="cm"> * Return value:</span>
<span class="cm"> *	 SUCCESS / FAILED</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pmcraid_eh_abort_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">scsi_cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pmcraid_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pmcraid_resource_entry</span> <span class="o">*</span><span class="n">res</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">host_lock_flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pending_lock_flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pmcraid_cmd</span> <span class="o">*</span><span class="n">cancel_cmd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cmd_found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">FAILED</span><span class="p">;</span>

	<span class="n">pinstance</span> <span class="o">=</span>
		<span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="p">)</span><span class="n">scsi_cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>

	<span class="n">scmd_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">scsi_cmd</span><span class="p">,</span>
		    <span class="s">&quot;I/O command timed out, aborting it.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">res</span> <span class="o">=</span> <span class="n">scsi_cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* If we are currently going through reset/reload, return failed.</span>
<span class="cm">	 * This will force the mid-layer to eventually call</span>
<span class="cm">	 * pmcraid_eh_host_reset which will then go to sleep and wait for the</span>
<span class="cm">	 * reset to complete</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">host_lock_flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ioa_reset_in_progress</span> <span class="o">||</span>
	    <span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ioa_state</span> <span class="o">==</span> <span class="n">IOA_STATE_DEAD</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span>
				       <span class="n">host_lock_flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* loop over pending cmd list to find cmd corresponding to this</span>
<span class="cm">	 * scsi_cmd. Note that this command might not have been completed</span>
<span class="cm">	 * already. locking: all pending commands are protected with</span>
<span class="cm">	 * pending_pool_lock.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">pending_pool_lock</span><span class="p">,</span> <span class="n">pending_lock_flags</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">pending_cmd_pool</span><span class="p">,</span> <span class="n">free_list</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_cmd</span> <span class="o">==</span> <span class="n">scsi_cmd</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cmd_found</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">pending_pool_lock</span><span class="p">,</span>
				<span class="n">pending_lock_flags</span><span class="p">);</span>

	<span class="cm">/* If the command to be aborted was given to IOA and still pending with</span>
<span class="cm">	 * it, send ABORT_TASK to abort this and wait for its completion</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd_found</span><span class="p">)</span>
		<span class="n">cancel_cmd</span> <span class="o">=</span> <span class="n">pmcraid_abort_cmd</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span>
			       <span class="n">host_lock_flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cancel_cmd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cancel_cmd</span><span class="o">-&gt;</span><span class="n">res</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">pmcraid_abort_complete</span><span class="p">(</span><span class="n">cancel_cmd</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">cmd_found</span> <span class="o">?</span> <span class="n">rc</span> <span class="o">:</span> <span class="n">SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_eh_xxxx_reset_handler - bus/target/device reset handler callbacks</span>
<span class="cm"> *</span>
<span class="cm"> * @scmd: pointer to scsi_cmd that was sent to the resource to be reset.</span>
<span class="cm"> *</span>
<span class="cm"> * All these routines invokve pmcraid_reset_device with appropriate parameters.</span>
<span class="cm"> * Since these are called from mid-layer EH thread, no other IO will be queued</span>
<span class="cm"> * to the resource being reset. However, control path (IOCTL) may be active so</span>
<span class="cm"> * it is necessary to synchronize IOARRIN writes which pmcraid_reset_device</span>
<span class="cm"> * takes care by locking/unlocking host_lock.</span>
<span class="cm"> *</span>
<span class="cm"> * Return value</span>
<span class="cm"> *	SUCCESS or FAILED</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pmcraid_eh_device_reset_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">scmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">scmd_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">scmd</span><span class="p">,</span>
		    <span class="s">&quot;resetting device due to an I/O command timeout.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">pmcraid_reset_device</span><span class="p">(</span><span class="n">scmd</span><span class="p">,</span>
				    <span class="n">PMCRAID_INTERNAL_TIMEOUT</span><span class="p">,</span>
				    <span class="n">RESET_DEVICE_LUN</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pmcraid_eh_bus_reset_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">scmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">scmd_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">scmd</span><span class="p">,</span>
		    <span class="s">&quot;Doing bus reset due to an I/O command timeout.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">pmcraid_reset_device</span><span class="p">(</span><span class="n">scmd</span><span class="p">,</span>
				    <span class="n">PMCRAID_RESET_BUS_TIMEOUT</span><span class="p">,</span>
				    <span class="n">RESET_DEVICE_BUS</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pmcraid_eh_target_reset_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">scmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">scmd_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">scmd</span><span class="p">,</span>
		    <span class="s">&quot;Doing target reset due to an I/O command timeout.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">pmcraid_reset_device</span><span class="p">(</span><span class="n">scmd</span><span class="p">,</span>
				    <span class="n">PMCRAID_INTERNAL_TIMEOUT</span><span class="p">,</span>
				    <span class="n">RESET_DEVICE_TARGET</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_eh_host_reset_handler - adapter reset handler callback</span>
<span class="cm"> *</span>
<span class="cm"> * @scmd: pointer to scsi_cmd that was sent to a resource of adapter</span>
<span class="cm"> *</span>
<span class="cm"> * Initiates adapter reset to bring it up to operational state</span>
<span class="cm"> *</span>
<span class="cm"> * Return value</span>
<span class="cm"> *	SUCCESS or FAILED</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pmcraid_eh_host_reset_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">scmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">interval</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">;</span> <span class="cm">/* 10 seconds interval */</span>
	<span class="kt">int</span> <span class="n">waits</span> <span class="o">=</span> <span class="n">jiffies_to_msecs</span><span class="p">(</span><span class="n">PMCRAID_RESET_HOST_TIMEOUT</span><span class="p">)</span> <span class="o">/</span> <span class="n">interval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span> <span class="o">=</span>
		<span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="p">)(</span><span class="n">scmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">);</span>


	<span class="cm">/* wait for an additional 150 seconds just in case firmware could come</span>
<span class="cm">	 * up and if it could complete all the pending commands excluding the</span>
<span class="cm">	 * two HCAM (CCN and LDN).</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">waits</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">outstanding_cmds</span><span class="p">)</span> <span class="o">&lt;=</span>
		    <span class="n">PMCRAID_MAX_HCAM_CMD</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">SUCCESS</span><span class="p">;</span>
		<span class="n">msleep</span><span class="p">(</span><span class="n">interval</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;Adapter being reset due to an I/O command timeout.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">pmcraid_reset_bringup</span><span class="p">(</span><span class="n">pinstance</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">SUCCESS</span> <span class="o">:</span> <span class="n">FAILED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_task_attributes - Translate SPI Q-Tags to task attributes</span>
<span class="cm"> * @scsi_cmd:   scsi command struct</span>
<span class="cm"> *</span>
<span class="cm"> * Return value</span>
<span class="cm"> *	  number of tags or 0 if the task is not tagged</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u8</span> <span class="nf">pmcraid_task_attributes</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">scsi_cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">tag</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">scsi_populate_tag_msg</span><span class="p">(</span><span class="n">scsi_cmd</span><span class="p">,</span> <span class="n">tag</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">tag</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">MSG_SIMPLE_TAG</span>:
			<span class="n">rc</span> <span class="o">=</span> <span class="n">TASK_TAG_SIMPLE</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">MSG_HEAD_TAG</span>:
			<span class="n">rc</span> <span class="o">=</span> <span class="n">TASK_TAG_QUEUE_HEAD</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">MSG_ORDERED_TAG</span>:
			<span class="n">rc</span> <span class="o">=</span> <span class="n">TASK_TAG_ORDERED</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">};</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * pmcraid_init_ioadls - initializes IOADL related fields in IOARCB</span>
<span class="cm"> * @cmd: pmcraid command struct</span>
<span class="cm"> * @sgcount: count of scatter-gather elements</span>
<span class="cm"> *</span>
<span class="cm"> * Return value</span>
<span class="cm"> *   returns pointer pmcraid_ioadl_desc, initialized to point to internal</span>
<span class="cm"> *   or external IOADLs</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">pmcraid_ioadl_desc</span> <span class="o">*</span>
<span class="nf">pmcraid_init_ioadls</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sgcount</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pmcraid_ioadl_desc</span> <span class="o">*</span><span class="n">ioadl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pmcraid_ioarcb</span> <span class="o">*</span><span class="n">ioarcb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ioa_cb</span><span class="o">-&gt;</span><span class="n">ioarcb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ioadl_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">add_cmd_param_length</span><span class="p">)</span>
		<span class="n">ioadl_count</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">add_cmd_param_length</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">ioadl_length</span> <span class="o">=</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_ioadl_desc</span><span class="p">)</span> <span class="o">*</span> <span class="n">sgcount</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">sgcount</span> <span class="o">+</span> <span class="n">ioadl_count</span><span class="p">)</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">add_data</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">ioadl</span><span class="p">)))</span> <span class="p">{</span>
		<span class="cm">/* external ioadls start at offset 0x80 from control_block</span>
<span class="cm">		 * structure, re-using 24 out of 27 ioadls part of IOARCB.</span>
<span class="cm">		 * It is necessary to indicate to firmware that driver is</span>
<span class="cm">		 * using ioadls to be treated as external to IOARCB.</span>
<span class="cm">		 */</span>
		<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">ioarcb_bus_addr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mh">0x1FULL</span><span class="p">);</span>
		<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">ioadl_bus_addr</span> <span class="o">=</span>
			<span class="n">cpu_to_le64</span><span class="p">((</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ioa_cb_bus_addr</span><span class="p">)</span> <span class="o">+</span>
				<span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_ioarcb</span><span class="p">,</span>
					<span class="n">add_data</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">ioadl</span><span class="p">[</span><span class="mi">3</span><span class="p">]));</span>
		<span class="n">ioadl</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">add_data</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">ioadl</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">ioadl_bus_addr</span> <span class="o">=</span>
			<span class="n">cpu_to_le64</span><span class="p">((</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ioa_cb_bus_addr</span><span class="p">)</span> <span class="o">+</span>
				<span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_ioarcb</span><span class="p">,</span>
					<span class="n">add_data</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">ioadl</span><span class="p">[</span><span class="n">ioadl_count</span><span class="p">]));</span>

		<span class="n">ioadl</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">add_data</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">ioadl</span><span class="p">[</span><span class="n">ioadl_count</span><span class="p">];</span>
		<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">ioarcb_bus_addr</span> <span class="o">|=</span>
				<span class="n">DIV_ROUND_CLOSEST</span><span class="p">(</span><span class="n">sgcount</span> <span class="o">+</span> <span class="n">ioadl_count</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ioadl</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_build_ioadl - Build a scatter/gather list and map the buffer</span>
<span class="cm"> * @pinstance: pointer to adapter instance structure</span>
<span class="cm"> * @cmd: pmcraid command struct</span>
<span class="cm"> *</span>
<span class="cm"> * This function is invoked by queuecommand entry point while sending a command</span>
<span class="cm"> * to firmware. This builds ioadl descriptors and sets up ioarcb fields.</span>
<span class="cm"> *</span>
<span class="cm"> * Return value:</span>
<span class="cm"> *	0 on success or -1 on failure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pmcraid_build_ioadl</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">pmcraid_cmd</span> <span class="o">*</span><span class="n">cmd</span>
<span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">nseg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sglist</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">scsi_cmd</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_cmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pmcraid_ioarcb</span> <span class="o">*</span><span class="n">ioarcb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ioa_cb</span><span class="o">-&gt;</span><span class="n">ioarcb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pmcraid_ioadl_desc</span> <span class="o">*</span><span class="n">ioadl</span> <span class="o">=</span> <span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">add_data</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">ioadl</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">length</span> <span class="o">=</span> <span class="n">scsi_bufflen</span><span class="p">(</span><span class="n">scsi_cmd</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">length</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">nseg</span> <span class="o">=</span> <span class="n">scsi_dma_map</span><span class="p">(</span><span class="n">scsi_cmd</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nseg</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">scmd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">scsi_cmd</span><span class="p">,</span> <span class="s">&quot;scsi_map_dma failed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">nseg</span> <span class="o">&gt;</span> <span class="n">PMCRAID_MAX_IOADLS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">scsi_dma_unmap</span><span class="p">(</span><span class="n">scsi_cmd</span><span class="p">);</span>
		<span class="n">scmd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">scsi_cmd</span><span class="p">,</span>
			<span class="s">&quot;sg count is (%d) more than allowed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">nseg</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Initialize IOARCB data transfer length fields */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">scsi_cmd</span><span class="o">-&gt;</span><span class="n">sc_data_direction</span> <span class="o">==</span> <span class="n">DMA_TO_DEVICE</span><span class="p">)</span>
		<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">request_flags0</span> <span class="o">|=</span> <span class="n">TRANSFER_DIR_WRITE</span><span class="p">;</span>

	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">request_flags0</span> <span class="o">|=</span> <span class="n">NO_LINK_DESCS</span><span class="p">;</span>
	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">data_transfer_length</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">length</span><span class="p">);</span>
	<span class="n">ioadl</span> <span class="o">=</span> <span class="n">pmcraid_init_ioadls</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">nseg</span><span class="p">);</span>

	<span class="cm">/* Initialize IOADL descriptor addresses */</span>
	<span class="n">scsi_for_each_sg</span><span class="p">(</span><span class="n">scsi_cmd</span><span class="p">,</span> <span class="n">sglist</span><span class="p">,</span> <span class="n">nseg</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ioadl</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">data_len</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">sg_dma_len</span><span class="p">(</span><span class="n">sglist</span><span class="p">));</span>
		<span class="n">ioadl</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">address</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">sg_dma_address</span><span class="p">(</span><span class="n">sglist</span><span class="p">));</span>
		<span class="n">ioadl</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* setup last descriptor */</span>
	<span class="n">ioadl</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">flags</span> <span class="o">=</span> <span class="n">IOADL_FLAGS_LAST_DESC</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_free_sglist - Frees an allocated SG buffer list</span>
<span class="cm"> * @sglist: scatter/gather list pointer</span>
<span class="cm"> *</span>
<span class="cm"> * Free a DMA&#39;able memory previously allocated with pmcraid_alloc_sglist</span>
<span class="cm"> *</span>
<span class="cm"> * Return value:</span>
<span class="cm"> *	none</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pmcraid_free_sglist</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_sglist</span> <span class="o">*</span><span class="n">sglist</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sglist</span><span class="o">-&gt;</span><span class="n">num_sg</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">__free_pages</span><span class="p">(</span><span class="n">sg_page</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">sglist</span><span class="o">-&gt;</span><span class="n">scatterlist</span><span class="p">[</span><span class="n">i</span><span class="p">])),</span>
			     <span class="n">sglist</span><span class="o">-&gt;</span><span class="n">order</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">sglist</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_alloc_sglist - Allocates memory for a SG list</span>
<span class="cm"> * @buflen: buffer length</span>
<span class="cm"> *</span>
<span class="cm"> * Allocates a DMA&#39;able buffer in chunks and assembles a scatter/gather</span>
<span class="cm"> * list.</span>
<span class="cm"> *</span>
<span class="cm"> * Return value</span>
<span class="cm"> *	pointer to sglist / NULL on failure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">pmcraid_sglist</span> <span class="o">*</span><span class="nf">pmcraid_alloc_sglist</span><span class="p">(</span><span class="kt">int</span> <span class="n">buflen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pmcraid_sglist</span> <span class="o">*</span><span class="n">sglist</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">scatterlist</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_elem</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sg_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">order</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bsize_elem</span><span class="p">;</span>

	<span class="n">sg_size</span> <span class="o">=</span> <span class="n">buflen</span> <span class="o">/</span> <span class="p">(</span><span class="n">PMCRAID_MAX_IOADLS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">order</span> <span class="o">=</span> <span class="p">(</span><span class="n">sg_size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="n">get_order</span><span class="p">(</span><span class="n">sg_size</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bsize_elem</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">order</span><span class="p">);</span>

	<span class="cm">/* Determine the actual number of sg entries needed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buflen</span> <span class="o">%</span> <span class="n">bsize_elem</span><span class="p">)</span>
		<span class="n">num_elem</span> <span class="o">=</span> <span class="p">(</span><span class="n">buflen</span> <span class="o">/</span> <span class="n">bsize_elem</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">num_elem</span> <span class="o">=</span> <span class="n">buflen</span> <span class="o">/</span> <span class="n">bsize_elem</span><span class="p">;</span>

	<span class="cm">/* Allocate a scatter/gather list for the DMA */</span>
	<span class="n">sglist</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_sglist</span><span class="p">)</span> <span class="o">+</span>
			 <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">scatterlist</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">num_elem</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)),</span>
			 <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sglist</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">scatterlist</span> <span class="o">=</span> <span class="n">sglist</span><span class="o">-&gt;</span><span class="n">scatterlist</span><span class="p">;</span>
	<span class="n">sg_init_table</span><span class="p">(</span><span class="n">scatterlist</span><span class="p">,</span> <span class="n">num_elem</span><span class="p">);</span>
	<span class="n">sglist</span><span class="o">-&gt;</span><span class="n">order</span> <span class="o">=</span> <span class="n">order</span><span class="p">;</span>
	<span class="n">sglist</span><span class="o">-&gt;</span><span class="n">num_sg</span> <span class="o">=</span> <span class="n">num_elem</span><span class="p">;</span>
	<span class="n">sg_size</span> <span class="o">=</span> <span class="n">buflen</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_elem</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">alloc_pages</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="o">|</span><span class="n">GFP_DMA</span><span class="o">|</span><span class="n">__GFP_ZERO</span><span class="p">,</span> <span class="n">order</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">--</span><span class="p">)</span>
				<span class="n">__free_pages</span><span class="p">(</span><span class="n">sg_page</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scatterlist</span><span class="p">[</span><span class="n">j</span><span class="p">]),</span> <span class="n">order</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">sglist</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">sg_set_page</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scatterlist</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">page</span><span class="p">,</span>
			<span class="n">sg_size</span> <span class="o">&lt;</span> <span class="n">bsize_elem</span> <span class="o">?</span> <span class="n">sg_size</span> <span class="o">:</span> <span class="n">bsize_elem</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">sg_size</span> <span class="o">-=</span> <span class="n">bsize_elem</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">sglist</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_copy_sglist - Copy user buffer to kernel buffer&#39;s SG list</span>
<span class="cm"> * @sglist: scatter/gather list pointer</span>
<span class="cm"> * @buffer: buffer pointer</span>
<span class="cm"> * @len: buffer length</span>
<span class="cm"> * @direction: data transfer direction</span>
<span class="cm"> *</span>
<span class="cm"> * Copy a user buffer into a buffer allocated by pmcraid_alloc_sglist</span>
<span class="cm"> *</span>
<span class="cm"> * Return value:</span>
<span class="cm"> * 0 on success / other on failure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pmcraid_copy_sglist</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">pmcraid_sglist</span> <span class="o">*</span><span class="n">sglist</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">buffer</span><span class="p">,</span>
	<span class="n">u32</span> <span class="n">len</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">direction</span>
<span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">scatterlist</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">kaddr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bsize_elem</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Determine the actual number of bytes per element */</span>
	<span class="n">bsize_elem</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">sglist</span><span class="o">-&gt;</span><span class="n">order</span><span class="p">);</span>

	<span class="n">scatterlist</span> <span class="o">=</span> <span class="n">sglist</span><span class="o">-&gt;</span><span class="n">scatterlist</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">len</span> <span class="o">/</span> <span class="n">bsize_elem</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">buffer</span> <span class="o">+=</span> <span class="n">bsize_elem</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">sg_page</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scatterlist</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

		<span class="n">kaddr</span> <span class="o">=</span> <span class="n">kmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">direction</span> <span class="o">==</span> <span class="n">DMA_TO_DEVICE</span><span class="p">)</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">__copy_from_user</span><span class="p">(</span><span class="n">kaddr</span><span class="p">,</span>
					      <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">buffer</span><span class="p">,</span>
					      <span class="n">bsize_elem</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">__copy_to_user</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">buffer</span><span class="p">,</span> <span class="n">kaddr</span><span class="p">,</span> <span class="n">bsize_elem</span><span class="p">);</span>

		<span class="n">kunmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pmcraid_err</span><span class="p">(</span><span class="s">&quot;failed to copy user data into sg list</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">scatterlist</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">length</span> <span class="o">=</span> <span class="n">bsize_elem</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">%</span> <span class="n">bsize_elem</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">sg_page</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scatterlist</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

		<span class="n">kaddr</span> <span class="o">=</span> <span class="n">kmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">direction</span> <span class="o">==</span> <span class="n">DMA_TO_DEVICE</span><span class="p">)</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">__copy_from_user</span><span class="p">(</span><span class="n">kaddr</span><span class="p">,</span>
					      <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">buffer</span><span class="p">,</span>
					      <span class="n">len</span> <span class="o">%</span> <span class="n">bsize_elem</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">__copy_to_user</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">buffer</span><span class="p">,</span>
					    <span class="n">kaddr</span><span class="p">,</span>
					    <span class="n">len</span> <span class="o">%</span> <span class="n">bsize_elem</span><span class="p">);</span>

		<span class="n">kunmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

		<span class="n">scatterlist</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">length</span> <span class="o">=</span> <span class="n">len</span> <span class="o">%</span> <span class="n">bsize_elem</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pmcraid_err</span><span class="p">(</span><span class="s">&quot;failed to copy user data into sg list</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_queuecommand - Queue a mid-layer request</span>
<span class="cm"> * @scsi_cmd: scsi command struct</span>
<span class="cm"> * @done: done function</span>
<span class="cm"> *</span>
<span class="cm"> * This function queues a request generated by the mid-layer. Midlayer calls</span>
<span class="cm"> * this routine within host-&gt;lock. Some of the functions called by queuecommand</span>
<span class="cm"> * would use cmd block queue locks (free_pool_lock and pending_pool_lock)</span>
<span class="cm"> *</span>
<span class="cm"> * Return value:</span>
<span class="cm"> *	  0 on success</span>
<span class="cm"> *	  SCSI_MLQUEUE_DEVICE_BUSY if device is busy</span>
<span class="cm"> *	  SCSI_MLQUEUE_HOST_BUSY if host is busy</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pmcraid_queuecommand_lck</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">scsi_cmd</span><span class="p">,</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">done</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="p">)</span>
<span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pmcraid_resource_entry</span> <span class="o">*</span><span class="n">res</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pmcraid_ioarcb</span> <span class="o">*</span><span class="n">ioarcb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pmcraid_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">fw_version</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pinstance</span> <span class="o">=</span>
		<span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="p">)</span><span class="n">scsi_cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="n">fw_version</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">inq_data</span><span class="o">-&gt;</span><span class="n">fw_version</span><span class="p">);</span>
	<span class="n">scsi_cmd</span><span class="o">-&gt;</span><span class="n">scsi_done</span> <span class="o">=</span> <span class="n">done</span><span class="p">;</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">scsi_cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="n">scsi_cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DID_OK</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>

	<span class="cm">/* if adapter is marked as dead, set result to DID_NO_CONNECT complete</span>
<span class="cm">	 * the command</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ioa_state</span> <span class="o">==</span> <span class="n">IOA_STATE_DEAD</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pmcraid_info</span><span class="p">(</span><span class="s">&quot;IOA is dead, but queuecommand is scheduled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">scsi_cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DID_NO_CONNECT</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
		<span class="n">scsi_cmd</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">(</span><span class="n">scsi_cmd</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If IOA reset is in progress, can&#39;t queue the commands */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ioa_reset_in_progress</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">SCSI_MLQUEUE_HOST_BUSY</span><span class="p">;</span>

	<span class="cm">/* Firmware doesn&#39;t support SYNCHRONIZE_CACHE command (0x35), complete</span>
<span class="cm">	 * the command here itself with success return</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">scsi_cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">SYNCHRONIZE_CACHE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pmcraid_info</span><span class="p">(</span><span class="s">&quot;SYNC_CACHE(0x35), completing in driver itself</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">scsi_cmd</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">(</span><span class="n">scsi_cmd</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* initialize the command and IOARCB to be sent to IOA */</span>
	<span class="n">cmd</span> <span class="o">=</span> <span class="n">pmcraid_get_free_cmd</span><span class="p">(</span><span class="n">pinstance</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pmcraid_err</span><span class="p">(</span><span class="s">&quot;free command block is not available</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">SCSI_MLQUEUE_HOST_BUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_cmd</span> <span class="o">=</span> <span class="n">scsi_cmd</span><span class="p">;</span>
	<span class="n">ioarcb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ioa_cb</span><span class="o">-&gt;</span><span class="n">ioarcb</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">cdb</span><span class="p">,</span> <span class="n">scsi_cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">,</span> <span class="n">scsi_cmd</span><span class="o">-&gt;</span><span class="n">cmd_len</span><span class="p">);</span>
	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">resource_handle</span> <span class="o">=</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">cfg_entry</span><span class="p">.</span><span class="n">resource_handle</span><span class="p">;</span>
	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">request_type</span> <span class="o">=</span> <span class="n">REQ_TYPE_SCSI</span><span class="p">;</span>

	<span class="cm">/* set hrrq number where the IOA should respond to. Note that all cmds</span>
<span class="cm">	 * generated internally uses hrrq_id 0, exception to this is the cmd</span>
<span class="cm">	 * block of scsi_cmd which is re-used (e.g. cancel/abort), which uses</span>
<span class="cm">	 * hrrq_id assigned here in queuecommand</span>
<span class="cm">	 */</span>
	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">hrrq_id</span> <span class="o">=</span> <span class="n">atomic_add_return</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">last_message_id</span><span class="p">))</span> <span class="o">%</span>
			  <span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">num_hrrq</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmd_done</span> <span class="o">=</span> <span class="n">pmcraid_io_done</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">RES_IS_GSCSI</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">cfg_entry</span><span class="p">)</span> <span class="o">||</span> <span class="n">RES_IS_VSET</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">cfg_entry</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">scsi_cmd</span><span class="o">-&gt;</span><span class="n">underflow</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">request_flags0</span> <span class="o">|=</span> <span class="n">INHIBIT_UL_CHECK</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">sync_reqd</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">request_flags0</span> <span class="o">|=</span> <span class="n">SYNC_COMPLETE</span><span class="p">;</span>
			<span class="n">res</span><span class="o">-&gt;</span><span class="n">sync_reqd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">request_flags0</span> <span class="o">|=</span> <span class="n">NO_LINK_DESCS</span><span class="p">;</span>
		<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">request_flags1</span> <span class="o">|=</span> <span class="n">pmcraid_task_attributes</span><span class="p">(</span><span class="n">scsi_cmd</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">RES_IS_GSCSI</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">cfg_entry</span><span class="p">))</span>
			<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">request_flags1</span> <span class="o">|=</span> <span class="n">DELAY_AFTER_RESET</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">pmcraid_build_ioadl</span><span class="p">(</span><span class="n">pinstance</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>

	<span class="n">pmcraid_info</span><span class="p">(</span><span class="s">&quot;command (%d) CDB[0] = %x for %x:%x:%x:%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">response_handle</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">,</span>
		     <span class="n">scsi_cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">unique_id</span><span class="p">,</span>
		     <span class="n">RES_IS_VSET</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">cfg_entry</span><span class="p">)</span> <span class="o">?</span> <span class="n">PMCRAID_VSET_BUS_ID</span> <span class="o">:</span>
			<span class="n">PMCRAID_PHYS_BUS_ID</span><span class="p">,</span>
		     <span class="n">RES_IS_VSET</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">cfg_entry</span><span class="p">)</span> <span class="o">?</span>
			<span class="p">(</span><span class="n">fw_version</span> <span class="o">&lt;=</span> <span class="n">PMCRAID_FW_VERSION_1</span> <span class="o">?</span>
				<span class="n">res</span><span class="o">-&gt;</span><span class="n">cfg_entry</span><span class="p">.</span><span class="n">unique_flags1</span> <span class="o">:</span>
					<span class="n">res</span><span class="o">-&gt;</span><span class="n">cfg_entry</span><span class="p">.</span><span class="n">array_id</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">)</span> <span class="o">:</span>
			<span class="n">RES_TARGET</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">cfg_entry</span><span class="p">.</span><span class="n">resource_address</span><span class="p">),</span>
		     <span class="n">RES_LUN</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">cfg_entry</span><span class="p">.</span><span class="n">resource_address</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">_pmcraid_fire_command</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pmcraid_err</span><span class="p">(</span><span class="s">&quot;queuecommand could not build ioadl</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">pmcraid_return_cmd</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">SCSI_MLQUEUE_HOST_BUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="nf">DEF_SCSI_QCMD</span><span class="p">(</span><span class="n">pmcraid_queuecommand</span><span class="p">)</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_open -char node &quot;open&quot; entry, allowed only users with admin access</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">pmcraid_chr_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>

	<span class="cm">/* Populate adapter instance * pointer for use by ioctl */</span>
	<span class="n">pinstance</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_cdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pmcraid_instance</span><span class="p">,</span> <span class="n">cdev</span><span class="p">);</span>
	<span class="n">filep</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">pinstance</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_release - char node &quot;release&quot; entry point</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pmcraid_chr_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span> <span class="o">=</span> <span class="n">filep</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="n">filep</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">fasync_helper</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">filep</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">aen_queue</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_fasync - Async notifier registration from applications</span>
<span class="cm"> *</span>
<span class="cm"> * This function adds the calling process to a driver global queue. When an</span>
<span class="cm"> * event occurs, SIGIO will be sent to all processes in this queue.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pmcraid_chr_fasync</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filep</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">pinstance</span> <span class="o">=</span> <span class="n">filep</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">aen_queue_lock</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">fasync_helper</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">filep</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">aen_queue</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">aen_queue_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * pmcraid_build_passthrough_ioadls - builds SG elements for passthrough</span>
<span class="cm"> * commands sent over IOCTL interface</span>
<span class="cm"> *</span>
<span class="cm"> * @cmd       : pointer to struct pmcraid_cmd</span>
<span class="cm"> * @buflen    : length of the request buffer</span>
<span class="cm"> * @direction : data transfer direction</span>
<span class="cm"> *</span>
<span class="cm"> * Return value</span>
<span class="cm"> *  0 on success, non-zero error code on failure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pmcraid_build_passthrough_ioadls</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">pmcraid_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">buflen</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">direction</span>
<span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pmcraid_sglist</span> <span class="o">*</span><span class="n">sglist</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pmcraid_ioarcb</span> <span class="o">*</span><span class="n">ioarcb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ioa_cb</span><span class="o">-&gt;</span><span class="n">ioarcb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pmcraid_ioadl_desc</span> <span class="o">*</span><span class="n">ioadl</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">sglist</span> <span class="o">=</span> <span class="n">pmcraid_alloc_sglist</span><span class="p">(</span><span class="n">buflen</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sglist</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pmcraid_err</span><span class="p">(</span><span class="s">&quot;can&#39;t allocate memory for passthrough SGls</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sglist</span><span class="o">-&gt;</span><span class="n">num_dma_sg</span> <span class="o">=</span> <span class="n">pci_map_sg</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">drv_inst</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
					<span class="n">sglist</span><span class="o">-&gt;</span><span class="n">scatterlist</span><span class="p">,</span>
					<span class="n">sglist</span><span class="o">-&gt;</span><span class="n">num_sg</span><span class="p">,</span> <span class="n">direction</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sglist</span><span class="o">-&gt;</span><span class="n">num_dma_sg</span> <span class="o">||</span> <span class="n">sglist</span><span class="o">-&gt;</span><span class="n">num_dma_sg</span> <span class="o">&gt;</span> <span class="n">PMCRAID_MAX_IOADLS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">drv_inst</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;Failed to map passthrough buffer!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">pmcraid_free_sglist</span><span class="p">(</span><span class="n">sglist</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sglist</span> <span class="o">=</span> <span class="n">sglist</span><span class="p">;</span>
	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">request_flags0</span> <span class="o">|=</span> <span class="n">NO_LINK_DESCS</span><span class="p">;</span>

	<span class="n">ioadl</span> <span class="o">=</span> <span class="n">pmcraid_init_ioadls</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">sglist</span><span class="o">-&gt;</span><span class="n">num_dma_sg</span><span class="p">);</span>

	<span class="cm">/* Initialize IOADL descriptor addresses */</span>
	<span class="n">for_each_sg</span><span class="p">(</span><span class="n">sglist</span><span class="o">-&gt;</span><span class="n">scatterlist</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">sglist</span><span class="o">-&gt;</span><span class="n">num_dma_sg</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ioadl</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">data_len</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">sg_dma_len</span><span class="p">(</span><span class="n">sg</span><span class="p">));</span>
		<span class="n">ioadl</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">address</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">sg_dma_address</span><span class="p">(</span><span class="n">sg</span><span class="p">));</span>
		<span class="n">ioadl</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* setup the last descriptor */</span>
	<span class="n">ioadl</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">flags</span> <span class="o">=</span> <span class="n">IOADL_FLAGS_LAST_DESC</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * pmcraid_release_passthrough_ioadls - release passthrough ioadls</span>
<span class="cm"> *</span>
<span class="cm"> * @cmd: pointer to struct pmcraid_cmd for which ioadls were allocated</span>
<span class="cm"> * @buflen: size of the request buffer</span>
<span class="cm"> * @direction: data transfer direction</span>
<span class="cm"> *</span>
<span class="cm"> * Return value</span>
<span class="cm"> *  0 on success, non-zero error code on failure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pmcraid_release_passthrough_ioadls</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">pmcraid_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">buflen</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">direction</span>
<span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pmcraid_sglist</span> <span class="o">*</span><span class="n">sglist</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sglist</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">buflen</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_unmap_sg</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">drv_inst</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
			     <span class="n">sglist</span><span class="o">-&gt;</span><span class="n">scatterlist</span><span class="p">,</span>
			     <span class="n">sglist</span><span class="o">-&gt;</span><span class="n">num_sg</span><span class="p">,</span>
			     <span class="n">direction</span><span class="p">);</span>
		<span class="n">pmcraid_free_sglist</span><span class="p">(</span><span class="n">sglist</span><span class="p">);</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sglist</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_ioctl_passthrough - handling passthrough IOCTL commands</span>
<span class="cm"> *</span>
<span class="cm"> * @pinstance: pointer to adapter instance structure</span>
<span class="cm"> * @cmd: ioctl code</span>
<span class="cm"> * @arg: pointer to pmcraid_passthrough_buffer user buffer</span>
<span class="cm"> *</span>
<span class="cm"> * Return value</span>
<span class="cm"> *  0 on success, non-zero error code on failure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">long</span> <span class="nf">pmcraid_ioctl_passthrough</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ioctl_cmd</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">buflen</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span>
<span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pmcraid_passthrough_ioctl_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pmcraid_ioarcb</span> <span class="o">*</span><span class="n">ioarcb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pmcraid_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pmcraid_cmd</span> <span class="o">*</span><span class="n">cancel_cmd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">request_buffer</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">request_offset</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lock_flags</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">ioasa</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ioasc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">request_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">buffer_size</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">access</span><span class="p">,</span> <span class="n">direction</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* If IOA reset is in progress, wait 10 secs for reset to complete */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ioa_reset_in_progress</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">wait_event_interruptible_timeout</span><span class="p">(</span>
				<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">reset_wait_q</span><span class="p">,</span>
				<span class="o">!</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ioa_reset_in_progress</span><span class="p">,</span>
				<span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="mi">10000</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ERESTARTSYS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If adapter is not in operational state, return error */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ioa_state</span> <span class="o">!=</span> <span class="n">IOA_STATE_OPERATIONAL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pmcraid_err</span><span class="p">(</span><span class="s">&quot;IOA is not operational</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">buffer_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_passthrough_ioctl_buffer</span><span class="p">);</span>
	<span class="n">buffer</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">buffer_size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pmcraid_err</span><span class="p">(</span><span class="s">&quot;no memory for passthrough buffer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">request_offset</span> <span class="o">=</span>
	    <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_passthrough_ioctl_buffer</span><span class="p">,</span> <span class="n">request_buffer</span><span class="p">);</span>

	<span class="n">request_buffer</span> <span class="o">=</span> <span class="n">arg</span> <span class="o">+</span> <span class="n">request_offset</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">__copy_from_user</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span>
			     <span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_passthrough_ioctl_buffer</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">,</span>
			     <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_passthrough_ioctl_buffer</span><span class="p">));</span>

	<span class="n">ioasa</span> <span class="o">=</span>
	<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">arg</span> <span class="o">+</span>
		<span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_passthrough_ioctl_buffer</span><span class="p">,</span> <span class="n">ioasa</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pmcraid_err</span><span class="p">(</span><span class="s">&quot;ioctl: can&#39;t copy passthrough buffer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_free_buffer</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">request_size</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">ioarcb</span><span class="p">.</span><span class="n">data_transfer_length</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">ioarcb</span><span class="p">.</span><span class="n">request_flags0</span> <span class="o">&amp;</span> <span class="n">TRANSFER_DIR_WRITE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">access</span> <span class="o">=</span> <span class="n">VERIFY_READ</span><span class="p">;</span>
		<span class="n">direction</span> <span class="o">=</span> <span class="n">DMA_TO_DEVICE</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">access</span> <span class="o">=</span> <span class="n">VERIFY_WRITE</span><span class="p">;</span>
		<span class="n">direction</span> <span class="o">=</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">request_size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">access_ok</span><span class="p">(</span><span class="n">access</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">request_offset</span> <span class="o">+</span> <span class="n">request_size</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_free_buffer</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">request_size</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_free_buffer</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* check if we have any additional command parameters */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">ioarcb</span><span class="p">.</span><span class="n">add_cmd_param_length</span> <span class="o">&gt;</span> <span class="n">PMCRAID_ADD_CMD_PARAM_LEN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_free_buffer</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cmd</span> <span class="o">=</span> <span class="n">pmcraid_get_free_cmd</span><span class="p">(</span><span class="n">pinstance</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pmcraid_err</span><span class="p">(</span><span class="s">&quot;free command block is not available</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_free_buffer</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_cmd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ioarcb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ioa_cb</span><span class="o">-&gt;</span><span class="n">ioarcb</span><span class="p">);</span>

	<span class="cm">/* Copy the user-provided IOARCB stuff field by field */</span>
	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">resource_handle</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">ioarcb</span><span class="p">.</span><span class="n">resource_handle</span><span class="p">;</span>
	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">data_transfer_length</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">ioarcb</span><span class="p">.</span><span class="n">data_transfer_length</span><span class="p">;</span>
	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">cmd_timeout</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">ioarcb</span><span class="p">.</span><span class="n">cmd_timeout</span><span class="p">;</span>
	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">request_type</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">ioarcb</span><span class="p">.</span><span class="n">request_type</span><span class="p">;</span>
	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">request_flags0</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">ioarcb</span><span class="p">.</span><span class="n">request_flags0</span><span class="p">;</span>
	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">request_flags1</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">ioarcb</span><span class="p">.</span><span class="n">request_flags1</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">cdb</span><span class="p">,</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">ioarcb</span><span class="p">.</span><span class="n">cdb</span><span class="p">,</span> <span class="n">PMCRAID_MAX_CDB_LEN</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">ioarcb</span><span class="p">.</span><span class="n">add_cmd_param_length</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">add_cmd_param_length</span> <span class="o">=</span>
			<span class="n">buffer</span><span class="o">-&gt;</span><span class="n">ioarcb</span><span class="p">.</span><span class="n">add_cmd_param_length</span><span class="p">;</span>
		<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">add_cmd_param_offset</span> <span class="o">=</span>
			<span class="n">buffer</span><span class="o">-&gt;</span><span class="n">ioarcb</span><span class="p">.</span><span class="n">add_cmd_param_offset</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">add_data</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">add_cmd_params</span><span class="p">,</span>
			<span class="n">buffer</span><span class="o">-&gt;</span><span class="n">ioarcb</span><span class="p">.</span><span class="n">add_data</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">add_cmd_params</span><span class="p">,</span>
			<span class="n">buffer</span><span class="o">-&gt;</span><span class="n">ioarcb</span><span class="p">.</span><span class="n">add_cmd_param_length</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* set hrrq number where the IOA should respond to. Note that all cmds</span>
<span class="cm">	 * generated internally uses hrrq_id 0, exception to this is the cmd</span>
<span class="cm">	 * block of scsi_cmd which is re-used (e.g. cancel/abort), which uses</span>
<span class="cm">	 * hrrq_id assigned here in queuecommand</span>
<span class="cm">	 */</span>
	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">hrrq_id</span> <span class="o">=</span> <span class="n">atomic_add_return</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">last_message_id</span><span class="p">))</span> <span class="o">%</span>
			  <span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">num_hrrq</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">request_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">pmcraid_build_passthrough_ioadls</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span>
						      <span class="n">request_size</span><span class="p">,</span>
						      <span class="n">direction</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pmcraid_err</span><span class="p">(</span><span class="s">&quot;couldn&#39;t build passthrough ioadls</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_free_buffer</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">request_size</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_free_buffer</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If data is being written into the device, copy the data from user</span>
<span class="cm">	 * buffers</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">direction</span> <span class="o">==</span> <span class="n">DMA_TO_DEVICE</span> <span class="o">&amp;&amp;</span> <span class="n">request_size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">pmcraid_copy_sglist</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sglist</span><span class="p">,</span>
					 <span class="n">request_buffer</span><span class="p">,</span>
					 <span class="n">request_size</span><span class="p">,</span>
					 <span class="n">direction</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pmcraid_err</span><span class="p">(</span><span class="s">&quot;failed to copy user buffer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_free_sglist</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* passthrough ioctl is a blocking command so, put the user to sleep</span>
<span class="cm">	 * until timeout. Note that a timeout value of 0 means, do timeout.</span>
<span class="cm">	 */</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmd_done</span> <span class="o">=</span> <span class="n">pmcraid_internal_done</span><span class="p">;</span>
	<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">wait_for_completion</span><span class="p">);</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">completion_req</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">pmcraid_info</span><span class="p">(</span><span class="s">&quot;command(%d) (CDB[0] = %x) for %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ioa_cb</span><span class="o">-&gt;</span><span class="n">ioarcb</span><span class="p">.</span><span class="n">response_handle</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">,</span>
		     <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ioa_cb</span><span class="o">-&gt;</span><span class="n">ioarcb</span><span class="p">.</span><span class="n">cdb</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
		     <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ioa_cb</span><span class="o">-&gt;</span><span class="n">ioarcb</span><span class="p">.</span><span class="n">resource_handle</span><span class="p">));</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">lock_flags</span><span class="p">);</span>
	<span class="n">_pmcraid_fire_command</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">lock_flags</span><span class="p">);</span>

	<span class="cm">/* NOTE ! Remove the below line once abort_task is implemented</span>
<span class="cm">	 * in firmware. This line disables ioctl command timeout handling logic</span>
<span class="cm">	 * similar to IO command timeout handling, making ioctl commands to wait</span>
<span class="cm">	 * until the command completion regardless of timeout value specified in</span>
<span class="cm">	 * ioarcb</span>
<span class="cm">	 */</span>
	<span class="n">buffer</span><span class="o">-&gt;</span><span class="n">ioarcb</span><span class="p">.</span><span class="n">cmd_timeout</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* If command timeout is specified put caller to wait till that time,</span>
<span class="cm">	 * otherwise it would be blocking wait. If command gets timed out, it</span>
<span class="cm">	 * will be aborted.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">ioarcb</span><span class="p">.</span><span class="n">cmd_timeout</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">wait_for_completion</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wait_for_completion_timeout</span><span class="p">(</span>
			<span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">wait_for_completion</span><span class="p">,</span>
			<span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">ioarcb</span><span class="p">.</span><span class="n">cmd_timeout</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">)))</span> <span class="p">{</span>

		<span class="n">pmcraid_info</span><span class="p">(</span><span class="s">&quot;aborting cmd %d (CDB[0] = %x) due to timeout</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ioa_cb</span><span class="o">-&gt;</span><span class="n">ioarcb</span><span class="p">.</span><span class="n">response_handle</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">),</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ioa_cb</span><span class="o">-&gt;</span><span class="n">ioarcb</span><span class="p">.</span><span class="n">cdb</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">lock_flags</span><span class="p">);</span>
		<span class="n">cancel_cmd</span> <span class="o">=</span> <span class="n">pmcraid_abort_cmd</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">lock_flags</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cancel_cmd</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cancel_cmd</span><span class="o">-&gt;</span><span class="n">wait_for_completion</span><span class="p">);</span>
			<span class="n">ioasc</span> <span class="o">=</span> <span class="n">cancel_cmd</span><span class="o">-&gt;</span><span class="n">ioa_cb</span><span class="o">-&gt;</span><span class="n">ioasa</span><span class="p">.</span><span class="n">ioasc</span><span class="p">;</span>
			<span class="n">pmcraid_return_cmd</span><span class="p">(</span><span class="n">cancel_cmd</span><span class="p">);</span>

			<span class="cm">/* if abort task couldn&#39;t find the command i.e it got</span>
<span class="cm">			 * completed prior to aborting, return good completion.</span>
<span class="cm">			 * if command got aborted successfully or there was IOA</span>
<span class="cm">			 * reset due to abort task itself getting timedout then</span>
<span class="cm">			 * return -ETIMEDOUT</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ioasc</span> <span class="o">==</span> <span class="n">PMCRAID_IOASC_IOA_WAS_RESET</span> <span class="o">||</span>
			    <span class="n">PMCRAID_IOASC_SENSE_KEY</span><span class="p">(</span><span class="n">ioasc</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x00</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ioasc</span> <span class="o">!=</span> <span class="n">PMCRAID_IOASC_GC_IOARCB_NOTFOUND</span><span class="p">)</span>
					<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out_handle_response</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* no command block for abort task or abort task failed to abort</span>
<span class="cm">		 * the IOARCB, then wait for 150 more seconds and initiate reset</span>
<span class="cm">		 * sequence after timeout</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wait_for_completion_timeout</span><span class="p">(</span>
			<span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">wait_for_completion</span><span class="p">,</span>
			<span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="mi">150</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">pmcraid_reset_bringup</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">drv_inst</span><span class="p">);</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">out_handle_response:</span>
	<span class="cm">/* copy entire IOASA buffer and return IOCTL success.</span>
<span class="cm">	 * If copying IOASA to user-buffer fails, return</span>
<span class="cm">	 * EFAULT</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">ioasa</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ioa_cb</span><span class="o">-&gt;</span><span class="n">ioasa</span><span class="p">,</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_ioasa</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">pmcraid_err</span><span class="p">(</span><span class="s">&quot;failed to copy ioasa buffer to user</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If the data transfer was from device, copy the data onto user</span>
<span class="cm">	 * buffers</span>
<span class="cm">	 */</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">direction</span> <span class="o">==</span> <span class="n">DMA_FROM_DEVICE</span> <span class="o">&amp;&amp;</span> <span class="n">request_size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">pmcraid_copy_sglist</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sglist</span><span class="p">,</span>
					 <span class="n">request_buffer</span><span class="p">,</span>
					 <span class="n">request_size</span><span class="p">,</span>
					 <span class="n">direction</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pmcraid_err</span><span class="p">(</span><span class="s">&quot;failed to copy user buffer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">out_free_sglist:</span>
	<span class="n">pmcraid_release_passthrough_ioadls</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">request_size</span><span class="p">,</span> <span class="n">direction</span><span class="p">);</span>
	<span class="n">pmcraid_return_cmd</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>

<span class="nl">out_free_buffer:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>




<span class="cm">/**</span>
<span class="cm"> * pmcraid_ioctl_driver - ioctl handler for commands handled by driver itself</span>
<span class="cm"> *</span>
<span class="cm"> * @pinstance: pointer to adapter instance structure</span>
<span class="cm"> * @cmd: ioctl command passed in</span>
<span class="cm"> * @buflen: length of user_buffer</span>
<span class="cm"> * @user_buffer: user buffer pointer</span>
<span class="cm"> *</span>
<span class="cm"> * Return Value</span>
<span class="cm"> *   0 in case of success, otherwise appropriate error code</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">long</span> <span class="nf">pmcraid_ioctl_driver</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">buflen</span><span class="p">,</span>
	<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">user_buffer</span>
<span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">access_ok</span><span class="p">(</span><span class="n">VERIFY_READ</span><span class="p">,</span> <span class="n">user_buffer</span><span class="p">,</span> <span class="n">_IOC_SIZE</span><span class="p">(</span><span class="n">cmd</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">pmcraid_err</span><span class="p">(</span><span class="s">&quot;ioctl_driver: access fault in request buffer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">PMCRAID_IOCTL_RESET_ADAPTER</span>:
		<span class="n">pmcraid_reset_bringup</span><span class="p">(</span><span class="n">pinstance</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_check_ioctl_buffer - check for proper access to user buffer</span>
<span class="cm"> *</span>
<span class="cm"> * @cmd: ioctl command</span>
<span class="cm"> * @arg: user buffer</span>
<span class="cm"> * @hdr: pointer to kernel memory for pmcraid_ioctl_header</span>
<span class="cm"> *</span>
<span class="cm"> * Return Value</span>
<span class="cm"> *	negetive error code if there are access issues, otherwise zero.</span>
<span class="cm"> *	Upon success, returns ioctl header copied out of user buffer.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pmcraid_check_ioctl_buffer</span><span class="p">(</span>
	<span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span>
	<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">pmcraid_ioctl_header</span> <span class="o">*</span><span class="n">hdr</span>
<span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">access</span> <span class="o">=</span> <span class="n">VERIFY_READ</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">hdr</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_ioctl_header</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">pmcraid_err</span><span class="p">(</span><span class="s">&quot;couldn&#39;t copy ioctl header from user buffer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* check for valid driver signature */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">memcmp</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">signature</span><span class="p">,</span>
		    <span class="n">PMCRAID_IOCTL_SIGNATURE</span><span class="p">,</span>
		    <span class="k">sizeof</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">signature</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pmcraid_err</span><span class="p">(</span><span class="s">&quot;signature verification failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* check for appropriate buffer access */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">_IOC_DIR</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_IOC_READ</span><span class="p">)</span> <span class="o">==</span> <span class="n">_IOC_READ</span><span class="p">)</span>
		<span class="n">access</span> <span class="o">=</span> <span class="n">VERIFY_WRITE</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">access_ok</span><span class="p">(</span><span class="n">access</span><span class="p">,</span>
		       <span class="p">(</span><span class="n">arg</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_ioctl_header</span><span class="p">)),</span>
		       <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">buffer_length</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pmcraid_err</span><span class="p">(</span><span class="s">&quot;access failed for user buffer of size %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">buffer_length</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  pmcraid_ioctl - char node ioctl entry point</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">long</span> <span class="nf">pmcraid_chr_ioctl</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filep</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span>
<span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pmcraid_ioctl_header</span> <span class="o">*</span><span class="n">hdr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">;</span>

	<span class="n">hdr</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_ioctl_header</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hdr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pmcraid_err</span><span class="p">(</span><span class="s">&quot;failed to allocate memory for ioctl header</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">pmcraid_check_ioctl_buffer</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">,</span> <span class="n">hdr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pmcraid_info</span><span class="p">(</span><span class="s">&quot;chr_ioctl: header check failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">hdr</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pinstance</span> <span class="o">=</span> <span class="n">filep</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pinstance</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pmcraid_info</span><span class="p">(</span><span class="s">&quot;adapter instance is not found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">hdr</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">_IOC_TYPE</span><span class="p">(</span><span class="n">cmd</span><span class="p">))</span> <span class="p">{</span>

	<span class="k">case</span> <span class="n">PMCRAID_PASSTHROUGH_IOCTL</span>:
		<span class="cm">/* If ioctl code is to download microcode, we need to block</span>
<span class="cm">		 * mid-layer requests.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">PMCRAID_IOCTL_DOWNLOAD_MICROCODE</span><span class="p">)</span>
			<span class="n">scsi_block_requests</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>

		<span class="n">retval</span> <span class="o">=</span> <span class="n">pmcraid_ioctl_passthrough</span><span class="p">(</span><span class="n">pinstance</span><span class="p">,</span>
						   <span class="n">cmd</span><span class="p">,</span>
						   <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">buffer_length</span><span class="p">,</span>
						   <span class="n">arg</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">PMCRAID_IOCTL_DOWNLOAD_MICROCODE</span><span class="p">)</span>
			<span class="n">scsi_unblock_requests</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">PMCRAID_DRIVER_IOCTL</span>:
		<span class="n">arg</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_ioctl_header</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">pmcraid_ioctl_driver</span><span class="p">(</span><span class="n">pinstance</span><span class="p">,</span>
					      <span class="n">cmd</span><span class="p">,</span>
					      <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">buffer_length</span><span class="p">,</span>
					      <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">hdr</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * File operations structure for management interface</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">pmcraid_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">pmcraid_chr_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">pmcraid_chr_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fasync</span> <span class="o">=</span> <span class="n">pmcraid_chr_fasync</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unlocked_ioctl</span> <span class="o">=</span> <span class="n">pmcraid_chr_ioctl</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_COMPAT</span>
	<span class="p">.</span><span class="n">compat_ioctl</span> <span class="o">=</span> <span class="n">pmcraid_chr_ioctl</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span> <span class="n">noop_llseek</span><span class="p">,</span>
<span class="p">};</span>




<span class="cm">/**</span>
<span class="cm"> * pmcraid_show_log_level - Display adapter&#39;s error logging level</span>
<span class="cm"> * @dev: class device struct</span>
<span class="cm"> * @buf: buffer</span>
<span class="cm"> *</span>
<span class="cm"> * Return value:</span>
<span class="cm"> *  number of bytes printed to buffer</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">pmcraid_show_log_level</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span> <span class="o">=</span>
		<span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="p">)</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">current_log_level</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_store_log_level - Change the adapter&#39;s error logging level</span>
<span class="cm"> * @dev: class device struct</span>
<span class="cm"> * @buf: buffer</span>
<span class="cm"> * @count: not used</span>
<span class="cm"> *</span>
<span class="cm"> * Return value:</span>
<span class="cm"> *  number of bytes printed to buffer</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">pmcraid_store_log_level</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
	<span class="kt">size_t</span> <span class="n">count</span>
<span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strict_strtoul</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="cm">/* log-level should be from 0 to 2 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">shost</span> <span class="o">=</span> <span class="n">class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">pinstance</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="p">)</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">current_log_level</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="n">pmcraid_log_level_attr</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">attr</span> <span class="o">=</span> <span class="p">{</span>
		 <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;log_level&quot;</span><span class="p">,</span>
		 <span class="p">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span>
		 <span class="p">},</span>
	<span class="p">.</span><span class="n">show</span> <span class="o">=</span> <span class="n">pmcraid_show_log_level</span><span class="p">,</span>
	<span class="p">.</span><span class="n">store</span> <span class="o">=</span> <span class="n">pmcraid_store_log_level</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_show_drv_version - Display driver version</span>
<span class="cm"> * @dev: class device struct</span>
<span class="cm"> * @buf: buffer</span>
<span class="cm"> *</span>
<span class="cm"> * Return value:</span>
<span class="cm"> *  number of bytes printed to buffer</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">pmcraid_show_drv_version</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span>
<span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="s">&quot;version: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">PMCRAID_DRIVER_VERSION</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="n">pmcraid_driver_version_attr</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">attr</span> <span class="o">=</span> <span class="p">{</span>
		 <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;drv_version&quot;</span><span class="p">,</span>
		 <span class="p">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">S_IRUGO</span><span class="p">,</span>
		 <span class="p">},</span>
	<span class="p">.</span><span class="n">show</span> <span class="o">=</span> <span class="n">pmcraid_show_drv_version</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_show_io_adapter_id - Display driver assigned adapter id</span>
<span class="cm"> * @dev: class device struct</span>
<span class="cm"> * @buf: buffer</span>
<span class="cm"> *</span>
<span class="cm"> * Return value:</span>
<span class="cm"> *  number of bytes printed to buffer</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">pmcraid_show_adapter_id</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span>
<span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span> <span class="o">=</span>
		<span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="p">)</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">adapter_id</span> <span class="o">=</span> <span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">number</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span>
		<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">aen_group</span> <span class="o">=</span> <span class="n">pmcraid_event_family</span><span class="p">.</span><span class="n">id</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span>
			<span class="s">&quot;adapter id: %d</span><span class="se">\n</span><span class="s">minor: %d</span><span class="se">\n</span><span class="s">aen group: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">adapter_id</span><span class="p">,</span> <span class="n">MINOR</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">.</span><span class="n">dev</span><span class="p">),</span> <span class="n">aen_group</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="n">pmcraid_adapter_id_attr</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">attr</span> <span class="o">=</span> <span class="p">{</span>
		 <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;adapter_id&quot;</span><span class="p">,</span>
		 <span class="p">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span>
		 <span class="p">},</span>
	<span class="p">.</span><span class="n">show</span> <span class="o">=</span> <span class="n">pmcraid_show_adapter_id</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">pmcraid_host_attrs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="o">&amp;</span><span class="n">pmcraid_log_level_attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">pmcraid_driver_version_attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">pmcraid_adapter_id_attr</span><span class="p">,</span>
	<span class="nb">NULL</span><span class="p">,</span>
<span class="p">};</span>


<span class="cm">/* host template structure for pmcraid driver */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">scsi_host_template</span> <span class="n">pmcraid_host_template</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">module</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">PMCRAID_DRIVER_NAME</span><span class="p">,</span>
	<span class="p">.</span><span class="n">queuecommand</span> <span class="o">=</span> <span class="n">pmcraid_queuecommand</span><span class="p">,</span>
	<span class="p">.</span><span class="n">eh_abort_handler</span> <span class="o">=</span> <span class="n">pmcraid_eh_abort_handler</span><span class="p">,</span>
	<span class="p">.</span><span class="n">eh_bus_reset_handler</span> <span class="o">=</span> <span class="n">pmcraid_eh_bus_reset_handler</span><span class="p">,</span>
	<span class="p">.</span><span class="n">eh_target_reset_handler</span> <span class="o">=</span> <span class="n">pmcraid_eh_target_reset_handler</span><span class="p">,</span>
	<span class="p">.</span><span class="n">eh_device_reset_handler</span> <span class="o">=</span> <span class="n">pmcraid_eh_device_reset_handler</span><span class="p">,</span>
	<span class="p">.</span><span class="n">eh_host_reset_handler</span> <span class="o">=</span> <span class="n">pmcraid_eh_host_reset_handler</span><span class="p">,</span>

	<span class="p">.</span><span class="n">slave_alloc</span> <span class="o">=</span> <span class="n">pmcraid_slave_alloc</span><span class="p">,</span>
	<span class="p">.</span><span class="n">slave_configure</span> <span class="o">=</span> <span class="n">pmcraid_slave_configure</span><span class="p">,</span>
	<span class="p">.</span><span class="n">slave_destroy</span> <span class="o">=</span> <span class="n">pmcraid_slave_destroy</span><span class="p">,</span>
	<span class="p">.</span><span class="n">change_queue_depth</span> <span class="o">=</span> <span class="n">pmcraid_change_queue_depth</span><span class="p">,</span>
	<span class="p">.</span><span class="n">change_queue_type</span>  <span class="o">=</span> <span class="n">pmcraid_change_queue_type</span><span class="p">,</span>
	<span class="p">.</span><span class="n">can_queue</span> <span class="o">=</span> <span class="n">PMCRAID_MAX_IO_CMD</span><span class="p">,</span>
	<span class="p">.</span><span class="n">this_id</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sg_tablesize</span> <span class="o">=</span> <span class="n">PMCRAID_MAX_IOADLS</span><span class="p">,</span>
	<span class="p">.</span><span class="n">max_sectors</span> <span class="o">=</span> <span class="n">PMCRAID_IOA_MAX_SECTORS</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cmd_per_lun</span> <span class="o">=</span> <span class="n">PMCRAID_MAX_CMD_PER_LUN</span><span class="p">,</span>
	<span class="p">.</span><span class="n">use_clustering</span> <span class="o">=</span> <span class="n">ENABLE_CLUSTERING</span><span class="p">,</span>
	<span class="p">.</span><span class="n">shost_attrs</span> <span class="o">=</span> <span class="n">pmcraid_host_attrs</span><span class="p">,</span>
	<span class="p">.</span><span class="n">proc_name</span> <span class="o">=</span> <span class="n">PMCRAID_DRIVER_NAME</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * pmcraid_isr_msix - implements MSI-X interrupt handling routine</span>
<span class="cm"> * @irq: interrupt vector number</span>
<span class="cm"> * @dev_id: pointer hrrq_vector</span>
<span class="cm"> *</span>
<span class="cm"> * Return Value</span>
<span class="cm"> *	 IRQ_HANDLED if interrupt is handled or IRQ_NONE if ignored</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">pmcraid_isr_msix</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pmcraid_isr_param</span> <span class="o">*</span><span class="n">hrrq_vector</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lock_flags</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">intrs_val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">hrrq_id</span><span class="p">;</span>

	<span class="n">hrrq_vector</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_isr_param</span> <span class="o">*</span><span class="p">)</span><span class="n">dev_id</span><span class="p">;</span>
	<span class="n">hrrq_id</span> <span class="o">=</span> <span class="n">hrrq_vector</span><span class="o">-&gt;</span><span class="n">hrrq_id</span><span class="p">;</span>
	<span class="n">pinstance</span> <span class="o">=</span> <span class="n">hrrq_vector</span><span class="o">-&gt;</span><span class="n">drv_inst</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hrrq_id</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Read the interrupt */</span>
		<span class="n">intrs_val</span> <span class="o">=</span> <span class="n">pmcraid_read_interrupts</span><span class="p">(</span><span class="n">pinstance</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">intrs_val</span> <span class="o">&amp;&amp;</span>
			<span class="p">((</span><span class="n">ioread32</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">int_regs</span><span class="p">.</span><span class="n">host_ioa_interrupt_reg</span><span class="p">)</span>
			<span class="o">&amp;</span> <span class="n">DOORBELL_INTR_MSIX_CLR</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Any error interrupts including unit_check,</span>
<span class="cm">			 * initiate IOA reset.In case of unit check indicate</span>
<span class="cm">			 * to reset_sequence that IOA unit checked and prepare</span>
<span class="cm">			 * for a dump during reset sequence</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">intrs_val</span> <span class="o">&amp;</span> <span class="n">PMCRAID_ERROR_INTERRUPTS</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">intrs_val</span> <span class="o">&amp;</span> <span class="n">INTRS_IOA_UNIT_CHECK</span><span class="p">)</span>
					<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ioa_unit_check</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

				<span class="n">pmcraid_err</span><span class="p">(</span><span class="s">&quot;ISR: error interrupts: %x \</span>
<span class="s">					initiating reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">intrs_val</span><span class="p">);</span>
				<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span>
					<span class="n">lock_flags</span><span class="p">);</span>
				<span class="n">pmcraid_initiate_reset</span><span class="p">(</span><span class="n">pinstance</span><span class="p">);</span>
				<span class="n">spin_unlock_irqrestore</span><span class="p">(</span>
					<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span>
					<span class="n">lock_flags</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="cm">/* If interrupt was as part of the ioa initialization,</span>
<span class="cm">			 * clear it. Delete the timer and wakeup the</span>
<span class="cm">			 * reset engine to proceed with reset sequence</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">intrs_val</span> <span class="o">&amp;</span> <span class="n">INTRS_TRANSITION_TO_OPERATIONAL</span><span class="p">)</span>
				<span class="n">pmcraid_clr_trans_op</span><span class="p">(</span><span class="n">pinstance</span><span class="p">);</span>

			<span class="cm">/* Clear the interrupt register by writing</span>
<span class="cm">			 * to host to ioa doorbell. Once done</span>
<span class="cm">			 * FW will clear the interrupt.</span>
<span class="cm">			 */</span>
			<span class="n">iowrite32</span><span class="p">(</span><span class="n">DOORBELL_INTR_MSIX_CLR</span><span class="p">,</span>
				<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">int_regs</span><span class="p">.</span><span class="n">host_ioa_interrupt_reg</span><span class="p">);</span>
			<span class="n">ioread32</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">int_regs</span><span class="p">.</span><span class="n">host_ioa_interrupt_reg</span><span class="p">);</span>


		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">tasklet_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">isr_tasklet</span><span class="p">[</span><span class="n">hrrq_id</span><span class="p">]));</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_isr  - implements legacy interrupt handling routine</span>
<span class="cm"> *</span>
<span class="cm"> * @irq: interrupt vector number</span>
<span class="cm"> * @dev_id: pointer hrrq_vector</span>
<span class="cm"> *</span>
<span class="cm"> * Return Value</span>
<span class="cm"> *	 IRQ_HANDLED if interrupt is handled or IRQ_NONE if ignored</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">pmcraid_isr</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pmcraid_isr_param</span> <span class="o">*</span><span class="n">hrrq_vector</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">intrs</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lock_flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">hrrq_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* In case of legacy interrupt mode where interrupts are shared across</span>
<span class="cm">	 * isrs, it may be possible that the current interrupt is not from IOA</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev_id</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s(): NULL host pointer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">hrrq_vector</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_isr_param</span> <span class="o">*</span><span class="p">)</span><span class="n">dev_id</span><span class="p">;</span>
	<span class="n">pinstance</span> <span class="o">=</span> <span class="n">hrrq_vector</span><span class="o">-&gt;</span><span class="n">drv_inst</span><span class="p">;</span>

	<span class="n">intrs</span> <span class="o">=</span> <span class="n">pmcraid_read_interrupts</span><span class="p">(</span><span class="n">pinstance</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">((</span><span class="n">intrs</span> <span class="o">&amp;</span> <span class="n">PMCRAID_PCI_INTERRUPTS</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>

	<span class="cm">/* Any error interrupts including unit_check, initiate IOA reset.</span>
<span class="cm">	 * In case of unit check indicate to reset_sequence that IOA unit</span>
<span class="cm">	 * checked and prepare for a dump during reset sequence</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">intrs</span> <span class="o">&amp;</span> <span class="n">PMCRAID_ERROR_INTERRUPTS</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">intrs</span> <span class="o">&amp;</span> <span class="n">INTRS_IOA_UNIT_CHECK</span><span class="p">)</span>
			<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ioa_unit_check</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">iowrite32</span><span class="p">(</span><span class="n">intrs</span><span class="p">,</span>
			  <span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">int_regs</span><span class="p">.</span><span class="n">ioa_host_interrupt_clr_reg</span><span class="p">);</span>
		<span class="n">pmcraid_err</span><span class="p">(</span><span class="s">&quot;ISR: error interrupts: %x initiating reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			    <span class="n">intrs</span><span class="p">);</span>
		<span class="n">intrs</span> <span class="o">=</span> <span class="n">ioread32</span><span class="p">(</span>
				<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">int_regs</span><span class="p">.</span><span class="n">ioa_host_interrupt_clr_reg</span><span class="p">);</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">lock_flags</span><span class="p">);</span>
		<span class="n">pmcraid_initiate_reset</span><span class="p">(</span><span class="n">pinstance</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">lock_flags</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* If interrupt was as part of the ioa initialization,</span>
<span class="cm">		 * clear. Delete the timer and wakeup the</span>
<span class="cm">		 * reset engine to proceed with reset sequence</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">intrs</span> <span class="o">&amp;</span> <span class="n">INTRS_TRANSITION_TO_OPERATIONAL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pmcraid_clr_trans_op</span><span class="p">(</span><span class="n">pinstance</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">iowrite32</span><span class="p">(</span><span class="n">intrs</span><span class="p">,</span>
				<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">int_regs</span><span class="p">.</span><span class="n">ioa_host_interrupt_clr_reg</span><span class="p">);</span>
			<span class="n">ioread32</span><span class="p">(</span>
				<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">int_regs</span><span class="p">.</span><span class="n">ioa_host_interrupt_clr_reg</span><span class="p">);</span>

			<span class="n">tasklet_schedule</span><span class="p">(</span>
					<span class="o">&amp;</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">isr_tasklet</span><span class="p">[</span><span class="n">hrrq_id</span><span class="p">]));</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * pmcraid_worker_function -  worker thread function</span>
<span class="cm"> *</span>
<span class="cm"> * @workp: pointer to struct work queue</span>
<span class="cm"> *</span>
<span class="cm"> * Return Value</span>
<span class="cm"> *	 None</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pmcraid_worker_function</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">workp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pmcraid_resource_entry</span> <span class="o">*</span><span class="n">res</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pmcraid_resource_entry</span> <span class="o">*</span><span class="n">temp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lock_flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">host_lock_flags</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">fw_version</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">bus</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">lun</span><span class="p">;</span>

	<span class="n">pinstance</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">workp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pmcraid_instance</span><span class="p">,</span> <span class="n">worker_q</span><span class="p">);</span>
	<span class="cm">/* add resources only after host is added into system */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">expose_resources</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">fw_version</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">inq_data</span><span class="o">-&gt;</span><span class="n">fw_version</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">resource_lock</span><span class="p">,</span> <span class="n">lock_flags</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">used_res_q</span><span class="p">,</span> <span class="n">queue</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">change_detected</span> <span class="o">==</span> <span class="n">RES_CHANGE_DEL</span> <span class="o">&amp;&amp;</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">scsi_dev</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sdev</span> <span class="o">=</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">scsi_dev</span><span class="p">;</span>

			<span class="cm">/* host_lock must be held before calling</span>
<span class="cm">			 * scsi_device_get</span>
<span class="cm">			 */</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span>
					  <span class="n">host_lock_flags</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">scsi_device_get</span><span class="p">(</span><span class="n">sdev</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">spin_unlock_irqrestore</span><span class="p">(</span>
						<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span>
						<span class="n">host_lock_flags</span><span class="p">);</span>
				<span class="n">pmcraid_info</span><span class="p">(</span><span class="s">&quot;deleting %x from midlayer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					     <span class="n">res</span><span class="o">-&gt;</span><span class="n">cfg_entry</span><span class="p">.</span><span class="n">resource_address</span><span class="p">);</span>
				<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">free_res_q</span><span class="p">);</span>
				<span class="n">spin_unlock_irqrestore</span><span class="p">(</span>
					<span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">resource_lock</span><span class="p">,</span>
					<span class="n">lock_flags</span><span class="p">);</span>
				<span class="n">scsi_remove_device</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>
				<span class="n">scsi_device_put</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>
				<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">resource_lock</span><span class="p">,</span>
						   <span class="n">lock_flags</span><span class="p">);</span>
				<span class="n">res</span><span class="o">-&gt;</span><span class="n">change_detected</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">spin_unlock_irqrestore</span><span class="p">(</span>
						<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span>
						<span class="n">host_lock_flags</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">used_res_q</span><span class="p">,</span> <span class="n">queue</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">change_detected</span> <span class="o">==</span> <span class="n">RES_CHANGE_ADD</span><span class="p">)</span> <span class="p">{</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pmcraid_expose_resource</span><span class="p">(</span><span class="n">fw_version</span><span class="p">,</span>
						     <span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">cfg_entry</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">RES_IS_VSET</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">cfg_entry</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">bus</span> <span class="o">=</span> <span class="n">PMCRAID_VSET_BUS_ID</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">fw_version</span> <span class="o">&lt;=</span> <span class="n">PMCRAID_FW_VERSION_1</span><span class="p">)</span>
					<span class="n">target</span> <span class="o">=</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">cfg_entry</span><span class="p">.</span><span class="n">unique_flags1</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="n">target</span> <span class="o">=</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">cfg_entry</span><span class="p">.</span><span class="n">array_id</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>
				<span class="n">lun</span> <span class="o">=</span> <span class="n">PMCRAID_VSET_LUN_ID</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">bus</span> <span class="o">=</span> <span class="n">PMCRAID_PHYS_BUS_ID</span><span class="p">;</span>
				<span class="n">target</span> <span class="o">=</span>
				     <span class="n">RES_TARGET</span><span class="p">(</span>
					<span class="n">res</span><span class="o">-&gt;</span><span class="n">cfg_entry</span><span class="p">.</span><span class="n">resource_address</span><span class="p">);</span>
				<span class="n">lun</span> <span class="o">=</span> <span class="n">RES_LUN</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">cfg_entry</span><span class="p">.</span><span class="n">resource_address</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="n">res</span><span class="o">-&gt;</span><span class="n">change_detected</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">resource_lock</span><span class="p">,</span>
						<span class="n">lock_flags</span><span class="p">);</span>
			<span class="n">scsi_add_device</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span> <span class="n">bus</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">lun</span><span class="p">);</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">resource_lock</span><span class="p">,</span>
					   <span class="n">lock_flags</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">resource_lock</span><span class="p">,</span> <span class="n">lock_flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_tasklet_function - Tasklet function</span>
<span class="cm"> *</span>
<span class="cm"> * @instance: pointer to msix param structure</span>
<span class="cm"> *</span>
<span class="cm"> * Return Value</span>
<span class="cm"> *	None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pmcraid_tasklet_function</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">instance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pmcraid_isr_param</span> <span class="o">*</span><span class="n">hrrq_vector</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hrrq_lock_flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pending_lock_flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">host_lock_flags</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="o">*</span><span class="n">lockp</span><span class="p">;</span> <span class="cm">/* hrrq buffer lock */</span>
	<span class="kt">int</span> <span class="n">id</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">resp</span><span class="p">;</span>

	<span class="n">hrrq_vector</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_isr_param</span> <span class="o">*</span><span class="p">)</span><span class="n">instance</span><span class="p">;</span>
	<span class="n">pinstance</span> <span class="o">=</span> <span class="n">hrrq_vector</span><span class="o">-&gt;</span><span class="n">drv_inst</span><span class="p">;</span>
	<span class="n">id</span> <span class="o">=</span> <span class="n">hrrq_vector</span><span class="o">-&gt;</span><span class="n">hrrq_id</span><span class="p">;</span>
	<span class="n">lockp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">hrrq_lock</span><span class="p">[</span><span class="n">id</span><span class="p">]);</span>

	<span class="cm">/* loop through each of the commands responded by IOA. Each HRRQ buf is</span>
<span class="cm">	 * protected by its own lock. Traversals must be done within this lock</span>
<span class="cm">	 * as there may be multiple tasklets running on multiple CPUs. Note</span>
<span class="cm">	 * that the lock is held just for picking up the response handle and</span>
<span class="cm">	 * manipulating hrrq_curr/toggle_bit values.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">lockp</span><span class="p">,</span> <span class="n">hrrq_lock_flags</span><span class="p">);</span>

	<span class="n">resp</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">hrrq_curr</span><span class="p">[</span><span class="n">id</span><span class="p">]));</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">resp</span> <span class="o">&amp;</span> <span class="n">HRRQ_TOGGLE_BIT</span><span class="p">)</span> <span class="o">==</span>
		<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">host_toggle_bit</span><span class="p">[</span><span class="n">id</span><span class="p">])</span> <span class="p">{</span>

		<span class="kt">int</span> <span class="n">cmd_index</span> <span class="o">=</span> <span class="n">resp</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">pmcraid_cmd</span> <span class="o">*</span><span class="n">cmd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">hrrq_curr</span><span class="p">[</span><span class="n">id</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">hrrq_end</span><span class="p">[</span><span class="n">id</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">hrrq_curr</span><span class="p">[</span><span class="n">id</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">hrrq_curr</span><span class="p">[</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">hrrq_start</span><span class="p">[</span><span class="n">id</span><span class="p">];</span>
			<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">host_toggle_bit</span><span class="p">[</span><span class="n">id</span><span class="p">]</span> <span class="o">^=</span> <span class="mi">1u</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cmd_index</span> <span class="o">&gt;=</span> <span class="n">PMCRAID_MAX_CMD</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* In case of invalid response handle, log message */</span>
			<span class="n">pmcraid_err</span><span class="p">(</span><span class="s">&quot;Invalid response handle %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cmd_index</span><span class="p">);</span>
			<span class="n">resp</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">hrrq_curr</span><span class="p">[</span><span class="n">id</span><span class="p">]));</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">cmd</span> <span class="o">=</span> <span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">cmd_list</span><span class="p">[</span><span class="n">cmd_index</span><span class="p">];</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">lockp</span><span class="p">,</span> <span class="n">hrrq_lock_flags</span><span class="p">);</span>

		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">pending_pool_lock</span><span class="p">,</span>
				   <span class="n">pending_lock_flags</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">free_list</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">pending_pool_lock</span><span class="p">,</span>
					<span class="n">pending_lock_flags</span><span class="p">);</span>
		<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>
		<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">outstanding_cmds</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmd_done</span> <span class="o">==</span> <span class="n">pmcraid_ioa_reset</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span>
					  <span class="n">host_lock_flags</span><span class="p">);</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmd_done</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span>
					       <span class="n">host_lock_flags</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmd_done</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmd_done</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* loop over until we are done with all responses */</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">lockp</span><span class="p">,</span> <span class="n">hrrq_lock_flags</span><span class="p">);</span>
		<span class="n">resp</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">hrrq_curr</span><span class="p">[</span><span class="n">id</span><span class="p">]));</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">lockp</span><span class="p">,</span> <span class="n">hrrq_lock_flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_unregister_interrupt_handler - de-register interrupts handlers</span>
<span class="cm"> * @pinstance: pointer to adapter instance structure</span>
<span class="cm"> *</span>
<span class="cm"> * This routine un-registers registered interrupt handler and</span>
<span class="cm"> * also frees irqs/vectors.</span>
<span class="cm"> *</span>
<span class="cm"> * Retun Value</span>
<span class="cm"> *	None</span>
<span class="cm"> */</span>
<span class="k">static</span>
<span class="kt">void</span> <span class="nf">pmcraid_unregister_interrupt_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">num_hrrq</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">hrrq_vector</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vector</span><span class="p">,</span>
			 <span class="o">&amp;</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">hrrq_vector</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">interrupt_mode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_disable_msix</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">);</span>
		<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">interrupt_mode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_register_interrupt_handler - registers interrupt handler</span>
<span class="cm"> * @pinstance: pointer to per-adapter instance structure</span>
<span class="cm"> *</span>
<span class="cm"> * Return Value</span>
<span class="cm"> *	0 on success, non-zero error code otherwise.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">pmcraid_register_interrupt_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">pmcraid_enable_msix</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="n">pci_find_capability</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_CAP_ID_MSIX</span><span class="p">)))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">num_hrrq</span> <span class="o">=</span> <span class="n">PMCRAID_NUM_MSIX_VECTORS</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">msix_entry</span> <span class="n">entries</span><span class="p">[</span><span class="n">PMCRAID_NUM_MSIX_VECTORS</span><span class="p">];</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PMCRAID_NUM_MSIX_VECTORS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">entry</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="n">pci_enable_msix</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">entries</span><span class="p">,</span> <span class="n">num_hrrq</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">pmcraid_isr_legacy</span><span class="p">;</span>

		<span class="cm">/* Check how many MSIX vectors are allocated and register</span>
<span class="cm">		 * msi-x handlers for each of them giving appropriate buffer</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">num_hrrq</span> <span class="o">=</span> <span class="n">rc</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pci_enable_msix</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">entries</span><span class="p">,</span> <span class="n">num_hrrq</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">pmcraid_isr_legacy</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_hrrq</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">hrrq_vector</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">hrrq_id</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">hrrq_vector</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">drv_inst</span> <span class="o">=</span> <span class="n">pinstance</span><span class="p">;</span>
			<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">hrrq_vector</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vector</span> <span class="o">=</span> <span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vector</span><span class="p">;</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">hrrq_vector</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vector</span><span class="p">,</span>
					<span class="n">pmcraid_isr_msix</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					<span class="n">PMCRAID_DRIVER_NAME</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">hrrq_vector</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
				<span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
				<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
					<span class="n">free_irq</span><span class="p">(</span><span class="n">entries</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">vector</span><span class="p">,</span>
						 <span class="o">&amp;</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">hrrq_vector</span><span class="p">[</span><span class="n">j</span><span class="p">]));</span>
				<span class="n">pci_disable_msix</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">pmcraid_isr_legacy</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">num_hrrq</span> <span class="o">=</span> <span class="n">num_hrrq</span><span class="p">;</span>
		<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">interrupt_mode</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">iowrite32</span><span class="p">(</span><span class="n">DOORBELL_INTR_MODE_MSIX</span><span class="p">,</span>
			  <span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">int_regs</span><span class="p">.</span><span class="n">host_ioa_interrupt_reg</span><span class="p">);</span>
		<span class="n">ioread32</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">int_regs</span><span class="p">.</span><span class="n">host_ioa_interrupt_reg</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">pmcraid_isr_out</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">pmcraid_isr_legacy:</span>
	<span class="cm">/* If MSI-X registration failed fallback to legacy mode, where</span>
<span class="cm">	 * only one hrrq entry will be used</span>
<span class="cm">	 */</span>
	<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">hrrq_vector</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">hrrq_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">hrrq_vector</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">drv_inst</span> <span class="o">=</span> <span class="n">pinstance</span><span class="p">;</span>
	<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">hrrq_vector</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">vector</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>
	<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">num_hrrq</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">pmcraid_isr</span><span class="p">,</span> <span class="n">IRQF_SHARED</span><span class="p">,</span>
			 <span class="n">PMCRAID_DRIVER_NAME</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">hrrq_vector</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="nl">pmcraid_isr_out:</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_release_cmd_blocks - release buufers allocated for command blocks</span>
<span class="cm"> * @pinstance: per adapter instance structure pointer</span>
<span class="cm"> * @max_index: number of buffer blocks to release</span>
<span class="cm"> *</span>
<span class="cm"> * Return Value</span>
<span class="cm"> *  None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">pmcraid_release_cmd_blocks</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max_index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">max_index</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">cmd_cachep</span><span class="p">,</span> <span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">cmd_list</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">cmd_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">cmd_cachep</span><span class="p">);</span>
	<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">cmd_cachep</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_release_control_blocks - releases buffers alloced for control blocks</span>
<span class="cm"> * @pinstance: pointer to per adapter instance structure</span>
<span class="cm"> * @max_index: number of buffers (from 0 onwards) to release</span>
<span class="cm"> *</span>
<span class="cm"> * This function assumes that the command blocks for which control blocks are</span>
<span class="cm"> * linked are not released.</span>
<span class="cm"> *</span>
<span class="cm"> * Return Value</span>
<span class="cm"> *	 None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">pmcraid_release_control_blocks</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">max_index</span>
<span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">control_pool</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">max_index</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_pool_free</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">control_pool</span><span class="p">,</span>
			      <span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">cmd_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ioa_cb</span><span class="p">,</span>
			      <span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">cmd_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ioa_cb_bus_addr</span><span class="p">);</span>
		<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">cmd_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ioa_cb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">cmd_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ioa_cb_bus_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pci_pool_destroy</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">control_pool</span><span class="p">);</span>
	<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">control_pool</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_allocate_cmd_blocks - allocate memory for cmd block structures</span>
<span class="cm"> * @pinstance - pointer to per adapter instance structure</span>
<span class="cm"> *</span>
<span class="cm"> * Allocates memory for command blocks using kernel slab allocator.</span>
<span class="cm"> *</span>
<span class="cm"> * Return Value</span>
<span class="cm"> *	0 in case of success; -ENOMEM in case of failure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span>
<span class="nf">pmcraid_allocate_cmd_blocks</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">sprintf</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">cmd_pool_name</span><span class="p">,</span> <span class="s">&quot;pmcraid_cmd_pool_%d&quot;</span><span class="p">,</span>
		<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">unique_id</span><span class="p">);</span>


	<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">cmd_cachep</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span>
					<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">cmd_pool_name</span><span class="p">,</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_cmd</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
					<span class="n">SLAB_HWCACHE_ALIGN</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">cmd_cachep</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PMCRAID_MAX_CMD</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">cmd_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>
			<span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">cmd_cachep</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">cmd_list</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">pmcraid_release_cmd_blocks</span><span class="p">(</span><span class="n">pinstance</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_allocate_control_blocks - allocates memory control blocks</span>
<span class="cm"> * @pinstance : pointer to per adapter instance structure</span>
<span class="cm"> *</span>
<span class="cm"> * This function allocates PCI memory for DMAable buffers like IOARCB, IOADLs</span>
<span class="cm"> * and IOASAs. This is called after command blocks are already allocated.</span>
<span class="cm"> *</span>
<span class="cm"> * Return Value</span>
<span class="cm"> *  0 in case it can allocate all control blocks, otherwise -ENOMEM</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span>
<span class="nf">pmcraid_allocate_control_blocks</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">sprintf</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ctl_pool_name</span><span class="p">,</span> <span class="s">&quot;pmcraid_control_pool_%d&quot;</span><span class="p">,</span>
		<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">unique_id</span><span class="p">);</span>

	<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">control_pool</span> <span class="o">=</span>
		<span class="n">pci_pool_create</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ctl_pool_name</span><span class="p">,</span>
				<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_control_block</span><span class="p">),</span>
				<span class="n">PMCRAID_IOARCB_ALIGNMENT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">control_pool</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PMCRAID_MAX_CMD</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">cmd_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ioa_cb</span> <span class="o">=</span>
			<span class="n">pci_pool_alloc</span><span class="p">(</span>
				<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">control_pool</span><span class="p">,</span>
				<span class="n">GFP_KERNEL</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">cmd_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ioa_cb_bus_addr</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">cmd_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ioa_cb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pmcraid_release_control_blocks</span><span class="p">(</span><span class="n">pinstance</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">cmd_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ioa_cb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_control_block</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_release_host_rrqs - release memory allocated for hrrq buffer(s)</span>
<span class="cm"> * @pinstance: pointer to per adapter instance structure</span>
<span class="cm"> * @maxindex: size of hrrq buffer pointer array</span>
<span class="cm"> *</span>
<span class="cm"> * Return Value</span>
<span class="cm"> *	None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">pmcraid_release_host_rrqs</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span><span class="p">,</span> <span class="kt">int</span> <span class="n">maxindex</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">maxindex</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
				    <span class="n">HRRQ_ENTRY_SIZE</span> <span class="o">*</span> <span class="n">PMCRAID_MAX_CMD</span><span class="p">,</span>
				    <span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">hrrq_start</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
				    <span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">hrrq_start_bus_addr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

		<span class="cm">/* reset pointers and toggle bit to zeros */</span>
		<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">hrrq_start</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">hrrq_start_bus_addr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">host_toggle_bit</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_allocate_host_rrqs - Allocate and initialize host RRQ buffers</span>
<span class="cm"> * @pinstance: pointer to per adapter instance structure</span>
<span class="cm"> *</span>
<span class="cm"> * Return value</span>
<span class="cm"> *	0 hrrq buffers are allocated, -ENOMEM otherwise.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span>
<span class="nf">pmcraid_allocate_host_rrqs</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">buffer_size</span><span class="p">;</span>

	<span class="n">buffer_size</span> <span class="o">=</span> <span class="n">HRRQ_ENTRY_SIZE</span> <span class="o">*</span> <span class="n">PMCRAID_MAX_CMD</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">num_hrrq</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">hrrq_start</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>
			<span class="n">pci_alloc_consistent</span><span class="p">(</span>
					<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
					<span class="n">buffer_size</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">hrrq_start_bus_addr</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">hrrq_start</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pmcraid_err</span><span class="p">(</span><span class="s">&quot;pci_alloc failed for hrrq vector : %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				    <span class="n">i</span><span class="p">);</span>
			<span class="n">pmcraid_release_host_rrqs</span><span class="p">(</span><span class="n">pinstance</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">memset</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">hrrq_start</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">buffer_size</span><span class="p">);</span>
		<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">hrrq_curr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">hrrq_start</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">hrrq_end</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>
			<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">hrrq_start</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">PMCRAID_MAX_CMD</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">host_toggle_bit</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">hrrq_lock</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_release_hcams - release HCAM buffers</span>
<span class="cm"> *</span>
<span class="cm"> * @pinstance: pointer to per adapter instance structure</span>
<span class="cm"> *</span>
<span class="cm"> * Return value</span>
<span class="cm"> *  none</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pmcraid_release_hcams</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ccn</span><span class="p">.</span><span class="n">msg</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
				    <span class="n">PMCRAID_AEN_HDR_SIZE</span> <span class="o">+</span>
				    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_hcam_ccn_ext</span><span class="p">),</span>
				    <span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ccn</span><span class="p">.</span><span class="n">msg</span><span class="p">,</span>
				    <span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ccn</span><span class="p">.</span><span class="n">baddr</span><span class="p">);</span>

		<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ccn</span><span class="p">.</span><span class="n">msg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ccn</span><span class="p">.</span><span class="n">hcam</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ccn</span><span class="p">.</span><span class="n">baddr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ldn</span><span class="p">.</span><span class="n">msg</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
				    <span class="n">PMCRAID_AEN_HDR_SIZE</span> <span class="o">+</span>
				    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_hcam_ldn</span><span class="p">),</span>
				    <span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ldn</span><span class="p">.</span><span class="n">msg</span><span class="p">,</span>
				    <span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ldn</span><span class="p">.</span><span class="n">baddr</span><span class="p">);</span>

		<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ldn</span><span class="p">.</span><span class="n">msg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ldn</span><span class="p">.</span><span class="n">hcam</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ldn</span><span class="p">.</span><span class="n">baddr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_allocate_hcams - allocates HCAM buffers</span>
<span class="cm"> * @pinstance : pointer to per adapter instance structure</span>
<span class="cm"> *</span>
<span class="cm"> * Return Value:</span>
<span class="cm"> *   0 in case of successful allocation, non-zero otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pmcraid_allocate_hcams</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ccn</span><span class="p">.</span><span class="n">msg</span> <span class="o">=</span> <span class="n">pci_alloc_consistent</span><span class="p">(</span>
					<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
					<span class="n">PMCRAID_AEN_HDR_SIZE</span> <span class="o">+</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_hcam_ccn_ext</span><span class="p">),</span>
					<span class="o">&amp;</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ccn</span><span class="p">.</span><span class="n">baddr</span><span class="p">));</span>

	<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ldn</span><span class="p">.</span><span class="n">msg</span> <span class="o">=</span> <span class="n">pci_alloc_consistent</span><span class="p">(</span>
					<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
					<span class="n">PMCRAID_AEN_HDR_SIZE</span> <span class="o">+</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_hcam_ldn</span><span class="p">),</span>
					<span class="o">&amp;</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ldn</span><span class="p">.</span><span class="n">baddr</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ldn</span><span class="p">.</span><span class="n">msg</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ccn</span><span class="p">.</span><span class="n">msg</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pmcraid_release_hcams</span><span class="p">(</span><span class="n">pinstance</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ccn</span><span class="p">.</span><span class="n">hcam</span> <span class="o">=</span>
			<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ccn</span><span class="p">.</span><span class="n">msg</span> <span class="o">+</span> <span class="n">PMCRAID_AEN_HDR_SIZE</span><span class="p">;</span>
		<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ldn</span><span class="p">.</span><span class="n">hcam</span> <span class="o">=</span>
			<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ldn</span><span class="p">.</span><span class="n">msg</span> <span class="o">+</span> <span class="n">PMCRAID_AEN_HDR_SIZE</span><span class="p">;</span>

		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ccn</span><span class="p">.</span><span class="n">ignore</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ldn</span><span class="p">.</span><span class="n">ignore</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ldn</span><span class="p">.</span><span class="n">msg</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">?</span> <span class="o">-</span><span class="n">ENOMEM</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_release_config_buffers - release config.table buffers</span>
<span class="cm"> * @pinstance: pointer to per adapter instance structure</span>
<span class="cm"> *</span>
<span class="cm"> * Return Value</span>
<span class="cm"> *	 none</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pmcraid_release_config_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">cfg_table</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span>
	    <span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">cfg_table_bus_addr</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
				    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_config_table</span><span class="p">),</span>
				    <span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">cfg_table</span><span class="p">,</span>
				    <span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">cfg_table_bus_addr</span><span class="p">);</span>
		<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">cfg_table</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">cfg_table_bus_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">res_entries</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PMCRAID_MAX_RESOURCES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">res_entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">queue</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">res_entries</span><span class="p">);</span>
		<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">res_entries</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pmcraid_release_hcams</span><span class="p">(</span><span class="n">pinstance</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_allocate_config_buffers - allocates DMAable memory for config table</span>
<span class="cm"> * @pinstance : pointer to per adapter instance structure</span>
<span class="cm"> *</span>
<span class="cm"> * Return Value</span>
<span class="cm"> *	0 for successful allocation, -ENOMEM for any failure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span>
<span class="nf">pmcraid_allocate_config_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">res_entries</span> <span class="o">=</span>
			<span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_resource_entry</span><span class="p">)</span> <span class="o">*</span>
				<span class="n">PMCRAID_MAX_RESOURCES</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">res_entries</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pmcraid_err</span><span class="p">(</span><span class="s">&quot;failed to allocate memory for resource table</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PMCRAID_MAX_RESOURCES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">res_entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">queue</span><span class="p">,</span>
			      <span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">free_res_q</span><span class="p">);</span>

	<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">cfg_table</span> <span class="o">=</span>
		<span class="n">pci_alloc_consistent</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
				     <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_config_table</span><span class="p">),</span>
				     <span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">cfg_table_bus_addr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">cfg_table</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pmcraid_err</span><span class="p">(</span><span class="s">&quot;couldn&#39;t alloc DMA memory for config table</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">pmcraid_release_config_buffers</span><span class="p">(</span><span class="n">pinstance</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pmcraid_allocate_hcams</span><span class="p">(</span><span class="n">pinstance</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pmcraid_err</span><span class="p">(</span><span class="s">&quot;could not alloc DMA memory for HCAMS</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">pmcraid_release_config_buffers</span><span class="p">(</span><span class="n">pinstance</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_init_tasklets - registers tasklets for response handling</span>
<span class="cm"> *</span>
<span class="cm"> * @pinstance: pointer adapter instance structure</span>
<span class="cm"> *</span>
<span class="cm"> * Return value</span>
<span class="cm"> *	none</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pmcraid_init_tasklets</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">num_hrrq</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">tasklet_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">isr_tasklet</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
			     <span class="n">pmcraid_tasklet_function</span><span class="p">,</span>
			     <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">hrrq_vector</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_kill_tasklets - destroys tasklets registered for response handling</span>
<span class="cm"> *</span>
<span class="cm"> * @pinstance: pointer to adapter instance structure</span>
<span class="cm"> *</span>
<span class="cm"> * Return value</span>
<span class="cm"> *	none</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pmcraid_kill_tasklets</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">num_hrrq</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">tasklet_kill</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">isr_tasklet</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_release_buffers - release per-adapter buffers allocated</span>
<span class="cm"> *</span>
<span class="cm"> * @pinstance: pointer to adapter soft state</span>
<span class="cm"> *</span>
<span class="cm"> * Return Value</span>
<span class="cm"> *	none</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pmcraid_release_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pmcraid_release_config_buffers</span><span class="p">(</span><span class="n">pinstance</span><span class="p">);</span>
	<span class="n">pmcraid_release_control_blocks</span><span class="p">(</span><span class="n">pinstance</span><span class="p">,</span> <span class="n">PMCRAID_MAX_CMD</span><span class="p">);</span>
	<span class="n">pmcraid_release_cmd_blocks</span><span class="p">(</span><span class="n">pinstance</span><span class="p">,</span> <span class="n">PMCRAID_MAX_CMD</span><span class="p">);</span>
	<span class="n">pmcraid_release_host_rrqs</span><span class="p">(</span><span class="n">pinstance</span><span class="p">,</span> <span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">num_hrrq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">inq_data</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
				    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_inquiry_data</span><span class="p">),</span>
				    <span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">inq_data</span><span class="p">,</span>
				    <span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">inq_data_baddr</span><span class="p">);</span>

		<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">inq_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">inq_data_baddr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">timestamp_data</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
				    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_timestamp_data</span><span class="p">),</span>
				    <span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">timestamp_data</span><span class="p">,</span>
				    <span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">timestamp_data_baddr</span><span class="p">);</span>

		<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">timestamp_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">timestamp_data_baddr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_init_buffers - allocates memory and initializes various structures</span>
<span class="cm"> * @pinstance: pointer to per adapter instance structure</span>
<span class="cm"> *</span>
<span class="cm"> * This routine pre-allocates memory based on the type of block as below:</span>
<span class="cm"> * cmdblocks(PMCRAID_MAX_CMD): kernel memory using kernel&#39;s slab_allocator,</span>
<span class="cm"> * IOARCBs(PMCRAID_MAX_CMD)  : DMAable memory, using pci pool allocator</span>
<span class="cm"> * config-table entries      : DMAable memory using pci_alloc_consistent</span>
<span class="cm"> * HostRRQs                  : DMAable memory, using pci_alloc_consistent</span>
<span class="cm"> *</span>
<span class="cm"> * Return Value</span>
<span class="cm"> *	 0 in case all of the blocks are allocated, -ENOMEM otherwise.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">pmcraid_init_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pmcraid_allocate_host_rrqs</span><span class="p">(</span><span class="n">pinstance</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pmcraid_err</span><span class="p">(</span><span class="s">&quot;couldn&#39;t allocate memory for %d host rrqs</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">num_hrrq</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pmcraid_allocate_config_buffers</span><span class="p">(</span><span class="n">pinstance</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pmcraid_err</span><span class="p">(</span><span class="s">&quot;couldn&#39;t allocate memory for config buffers</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">pmcraid_release_host_rrqs</span><span class="p">(</span><span class="n">pinstance</span><span class="p">,</span> <span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">num_hrrq</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pmcraid_allocate_cmd_blocks</span><span class="p">(</span><span class="n">pinstance</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pmcraid_err</span><span class="p">(</span><span class="s">&quot;couldn&#39;t allocate memory for cmd blocks</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">pmcraid_release_config_buffers</span><span class="p">(</span><span class="n">pinstance</span><span class="p">);</span>
		<span class="n">pmcraid_release_host_rrqs</span><span class="p">(</span><span class="n">pinstance</span><span class="p">,</span> <span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">num_hrrq</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pmcraid_allocate_control_blocks</span><span class="p">(</span><span class="n">pinstance</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pmcraid_err</span><span class="p">(</span><span class="s">&quot;couldn&#39;t allocate memory control blocks</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">pmcraid_release_config_buffers</span><span class="p">(</span><span class="n">pinstance</span><span class="p">);</span>
		<span class="n">pmcraid_release_cmd_blocks</span><span class="p">(</span><span class="n">pinstance</span><span class="p">,</span> <span class="n">PMCRAID_MAX_CMD</span><span class="p">);</span>
		<span class="n">pmcraid_release_host_rrqs</span><span class="p">(</span><span class="n">pinstance</span><span class="p">,</span> <span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">num_hrrq</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* allocate DMAable memory for page D0 INQUIRY buffer */</span>
	<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">inq_data</span> <span class="o">=</span> <span class="n">pci_alloc_consistent</span><span class="p">(</span>
					<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_inquiry_data</span><span class="p">),</span>
					<span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">inq_data_baddr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">inq_data</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pmcraid_err</span><span class="p">(</span><span class="s">&quot;couldn&#39;t allocate DMA memory for INQUIRY</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">pmcraid_release_buffers</span><span class="p">(</span><span class="n">pinstance</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* allocate DMAable memory for set timestamp data buffer */</span>
	<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">timestamp_data</span> <span class="o">=</span> <span class="n">pci_alloc_consistent</span><span class="p">(</span>
					<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_timestamp_data</span><span class="p">),</span>
					<span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">timestamp_data_baddr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">timestamp_data</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pmcraid_err</span><span class="p">(</span><span class="s">&quot;couldn&#39;t allocate DMA memory for \</span>
<span class="s">				set time_stamp </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">pmcraid_release_buffers</span><span class="p">(</span><span class="n">pinstance</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>


	<span class="cm">/* Initialize all the command blocks and add them to free pool. No</span>
<span class="cm">	 * need to lock (free_pool_lock) as this is done in initialization</span>
<span class="cm">	 * itself</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PMCRAID_MAX_CMD</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">pmcraid_cmd</span> <span class="o">*</span><span class="n">cmdp</span> <span class="o">=</span> <span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">cmd_list</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">pmcraid_init_cmdblk</span><span class="p">(</span><span class="n">cmdp</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">cmdp</span><span class="o">-&gt;</span><span class="n">drv_inst</span> <span class="o">=</span> <span class="n">pinstance</span><span class="p">;</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmdp</span><span class="o">-&gt;</span><span class="n">free_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">free_cmd_pool</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_reinit_buffers - resets various buffer pointers</span>
<span class="cm"> * @pinstance: pointer to adapter instance</span>
<span class="cm"> * Return value</span>
<span class="cm"> *	none</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pmcraid_reinit_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">buffer_size</span> <span class="o">=</span> <span class="n">HRRQ_ENTRY_SIZE</span> <span class="o">*</span> <span class="n">PMCRAID_MAX_CMD</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">num_hrrq</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">hrrq_start</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">buffer_size</span><span class="p">);</span>
		<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">hrrq_curr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">hrrq_start</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">hrrq_end</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>
			<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">hrrq_start</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">PMCRAID_MAX_CMD</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">host_toggle_bit</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_init_instance - initialize per instance data structure</span>
<span class="cm"> * @pdev: pointer to pci device structure</span>
<span class="cm"> * @host: pointer to Scsi_Host structure</span>
<span class="cm"> * @mapped_pci_addr: memory mapped IOA configuration registers</span>
<span class="cm"> *</span>
<span class="cm"> * Return Value</span>
<span class="cm"> *	 0 on success, non-zero in case of any failure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">pmcraid_init_instance</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">host</span><span class="p">,</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">mapped_pci_addr</span>
<span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span> <span class="o">=</span>
		<span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="p">)</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>

	<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">host</span> <span class="o">=</span> <span class="n">host</span><span class="p">;</span>
	<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">pdev</span><span class="p">;</span>

	<span class="cm">/* Initialize register addresses */</span>
	<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">mapped_dma_addr</span> <span class="o">=</span> <span class="n">mapped_pci_addr</span><span class="p">;</span>

	<span class="cm">/* Initialize chip-specific details */</span>
	<span class="p">{</span>
		<span class="k">struct</span> <span class="n">pmcraid_chip_details</span> <span class="o">*</span><span class="n">chip_cfg</span> <span class="o">=</span> <span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">chip_cfg</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">pmcraid_interrupts</span> <span class="o">*</span><span class="n">pint_regs</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">int_regs</span><span class="p">;</span>

		<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ioarrin</span> <span class="o">=</span> <span class="n">mapped_pci_addr</span> <span class="o">+</span> <span class="n">chip_cfg</span><span class="o">-&gt;</span><span class="n">ioarrin</span><span class="p">;</span>

		<span class="n">pint_regs</span><span class="o">-&gt;</span><span class="n">ioa_host_interrupt_reg</span> <span class="o">=</span>
			<span class="n">mapped_pci_addr</span> <span class="o">+</span> <span class="n">chip_cfg</span><span class="o">-&gt;</span><span class="n">ioa_host_intr</span><span class="p">;</span>
		<span class="n">pint_regs</span><span class="o">-&gt;</span><span class="n">ioa_host_interrupt_clr_reg</span> <span class="o">=</span>
			<span class="n">mapped_pci_addr</span> <span class="o">+</span> <span class="n">chip_cfg</span><span class="o">-&gt;</span><span class="n">ioa_host_intr_clr</span><span class="p">;</span>
		<span class="n">pint_regs</span><span class="o">-&gt;</span><span class="n">ioa_host_msix_interrupt_reg</span> <span class="o">=</span>
			<span class="n">mapped_pci_addr</span> <span class="o">+</span> <span class="n">chip_cfg</span><span class="o">-&gt;</span><span class="n">ioa_host_msix_intr</span><span class="p">;</span>
		<span class="n">pint_regs</span><span class="o">-&gt;</span><span class="n">host_ioa_interrupt_reg</span> <span class="o">=</span>
			<span class="n">mapped_pci_addr</span> <span class="o">+</span> <span class="n">chip_cfg</span><span class="o">-&gt;</span><span class="n">host_ioa_intr</span><span class="p">;</span>
		<span class="n">pint_regs</span><span class="o">-&gt;</span><span class="n">host_ioa_interrupt_clr_reg</span> <span class="o">=</span>
			<span class="n">mapped_pci_addr</span> <span class="o">+</span> <span class="n">chip_cfg</span><span class="o">-&gt;</span><span class="n">host_ioa_intr_clr</span><span class="p">;</span>

		<span class="cm">/* Current version of firmware exposes interrupt mask set</span>
<span class="cm">		 * and mask clr registers through memory mapped bar0.</span>
<span class="cm">		 */</span>
		<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">mailbox</span> <span class="o">=</span> <span class="n">mapped_pci_addr</span> <span class="o">+</span> <span class="n">chip_cfg</span><span class="o">-&gt;</span><span class="n">mailbox</span><span class="p">;</span>
		<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ioa_status</span> <span class="o">=</span> <span class="n">mapped_pci_addr</span> <span class="o">+</span> <span class="n">chip_cfg</span><span class="o">-&gt;</span><span class="n">ioastatus</span><span class="p">;</span>
		<span class="n">pint_regs</span><span class="o">-&gt;</span><span class="n">ioa_host_interrupt_mask_reg</span> <span class="o">=</span>
			<span class="n">mapped_pci_addr</span> <span class="o">+</span> <span class="n">chip_cfg</span><span class="o">-&gt;</span><span class="n">ioa_host_mask</span><span class="p">;</span>
		<span class="n">pint_regs</span><span class="o">-&gt;</span><span class="n">ioa_host_interrupt_mask_clr_reg</span> <span class="o">=</span>
			<span class="n">mapped_pci_addr</span> <span class="o">+</span> <span class="n">chip_cfg</span><span class="o">-&gt;</span><span class="n">ioa_host_mask_clr</span><span class="p">;</span>
		<span class="n">pint_regs</span><span class="o">-&gt;</span><span class="n">global_interrupt_mask_reg</span> <span class="o">=</span>
			<span class="n">mapped_pci_addr</span> <span class="o">+</span> <span class="n">chip_cfg</span><span class="o">-&gt;</span><span class="n">global_intr_mask</span><span class="p">;</span>
	<span class="p">};</span>

	<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ioa_reset_attempts</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">reset_wait_q</span><span class="p">);</span>

	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">outstanding_cmds</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">last_message_id</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">expose_resources</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">free_res_q</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">used_res_q</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">free_cmd_pool</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">pending_cmd_pool</span><span class="p">);</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">free_pool_lock</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">pending_pool_lock</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">resource_lock</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">aen_queue_lock</span><span class="p">);</span>

	<span class="cm">/* Work-queue (Shared) for deferred processing error handling */</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">worker_q</span><span class="p">,</span> <span class="n">pmcraid_worker_function</span><span class="p">);</span>

	<span class="cm">/* Initialize the default log_level */</span>
	<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">current_log_level</span> <span class="o">=</span> <span class="n">pmcraid_log_level</span><span class="p">;</span>

	<span class="cm">/* Setup variables required for reset engine */</span>
	<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ioa_state</span> <span class="o">=</span> <span class="n">IOA_STATE_UNKNOWN</span><span class="p">;</span>
	<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">reset_cmd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_shutdown - shutdown adapter controller.</span>
<span class="cm"> * @pdev: pci device struct</span>
<span class="cm"> *</span>
<span class="cm"> * Issues an adapter shutdown to the card waits for its completion</span>
<span class="cm"> *</span>
<span class="cm"> * Return value</span>
<span class="cm"> *	  none</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pmcraid_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">pmcraid_reset_bringdown</span><span class="p">(</span><span class="n">pinstance</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * pmcraid_get_minor - returns unused minor number from minor number bitmap</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="nf">pmcraid_get_minor</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">minor</span><span class="p">;</span>

	<span class="n">minor</span> <span class="o">=</span> <span class="n">find_first_zero_bit</span><span class="p">(</span><span class="n">pmcraid_minor</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pmcraid_minor</span><span class="p">));</span>
	<span class="n">__set_bit</span><span class="p">(</span><span class="n">minor</span><span class="p">,</span> <span class="n">pmcraid_minor</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">minor</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_release_minor - releases given minor back to minor number bitmap</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pmcraid_release_minor</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">minor</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__clear_bit</span><span class="p">(</span><span class="n">minor</span><span class="p">,</span> <span class="n">pmcraid_minor</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_setup_chrdev - allocates a minor number and registers a char device</span>
<span class="cm"> *</span>
<span class="cm"> * @pinstance: pointer to adapter instance for which to register device</span>
<span class="cm"> *</span>
<span class="cm"> * Return value</span>
<span class="cm"> *	0 in case of success, otherwise non-zero</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pmcraid_setup_chrdev</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">minor</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">minor</span> <span class="o">=</span> <span class="n">pmcraid_get_minor</span><span class="p">();</span>
	<span class="n">cdev_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pmcraid_fops</span><span class="p">);</span>
	<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">cdev_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">,</span> <span class="n">MKDEV</span><span class="p">(</span><span class="n">pmcraid_major</span><span class="p">,</span> <span class="n">minor</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="n">pmcraid_release_minor</span><span class="p">(</span><span class="n">minor</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">device_create</span><span class="p">(</span><span class="n">pmcraid_class</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">MKDEV</span><span class="p">(</span><span class="n">pmcraid_major</span><span class="p">,</span> <span class="n">minor</span><span class="p">),</span>
			      <span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;%s%u&quot;</span><span class="p">,</span> <span class="n">PMCRAID_DEVFILE</span><span class="p">,</span> <span class="n">minor</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_release_chrdev - unregisters per-adapter management interface</span>
<span class="cm"> *</span>
<span class="cm"> * @pinstance: pointer to adapter instance structure</span>
<span class="cm"> *</span>
<span class="cm"> * Return value</span>
<span class="cm"> *  none</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pmcraid_release_chrdev</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pmcraid_release_minor</span><span class="p">(</span><span class="n">MINOR</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">.</span><span class="n">dev</span><span class="p">));</span>
	<span class="n">device_destroy</span><span class="p">(</span><span class="n">pmcraid_class</span><span class="p">,</span>
		       <span class="n">MKDEV</span><span class="p">(</span><span class="n">pmcraid_major</span><span class="p">,</span> <span class="n">MINOR</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">.</span><span class="n">dev</span><span class="p">)));</span>
	<span class="n">cdev_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_remove - IOA hot plug remove entry point</span>
<span class="cm"> * @pdev: pci device struct</span>
<span class="cm"> *</span>
<span class="cm"> * Return value</span>
<span class="cm"> *	  none</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devexit</span> <span class="nf">pmcraid_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="cm">/* remove the management interface (/dev file) for this device */</span>
	<span class="n">pmcraid_release_chrdev</span><span class="p">(</span><span class="n">pinstance</span><span class="p">);</span>

	<span class="cm">/* remove host template from scsi midlayer */</span>
	<span class="n">scsi_remove_host</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>

	<span class="cm">/* block requests from mid-layer */</span>
	<span class="n">scsi_block_requests</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>

	<span class="cm">/* initiate shutdown adapter */</span>
	<span class="n">pmcraid_shutdown</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="n">pmcraid_disable_interrupts</span><span class="p">(</span><span class="n">pinstance</span><span class="p">,</span> <span class="o">~</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">flush_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">worker_q</span><span class="p">);</span>

	<span class="n">pmcraid_kill_tasklets</span><span class="p">(</span><span class="n">pinstance</span><span class="p">);</span>
	<span class="n">pmcraid_unregister_interrupt_handler</span><span class="p">(</span><span class="n">pinstance</span><span class="p">);</span>
	<span class="n">pmcraid_release_buffers</span><span class="p">(</span><span class="n">pinstance</span><span class="p">);</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">mapped_dma_addr</span><span class="p">);</span>
	<span class="n">pci_release_regions</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">scsi_host_put</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>
	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PM</span>
<span class="cm">/**</span>
<span class="cm"> * pmcraid_suspend - driver suspend entry point for power management</span>
<span class="cm"> * @pdev:   PCI device structure</span>
<span class="cm"> * @state:  PCI power state to suspend routine</span>
<span class="cm"> *</span>
<span class="cm"> * Return Value - 0 always</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pmcraid_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="n">pmcraid_shutdown</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">pmcraid_disable_interrupts</span><span class="p">(</span><span class="n">pinstance</span><span class="p">,</span> <span class="o">~</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">pmcraid_kill_tasklets</span><span class="p">(</span><span class="n">pinstance</span><span class="p">);</span>
	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">pinstance</span><span class="p">);</span>
	<span class="n">pmcraid_unregister_interrupt_handler</span><span class="p">(</span><span class="n">pinstance</span><span class="p">);</span>
	<span class="n">pci_save_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">pci_set_power_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">pci_choose_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">state</span><span class="p">));</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_resume - driver resume entry point PCI power management</span>
<span class="cm"> * @pdev: PCI device structure</span>
<span class="cm"> *</span>
<span class="cm"> * Return Value - 0 in case of success. Error code in case of any failure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pmcraid_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">host</span> <span class="o">=</span> <span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">pci_set_power_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_D0</span><span class="p">);</span>
	<span class="n">pci_enable_wake</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_D0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">pci_restore_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">pci_enable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;resume: Enable device failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pci_set_master</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="k">sizeof</span><span class="p">(</span><span class="n">dma_addr_t</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span> <span class="o">||</span>
	     <span class="n">pci_set_dma_mask</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">64</span><span class="p">)))</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">pci_set_dma_mask</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">32</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">pci_set_consistent_dma_mask</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">32</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;resume: Failed to set PCI DMA mask</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">disable_device</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pmcraid_disable_interrupts</span><span class="p">(</span><span class="n">pinstance</span><span class="p">,</span> <span class="o">~</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">outstanding_cmds</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">pmcraid_register_interrupt_handler</span><span class="p">(</span><span class="n">pinstance</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;resume: couldn&#39;t register interrupt handlers</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">release_host</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pmcraid_init_tasklets</span><span class="p">(</span><span class="n">pinstance</span><span class="p">);</span>
	<span class="n">pmcraid_enable_interrupts</span><span class="p">(</span><span class="n">pinstance</span><span class="p">,</span> <span class="n">PMCRAID_PCI_INTERRUPTS</span><span class="p">);</span>

	<span class="cm">/* Start with hard reset sequence which brings up IOA to operational</span>
<span class="cm">	 * state as well as completes the reset sequence.</span>
<span class="cm">	 */</span>
	<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">ioa_hard_reset</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Start IOA firmware initialization and bring card to Operational</span>
<span class="cm">	 * state.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pmcraid_reset_bringup</span><span class="p">(</span><span class="n">pinstance</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;couldn&#39;t initialize IOA</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">release_tasklets</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">release_tasklets:</span>
	<span class="n">pmcraid_disable_interrupts</span><span class="p">(</span><span class="n">pinstance</span><span class="p">,</span> <span class="o">~</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">pmcraid_kill_tasklets</span><span class="p">(</span><span class="n">pinstance</span><span class="p">);</span>
	<span class="n">pmcraid_unregister_interrupt_handler</span><span class="p">(</span><span class="n">pinstance</span><span class="p">);</span>

<span class="nl">release_host:</span>
	<span class="n">scsi_host_put</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>

<span class="nl">disable_device:</span>
	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#else</span>

<span class="cp">#define pmcraid_suspend NULL</span>
<span class="cp">#define pmcraid_resume  NULL</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_PM */</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_complete_ioa_reset - Called by either timer or tasklet during</span>
<span class="cm"> *				completion of the ioa reset</span>
<span class="cm"> * @cmd: pointer to reset command block</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pmcraid_complete_ioa_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">drv_inst</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">pmcraid_ioa_reset</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">scsi_unblock_requests</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>
	<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">worker_q</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_set_supported_devs - sends SET SUPPORTED DEVICES to IOAFP</span>
<span class="cm"> *</span>
<span class="cm"> * @cmd: pointer to pmcraid_cmd structure</span>
<span class="cm"> *</span>
<span class="cm"> * Return Value</span>
<span class="cm"> *  0 for success or non-zero for failure cases</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pmcraid_set_supported_devs</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pmcraid_ioarcb</span> <span class="o">*</span><span class="n">ioarcb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ioa_cb</span><span class="o">-&gt;</span><span class="n">ioarcb</span><span class="p">;</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">cmd_done</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_cmd</span> <span class="o">*</span><span class="p">)</span> <span class="o">=</span> <span class="n">pmcraid_complete_ioa_reset</span><span class="p">;</span>

	<span class="n">pmcraid_reinit_cmdblk</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>

	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">resource_handle</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">PMCRAID_IOA_RES_HANDLE</span><span class="p">);</span>
	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">request_type</span> <span class="o">=</span> <span class="n">REQ_TYPE_IOACMD</span><span class="p">;</span>
	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">cdb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">PMCRAID_SET_SUPPORTED_DEVICES</span><span class="p">;</span>
	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">cdb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ALL_DEVICES_SUPPORTED</span><span class="p">;</span>

	<span class="cm">/* If this was called as part of resource table reinitialization due to</span>
<span class="cm">	 * lost CCN, it is enough to return the command block back to free pool</span>
<span class="cm">	 * as part of set_supported_devs completion function.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">drv_inst</span><span class="o">-&gt;</span><span class="n">reinit_cfg_table</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">drv_inst</span><span class="o">-&gt;</span><span class="n">reinit_cfg_table</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">release</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">cmd_done</span> <span class="o">=</span> <span class="n">pmcraid_reinit_cfgtable_done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* we will be done with the reset sequence after set supported devices,</span>
<span class="cm">	 * setup the done function to return the command block back to free</span>
<span class="cm">	 * pool</span>
<span class="cm">	 */</span>
	<span class="n">pmcraid_send_cmd</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span>
			 <span class="n">cmd_done</span><span class="p">,</span>
			 <span class="n">PMCRAID_SET_SUP_DEV_TIMEOUT</span><span class="p">,</span>
			 <span class="n">pmcraid_timeout_handler</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_set_timestamp - set the timestamp to IOAFP</span>
<span class="cm"> *</span>
<span class="cm"> * @cmd: pointer to pmcraid_cmd structure</span>
<span class="cm"> *</span>
<span class="cm"> * Return Value</span>
<span class="cm"> *  0 for success or non-zero for failure cases</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pmcraid_set_timestamp</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">drv_inst</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pmcraid_ioarcb</span> <span class="o">*</span><span class="n">ioarcb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ioa_cb</span><span class="o">-&gt;</span><span class="n">ioarcb</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="n">time_stamp_len</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">PMCRAID_TIMESTAMP_LEN</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pmcraid_ioadl_desc</span> <span class="o">*</span><span class="n">ioadl</span> <span class="o">=</span> <span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">add_data</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">ioadl</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">timeval</span> <span class="n">tv</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">timestamp</span><span class="p">;</span>

	<span class="n">do_gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tv</span><span class="p">);</span>
	<span class="n">timestamp</span> <span class="o">=</span> <span class="n">tv</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">;</span>

	<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">timestamp_data</span><span class="o">-&gt;</span><span class="n">timestamp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">__u8</span><span class="p">)(</span><span class="n">timestamp</span><span class="p">);</span>
	<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">timestamp_data</span><span class="o">-&gt;</span><span class="n">timestamp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">__u8</span><span class="p">)((</span><span class="n">timestamp</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">timestamp_data</span><span class="o">-&gt;</span><span class="n">timestamp</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">__u8</span><span class="p">)((</span><span class="n">timestamp</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">);</span>
	<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">timestamp_data</span><span class="o">-&gt;</span><span class="n">timestamp</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">__u8</span><span class="p">)((</span><span class="n">timestamp</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">);</span>
	<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">timestamp_data</span><span class="o">-&gt;</span><span class="n">timestamp</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">__u8</span><span class="p">)((</span><span class="n">timestamp</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">);</span>
	<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">timestamp_data</span><span class="o">-&gt;</span><span class="n">timestamp</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">__u8</span><span class="p">)((</span><span class="n">timestamp</span><span class="p">)</span>  <span class="o">&gt;&gt;</span> <span class="mi">40</span><span class="p">);</span>

	<span class="n">pmcraid_reinit_cmdblk</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">request_type</span> <span class="o">=</span> <span class="n">REQ_TYPE_SCSI</span><span class="p">;</span>
	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">resource_handle</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">PMCRAID_IOA_RES_HANDLE</span><span class="p">);</span>
	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">cdb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">PMCRAID_SCSI_SET_TIMESTAMP</span><span class="p">;</span>
	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">cdb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">PMCRAID_SCSI_SERVICE_ACTION</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">cdb</span><span class="p">[</span><span class="mi">6</span><span class="p">]),</span> <span class="o">&amp;</span><span class="n">time_stamp_len</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">time_stamp_len</span><span class="p">));</span>

	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">ioadl_bus_addr</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">((</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ioa_cb_bus_addr</span><span class="p">)</span> <span class="o">+</span>
					<span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_ioarcb</span><span class="p">,</span>
						<span class="n">add_data</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">ioadl</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">ioadl_length</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_ioadl_desc</span><span class="p">));</span>
	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">ioarcb_bus_addr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mh">0x1FULL</span><span class="p">);</span>

	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">request_flags0</span> <span class="o">|=</span> <span class="n">NO_LINK_DESCS</span><span class="p">;</span>
	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">request_flags0</span> <span class="o">|=</span> <span class="n">TRANSFER_DIR_WRITE</span><span class="p">;</span>
	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">data_transfer_length</span> <span class="o">=</span>
		<span class="n">cpu_to_le32</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_timestamp_data</span><span class="p">));</span>
	<span class="n">ioadl</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">add_data</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">ioadl</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">ioadl</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">IOADL_FLAGS_LAST_DESC</span><span class="p">;</span>
	<span class="n">ioadl</span><span class="o">-&gt;</span><span class="n">address</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">timestamp_data_baddr</span><span class="p">);</span>
	<span class="n">ioadl</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_timestamp_data</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">timestamp_error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">timestamp_error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">pmcraid_send_cmd</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">pmcraid_set_supported_devs</span><span class="p">,</span>
			 <span class="n">PMCRAID_INTERNAL_TIMEOUT</span><span class="p">,</span> <span class="n">pmcraid_timeout_handler</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pmcraid_send_cmd</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">pmcraid_return_cmd</span><span class="p">,</span>
			 <span class="n">PMCRAID_INTERNAL_TIMEOUT</span><span class="p">,</span> <span class="n">pmcraid_timeout_handler</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * pmcraid_init_res_table - Initialize the resource table</span>
<span class="cm"> * @cmd:  pointer to pmcraid command struct</span>
<span class="cm"> *</span>
<span class="cm"> * This function looks through the existing resource table, comparing</span>
<span class="cm"> * it with the config table. This function will take care of old/new</span>
<span class="cm"> * devices and schedule adding/removing them from the mid-layer</span>
<span class="cm"> * as appropriate.</span>
<span class="cm"> *</span>
<span class="cm"> * Return value</span>
<span class="cm"> *	 None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pmcraid_init_res_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">drv_inst</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pmcraid_resource_entry</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span> <span class="o">*</span><span class="n">temp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pmcraid_config_table_entry</span> <span class="o">*</span><span class="n">cfgte</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lock_flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">found</span><span class="p">,</span> <span class="n">rc</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">fw_version</span><span class="p">;</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">old_res</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">cfg_table</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MICROCODE_UPDATE_REQUIRED</span><span class="p">)</span>
		<span class="n">pmcraid_err</span><span class="p">(</span><span class="s">&quot;IOA requires microcode download</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">fw_version</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">inq_data</span><span class="o">-&gt;</span><span class="n">fw_version</span><span class="p">);</span>

	<span class="cm">/* resource list is protected by pinstance-&gt;resource_lock.</span>
<span class="cm">	 * init_res_table can be called from probe (user-thread) or runtime</span>
<span class="cm">	 * reset (timer/tasklet)</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">resource_lock</span><span class="p">,</span> <span class="n">lock_flags</span><span class="p">);</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">used_res_q</span><span class="p">,</span> <span class="n">queue</span><span class="p">)</span>
		<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">old_res</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">cfg_table</span><span class="o">-&gt;</span><span class="n">num_entries</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">inq_data</span><span class="o">-&gt;</span><span class="n">fw_version</span><span class="p">)</span> <span class="o">&lt;=</span>
						<span class="n">PMCRAID_FW_VERSION_1</span><span class="p">)</span>
			<span class="n">cfgte</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">cfg_table</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">else</span>
			<span class="n">cfgte</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_config_table_entry</span> <span class="o">*</span><span class="p">)</span>
					<span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">cfg_table</span><span class="o">-&gt;</span><span class="n">entries_ext</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pmcraid_expose_resource</span><span class="p">(</span><span class="n">fw_version</span><span class="p">,</span> <span class="n">cfgte</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* If this entry was already detected and initialized */</span>
		<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">old_res</span><span class="p">,</span> <span class="n">queue</span><span class="p">)</span> <span class="p">{</span>

			<span class="n">rc</span> <span class="o">=</span> <span class="n">memcmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">cfg_entry</span><span class="p">.</span><span class="n">resource_address</span><span class="p">,</span>
				    <span class="o">&amp;</span><span class="n">cfgte</span><span class="o">-&gt;</span><span class="n">resource_address</span><span class="p">,</span>
				    <span class="k">sizeof</span><span class="p">(</span><span class="n">cfgte</span><span class="o">-&gt;</span><span class="n">resource_address</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">used_res_q</span><span class="p">);</span>
				<span class="n">found</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* If this is new entry, initialize it and add it the queue */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">found</span><span class="p">)</span> <span class="p">{</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">free_res_q</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">pmcraid_err</span><span class="p">(</span><span class="s">&quot;Too many devices attached</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">found</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">res</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">free_res_q</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">pmcraid_resource_entry</span><span class="p">,</span> <span class="n">queue</span><span class="p">);</span>

			<span class="n">res</span><span class="o">-&gt;</span><span class="n">scsi_dev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">res</span><span class="o">-&gt;</span><span class="n">change_detected</span> <span class="o">=</span> <span class="n">RES_CHANGE_ADD</span><span class="p">;</span>
			<span class="n">res</span><span class="o">-&gt;</span><span class="n">reset_progress</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">used_res_q</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* copy new configuration table entry details into driver</span>
<span class="cm">		 * maintained resource entry</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">found</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">cfg_entry</span><span class="p">,</span> <span class="n">cfgte</span><span class="p">,</span>
					<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">config_table_entry_size</span><span class="p">);</span>
			<span class="n">pmcraid_info</span><span class="p">(</span><span class="s">&quot;New res type:%x, vset:%x, addr:%x:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">res</span><span class="o">-&gt;</span><span class="n">cfg_entry</span><span class="p">.</span><span class="n">resource_type</span><span class="p">,</span>
				 <span class="p">(</span><span class="n">fw_version</span> <span class="o">&lt;=</span> <span class="n">PMCRAID_FW_VERSION_1</span> <span class="o">?</span>
					<span class="n">res</span><span class="o">-&gt;</span><span class="n">cfg_entry</span><span class="p">.</span><span class="n">unique_flags1</span> <span class="o">:</span>
						<span class="n">res</span><span class="o">-&gt;</span><span class="n">cfg_entry</span><span class="p">.</span><span class="n">array_id</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">),</span>
				 <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">cfg_entry</span><span class="p">.</span><span class="n">resource_address</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Detect any deleted entries, mark them for deletion from mid-layer */</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">old_res</span><span class="p">,</span> <span class="n">queue</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">scsi_dev</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">res</span><span class="o">-&gt;</span><span class="n">change_detected</span> <span class="o">=</span> <span class="n">RES_CHANGE_DEL</span><span class="p">;</span>
			<span class="n">res</span><span class="o">-&gt;</span><span class="n">cfg_entry</span><span class="p">.</span><span class="n">resource_handle</span> <span class="o">=</span>
				<span class="n">PMCRAID_INVALID_RES_HANDLE</span><span class="p">;</span>
			<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">used_res_q</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">free_res_q</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* release the resource list lock */</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">resource_lock</span><span class="p">,</span> <span class="n">lock_flags</span><span class="p">);</span>
	<span class="n">pmcraid_set_timestamp</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_querycfg - Send a Query IOA Config to the adapter.</span>
<span class="cm"> * @cmd: pointer pmcraid_cmd struct</span>
<span class="cm"> *</span>
<span class="cm"> * This function sends a Query IOA Configuration command to the adapter to</span>
<span class="cm"> * retrieve the IOA configuration table.</span>
<span class="cm"> *</span>
<span class="cm"> * Return value:</span>
<span class="cm"> *	none</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pmcraid_querycfg</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pmcraid_ioarcb</span> <span class="o">*</span><span class="n">ioarcb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ioa_cb</span><span class="o">-&gt;</span><span class="n">ioarcb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pmcraid_ioadl_desc</span> <span class="o">*</span><span class="n">ioadl</span> <span class="o">=</span> <span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">add_data</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">ioadl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">drv_inst</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cfg_table_size</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_config_table</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">inq_data</span><span class="o">-&gt;</span><span class="n">fw_version</span><span class="p">)</span> <span class="o">&lt;=</span>
					<span class="n">PMCRAID_FW_VERSION_1</span><span class="p">)</span>
		<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">config_table_entry_size</span> <span class="o">=</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_config_table_entry</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">config_table_entry_size</span> <span class="o">=</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_config_table_entry_ext</span><span class="p">);</span>

	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">request_type</span> <span class="o">=</span> <span class="n">REQ_TYPE_IOACMD</span><span class="p">;</span>
	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">resource_handle</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">PMCRAID_IOA_RES_HANDLE</span><span class="p">);</span>

	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">cdb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">PMCRAID_QUERY_IOA_CONFIG</span><span class="p">;</span>

	<span class="cm">/* firmware requires 4-byte length field, specified in B.E format */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">cdb</span><span class="p">[</span><span class="mi">10</span><span class="p">]),</span> <span class="o">&amp;</span><span class="n">cfg_table_size</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cfg_table_size</span><span class="p">));</span>

	<span class="cm">/* Since entire config table can be described by single IOADL, it can</span>
<span class="cm">	 * be part of IOARCB itself</span>
<span class="cm">	 */</span>
	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">ioadl_bus_addr</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">((</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ioa_cb_bus_addr</span><span class="p">)</span> <span class="o">+</span>
					<span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_ioarcb</span><span class="p">,</span>
						<span class="n">add_data</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">ioadl</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">ioadl_length</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_ioadl_desc</span><span class="p">));</span>
	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">ioarcb_bus_addr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mh">0x1FULL</span><span class="p">);</span>

	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">request_flags0</span> <span class="o">|=</span> <span class="n">NO_LINK_DESCS</span><span class="p">;</span>
	<span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">data_transfer_length</span> <span class="o">=</span>
		<span class="n">cpu_to_le32</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_config_table</span><span class="p">));</span>

	<span class="n">ioadl</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">ioarcb</span><span class="o">-&gt;</span><span class="n">add_data</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">ioadl</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">ioadl</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">IOADL_FLAGS_LAST_DESC</span><span class="p">;</span>
	<span class="n">ioadl</span><span class="o">-&gt;</span><span class="n">address</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">cfg_table_bus_addr</span><span class="p">);</span>
	<span class="n">ioadl</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_config_table</span><span class="p">));</span>

	<span class="n">pmcraid_send_cmd</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">pmcraid_init_res_table</span><span class="p">,</span>
			 <span class="n">PMCRAID_INTERNAL_TIMEOUT</span><span class="p">,</span> <span class="n">pmcraid_timeout_handler</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * pmcraid_probe - PCI probe entry pointer for PMC MaxRAID controller driver</span>
<span class="cm"> * @pdev: pointer to pci device structure</span>
<span class="cm"> * @dev_id: pointer to device ids structure</span>
<span class="cm"> *</span>
<span class="cm"> * Return Value</span>
<span class="cm"> *	returns 0 if the device is claimed and successfully configured.</span>
<span class="cm"> *	returns non-zero error code in case of any failure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">pmcraid_probe</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">dev_id</span>
<span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="n">pinstance</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">host</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">mapped_pci_addr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">PCIBIOS_SUCCESSFUL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pmcraid_adapter_count</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">PMCRAID_MAX_ADAPTERS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pmcraid_err</span>
			<span class="p">(</span><span class="s">&quot;maximum number(%d) of supported adapters reached</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pmcraid_adapter_count</span><span class="p">));</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pmcraid_adapter_count</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">pci_enable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Cannot enable adapter</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pmcraid_adapter_count</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;Found new IOA(%x:%x), Total IOA count: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">vendor</span><span class="p">,</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span>
		 <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pmcraid_adapter_count</span><span class="p">));</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">pci_request_regions</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PMCRAID_DRIVER_NAME</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;Couldn&#39;t register memory range of registers</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_disable_device</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mapped_pci_addr</span> <span class="o">=</span> <span class="n">pci_iomap</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mapped_pci_addr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Couldn&#39;t map PCI registers memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_release_regions</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pci_set_master</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="cm">/* Firmware requires the system bus address of IOARCB to be within</span>
<span class="cm">	 * 32-bit addressable range though it has 64-bit IOARRIN register.</span>
<span class="cm">	 * However, firmware supports 64-bit streaming DMA buffers, whereas</span>
<span class="cm">	 * coherent buffers are to be 32-bit. Since pci_alloc_consistent always</span>
<span class="cm">	 * returns memory within 4GB (if not, change this logic), coherent</span>
<span class="cm">	 * buffers are within firmware acceptable address ranges.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="k">sizeof</span><span class="p">(</span><span class="n">dma_addr_t</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">pci_set_dma_mask</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">64</span><span class="p">)))</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">pci_set_dma_mask</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">32</span><span class="p">));</span>

	<span class="cm">/* firmware expects 32-bit DMA addresses for IOARRIN register; set 32</span>
<span class="cm">	 * bit mask for pci_alloc_consistent to return addresses within 4GB</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">pci_set_consistent_dma_mask</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">32</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Failed to set PCI DMA mask</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">cleanup_nomem</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">host</span> <span class="o">=</span> <span class="n">scsi_host_alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pmcraid_host_template</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_instance</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">host</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;scsi_host_alloc failed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">cleanup_nomem</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">host</span><span class="o">-&gt;</span><span class="n">max_id</span> <span class="o">=</span> <span class="n">PMCRAID_MAX_NUM_TARGETS_PER_BUS</span><span class="p">;</span>
	<span class="n">host</span><span class="o">-&gt;</span><span class="n">max_lun</span> <span class="o">=</span> <span class="n">PMCRAID_MAX_NUM_LUNS_PER_TARGET</span><span class="p">;</span>
	<span class="n">host</span><span class="o">-&gt;</span><span class="n">unique_id</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">;</span>
	<span class="n">host</span><span class="o">-&gt;</span><span class="n">max_channel</span> <span class="o">=</span> <span class="n">PMCRAID_MAX_BUS_TO_SCAN</span><span class="p">;</span>
	<span class="n">host</span><span class="o">-&gt;</span><span class="n">max_cmd_len</span> <span class="o">=</span> <span class="n">PMCRAID_MAX_CDB_LEN</span><span class="p">;</span>

	<span class="cm">/* zero out entire instance structure */</span>
	<span class="n">pinstance</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_instance</span> <span class="o">*</span><span class="p">)</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">pinstance</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">pinstance</span><span class="p">));</span>

	<span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">chip_cfg</span> <span class="o">=</span>
		<span class="p">(</span><span class="k">struct</span> <span class="n">pmcraid_chip_details</span> <span class="o">*</span><span class="p">)(</span><span class="n">dev_id</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">pmcraid_init_instance</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">host</span><span class="p">,</span> <span class="n">mapped_pci_addr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed to initialize adapter instance</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_scsi_host_put</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">pinstance</span><span class="p">);</span>

	<span class="cm">/* Save PCI config-space for use following the reset */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">pci_save_state</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Failed to save PCI config space</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_scsi_host_put</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pmcraid_disable_interrupts</span><span class="p">(</span><span class="n">pinstance</span><span class="p">,</span> <span class="o">~</span><span class="mi">0</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">pmcraid_register_interrupt_handler</span><span class="p">(</span><span class="n">pinstance</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;couldn&#39;t register interrupt handler</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_scsi_host_put</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pmcraid_init_tasklets</span><span class="p">(</span><span class="n">pinstance</span><span class="p">);</span>

	<span class="cm">/* allocate verious buffers used by LLD.*/</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">pmcraid_init_buffers</span><span class="p">(</span><span class="n">pinstance</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pmcraid_err</span><span class="p">(</span><span class="s">&quot;couldn&#39;t allocate memory blocks</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_unregister_isr</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* check the reset type required */</span>
	<span class="n">pmcraid_reset_type</span><span class="p">(</span><span class="n">pinstance</span><span class="p">);</span>

	<span class="n">pmcraid_enable_interrupts</span><span class="p">(</span><span class="n">pinstance</span><span class="p">,</span> <span class="n">PMCRAID_PCI_INTERRUPTS</span><span class="p">);</span>

	<span class="cm">/* Start IOA firmware initialization and bring card to Operational</span>
<span class="cm">	 * state.</span>
<span class="cm">	 */</span>
	<span class="n">pmcraid_info</span><span class="p">(</span><span class="s">&quot;starting IOA initialization sequence</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pmcraid_reset_bringup</span><span class="p">(</span><span class="n">pinstance</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;couldn&#39;t initialize IOA</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_release_bufs</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Add adapter instance into mid-layer list */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">scsi_add_host</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pmcraid_err</span><span class="p">(</span><span class="s">&quot;couldn&#39;t add host into mid-layer: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_release_bufs</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">scsi_scan_host</span><span class="p">(</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">pmcraid_setup_chrdev</span><span class="p">(</span><span class="n">pinstance</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pmcraid_err</span><span class="p">(</span><span class="s">&quot;couldn&#39;t create mgmt interface, error: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">rc</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_remove_host</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Schedule worker thread to handle CCN and take care of adding and</span>
<span class="cm">	 * removing devices to OS</span>
<span class="cm">	 */</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">expose_resources</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinstance</span><span class="o">-&gt;</span><span class="n">worker_q</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

<span class="nl">out_remove_host:</span>
	<span class="n">scsi_remove_host</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>

<span class="nl">out_release_bufs:</span>
	<span class="n">pmcraid_release_buffers</span><span class="p">(</span><span class="n">pinstance</span><span class="p">);</span>

<span class="nl">out_unregister_isr:</span>
	<span class="n">pmcraid_kill_tasklets</span><span class="p">(</span><span class="n">pinstance</span><span class="p">);</span>
	<span class="n">pmcraid_unregister_interrupt_handler</span><span class="p">(</span><span class="n">pinstance</span><span class="p">);</span>

<span class="nl">out_scsi_host_put:</span>
	<span class="n">scsi_host_put</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>

<span class="nl">cleanup_nomem:</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">mapped_pci_addr</span><span class="p">);</span>

<span class="nl">out_release_regions:</span>
	<span class="n">pci_release_regions</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

<span class="nl">out_disable_device:</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pmcraid_adapter_count</span><span class="p">);</span>
	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * PCI driver structure of pcmraid driver</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_driver</span> <span class="n">pmcraid_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">PMCRAID_DRIVER_NAME</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_table</span> <span class="o">=</span> <span class="n">pmcraid_pci_table</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span> <span class="o">=</span> <span class="n">pmcraid_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span> <span class="o">=</span> <span class="n">pmcraid_remove</span><span class="p">,</span>
	<span class="p">.</span><span class="n">suspend</span> <span class="o">=</span> <span class="n">pmcraid_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span> <span class="o">=</span> <span class="n">pmcraid_resume</span><span class="p">,</span>
	<span class="p">.</span><span class="n">shutdown</span> <span class="o">=</span> <span class="n">pmcraid_shutdown</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_init - module load entry point</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">pmcraid_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev_t</span> <span class="n">dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">pmcraid_info</span><span class="p">(</span><span class="s">&quot;%s Device Driver version: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">PMCRAID_DRIVER_NAME</span><span class="p">,</span> <span class="n">PMCRAID_DRIVER_VERSION</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">alloc_chrdev_region</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				    <span class="n">PMCRAID_MAX_ADAPTERS</span><span class="p">,</span>
				    <span class="n">PMCRAID_DEVFILE</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pmcraid_err</span><span class="p">(</span><span class="s">&quot;failed to get a major number for adapters</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_init</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pmcraid_major</span> <span class="o">=</span> <span class="n">MAJOR</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">pmcraid_class</span> <span class="o">=</span> <span class="n">class_create</span><span class="p">(</span><span class="n">THIS_MODULE</span><span class="p">,</span> <span class="n">PMCRAID_DEVFILE</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">pmcraid_class</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">pmcraid_class</span><span class="p">);</span>
		<span class="n">pmcraid_err</span><span class="p">(</span><span class="s">&quot;failed to register with with sysfs, error = %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			    <span class="n">error</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_unreg_chrdev</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">pmcraid_netlink_init</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unreg_chrdev</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">pci_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pmcraid_driver</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_init</span><span class="p">;</span>

	<span class="n">pmcraid_err</span><span class="p">(</span><span class="s">&quot;failed to register pmcraid driver, error = %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">error</span><span class="p">);</span>
	<span class="n">class_destroy</span><span class="p">(</span><span class="n">pmcraid_class</span><span class="p">);</span>
	<span class="n">pmcraid_netlink_release</span><span class="p">();</span>

<span class="nl">out_unreg_chrdev:</span>
	<span class="n">unregister_chrdev_region</span><span class="p">(</span><span class="n">MKDEV</span><span class="p">(</span><span class="n">pmcraid_major</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">PMCRAID_MAX_ADAPTERS</span><span class="p">);</span>

<span class="nl">out_init:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pmcraid_exit - module unload entry point</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">pmcraid_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pmcraid_netlink_release</span><span class="p">();</span>
	<span class="n">unregister_chrdev_region</span><span class="p">(</span><span class="n">MKDEV</span><span class="p">(</span><span class="n">pmcraid_major</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
				 <span class="n">PMCRAID_MAX_ADAPTERS</span><span class="p">);</span>
	<span class="n">pci_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pmcraid_driver</span><span class="p">);</span>
	<span class="n">class_destroy</span><span class="p">(</span><span class="n">pmcraid_class</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">pmcraid_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">pmcraid_exit</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
