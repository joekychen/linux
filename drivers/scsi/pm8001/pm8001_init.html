<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › scsi › pm8001 › pm8001_init.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>pm8001_init.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * PMC-Sierra SPC 8001 SAS/SATA based host adapters driver</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2008-2009 USI Co., Ltd.</span>
<span class="cm"> * All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * Redistribution and use in source and binary forms, with or without</span>
<span class="cm"> * modification, are permitted provided that the following conditions</span>
<span class="cm"> * are met:</span>
<span class="cm"> * 1. Redistributions of source code must retain the above copyright</span>
<span class="cm"> *    notice, this list of conditions, and the following disclaimer,</span>
<span class="cm"> *    without modification.</span>
<span class="cm"> * 2. Redistributions in binary form must reproduce at minimum a disclaimer</span>
<span class="cm"> *    substantially similar to the &quot;NO WARRANTY&quot; disclaimer below</span>
<span class="cm"> *    (&quot;Disclaimer&quot;) and any redistribution must be conditioned upon</span>
<span class="cm"> *    including a substantially similar Disclaimer requirement for further</span>
<span class="cm"> *    binary redistribution.</span>
<span class="cm"> * 3. Neither the names of the above-listed copyright holders nor the names</span>
<span class="cm"> *    of any contributors may be used to endorse or promote products derived</span>
<span class="cm"> *    from this software without specific prior written permission.</span>
<span class="cm"> *</span>
<span class="cm"> * Alternatively, this software may be distributed under the terms of the</span>
<span class="cm"> * GNU General Public License (&quot;GPL&quot;) version 2 as published by the Free</span>
<span class="cm"> * Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * NO WARRANTY</span>
<span class="cm"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span>
<span class="cm"> * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span>
<span class="cm"> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR</span>
<span class="cm"> * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</span>
<span class="cm"> * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</span>
<span class="cm"> * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</span>
<span class="cm"> * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</span>
<span class="cm"> * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,</span>
<span class="cm"> * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING</span>
<span class="cm"> * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</span>
<span class="cm"> * POSSIBILITY OF SUCH DAMAGES.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &quot;pm8001_sas.h&quot;</span>
<span class="cp">#include &quot;pm8001_chips.h&quot;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">scsi_transport_template</span> <span class="o">*</span><span class="n">pm8001_stt</span><span class="p">;</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">pm8001_chip_info</span> <span class="n">pm8001_chips</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">chip_8001</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>  <span class="mi">8</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pm8001_8001_dispatch</span><span class="p">,},</span>
<span class="p">};</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">pm8001_id</span><span class="p">;</span>

<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">hba_list</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">pm8001_wq</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * The main structure which LLDD must register for scsi core.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">scsi_host_template</span> <span class="n">pm8001_sht</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">module</span>			<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span>			<span class="o">=</span> <span class="n">DRV_NAME</span><span class="p">,</span>
	<span class="p">.</span><span class="n">queuecommand</span>		<span class="o">=</span> <span class="n">sas_queuecommand</span><span class="p">,</span>
	<span class="p">.</span><span class="n">target_alloc</span>		<span class="o">=</span> <span class="n">sas_target_alloc</span><span class="p">,</span>
	<span class="p">.</span><span class="n">slave_configure</span>	<span class="o">=</span> <span class="n">sas_slave_configure</span><span class="p">,</span>
	<span class="p">.</span><span class="n">scan_finished</span>		<span class="o">=</span> <span class="n">pm8001_scan_finished</span><span class="p">,</span>
	<span class="p">.</span><span class="n">scan_start</span>		<span class="o">=</span> <span class="n">pm8001_scan_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">change_queue_depth</span>	<span class="o">=</span> <span class="n">sas_change_queue_depth</span><span class="p">,</span>
	<span class="p">.</span><span class="n">change_queue_type</span>	<span class="o">=</span> <span class="n">sas_change_queue_type</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bios_param</span>		<span class="o">=</span> <span class="n">sas_bios_param</span><span class="p">,</span>
	<span class="p">.</span><span class="n">can_queue</span>		<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cmd_per_lun</span>		<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">this_id</span>		<span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sg_tablesize</span>		<span class="o">=</span> <span class="n">SG_ALL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">max_sectors</span>		<span class="o">=</span> <span class="n">SCSI_DEFAULT_MAX_SECTORS</span><span class="p">,</span>
	<span class="p">.</span><span class="n">use_clustering</span>		<span class="o">=</span> <span class="n">ENABLE_CLUSTERING</span><span class="p">,</span>
	<span class="p">.</span><span class="n">eh_device_reset_handler</span> <span class="o">=</span> <span class="n">sas_eh_device_reset_handler</span><span class="p">,</span>
	<span class="p">.</span><span class="n">eh_bus_reset_handler</span>	<span class="o">=</span> <span class="n">sas_eh_bus_reset_handler</span><span class="p">,</span>
	<span class="p">.</span><span class="n">target_destroy</span>		<span class="o">=</span> <span class="n">sas_target_destroy</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ioctl</span>			<span class="o">=</span> <span class="n">sas_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">shost_attrs</span>		<span class="o">=</span> <span class="n">pm8001_host_attrs</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * Sas layer call this function to execute specific task.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sas_domain_function_template</span> <span class="n">pm8001_transport_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">lldd_dev_found</span>		<span class="o">=</span> <span class="n">pm8001_dev_found</span><span class="p">,</span>
	<span class="p">.</span><span class="n">lldd_dev_gone</span>		<span class="o">=</span> <span class="n">pm8001_dev_gone</span><span class="p">,</span>

	<span class="p">.</span><span class="n">lldd_execute_task</span>	<span class="o">=</span> <span class="n">pm8001_queue_command</span><span class="p">,</span>
	<span class="p">.</span><span class="n">lldd_control_phy</span>	<span class="o">=</span> <span class="n">pm8001_phy_control</span><span class="p">,</span>

	<span class="p">.</span><span class="n">lldd_abort_task</span>	<span class="o">=</span> <span class="n">pm8001_abort_task</span><span class="p">,</span>
	<span class="p">.</span><span class="n">lldd_abort_task_set</span>	<span class="o">=</span> <span class="n">pm8001_abort_task_set</span><span class="p">,</span>
	<span class="p">.</span><span class="n">lldd_clear_aca</span>		<span class="o">=</span> <span class="n">pm8001_clear_aca</span><span class="p">,</span>
	<span class="p">.</span><span class="n">lldd_clear_task_set</span>	<span class="o">=</span> <span class="n">pm8001_clear_task_set</span><span class="p">,</span>
	<span class="p">.</span><span class="n">lldd_I_T_nexus_reset</span>   <span class="o">=</span> <span class="n">pm8001_I_T_nexus_reset</span><span class="p">,</span>
	<span class="p">.</span><span class="n">lldd_lu_reset</span>		<span class="o">=</span> <span class="n">pm8001_lu_reset</span><span class="p">,</span>
	<span class="p">.</span><span class="n">lldd_query_task</span>	<span class="o">=</span> <span class="n">pm8001_query_task</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> *pm8001_phy_init - initiate our adapter phys</span>
<span class="cm"> *@pm8001_ha: our hba structure.</span>
<span class="cm"> *@phy_id: phy id.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">pm8001_phy_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">pm8001_hba_info</span> <span class="o">*</span><span class="n">pm8001_ha</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">phy_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pm8001_phy</span> <span class="o">*</span><span class="n">phy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">[</span><span class="n">phy_id</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">asd_sas_phy</span> <span class="o">*</span><span class="n">sas_phy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">sas_phy</span><span class="p">;</span>
	<span class="n">phy</span><span class="o">-&gt;</span><span class="n">phy_state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">phy</span><span class="o">-&gt;</span><span class="n">pm8001_ha</span> <span class="o">=</span> <span class="n">pm8001_ha</span><span class="p">;</span>
	<span class="n">sas_phy</span><span class="o">-&gt;</span><span class="n">enabled</span> <span class="o">=</span> <span class="p">(</span><span class="n">phy_id</span> <span class="o">&lt;</span> <span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">n_phy</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sas_phy</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">=</span> <span class="n">SAS</span><span class="p">;</span>
	<span class="n">sas_phy</span><span class="o">-&gt;</span><span class="n">iproto</span> <span class="o">=</span> <span class="n">SAS_PROTOCOL_ALL</span><span class="p">;</span>
	<span class="n">sas_phy</span><span class="o">-&gt;</span><span class="n">tproto</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sas_phy</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">PHY_TYPE_PHYSICAL</span><span class="p">;</span>
	<span class="n">sas_phy</span><span class="o">-&gt;</span><span class="n">role</span> <span class="o">=</span> <span class="n">PHY_ROLE_INITIATOR</span><span class="p">;</span>
	<span class="n">sas_phy</span><span class="o">-&gt;</span><span class="n">oob_mode</span> <span class="o">=</span> <span class="n">OOB_NOT_CONNECTED</span><span class="p">;</span>
	<span class="n">sas_phy</span><span class="o">-&gt;</span><span class="n">linkrate</span> <span class="o">=</span> <span class="n">SAS_LINK_RATE_UNKNOWN</span><span class="p">;</span>
	<span class="n">sas_phy</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">=</span> <span class="n">phy_id</span><span class="p">;</span>
	<span class="n">sas_phy</span><span class="o">-&gt;</span><span class="n">sas_addr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">sas_addr</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">sas_phy</span><span class="o">-&gt;</span><span class="n">frame_rcvd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">frame_rcvd</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">sas_phy</span><span class="o">-&gt;</span><span class="n">ha</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sas_ha_struct</span> <span class="o">*</span><span class="p">)</span><span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="n">sas_phy</span><span class="o">-&gt;</span><span class="n">lldd_phy</span> <span class="o">=</span> <span class="n">phy</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *pm8001_free - free hba</span>
<span class="cm"> *@pm8001_ha:	our hba structure.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pm8001_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">pm8001_hba_info</span> <span class="o">*</span><span class="n">pm8001_ha</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pm8001_ha</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">USI_MAX_MEMCNT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">memoryMap</span><span class="p">.</span><span class="n">region</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">virt_ptr</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
				<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">memoryMap</span><span class="p">.</span><span class="n">region</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">element_size</span><span class="p">,</span>
				<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">memoryMap</span><span class="p">.</span><span class="n">region</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">virt_ptr</span><span class="p">,</span>
				<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">memoryMap</span><span class="p">.</span><span class="n">region</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">phys_addr</span><span class="p">);</span>
			<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">PM8001_CHIP_DISP</span><span class="o">-&gt;</span><span class="n">chip_iounmap</span><span class="p">(</span><span class="n">pm8001_ha</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">shost</span><span class="p">)</span>
		<span class="n">scsi_host_put</span><span class="p">(</span><span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">shost</span><span class="p">);</span>
	<span class="n">flush_workqueue</span><span class="p">(</span><span class="n">pm8001_wq</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">tags</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">pm8001_ha</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef PM8001_USE_TASKLET</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pm8001_tasklet</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">opaque</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pm8001_hba_info</span> <span class="o">*</span><span class="n">pm8001_ha</span><span class="p">;</span>
	<span class="n">pm8001_ha</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pm8001_hba_info</span> <span class="o">*</span><span class="p">)</span><span class="n">opaque</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">pm8001_ha</span><span class="p">))</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">PM8001_CHIP_DISP</span><span class="o">-&gt;</span><span class="n">isr</span><span class="p">(</span><span class="n">pm8001_ha</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>


 <span class="cm">/**</span>
<span class="cm">  * pm8001_interrupt - when HBA originate a interrupt,we should invoke this</span>
<span class="cm">  * dispatcher to handle each case.</span>
<span class="cm">  * @irq: irq number.</span>
<span class="cm">  * @opaque: the passed general host adapter struct</span>
<span class="cm">  */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">pm8001_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">opaque</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pm8001_hba_info</span> <span class="o">*</span><span class="n">pm8001_ha</span><span class="p">;</span>
	<span class="n">irqreturn_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sas_ha_struct</span> <span class="o">*</span><span class="n">sha</span> <span class="o">=</span> <span class="n">opaque</span><span class="p">;</span>
	<span class="n">pm8001_ha</span> <span class="o">=</span> <span class="n">sha</span><span class="o">-&gt;</span><span class="n">lldd_ha</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">pm8001_ha</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PM8001_CHIP_DISP</span><span class="o">-&gt;</span><span class="n">is_our_interupt</span><span class="p">(</span><span class="n">pm8001_ha</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>
<span class="cp">#ifdef PM8001_USE_TASKLET</span>
	<span class="n">tasklet_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">tasklet</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">PM8001_CHIP_DISP</span><span class="o">-&gt;</span><span class="n">isr</span><span class="p">(</span><span class="n">pm8001_ha</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pm8001_alloc - initiate our hba structure and 6 DMAs area.</span>
<span class="cm"> * @pm8001_ha:our hba structure.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">pm8001_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">pm8001_hba_info</span> <span class="o">*</span><span class="n">pm8001_ha</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">n_phy</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pm8001_phy_init</span><span class="p">(</span><span class="n">pm8001_ha</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">wide_port_phymap</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">port_attached</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">port_state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">list</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">tags</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">PM8001_MAX_CCB</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">tags</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
	<span class="cm">/* MPI Memory region 1 for AAP Event Log for fw */</span>
	<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">memoryMap</span><span class="p">.</span><span class="n">region</span><span class="p">[</span><span class="n">AAP1</span><span class="p">].</span><span class="n">num_elements</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">memoryMap</span><span class="p">.</span><span class="n">region</span><span class="p">[</span><span class="n">AAP1</span><span class="p">].</span><span class="n">element_size</span> <span class="o">=</span> <span class="n">PM8001_EVENT_LOG_SIZE</span><span class="p">;</span>
	<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">memoryMap</span><span class="p">.</span><span class="n">region</span><span class="p">[</span><span class="n">AAP1</span><span class="p">].</span><span class="n">total_len</span> <span class="o">=</span> <span class="n">PM8001_EVENT_LOG_SIZE</span><span class="p">;</span>
	<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">memoryMap</span><span class="p">.</span><span class="n">region</span><span class="p">[</span><span class="n">AAP1</span><span class="p">].</span><span class="n">alignment</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>

	<span class="cm">/* MPI Memory region 2 for IOP Event Log for fw */</span>
	<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">memoryMap</span><span class="p">.</span><span class="n">region</span><span class="p">[</span><span class="n">IOP</span><span class="p">].</span><span class="n">num_elements</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">memoryMap</span><span class="p">.</span><span class="n">region</span><span class="p">[</span><span class="n">IOP</span><span class="p">].</span><span class="n">element_size</span> <span class="o">=</span> <span class="n">PM8001_EVENT_LOG_SIZE</span><span class="p">;</span>
	<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">memoryMap</span><span class="p">.</span><span class="n">region</span><span class="p">[</span><span class="n">IOP</span><span class="p">].</span><span class="n">total_len</span> <span class="o">=</span> <span class="n">PM8001_EVENT_LOG_SIZE</span><span class="p">;</span>
	<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">memoryMap</span><span class="p">.</span><span class="n">region</span><span class="p">[</span><span class="n">IOP</span><span class="p">].</span><span class="n">alignment</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>

	<span class="cm">/* MPI Memory region 3 for consumer Index of inbound queues */</span>
	<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">memoryMap</span><span class="p">.</span><span class="n">region</span><span class="p">[</span><span class="n">CI</span><span class="p">].</span><span class="n">num_elements</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">memoryMap</span><span class="p">.</span><span class="n">region</span><span class="p">[</span><span class="n">CI</span><span class="p">].</span><span class="n">element_size</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">memoryMap</span><span class="p">.</span><span class="n">region</span><span class="p">[</span><span class="n">CI</span><span class="p">].</span><span class="n">total_len</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">memoryMap</span><span class="p">.</span><span class="n">region</span><span class="p">[</span><span class="n">CI</span><span class="p">].</span><span class="n">alignment</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>

	<span class="cm">/* MPI Memory region 4 for producer Index of outbound queues */</span>
	<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">memoryMap</span><span class="p">.</span><span class="n">region</span><span class="p">[</span><span class="n">PI</span><span class="p">].</span><span class="n">num_elements</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">memoryMap</span><span class="p">.</span><span class="n">region</span><span class="p">[</span><span class="n">PI</span><span class="p">].</span><span class="n">element_size</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">memoryMap</span><span class="p">.</span><span class="n">region</span><span class="p">[</span><span class="n">PI</span><span class="p">].</span><span class="n">total_len</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">memoryMap</span><span class="p">.</span><span class="n">region</span><span class="p">[</span><span class="n">PI</span><span class="p">].</span><span class="n">alignment</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>

	<span class="cm">/* MPI Memory region 5 inbound queues */</span>
	<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">memoryMap</span><span class="p">.</span><span class="n">region</span><span class="p">[</span><span class="n">IB</span><span class="p">].</span><span class="n">num_elements</span> <span class="o">=</span> <span class="n">PM8001_MPI_QUEUE</span><span class="p">;</span>
	<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">memoryMap</span><span class="p">.</span><span class="n">region</span><span class="p">[</span><span class="n">IB</span><span class="p">].</span><span class="n">element_size</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>
	<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">memoryMap</span><span class="p">.</span><span class="n">region</span><span class="p">[</span><span class="n">IB</span><span class="p">].</span><span class="n">total_len</span> <span class="o">=</span> <span class="n">PM8001_MPI_QUEUE</span> <span class="o">*</span> <span class="mi">64</span><span class="p">;</span>
	<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">memoryMap</span><span class="p">.</span><span class="n">region</span><span class="p">[</span><span class="n">IB</span><span class="p">].</span><span class="n">alignment</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>

	<span class="cm">/* MPI Memory region 6 outbound queues */</span>
	<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">memoryMap</span><span class="p">.</span><span class="n">region</span><span class="p">[</span><span class="n">OB</span><span class="p">].</span><span class="n">num_elements</span> <span class="o">=</span> <span class="n">PM8001_MPI_QUEUE</span><span class="p">;</span>
	<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">memoryMap</span><span class="p">.</span><span class="n">region</span><span class="p">[</span><span class="n">OB</span><span class="p">].</span><span class="n">element_size</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>
	<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">memoryMap</span><span class="p">.</span><span class="n">region</span><span class="p">[</span><span class="n">OB</span><span class="p">].</span><span class="n">total_len</span> <span class="o">=</span> <span class="n">PM8001_MPI_QUEUE</span> <span class="o">*</span> <span class="mi">64</span><span class="p">;</span>
	<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">memoryMap</span><span class="p">.</span><span class="n">region</span><span class="p">[</span><span class="n">OB</span><span class="p">].</span><span class="n">alignment</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>

	<span class="cm">/* Memory region write DMA*/</span>
	<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">memoryMap</span><span class="p">.</span><span class="n">region</span><span class="p">[</span><span class="n">NVMD</span><span class="p">].</span><span class="n">num_elements</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">memoryMap</span><span class="p">.</span><span class="n">region</span><span class="p">[</span><span class="n">NVMD</span><span class="p">].</span><span class="n">element_size</span> <span class="o">=</span> <span class="mi">4096</span><span class="p">;</span>
	<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">memoryMap</span><span class="p">.</span><span class="n">region</span><span class="p">[</span><span class="n">NVMD</span><span class="p">].</span><span class="n">total_len</span> <span class="o">=</span> <span class="mi">4096</span><span class="p">;</span>
	<span class="cm">/* Memory region for devices*/</span>
	<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">memoryMap</span><span class="p">.</span><span class="n">region</span><span class="p">[</span><span class="n">DEV_MEM</span><span class="p">].</span><span class="n">num_elements</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">memoryMap</span><span class="p">.</span><span class="n">region</span><span class="p">[</span><span class="n">DEV_MEM</span><span class="p">].</span><span class="n">element_size</span> <span class="o">=</span> <span class="n">PM8001_MAX_DEVICES</span> <span class="o">*</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pm8001_device</span><span class="p">);</span>
	<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">memoryMap</span><span class="p">.</span><span class="n">region</span><span class="p">[</span><span class="n">DEV_MEM</span><span class="p">].</span><span class="n">total_len</span> <span class="o">=</span> <span class="n">PM8001_MAX_DEVICES</span> <span class="o">*</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pm8001_device</span><span class="p">);</span>

	<span class="cm">/* Memory region for ccb_info*/</span>
	<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">memoryMap</span><span class="p">.</span><span class="n">region</span><span class="p">[</span><span class="n">CCB_MEM</span><span class="p">].</span><span class="n">num_elements</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">memoryMap</span><span class="p">.</span><span class="n">region</span><span class="p">[</span><span class="n">CCB_MEM</span><span class="p">].</span><span class="n">element_size</span> <span class="o">=</span> <span class="n">PM8001_MAX_CCB</span> <span class="o">*</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pm8001_ccb_info</span><span class="p">);</span>
	<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">memoryMap</span><span class="p">.</span><span class="n">region</span><span class="p">[</span><span class="n">CCB_MEM</span><span class="p">].</span><span class="n">total_len</span> <span class="o">=</span> <span class="n">PM8001_MAX_CCB</span> <span class="o">*</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pm8001_ccb_info</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">USI_MAX_MEMCNT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pm8001_mem_alloc</span><span class="p">(</span><span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">memoryMap</span><span class="p">.</span><span class="n">region</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">virt_ptr</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">memoryMap</span><span class="p">.</span><span class="n">region</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">phys_addr</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">memoryMap</span><span class="p">.</span><span class="n">region</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">phys_addr_hi</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">memoryMap</span><span class="p">.</span><span class="n">region</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">phys_addr_lo</span><span class="p">,</span>
			<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">memoryMap</span><span class="p">.</span><span class="n">region</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">total_len</span><span class="p">,</span>
			<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">memoryMap</span><span class="p">.</span><span class="n">region</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">alignment</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">PM8001_FAIL_DBG</span><span class="p">(</span><span class="n">pm8001_ha</span><span class="p">,</span>
					<span class="n">pm8001_printk</span><span class="p">(</span><span class="s">&quot;Mem%d alloc failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">i</span><span class="p">));</span>
				<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">devices</span> <span class="o">=</span> <span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">memoryMap</span><span class="p">.</span><span class="n">region</span><span class="p">[</span><span class="n">DEV_MEM</span><span class="p">].</span><span class="n">virt_ptr</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PM8001_MAX_DEVICES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">devices</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">dev_type</span> <span class="o">=</span> <span class="n">NO_DEVICE</span><span class="p">;</span>
		<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">devices</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">id</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">devices</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">device_id</span> <span class="o">=</span> <span class="n">PM8001_MAX_DEVICES</span><span class="p">;</span>
		<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">devices</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">running_req</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">ccb_info</span> <span class="o">=</span> <span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">memoryMap</span><span class="p">.</span><span class="n">region</span><span class="p">[</span><span class="n">CCB_MEM</span><span class="p">].</span><span class="n">virt_ptr</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PM8001_MAX_CCB</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">ccb_info</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">ccb_dma_handle</span> <span class="o">=</span>
			<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">memoryMap</span><span class="p">.</span><span class="n">region</span><span class="p">[</span><span class="n">CCB_MEM</span><span class="p">].</span><span class="n">phys_addr</span> <span class="o">+</span>
			<span class="n">i</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pm8001_ccb_info</span><span class="p">);</span>
		<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">ccb_info</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">task</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">ccb_info</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">ccb_tag</span> <span class="o">=</span> <span class="mh">0xffffffff</span><span class="p">;</span>
		<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">ccb_info</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">device</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="o">++</span><span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">tags_num</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">PM8001F_INIT_TIME</span><span class="p">;</span>
	<span class="cm">/* Initialize tags */</span>
	<span class="n">pm8001_tag_init</span><span class="p">(</span><span class="n">pm8001_ha</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">err_out:</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pm8001_ioremap - remap the pci high physical address to kernal virtual</span>
<span class="cm"> * address so that we can access them.</span>
<span class="cm"> * @pm8001_ha:our hba structure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pm8001_ioremap</span><span class="p">(</span><span class="k">struct</span> <span class="n">pm8001_hba_info</span> <span class="o">*</span><span class="n">pm8001_ha</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">bar</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">logicalBar</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">;</span>

	<span class="n">pdev</span> <span class="o">=</span> <span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="cm">/* map pci mem (PMC pci base 0-3)*/</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">bar</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">bar</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="n">bar</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		** logical BARs for SPC:</span>
<span class="cm">		** bar 0 and 1 - logical BAR0</span>
<span class="cm">		** bar 2 and 3 - logical BAR1</span>
<span class="cm">		** bar4 - logical BAR2</span>
<span class="cm">		** bar5 - logical BAR3</span>
<span class="cm">		** Skip the appropriate assignments:</span>
<span class="cm">		*/</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">bar</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">bar</span> <span class="o">==</span> <span class="mi">3</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pci_resource_flags</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">bar</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">IORESOURCE_MEM</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">io_mem</span><span class="p">[</span><span class="n">logicalBar</span><span class="p">].</span><span class="n">membase</span> <span class="o">=</span>
				<span class="n">pci_resource_start</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">bar</span><span class="p">);</span>
			<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">io_mem</span><span class="p">[</span><span class="n">logicalBar</span><span class="p">].</span><span class="n">membase</span> <span class="o">&amp;=</span>
				<span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">PCI_BASE_ADDRESS_MEM_MASK</span><span class="p">;</span>
			<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">io_mem</span><span class="p">[</span><span class="n">logicalBar</span><span class="p">].</span><span class="n">memsize</span> <span class="o">=</span>
				<span class="n">pci_resource_len</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">bar</span><span class="p">);</span>
			<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">io_mem</span><span class="p">[</span><span class="n">logicalBar</span><span class="p">].</span><span class="n">memvirtaddr</span> <span class="o">=</span>
				<span class="n">ioremap</span><span class="p">(</span><span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">io_mem</span><span class="p">[</span><span class="n">logicalBar</span><span class="p">].</span><span class="n">membase</span><span class="p">,</span>
				<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">io_mem</span><span class="p">[</span><span class="n">logicalBar</span><span class="p">].</span><span class="n">memsize</span><span class="p">);</span>
			<span class="n">PM8001_INIT_DBG</span><span class="p">(</span><span class="n">pm8001_ha</span><span class="p">,</span>
				<span class="n">pm8001_printk</span><span class="p">(</span><span class="s">&quot;PCI: bar %d, logicalBar %d &quot;</span>
				<span class="s">&quot;virt_addr=%lx,len=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bar</span><span class="p">,</span> <span class="n">logicalBar</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span>
				<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">io_mem</span><span class="p">[</span><span class="n">logicalBar</span><span class="p">].</span><span class="n">memvirtaddr</span><span class="p">,</span>
				<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">io_mem</span><span class="p">[</span><span class="n">logicalBar</span><span class="p">].</span><span class="n">memsize</span><span class="p">));</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">io_mem</span><span class="p">[</span><span class="n">logicalBar</span><span class="p">].</span><span class="n">membase</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">io_mem</span><span class="p">[</span><span class="n">logicalBar</span><span class="p">].</span><span class="n">memsize</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">io_mem</span><span class="p">[</span><span class="n">logicalBar</span><span class="p">].</span><span class="n">memvirtaddr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">logicalBar</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pm8001_pci_alloc - initialize our ha card structure</span>
<span class="cm"> * @pdev: pci device.</span>
<span class="cm"> * @ent: ent</span>
<span class="cm"> * @shost: scsi host struct which has been initialized before.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">pm8001_hba_info</span> <span class="o">*</span><span class="n">__devinit</span>
<span class="nf">pm8001_pci_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="n">u32</span> <span class="n">chip_id</span><span class="p">,</span> <span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pm8001_hba_info</span> <span class="o">*</span><span class="n">pm8001_ha</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sas_ha_struct</span> <span class="o">*</span><span class="n">sha</span> <span class="o">=</span> <span class="n">SHOST_TO_SAS_HA</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>


	<span class="n">pm8001_ha</span> <span class="o">=</span> <span class="n">sha</span><span class="o">-&gt;</span><span class="n">lldd_ha</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pm8001_ha</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">pdev</span><span class="p">;</span>
	<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">chip_id</span> <span class="o">=</span> <span class="n">chip_id</span><span class="p">;</span>
	<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">chip</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pm8001_chips</span><span class="p">[</span><span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">chip_id</span><span class="p">];</span>
	<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>
	<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">sas</span> <span class="o">=</span> <span class="n">sha</span><span class="p">;</span>
	<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">shost</span> <span class="o">=</span> <span class="n">shost</span><span class="p">;</span>
	<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">=</span> <span class="n">pm8001_id</span><span class="o">++</span><span class="p">;</span>
	<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">logging_level</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">;</span>
	<span class="n">sprintf</span><span class="p">(</span><span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;%s%d&quot;</span><span class="p">,</span> <span class="n">DRV_NAME</span><span class="p">,</span> <span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
<span class="cp">#ifdef PM8001_USE_TASKLET</span>
	<span class="n">tasklet_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">tasklet</span><span class="p">,</span> <span class="n">pm8001_tasklet</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">pm8001_ha</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">pm8001_ioremap</span><span class="p">(</span><span class="n">pm8001_ha</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pm8001_alloc</span><span class="p">(</span><span class="n">pm8001_ha</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">pm8001_ha</span><span class="p">;</span>
	<span class="n">pm8001_free</span><span class="p">(</span><span class="n">pm8001_ha</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pci_go_44 - pm8001 specified, its DMA is 44 bit rather than 64 bit</span>
<span class="cm"> * @pdev: pci device.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pci_go_44</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pci_set_dma_mask</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">44</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">pci_set_consistent_dma_mask</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">44</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">pci_set_consistent_dma_mask</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span>
				<span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">32</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="s">&quot;44-bit DMA enable failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">pci_set_dma_mask</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">32</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;32-bit DMA enable failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">pci_set_consistent_dma_mask</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">32</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;32-bit consistent DMA enable failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pm8001_prep_sas_ha_init - allocate memory in general hba struct &amp;&amp; init them.</span>
<span class="cm"> * @shost: scsi host which has been allocated outside.</span>
<span class="cm"> * @chip_info: our ha struct.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">pm8001_prep_sas_ha_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span> <span class="n">shost</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">pm8001_chip_info</span> <span class="o">*</span><span class="n">chip_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">phy_nr</span><span class="p">,</span> <span class="n">port_nr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">asd_sas_phy</span> <span class="o">**</span><span class="n">arr_phy</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">asd_sas_port</span> <span class="o">**</span><span class="n">arr_port</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sas_ha_struct</span> <span class="o">*</span><span class="n">sha</span> <span class="o">=</span> <span class="n">SHOST_TO_SAS_HA</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>

	<span class="n">phy_nr</span> <span class="o">=</span> <span class="n">chip_info</span><span class="o">-&gt;</span><span class="n">n_phy</span><span class="p">;</span>
	<span class="n">port_nr</span> <span class="o">=</span> <span class="n">phy_nr</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">sha</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">sha</span><span class="p">));</span>
	<span class="n">arr_phy</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">phy_nr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">arr_phy</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="n">arr_port</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">port_nr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">arr_port</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit_free2</span><span class="p">;</span>

	<span class="n">sha</span><span class="o">-&gt;</span><span class="n">sas_phy</span> <span class="o">=</span> <span class="n">arr_phy</span><span class="p">;</span>
	<span class="n">sha</span><span class="o">-&gt;</span><span class="n">sas_port</span> <span class="o">=</span> <span class="n">arr_port</span><span class="p">;</span>
	<span class="n">sha</span><span class="o">-&gt;</span><span class="n">lldd_ha</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pm8001_hba_info</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sha</span><span class="o">-&gt;</span><span class="n">lldd_ha</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit_free1</span><span class="p">;</span>

	<span class="n">shost</span><span class="o">-&gt;</span><span class="n">transportt</span> <span class="o">=</span> <span class="n">pm8001_stt</span><span class="p">;</span>
	<span class="n">shost</span><span class="o">-&gt;</span><span class="n">max_id</span> <span class="o">=</span> <span class="n">PM8001_MAX_DEVICES</span><span class="p">;</span>
	<span class="n">shost</span><span class="o">-&gt;</span><span class="n">max_lun</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">shost</span><span class="o">-&gt;</span><span class="n">max_channel</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">shost</span><span class="o">-&gt;</span><span class="n">unique_id</span> <span class="o">=</span> <span class="n">pm8001_id</span><span class="p">;</span>
	<span class="n">shost</span><span class="o">-&gt;</span><span class="n">max_cmd_len</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
	<span class="n">shost</span><span class="o">-&gt;</span><span class="n">can_queue</span> <span class="o">=</span> <span class="n">PM8001_CAN_QUEUE</span><span class="p">;</span>
	<span class="n">shost</span><span class="o">-&gt;</span><span class="n">cmd_per_lun</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">exit_free1:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">arr_port</span><span class="p">);</span>
<span class="nl">exit_free2:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">arr_phy</span><span class="p">);</span>
<span class="nl">exit:</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pm8001_post_sas_ha_init - initialize general hba struct defined in libsas</span>
<span class="cm"> * @shost: scsi host which has been allocated outside</span>
<span class="cm"> * @chip_info: our ha struct.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>  <span class="n">__devinit</span> <span class="nf">pm8001_post_sas_ha_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">pm8001_chip_info</span> <span class="o">*</span><span class="n">chip_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pm8001_hba_info</span> <span class="o">*</span><span class="n">pm8001_ha</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sas_ha_struct</span> <span class="o">*</span><span class="n">sha</span> <span class="o">=</span> <span class="n">SHOST_TO_SAS_HA</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>

	<span class="n">pm8001_ha</span> <span class="o">=</span> <span class="n">sha</span><span class="o">-&gt;</span><span class="n">lldd_ha</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">chip_info</span><span class="o">-&gt;</span><span class="n">n_phy</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sha</span><span class="o">-&gt;</span><span class="n">sas_phy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sas_phy</span><span class="p">;</span>
		<span class="n">sha</span><span class="o">-&gt;</span><span class="n">sas_port</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sas_port</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">sha</span><span class="o">-&gt;</span><span class="n">sas_ha_name</span> <span class="o">=</span> <span class="n">DRV_NAME</span><span class="p">;</span>
	<span class="n">sha</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="n">sha</span><span class="o">-&gt;</span><span class="n">lldd_module</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">;</span>
	<span class="n">sha</span><span class="o">-&gt;</span><span class="n">sas_addr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">sas_addr</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">sha</span><span class="o">-&gt;</span><span class="n">num_phys</span> <span class="o">=</span> <span class="n">chip_info</span><span class="o">-&gt;</span><span class="n">n_phy</span><span class="p">;</span>
	<span class="n">sha</span><span class="o">-&gt;</span><span class="n">lldd_max_execute_num</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">sha</span><span class="o">-&gt;</span><span class="n">lldd_queue_size</span> <span class="o">=</span> <span class="n">PM8001_CAN_QUEUE</span><span class="p">;</span>
	<span class="n">sha</span><span class="o">-&gt;</span><span class="n">core</span><span class="p">.</span><span class="n">shost</span> <span class="o">=</span> <span class="n">shost</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pm8001_init_sas_add - initialize sas address</span>
<span class="cm"> * @chip_info: our ha struct.</span>
<span class="cm"> *</span>
<span class="cm"> * Currently we just set the fixed SAS address to our HBA,for manufacture,</span>
<span class="cm"> * it should read from the EEPROM</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pm8001_init_sas_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">pm8001_hba_info</span> <span class="o">*</span><span class="n">pm8001_ha</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">i</span><span class="p">;</span>
<span class="cp">#ifdef PM8001_READ_VPD</span>
	<span class="n">DECLARE_COMPLETION_ONSTACK</span><span class="p">(</span><span class="n">completion</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pm8001_ioctl_payload</span> <span class="n">payload</span><span class="p">;</span>
	<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">nvmd_completion</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">completion</span><span class="p">;</span>
	<span class="n">payload</span><span class="p">.</span><span class="n">minor_function</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">payload</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="mi">128</span><span class="p">;</span>
	<span class="n">payload</span><span class="p">.</span><span class="n">func_specific</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="mi">128</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="n">PM8001_CHIP_DISP</span><span class="o">-&gt;</span><span class="n">get_nvmd_req</span><span class="p">(</span><span class="n">pm8001_ha</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">payload</span><span class="p">);</span>
	<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">completion</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">n_phy</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">dev_sas_addr</span><span class="p">,</span> <span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">sas_addr</span><span class="p">,</span>
			<span class="n">SAS_ADDR_SIZE</span><span class="p">);</span>
		<span class="n">PM8001_INIT_DBG</span><span class="p">(</span><span class="n">pm8001_ha</span><span class="p">,</span>
			<span class="n">pm8001_printk</span><span class="p">(</span><span class="s">&quot;phy %d sas_addr = %016llx </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
			<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">dev_sas_addr</span><span class="p">));</span>
	<span class="p">}</span>
<span class="cp">#else</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">n_phy</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">dev_sas_addr</span> <span class="o">=</span> <span class="mh">0x50010c600047f9d0ULL</span><span class="p">;</span>
		<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">dev_sas_addr</span> <span class="o">=</span>
			<span class="n">cpu_to_be64</span><span class="p">((</span><span class="n">u64</span><span class="p">)</span>
				<span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">dev_sas_addr</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">sas_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">dev_sas_addr</span><span class="p">,</span>
		<span class="n">SAS_ADDR_SIZE</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cp">#ifdef PM8001_USE_MSIX</span>
<span class="cm">/**</span>
<span class="cm"> * pm8001_setup_msix - enable MSI-X interrupt</span>
<span class="cm"> * @chip_info: our ha struct.</span>
<span class="cm"> * @irq_handler: irq_handler</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="nf">pm8001_setup_msix</span><span class="p">(</span><span class="k">struct</span> <span class="n">pm8001_hba_info</span> <span class="o">*</span><span class="n">pm8001_ha</span><span class="p">,</span>
	<span class="n">irq_handler_t</span> <span class="n">irq_handler</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">number_of_intr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">max_entry</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">max_entry</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">)</span> <span class="o">/</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">flag</span> <span class="o">|=</span> <span class="n">IRQF_DISABLED</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">max_entry</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">entry</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">pci_enable_msix</span><span class="p">(</span><span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">,</span>
		<span class="n">number_of_intr</span><span class="p">);</span>
	<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">number_of_intr</span> <span class="o">=</span> <span class="n">number_of_intr</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">number_of_intr</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">request_irq</span><span class="p">(</span><span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vector</span><span class="p">,</span>
				<span class="n">irq_handler</span><span class="p">,</span> <span class="n">flag</span><span class="p">,</span> <span class="n">DRV_NAME</span><span class="p">,</span>
				<span class="n">SHOST_TO_SAS_HA</span><span class="p">(</span><span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">shost</span><span class="p">)))</span> <span class="p">{</span>
				<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
					<span class="n">free_irq</span><span class="p">(</span>
					<span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">vector</span><span class="p">,</span>
					<span class="n">SHOST_TO_SAS_HA</span><span class="p">(</span><span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">shost</span><span class="p">));</span>
				<span class="n">pci_disable_msix</span><span class="p">(</span><span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * pm8001_request_irq - register interrupt</span>
<span class="cm"> * @chip_info: our ha struct.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="nf">pm8001_request_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">pm8001_hba_info</span> <span class="o">*</span><span class="n">pm8001_ha</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">;</span>
	<span class="n">irq_handler_t</span> <span class="n">irq_handler</span> <span class="o">=</span> <span class="n">pm8001_interrupt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">pdev</span> <span class="o">=</span> <span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>

<span class="cp">#ifdef PM8001_USE_MSIX</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pci_find_capability</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_CAP_ID_MSIX</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">pm8001_setup_msix</span><span class="p">(</span><span class="n">pm8001_ha</span><span class="p">,</span> <span class="n">irq_handler</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">goto</span> <span class="n">intx</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="nl">intx:</span>
	<span class="cm">/* initialize the INT-X interrupt */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">irq_handler</span><span class="p">,</span> <span class="n">IRQF_SHARED</span><span class="p">,</span> <span class="n">DRV_NAME</span><span class="p">,</span>
		<span class="n">SHOST_TO_SAS_HA</span><span class="p">(</span><span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">shost</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pm8001_pci_probe - probe supported device</span>
<span class="cm"> * @pdev: pci device which kernel has been prepared for.</span>
<span class="cm"> * @ent: pci device id</span>
<span class="cm"> *</span>
<span class="cm"> * This function is the main initialization function, when register a new</span>
<span class="cm"> * pci driver it is invoked, all struct an hardware initilization should be done</span>
<span class="cm"> * here, also, register interrupt</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">pm8001_pci_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">ent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">pci_reg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pm8001_hba_info</span> <span class="o">*</span><span class="n">pm8001_ha</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">pm8001_chip_info</span> <span class="o">*</span><span class="n">chip</span><span class="p">;</span>

	<span class="n">dev_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;pm8001: driver version %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">DRV_VERSION</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">pci_enable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_out_enable</span><span class="p">;</span>
	<span class="n">pci_set_master</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Enable pci slot busmaster by setting pci command register.</span>
<span class="cm">	 * This is required by FW for Cyclone card.</span>
<span class="cm">	 */</span>

	<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_COMMAND</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pci_reg</span><span class="p">);</span>
	<span class="n">pci_reg</span> <span class="o">|=</span> <span class="mh">0x157</span><span class="p">;</span>
	<span class="n">pci_write_config_dword</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_COMMAND</span><span class="p">,</span> <span class="n">pci_reg</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">pci_request_regions</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DRV_NAME</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_out_disable</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">pci_go_44</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_out_regions</span><span class="p">;</span>

	<span class="n">shost</span> <span class="o">=</span> <span class="n">scsi_host_alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pm8001_sht</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">shost</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_out_regions</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">chip</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pm8001_chips</span><span class="p">[</span><span class="n">ent</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">];</span>
	<span class="n">SHOST_TO_SAS_HA</span><span class="p">(</span><span class="n">shost</span><span class="p">)</span> <span class="o">=</span>
		<span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sas_ha_struct</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">SHOST_TO_SAS_HA</span><span class="p">(</span><span class="n">shost</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_out_free_host</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">pm8001_prep_sas_ha_init</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="n">chip</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_out_free</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">SHOST_TO_SAS_HA</span><span class="p">(</span><span class="n">shost</span><span class="p">));</span>
	<span class="n">pm8001_ha</span> <span class="o">=</span> <span class="n">pm8001_pci_alloc</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">chip_8001</span><span class="p">,</span> <span class="n">shost</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pm8001_ha</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_out_free</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hba_list</span><span class="p">);</span>
	<span class="n">PM8001_CHIP_DISP</span><span class="o">-&gt;</span><span class="n">chip_soft_rst</span><span class="p">(</span><span class="n">pm8001_ha</span><span class="p">,</span> <span class="mh">0x252acbcd</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">PM8001_CHIP_DISP</span><span class="o">-&gt;</span><span class="n">chip_init</span><span class="p">(</span><span class="n">pm8001_ha</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_out_ha_free</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">scsi_add_host</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_out_ha_free</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">pm8001_request_irq</span><span class="p">(</span><span class="n">pm8001_ha</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_out_shost</span><span class="p">;</span>

	<span class="n">PM8001_CHIP_DISP</span><span class="o">-&gt;</span><span class="n">interrupt_enable</span><span class="p">(</span><span class="n">pm8001_ha</span><span class="p">);</span>
	<span class="n">pm8001_init_sas_add</span><span class="p">(</span><span class="n">pm8001_ha</span><span class="p">);</span>
	<span class="n">pm8001_post_sas_ha_init</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="n">chip</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">sas_register_ha</span><span class="p">(</span><span class="n">SHOST_TO_SAS_HA</span><span class="p">(</span><span class="n">shost</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_out_shost</span><span class="p">;</span>
	<span class="n">scsi_scan_host</span><span class="p">(</span><span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">shost</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_out_shost:</span>
	<span class="n">scsi_remove_host</span><span class="p">(</span><span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">shost</span><span class="p">);</span>
<span class="nl">err_out_ha_free:</span>
	<span class="n">pm8001_free</span><span class="p">(</span><span class="n">pm8001_ha</span><span class="p">);</span>
<span class="nl">err_out_free:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">SHOST_TO_SAS_HA</span><span class="p">(</span><span class="n">shost</span><span class="p">));</span>
<span class="nl">err_out_free_host:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
<span class="nl">err_out_regions:</span>
	<span class="n">pci_release_regions</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
<span class="nl">err_out_disable:</span>
	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
<span class="nl">err_out_enable:</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devexit</span> <span class="nf">pm8001_pci_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sas_ha_struct</span> <span class="o">*</span><span class="n">sha</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pm8001_hba_info</span> <span class="o">*</span><span class="n">pm8001_ha</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">pm8001_ha</span> <span class="o">=</span> <span class="n">sha</span><span class="o">-&gt;</span><span class="n">lldd_ha</span><span class="p">;</span>
	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">sas_unregister_ha</span><span class="p">(</span><span class="n">sha</span><span class="p">);</span>
	<span class="n">sas_remove_host</span><span class="p">(</span><span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">shost</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">scsi_remove_host</span><span class="p">(</span><span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">shost</span><span class="p">);</span>
	<span class="n">PM8001_CHIP_DISP</span><span class="o">-&gt;</span><span class="n">interrupt_disable</span><span class="p">(</span><span class="n">pm8001_ha</span><span class="p">);</span>
	<span class="n">PM8001_CHIP_DISP</span><span class="o">-&gt;</span><span class="n">chip_soft_rst</span><span class="p">(</span><span class="n">pm8001_ha</span><span class="p">,</span> <span class="mh">0x252acbcd</span><span class="p">);</span>

<span class="cp">#ifdef PM8001_USE_MSIX</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">number_of_intr</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">synchronize_irq</span><span class="p">(</span><span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vector</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">number_of_intr</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vector</span><span class="p">,</span> <span class="n">sha</span><span class="p">);</span>
	<span class="n">pci_disable_msix</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">sha</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef PM8001_USE_TASKLET</span>
	<span class="n">tasklet_kill</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">tasklet</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">pm8001_free</span><span class="p">(</span><span class="n">pm8001_ha</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">sha</span><span class="o">-&gt;</span><span class="n">sas_phy</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">sha</span><span class="o">-&gt;</span><span class="n">sas_port</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">sha</span><span class="p">);</span>
	<span class="n">pci_release_regions</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pm8001_pci_suspend - power management suspend main entry point</span>
<span class="cm"> * @pdev: PCI device struct</span>
<span class="cm"> * @state: PM state change to (usually PCI_D3)</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 success, anything else error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pm8001_pci_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sas_ha_struct</span> <span class="o">*</span><span class="n">sha</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pm8001_hba_info</span> <span class="o">*</span><span class="n">pm8001_ha</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="p">,</span> <span class="n">pos</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">device_state</span><span class="p">;</span>
	<span class="n">pm8001_ha</span> <span class="o">=</span> <span class="n">sha</span><span class="o">-&gt;</span><span class="n">lldd_ha</span><span class="p">;</span>
	<span class="n">flush_workqueue</span><span class="p">(</span><span class="n">pm8001_wq</span><span class="p">);</span>
	<span class="n">scsi_block_requests</span><span class="p">(</span><span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">shost</span><span class="p">);</span>
	<span class="n">pos</span> <span class="o">=</span> <span class="n">pci_find_capability</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_CAP_ID_PM</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot; PCI PM not supported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">PM8001_CHIP_DISP</span><span class="o">-&gt;</span><span class="n">interrupt_disable</span><span class="p">(</span><span class="n">pm8001_ha</span><span class="p">);</span>
	<span class="n">PM8001_CHIP_DISP</span><span class="o">-&gt;</span><span class="n">chip_soft_rst</span><span class="p">(</span><span class="n">pm8001_ha</span><span class="p">,</span> <span class="mh">0x252acbcd</span><span class="p">);</span>
<span class="cp">#ifdef PM8001_USE_MSIX</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">number_of_intr</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">synchronize_irq</span><span class="p">(</span><span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vector</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">number_of_intr</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vector</span><span class="p">,</span> <span class="n">sha</span><span class="p">);</span>
	<span class="n">pci_disable_msix</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">sha</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef PM8001_USE_TASKLET</span>
	<span class="n">tasklet_kill</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">tasklet</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">device_state</span> <span class="o">=</span> <span class="n">pci_choose_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
	<span class="n">pm8001_printk</span><span class="p">(</span><span class="s">&quot;pdev=0x%p, slot=%s, entering &quot;</span>
		      <span class="s">&quot;operating state [D%d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pdev</span><span class="p">,</span>
		      <span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">device_state</span><span class="p">);</span>
	<span class="n">pci_save_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">pci_set_power_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">device_state</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pm8001_pci_resume - power management resume main entry point</span>
<span class="cm"> * @pdev: PCI device struct</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 success, anything else error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pm8001_pci_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sas_ha_struct</span> <span class="o">*</span><span class="n">sha</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pm8001_hba_info</span> <span class="o">*</span><span class="n">pm8001_ha</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">device_state</span><span class="p">;</span>
	<span class="n">pm8001_ha</span> <span class="o">=</span> <span class="n">sha</span><span class="o">-&gt;</span><span class="n">lldd_ha</span><span class="p">;</span>
	<span class="n">device_state</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">current_state</span><span class="p">;</span>

	<span class="n">pm8001_printk</span><span class="p">(</span><span class="s">&quot;pdev=0x%p, slot=%s, resuming from previous &quot;</span>
		<span class="s">&quot;operating state [D%d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pdev</span><span class="p">,</span> <span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">device_state</span><span class="p">);</span>

	<span class="n">pci_set_power_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_D0</span><span class="p">);</span>
	<span class="n">pci_enable_wake</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_D0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">pci_restore_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">pci_enable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pm8001_printk</span><span class="p">(</span><span class="s">&quot;slot=%s Enable device failed during resume</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			      <span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_out_enable</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pci_set_master</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">pci_go_44</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_out_disable</span><span class="p">;</span>

	<span class="n">PM8001_CHIP_DISP</span><span class="o">-&gt;</span><span class="n">chip_soft_rst</span><span class="p">(</span><span class="n">pm8001_ha</span><span class="p">,</span> <span class="mh">0x252acbcd</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">PM8001_CHIP_DISP</span><span class="o">-&gt;</span><span class="n">chip_init</span><span class="p">(</span><span class="n">pm8001_ha</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_out_disable</span><span class="p">;</span>
	<span class="n">PM8001_CHIP_DISP</span><span class="o">-&gt;</span><span class="n">interrupt_disable</span><span class="p">(</span><span class="n">pm8001_ha</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">pm8001_request_irq</span><span class="p">(</span><span class="n">pm8001_ha</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_out_disable</span><span class="p">;</span>
	<span class="cp">#ifdef PM8001_USE_TASKLET</span>
	<span class="n">tasklet_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">tasklet</span><span class="p">,</span> <span class="n">pm8001_tasklet</span><span class="p">,</span>
		    <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">pm8001_ha</span><span class="p">);</span>
	<span class="cp">#endif</span>
	<span class="n">PM8001_CHIP_DISP</span><span class="o">-&gt;</span><span class="n">interrupt_enable</span><span class="p">(</span><span class="n">pm8001_ha</span><span class="p">);</span>
	<span class="n">scsi_unblock_requests</span><span class="p">(</span><span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">shost</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_out_disable:</span>
	<span class="n">scsi_remove_host</span><span class="p">(</span><span class="n">pm8001_ha</span><span class="o">-&gt;</span><span class="n">shost</span><span class="p">);</span>
	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
<span class="nl">err_out_enable:</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="n">__devinitdata</span> <span class="n">pm8001_pci_table</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span>
		<span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">PMC_Sierra</span><span class="p">,</span> <span class="mh">0x8001</span><span class="p">),</span> <span class="n">chip_8001</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="n">PCI_DEVICE</span><span class="p">(</span><span class="mh">0x117c</span><span class="p">,</span> <span class="mh">0x0042</span><span class="p">),</span>
		<span class="p">.</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">chip_8001</span>
	<span class="p">},</span>
	<span class="p">{}</span> <span class="cm">/* terminate list */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_driver</span> <span class="n">pm8001_pci_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="n">DRV_NAME</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_table</span>	<span class="o">=</span> <span class="n">pm8001_pci_table</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span>		<span class="o">=</span> <span class="n">pm8001_pci_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span>		<span class="o">=</span> <span class="n">__devexit_p</span><span class="p">(</span><span class="n">pm8001_pci_remove</span><span class="p">),</span>
	<span class="p">.</span><span class="n">suspend</span>	<span class="o">=</span> <span class="n">pm8001_pci_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span>		<span class="o">=</span> <span class="n">pm8001_pci_resume</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> *	pm8001_init - initialize scsi transport template</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">pm8001_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">pm8001_wq</span> <span class="o">=</span> <span class="n">alloc_workqueue</span><span class="p">(</span><span class="s">&quot;pm8001&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pm8001_wq</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">pm8001_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pm8001_stt</span> <span class="o">=</span> <span class="n">sas_domain_attach_transport</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pm8001_transport_ops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pm8001_stt</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_wq</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">pci_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pm8001_pci_driver</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_tp</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_tp:</span>
	<span class="n">sas_release_transport</span><span class="p">(</span><span class="n">pm8001_stt</span><span class="p">);</span>
<span class="nl">err_wq:</span>
	<span class="n">destroy_workqueue</span><span class="p">(</span><span class="n">pm8001_wq</span><span class="p">);</span>
<span class="nl">err:</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">pm8001_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pci_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pm8001_pci_driver</span><span class="p">);</span>
	<span class="n">sas_release_transport</span><span class="p">(</span><span class="n">pm8001_stt</span><span class="p">);</span>
	<span class="n">destroy_workqueue</span><span class="p">(</span><span class="n">pm8001_wq</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">pm8001_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">pm8001_exit</span><span class="p">);</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Jack Wang &lt;jack_wang@usish.com&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;PMC-Sierra PM8001 SAS/SATA controller driver&quot;</span><span class="p">);</span>
<span class="n">MODULE_VERSION</span><span class="p">(</span><span class="n">DRV_VERSION</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">pm8001_pci_table</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
