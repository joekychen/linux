<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › scsi › aic7xxx › aic79xx_core.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>aic79xx_core.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Core routines and tables shareable across OS platforms.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 1994-2002 Justin T. Gibbs.</span>
<span class="cm"> * Copyright (c) 2000-2003 Adaptec Inc.</span>
<span class="cm"> * All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * Redistribution and use in source and binary forms, with or without</span>
<span class="cm"> * modification, are permitted provided that the following conditions</span>
<span class="cm"> * are met:</span>
<span class="cm"> * 1. Redistributions of source code must retain the above copyright</span>
<span class="cm"> *    notice, this list of conditions, and the following disclaimer,</span>
<span class="cm"> *    without modification.</span>
<span class="cm"> * 2. Redistributions in binary form must reproduce at minimum a disclaimer</span>
<span class="cm"> *    substantially similar to the &quot;NO WARRANTY&quot; disclaimer below</span>
<span class="cm"> *    (&quot;Disclaimer&quot;) and any redistribution must be conditioned upon</span>
<span class="cm"> *    including a substantially similar Disclaimer requirement for further</span>
<span class="cm"> *    binary redistribution.</span>
<span class="cm"> * 3. Neither the names of the above-listed copyright holders nor the names</span>
<span class="cm"> *    of any contributors may be used to endorse or promote products derived</span>
<span class="cm"> *    from this software without specific prior written permission.</span>
<span class="cm"> *</span>
<span class="cm"> * Alternatively, this software may be distributed under the terms of the</span>
<span class="cm"> * GNU General Public License (&quot;GPL&quot;) version 2 as published by the Free</span>
<span class="cm"> * Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * NO WARRANTY</span>
<span class="cm"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span>
<span class="cm"> * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span>
<span class="cm"> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR</span>
<span class="cm"> * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</span>
<span class="cm"> * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</span>
<span class="cm"> * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</span>
<span class="cm"> * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</span>
<span class="cm"> * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,</span>
<span class="cm"> * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING</span>
<span class="cm"> * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</span>
<span class="cm"> * POSSIBILITY OF SUCH DAMAGES.</span>
<span class="cm"> *</span>
<span class="cm"> * $Id: //depot/aic7xxx/aic7xxx/aic79xx.c#250 $</span>
<span class="cm"> */</span>

<span class="cp">#ifdef __linux__</span>
<span class="cp">#include &quot;aic79xx_osm.h&quot;</span>
<span class="cp">#include &quot;aic79xx_inline.h&quot;</span>
<span class="cp">#include &quot;aicasm/aicasm_insformat.h&quot;</span>
<span class="cp">#else</span>
<span class="cp">#include &lt;dev/aic7xxx/aic79xx_osm.h&gt;</span>
<span class="cp">#include &lt;dev/aic7xxx/aic79xx_inline.h&gt;</span>
<span class="cp">#include &lt;dev/aic7xxx/aicasm/aicasm_insformat.h&gt;</span>
<span class="cp">#endif</span>


<span class="cm">/***************************** Lookup Tables **********************************/</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="n">ahd_chip_names</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
	<span class="s">&quot;NONE&quot;</span><span class="p">,</span>
	<span class="s">&quot;aic7901&quot;</span><span class="p">,</span>
	<span class="s">&quot;aic7902&quot;</span><span class="p">,</span>
	<span class="s">&quot;aic7901A&quot;</span>
<span class="p">};</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">u_int</span> <span class="n">num_chip_names</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">ahd_chip_names</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Hardware error codes.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ahd_hard_error_entry</span> <span class="p">{</span>
        <span class="kt">uint8_t</span> <span class="n">errno</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">errmesg</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ahd_hard_error_entry</span> <span class="n">ahd_hard_errors</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">DSCTMOUT</span><span class="p">,</span>	<span class="s">&quot;Discard Timer has timed out&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">ILLOPCODE</span><span class="p">,</span>	<span class="s">&quot;Illegal Opcode in sequencer program&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">SQPARERR</span><span class="p">,</span>	<span class="s">&quot;Sequencer Parity Error&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">DPARERR</span><span class="p">,</span>	<span class="s">&quot;Data-path Parity Error&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">MPARERR</span><span class="p">,</span>	<span class="s">&quot;Scratch or SCB Memory Parity Error&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">CIOPARERR</span><span class="p">,</span>	<span class="s">&quot;CIOBUS Parity Error&quot;</span> <span class="p">},</span>
<span class="p">};</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">u_int</span> <span class="n">num_errors</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">ahd_hard_errors</span><span class="p">);</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ahd_phase_table_entry</span> <span class="n">ahd_phase_table</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
	<span class="p">{</span> <span class="n">P_DATAOUT</span><span class="p">,</span>	<span class="n">MSG_NOOP</span><span class="p">,</span>		<span class="s">&quot;in Data-out phase&quot;</span>	<span class="p">},</span>
	<span class="p">{</span> <span class="n">P_DATAIN</span><span class="p">,</span>	<span class="n">MSG_INITIATOR_DET_ERR</span><span class="p">,</span>	<span class="s">&quot;in Data-in phase&quot;</span>	<span class="p">},</span>
	<span class="p">{</span> <span class="n">P_DATAOUT_DT</span><span class="p">,</span>	<span class="n">MSG_NOOP</span><span class="p">,</span>		<span class="s">&quot;in DT Data-out phase&quot;</span>	<span class="p">},</span>
	<span class="p">{</span> <span class="n">P_DATAIN_DT</span><span class="p">,</span>	<span class="n">MSG_INITIATOR_DET_ERR</span><span class="p">,</span>	<span class="s">&quot;in DT Data-in phase&quot;</span>	<span class="p">},</span>
	<span class="p">{</span> <span class="n">P_COMMAND</span><span class="p">,</span>	<span class="n">MSG_NOOP</span><span class="p">,</span>		<span class="s">&quot;in Command phase&quot;</span>	<span class="p">},</span>
	<span class="p">{</span> <span class="n">P_MESGOUT</span><span class="p">,</span>	<span class="n">MSG_NOOP</span><span class="p">,</span>		<span class="s">&quot;in Message-out phase&quot;</span>	<span class="p">},</span>
	<span class="p">{</span> <span class="n">P_STATUS</span><span class="p">,</span>	<span class="n">MSG_INITIATOR_DET_ERR</span><span class="p">,</span>	<span class="s">&quot;in Status phase&quot;</span>	<span class="p">},</span>
	<span class="p">{</span> <span class="n">P_MESGIN</span><span class="p">,</span>	<span class="n">MSG_PARITY_ERROR</span><span class="p">,</span>	<span class="s">&quot;in Message-in phase&quot;</span>	<span class="p">},</span>
	<span class="p">{</span> <span class="n">P_BUSFREE</span><span class="p">,</span>	<span class="n">MSG_NOOP</span><span class="p">,</span>		<span class="s">&quot;while idle&quot;</span>		<span class="p">},</span>
	<span class="p">{</span> <span class="mi">0</span><span class="p">,</span>		<span class="n">MSG_NOOP</span><span class="p">,</span>		<span class="s">&quot;in unknown phase&quot;</span>	<span class="p">}</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * In most cases we only wish to itterate over real phases, so</span>
<span class="cm"> * exclude the last element from the count.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">u_int</span> <span class="n">num_phases</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">ahd_phase_table</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

<span class="cm">/* Our Sequencer Program */</span>
<span class="cp">#include &quot;aic79xx_seq.h&quot;</span>

<span class="cm">/**************************** Function Declarations ***************************/</span>
<span class="k">static</span> <span class="kt">void</span>		<span class="n">ahd_handle_transmission_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span>		<span class="n">ahd_handle_lqiphase_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span>
						  <span class="n">u_int</span> <span class="n">lqistat1</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span>		<span class="n">ahd_handle_pkt_busfree</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span>
					       <span class="n">u_int</span> <span class="n">busfreetime</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span>		<span class="n">ahd_handle_nonpkt_busfree</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span>		<span class="n">ahd_handle_proto_violation</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span>		<span class="n">ahd_force_renegotiation</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">ahd_devinfo</span> <span class="o">*</span><span class="n">devinfo</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">ahd_tmode_tstate</span><span class="o">*</span>
			<span class="n">ahd_alloc_tstate</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span>
					 <span class="n">u_int</span> <span class="n">scsi_id</span><span class="p">,</span> <span class="kt">char</span> <span class="n">channel</span><span class="p">);</span>
<span class="cp">#ifdef AHD_TARGET_MODE</span>
<span class="k">static</span> <span class="kt">void</span>		<span class="n">ahd_free_tstate</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span>
					<span class="n">u_int</span> <span class="n">scsi_id</span><span class="p">,</span> <span class="kt">char</span> <span class="n">channel</span><span class="p">,</span> <span class="kt">int</span> <span class="n">force</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="k">static</span> <span class="kt">void</span>		<span class="n">ahd_devlimited_syncrate</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span>
					        <span class="k">struct</span> <span class="n">ahd_initiator_tinfo</span> <span class="o">*</span><span class="p">,</span>
						<span class="n">u_int</span> <span class="o">*</span><span class="n">period</span><span class="p">,</span>
						<span class="n">u_int</span> <span class="o">*</span><span class="n">ppr_options</span><span class="p">,</span>
						<span class="n">role_t</span> <span class="n">role</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span>		<span class="n">ahd_update_neg_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">ahd_devinfo</span> <span class="o">*</span><span class="n">devinfo</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">ahd_transinfo</span> <span class="o">*</span><span class="n">tinfo</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span>		<span class="n">ahd_update_pending_scbs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span>		<span class="n">ahd_fetch_devinfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">ahd_devinfo</span> <span class="o">*</span><span class="n">devinfo</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span>		<span class="n">ahd_scb_devinfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">ahd_devinfo</span> <span class="o">*</span><span class="n">devinfo</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">scb</span> <span class="o">*</span><span class="n">scb</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span>		<span class="n">ahd_setup_initiator_msgout</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span>
						   <span class="k">struct</span> <span class="n">ahd_devinfo</span> <span class="o">*</span><span class="n">devinfo</span><span class="p">,</span>
						   <span class="k">struct</span> <span class="n">scb</span> <span class="o">*</span><span class="n">scb</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span>		<span class="n">ahd_build_transfer_msg</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span>
					       <span class="k">struct</span> <span class="n">ahd_devinfo</span> <span class="o">*</span><span class="n">devinfo</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span>		<span class="n">ahd_construct_sdtr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">ahd_devinfo</span> <span class="o">*</span><span class="n">devinfo</span><span class="p">,</span>
					   <span class="n">u_int</span> <span class="n">period</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">offset</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span>		<span class="n">ahd_construct_wdtr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">ahd_devinfo</span> <span class="o">*</span><span class="n">devinfo</span><span class="p">,</span>
					   <span class="n">u_int</span> <span class="n">bus_width</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span>		<span class="n">ahd_construct_ppr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">ahd_devinfo</span> <span class="o">*</span><span class="n">devinfo</span><span class="p">,</span>
					  <span class="n">u_int</span> <span class="n">period</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">offset</span><span class="p">,</span>
					  <span class="n">u_int</span> <span class="n">bus_width</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">ppr_options</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span>		<span class="n">ahd_clear_msg_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span>		<span class="n">ahd_handle_message_phase</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">);</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
	<span class="n">AHDMSG_1B</span><span class="p">,</span>
	<span class="n">AHDMSG_2B</span><span class="p">,</span>
	<span class="n">AHDMSG_EXT</span>
<span class="p">}</span> <span class="n">ahd_msgtype</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span>		<span class="n">ahd_sent_msg</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="n">ahd_msgtype</span> <span class="n">type</span><span class="p">,</span>
				     <span class="n">u_int</span> <span class="n">msgval</span><span class="p">,</span> <span class="kt">int</span> <span class="n">full</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span>		<span class="n">ahd_parse_msg</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">ahd_devinfo</span> <span class="o">*</span><span class="n">devinfo</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span>		<span class="n">ahd_handle_msg_reject</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span>
					      <span class="k">struct</span> <span class="n">ahd_devinfo</span> <span class="o">*</span><span class="n">devinfo</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span>		<span class="n">ahd_handle_ign_wide_residue</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">ahd_devinfo</span> <span class="o">*</span><span class="n">devinfo</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span>		<span class="n">ahd_reinitialize_dataptrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span>		<span class="n">ahd_handle_devreset</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">ahd_devinfo</span> <span class="o">*</span><span class="n">devinfo</span><span class="p">,</span>
					    <span class="n">u_int</span> <span class="n">lun</span><span class="p">,</span> <span class="n">cam_status</span> <span class="n">status</span><span class="p">,</span>
					    <span class="kt">char</span> <span class="o">*</span><span class="n">message</span><span class="p">,</span> <span class="kt">int</span> <span class="n">verbose_level</span><span class="p">);</span>
<span class="cp">#ifdef AHD_TARGET_MODE</span>
<span class="k">static</span> <span class="kt">void</span>		<span class="n">ahd_setup_target_msgin</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span>
					       <span class="k">struct</span> <span class="n">ahd_devinfo</span> <span class="o">*</span><span class="n">devinfo</span><span class="p">,</span>
					       <span class="k">struct</span> <span class="n">scb</span> <span class="o">*</span><span class="n">scb</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="n">u_int</span>		<span class="n">ahd_sglist_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">);</span>
<span class="k">static</span> <span class="n">u_int</span>		<span class="n">ahd_sglist_allocsize</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">);</span>
<span class="k">static</span> <span class="n">bus_dmamap_callback_t</span>
			<span class="n">ahd_dmamap_cb</span><span class="p">;</span> 
<span class="k">static</span> <span class="kt">void</span>		<span class="n">ahd_initialize_hscbs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span>		<span class="n">ahd_init_scbdata</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span>		<span class="n">ahd_fini_scbdata</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span>		<span class="n">ahd_setup_iocell_workaround</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span>		<span class="n">ahd_iocell_first_selection</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span>		<span class="n">ahd_add_col_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">scb</span> <span class="o">*</span><span class="n">scb</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">col_idx</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span>		<span class="n">ahd_rem_col_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">scb</span> <span class="o">*</span><span class="n">scb</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span>		<span class="n">ahd_chip_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span>		<span class="n">ahd_qinfifo_requeue</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">scb</span> <span class="o">*</span><span class="n">prev_scb</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">scb</span> <span class="o">*</span><span class="n">scb</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span>		<span class="n">ahd_qinfifo_count</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span>		<span class="n">ahd_search_scb_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">,</span>
					    <span class="kt">char</span> <span class="n">channel</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lun</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">tag</span><span class="p">,</span>
					    <span class="n">role_t</span> <span class="n">role</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">status</span><span class="p">,</span>
					    <span class="n">ahd_search_action</span> <span class="n">action</span><span class="p">,</span>
					    <span class="n">u_int</span> <span class="o">*</span><span class="n">list_head</span><span class="p">,</span> <span class="n">u_int</span> <span class="o">*</span><span class="n">list_tail</span><span class="p">,</span>
					    <span class="n">u_int</span> <span class="n">tid</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span>		<span class="n">ahd_stitch_tid_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span>
					    <span class="n">u_int</span> <span class="n">tid_prev</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">tid_cur</span><span class="p">,</span>
					    <span class="n">u_int</span> <span class="n">tid_next</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span>		<span class="n">ahd_add_scb_to_free_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span>
						 <span class="n">u_int</span> <span class="n">scbid</span><span class="p">);</span>
<span class="k">static</span> <span class="n">u_int</span>		<span class="n">ahd_rem_wscb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">scbid</span><span class="p">,</span>
				     <span class="n">u_int</span> <span class="n">prev</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">next</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">tid</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span>		<span class="n">ahd_reset_current_bus</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">);</span>
<span class="k">static</span> <span class="n">ahd_callback_t</span>	<span class="n">ahd_stat_timer</span><span class="p">;</span>
<span class="cp">#ifdef AHD_DUMP_SEQ</span>
<span class="k">static</span> <span class="kt">void</span>		<span class="n">ahd_dumpseq</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="k">static</span> <span class="kt">void</span>		<span class="n">ahd_loadseq</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span>		<span class="n">ahd_check_patch</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span>
					<span class="k">const</span> <span class="k">struct</span> <span class="n">patch</span> <span class="o">**</span><span class="n">start_patch</span><span class="p">,</span>
					<span class="n">u_int</span> <span class="n">start_instr</span><span class="p">,</span> <span class="n">u_int</span> <span class="o">*</span><span class="n">skip_addr</span><span class="p">);</span>
<span class="k">static</span> <span class="n">u_int</span>		<span class="n">ahd_resolve_seqaddr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span>
					    <span class="n">u_int</span> <span class="n">address</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span>		<span class="n">ahd_download_instr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span>
					   <span class="n">u_int</span> <span class="n">instrptr</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">dconsts</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span>		<span class="n">ahd_probe_stack_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span>		<span class="n">ahd_scb_active_in_fifo</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span>
					       <span class="k">struct</span> <span class="n">scb</span> <span class="o">*</span><span class="n">scb</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span>		<span class="n">ahd_run_data_fifo</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">scb</span> <span class="o">*</span><span class="n">scb</span><span class="p">);</span>

<span class="cp">#ifdef AHD_TARGET_MODE</span>
<span class="k">static</span> <span class="kt">void</span>		<span class="n">ahd_queue_lstate_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span>
					       <span class="k">struct</span> <span class="n">ahd_tmode_lstate</span> <span class="o">*</span><span class="n">lstate</span><span class="p">,</span>
					       <span class="n">u_int</span> <span class="n">initiator_id</span><span class="p">,</span>
					       <span class="n">u_int</span> <span class="n">event_type</span><span class="p">,</span>
					       <span class="n">u_int</span> <span class="n">event_arg</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span>		<span class="n">ahd_update_scsiid</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span>
					  <span class="n">u_int</span> <span class="n">targid_mask</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span>		<span class="n">ahd_handle_target_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span>
					      <span class="k">struct</span> <span class="n">target_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span>		<span class="n">ahd_abort_scbs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">,</span>
				       <span class="kt">char</span> <span class="n">channel</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lun</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">tag</span><span class="p">,</span>
				       <span class="n">role_t</span> <span class="n">role</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">status</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span>		<span class="n">ahd_alloc_scbs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span>		<span class="n">ahd_busy_tcl</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">tcl</span><span class="p">,</span>
				     <span class="n">u_int</span> <span class="n">scbid</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span>		<span class="n">ahd_calc_residual</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">scb</span> <span class="o">*</span><span class="n">scb</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span>		<span class="n">ahd_clear_critical_section</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span>		<span class="n">ahd_clear_intstat</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span>		<span class="n">ahd_enable_coalescing</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span>
					      <span class="kt">int</span> <span class="n">enable</span><span class="p">);</span>
<span class="k">static</span> <span class="n">u_int</span>		<span class="n">ahd_find_busy_tcl</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">tcl</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span>		<span class="n">ahd_freeze_devq</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">scb</span> <span class="o">*</span><span class="n">scb</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span>		<span class="n">ahd_handle_scb_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span>
					      <span class="k">struct</span> <span class="n">scb</span> <span class="o">*</span><span class="n">scb</span><span class="p">);</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ahd_phase_table_entry</span><span class="o">*</span> <span class="n">ahd_lookup_phase_entry</span><span class="p">(</span><span class="kt">int</span> <span class="n">phase</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span>		<span class="n">ahd_shutdown</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span>		<span class="n">ahd_update_coalescing_values</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span>
						     <span class="n">u_int</span> <span class="n">timer</span><span class="p">,</span>
						     <span class="n">u_int</span> <span class="n">maxcmds</span><span class="p">,</span>
						     <span class="n">u_int</span> <span class="n">mincmds</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span>		<span class="n">ahd_verify_vpd_cksum</span><span class="p">(</span><span class="k">struct</span> <span class="n">vpd_config</span> <span class="o">*</span><span class="n">vpd</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span>		<span class="n">ahd_wait_seeprom</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span>		<span class="n">ahd_match_scb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scb</span> <span class="o">*</span><span class="n">scb</span><span class="p">,</span>
				      <span class="kt">int</span> <span class="n">target</span><span class="p">,</span> <span class="kt">char</span> <span class="n">channel</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lun</span><span class="p">,</span>
				      <span class="n">u_int</span> <span class="n">tag</span><span class="p">,</span> <span class="n">role_t</span> <span class="n">role</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span>		<span class="n">ahd_reset_cmds_pending</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">);</span>

<span class="cm">/*************************** Interrupt Services *******************************/</span>
<span class="k">static</span> <span class="kt">void</span>		<span class="n">ahd_run_qoutfifo</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">);</span>
<span class="cp">#ifdef AHD_TARGET_MODE</span>
<span class="k">static</span> <span class="kt">void</span>		<span class="n">ahd_run_tqinfifo</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">paused</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="k">static</span> <span class="kt">void</span>		<span class="n">ahd_handle_hwerrint</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span>		<span class="n">ahd_handle_seqint</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">intstat</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span>		<span class="n">ahd_handle_scsiint</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span>
				           <span class="n">u_int</span> <span class="n">intstat</span><span class="p">);</span>

<span class="cm">/************************ Sequencer Execution Control *************************/</span>
<span class="kt">void</span>
<span class="nf">ahd_set_modes</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="n">ahd_mode</span> <span class="n">src</span><span class="p">,</span> <span class="n">ahd_mode</span> <span class="n">dst</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">src_mode</span> <span class="o">==</span> <span class="n">src</span> <span class="o">&amp;&amp;</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">dst_mode</span> <span class="o">==</span> <span class="n">dst</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
<span class="cp">#ifdef AHD_DEBUG</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">src_mode</span> <span class="o">==</span> <span class="n">AHD_MODE_UNKNOWN</span>
	 <span class="o">||</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">dst_mode</span> <span class="o">==</span> <span class="n">AHD_MODE_UNKNOWN</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Setting mode prior to saving it.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ahd_debug</span> <span class="o">&amp;</span> <span class="n">AHD_SHOW_MODEPTR</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: Setting mode 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">),</span>
		       <span class="n">ahd_build_mode_state</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">));</span>
<span class="cp">#endif</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">MODE_PTR</span><span class="p">,</span> <span class="n">ahd_build_mode_state</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">));</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">src_mode</span> <span class="o">=</span> <span class="n">src</span><span class="p">;</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">dst_mode</span> <span class="o">=</span> <span class="n">dst</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_update_modes</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ahd_mode_state</span> <span class="n">mode_ptr</span><span class="p">;</span>
	<span class="n">ahd_mode</span> <span class="n">src</span><span class="p">;</span>
	<span class="n">ahd_mode</span> <span class="n">dst</span><span class="p">;</span>

	<span class="n">mode_ptr</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">MODE_PTR</span><span class="p">);</span>
<span class="cp">#ifdef AHD_DEBUG</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ahd_debug</span> <span class="o">&amp;</span> <span class="n">AHD_SHOW_MODEPTR</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Reading mode 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mode_ptr</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">ahd_extract_mode_state</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">mode_ptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">src</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dst</span><span class="p">);</span>
	<span class="n">ahd_known_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_assert_modes</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="n">ahd_mode</span> <span class="n">srcmode</span><span class="p">,</span>
		 <span class="n">ahd_mode</span> <span class="n">dstmode</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">int</span> <span class="n">line</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef AHD_DEBUG</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">srcmode</span> <span class="o">&amp;</span> <span class="n">AHD_MK_MSK</span><span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">src_mode</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span>
	 <span class="o">||</span> <span class="p">(</span><span class="n">dstmode</span> <span class="o">&amp;</span> <span class="n">AHD_MK_MSK</span><span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">dst_mode</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;%s:%s:%d: Mode assertion failed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">),</span> <span class="n">file</span><span class="p">,</span> <span class="n">line</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cp">#define AHD_ASSERT_MODES(ahd, source, dest) \</span>
<span class="cp">	ahd_assert_modes(ahd, source, dest, __FILE__, __LINE__);</span>

<span class="n">ahd_mode_state</span>
<span class="nf">ahd_save_modes</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">src_mode</span> <span class="o">==</span> <span class="n">AHD_MODE_UNKNOWN</span>
	 <span class="o">||</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">dst_mode</span> <span class="o">==</span> <span class="n">AHD_MODE_UNKNOWN</span><span class="p">)</span>
		<span class="n">ahd_update_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">ahd_build_mode_state</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">src_mode</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">dst_mode</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">ahd_restore_modes</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="n">ahd_mode_state</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ahd_mode</span> <span class="n">src</span><span class="p">;</span>
	<span class="n">ahd_mode</span> <span class="n">dst</span><span class="p">;</span>

	<span class="n">ahd_extract_mode_state</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">src</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dst</span><span class="p">);</span>
	<span class="n">ahd_set_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Determine whether the sequencer has halted code execution.</span>
<span class="cm"> * Returns non-zero status if the sequencer is stopped.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">ahd_is_paused</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">((</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">HCNTRL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PAUSE</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Request that the sequencer stop and wait, indefinitely, for it</span>
<span class="cm"> * to stop.  The sequencer will only acknowledge that it is paused</span>
<span class="cm"> * once it has reached an instruction boundary and PAUSEDIS is</span>
<span class="cm"> * cleared in the SEQCTL register.  The sequencer may use PAUSEDIS</span>
<span class="cm"> * for critical sections.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">ahd_pause</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">HCNTRL</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">pause</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Since the sequencer can disable pausing in a critical section, we</span>
<span class="cm">	 * must loop until it actually stops.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">ahd_is_paused</span><span class="p">(</span><span class="n">ahd</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allow the sequencer to continue program execution.</span>
<span class="cm"> * We check here to ensure that no additional interrupt</span>
<span class="cm"> * sources that would cause the sequencer to halt have been</span>
<span class="cm"> * asserted.  If, for example, a SCSI bus reset is detected</span>
<span class="cm"> * while we are fielding a different, pausing, interrupt type,</span>
<span class="cm"> * we don&#39;t want to release the sequencer before going back</span>
<span class="cm"> * into our interrupt handler and dealing with this new</span>
<span class="cm"> * condition.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">ahd_unpause</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Automatically restore our modes to those saved</span>
<span class="cm">	 * prior to the first change of the mode.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">saved_src_mode</span> <span class="o">!=</span> <span class="n">AHD_MODE_UNKNOWN</span>
	 <span class="o">&amp;&amp;</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">saved_dst_mode</span> <span class="o">!=</span> <span class="n">AHD_MODE_UNKNOWN</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AHD_UPDATE_PEND_CMDS</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ahd_reset_cmds_pending</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
		<span class="n">ahd_set_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">saved_src_mode</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">saved_dst_mode</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">INTSTAT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">CMDCMPLT</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">HCNTRL</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">unpause</span><span class="p">);</span>

	<span class="n">ahd_known_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHD_MODE_UNKNOWN</span><span class="p">,</span> <span class="n">AHD_MODE_UNKNOWN</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*********************** Scatter Gather List Handling *************************/</span>
<span class="kt">void</span> <span class="o">*</span>
<span class="nf">ahd_sg_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scb</span> <span class="o">*</span><span class="n">scb</span><span class="p">,</span>
	     <span class="kt">void</span> <span class="o">*</span><span class="n">sgptr</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">addr</span><span class="p">,</span> <span class="n">bus_size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">last</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">scb</span><span class="o">-&gt;</span><span class="n">sg_count</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">dma_addr_t</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">4</span>
	 <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AHD_64BIT_ADDRESSING</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ahd_dma64_seg</span> <span class="o">*</span><span class="n">sg</span><span class="p">;</span>

		<span class="n">sg</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ahd_dma64_seg</span> <span class="o">*</span><span class="p">)</span><span class="n">sgptr</span><span class="p">;</span>
		<span class="n">sg</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span> <span class="n">ahd_htole64</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
		<span class="n">sg</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">ahd_htole32</span><span class="p">(</span><span class="n">len</span> <span class="o">|</span> <span class="p">(</span><span class="n">last</span> <span class="o">?</span> <span class="n">AHD_DMA_LAST_SEG</span> <span class="o">:</span> <span class="mi">0</span><span class="p">));</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">sg</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ahd_dma_seg</span> <span class="o">*</span><span class="n">sg</span><span class="p">;</span>

		<span class="n">sg</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ahd_dma_seg</span> <span class="o">*</span><span class="p">)</span><span class="n">sgptr</span><span class="p">;</span>
		<span class="n">sg</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span> <span class="n">ahd_htole32</span><span class="p">(</span><span class="n">addr</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFFFF</span><span class="p">);</span>
		<span class="n">sg</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">ahd_htole32</span><span class="p">(</span><span class="n">len</span> <span class="o">|</span> <span class="p">((</span><span class="n">addr</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x7F000000</span><span class="p">)</span>
				    <span class="o">|</span> <span class="p">(</span><span class="n">last</span> <span class="o">?</span> <span class="n">AHD_DMA_LAST_SEG</span> <span class="o">:</span> <span class="mi">0</span><span class="p">));</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">sg</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_setup_scb_common</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scb</span> <span class="o">*</span><span class="n">scb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* XXX Handle target mode SCBs. */</span>
	<span class="n">scb</span><span class="o">-&gt;</span><span class="n">crc_retry_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SCB_PACKETIZED</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* XXX what about ACA??  It is type 4, but TAG_TYPE == 0x3. */</span>
		<span class="n">scb</span><span class="o">-&gt;</span><span class="n">hscb</span><span class="o">-&gt;</span><span class="n">task_attribute</span> <span class="o">=</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">hscb</span><span class="o">-&gt;</span><span class="n">control</span> <span class="o">&amp;</span> <span class="n">SCB_TAG_TYPE</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ahd_get_transfer_length</span><span class="p">(</span><span class="n">scb</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">)</span>
			<span class="n">scb</span><span class="o">-&gt;</span><span class="n">hscb</span><span class="o">-&gt;</span><span class="n">task_attribute</span> <span class="o">=</span> <span class="n">SCB_XFERLEN_ODD</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">scb</span><span class="o">-&gt;</span><span class="n">hscb</span><span class="o">-&gt;</span><span class="n">task_attribute</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">hscb</span><span class="o">-&gt;</span><span class="n">cdb_len</span> <span class="o">&lt;=</span> <span class="n">MAX_CDB_LEN_WITH_SENSE_ADDR</span>
	 <span class="o">||</span> <span class="p">(</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">hscb</span><span class="o">-&gt;</span><span class="n">cdb_len</span> <span class="o">&amp;</span> <span class="n">SCB_CDB_LEN_PTR</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">scb</span><span class="o">-&gt;</span><span class="n">hscb</span><span class="o">-&gt;</span><span class="n">shared_data</span><span class="p">.</span><span class="n">idata</span><span class="p">.</span><span class="n">cdb_plus_saddr</span><span class="p">.</span><span class="n">sense_addr</span> <span class="o">=</span>
		    <span class="n">ahd_htole32</span><span class="p">(</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">sense_busaddr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_setup_data_scb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scb</span> <span class="o">*</span><span class="n">scb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Copy the first SG into the &quot;current&quot; data ponter area.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AHD_64BIT_ADDRESSING</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ahd_dma64_seg</span> <span class="o">*</span><span class="n">sg</span><span class="p">;</span>

		<span class="n">sg</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ahd_dma64_seg</span> <span class="o">*</span><span class="p">)</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">sg_list</span><span class="p">;</span>
		<span class="n">scb</span><span class="o">-&gt;</span><span class="n">hscb</span><span class="o">-&gt;</span><span class="n">dataptr</span> <span class="o">=</span> <span class="n">sg</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">;</span>
		<span class="n">scb</span><span class="o">-&gt;</span><span class="n">hscb</span><span class="o">-&gt;</span><span class="n">datacnt</span> <span class="o">=</span> <span class="n">sg</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ahd_dma_seg</span> <span class="o">*</span><span class="n">sg</span><span class="p">;</span>
		<span class="kt">uint32_t</span> <span class="o">*</span><span class="n">dataptr_words</span><span class="p">;</span>

		<span class="n">sg</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ahd_dma_seg</span> <span class="o">*</span><span class="p">)</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">sg_list</span><span class="p">;</span>
		<span class="n">dataptr_words</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">hscb</span><span class="o">-&gt;</span><span class="n">dataptr</span><span class="p">;</span>
		<span class="n">dataptr_words</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">sg</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">;</span>
		<span class="n">dataptr_words</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AHD_39BIT_ADDRESSING</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">uint64_t</span> <span class="n">high_addr</span><span class="p">;</span>

			<span class="n">high_addr</span> <span class="o">=</span> <span class="n">ahd_le32toh</span><span class="p">(</span><span class="n">sg</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x7F000000</span><span class="p">;</span>
			<span class="n">scb</span><span class="o">-&gt;</span><span class="n">hscb</span><span class="o">-&gt;</span><span class="n">dataptr</span> <span class="o">|=</span> <span class="n">ahd_htole64</span><span class="p">(</span><span class="n">high_addr</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">scb</span><span class="o">-&gt;</span><span class="n">hscb</span><span class="o">-&gt;</span><span class="n">datacnt</span> <span class="o">=</span> <span class="n">sg</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Note where to find the SG entries in bus space.</span>
<span class="cm">	 * We also set the full residual flag which the</span>
<span class="cm">	 * sequencer will clear as soon as a data transfer</span>
<span class="cm">	 * occurs.</span>
<span class="cm">	 */</span>
	<span class="n">scb</span><span class="o">-&gt;</span><span class="n">hscb</span><span class="o">-&gt;</span><span class="n">sgptr</span> <span class="o">=</span> <span class="n">ahd_htole32</span><span class="p">(</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">sg_list_busaddr</span><span class="o">|</span><span class="n">SG_FULL_RESID</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_setup_noxfer_scb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scb</span> <span class="o">*</span><span class="n">scb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">scb</span><span class="o">-&gt;</span><span class="n">hscb</span><span class="o">-&gt;</span><span class="n">sgptr</span> <span class="o">=</span> <span class="n">ahd_htole32</span><span class="p">(</span><span class="n">SG_LIST_NULL</span><span class="p">);</span>
	<span class="n">scb</span><span class="o">-&gt;</span><span class="n">hscb</span><span class="o">-&gt;</span><span class="n">dataptr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">scb</span><span class="o">-&gt;</span><span class="n">hscb</span><span class="o">-&gt;</span><span class="n">datacnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/************************** Memory mapping routines ***************************/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span>
<span class="nf">ahd_sg_bus_to_virt</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scb</span> <span class="o">*</span><span class="n">scb</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">sg_busaddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dma_addr_t</span> <span class="n">sg_offset</span><span class="p">;</span>

	<span class="cm">/* sg_list_phys points to entry 1, not 0 */</span>
	<span class="n">sg_offset</span> <span class="o">=</span> <span class="n">sg_busaddr</span> <span class="o">-</span> <span class="p">(</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">sg_list_busaddr</span> <span class="o">-</span> <span class="n">ahd_sg_size</span><span class="p">(</span><span class="n">ahd</span><span class="p">));</span>
	<span class="k">return</span> <span class="p">((</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">sg_list</span> <span class="o">+</span> <span class="n">sg_offset</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">uint32_t</span>
<span class="nf">ahd_sg_virt_to_bus</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scb</span> <span class="o">*</span><span class="n">scb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">sg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dma_addr_t</span> <span class="n">sg_offset</span><span class="p">;</span>

	<span class="cm">/* sg_list_phys points to entry 1, not 0 */</span>
	<span class="n">sg_offset</span> <span class="o">=</span> <span class="p">((</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span><span class="n">sg</span> <span class="o">-</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">sg_list</span><span class="p">)</span>
		  <span class="o">-</span> <span class="n">ahd_sg_size</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">sg_list_busaddr</span> <span class="o">+</span> <span class="n">sg_offset</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_sync_scb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scb</span> <span class="o">*</span><span class="n">scb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ahd_dmamap_sync</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">scb_data</span><span class="p">.</span><span class="n">hscb_dmat</span><span class="p">,</span>
			<span class="n">scb</span><span class="o">-&gt;</span><span class="n">hscb_map</span><span class="o">-&gt;</span><span class="n">dmamap</span><span class="p">,</span>
			<span class="cm">/*offset*/</span><span class="p">(</span><span class="kt">uint8_t</span><span class="o">*</span><span class="p">)</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">hscb</span> <span class="o">-</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">hscb_map</span><span class="o">-&gt;</span><span class="n">vaddr</span><span class="p">,</span>
			<span class="cm">/*len*/</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">hscb</span><span class="p">),</span> <span class="n">op</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">ahd_sync_sglist</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scb</span> <span class="o">*</span><span class="n">scb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">sg_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">ahd_dmamap_sync</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">scb_data</span><span class="p">.</span><span class="n">sg_dmat</span><span class="p">,</span>
			<span class="n">scb</span><span class="o">-&gt;</span><span class="n">sg_map</span><span class="o">-&gt;</span><span class="n">dmamap</span><span class="p">,</span>
			<span class="cm">/*offset*/</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">sg_list_busaddr</span> <span class="o">-</span> <span class="n">ahd_sg_size</span><span class="p">(</span><span class="n">ahd</span><span class="p">),</span>
			<span class="cm">/*len*/</span><span class="n">ahd_sg_size</span><span class="p">(</span><span class="n">ahd</span><span class="p">)</span> <span class="o">*</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">sg_count</span><span class="p">,</span> <span class="n">op</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_sync_sense</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scb</span> <span class="o">*</span><span class="n">scb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ahd_dmamap_sync</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">scb_data</span><span class="p">.</span><span class="n">sense_dmat</span><span class="p">,</span>
			<span class="n">scb</span><span class="o">-&gt;</span><span class="n">sense_map</span><span class="o">-&gt;</span><span class="n">dmamap</span><span class="p">,</span>
			<span class="cm">/*offset*/</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">sense_busaddr</span><span class="p">,</span>
			<span class="cm">/*len*/</span><span class="n">AHD_SENSE_BUFSIZE</span><span class="p">,</span> <span class="n">op</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef AHD_TARGET_MODE</span>
<span class="k">static</span> <span class="kt">uint32_t</span>
<span class="nf">ahd_targetcmd_offset</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(((</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">targetcmds</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
	       <span class="o">-</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">qoutfifo</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*********************** Miscellaneous Support Functions ***********************/</span>
<span class="cm">/*</span>
<span class="cm"> * Return pointers to the transfer negotiation information</span>
<span class="cm"> * for the specified our_id/remote_id pair.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ahd_initiator_tinfo</span> <span class="o">*</span>
<span class="nf">ahd_fetch_transinfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="kt">char</span> <span class="n">channel</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">our_id</span><span class="p">,</span>
		    <span class="n">u_int</span> <span class="n">remote_id</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ahd_tmode_tstate</span> <span class="o">**</span><span class="n">tstate</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Transfer data structures are stored from the perspective</span>
<span class="cm">	 * of the target role.  Since the parameters for a connection</span>
<span class="cm">	 * in the initiator role to a given target are the same as</span>
<span class="cm">	 * when the roles are reversed, we pretend we are the target.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">channel</span> <span class="o">==</span> <span class="sc">&#39;B&#39;</span><span class="p">)</span>
		<span class="n">our_id</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="o">*</span><span class="n">tstate</span> <span class="o">=</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">enabled_targets</span><span class="p">[</span><span class="n">our_id</span><span class="p">];</span>
	<span class="k">return</span> <span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">tstate</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">transinfo</span><span class="p">[</span><span class="n">remote_id</span><span class="p">]);</span>
<span class="p">}</span>

<span class="kt">uint16_t</span>
<span class="nf">ahd_inw</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Read high byte first as some registers increment</span>
<span class="cm">	 * or have other side effects when the low byte is</span>
<span class="cm">	 * read.</span>
<span class="cm">	 */</span>
	<span class="kt">uint16_t</span> <span class="n">r</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">port</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">r</span> <span class="o">|</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">ahd_outw</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">port</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Write low byte first to accommodate registers</span>
<span class="cm">	 * such as PRGMCNT where the order maters.</span>
<span class="cm">	 */</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">value</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">port</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">value</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">uint32_t</span>
<span class="nf">ahd_inl</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">((</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">port</span><span class="p">))</span>
	      <span class="o">|</span> <span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">port</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span>
	      <span class="o">|</span> <span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">port</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span>
	      <span class="o">|</span> <span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">port</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">ahd_outl</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">port</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">port</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="p">((</span><span class="n">value</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">port</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="p">((</span><span class="n">value</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">port</span><span class="o">+</span><span class="mi">3</span><span class="p">,</span> <span class="p">((</span><span class="n">value</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">uint64_t</span>
<span class="nf">ahd_inq</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">((</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">port</span><span class="p">))</span>
	      <span class="o">|</span> <span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">port</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span>
	      <span class="o">|</span> <span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">port</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span>
	      <span class="o">|</span> <span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">port</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span>
	      <span class="o">|</span> <span class="p">(((</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">port</span><span class="o">+</span><span class="mi">4</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">)</span>
	      <span class="o">|</span> <span class="p">(((</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">port</span><span class="o">+</span><span class="mi">5</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="mi">40</span><span class="p">)</span>
	      <span class="o">|</span> <span class="p">(((</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">port</span><span class="o">+</span><span class="mi">6</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="mi">48</span><span class="p">)</span>
	      <span class="o">|</span> <span class="p">(((</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">port</span><span class="o">+</span><span class="mi">7</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="mi">56</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">ahd_outq</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">port</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">value</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">port</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">value</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">port</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="n">value</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">port</span><span class="o">+</span><span class="mi">3</span><span class="p">,</span> <span class="p">(</span><span class="n">value</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">port</span><span class="o">+</span><span class="mi">4</span><span class="p">,</span> <span class="p">(</span><span class="n">value</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">port</span><span class="o">+</span><span class="mi">5</span><span class="p">,</span> <span class="p">(</span><span class="n">value</span> <span class="o">&gt;&gt;</span> <span class="mi">40</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">port</span><span class="o">+</span><span class="mi">6</span><span class="p">,</span> <span class="p">(</span><span class="n">value</span> <span class="o">&gt;&gt;</span> <span class="mi">48</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">port</span><span class="o">+</span><span class="mi">7</span><span class="p">,</span> <span class="p">(</span><span class="n">value</span> <span class="o">&gt;&gt;</span> <span class="mi">56</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">u_int</span>
<span class="nf">ahd_get_scbptr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">AHD_ASSERT_MODES</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="o">~</span><span class="p">(</span><span class="n">AHD_MODE_UNKNOWN_MSK</span><span class="o">|</span><span class="n">AHD_MODE_CFG_MSK</span><span class="p">),</span>
			 <span class="o">~</span><span class="p">(</span><span class="n">AHD_MODE_UNKNOWN_MSK</span><span class="o">|</span><span class="n">AHD_MODE_CFG_MSK</span><span class="p">));</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCBPTR</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCBPTR</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">ahd_set_scbptr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">scbptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">AHD_ASSERT_MODES</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="o">~</span><span class="p">(</span><span class="n">AHD_MODE_UNKNOWN_MSK</span><span class="o">|</span><span class="n">AHD_MODE_CFG_MSK</span><span class="p">),</span>
			 <span class="o">~</span><span class="p">(</span><span class="n">AHD_MODE_UNKNOWN_MSK</span><span class="o">|</span><span class="n">AHD_MODE_CFG_MSK</span><span class="p">));</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCBPTR</span><span class="p">,</span> <span class="n">scbptr</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCBPTR</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">scbptr</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#if 0</span><span class="c"> /* unused */</span>
<span class="c">static u_int</span>
<span class="c">ahd_get_hnscb_qoff(struct ahd_softc *ahd)</span>
<span class="c">{</span>
<span class="c">	return (ahd_inw_atomic(ahd, HNSCB_QOFF));</span>
<span class="c">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_set_hnscb_qoff</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ahd_outw_atomic</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">HNSCB_QOFF</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#if 0</span><span class="c"> /* unused */</span>
<span class="c">static u_int</span>
<span class="c">ahd_get_hescb_qoff(struct ahd_softc *ahd)</span>
<span class="c">{</span>
<span class="c">	return (ahd_inb(ahd, HESCB_QOFF));</span>
<span class="c">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_set_hescb_qoff</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">HESCB_QOFF</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u_int</span>
<span class="nf">ahd_get_snscb_qoff</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u_int</span> <span class="n">oldvalue</span><span class="p">;</span>

	<span class="n">AHD_ASSERT_MODES</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHD_MODE_CCHAN_MSK</span><span class="p">,</span> <span class="n">AHD_MODE_CCHAN_MSK</span><span class="p">);</span>
	<span class="n">oldvalue</span> <span class="o">=</span> <span class="n">ahd_inw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SNSCB_QOFF</span><span class="p">);</span>
	<span class="n">ahd_outw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SNSCB_QOFF</span><span class="p">,</span> <span class="n">oldvalue</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">oldvalue</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_set_snscb_qoff</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">AHD_ASSERT_MODES</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHD_MODE_CCHAN_MSK</span><span class="p">,</span> <span class="n">AHD_MODE_CCHAN_MSK</span><span class="p">);</span>
	<span class="n">ahd_outw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SNSCB_QOFF</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#if 0</span><span class="c"> /* unused */</span>
<span class="c">static u_int</span>
<span class="c">ahd_get_sescb_qoff(struct ahd_softc *ahd)</span>
<span class="c">{</span>
<span class="c">	AHD_ASSERT_MODES(ahd, AHD_MODE_CCHAN_MSK, AHD_MODE_CCHAN_MSK);</span>
<span class="c">	return (ahd_inb(ahd, SESCB_QOFF));</span>
<span class="c">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_set_sescb_qoff</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">AHD_ASSERT_MODES</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHD_MODE_CCHAN_MSK</span><span class="p">,</span> <span class="n">AHD_MODE_CCHAN_MSK</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SESCB_QOFF</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#if 0</span><span class="c"> /* unused */</span>
<span class="c">static u_int</span>
<span class="c">ahd_get_sdscb_qoff(struct ahd_softc *ahd)</span>
<span class="c">{</span>
<span class="c">	AHD_ASSERT_MODES(ahd, AHD_MODE_CCHAN_MSK, AHD_MODE_CCHAN_MSK);</span>
<span class="c">	return (ahd_inb(ahd, SDSCB_QOFF) | (ahd_inb(ahd, SDSCB_QOFF + 1) &lt;&lt; 8));</span>
<span class="c">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_set_sdscb_qoff</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">AHD_ASSERT_MODES</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHD_MODE_CCHAN_MSK</span><span class="p">,</span> <span class="n">AHD_MODE_CCHAN_MSK</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SDSCB_QOFF</span><span class="p">,</span> <span class="n">value</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SDSCB_QOFF</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">value</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">u_int</span>
<span class="nf">ahd_inb_scbram</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u_int</span> <span class="n">value</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Workaround PCI-X Rev A. hardware bug.</span>
<span class="cm">	 * After a host read of SCB memory, the chip</span>
<span class="cm">	 * may become confused into thinking prefetch</span>
<span class="cm">	 * was required.  This starts the discard timer</span>
<span class="cm">	 * running and can cause an unexpected discard</span>
<span class="cm">	 * timer interrupt.  The work around is to read</span>
<span class="cm">	 * a normal register prior to the exhaustion of</span>
<span class="cm">	 * the discard timer.  The mode pointer register</span>
<span class="cm">	 * has no side effects and so serves well for</span>
<span class="cm">	 * this purpose.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Razor #528</span>
<span class="cm">	 */</span>
	<span class="n">value</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">bugs</span> <span class="o">&amp;</span> <span class="n">AHD_PCIX_SCBRAM_RD_BUG</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">MODE_PTR</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">u_int</span>
<span class="nf">ahd_inw_scbram</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">ahd_inb_scbram</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>
	      <span class="o">|</span> <span class="p">(</span><span class="n">ahd_inb_scbram</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">offset</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">uint32_t</span>
<span class="nf">ahd_inl_scbram</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">ahd_inw_scbram</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>
	      <span class="o">|</span> <span class="p">(</span><span class="n">ahd_inw_scbram</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">offset</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">uint64_t</span>
<span class="nf">ahd_inq_scbram</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">ahd_inl_scbram</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>
	      <span class="o">|</span> <span class="p">((</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">ahd_inl_scbram</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">offset</span><span class="o">+</span><span class="mi">4</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">scb</span> <span class="o">*</span>
<span class="nf">ahd_lookup_scb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">tag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scb</span><span class="o">*</span> <span class="n">scb</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tag</span> <span class="o">&gt;=</span> <span class="n">AHD_SCB_MAX</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
	<span class="n">scb</span> <span class="o">=</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">scb_data</span><span class="p">.</span><span class="n">scbindex</span><span class="p">[</span><span class="n">tag</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">scb</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">ahd_sync_scb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">,</span>
			     <span class="n">BUS_DMASYNC_POSTREAD</span><span class="o">|</span><span class="n">BUS_DMASYNC_POSTWRITE</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">scb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_swap_with_next_hscb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scb</span> <span class="o">*</span><span class="n">scb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span>	 <span class="n">hardware_scb</span> <span class="o">*</span><span class="n">q_hscb</span><span class="p">;</span>
	<span class="k">struct</span>	 <span class="n">map_node</span> <span class="o">*</span><span class="n">q_hscb_map</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">saved_hscb_busaddr</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Our queuing method is a bit tricky.  The card</span>
<span class="cm">	 * knows in advance which HSCB (by address) to download,</span>
<span class="cm">	 * and we can&#39;t disappoint it.  To achieve this, the next</span>
<span class="cm">	 * HSCB to download is saved off in ahd-&gt;next_queued_hscb.</span>
<span class="cm">	 * When we are called to queue &quot;an arbitrary scb&quot;,</span>
<span class="cm">	 * we copy the contents of the incoming HSCB to the one</span>
<span class="cm">	 * the sequencer knows about, swap HSCB pointers and</span>
<span class="cm">	 * finally assign the SCB to the tag indexed location</span>
<span class="cm">	 * in the scb_array.  This makes sure that we can still</span>
<span class="cm">	 * locate the correct SCB by SCB_TAG.</span>
<span class="cm">	 */</span>
	<span class="n">q_hscb</span> <span class="o">=</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">next_queued_hscb</span><span class="p">;</span>
	<span class="n">q_hscb_map</span> <span class="o">=</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">next_queued_hscb_map</span><span class="p">;</span>
	<span class="n">saved_hscb_busaddr</span> <span class="o">=</span> <span class="n">q_hscb</span><span class="o">-&gt;</span><span class="n">hscb_busaddr</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">q_hscb</span><span class="p">,</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">hscb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">hscb</span><span class="p">));</span>
	<span class="n">q_hscb</span><span class="o">-&gt;</span><span class="n">hscb_busaddr</span> <span class="o">=</span> <span class="n">saved_hscb_busaddr</span><span class="p">;</span>
	<span class="n">q_hscb</span><span class="o">-&gt;</span><span class="n">next_hscb_busaddr</span> <span class="o">=</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">hscb</span><span class="o">-&gt;</span><span class="n">hscb_busaddr</span><span class="p">;</span>

	<span class="cm">/* Now swap HSCB pointers. */</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">next_queued_hscb</span> <span class="o">=</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">hscb</span><span class="p">;</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">next_queued_hscb_map</span> <span class="o">=</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">hscb_map</span><span class="p">;</span>
	<span class="n">scb</span><span class="o">-&gt;</span><span class="n">hscb</span> <span class="o">=</span> <span class="n">q_hscb</span><span class="p">;</span>
	<span class="n">scb</span><span class="o">-&gt;</span><span class="n">hscb_map</span> <span class="o">=</span> <span class="n">q_hscb_map</span><span class="p">;</span>

	<span class="cm">/* Now define the mapping from tag to SCB in the scbindex */</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">scb_data</span><span class="p">.</span><span class="n">scbindex</span><span class="p">[</span><span class="n">SCB_GET_TAG</span><span class="p">(</span><span class="n">scb</span><span class="p">)]</span> <span class="o">=</span> <span class="n">scb</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Tell the sequencer about a new transaction to execute.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">ahd_queue_scb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scb</span> <span class="o">*</span><span class="n">scb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ahd_swap_with_next_hscb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">SCBID_IS_NULL</span><span class="p">(</span><span class="n">SCB_GET_TAG</span><span class="p">(</span><span class="n">scb</span><span class="p">)))</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Attempt to queue invalid SCB tag %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		      <span class="n">SCB_GET_TAG</span><span class="p">(</span><span class="n">scb</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Keep a history of SCBs we&#39;ve downloaded in the qinfifo.</span>
<span class="cm">	 */</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">qinfifo</span><span class="p">[</span><span class="n">AHD_QIN_WRAP</span><span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">qinfifonext</span><span class="p">)]</span> <span class="o">=</span> <span class="n">SCB_GET_TAG</span><span class="p">(</span><span class="n">scb</span><span class="p">);</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">qinfifonext</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">sg_count</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ahd_setup_data_scb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ahd_setup_noxfer_scb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
	<span class="n">ahd_setup_scb_common</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Make sure our data is consistent from the</span>
<span class="cm">	 * perspective of the adapter.</span>
<span class="cm">	 */</span>
	<span class="n">ahd_sync_scb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">,</span> <span class="n">BUS_DMASYNC_PREREAD</span><span class="o">|</span><span class="n">BUS_DMASYNC_PREWRITE</span><span class="p">);</span>

<span class="cp">#ifdef AHD_DEBUG</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ahd_debug</span> <span class="o">&amp;</span> <span class="n">AHD_SHOW_QUEUE</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">uint64_t</span> <span class="n">host_dataptr</span><span class="p">;</span>

		<span class="n">host_dataptr</span> <span class="o">=</span> <span class="n">ahd_le64toh</span><span class="p">(</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">hscb</span><span class="o">-&gt;</span><span class="n">dataptr</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: Queueing SCB %d:0x%x bus addr 0x%x - 0x%x%x/0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">),</span>
		       <span class="n">SCB_GET_TAG</span><span class="p">(</span><span class="n">scb</span><span class="p">),</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">hscb</span><span class="o">-&gt;</span><span class="n">scsiid</span><span class="p">,</span>
		       <span class="n">ahd_le32toh</span><span class="p">(</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">hscb</span><span class="o">-&gt;</span><span class="n">hscb_busaddr</span><span class="p">),</span>
		       <span class="p">(</span><span class="n">u_int</span><span class="p">)((</span><span class="n">host_dataptr</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFFFF</span><span class="p">),</span>
		       <span class="p">(</span><span class="n">u_int</span><span class="p">)(</span><span class="n">host_dataptr</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFFFF</span><span class="p">),</span>
		       <span class="n">ahd_le32toh</span><span class="p">(</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">hscb</span><span class="o">-&gt;</span><span class="n">datacnt</span><span class="p">));</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="cm">/* Tell the adapter about the newly queued SCB */</span>
	<span class="n">ahd_set_hnscb_qoff</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">qinfifonext</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/************************** Interrupt Processing ******************************/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_sync_qoutfifo</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ahd_dmamap_sync</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">shared_data_dmat</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">shared_data_map</span><span class="p">.</span><span class="n">dmamap</span><span class="p">,</span>
			<span class="cm">/*offset*/</span><span class="mi">0</span><span class="p">,</span>
			<span class="cm">/*len*/</span><span class="n">AHD_SCB_MAX</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_completion</span><span class="p">),</span> <span class="n">op</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_sync_tqinfifo</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef AHD_TARGET_MODE</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AHD_TARGETROLE</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ahd_dmamap_sync</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">shared_data_dmat</span><span class="p">,</span>
				<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">shared_data_map</span><span class="p">.</span><span class="n">dmamap</span><span class="p">,</span>
				<span class="n">ahd_targetcmd_offset</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">target_cmd</span><span class="p">)</span> <span class="o">*</span> <span class="n">AHD_TMODE_CMDS</span><span class="p">,</span>
				<span class="n">op</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * See if the firmware has posted any completed commands</span>
<span class="cm"> * into our in-core command complete fifos.</span>
<span class="cm"> */</span>
<span class="cp">#define AHD_RUN_QOUTFIFO 0x1</span>
<span class="cp">#define AHD_RUN_TQINFIFO 0x2</span>
<span class="k">static</span> <span class="n">u_int</span>
<span class="nf">ahd_check_cmdcmpltqueues</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u_int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ahd_dmamap_sync</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">shared_data_dmat</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">shared_data_map</span><span class="p">.</span><span class="n">dmamap</span><span class="p">,</span>
			<span class="cm">/*offset*/</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">qoutfifonext</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">qoutfifo</span><span class="p">),</span>
			<span class="cm">/*len*/</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">qoutfifo</span><span class="p">),</span> <span class="n">BUS_DMASYNC_POSTREAD</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">qoutfifo</span><span class="p">[</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">qoutfifonext</span><span class="p">].</span><span class="n">valid_tag</span>
	  <span class="o">==</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">qoutfifonext_valid_tag</span><span class="p">)</span>
		<span class="n">retval</span> <span class="o">|=</span> <span class="n">AHD_RUN_QOUTFIFO</span><span class="p">;</span>
<span class="cp">#ifdef AHD_TARGET_MODE</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AHD_TARGETROLE</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>
	 <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AHD_TQINFIFO_BLOCKED</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ahd_dmamap_sync</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">shared_data_dmat</span><span class="p">,</span>
				<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">shared_data_map</span><span class="p">.</span><span class="n">dmamap</span><span class="p">,</span>
				<span class="n">ahd_targetcmd_offset</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">tqinfifofnext</span><span class="p">),</span>
				<span class="cm">/*len*/</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">target_cmd</span><span class="p">),</span>
				<span class="n">BUS_DMASYNC_POSTREAD</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">targetcmds</span><span class="p">[</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">tqinfifonext</span><span class="p">].</span><span class="n">cmd_valid</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">retval</span> <span class="o">|=</span> <span class="n">AHD_RUN_TQINFIFO</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">retval</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Catch an interrupt from the adapter</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">ahd_intr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u_int</span>	<span class="n">intstat</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">pause</span> <span class="o">&amp;</span> <span class="n">INTEN</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Our interrupt is not enabled on the chip</span>
<span class="cm">		 * and may be disabled for re-entrancy reasons,</span>
<span class="cm">		 * so just return.  This is likely just a shared</span>
<span class="cm">		 * interrupt.</span>
<span class="cm">		 */</span>
		<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Instead of directly reading the interrupt status register,</span>
<span class="cm">	 * infer the cause of the interrupt by checking our in-core</span>
<span class="cm">	 * completion queues.  This avoids a costly PCI bus read in</span>
<span class="cm">	 * most cases.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AHD_ALL_INTERRUPTS</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
	 <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ahd_check_cmdcmpltqueues</span><span class="p">(</span><span class="n">ahd</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">intstat</span> <span class="o">=</span> <span class="n">CMDCMPLT</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">intstat</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">INTSTAT</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">intstat</span> <span class="o">&amp;</span> <span class="n">INT_PEND</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">intstat</span> <span class="o">&amp;</span> <span class="n">CMDCMPLT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CLRINT</span><span class="p">,</span> <span class="n">CLRCMDINT</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Ensure that the chip sees that we&#39;ve cleared</span>
<span class="cm">		 * this interrupt before we walk the output fifo.</span>
<span class="cm">		 * Otherwise, we may, due to posted bus writes,</span>
<span class="cm">		 * clear the interrupt after we finish the scan,</span>
<span class="cm">		 * and after the sequencer has added new entries</span>
<span class="cm">		 * and asserted the interrupt again.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">bugs</span> <span class="o">&amp;</span> <span class="n">AHD_INTCOLLISION_BUG</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ahd_is_paused</span><span class="p">(</span><span class="n">ahd</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Potentially lost SEQINT.</span>
<span class="cm">				 * If SEQINTCODE is non-zero,</span>
<span class="cm">				 * simulate the SEQINT.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SEQINTCODE</span><span class="p">)</span> <span class="o">!=</span> <span class="n">NO_SEQINT</span><span class="p">)</span>
					<span class="n">intstat</span> <span class="o">|=</span> <span class="n">SEQINT</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ahd_flush_device_writes</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">ahd_run_qoutfifo</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
		<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">cmdcmplt_counts</span><span class="p">[</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">cmdcmplt_bucket</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
		<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">cmdcmplt_total</span><span class="o">++</span><span class="p">;</span>
<span class="cp">#ifdef AHD_TARGET_MODE</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AHD_TARGETROLE</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ahd_run_tqinfifo</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="cm">/*paused*/</span><span class="n">FALSE</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Handle statuses that may invalidate our cached</span>
<span class="cm">	 * copy of INTSTAT separately.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">intstat</span> <span class="o">==</span> <span class="mh">0xFF</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">AHD_REMOVABLE</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Hot eject.  Do nothing */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">intstat</span> <span class="o">&amp;</span> <span class="n">HWERRINT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ahd_handle_hwerrint</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">intstat</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PCIINT</span><span class="o">|</span><span class="n">SPLTINT</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">bus_intr</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">intstat</span> <span class="o">&amp;</span> <span class="n">SEQINT</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ahd_handle_seqint</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">intstat</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">intstat</span> <span class="o">&amp;</span> <span class="n">SCSIINT</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ahd_handle_scsiint</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">intstat</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/******************************** Private Inlines *****************************/</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">ahd_assert_atn</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCSISIGO</span><span class="p">,</span> <span class="n">ATNO</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Determine if the current connection has a packetized</span>
<span class="cm"> * agreement.  This does not necessarily mean that we</span>
<span class="cm"> * are currently in a packetized transfer.  We could</span>
<span class="cm"> * just as easily be sending or receiving a message.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ahd_currently_packetized</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ahd_mode_state</span>	 <span class="n">saved_modes</span><span class="p">;</span>
	<span class="kt">int</span>		 <span class="n">packetized</span><span class="p">;</span>

	<span class="n">saved_modes</span> <span class="o">=</span> <span class="n">ahd_save_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">bugs</span> <span class="o">&amp;</span> <span class="n">AHD_PKTIZED_STATUS_BUG</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The packetized bit refers to the last</span>
<span class="cm">		 * connection, not the current one.  Check</span>
<span class="cm">		 * for non-zero LQISTATE instead.</span>
<span class="cm">		 */</span>
		<span class="n">ahd_set_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHD_MODE_CFG</span><span class="p">,</span> <span class="n">AHD_MODE_CFG</span><span class="p">);</span>
		<span class="n">packetized</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">LQISTATE</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ahd_set_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI</span><span class="p">);</span>
		<span class="n">packetized</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">LQISTAT2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PACKETIZED</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ahd_restore_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">saved_modes</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">packetized</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">ahd_set_active_fifo</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u_int</span> <span class="n">active_fifo</span><span class="p">;</span>

	<span class="n">AHD_ASSERT_MODES</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI_MSK</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI_MSK</span><span class="p">);</span>
	<span class="n">active_fifo</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">DFFSTAT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">CURRFIFO</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">active_fifo</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="n">ahd_set_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">active_fifo</span><span class="p">,</span> <span class="n">active_fifo</span><span class="p">);</span>
		<span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">ahd_unbusy_tcl</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">tcl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ahd_busy_tcl</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">tcl</span><span class="p">,</span> <span class="n">SCB_LIST_NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Determine whether the sequencer reported a residual</span>
<span class="cm"> * for this SCB/transaction.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">ahd_update_residual</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scb</span> <span class="o">*</span><span class="n">scb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">sgptr</span><span class="p">;</span>

	<span class="n">sgptr</span> <span class="o">=</span> <span class="n">ahd_le32toh</span><span class="p">(</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">hscb</span><span class="o">-&gt;</span><span class="n">sgptr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">sgptr</span> <span class="o">&amp;</span> <span class="n">SG_STATUS_VALID</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ahd_calc_residual</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">ahd_complete_scb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scb</span> <span class="o">*</span><span class="n">scb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">sgptr</span><span class="p">;</span>

	<span class="n">sgptr</span> <span class="o">=</span> <span class="n">ahd_le32toh</span><span class="p">(</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">hscb</span><span class="o">-&gt;</span><span class="n">sgptr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">sgptr</span> <span class="o">&amp;</span> <span class="n">SG_STATUS_VALID</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ahd_handle_scb_status</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ahd_done</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/************************* Sequencer Execution Control ************************/</span>
<span class="cm">/*</span>
<span class="cm"> * Restart the sequencer program from address zero</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_restart</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">)</span>
<span class="p">{</span>

	<span class="n">ahd_pause</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>

	<span class="n">ahd_set_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI</span><span class="p">);</span>

	<span class="cm">/* No more pending messages */</span>
	<span class="n">ahd_clear_msg_state</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCSISIGO</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>		<span class="cm">/* De-assert BSY */</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">MSG_OUT</span><span class="p">,</span> <span class="n">MSG_NOOP</span><span class="p">);</span>	<span class="cm">/* No message to send */</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SXFRCTL1</span><span class="p">,</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SXFRCTL1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">BITBUCKET</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SEQINTCTL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">LASTPHASE</span><span class="p">,</span> <span class="n">P_BUSFREE</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SEQ_FLAGS</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SAVED_SCSIID</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SAVED_LUN</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Ensure that the sequencer&#39;s idea of TQINPOS</span>
<span class="cm">	 * matches our own.  The sequencer increments TQINPOS</span>
<span class="cm">	 * only after it sees a DMA complete and a reset could</span>
<span class="cm">	 * occur before the increment leaving the kernel to believe</span>
<span class="cm">	 * the command arrived but the sequencer to not.</span>
<span class="cm">	 */</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">TQINPOS</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">tqinfifonext</span><span class="p">);</span>

	<span class="cm">/* Always allow reselection */</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCSISEQ1</span><span class="p">,</span>
		 <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCSISEQ_TEMPLATE</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ENSELI</span><span class="o">|</span><span class="n">ENRSELI</span><span class="o">|</span><span class="n">ENAUTOATNP</span><span class="p">));</span>
	<span class="n">ahd_set_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHD_MODE_CCHAN</span><span class="p">,</span> <span class="n">AHD_MODE_CCHAN</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Clear any pending sequencer interrupt.  It is no</span>
<span class="cm">	 * longer relevant since we&#39;re resetting the Program</span>
<span class="cm">	 * Counter.</span>
<span class="cm">	 */</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CLRINT</span><span class="p">,</span> <span class="n">CLRSEQINT</span><span class="p">);</span>

	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SEQCTL0</span><span class="p">,</span> <span class="n">FASTMODE</span><span class="o">|</span><span class="n">SEQRESET</span><span class="p">);</span>
	<span class="n">ahd_unpause</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_clear_fifo</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">fifo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ahd_mode_state</span>	 <span class="n">saved_modes</span><span class="p">;</span>

<span class="cp">#ifdef AHD_DEBUG</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ahd_debug</span> <span class="o">&amp;</span> <span class="n">AHD_SHOW_FIFOS</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: Clearing FIFO %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">),</span> <span class="n">fifo</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">saved_modes</span> <span class="o">=</span> <span class="n">ahd_save_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
	<span class="n">ahd_set_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">fifo</span><span class="p">,</span> <span class="n">fifo</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">DFFSXFRCTL</span><span class="p">,</span> <span class="n">RSTCHN</span><span class="o">|</span><span class="n">CLRSHCNT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SG_STATE</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">FETCH_INPROG</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CCSGCTL</span><span class="p">,</span> <span class="n">CCSGRESET</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">LONGJMP_ADDR</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">INVALID_ADDR</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SG_STATE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ahd_restore_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">saved_modes</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/************************* Input/Output Queues ********************************/</span>
<span class="cm">/*</span>
<span class="cm"> * Flush and completed commands that are sitting in the command</span>
<span class="cm"> * complete queues down on the chip but have yet to be dma&#39;ed back up.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_flush_qoutfifo</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span>		<span class="n">scb</span> <span class="o">*</span><span class="n">scb</span><span class="p">;</span>
	<span class="n">ahd_mode_state</span>	<span class="n">saved_modes</span><span class="p">;</span>
	<span class="n">u_int</span>		<span class="n">saved_scbptr</span><span class="p">;</span>
	<span class="n">u_int</span>		<span class="n">ccscbctl</span><span class="p">;</span>
	<span class="n">u_int</span>		<span class="n">scbid</span><span class="p">;</span>
	<span class="n">u_int</span>		<span class="n">next_scbid</span><span class="p">;</span>

	<span class="n">saved_modes</span> <span class="o">=</span> <span class="n">ahd_save_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Flush the good status FIFO for completed packetized commands.</span>
<span class="cm">	 */</span>
	<span class="n">ahd_set_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI</span><span class="p">);</span>
	<span class="n">saved_scbptr</span> <span class="o">=</span> <span class="n">ahd_get_scbptr</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">LQISTAT2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">LQIGSAVAIL</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u_int</span> <span class="n">fifo_mode</span><span class="p">;</span>
		<span class="n">u_int</span> <span class="n">i</span><span class="p">;</span>
		
		<span class="n">scbid</span> <span class="o">=</span> <span class="n">ahd_inw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">GSFIFO</span><span class="p">);</span>
		<span class="n">scb</span> <span class="o">=</span> <span class="n">ahd_lookup_scb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scbid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">scb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: Warning - GSFIFO SCB %d invalid</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">),</span> <span class="n">scbid</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * Determine if this transaction is still active in</span>
<span class="cm">		 * any FIFO.  If it is, we must flush that FIFO to</span>
<span class="cm">		 * the host before completing the  command.</span>
<span class="cm">		 */</span>
		<span class="n">fifo_mode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">rescan_fifos:</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Toggle to the other mode. */</span>
			<span class="n">fifo_mode</span> <span class="o">^=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">ahd_set_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">fifo_mode</span><span class="p">,</span> <span class="n">fifo_mode</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">ahd_scb_active_in_fifo</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="n">ahd_run_data_fifo</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * Running this FIFO may cause a CFG4DATA for</span>
<span class="cm">			 * this same transaction to assert in the other</span>
<span class="cm">			 * FIFO or a new snapshot SAVEPTRS interrupt</span>
<span class="cm">			 * in this FIFO.  Even running a FIFO may not</span>
<span class="cm">			 * clear the transaction if we are still waiting</span>
<span class="cm">			 * for data to drain to the host. We must loop</span>
<span class="cm">			 * until the transaction is not active in either</span>
<span class="cm">			 * FIFO just to be sure.  Reset our loop counter</span>
<span class="cm">			 * so we will visit both FIFOs again before</span>
<span class="cm">			 * declaring this transaction finished.  We</span>
<span class="cm">			 * also delay a bit so that status has a chance</span>
<span class="cm">			 * to change before we look at this FIFO again.</span>
<span class="cm">			 */</span>
			<span class="n">ahd_delay</span><span class="p">(</span><span class="mi">200</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">rescan_fifos</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ahd_set_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI</span><span class="p">);</span>
		<span class="n">ahd_set_scbptr</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scbid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ahd_inb_scbram</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_SGPTR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SG_LIST_NULL</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
		 <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">ahd_inb_scbram</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_SGPTR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SG_FULL_RESID</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>
		  <span class="o">||</span> <span class="p">(</span><span class="n">ahd_inb_scbram</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_RESIDUAL_SGPTR</span><span class="p">)</span>
		      <span class="o">&amp;</span> <span class="n">SG_LIST_NULL</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">u_int</span> <span class="n">comp_head</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * The transfer completed with a residual.</span>
<span class="cm">			 * Place this SCB on the complete DMA list</span>
<span class="cm">			 * so that we update our in-core copy of the</span>
<span class="cm">			 * SCB before completing the command.</span>
<span class="cm">			 */</span>
			<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_SCSI_STATUS</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_SGPTR</span><span class="p">,</span>
				 <span class="n">ahd_inb_scbram</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_SGPTR</span><span class="p">)</span>
				 <span class="o">|</span> <span class="n">SG_STATUS_VALID</span><span class="p">);</span>
			<span class="n">ahd_outw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_TAG</span><span class="p">,</span> <span class="n">scbid</span><span class="p">);</span>
			<span class="n">ahd_outw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_NEXT_COMPLETE</span><span class="p">,</span> <span class="n">SCB_LIST_NULL</span><span class="p">);</span>
			<span class="n">comp_head</span> <span class="o">=</span> <span class="n">ahd_inw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">COMPLETE_DMA_SCB_HEAD</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">SCBID_IS_NULL</span><span class="p">(</span><span class="n">comp_head</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ahd_outw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">COMPLETE_DMA_SCB_HEAD</span><span class="p">,</span> <span class="n">scbid</span><span class="p">);</span>
				<span class="n">ahd_outw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">COMPLETE_DMA_SCB_TAIL</span><span class="p">,</span> <span class="n">scbid</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">u_int</span> <span class="n">tail</span><span class="p">;</span>

				<span class="n">tail</span> <span class="o">=</span> <span class="n">ahd_inw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">COMPLETE_DMA_SCB_TAIL</span><span class="p">);</span>
				<span class="n">ahd_set_scbptr</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">tail</span><span class="p">);</span>
				<span class="n">ahd_outw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_NEXT_COMPLETE</span><span class="p">,</span> <span class="n">scbid</span><span class="p">);</span>
				<span class="n">ahd_outw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">COMPLETE_DMA_SCB_TAIL</span><span class="p">,</span> <span class="n">scbid</span><span class="p">);</span>
				<span class="n">ahd_set_scbptr</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scbid</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">ahd_complete_scb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">ahd_set_scbptr</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">saved_scbptr</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Setup for command channel portion of flush.</span>
<span class="cm">	 */</span>
	<span class="n">ahd_set_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHD_MODE_CCHAN</span><span class="p">,</span> <span class="n">AHD_MODE_CCHAN</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Wait for any inprogress DMA to complete and clear DMA state</span>
<span class="cm">	 * if this if for an SCB in the qinfifo.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(((</span><span class="n">ccscbctl</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CCSCBCTL</span><span class="p">))</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">CCARREN</span><span class="o">|</span><span class="n">CCSCBEN</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">ccscbctl</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">CCSCBDIR</span><span class="o">|</span><span class="n">CCARREN</span><span class="p">))</span> <span class="o">==</span> <span class="p">(</span><span class="n">CCSCBDIR</span><span class="o">|</span><span class="n">CCARREN</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">ccscbctl</span> <span class="o">&amp;</span> <span class="n">ARRDONE</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">ccscbctl</span> <span class="o">&amp;</span> <span class="n">CCSCBDONE</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">ahd_delay</span><span class="p">(</span><span class="mi">200</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * We leave the sequencer to cleanup in the case of DMA&#39;s to</span>
<span class="cm">	 * update the qoutfifo.  In all other cases (DMA&#39;s to the</span>
<span class="cm">	 * chip or a push of an SCB from the COMPLETE_DMA_SCB list),</span>
<span class="cm">	 * we disable the DMA engine so that the sequencer will not</span>
<span class="cm">	 * attempt to handle the DMA completion.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ccscbctl</span> <span class="o">&amp;</span> <span class="n">CCSCBDIR</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="p">(</span><span class="n">ccscbctl</span> <span class="o">&amp;</span> <span class="n">ARRDONE</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CCSCBCTL</span><span class="p">,</span> <span class="n">ccscbctl</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">CCARREN</span><span class="o">|</span><span class="n">CCSCBEN</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Complete any SCBs that just finished</span>
<span class="cm">	 * being DMA&#39;ed into the qoutfifo.</span>
<span class="cm">	 */</span>
	<span class="n">ahd_run_qoutfifo</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>

	<span class="n">saved_scbptr</span> <span class="o">=</span> <span class="n">ahd_get_scbptr</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Manually update/complete any completed SCBs that are waiting to be</span>
<span class="cm">	 * DMA&#39;ed back up to the host.</span>
<span class="cm">	 */</span>
	<span class="n">scbid</span> <span class="o">=</span> <span class="n">ahd_inw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">COMPLETE_DMA_SCB_HEAD</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">SCBID_IS_NULL</span><span class="p">(</span><span class="n">scbid</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">hscb_ptr</span><span class="p">;</span>
		<span class="n">u_int</span>	 <span class="n">i</span><span class="p">;</span>
		
		<span class="n">ahd_set_scbptr</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scbid</span><span class="p">);</span>
		<span class="n">next_scbid</span> <span class="o">=</span> <span class="n">ahd_inw_scbram</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_NEXT_COMPLETE</span><span class="p">);</span>
		<span class="n">scb</span> <span class="o">=</span> <span class="n">ahd_lookup_scb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scbid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">scb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: Warning - DMA-up and complete &quot;</span>
			       <span class="s">&quot;SCB %d invalid</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">),</span> <span class="n">scbid</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">hscb_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">hscb</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hardware_scb</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="o">*</span><span class="n">hscb_ptr</span><span class="o">++</span> <span class="o">=</span> <span class="n">ahd_inb_scbram</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_BASE</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>

		<span class="n">ahd_complete_scb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
		<span class="n">scbid</span> <span class="o">=</span> <span class="n">next_scbid</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ahd_outw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">COMPLETE_DMA_SCB_HEAD</span><span class="p">,</span> <span class="n">SCB_LIST_NULL</span><span class="p">);</span>
	<span class="n">ahd_outw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">COMPLETE_DMA_SCB_TAIL</span><span class="p">,</span> <span class="n">SCB_LIST_NULL</span><span class="p">);</span>

	<span class="n">scbid</span> <span class="o">=</span> <span class="n">ahd_inw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">COMPLETE_ON_QFREEZE_HEAD</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">SCBID_IS_NULL</span><span class="p">(</span><span class="n">scbid</span><span class="p">))</span> <span class="p">{</span>

		<span class="n">ahd_set_scbptr</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scbid</span><span class="p">);</span>
		<span class="n">next_scbid</span> <span class="o">=</span> <span class="n">ahd_inw_scbram</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_NEXT_COMPLETE</span><span class="p">);</span>
		<span class="n">scb</span> <span class="o">=</span> <span class="n">ahd_lookup_scb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scbid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">scb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: Warning - Complete Qfrz SCB %d invalid</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">),</span> <span class="n">scbid</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ahd_complete_scb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
		<span class="n">scbid</span> <span class="o">=</span> <span class="n">next_scbid</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ahd_outw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">COMPLETE_ON_QFREEZE_HEAD</span><span class="p">,</span> <span class="n">SCB_LIST_NULL</span><span class="p">);</span>

	<span class="n">scbid</span> <span class="o">=</span> <span class="n">ahd_inw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">COMPLETE_SCB_HEAD</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">SCBID_IS_NULL</span><span class="p">(</span><span class="n">scbid</span><span class="p">))</span> <span class="p">{</span>

		<span class="n">ahd_set_scbptr</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scbid</span><span class="p">);</span>
		<span class="n">next_scbid</span> <span class="o">=</span> <span class="n">ahd_inw_scbram</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_NEXT_COMPLETE</span><span class="p">);</span>
		<span class="n">scb</span> <span class="o">=</span> <span class="n">ahd_lookup_scb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scbid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">scb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: Warning - Complete SCB %d invalid</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">),</span> <span class="n">scbid</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ahd_complete_scb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
		<span class="n">scbid</span> <span class="o">=</span> <span class="n">next_scbid</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ahd_outw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">COMPLETE_SCB_HEAD</span><span class="p">,</span> <span class="n">SCB_LIST_NULL</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Restore state.</span>
<span class="cm">	 */</span>
	<span class="n">ahd_set_scbptr</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">saved_scbptr</span><span class="p">);</span>
	<span class="n">ahd_restore_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">saved_modes</span><span class="p">);</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">AHD_UPDATE_PEND_CMDS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Determine if an SCB for a packetized transaction</span>
<span class="cm"> * is active in a FIFO.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ahd_scb_active_in_fifo</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scb</span> <span class="o">*</span><span class="n">scb</span><span class="p">)</span>
<span class="p">{</span>

	<span class="cm">/*</span>
<span class="cm">	 * The FIFO is only active for our transaction if</span>
<span class="cm">	 * the SCBPTR matches the SCB&#39;s ID and the firmware</span>
<span class="cm">	 * has installed a handler for the FIFO or we have</span>
<span class="cm">	 * a pending SAVEPTRS or CFG4DATA interrupt.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ahd_get_scbptr</span><span class="p">(</span><span class="n">ahd</span><span class="p">)</span> <span class="o">!=</span> <span class="n">SCB_GET_TAG</span><span class="p">(</span><span class="n">scb</span><span class="p">)</span>
	 <span class="o">||</span> <span class="p">((</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">LONGJMP_ADDR</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">INVALID_ADDR</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>
	  <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SEQINTSRC</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">CFG4DATA</span><span class="o">|</span><span class="n">SAVEPTRS</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Run a data fifo to completion for a transaction we know</span>
<span class="cm"> * has completed across the SCSI bus (good status has been</span>
<span class="cm"> * received).  We are already set to the correct FIFO mode</span>
<span class="cm"> * on entry to this routine.</span>
<span class="cm"> *</span>
<span class="cm"> * This function attempts to operate exactly as the firmware</span>
<span class="cm"> * would when running this FIFO.  Care must be taken to update</span>
<span class="cm"> * this routine any time the firmware&#39;s FIFO algorithm is</span>
<span class="cm"> * changed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_run_data_fifo</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scb</span> <span class="o">*</span><span class="n">scb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u_int</span> <span class="n">seqintsrc</span><span class="p">;</span>

	<span class="n">seqintsrc</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SEQINTSRC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">seqintsrc</span> <span class="o">&amp;</span> <span class="n">CFG4DATA</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">uint32_t</span> <span class="n">datacnt</span><span class="p">;</span>
		<span class="kt">uint32_t</span> <span class="n">sgptr</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Clear full residual flag.</span>
<span class="cm">		 */</span>
		<span class="n">sgptr</span> <span class="o">=</span> <span class="n">ahd_inl_scbram</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_SGPTR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">SG_FULL_RESID</span><span class="p">;</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_SGPTR</span><span class="p">,</span> <span class="n">sgptr</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Load datacnt and address.</span>
<span class="cm">		 */</span>
		<span class="n">datacnt</span> <span class="o">=</span> <span class="n">ahd_inl_scbram</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_DATACNT</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">datacnt</span> <span class="o">&amp;</span> <span class="n">AHD_DMA_LAST_SEG</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sgptr</span> <span class="o">|=</span> <span class="n">LAST_SEG</span><span class="p">;</span>
			<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SG_STATE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SG_STATE</span><span class="p">,</span> <span class="n">LOADING_NEEDED</span><span class="p">);</span>
		<span class="n">ahd_outq</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">HADDR</span><span class="p">,</span> <span class="n">ahd_inq_scbram</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_DATAPTR</span><span class="p">));</span>
		<span class="n">ahd_outl</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">HCNT</span><span class="p">,</span> <span class="n">datacnt</span> <span class="o">&amp;</span> <span class="n">AHD_SG_LEN_MASK</span><span class="p">);</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SG_CACHE_PRE</span><span class="p">,</span> <span class="n">sgptr</span><span class="p">);</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">DFCNTRL</span><span class="p">,</span> <span class="n">PRELOADEN</span><span class="o">|</span><span class="n">SCSIEN</span><span class="o">|</span><span class="n">HDMAEN</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Initialize Residual Fields.</span>
<span class="cm">		 */</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_RESIDUAL_DATACNT</span><span class="o">+</span><span class="mi">3</span><span class="p">,</span> <span class="n">datacnt</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">);</span>
		<span class="n">ahd_outl</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_RESIDUAL_SGPTR</span><span class="p">,</span> <span class="n">sgptr</span> <span class="o">&amp;</span> <span class="n">SG_PTR_MASK</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Mark the SCB as having a FIFO in use.</span>
<span class="cm">		 */</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_FIFO_USE_COUNT</span><span class="p">,</span>
			 <span class="n">ahd_inb_scbram</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_FIFO_USE_COUNT</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Install a &quot;fake&quot; handler for this FIFO.</span>
<span class="cm">		 */</span>
		<span class="n">ahd_outw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">LONGJMP_ADDR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Notify the hardware that we have satisfied</span>
<span class="cm">		 * this sequencer interrupt.</span>
<span class="cm">		 */</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CLRSEQINTSRC</span><span class="p">,</span> <span class="n">CLRCFG4DATA</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">seqintsrc</span> <span class="o">&amp;</span> <span class="n">SAVEPTRS</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">uint32_t</span> <span class="n">sgptr</span><span class="p">;</span>
		<span class="kt">uint32_t</span> <span class="n">resid</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">LONGJMP_ADDR</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">&amp;</span><span class="n">INVALID_ADDR</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Snapshot Save Pointers.  All that</span>
<span class="cm">			 * is necessary to clear the snapshot</span>
<span class="cm">			 * is a CLRCHN.</span>
<span class="cm">			 */</span>
			<span class="k">goto</span> <span class="n">clrchn</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Disable S/G fetch so the DMA engine</span>
<span class="cm">		 * is available to future users.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SG_STATE</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">FETCH_INPROG</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CCSGCTL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SG_STATE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Flush the data FIFO.  Strickly only</span>
<span class="cm">		 * necessary for Rev A parts.</span>
<span class="cm">		 */</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">DFCNTRL</span><span class="p">,</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">DFCNTRL</span><span class="p">)</span> <span class="o">|</span> <span class="n">FIFOFLUSH</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Calculate residual.</span>
<span class="cm">		 */</span>
		<span class="n">sgptr</span> <span class="o">=</span> <span class="n">ahd_inl_scbram</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_RESIDUAL_SGPTR</span><span class="p">);</span>
		<span class="n">resid</span> <span class="o">=</span> <span class="n">ahd_inl</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SHCNT</span><span class="p">);</span>
		<span class="n">resid</span> <span class="o">|=</span> <span class="n">ahd_inb_scbram</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_RESIDUAL_DATACNT</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">;</span>
		<span class="n">ahd_outl</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_RESIDUAL_DATACNT</span><span class="p">,</span> <span class="n">resid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SG_CACHE_SHADOW</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">LAST_SEG</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Must back up to the correct S/G element.</span>
<span class="cm">			 * Typically this just means resetting our</span>
<span class="cm">			 * low byte to the offset in the SG_CACHE,</span>
<span class="cm">			 * but if we wrapped, we have to correct</span>
<span class="cm">			 * the other bytes of the sgptr too.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SG_CACHE_SHADOW</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>
			 <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">sgptr</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">sgptr</span> <span class="o">-=</span> <span class="mh">0x100</span><span class="p">;</span>
			<span class="n">sgptr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mh">0xFF</span><span class="p">;</span>
			<span class="n">sgptr</span> <span class="o">|=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SG_CACHE_SHADOW</span><span class="p">)</span>
			       <span class="o">&amp;</span> <span class="n">SG_ADDR_MASK</span><span class="p">;</span>
			<span class="n">ahd_outl</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_RESIDUAL_SGPTR</span><span class="p">,</span> <span class="n">sgptr</span><span class="p">);</span>
			<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_RESIDUAL_DATACNT</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">resid</span> <span class="o">&amp;</span> <span class="n">AHD_SG_LEN_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_RESIDUAL_SGPTR</span><span class="p">,</span>
				 <span class="n">sgptr</span> <span class="o">|</span> <span class="n">SG_LIST_NULL</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * Save Pointers.</span>
<span class="cm">		 */</span>
		<span class="n">ahd_outq</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_DATAPTR</span><span class="p">,</span> <span class="n">ahd_inq</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SHADDR</span><span class="p">));</span>
		<span class="n">ahd_outl</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_DATACNT</span><span class="p">,</span> <span class="n">resid</span><span class="p">);</span>
		<span class="n">ahd_outl</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_SGPTR</span><span class="p">,</span> <span class="n">sgptr</span><span class="p">);</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CLRSEQINTSRC</span><span class="p">,</span> <span class="n">CLRSAVEPTRS</span><span class="p">);</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SEQIMODE</span><span class="p">,</span>
			 <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SEQIMODE</span><span class="p">)</span> <span class="o">|</span> <span class="n">ENSAVEPTRS</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * If the data is to the SCSI bus, we are</span>
<span class="cm">		 * done, otherwise wait for FIFOEMP.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">DFCNTRL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">DIRECTION</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">clrchn</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SG_STATE</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">LOADING_NEEDED</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">uint32_t</span> <span class="n">sgptr</span><span class="p">;</span>
		<span class="kt">uint64_t</span> <span class="n">data_addr</span><span class="p">;</span>
		<span class="kt">uint32_t</span> <span class="n">data_len</span><span class="p">;</span>
		<span class="n">u_int</span>	 <span class="n">dfcntrl</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Disable S/G fetch so the DMA engine</span>
<span class="cm">		 * is available to future users.  We won&#39;t</span>
<span class="cm">		 * be using the DMA engine to load segments.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SG_STATE</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">FETCH_INPROG</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CCSGCTL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SG_STATE</span><span class="p">,</span> <span class="n">LOADING_NEEDED</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Wait for the DMA engine to notice that the</span>
<span class="cm">		 * host transfer is enabled and that there is</span>
<span class="cm">		 * space in the S/G FIFO for new segments before</span>
<span class="cm">		 * loading more segments.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">DFSTATUS</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PRELOAD_AVAIL</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>
		 <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">DFCNTRL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">HDMAENACK</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

			<span class="cm">/*</span>
<span class="cm">			 * Determine the offset of the next S/G</span>
<span class="cm">			 * element to load.</span>
<span class="cm">			 */</span>
			<span class="n">sgptr</span> <span class="o">=</span> <span class="n">ahd_inl_scbram</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_RESIDUAL_SGPTR</span><span class="p">);</span>
			<span class="n">sgptr</span> <span class="o">&amp;=</span> <span class="n">SG_PTR_MASK</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AHD_64BIT_ADDRESSING</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">struct</span> <span class="n">ahd_dma64_seg</span> <span class="o">*</span><span class="n">sg</span><span class="p">;</span>

				<span class="n">sg</span> <span class="o">=</span> <span class="n">ahd_sg_bus_to_virt</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">,</span> <span class="n">sgptr</span><span class="p">);</span>
				<span class="n">data_addr</span> <span class="o">=</span> <span class="n">sg</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">;</span>
				<span class="n">data_len</span> <span class="o">=</span> <span class="n">sg</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
				<span class="n">sgptr</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">sg</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">struct</span>	<span class="n">ahd_dma_seg</span> <span class="o">*</span><span class="n">sg</span><span class="p">;</span>

				<span class="n">sg</span> <span class="o">=</span> <span class="n">ahd_sg_bus_to_virt</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">,</span> <span class="n">sgptr</span><span class="p">);</span>
				<span class="n">data_addr</span> <span class="o">=</span> <span class="n">sg</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&amp;</span> <span class="n">AHD_SG_HIGH_ADDR_MASK</span><span class="p">;</span>
				<span class="n">data_addr</span> <span class="o">&lt;&lt;=</span> <span class="mi">8</span><span class="p">;</span>
				<span class="n">data_addr</span> <span class="o">|=</span> <span class="n">sg</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">;</span>
				<span class="n">data_len</span> <span class="o">=</span> <span class="n">sg</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
				<span class="n">sgptr</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">sg</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * Update residual information.</span>
<span class="cm">			 */</span>
			<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_RESIDUAL_DATACNT</span><span class="o">+</span><span class="mi">3</span><span class="p">,</span> <span class="n">data_len</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">);</span>
			<span class="n">ahd_outl</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_RESIDUAL_SGPTR</span><span class="p">,</span> <span class="n">sgptr</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * Load the S/G.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">data_len</span> <span class="o">&amp;</span> <span class="n">AHD_DMA_LAST_SEG</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">sgptr</span> <span class="o">|=</span> <span class="n">LAST_SEG</span><span class="p">;</span>
				<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SG_STATE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">ahd_outq</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">HADDR</span><span class="p">,</span> <span class="n">data_addr</span><span class="p">);</span>
			<span class="n">ahd_outl</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">HCNT</span><span class="p">,</span> <span class="n">data_len</span> <span class="o">&amp;</span> <span class="n">AHD_SG_LEN_MASK</span><span class="p">);</span>
			<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SG_CACHE_PRE</span><span class="p">,</span> <span class="n">sgptr</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * Advertise the segment to the hardware.</span>
<span class="cm">			 */</span>
			<span class="n">dfcntrl</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">DFCNTRL</span><span class="p">)</span><span class="o">|</span><span class="n">PRELOADEN</span><span class="o">|</span><span class="n">HDMAEN</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">AHD_NEW_DFCNTRL_OPTS</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Use SCSIENWRDIS so that SCSIEN</span>
<span class="cm">				 * is never modified by this</span>
<span class="cm">				 * operation.</span>
<span class="cm">				 */</span>
				<span class="n">dfcntrl</span> <span class="o">|=</span> <span class="n">SCSIENWRDIS</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">DFCNTRL</span><span class="p">,</span> <span class="n">dfcntrl</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SG_CACHE_SHADOW</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">LAST_SEG_DONE</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/*</span>
<span class="cm">		 * Transfer completed to the end of SG list</span>
<span class="cm">		 * and has flushed to the host.</span>
<span class="cm">		 */</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_SGPTR</span><span class="p">,</span>
			 <span class="n">ahd_inb_scbram</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_SGPTR</span><span class="p">)</span> <span class="o">|</span> <span class="n">SG_LIST_NULL</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">clrchn</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">DFSTATUS</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">FIFOEMP</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">clrchn:</span>
		<span class="cm">/*</span>
<span class="cm">		 * Clear any handler for this FIFO, decrement</span>
<span class="cm">		 * the FIFO use count for the SCB, and release</span>
<span class="cm">		 * the FIFO.</span>
<span class="cm">		 */</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">LONGJMP_ADDR</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">INVALID_ADDR</span><span class="p">);</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_FIFO_USE_COUNT</span><span class="p">,</span>
			 <span class="n">ahd_inb_scbram</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_FIFO_USE_COUNT</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">DFFSXFRCTL</span><span class="p">,</span> <span class="n">CLRCHN</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Look for entries in the QoutFIFO that have completed.</span>
<span class="cm"> * The valid_tag completion field indicates the validity</span>
<span class="cm"> * of the entry - the valid value toggles each time through</span>
<span class="cm"> * the queue. We use the sg_status field in the completion</span>
<span class="cm"> * entry to avoid referencing the hscb if the completion</span>
<span class="cm"> * occurred with no errors and no residual.  sg_status is</span>
<span class="cm"> * a copy of the first byte (little endian) of the sgptr</span>
<span class="cm"> * hscb field.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_run_qoutfifo</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ahd_completion</span> <span class="o">*</span><span class="n">completion</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scb</span> <span class="o">*</span><span class="n">scb</span><span class="p">;</span>
	<span class="n">u_int</span>  <span class="n">scb_index</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AHD_RUNNING_QOUTFIFO</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;ahd_run_qoutfifo recursion&quot;</span><span class="p">);</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">AHD_RUNNING_QOUTFIFO</span><span class="p">;</span>
	<span class="n">ahd_sync_qoutfifo</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">BUS_DMASYNC_POSTREAD</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">completion</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">qoutfifo</span><span class="p">[</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">qoutfifonext</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">completion</span><span class="o">-&gt;</span><span class="n">valid_tag</span> <span class="o">!=</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">qoutfifonext_valid_tag</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">scb_index</span> <span class="o">=</span> <span class="n">ahd_le16toh</span><span class="p">(</span><span class="n">completion</span><span class="o">-&gt;</span><span class="n">tag</span><span class="p">);</span>
		<span class="n">scb</span> <span class="o">=</span> <span class="n">ahd_lookup_scb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb_index</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">scb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: WARNING no command for scb %d &quot;</span>
			       <span class="s">&quot;(cmdcmplt)</span><span class="se">\n</span><span class="s">QOUTPOS = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">),</span> <span class="n">scb_index</span><span class="p">,</span>
			       <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">qoutfifonext</span><span class="p">);</span>
			<span class="n">ahd_dump_card_state</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">completion</span><span class="o">-&gt;</span><span class="n">sg_status</span> <span class="o">&amp;</span> <span class="n">SG_STATUS_VALID</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ahd_handle_scb_status</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ahd_done</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">qoutfifonext</span> <span class="o">=</span> <span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">qoutfifonext</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">AHD_QOUT_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">qoutfifonext</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">qoutfifonext_valid_tag</span> <span class="o">^=</span> <span class="n">QOUTFIFO_ENTRY_VALID</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">AHD_RUNNING_QOUTFIFO</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/************************* Interrupt Handling *********************************/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_handle_hwerrint</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Some catastrophic hardware error has occurred.</span>
<span class="cm">	 * Print it for the user and disable the controller.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">ERROR</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_errors</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">&amp;</span> <span class="n">ahd_hard_errors</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">errno</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: hwerrint, %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">),</span> <span class="n">ahd_hard_errors</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">errmesg</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ahd_dump_card_state</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
	<span class="n">panic</span><span class="p">(</span><span class="s">&quot;BRKADRINT&quot;</span><span class="p">);</span>

	<span class="cm">/* Tell everyone that this HBA is no longer available */</span>
	<span class="n">ahd_abort_scbs</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CAM_TARGET_WILDCARD</span><span class="p">,</span> <span class="n">ALL_CHANNELS</span><span class="p">,</span>
		       <span class="n">CAM_LUN_WILDCARD</span><span class="p">,</span> <span class="n">SCB_LIST_NULL</span><span class="p">,</span> <span class="n">ROLE_UNKNOWN</span><span class="p">,</span>
		       <span class="n">CAM_NO_HBA</span><span class="p">);</span>

	<span class="cm">/* Tell the system that this controller has gone away. */</span>
	<span class="n">ahd_free</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef AHD_DEBUG</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_dump_sglist</span><span class="p">(</span><span class="k">struct</span> <span class="n">scb</span> <span class="o">*</span><span class="n">scb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">sg_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">ahd_softc</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AHD_64BIT_ADDRESSING</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">ahd_dma64_seg</span> <span class="o">*</span><span class="n">sg_list</span><span class="p">;</span>

			<span class="n">sg_list</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ahd_dma64_seg</span><span class="o">*</span><span class="p">)</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">sg_list</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">sg_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="kt">uint64_t</span> <span class="n">addr</span><span class="p">;</span>
				<span class="kt">uint32_t</span> <span class="n">len</span><span class="p">;</span>

				<span class="n">addr</span> <span class="o">=</span> <span class="n">ahd_le64toh</span><span class="p">(</span><span class="n">sg_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">addr</span><span class="p">);</span>
				<span class="n">len</span> <span class="o">=</span> <span class="n">ahd_le32toh</span><span class="p">(</span><span class="n">sg_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">len</span><span class="p">);</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;sg[%d] - Addr 0x%x%x : Length %d%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">i</span><span class="p">,</span>
				       <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)((</span><span class="n">addr</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFFFF</span><span class="p">),</span>
				       <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)(</span><span class="n">addr</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFFFF</span><span class="p">),</span>
				       <span class="n">sg_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">len</span> <span class="o">&amp;</span> <span class="n">AHD_SG_LEN_MASK</span><span class="p">,</span>
				       <span class="p">(</span><span class="n">sg_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">len</span> <span class="o">&amp;</span> <span class="n">AHD_DMA_LAST_SEG</span><span class="p">)</span>
				     <span class="o">?</span> <span class="s">&quot; Last&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">ahd_dma_seg</span> <span class="o">*</span><span class="n">sg_list</span><span class="p">;</span>

			<span class="n">sg_list</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ahd_dma_seg</span><span class="o">*</span><span class="p">)</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">sg_list</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">sg_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="kt">uint32_t</span> <span class="n">len</span><span class="p">;</span>

				<span class="n">len</span> <span class="o">=</span> <span class="n">ahd_le32toh</span><span class="p">(</span><span class="n">sg_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">len</span><span class="p">);</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;sg[%d] - Addr 0x%x%x : Length %d%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">i</span><span class="p">,</span>
				       <span class="p">(</span><span class="n">len</span> <span class="o">&amp;</span> <span class="n">AHD_SG_HIGH_ADDR_MASK</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">,</span>
				       <span class="n">ahd_le32toh</span><span class="p">(</span><span class="n">sg_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">addr</span><span class="p">),</span>
				       <span class="n">len</span> <span class="o">&amp;</span> <span class="n">AHD_SG_LEN_MASK</span><span class="p">,</span>
				       <span class="n">len</span> <span class="o">&amp;</span> <span class="n">AHD_DMA_LAST_SEG</span> <span class="o">?</span> <span class="s">&quot; Last&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif  </span><span class="cm">/*  AHD_DEBUG  */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_handle_seqint</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">intstat</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u_int</span> <span class="n">seqintcode</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Save the sequencer interrupt code and clear the SEQINT</span>
<span class="cm">	 * bit. We will unpause the sequencer, if appropriate,</span>
<span class="cm">	 * after servicing the request.</span>
<span class="cm">	 */</span>
	<span class="n">seqintcode</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SEQINTCODE</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CLRINT</span><span class="p">,</span> <span class="n">CLRSEQINT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">bugs</span> <span class="o">&amp;</span> <span class="n">AHD_INTCOLLISION_BUG</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Unpause the sequencer and let it clear</span>
<span class="cm">		 * SEQINT by writing NO_SEQINT to it.  This</span>
<span class="cm">		 * will cause the sequencer to be paused again,</span>
<span class="cm">		 * which is the expected state of this routine.</span>
<span class="cm">		 */</span>
		<span class="n">ahd_unpause</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">ahd_is_paused</span><span class="p">(</span><span class="n">ahd</span><span class="p">))</span>
			<span class="p">;</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CLRINT</span><span class="p">,</span> <span class="n">CLRSEQINT</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">ahd_update_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
<span class="cp">#ifdef AHD_DEBUG</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ahd_debug</span> <span class="o">&amp;</span> <span class="n">AHD_SHOW_MISC</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: Handle Seqint Called for code %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">),</span> <span class="n">seqintcode</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">seqintcode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ENTERING_NONPACK</span>:
	<span class="p">{</span>
		<span class="k">struct</span>	<span class="n">scb</span> <span class="o">*</span><span class="n">scb</span><span class="p">;</span>
		<span class="n">u_int</span>	<span class="n">scbid</span><span class="p">;</span>

		<span class="n">AHD_ASSERT_MODES</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="o">~</span><span class="p">(</span><span class="n">AHD_MODE_UNKNOWN_MSK</span><span class="o">|</span><span class="n">AHD_MODE_CFG_MSK</span><span class="p">),</span>
				 <span class="o">~</span><span class="p">(</span><span class="n">AHD_MODE_UNKNOWN_MSK</span><span class="o">|</span><span class="n">AHD_MODE_CFG_MSK</span><span class="p">));</span>
		<span class="n">scbid</span> <span class="o">=</span> <span class="n">ahd_get_scbptr</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
		<span class="n">scb</span> <span class="o">=</span> <span class="n">ahd_lookup_scb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scbid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">scb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Somehow need to know if this</span>
<span class="cm">			 * is from a selection or reselection.</span>
<span class="cm">			 * From that, we can determine target</span>
<span class="cm">			 * ID so we at least have an I_T nexus.</span>
<span class="cm">			 */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SAVED_SCSIID</span><span class="p">,</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">hscb</span><span class="o">-&gt;</span><span class="n">scsiid</span><span class="p">);</span>
			<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SAVED_LUN</span><span class="p">,</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">hscb</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>
			<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SEQ_FLAGS</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">LQISTAT2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">LQIPHASE_OUTPKT</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>
		 <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCSISIGO</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">ATNO</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Phase change after read stream with</span>
<span class="cm">			 * CRC error with P0 asserted on last</span>
<span class="cm">			 * packet.</span>
<span class="cm">			 */</span>
<span class="cp">#ifdef AHD_DEBUG</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">ahd_debug</span> <span class="o">&amp;</span> <span class="n">AHD_SHOW_RECOVERY</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: Assuming LQIPHASE_NLQ with &quot;</span>
				       <span class="s">&quot;P0 assertion</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">));</span>
<span class="cp">#endif</span>
		<span class="p">}</span>
<span class="cp">#ifdef AHD_DEBUG</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ahd_debug</span> <span class="o">&amp;</span> <span class="n">AHD_SHOW_RECOVERY</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: Entering NONPACK</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">));</span>
<span class="cp">#endif</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">INVALID_SEQINT</span>:
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: Invalid Sequencer interrupt occurred, &quot;</span>
		       <span class="s">&quot;resetting channel.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">));</span>
<span class="cp">#ifdef AHD_DEBUG</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ahd_debug</span> <span class="o">&amp;</span> <span class="n">AHD_SHOW_RECOVERY</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ahd_dump_card_state</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="n">ahd_reset_channel</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="sc">&#39;A&#39;</span><span class="p">,</span> <span class="cm">/*Initiate Reset*/</span><span class="n">TRUE</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">STATUS_OVERRUN</span>:
	<span class="p">{</span>
		<span class="k">struct</span>	<span class="n">scb</span> <span class="o">*</span><span class="n">scb</span><span class="p">;</span>
		<span class="n">u_int</span>	<span class="n">scbid</span><span class="p">;</span>

		<span class="n">scbid</span> <span class="o">=</span> <span class="n">ahd_get_scbptr</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
		<span class="n">scb</span> <span class="o">=</span> <span class="n">ahd_lookup_scb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scbid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">scb</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">ahd_print_path</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: &quot;</span><span class="p">,</span> <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;SCB %d Packetized Status Overrun&quot;</span><span class="p">,</span> <span class="n">scbid</span><span class="p">);</span>
		<span class="n">ahd_dump_card_state</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
		<span class="n">ahd_reset_channel</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="sc">&#39;A&#39;</span><span class="p">,</span> <span class="cm">/*Initiate Reset*/</span><span class="n">TRUE</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">CFG4ISTAT_INTR</span>:
	<span class="p">{</span>
		<span class="k">struct</span>	<span class="n">scb</span> <span class="o">*</span><span class="n">scb</span><span class="p">;</span>
		<span class="n">u_int</span>	<span class="n">scbid</span><span class="p">;</span>

		<span class="n">scbid</span> <span class="o">=</span> <span class="n">ahd_get_scbptr</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
		<span class="n">scb</span> <span class="o">=</span> <span class="n">ahd_lookup_scb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scbid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">scb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ahd_dump_card_state</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;CFG4ISTAT: Free SCB %d referenced&quot;</span><span class="p">,</span> <span class="n">scbid</span><span class="p">);</span>
			<span class="n">panic</span><span class="p">(</span><span class="s">&quot;For safety&quot;</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">ahd_outq</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">HADDR</span><span class="p">,</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">sense_busaddr</span><span class="p">);</span>
		<span class="n">ahd_outw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">HCNT</span><span class="p">,</span> <span class="n">AHD_SENSE_BUFSIZE</span><span class="p">);</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">HCNT</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SG_CACHE_PRE</span><span class="p">,</span> <span class="n">SG_LAST_SEG</span><span class="p">);</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">DFCNTRL</span><span class="p">,</span> <span class="n">PRELOADEN</span><span class="o">|</span><span class="n">SCSIEN</span><span class="o">|</span><span class="n">HDMAEN</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">ILLEGAL_PHASE</span>:
	<span class="p">{</span>
		<span class="n">u_int</span> <span class="n">bus_phase</span><span class="p">;</span>

		<span class="n">bus_phase</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCSISIGI</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PHASE_MASK</span><span class="p">;</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: ILLEGAL_PHASE 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">),</span> <span class="n">bus_phase</span><span class="p">);</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">bus_phase</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">P_DATAOUT</span>:
		<span class="k">case</span> <span class="n">P_DATAIN</span>:
		<span class="k">case</span> <span class="n">P_DATAOUT_DT</span>:
		<span class="k">case</span> <span class="n">P_DATAIN_DT</span>:
		<span class="k">case</span> <span class="n">P_MESGOUT</span>:
		<span class="k">case</span> <span class="n">P_STATUS</span>:
		<span class="k">case</span> <span class="n">P_MESGIN</span>:
			<span class="n">ahd_reset_channel</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="sc">&#39;A&#39;</span><span class="p">,</span> <span class="cm">/*Initiate Reset*/</span><span class="n">TRUE</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: Issued Bus Reset.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">));</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">P_COMMAND</span>:
		<span class="p">{</span>
			<span class="k">struct</span>	<span class="n">ahd_devinfo</span> <span class="n">devinfo</span><span class="p">;</span>
			<span class="k">struct</span>	<span class="n">scb</span> <span class="o">*</span><span class="n">scb</span><span class="p">;</span>
			<span class="k">struct</span>	<span class="n">ahd_initiator_tinfo</span> <span class="o">*</span><span class="n">targ_info</span><span class="p">;</span>
			<span class="k">struct</span>	<span class="n">ahd_tmode_tstate</span> <span class="o">*</span><span class="n">tstate</span><span class="p">;</span>
			<span class="k">struct</span>	<span class="n">ahd_transinfo</span> <span class="o">*</span><span class="n">tinfo</span><span class="p">;</span>
			<span class="n">u_int</span>	<span class="n">scbid</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * If a target takes us into the command phase</span>
<span class="cm">			 * assume that it has been externally reset and</span>
<span class="cm">			 * has thus lost our previous packetized negotiation</span>
<span class="cm">			 * agreement.  Since we have not sent an identify</span>
<span class="cm">			 * message and may not have fully qualified the</span>
<span class="cm">			 * connection, we change our command to TUR, assert</span>
<span class="cm">			 * ATN and ABORT the task when we go to message in</span>
<span class="cm">			 * phase.  The OSM will see the REQUEUE_REQUEST</span>
<span class="cm">			 * status and retry the command.</span>
<span class="cm">			 */</span>
			<span class="n">scbid</span> <span class="o">=</span> <span class="n">ahd_get_scbptr</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
			<span class="n">scb</span> <span class="o">=</span> <span class="n">ahd_lookup_scb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scbid</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">scb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Invalid phase with no valid SCB.  &quot;</span>
				       <span class="s">&quot;Resetting bus.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">ahd_reset_channel</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="sc">&#39;A&#39;</span><span class="p">,</span>
						  <span class="cm">/*Initiate Reset*/</span><span class="n">TRUE</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">ahd_compile_devinfo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devinfo</span><span class="p">,</span> <span class="n">SCB_GET_OUR_ID</span><span class="p">(</span><span class="n">scb</span><span class="p">),</span>
					    <span class="n">SCB_GET_TARGET</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">),</span>
					    <span class="n">SCB_GET_LUN</span><span class="p">(</span><span class="n">scb</span><span class="p">),</span>
					    <span class="n">SCB_GET_CHANNEL</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">),</span>
					    <span class="n">ROLE_INITIATOR</span><span class="p">);</span>
			<span class="n">targ_info</span> <span class="o">=</span> <span class="n">ahd_fetch_transinfo</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span>
							<span class="n">devinfo</span><span class="p">.</span><span class="n">channel</span><span class="p">,</span>
							<span class="n">devinfo</span><span class="p">.</span><span class="n">our_scsiid</span><span class="p">,</span>
							<span class="n">devinfo</span><span class="p">.</span><span class="n">target</span><span class="p">,</span>
							<span class="o">&amp;</span><span class="n">tstate</span><span class="p">);</span>
			<span class="n">tinfo</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">targ_info</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">;</span>
			<span class="n">ahd_set_width</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">devinfo</span><span class="p">,</span> <span class="n">MSG_EXT_WDTR_BUS_8_BIT</span><span class="p">,</span>
				      <span class="n">AHD_TRANS_ACTIVE</span><span class="p">,</span> <span class="cm">/*paused*/</span><span class="n">TRUE</span><span class="p">);</span>
			<span class="n">ahd_set_syncrate</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">devinfo</span><span class="p">,</span> <span class="cm">/*period*/</span><span class="mi">0</span><span class="p">,</span>
					 <span class="cm">/*offset*/</span><span class="mi">0</span><span class="p">,</span> <span class="cm">/*ppr_options*/</span><span class="mi">0</span><span class="p">,</span>
					 <span class="n">AHD_TRANS_ACTIVE</span><span class="p">,</span> <span class="cm">/*paused*/</span><span class="n">TRUE</span><span class="p">);</span>
			<span class="cm">/* Hand-craft TUR command */</span>
			<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_CDB_STORE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_CDB_STORE</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_CDB_STORE</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_CDB_STORE</span><span class="o">+</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_CDB_STORE</span><span class="o">+</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_CDB_STORE</span><span class="o">+</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_CDB_LEN</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
			<span class="n">scb</span><span class="o">-&gt;</span><span class="n">hscb</span><span class="o">-&gt;</span><span class="n">control</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">TAG_ENB</span><span class="o">|</span><span class="n">SCB_TAG_TYPE</span><span class="p">);</span>
			<span class="n">scb</span><span class="o">-&gt;</span><span class="n">hscb</span><span class="o">-&gt;</span><span class="n">control</span> <span class="o">|=</span> <span class="n">MK_MESSAGE</span><span class="p">;</span>
			<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_CONTROL</span><span class="p">,</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">hscb</span><span class="o">-&gt;</span><span class="n">control</span><span class="p">);</span>
			<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">MSG_OUT</span><span class="p">,</span> <span class="n">HOST_MSG</span><span class="p">);</span>
			<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SAVED_SCSIID</span><span class="p">,</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">hscb</span><span class="o">-&gt;</span><span class="n">scsiid</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * The lun is 0, regardless of the SCB&#39;s lun</span>
<span class="cm">			 * as we have not sent an identify message.</span>
<span class="cm">			 */</span>
			<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SAVED_LUN</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SEQ_FLAGS</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">ahd_assert_atn</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
			<span class="n">scb</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SCB_PACKETIZED</span><span class="p">;</span>
			<span class="n">scb</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">SCB_ABORT</span><span class="o">|</span><span class="n">SCB_EXTERNAL_RESET</span><span class="p">;</span>
			<span class="n">ahd_freeze_devq</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
			<span class="n">ahd_set_transaction_status</span><span class="p">(</span><span class="n">scb</span><span class="p">,</span> <span class="n">CAM_REQUEUE_REQ</span><span class="p">);</span>
			<span class="n">ahd_freeze_scb</span><span class="p">(</span><span class="n">scb</span><span class="p">);</span>

			<span class="cm">/* Notify XPT */</span>
			<span class="n">ahd_send_async</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">devinfo</span><span class="p">.</span><span class="n">channel</span><span class="p">,</span> <span class="n">devinfo</span><span class="p">.</span><span class="n">target</span><span class="p">,</span>
				       <span class="n">CAM_LUN_WILDCARD</span><span class="p">,</span> <span class="n">AC_SENT_BDR</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * Allow the sequencer to continue with</span>
<span class="cm">			 * non-pack processing.</span>
<span class="cm">			 */</span>
			<span class="n">ahd_set_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI</span><span class="p">);</span>
			<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CLRLQOINT1</span><span class="p">,</span> <span class="n">CLRLQOPHACHGINPKT</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">bugs</span> <span class="o">&amp;</span> <span class="n">AHD_CLRLQO_AUTOCLR_BUG</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CLRLQOINT1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="p">}</span>
<span class="cp">#ifdef AHD_DEBUG</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">ahd_debug</span> <span class="o">&amp;</span> <span class="n">AHD_SHOW_RECOVERY</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ahd_print_path</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Unexpected command phase from &quot;</span>
				       <span class="s">&quot;packetized target</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="p">}</span>
<span class="cp">#endif</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">CFG4OVERRUN</span>:
	<span class="p">{</span>
		<span class="k">struct</span>	<span class="n">scb</span> <span class="o">*</span><span class="n">scb</span><span class="p">;</span>
		<span class="n">u_int</span>	<span class="n">scb_index</span><span class="p">;</span>
		
<span class="cp">#ifdef AHD_DEBUG</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ahd_debug</span> <span class="o">&amp;</span> <span class="n">AHD_SHOW_RECOVERY</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: CFG4OVERRUN mode = %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">),</span>
			       <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">MODE_PTR</span><span class="p">));</span>
		<span class="p">}</span>
<span class="cp">#endif</span>
		<span class="n">scb_index</span> <span class="o">=</span> <span class="n">ahd_get_scbptr</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
		<span class="n">scb</span> <span class="o">=</span> <span class="n">ahd_lookup_scb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb_index</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">scb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Attempt to transfer to an SCB that is</span>
<span class="cm">			 * not outstanding.</span>
<span class="cm">			 */</span>
			<span class="n">ahd_assert_atn</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
			<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">MSG_OUT</span><span class="p">,</span> <span class="n">HOST_MSG</span><span class="p">);</span>
			<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">MSG_ABORT_TASK</span><span class="p">;</span>
			<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_len</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msg_type</span> <span class="o">=</span> <span class="n">MSG_TYPE_INITIATOR_MSGOUT</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * Clear status received flag to prevent any</span>
<span class="cm">			 * attempt to complete this bogus SCB.</span>
<span class="cm">			 */</span>
			<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_CONTROL</span><span class="p">,</span>
				 <span class="n">ahd_inb_scbram</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_CONTROL</span><span class="p">)</span>
				 <span class="o">&amp;</span> <span class="o">~</span><span class="n">STATUS_RCVD</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">DUMP_CARD_STATE</span>:
	<span class="p">{</span>
		<span class="n">ahd_dump_card_state</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">PDATA_REINIT</span>:
	<span class="p">{</span>
<span class="cp">#ifdef AHD_DEBUG</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ahd_debug</span> <span class="o">&amp;</span> <span class="n">AHD_SHOW_RECOVERY</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: PDATA_REINIT - DFCNTRL = 0x%x &quot;</span>
			       <span class="s">&quot;SG_CACHE_SHADOW = 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">),</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">DFCNTRL</span><span class="p">),</span>
			       <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SG_CACHE_SHADOW</span><span class="p">));</span>
		<span class="p">}</span>
<span class="cp">#endif</span>
		<span class="n">ahd_reinitialize_dataptrs</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">HOST_MSG_LOOP</span>:
	<span class="p">{</span>
		<span class="k">struct</span> <span class="n">ahd_devinfo</span> <span class="n">devinfo</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * The sequencer has encountered a message phase</span>
<span class="cm">		 * that requires host assistance for completion.</span>
<span class="cm">		 * While handling the message phase(s), we will be</span>
<span class="cm">		 * notified by the sequencer after each byte is</span>
<span class="cm">		 * transferred so we can track bus phase changes.</span>
<span class="cm">		 *</span>
<span class="cm">		 * If this is the first time we&#39;ve seen a HOST_MSG_LOOP</span>
<span class="cm">		 * interrupt, initialize the state of the host message</span>
<span class="cm">		 * loop.</span>
<span class="cm">		 */</span>
		<span class="n">ahd_fetch_devinfo</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">devinfo</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msg_type</span> <span class="o">==</span> <span class="n">MSG_TYPE_NONE</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">scb</span> <span class="o">*</span><span class="n">scb</span><span class="p">;</span>
			<span class="n">u_int</span> <span class="n">scb_index</span><span class="p">;</span>
			<span class="n">u_int</span> <span class="n">bus_phase</span><span class="p">;</span>

			<span class="n">bus_phase</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCSISIGI</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PHASE_MASK</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bus_phase</span> <span class="o">!=</span> <span class="n">P_MESGIN</span>
			 <span class="o">&amp;&amp;</span> <span class="n">bus_phase</span> <span class="o">!=</span> <span class="n">P_MESGOUT</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;ahd_intr: HOST_MSG_LOOP bad &quot;</span>
				       <span class="s">&quot;phase 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bus_phase</span><span class="p">);</span>
				<span class="cm">/*</span>
<span class="cm">				 * Probably transitioned to bus free before</span>
<span class="cm">				 * we got here.  Just punt the message.</span>
<span class="cm">				 */</span>
				<span class="n">ahd_dump_card_state</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
				<span class="n">ahd_clear_intstat</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
				<span class="n">ahd_restart</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">scb_index</span> <span class="o">=</span> <span class="n">ahd_get_scbptr</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
			<span class="n">scb</span> <span class="o">=</span> <span class="n">ahd_lookup_scb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb_index</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">devinfo</span><span class="p">.</span><span class="n">role</span> <span class="o">==</span> <span class="n">ROLE_INITIATOR</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">bus_phase</span> <span class="o">==</span> <span class="n">P_MESGOUT</span><span class="p">)</span>
					<span class="n">ahd_setup_initiator_msgout</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span>
								   <span class="o">&amp;</span><span class="n">devinfo</span><span class="p">,</span>
								   <span class="n">scb</span><span class="p">);</span>
				<span class="k">else</span> <span class="p">{</span>
					<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msg_type</span> <span class="o">=</span>
					    <span class="n">MSG_TYPE_INITIATOR_MSGIN</span><span class="p">;</span>
					<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgin_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
<span class="cp">#ifdef AHD_TARGET_MODE</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">bus_phase</span> <span class="o">==</span> <span class="n">P_MESGOUT</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msg_type</span> <span class="o">=</span>
					    <span class="n">MSG_TYPE_TARGET_MSGOUT</span><span class="p">;</span>
					<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgin_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">else</span> 
					<span class="n">ahd_setup_target_msgin</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span>
							       <span class="o">&amp;</span><span class="n">devinfo</span><span class="p">,</span>
							       <span class="n">scb</span><span class="p">);</span>
			<span class="p">}</span>
<span class="cp">#endif</span>
		<span class="p">}</span>

		<span class="n">ahd_handle_message_phase</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">NO_MATCH</span>:
	<span class="p">{</span>
		<span class="cm">/* Ensure we don&#39;t leave the selection hardware on */</span>
		<span class="n">AHD_ASSERT_MODES</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI_MSK</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI_MSK</span><span class="p">);</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCSISEQ0</span><span class="p">,</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCSISEQ0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">ENSELO</span><span class="p">);</span>

		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s:%c:%d: no active SCB for reconnecting &quot;</span>
		       <span class="s">&quot;target - issuing BUS DEVICE RESET</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">),</span> <span class="sc">&#39;A&#39;</span><span class="p">,</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SELID</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;SAVED_SCSIID == 0x%x, SAVED_LUN == 0x%x, &quot;</span>
		       <span class="s">&quot;REG0 == 0x%x ACCUM = 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SAVED_SCSIID</span><span class="p">),</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SAVED_LUN</span><span class="p">),</span>
		       <span class="n">ahd_inw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">REG0</span><span class="p">),</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">ACCUM</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;SEQ_FLAGS == 0x%x, SCBPTR == 0x%x, BTT == 0x%x, &quot;</span>
		       <span class="s">&quot;SINDEX == 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SEQ_FLAGS</span><span class="p">),</span> <span class="n">ahd_get_scbptr</span><span class="p">(</span><span class="n">ahd</span><span class="p">),</span>
		       <span class="n">ahd_find_busy_tcl</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span>
					 <span class="n">BUILD_TCL</span><span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SAVED_SCSIID</span><span class="p">),</span>
						   <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SAVED_LUN</span><span class="p">))),</span>
		       <span class="n">ahd_inw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SINDEX</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;SELID == 0x%x, SCB_SCSIID == 0x%x, SCB_LUN == 0x%x, &quot;</span>
		       <span class="s">&quot;SCB_CONTROL == 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SELID</span><span class="p">),</span> <span class="n">ahd_inb_scbram</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_SCSIID</span><span class="p">),</span>
		       <span class="n">ahd_inb_scbram</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_LUN</span><span class="p">),</span>
		       <span class="n">ahd_inb_scbram</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_CONTROL</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;SCSIBUS[0] == 0x%x, SCSISIGI == 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCSIBUS</span><span class="p">),</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCSISIGI</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;SXFRCTL0 == 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SXFRCTL0</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;SEQCTL0 == 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SEQCTL0</span><span class="p">));</span>
		<span class="n">ahd_dump_card_state</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
		<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">MSG_BUS_DEV_RESET</span><span class="p">;</span>
		<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_len</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msg_type</span> <span class="o">=</span> <span class="n">MSG_TYPE_INITIATOR_MSGOUT</span><span class="p">;</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">MSG_OUT</span><span class="p">,</span> <span class="n">HOST_MSG</span><span class="p">);</span>
		<span class="n">ahd_assert_atn</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">PROTO_VIOLATION</span>:
	<span class="p">{</span>
		<span class="n">ahd_handle_proto_violation</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">IGN_WIDE_RES</span>:
	<span class="p">{</span>
		<span class="k">struct</span> <span class="n">ahd_devinfo</span> <span class="n">devinfo</span><span class="p">;</span>

		<span class="n">ahd_fetch_devinfo</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">devinfo</span><span class="p">);</span>
		<span class="n">ahd_handle_ign_wide_residue</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">devinfo</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">BAD_PHASE</span>:
	<span class="p">{</span>
		<span class="n">u_int</span> <span class="n">lastphase</span><span class="p">;</span>

		<span class="n">lastphase</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">LASTPHASE</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s:%c:%d: unknown scsi bus phase %x, &quot;</span>
		       <span class="s">&quot;lastphase = 0x%x.  Attempting to continue</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">),</span> <span class="sc">&#39;A&#39;</span><span class="p">,</span>
		       <span class="n">SCSIID_TARGET</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SAVED_SCSIID</span><span class="p">)),</span>
		       <span class="n">lastphase</span><span class="p">,</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCSISIGI</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">MISSED_BUSFREE</span>:
	<span class="p">{</span>
		<span class="n">u_int</span> <span class="n">lastphase</span><span class="p">;</span>

		<span class="n">lastphase</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">LASTPHASE</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s:%c:%d: Missed busfree. &quot;</span>
		       <span class="s">&quot;Lastphase = 0x%x, Curphase = 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">),</span> <span class="sc">&#39;A&#39;</span><span class="p">,</span>
		       <span class="n">SCSIID_TARGET</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SAVED_SCSIID</span><span class="p">)),</span>
		       <span class="n">lastphase</span><span class="p">,</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCSISIGI</span><span class="p">));</span>
		<span class="n">ahd_restart</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">DATA_OVERRUN</span>:
	<span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * When the sequencer detects an overrun, it</span>
<span class="cm">		 * places the controller in &quot;BITBUCKET&quot; mode</span>
<span class="cm">		 * and allows the target to complete its transfer.</span>
<span class="cm">		 * Unfortunately, none of the counters get updated</span>
<span class="cm">		 * when the controller is in this mode, so we have</span>
<span class="cm">		 * no way of knowing how large the overrun was.</span>
<span class="cm">		 */</span>
		<span class="k">struct</span>	<span class="n">scb</span> <span class="o">*</span><span class="n">scb</span><span class="p">;</span>
		<span class="n">u_int</span>	<span class="n">scbindex</span><span class="p">;</span>
<span class="cp">#ifdef AHD_DEBUG</span>
		<span class="n">u_int</span>	<span class="n">lastphase</span><span class="p">;</span>
<span class="cp">#endif</span>

		<span class="n">scbindex</span> <span class="o">=</span> <span class="n">ahd_get_scbptr</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
		<span class="n">scb</span> <span class="o">=</span> <span class="n">ahd_lookup_scb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scbindex</span><span class="p">);</span>
<span class="cp">#ifdef AHD_DEBUG</span>
		<span class="n">lastphase</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">LASTPHASE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ahd_debug</span> <span class="o">&amp;</span> <span class="n">AHD_SHOW_RECOVERY</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ahd_print_path</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;data overrun detected %s.  Tag == 0x%x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">ahd_lookup_phase_entry</span><span class="p">(</span><span class="n">lastphase</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">phasemsg</span><span class="p">,</span>
			       <span class="n">SCB_GET_TAG</span><span class="p">(</span><span class="n">scb</span><span class="p">));</span>
			<span class="n">ahd_print_path</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s seen Data Phase.  Length = %ld.  &quot;</span>
			       <span class="s">&quot;NumSGs = %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SEQ_FLAGS</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">DPHASE</span>
			       <span class="o">?</span> <span class="s">&quot;Have&quot;</span> <span class="o">:</span> <span class="s">&quot;Haven&#39;t&quot;</span><span class="p">,</span>
			       <span class="n">ahd_get_transfer_length</span><span class="p">(</span><span class="n">scb</span><span class="p">),</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">sg_count</span><span class="p">);</span>
			<span class="n">ahd_dump_sglist</span><span class="p">(</span><span class="n">scb</span><span class="p">);</span>
		<span class="p">}</span>
<span class="cp">#endif</span>

		<span class="cm">/*</span>
<span class="cm">		 * Set this and it will take effect when the</span>
<span class="cm">		 * target does a command complete.</span>
<span class="cm">		 */</span>
		<span class="n">ahd_freeze_devq</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
		<span class="n">ahd_set_transaction_status</span><span class="p">(</span><span class="n">scb</span><span class="p">,</span> <span class="n">CAM_DATA_RUN_ERR</span><span class="p">);</span>
		<span class="n">ahd_freeze_scb</span><span class="p">(</span><span class="n">scb</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">MKMSG_FAILED</span>:
	<span class="p">{</span>
		<span class="k">struct</span> <span class="n">ahd_devinfo</span> <span class="n">devinfo</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">scb</span> <span class="o">*</span><span class="n">scb</span><span class="p">;</span>
		<span class="n">u_int</span> <span class="n">scbid</span><span class="p">;</span>

		<span class="n">ahd_fetch_devinfo</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">devinfo</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s:%c:%d:%d: Attempt to issue message failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">),</span> <span class="n">devinfo</span><span class="p">.</span><span class="n">channel</span><span class="p">,</span> <span class="n">devinfo</span><span class="p">.</span><span class="n">target</span><span class="p">,</span>
		       <span class="n">devinfo</span><span class="p">.</span><span class="n">lun</span><span class="p">);</span>
		<span class="n">scbid</span> <span class="o">=</span> <span class="n">ahd_get_scbptr</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
		<span class="n">scb</span> <span class="o">=</span> <span class="n">ahd_lookup_scb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scbid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">scb</span> <span class="o">!=</span> <span class="nb">NULL</span>
		 <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SCB_RECOVERY_SCB</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="cm">/*</span>
<span class="cm">			 * Ensure that we didn&#39;t put a second instance of this</span>
<span class="cm">			 * SCB into the QINFIFO.</span>
<span class="cm">			 */</span>
			<span class="n">ahd_search_qinfifo</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_GET_TARGET</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">),</span>
					   <span class="n">SCB_GET_CHANNEL</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">),</span>
					   <span class="n">SCB_GET_LUN</span><span class="p">(</span><span class="n">scb</span><span class="p">),</span> <span class="n">SCB_GET_TAG</span><span class="p">(</span><span class="n">scb</span><span class="p">),</span>
					   <span class="n">ROLE_INITIATOR</span><span class="p">,</span> <span class="cm">/*status*/</span><span class="mi">0</span><span class="p">,</span>
					   <span class="n">SEARCH_REMOVE</span><span class="p">);</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_CONTROL</span><span class="p">,</span>
			 <span class="n">ahd_inb_scbram</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_CONTROL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">MK_MESSAGE</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">TASKMGMT_FUNC_COMPLETE</span>:
	<span class="p">{</span>
		<span class="n">u_int</span>	<span class="n">scbid</span><span class="p">;</span>
		<span class="k">struct</span>	<span class="n">scb</span> <span class="o">*</span><span class="n">scb</span><span class="p">;</span>

		<span class="n">scbid</span> <span class="o">=</span> <span class="n">ahd_get_scbptr</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
		<span class="n">scb</span> <span class="o">=</span> <span class="n">ahd_lookup_scb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scbid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">scb</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u_int</span>	   <span class="n">lun</span><span class="p">;</span>
			<span class="n">u_int</span>	   <span class="n">tag</span><span class="p">;</span>
			<span class="n">cam_status</span> <span class="n">error</span><span class="p">;</span>

			<span class="n">ahd_print_path</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Task Management Func 0x%x Complete</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">scb</span><span class="o">-&gt;</span><span class="n">hscb</span><span class="o">-&gt;</span><span class="n">task_management</span><span class="p">);</span>
			<span class="n">lun</span> <span class="o">=</span> <span class="n">CAM_LUN_WILDCARD</span><span class="p">;</span>
			<span class="n">tag</span> <span class="o">=</span> <span class="n">SCB_LIST_NULL</span><span class="p">;</span>

			<span class="k">switch</span> <span class="p">(</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">hscb</span><span class="o">-&gt;</span><span class="n">task_management</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">SIU_TASKMGMT_ABORT_TASK</span>:
				<span class="n">tag</span> <span class="o">=</span> <span class="n">SCB_GET_TAG</span><span class="p">(</span><span class="n">scb</span><span class="p">);</span>
			<span class="k">case</span> <span class="n">SIU_TASKMGMT_ABORT_TASK_SET</span>:
			<span class="k">case</span> <span class="n">SIU_TASKMGMT_CLEAR_TASK_SET</span>:
				<span class="n">lun</span> <span class="o">=</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">hscb</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">;</span>
				<span class="n">error</span> <span class="o">=</span> <span class="n">CAM_REQ_ABORTED</span><span class="p">;</span>
				<span class="n">ahd_abort_scbs</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_GET_TARGET</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">),</span>
					       <span class="sc">&#39;A&#39;</span><span class="p">,</span> <span class="n">lun</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="n">ROLE_INITIATOR</span><span class="p">,</span>
					       <span class="n">error</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">SIU_TASKMGMT_LUN_RESET</span>:
				<span class="n">lun</span> <span class="o">=</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">hscb</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">SIU_TASKMGMT_TARGET_RESET</span>:
			<span class="p">{</span>
				<span class="k">struct</span> <span class="n">ahd_devinfo</span> <span class="n">devinfo</span><span class="p">;</span>

				<span class="n">ahd_scb_devinfo</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">devinfo</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
				<span class="n">error</span> <span class="o">=</span> <span class="n">CAM_BDR_SENT</span><span class="p">;</span>
				<span class="n">ahd_handle_devreset</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">devinfo</span><span class="p">,</span> <span class="n">lun</span><span class="p">,</span>
						    <span class="n">CAM_BDR_SENT</span><span class="p">,</span>
						    <span class="n">lun</span> <span class="o">!=</span> <span class="n">CAM_LUN_WILDCARD</span>
						    <span class="o">?</span> <span class="s">&quot;Lun Reset&quot;</span>
						    <span class="o">:</span> <span class="s">&quot;Target Reset&quot;</span><span class="p">,</span>
						    <span class="cm">/*verbose_level*/</span><span class="mi">0</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="nl">default:</span>
				<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Unexpected TaskMgmt Func</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">TASKMGMT_CMD_CMPLT_OKAY</span>:
	<span class="p">{</span>
		<span class="n">u_int</span>	<span class="n">scbid</span><span class="p">;</span>
		<span class="k">struct</span>	<span class="n">scb</span> <span class="o">*</span><span class="n">scb</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * An ABORT TASK TMF failed to be delivered before</span>
<span class="cm">		 * the targeted command completed normally.</span>
<span class="cm">		 */</span>
		<span class="n">scbid</span> <span class="o">=</span> <span class="n">ahd_get_scbptr</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
		<span class="n">scb</span> <span class="o">=</span> <span class="n">ahd_lookup_scb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scbid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">scb</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Remove the second instance of this SCB from</span>
<span class="cm">			 * the QINFIFO if it is still there.</span>
<span class="cm">                         */</span>
			<span class="n">ahd_print_path</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;SCB completes before TMF</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * Handle losing the race.  Wait until any</span>
<span class="cm">			 * current selection completes.  We will then</span>
<span class="cm">			 * set the TMF back to zero in this SCB so that</span>
<span class="cm">			 * the sequencer doesn&#39;t bother to issue another</span>
<span class="cm">			 * sequencer interrupt for its completion.</span>
<span class="cm">			 */</span>
			<span class="k">while</span> <span class="p">((</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCSISEQ0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">ENSELO</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>
			    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SSTAT0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SELDO</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
			    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SSTAT1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SELTO</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="p">;</span>
			<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_TASK_MANAGEMENT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">ahd_search_qinfifo</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_GET_TARGET</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">),</span>
					   <span class="n">SCB_GET_CHANNEL</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">),</span>  
					   <span class="n">SCB_GET_LUN</span><span class="p">(</span><span class="n">scb</span><span class="p">),</span> <span class="n">SCB_GET_TAG</span><span class="p">(</span><span class="n">scb</span><span class="p">),</span> 
					   <span class="n">ROLE_INITIATOR</span><span class="p">,</span> <span class="cm">/*status*/</span><span class="mi">0</span><span class="p">,</span>   
					   <span class="n">SEARCH_REMOVE</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">TRACEPOINT0</span>:
	<span class="k">case</span> <span class="n">TRACEPOINT1</span>:
	<span class="k">case</span> <span class="n">TRACEPOINT2</span>:
	<span class="k">case</span> <span class="n">TRACEPOINT3</span>:
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: Tracepoint %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">),</span>
		       <span class="n">seqintcode</span> <span class="o">-</span> <span class="n">TRACEPOINT0</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NO_SEQINT</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SAW_HWERR</span>:
		<span class="n">ahd_handle_hwerrint</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: Unexpected SEQINTCODE %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">),</span>
		       <span class="n">seqintcode</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 *  The sequencer is paused immediately on</span>
<span class="cm">	 *  a SEQINT, so we should restart it when</span>
<span class="cm">	 *  we&#39;re done.</span>
<span class="cm">	 */</span>
	<span class="n">ahd_unpause</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_handle_scsiint</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">intstat</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scb</span>	<span class="o">*</span><span class="n">scb</span><span class="p">;</span>
	<span class="n">u_int</span>		 <span class="n">status0</span><span class="p">;</span>
	<span class="n">u_int</span>		 <span class="n">status3</span><span class="p">;</span>
	<span class="n">u_int</span>		 <span class="n">status</span><span class="p">;</span>
	<span class="n">u_int</span>		 <span class="n">lqistat1</span><span class="p">;</span>
	<span class="n">u_int</span>		 <span class="n">lqostat0</span><span class="p">;</span>
	<span class="n">u_int</span>		 <span class="n">scbid</span><span class="p">;</span>
	<span class="n">u_int</span>		 <span class="n">busfreetime</span><span class="p">;</span>

	<span class="n">ahd_update_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
	<span class="n">ahd_set_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI</span><span class="p">);</span>

	<span class="n">status3</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SSTAT3</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">NTRAMPERR</span><span class="o">|</span><span class="n">OSRAMPERR</span><span class="p">);</span>
	<span class="n">status0</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SSTAT0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">IOERR</span><span class="o">|</span><span class="n">OVERRUN</span><span class="o">|</span><span class="n">SELDI</span><span class="o">|</span><span class="n">SELDO</span><span class="p">);</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SSTAT1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">SELTO</span><span class="o">|</span><span class="n">SCSIRSTI</span><span class="o">|</span><span class="n">BUSFREE</span><span class="o">|</span><span class="n">SCSIPERR</span><span class="p">);</span>
	<span class="n">lqistat1</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">LQISTAT1</span><span class="p">);</span>
	<span class="n">lqostat0</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">LQOSTAT0</span><span class="p">);</span>
	<span class="n">busfreetime</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SSTAT2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">BUSFREETIME</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Ignore external resets after a bus reset.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(((</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">SCSIRSTI</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AHD_BUS_RESET_ACTIVE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CLRSINT1</span><span class="p">,</span> <span class="n">CLRSCSIRSTI</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Clear bus reset flag</span>
<span class="cm">	 */</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">AHD_BUS_RESET_ACTIVE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">status0</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">SELDI</span><span class="o">|</span><span class="n">SELDO</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u_int</span> <span class="n">simode0</span><span class="p">;</span>

		<span class="n">ahd_set_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHD_MODE_CFG</span><span class="p">,</span> <span class="n">AHD_MODE_CFG</span><span class="p">);</span>
		<span class="n">simode0</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SIMODE0</span><span class="p">);</span>
		<span class="n">status0</span> <span class="o">&amp;=</span> <span class="n">simode0</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">IOERR</span><span class="o">|</span><span class="n">OVERRUN</span><span class="o">|</span><span class="n">SELDI</span><span class="o">|</span><span class="n">SELDO</span><span class="p">);</span>
		<span class="n">ahd_set_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">scbid</span> <span class="o">=</span> <span class="n">ahd_get_scbptr</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
	<span class="n">scb</span> <span class="o">=</span> <span class="n">ahd_lookup_scb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scbid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">scb</span> <span class="o">!=</span> <span class="nb">NULL</span>
	 <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SEQ_FLAGS</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">NOT_IDENTIFIED</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">scb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">status0</span> <span class="o">&amp;</span> <span class="n">IOERR</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u_int</span> <span class="n">now_lvd</span><span class="p">;</span>

		<span class="n">now_lvd</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SBLKCTL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">ENAB40</span><span class="p">;</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: Transceiver State Has Changed to %s mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">),</span> <span class="n">now_lvd</span> <span class="o">?</span> <span class="s">&quot;LVD&quot;</span> <span class="o">:</span> <span class="s">&quot;SE&quot;</span><span class="p">);</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CLRSINT0</span><span class="p">,</span> <span class="n">CLRIOERR</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * A change in I/O mode is equivalent to a bus reset.</span>
<span class="cm">		 */</span>
		<span class="n">ahd_reset_channel</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="sc">&#39;A&#39;</span><span class="p">,</span> <span class="cm">/*Initiate Reset*/</span><span class="n">TRUE</span><span class="p">);</span>
		<span class="n">ahd_pause</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
		<span class="n">ahd_setup_iocell_workaround</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
		<span class="n">ahd_unpause</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">status0</span> <span class="o">&amp;</span> <span class="n">OVERRUN</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: SCSI offset overrun detected.  Resetting bus.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">));</span>
		<span class="n">ahd_reset_channel</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="sc">&#39;A&#39;</span><span class="p">,</span> <span class="cm">/*Initiate Reset*/</span><span class="n">TRUE</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">SCSIRSTI</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: Someone reset channel A</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">));</span>
		<span class="n">ahd_reset_channel</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="sc">&#39;A&#39;</span><span class="p">,</span> <span class="cm">/*Initiate Reset*/</span><span class="n">FALSE</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">SCSIPERR</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* Make sure the sequencer is in a safe location. */</span>
		<span class="n">ahd_clear_critical_section</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>

		<span class="n">ahd_handle_transmission_error</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">lqostat0</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: lqostat0 == 0x%x!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">),</span> <span class="n">lqostat0</span><span class="p">);</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CLRLQOINT0</span><span class="p">,</span> <span class="n">lqostat0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">bugs</span> <span class="o">&amp;</span> <span class="n">AHD_CLRLQO_AUTOCLR_BUG</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CLRLQOINT1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">SELTO</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Stop the selection */</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCSISEQ0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="cm">/* Make sure the sequencer is in a safe location. */</span>
		<span class="n">ahd_clear_critical_section</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>

		<span class="cm">/* No more pending messages */</span>
		<span class="n">ahd_clear_msg_state</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>

		<span class="cm">/* Clear interrupt state */</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CLRSINT1</span><span class="p">,</span> <span class="n">CLRSELTIMEO</span><span class="o">|</span><span class="n">CLRBUSFREE</span><span class="o">|</span><span class="n">CLRSCSIPERR</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Although the driver does not care about the</span>
<span class="cm">		 * &#39;Selection in Progress&#39; status bit, the busy</span>
<span class="cm">		 * LED does.  SELINGO is only cleared by a successful</span>
<span class="cm">		 * selection, so we must manually clear it to insure</span>
<span class="cm">		 * the LED turns off just incase no future successful</span>
<span class="cm">		 * selections occur (e.g. no devices on the bus).</span>
<span class="cm">		 */</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CLRSINT0</span><span class="p">,</span> <span class="n">CLRSELINGO</span><span class="p">);</span>

		<span class="n">scbid</span> <span class="o">=</span> <span class="n">ahd_inw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">WAITING_TID_HEAD</span><span class="p">);</span>
		<span class="n">scb</span> <span class="o">=</span> <span class="n">ahd_lookup_scb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scbid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">scb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: ahd_intr - referenced scb not &quot;</span>
			       <span class="s">&quot;valid during SELTO scb(0x%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">),</span> <span class="n">scbid</span><span class="p">);</span>
			<span class="n">ahd_dump_card_state</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">ahd_devinfo</span> <span class="n">devinfo</span><span class="p">;</span>
<span class="cp">#ifdef AHD_DEBUG</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">ahd_debug</span> <span class="o">&amp;</span> <span class="n">AHD_SHOW_SELTO</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ahd_print_path</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Saw Selection Timeout for SCB 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">scbid</span><span class="p">);</span>
			<span class="p">}</span>
<span class="cp">#endif</span>
			<span class="n">ahd_scb_devinfo</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">devinfo</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
			<span class="n">ahd_set_transaction_status</span><span class="p">(</span><span class="n">scb</span><span class="p">,</span> <span class="n">CAM_SEL_TIMEOUT</span><span class="p">);</span>
			<span class="n">ahd_freeze_devq</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * Cancel any pending transactions on the device</span>
<span class="cm">			 * now that it seems to be missing.  This will</span>
<span class="cm">			 * also revert us to async/narrow transfers until</span>
<span class="cm">			 * we can renegotiate with the device.</span>
<span class="cm">			 */</span>
			<span class="n">ahd_handle_devreset</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">devinfo</span><span class="p">,</span>
					    <span class="n">CAM_LUN_WILDCARD</span><span class="p">,</span>
					    <span class="n">CAM_SEL_TIMEOUT</span><span class="p">,</span>
					    <span class="s">&quot;Selection Timeout&quot;</span><span class="p">,</span>
					    <span class="cm">/*verbose_level*/</span><span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CLRINT</span><span class="p">,</span> <span class="n">CLRSCSIINT</span><span class="p">);</span>
		<span class="n">ahd_iocell_first_selection</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
		<span class="n">ahd_unpause</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">status0</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">SELDI</span><span class="o">|</span><span class="n">SELDO</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">ahd_iocell_first_selection</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
		<span class="n">ahd_unpause</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">status3</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: SCSI Cell parity error SSTAT3 == 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">),</span> <span class="n">status3</span><span class="p">);</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CLRSINT3</span><span class="p">,</span> <span class="n">status3</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">lqistat1</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">LQIPHASE_LQ</span><span class="o">|</span><span class="n">LQIPHASE_NLQ</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* Make sure the sequencer is in a safe location. */</span>
		<span class="n">ahd_clear_critical_section</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>

		<span class="n">ahd_handle_lqiphase_error</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">lqistat1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">lqistat1</span> <span class="o">&amp;</span> <span class="n">LQICRCI_NLQ</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * This status can be delayed during some</span>
<span class="cm">		 * streaming operations.  The SCSIPHASE</span>
<span class="cm">		 * handler has already dealt with this case</span>
<span class="cm">		 * so just clear the error.</span>
<span class="cm">		 */</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CLRLQIINT1</span><span class="p">,</span> <span class="n">CLRLQICRCI_NLQ</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">BUSFREE</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>
		<span class="o">||</span> <span class="p">(</span><span class="n">lqistat1</span> <span class="o">&amp;</span> <span class="n">LQOBUSFREE</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u_int</span> <span class="n">lqostat1</span><span class="p">;</span>
		<span class="kt">int</span>   <span class="n">restart</span><span class="p">;</span>
		<span class="kt">int</span>   <span class="n">clear_fifo</span><span class="p">;</span>
		<span class="kt">int</span>   <span class="n">packetized</span><span class="p">;</span>
		<span class="n">u_int</span> <span class="n">mode</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Clear our selection hardware as soon as possible.</span>
<span class="cm">		 * We may have an entry in the waiting Q for this target,</span>
<span class="cm">		 * that is affected by this busfree and we don&#39;t want to</span>
<span class="cm">		 * go about selecting the target while we handle the event.</span>
<span class="cm">		 */</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCSISEQ0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="cm">/* Make sure the sequencer is in a safe location. */</span>
		<span class="n">ahd_clear_critical_section</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Determine what we were up to at the time of</span>
<span class="cm">		 * the busfree.</span>
<span class="cm">		 */</span>
		<span class="n">mode</span> <span class="o">=</span> <span class="n">AHD_MODE_SCSI</span><span class="p">;</span>
		<span class="n">busfreetime</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SSTAT2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">BUSFREETIME</span><span class="p">;</span>
		<span class="n">lqostat1</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">LQOSTAT1</span><span class="p">);</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">busfreetime</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">BUSFREE_DFF0</span>:
		<span class="k">case</span> <span class="n">BUSFREE_DFF1</span>:
		<span class="p">{</span>
			<span class="n">mode</span> <span class="o">=</span> <span class="n">busfreetime</span> <span class="o">==</span> <span class="n">BUSFREE_DFF0</span>
			     <span class="o">?</span> <span class="n">AHD_MODE_DFF0</span> <span class="o">:</span> <span class="n">AHD_MODE_DFF1</span><span class="p">;</span>
			<span class="n">ahd_set_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
			<span class="n">scbid</span> <span class="o">=</span> <span class="n">ahd_get_scbptr</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
			<span class="n">scb</span> <span class="o">=</span> <span class="n">ahd_lookup_scb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scbid</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">scb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: Invalid SCB %d in DFF%d &quot;</span>
				       <span class="s">&quot;during unexpected busfree</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">),</span> <span class="n">scbid</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
				<span class="n">packetized</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="n">packetized</span> <span class="o">=</span> <span class="p">(</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SCB_PACKETIZED</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">clear_fifo</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">case</span> <span class="n">BUSFREE_LQO</span>:
			<span class="n">clear_fifo</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">packetized</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">clear_fifo</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">packetized</span> <span class="o">=</span>  <span class="p">(</span><span class="n">lqostat1</span> <span class="o">&amp;</span> <span class="n">LQOBUSFREE</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">packetized</span>
			 <span class="o">&amp;&amp;</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">LASTPHASE</span><span class="p">)</span> <span class="o">==</span> <span class="n">P_BUSFREE</span>
			 <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SSTAT0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SELDI</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
			 <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SSTAT0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SELDO</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
			  <span class="o">||</span> <span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCSISEQ0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">ENSELO</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
				<span class="cm">/*</span>
<span class="cm">				 * Assume packetized if we are not</span>
<span class="cm">				 * on the bus in a non-packetized</span>
<span class="cm">				 * capacity and any pending selection</span>
<span class="cm">				 * was a packetized selection.</span>
<span class="cm">				 */</span>
				<span class="n">packetized</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

<span class="cp">#ifdef AHD_DEBUG</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ahd_debug</span> <span class="o">&amp;</span> <span class="n">AHD_SHOW_MISC</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Saw Busfree.  Busfreetime = 0x%x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">busfreetime</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="cm">/*</span>
<span class="cm">		 * Busfrees that occur in non-packetized phases are</span>
<span class="cm">		 * handled by the nonpkt_busfree handler.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">packetized</span> <span class="o">&amp;&amp;</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">LASTPHASE</span><span class="p">)</span> <span class="o">==</span> <span class="n">P_BUSFREE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">restart</span> <span class="o">=</span> <span class="n">ahd_handle_pkt_busfree</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">busfreetime</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">packetized</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">restart</span> <span class="o">=</span> <span class="n">ahd_handle_nonpkt_busfree</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * Clear the busfree interrupt status.  The setting of</span>
<span class="cm">		 * the interrupt is a pulse, so in a perfect world, we</span>
<span class="cm">		 * would not need to muck with the ENBUSFREE logic.  This</span>
<span class="cm">		 * would ensure that if the bus moves on to another</span>
<span class="cm">		 * connection, busfree protection is still in force.  If</span>
<span class="cm">		 * BUSFREEREV is broken, however, we must manually clear</span>
<span class="cm">		 * the ENBUSFREE if the busfree occurred during a non-pack</span>
<span class="cm">		 * connection so that we don&#39;t get false positives during</span>
<span class="cm">		 * future, packetized, connections.</span>
<span class="cm">		 */</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CLRSINT1</span><span class="p">,</span> <span class="n">CLRBUSFREE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">packetized</span> <span class="o">==</span> <span class="mi">0</span>
		 <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">bugs</span> <span class="o">&amp;</span> <span class="n">AHD_BUSFREEREV_BUG</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SIMODE1</span><span class="p">,</span>
				 <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SIMODE1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">ENBUSFREE</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">clear_fifo</span><span class="p">)</span>
			<span class="n">ahd_clear_fifo</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>

		<span class="n">ahd_clear_msg_state</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CLRINT</span><span class="p">,</span> <span class="n">CLRSCSIINT</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">restart</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ahd_restart</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ahd_unpause</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: Missing case in ahd_handle_scsiint. status = %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">),</span> <span class="n">status</span><span class="p">);</span>
		<span class="n">ahd_dump_card_state</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
		<span class="n">ahd_clear_intstat</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
		<span class="n">ahd_unpause</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_handle_transmission_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span>	<span class="n">scb</span> <span class="o">*</span><span class="n">scb</span><span class="p">;</span>
	<span class="n">u_int</span>	<span class="n">scbid</span><span class="p">;</span>
	<span class="n">u_int</span>	<span class="n">lqistat1</span><span class="p">;</span>
	<span class="n">u_int</span>	<span class="n">lqistat2</span><span class="p">;</span>
	<span class="n">u_int</span>	<span class="n">msg_out</span><span class="p">;</span>
	<span class="n">u_int</span>	<span class="n">curphase</span><span class="p">;</span>
	<span class="n">u_int</span>	<span class="n">lastphase</span><span class="p">;</span>
	<span class="n">u_int</span>	<span class="n">perrdiag</span><span class="p">;</span>
	<span class="n">u_int</span>	<span class="n">cur_col</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">silent</span><span class="p">;</span>

	<span class="n">scb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ahd_set_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI</span><span class="p">);</span>
	<span class="n">lqistat1</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">LQISTAT1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">LQIPHASE_LQ</span><span class="o">|</span><span class="n">LQIPHASE_NLQ</span><span class="p">);</span>
	<span class="n">lqistat2</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">LQISTAT2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">lqistat1</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">LQICRCI_NLQ</span><span class="o">|</span><span class="n">LQICRCI_LQ</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span>
	 <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">bugs</span> <span class="o">&amp;</span> <span class="n">AHD_NLQICRC_DELAYED_BUG</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u_int</span> <span class="n">lqistate</span><span class="p">;</span>

		<span class="n">ahd_set_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHD_MODE_CFG</span><span class="p">,</span> <span class="n">AHD_MODE_CFG</span><span class="p">);</span>
		<span class="n">lqistate</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">LQISTATE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">lqistate</span> <span class="o">&gt;=</span> <span class="mh">0x1E</span> <span class="o">&amp;&amp;</span> <span class="n">lqistate</span> <span class="o">&lt;=</span> <span class="mh">0x24</span><span class="p">)</span>
		 <span class="o">||</span> <span class="p">(</span><span class="n">lqistate</span> <span class="o">==</span> <span class="mh">0x29</span><span class="p">))</span> <span class="p">{</span>
<span class="cp">#ifdef AHD_DEBUG</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">ahd_debug</span> <span class="o">&amp;</span> <span class="n">AHD_SHOW_RECOVERY</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: NLQCRC found via LQISTATE</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">));</span>
			<span class="p">}</span>
<span class="cp">#endif</span>
			<span class="n">lqistat1</span> <span class="o">|=</span> <span class="n">LQICRCI_NLQ</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ahd_set_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CLRLQIINT1</span><span class="p">,</span> <span class="n">lqistat1</span><span class="p">);</span>
	<span class="n">lastphase</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">LASTPHASE</span><span class="p">);</span>
	<span class="n">curphase</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCSISIGI</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PHASE_MASK</span><span class="p">;</span>
	<span class="n">perrdiag</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">PERRDIAG</span><span class="p">);</span>
	<span class="n">msg_out</span> <span class="o">=</span> <span class="n">MSG_INITIATOR_DET_ERR</span><span class="p">;</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CLRSINT1</span><span class="p">,</span> <span class="n">CLRSCSIPERR</span><span class="p">);</span>
	
	<span class="cm">/*</span>
<span class="cm">	 * Try to find the SCB associated with this error.</span>
<span class="cm">	 */</span>
	<span class="n">silent</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lqistat1</span> <span class="o">==</span> <span class="mi">0</span>
	 <span class="o">||</span> <span class="p">(</span><span class="n">lqistat1</span> <span class="o">&amp;</span> <span class="n">LQICRCI_NLQ</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
	 	<span class="k">if</span> <span class="p">((</span><span class="n">lqistat1</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">LQICRCI_NLQ</span><span class="o">|</span><span class="n">LQIOVERI_NLQ</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ahd_set_active_fifo</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
		<span class="n">scbid</span> <span class="o">=</span> <span class="n">ahd_get_scbptr</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
		<span class="n">scb</span> <span class="o">=</span> <span class="n">ahd_lookup_scb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scbid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">scb</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">SCB_IS_SILENT</span><span class="p">(</span><span class="n">scb</span><span class="p">))</span>
			<span class="n">silent</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cur_col</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">silent</span> <span class="o">==</span> <span class="n">FALSE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: Transmission error detected</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">));</span>
		<span class="n">ahd_lqistat1_print</span><span class="p">(</span><span class="n">lqistat1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cur_col</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
		<span class="n">ahd_lastphase_print</span><span class="p">(</span><span class="n">lastphase</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cur_col</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
		<span class="n">ahd_scsisigi_print</span><span class="p">(</span><span class="n">curphase</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cur_col</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
		<span class="n">ahd_perrdiag_print</span><span class="p">(</span><span class="n">perrdiag</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cur_col</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ahd_dump_card_state</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">lqistat1</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">LQIOVERI_LQ</span><span class="o">|</span><span class="n">LQIOVERI_NLQ</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">silent</span> <span class="o">==</span> <span class="n">FALSE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: Gross protocol error during incoming &quot;</span>
			       <span class="s">&quot;packet.  lqistat1 == 0x%x.  Resetting bus.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">),</span> <span class="n">lqistat1</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">ahd_reset_channel</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="sc">&#39;A&#39;</span><span class="p">,</span> <span class="cm">/*Initiate Reset*/</span><span class="n">TRUE</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">lqistat1</span> <span class="o">&amp;</span> <span class="n">LQICRCI_LQ</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * A CRC error has been detected on an incoming LQ.</span>
<span class="cm">		 * The bus is currently hung on the last ACK.</span>
<span class="cm">		 * Hit LQIRETRY to release the last ack, and</span>
<span class="cm">		 * wait for the sequencer to determine that ATNO</span>
<span class="cm">		 * is asserted while in message out to take us</span>
<span class="cm">		 * to our host message loop.  No NONPACKREQ or</span>
<span class="cm">		 * LQIPHASE type errors will occur in this</span>
<span class="cm">		 * scenario.  After this first LQIRETRY, the LQI</span>
<span class="cm">		 * manager will be in ISELO where it will</span>
<span class="cm">		 * happily sit until another packet phase begins.</span>
<span class="cm">		 * Unexpected bus free detection is enabled</span>
<span class="cm">		 * through any phases that occur after we release</span>
<span class="cm">		 * this last ack until the LQI manager sees a</span>
<span class="cm">		 * packet phase.  This implies we may have to</span>
<span class="cm">		 * ignore a perfectly valid &quot;unexected busfree&quot;</span>
<span class="cm">		 * after our &quot;initiator detected error&quot; message is</span>
<span class="cm">		 * sent.  A busfree is the expected response after</span>
<span class="cm">		 * we tell the target that it&#39;s L_Q was corrupted.</span>
<span class="cm">		 * (SPI4R09 10.7.3.3.3)</span>
<span class="cm">		 */</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">LQCTL2</span><span class="p">,</span> <span class="n">LQIRETRY</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;LQIRetry for LQICRCI_LQ to release ACK</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">lqistat1</span> <span class="o">&amp;</span> <span class="n">LQICRCI_NLQ</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We detected a CRC error in a NON-LQ packet.</span>
<span class="cm">		 * The hardware has varying behavior in this situation</span>
<span class="cm">		 * depending on whether this packet was part of a</span>
<span class="cm">		 * stream or not.</span>
<span class="cm">		 *</span>
<span class="cm">		 * PKT by PKT mode:</span>
<span class="cm">		 * The hardware has already acked the complete packet.</span>
<span class="cm">		 * If the target honors our outstanding ATN condition,</span>
<span class="cm">		 * we should be (or soon will be) in MSGOUT phase.</span>
<span class="cm">		 * This will trigger the LQIPHASE_LQ status bit as the</span>
<span class="cm">		 * hardware was expecting another LQ.  Unexpected</span>
<span class="cm">		 * busfree detection is enabled.  Once LQIPHASE_LQ is</span>
<span class="cm">		 * true (first entry into host message loop is much</span>
<span class="cm">		 * the same), we must clear LQIPHASE_LQ and hit</span>
<span class="cm">		 * LQIRETRY so the hardware is ready to handle</span>
<span class="cm">		 * a future LQ.  NONPACKREQ will not be asserted again</span>
<span class="cm">		 * once we hit LQIRETRY until another packet is</span>
<span class="cm">		 * processed.  The target may either go busfree</span>
<span class="cm">		 * or start another packet in response to our message.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Read Streaming P0 asserted:</span>
<span class="cm">		 * If we raise ATN and the target completes the entire</span>
<span class="cm">		 * stream (P0 asserted during the last packet), the</span>
<span class="cm">		 * hardware will ack all data and return to the ISTART</span>
<span class="cm">		 * state.  When the target reponds to our ATN condition,</span>
<span class="cm">		 * LQIPHASE_LQ will be asserted.  We should respond to</span>
<span class="cm">		 * this with an LQIRETRY to prepare for any future</span>
<span class="cm">		 * packets.  NONPACKREQ will not be asserted again</span>
<span class="cm">		 * once we hit LQIRETRY until another packet is</span>
<span class="cm">		 * processed.  The target may either go busfree or</span>
<span class="cm">		 * start another packet in response to our message.</span>
<span class="cm">		 * Busfree detection is enabled.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Read Streaming P0 not asserted:</span>
<span class="cm">		 * If we raise ATN and the target transitions to</span>
<span class="cm">		 * MSGOUT in or after a packet where P0 is not</span>
<span class="cm">		 * asserted, the hardware will assert LQIPHASE_NLQ.</span>
<span class="cm">		 * We should respond to the LQIPHASE_NLQ with an</span>
<span class="cm">		 * LQIRETRY.  Should the target stay in a non-pkt</span>
<span class="cm">		 * phase after we send our message, the hardware</span>
<span class="cm">		 * will assert LQIPHASE_LQ.  Recovery is then just as</span>
<span class="cm">		 * listed above for the read streaming with P0 asserted.</span>
<span class="cm">		 * Busfree detection is enabled.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">silent</span> <span class="o">==</span> <span class="n">FALSE</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;LQICRC_NLQ</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">scb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: No SCB valid for LQICRC_NLQ.  &quot;</span>
			       <span class="s">&quot;Resetting bus</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">));</span>
			<span class="n">ahd_reset_channel</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="sc">&#39;A&#39;</span><span class="p">,</span> <span class="cm">/*Initiate Reset*/</span><span class="n">TRUE</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">lqistat1</span> <span class="o">&amp;</span> <span class="n">LQIBADLQI</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Need to handle BADLQI!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ahd_reset_channel</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="sc">&#39;A&#39;</span><span class="p">,</span> <span class="cm">/*Initiate Reset*/</span><span class="n">TRUE</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">perrdiag</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PARITYERR</span><span class="o">|</span><span class="n">PREVPHASE</span><span class="p">))</span> <span class="o">==</span> <span class="n">PARITYERR</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">curphase</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">P_DATAIN_DT</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Ack the byte.  So we can continue. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">silent</span> <span class="o">==</span> <span class="n">FALSE</span><span class="p">)</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Acking %s to clear perror</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				    <span class="n">ahd_lookup_phase_entry</span><span class="p">(</span><span class="n">curphase</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">phasemsg</span><span class="p">);</span>
			<span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCSIDAT</span><span class="p">);</span>
		<span class="p">}</span>
	
		<span class="k">if</span> <span class="p">(</span><span class="n">curphase</span> <span class="o">==</span> <span class="n">P_MESGIN</span><span class="p">)</span>
			<span class="n">msg_out</span> <span class="o">=</span> <span class="n">MSG_PARITY_ERROR</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We&#39;ve set the hardware to assert ATN if we </span>
<span class="cm">	 * get a parity error on &quot;in&quot; phases, so all we</span>
<span class="cm">	 * need to do is stuff the message buffer with</span>
<span class="cm">	 * the appropriate message.  &quot;In&quot; phases have set</span>
<span class="cm">	 * mesg_out to something other than MSG_NOP.</span>
<span class="cm">	 */</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">send_msg_perror</span> <span class="o">=</span> <span class="n">msg_out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">scb</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">msg_out</span> <span class="o">==</span> <span class="n">MSG_INITIATOR_DET_ERR</span><span class="p">)</span>
		<span class="n">scb</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">SCB_TRANSMISSION_ERROR</span><span class="p">;</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">MSG_OUT</span><span class="p">,</span> <span class="n">HOST_MSG</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CLRINT</span><span class="p">,</span> <span class="n">CLRSCSIINT</span><span class="p">);</span>
	<span class="n">ahd_unpause</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_handle_lqiphase_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">lqistat1</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Clear the sources of the interrupts.</span>
<span class="cm">	 */</span>
	<span class="n">ahd_set_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CLRLQIINT1</span><span class="p">,</span> <span class="n">lqistat1</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the &quot;illegal&quot; phase changes were in response</span>
<span class="cm">	 * to our ATN to flag a CRC error, AND we ended up</span>
<span class="cm">	 * on packet boundaries, clear the error, restart the</span>
<span class="cm">	 * LQI manager as appropriate, and go on our merry</span>
<span class="cm">	 * way toward sending the message.  Otherwise, reset</span>
<span class="cm">	 * the bus to clear the error.</span>
<span class="cm">	 */</span>
	<span class="n">ahd_set_active_fifo</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCSISIGO</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">ATNO</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>
	 <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">MDFFSTAT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">DLZERO</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">lqistat1</span> <span class="o">&amp;</span> <span class="n">LQIPHASE_LQ</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;LQIRETRY for LQIPHASE_LQ</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">LQCTL2</span><span class="p">,</span> <span class="n">LQIRETRY</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">lqistat1</span> <span class="o">&amp;</span> <span class="n">LQIPHASE_NLQ</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;LQIRETRY for LQIPHASE_NLQ</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">LQCTL2</span><span class="p">,</span> <span class="n">LQIRETRY</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">panic</span><span class="p">(</span><span class="s">&quot;ahd_handle_lqiphase_error: No phase errors</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ahd_dump_card_state</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CLRINT</span><span class="p">,</span> <span class="n">CLRSCSIINT</span><span class="p">);</span>
		<span class="n">ahd_unpause</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Reseting Channel for LQI Phase error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ahd_dump_card_state</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
		<span class="n">ahd_reset_channel</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="sc">&#39;A&#39;</span><span class="p">,</span> <span class="cm">/*Initiate Reset*/</span><span class="n">TRUE</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Packetized unexpected or expected busfree.</span>
<span class="cm"> * Entered in mode based on busfreetime.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ahd_handle_pkt_busfree</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">busfreetime</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u_int</span> <span class="n">lqostat1</span><span class="p">;</span>

	<span class="n">AHD_ASSERT_MODES</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="o">~</span><span class="p">(</span><span class="n">AHD_MODE_UNKNOWN_MSK</span><span class="o">|</span><span class="n">AHD_MODE_CFG_MSK</span><span class="p">),</span>
			 <span class="o">~</span><span class="p">(</span><span class="n">AHD_MODE_UNKNOWN_MSK</span><span class="o">|</span><span class="n">AHD_MODE_CFG_MSK</span><span class="p">));</span>
	<span class="n">lqostat1</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">LQOSTAT1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">lqostat1</span> <span class="o">&amp;</span> <span class="n">LQOBUSFREE</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">scb</span> <span class="o">*</span><span class="n">scb</span><span class="p">;</span>
		<span class="n">u_int</span> <span class="n">scbid</span><span class="p">;</span>
		<span class="n">u_int</span> <span class="n">saved_scbptr</span><span class="p">;</span>
		<span class="n">u_int</span> <span class="n">waiting_h</span><span class="p">;</span>
		<span class="n">u_int</span> <span class="n">waiting_t</span><span class="p">;</span>
		<span class="n">u_int</span> <span class="n">next</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * The LQO manager detected an unexpected busfree</span>
<span class="cm">		 * either:</span>
<span class="cm">		 *</span>
<span class="cm">		 * 1) During an outgoing LQ.</span>
<span class="cm">		 * 2) After an outgoing LQ but before the first</span>
<span class="cm">		 *    REQ of the command packet.</span>
<span class="cm">		 * 3) During an outgoing command packet.</span>
<span class="cm">		 *</span>
<span class="cm">		 * In all cases, CURRSCB is pointing to the</span>
<span class="cm">		 * SCB that encountered the failure.  Clean</span>
<span class="cm">		 * up the queue, clear SELDO and LQOBUSFREE,</span>
<span class="cm">		 * and allow the sequencer to restart the select</span>
<span class="cm">		 * out at its lesure.</span>
<span class="cm">		 */</span>
		<span class="n">ahd_set_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI</span><span class="p">);</span>
		<span class="n">scbid</span> <span class="o">=</span> <span class="n">ahd_inw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CURRSCB</span><span class="p">);</span>
		<span class="n">scb</span> <span class="o">=</span> <span class="n">ahd_lookup_scb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scbid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">scb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		       <span class="n">panic</span><span class="p">(</span><span class="s">&quot;SCB not valid during LQOBUSFREE&quot;</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Clear the status.</span>
<span class="cm">		 */</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CLRLQOINT1</span><span class="p">,</span> <span class="n">CLRLQOBUSFREE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">bugs</span> <span class="o">&amp;</span> <span class="n">AHD_CLRLQO_AUTOCLR_BUG</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CLRLQOINT1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCSISEQ0</span><span class="p">,</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCSISEQ0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">ENSELO</span><span class="p">);</span>
		<span class="n">ahd_flush_device_writes</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CLRSINT0</span><span class="p">,</span> <span class="n">CLRSELDO</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Return the LQO manager to its idle loop.  It will</span>
<span class="cm">		 * not do this automatically if the busfree occurs</span>
<span class="cm">		 * after the first REQ of either the LQ or command</span>
<span class="cm">		 * packet or between the LQ and command packet.</span>
<span class="cm">		 */</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">LQCTL2</span><span class="p">,</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">LQCTL2</span><span class="p">)</span> <span class="o">|</span> <span class="n">LQOTOIDLE</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Update the waiting for selection queue so</span>
<span class="cm">		 * we restart on the correct SCB.</span>
<span class="cm">		 */</span>
		<span class="n">waiting_h</span> <span class="o">=</span> <span class="n">ahd_inw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">WAITING_TID_HEAD</span><span class="p">);</span>
		<span class="n">saved_scbptr</span> <span class="o">=</span> <span class="n">ahd_get_scbptr</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">waiting_h</span> <span class="o">!=</span> <span class="n">scbid</span><span class="p">)</span> <span class="p">{</span>

			<span class="n">ahd_outw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">WAITING_TID_HEAD</span><span class="p">,</span> <span class="n">scbid</span><span class="p">);</span>
			<span class="n">waiting_t</span> <span class="o">=</span> <span class="n">ahd_inw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">WAITING_TID_TAIL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">waiting_t</span> <span class="o">==</span> <span class="n">waiting_h</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ahd_outw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">WAITING_TID_TAIL</span><span class="p">,</span> <span class="n">scbid</span><span class="p">);</span>
				<span class="n">next</span> <span class="o">=</span> <span class="n">SCB_LIST_NULL</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">ahd_set_scbptr</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">waiting_h</span><span class="p">);</span>
				<span class="n">next</span> <span class="o">=</span> <span class="n">ahd_inw_scbram</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_NEXT2</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">ahd_set_scbptr</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scbid</span><span class="p">);</span>
			<span class="n">ahd_outw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_NEXT2</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">ahd_set_scbptr</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">saved_scbptr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">crc_retry_count</span> <span class="o">&lt;</span> <span class="n">AHD_MAX_LQ_CRC_ERRORS</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">SCB_IS_SILENT</span><span class="p">(</span><span class="n">scb</span><span class="p">)</span> <span class="o">==</span> <span class="n">FALSE</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ahd_print_path</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Probable outgoing LQ CRC error.  &quot;</span>
				       <span class="s">&quot;Retrying command</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">scb</span><span class="o">-&gt;</span><span class="n">crc_retry_count</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ahd_set_transaction_status</span><span class="p">(</span><span class="n">scb</span><span class="p">,</span> <span class="n">CAM_UNCOR_PARITY</span><span class="p">);</span>
			<span class="n">ahd_freeze_scb</span><span class="p">(</span><span class="n">scb</span><span class="p">);</span>
			<span class="n">ahd_freeze_devq</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* Return unpausing the sequencer. */</span>
		<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">PERRDIAG</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PARITYERR</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Ignore what are really parity errors that</span>
<span class="cm">		 * occur on the last REQ of a free running</span>
<span class="cm">		 * clock prior to going busfree.  Some drives</span>
<span class="cm">		 * do not properly active negate just before</span>
<span class="cm">		 * going busfree resulting in a parity glitch.</span>
<span class="cm">		 */</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CLRSINT1</span><span class="p">,</span> <span class="n">CLRSCSIPERR</span><span class="o">|</span><span class="n">CLRBUSFREE</span><span class="p">);</span>
<span class="cp">#ifdef AHD_DEBUG</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ahd_debug</span> <span class="o">&amp;</span> <span class="n">AHD_SHOW_MASKED_ERRORS</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: Parity on last REQ detected &quot;</span>
			       <span class="s">&quot;during busfree phase.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">));</span>
<span class="cp">#endif</span>
		<span class="cm">/* Return unpausing the sequencer. */</span>
		<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">src_mode</span> <span class="o">!=</span> <span class="n">AHD_MODE_SCSI</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u_int</span>	<span class="n">scbid</span><span class="p">;</span>
		<span class="k">struct</span>	<span class="n">scb</span> <span class="o">*</span><span class="n">scb</span><span class="p">;</span>

		<span class="n">scbid</span> <span class="o">=</span> <span class="n">ahd_get_scbptr</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
		<span class="n">scb</span> <span class="o">=</span> <span class="n">ahd_lookup_scb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scbid</span><span class="p">);</span>
		<span class="n">ahd_print_path</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Unexpected PKT busfree condition</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ahd_dump_card_state</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
		<span class="n">ahd_abort_scbs</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_GET_TARGET</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">),</span> <span class="sc">&#39;A&#39;</span><span class="p">,</span>
			       <span class="n">SCB_GET_LUN</span><span class="p">(</span><span class="n">scb</span><span class="p">),</span> <span class="n">SCB_GET_TAG</span><span class="p">(</span><span class="n">scb</span><span class="p">),</span>
			       <span class="n">ROLE_INITIATOR</span><span class="p">,</span> <span class="n">CAM_UNEXP_BUSFREE</span><span class="p">);</span>

		<span class="cm">/* Return restarting the sequencer. */</span>
		<span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: Unexpected PKT busfree condition</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">));</span>
	<span class="n">ahd_dump_card_state</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
	<span class="cm">/* Restart the sequencer. */</span>
	<span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Non-packetized unexpected or expected busfree.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ahd_handle_nonpkt_busfree</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span>	<span class="n">ahd_devinfo</span> <span class="n">devinfo</span><span class="p">;</span>
	<span class="k">struct</span>	<span class="n">scb</span> <span class="o">*</span><span class="n">scb</span><span class="p">;</span>
	<span class="n">u_int</span>	<span class="n">lastphase</span><span class="p">;</span>
	<span class="n">u_int</span>	<span class="n">saved_scsiid</span><span class="p">;</span>
	<span class="n">u_int</span>	<span class="n">saved_lun</span><span class="p">;</span>
	<span class="n">u_int</span>	<span class="n">target</span><span class="p">;</span>
	<span class="n">u_int</span>	<span class="n">initiator_role_id</span><span class="p">;</span>
	<span class="n">u_int</span>	<span class="n">scbid</span><span class="p">;</span>
	<span class="n">u_int</span>	<span class="n">ppr_busfree</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">printerror</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Look at what phase we were last in.  If its message out,</span>
<span class="cm">	 * chances are pretty good that the busfree was in response</span>
<span class="cm">	 * to one of our abort requests.</span>
<span class="cm">	 */</span>
	<span class="n">lastphase</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">LASTPHASE</span><span class="p">);</span>
	<span class="n">saved_scsiid</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SAVED_SCSIID</span><span class="p">);</span>
	<span class="n">saved_lun</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SAVED_LUN</span><span class="p">);</span>
	<span class="n">target</span> <span class="o">=</span> <span class="n">SCSIID_TARGET</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">saved_scsiid</span><span class="p">);</span>
	<span class="n">initiator_role_id</span> <span class="o">=</span> <span class="n">SCSIID_OUR_ID</span><span class="p">(</span><span class="n">saved_scsiid</span><span class="p">);</span>
	<span class="n">ahd_compile_devinfo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devinfo</span><span class="p">,</span> <span class="n">initiator_role_id</span><span class="p">,</span>
			    <span class="n">target</span><span class="p">,</span> <span class="n">saved_lun</span><span class="p">,</span> <span class="sc">&#39;A&#39;</span><span class="p">,</span> <span class="n">ROLE_INITIATOR</span><span class="p">);</span>
	<span class="n">printerror</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">scbid</span> <span class="o">=</span> <span class="n">ahd_get_scbptr</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
	<span class="n">scb</span> <span class="o">=</span> <span class="n">ahd_lookup_scb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scbid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">scb</span> <span class="o">!=</span> <span class="nb">NULL</span>
	 <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SEQ_FLAGS</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">NOT_IDENTIFIED</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">scb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">ppr_busfree</span> <span class="o">=</span> <span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msg_flags</span> <span class="o">&amp;</span> <span class="n">MSG_FLAG_EXPECT_PPR_BUSFREE</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lastphase</span> <span class="o">==</span> <span class="n">P_MESGOUT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u_int</span> <span class="n">tag</span><span class="p">;</span>

		<span class="n">tag</span> <span class="o">=</span> <span class="n">SCB_LIST_NULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ahd_sent_msg</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHDMSG_1B</span><span class="p">,</span> <span class="n">MSG_ABORT_TAG</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">)</span>
		 <span class="o">||</span> <span class="n">ahd_sent_msg</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHDMSG_1B</span><span class="p">,</span> <span class="n">MSG_ABORT</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">found</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">sent_msg</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">scb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ahd_print_devinfo</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">devinfo</span><span class="p">);</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Abort for unidentified &quot;</span>
				       <span class="s">&quot;connection completed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="cm">/* restart the sequencer. */</span>
				<span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">sent_msg</span> <span class="o">=</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_buf</span><span class="p">[</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
			<span class="n">ahd_print_path</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;SCB %d - Abort%s Completed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">SCB_GET_TAG</span><span class="p">(</span><span class="n">scb</span><span class="p">),</span>
			       <span class="n">sent_msg</span> <span class="o">==</span> <span class="n">MSG_ABORT_TAG</span> <span class="o">?</span> <span class="s">&quot;&quot;</span> <span class="o">:</span> <span class="s">&quot; Tag&quot;</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">sent_msg</span> <span class="o">==</span> <span class="n">MSG_ABORT_TAG</span><span class="p">)</span>
				<span class="n">tag</span> <span class="o">=</span> <span class="n">SCB_GET_TAG</span><span class="p">(</span><span class="n">scb</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">((</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SCB_EXTERNAL_RESET</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * This abort is in response to an</span>
<span class="cm">				 * unexpected switch to command phase</span>
<span class="cm">				 * for a packetized connection.  Since</span>
<span class="cm">				 * the identify message was never sent,</span>
<span class="cm">				 * &quot;saved lun&quot; is 0.  We really want to</span>
<span class="cm">				 * abort only the SCB that encountered</span>
<span class="cm">				 * this error, which could have a different</span>
<span class="cm">				 * lun.  The SCB will be retried so the OS</span>
<span class="cm">				 * will see the UA after renegotiating to</span>
<span class="cm">				 * packetized.</span>
<span class="cm">				 */</span>
				<span class="n">tag</span> <span class="o">=</span> <span class="n">SCB_GET_TAG</span><span class="p">(</span><span class="n">scb</span><span class="p">);</span>
				<span class="n">saved_lun</span> <span class="o">=</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">hscb</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">found</span> <span class="o">=</span> <span class="n">ahd_abort_scbs</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="sc">&#39;A&#39;</span><span class="p">,</span> <span class="n">saved_lun</span><span class="p">,</span>
					       <span class="n">tag</span><span class="p">,</span> <span class="n">ROLE_INITIATOR</span><span class="p">,</span>
					       <span class="n">CAM_REQ_ABORTED</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;found == 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">found</span><span class="p">);</span>
			<span class="n">printerror</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ahd_sent_msg</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHDMSG_1B</span><span class="p">,</span>
					<span class="n">MSG_BUS_DEV_RESET</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">))</span> <span class="p">{</span>
<span class="cp">#ifdef __FreeBSD__</span>
			<span class="cm">/*</span>
<span class="cm">			 * Don&#39;t mark the user&#39;s request for this BDR</span>
<span class="cm">			 * as completing with CAM_BDR_SENT.  CAM3</span>
<span class="cm">			 * specifies CAM_REQ_CMP.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">scb</span> <span class="o">!=</span> <span class="nb">NULL</span>
			 <span class="o">&amp;&amp;</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">io_ctx</span><span class="o">-&gt;</span><span class="n">ccb_h</span><span class="p">.</span><span class="n">func_code</span><span class="o">==</span> <span class="n">XPT_RESET_DEV</span>
			 <span class="o">&amp;&amp;</span> <span class="n">ahd_match_scb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="sc">&#39;A&#39;</span><span class="p">,</span>
					  <span class="n">CAM_LUN_WILDCARD</span><span class="p">,</span> <span class="n">SCB_LIST_NULL</span><span class="p">,</span>
					  <span class="n">ROLE_INITIATOR</span><span class="p">))</span>
				<span class="n">ahd_set_transaction_status</span><span class="p">(</span><span class="n">scb</span><span class="p">,</span> <span class="n">CAM_REQ_CMP</span><span class="p">);</span>
<span class="cp">#endif</span>
			<span class="n">ahd_handle_devreset</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">devinfo</span><span class="p">,</span> <span class="n">CAM_LUN_WILDCARD</span><span class="p">,</span>
					    <span class="n">CAM_BDR_SENT</span><span class="p">,</span> <span class="s">&quot;Bus Device Reset&quot;</span><span class="p">,</span>
					    <span class="cm">/*verbose_level*/</span><span class="mi">0</span><span class="p">);</span>
			<span class="n">printerror</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ahd_sent_msg</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHDMSG_EXT</span><span class="p">,</span> <span class="n">MSG_EXT_PPR</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">)</span>
			<span class="o">&amp;&amp;</span> <span class="n">ppr_busfree</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">ahd_initiator_tinfo</span> <span class="o">*</span><span class="n">tinfo</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">ahd_tmode_tstate</span> <span class="o">*</span><span class="n">tstate</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * PPR Rejected.</span>
<span class="cm">			 *</span>
<span class="cm">			 * If the previous negotiation was packetized,</span>
<span class="cm">			 * this could be because the device has been</span>
<span class="cm">			 * reset without our knowledge.  Force our</span>
<span class="cm">			 * current negotiation to async and retry the</span>
<span class="cm">			 * negotiation.  Otherwise retry the command</span>
<span class="cm">			 * with non-ppr negotiation.</span>
<span class="cm">			 */</span>
<span class="cp">#ifdef AHD_DEBUG</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">ahd_debug</span> <span class="o">&amp;</span> <span class="n">AHD_SHOW_MESSAGES</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;PPR negotiation rejected busfree.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
			<span class="n">tinfo</span> <span class="o">=</span> <span class="n">ahd_fetch_transinfo</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">devinfo</span><span class="p">.</span><span class="n">channel</span><span class="p">,</span>
						    <span class="n">devinfo</span><span class="p">.</span><span class="n">our_scsiid</span><span class="p">,</span>
						    <span class="n">devinfo</span><span class="p">.</span><span class="n">target</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tstate</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">.</span><span class="n">ppr_options</span> <span class="o">&amp;</span> <span class="n">MSG_EXT_PPR_IU_REQ</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ahd_set_width</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">devinfo</span><span class="p">,</span>
					      <span class="n">MSG_EXT_WDTR_BUS_8_BIT</span><span class="p">,</span>
					      <span class="n">AHD_TRANS_CUR</span><span class="p">,</span>
					      <span class="cm">/*paused*/</span><span class="n">TRUE</span><span class="p">);</span>
				<span class="n">ahd_set_syncrate</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">devinfo</span><span class="p">,</span>
						<span class="cm">/*period*/</span><span class="mi">0</span><span class="p">,</span> <span class="cm">/*offset*/</span><span class="mi">0</span><span class="p">,</span>
						<span class="cm">/*ppr_options*/</span><span class="mi">0</span><span class="p">,</span>
						<span class="n">AHD_TRANS_CUR</span><span class="p">,</span>
						<span class="cm">/*paused*/</span><span class="n">TRUE</span><span class="p">);</span>
				<span class="cm">/*</span>
<span class="cm">				 * The expect PPR busfree handler below</span>
<span class="cm">				 * will effect the retry and necessary</span>
<span class="cm">				 * abort.</span>
<span class="cm">				 */</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">.</span><span class="n">transport_version</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
				<span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">goal</span><span class="p">.</span><span class="n">transport_version</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
				<span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">goal</span><span class="p">.</span><span class="n">ppr_options</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">scb</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/*</span>
<span class="cm">					 * Remove any SCBs in the waiting</span>
<span class="cm">					 * for selection queue that may</span>
<span class="cm">					 * also be for this target so that</span>
<span class="cm">					 * command ordering is preserved.</span>
<span class="cm">					 */</span>
					<span class="n">ahd_freeze_devq</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
					<span class="n">ahd_qinfifo_requeue_tail</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="n">printerror</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ahd_sent_msg</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHDMSG_EXT</span><span class="p">,</span> <span class="n">MSG_EXT_WDTR</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">)</span>
			<span class="o">&amp;&amp;</span> <span class="n">ppr_busfree</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Negotiation Rejected.  Go-narrow and</span>
<span class="cm">			 * retry command.</span>
<span class="cm">			 */</span>
<span class="cp">#ifdef AHD_DEBUG</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">ahd_debug</span> <span class="o">&amp;</span> <span class="n">AHD_SHOW_MESSAGES</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;WDTR negotiation rejected busfree.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
			<span class="n">ahd_set_width</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">devinfo</span><span class="p">,</span>
				      <span class="n">MSG_EXT_WDTR_BUS_8_BIT</span><span class="p">,</span>
				      <span class="n">AHD_TRANS_CUR</span><span class="o">|</span><span class="n">AHD_TRANS_GOAL</span><span class="p">,</span>
				      <span class="cm">/*paused*/</span><span class="n">TRUE</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">scb</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Remove any SCBs in the waiting for</span>
<span class="cm">				 * selection queue that may also be for</span>
<span class="cm">				 * this target so that command ordering</span>
<span class="cm">				 * is preserved.</span>
<span class="cm">				 */</span>
				<span class="n">ahd_freeze_devq</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
				<span class="n">ahd_qinfifo_requeue_tail</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">printerror</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ahd_sent_msg</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHDMSG_EXT</span><span class="p">,</span> <span class="n">MSG_EXT_SDTR</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">)</span>
			<span class="o">&amp;&amp;</span> <span class="n">ppr_busfree</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Negotiation Rejected.  Go-async and</span>
<span class="cm">			 * retry command.</span>
<span class="cm">			 */</span>
<span class="cp">#ifdef AHD_DEBUG</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">ahd_debug</span> <span class="o">&amp;</span> <span class="n">AHD_SHOW_MESSAGES</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;SDTR negotiation rejected busfree.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
			<span class="n">ahd_set_syncrate</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">devinfo</span><span class="p">,</span>
					<span class="cm">/*period*/</span><span class="mi">0</span><span class="p">,</span> <span class="cm">/*offset*/</span><span class="mi">0</span><span class="p">,</span>
					<span class="cm">/*ppr_options*/</span><span class="mi">0</span><span class="p">,</span>
					<span class="n">AHD_TRANS_CUR</span><span class="o">|</span><span class="n">AHD_TRANS_GOAL</span><span class="p">,</span>
					<span class="cm">/*paused*/</span><span class="n">TRUE</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">scb</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Remove any SCBs in the waiting for</span>
<span class="cm">				 * selection queue that may also be for</span>
<span class="cm">				 * this target so that command ordering</span>
<span class="cm">				 * is preserved.</span>
<span class="cm">				 */</span>
				<span class="n">ahd_freeze_devq</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
				<span class="n">ahd_qinfifo_requeue_tail</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">printerror</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msg_flags</span> <span class="o">&amp;</span> <span class="n">MSG_FLAG_EXPECT_IDE_BUSFREE</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>
			<span class="o">&amp;&amp;</span> <span class="n">ahd_sent_msg</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHDMSG_1B</span><span class="p">,</span>
					 <span class="n">MSG_INITIATOR_DET_ERR</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">))</span> <span class="p">{</span>

<span class="cp">#ifdef AHD_DEBUG</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">ahd_debug</span> <span class="o">&amp;</span> <span class="n">AHD_SHOW_MESSAGES</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Expected IDE Busfree</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
			<span class="n">printerror</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msg_flags</span> <span class="o">&amp;</span> <span class="n">MSG_FLAG_EXPECT_QASREJ_BUSFREE</span><span class="p">)</span>
			<span class="o">&amp;&amp;</span> <span class="n">ahd_sent_msg</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHDMSG_1B</span><span class="p">,</span>
					<span class="n">MSG_MESSAGE_REJECT</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">))</span> <span class="p">{</span>

<span class="cp">#ifdef AHD_DEBUG</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">ahd_debug</span> <span class="o">&amp;</span> <span class="n">AHD_SHOW_MESSAGES</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Expected QAS Reject Busfree</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
			<span class="n">printerror</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * The busfree required flag is honored at the end of</span>
<span class="cm">	 * the message phases.  We check it last in case we</span>
<span class="cm">	 * had to send some other message that caused a busfree.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">scb</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">printerror</span> <span class="o">!=</span> <span class="mi">0</span>
	 <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">lastphase</span> <span class="o">==</span> <span class="n">P_MESGIN</span> <span class="o">||</span> <span class="n">lastphase</span> <span class="o">==</span> <span class="n">P_MESGOUT</span><span class="p">)</span>
	 <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msg_flags</span> <span class="o">&amp;</span> <span class="n">MSG_FLAG_EXPECT_PPR_BUSFREE</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>

		<span class="n">ahd_freeze_devq</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
		<span class="n">ahd_set_transaction_status</span><span class="p">(</span><span class="n">scb</span><span class="p">,</span> <span class="n">CAM_REQUEUE_REQ</span><span class="p">);</span>
		<span class="n">ahd_freeze_scb</span><span class="p">(</span><span class="n">scb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msg_flags</span> <span class="o">&amp;</span> <span class="n">MSG_FLAG_IU_REQ_CHANGED</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ahd_abort_scbs</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_GET_TARGET</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">),</span>
				       <span class="n">SCB_GET_CHANNEL</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">),</span>
				       <span class="n">SCB_GET_LUN</span><span class="p">(</span><span class="n">scb</span><span class="p">),</span> <span class="n">SCB_LIST_NULL</span><span class="p">,</span>
				       <span class="n">ROLE_INITIATOR</span><span class="p">,</span> <span class="n">CAM_REQ_ABORTED</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="cp">#ifdef AHD_DEBUG</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">ahd_debug</span> <span class="o">&amp;</span> <span class="n">AHD_SHOW_MESSAGES</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;PPR Negotiation Busfree.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
			<span class="n">ahd_done</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">printerror</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">printerror</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">aborted</span><span class="p">;</span>

		<span class="n">aborted</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">scb</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u_int</span> <span class="n">tag</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">((</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">hscb</span><span class="o">-&gt;</span><span class="n">control</span> <span class="o">&amp;</span> <span class="n">TAG_ENB</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">tag</span> <span class="o">=</span> <span class="n">SCB_GET_TAG</span><span class="p">(</span><span class="n">scb</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">tag</span> <span class="o">=</span> <span class="n">SCB_LIST_NULL</span><span class="p">;</span>
			<span class="n">ahd_print_path</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
			<span class="n">aborted</span> <span class="o">=</span> <span class="n">ahd_abort_scbs</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="sc">&#39;A&#39;</span><span class="p">,</span>
				       <span class="n">SCB_GET_LUN</span><span class="p">(</span><span class="n">scb</span><span class="p">),</span> <span class="n">tag</span><span class="p">,</span>
				       <span class="n">ROLE_INITIATOR</span><span class="p">,</span>
				       <span class="n">CAM_UNEXP_BUSFREE</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * We had not fully identified this connection,</span>
<span class="cm">			 * so we cannot abort anything.</span>
<span class="cm">			 */</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: &quot;</span><span class="p">,</span> <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Unexpected busfree %s, %d SCBs aborted, &quot;</span>
		       <span class="s">&quot;PRGMCNT == 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">ahd_lookup_phase_entry</span><span class="p">(</span><span class="n">lastphase</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">phasemsg</span><span class="p">,</span>
		       <span class="n">aborted</span><span class="p">,</span>
		       <span class="n">ahd_inw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">PRGMCNT</span><span class="p">));</span>
		<span class="n">ahd_dump_card_state</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lastphase</span> <span class="o">!=</span> <span class="n">P_BUSFREE</span><span class="p">)</span>
			<span class="n">ahd_force_renegotiation</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">devinfo</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* Always restart the sequencer. */</span>
	<span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_handle_proto_violation</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span>	<span class="n">ahd_devinfo</span> <span class="n">devinfo</span><span class="p">;</span>
	<span class="k">struct</span>	<span class="n">scb</span> <span class="o">*</span><span class="n">scb</span><span class="p">;</span>
	<span class="n">u_int</span>	<span class="n">scbid</span><span class="p">;</span>
	<span class="n">u_int</span>	<span class="n">seq_flags</span><span class="p">;</span>
	<span class="n">u_int</span>	<span class="n">curphase</span><span class="p">;</span>
	<span class="n">u_int</span>	<span class="n">lastphase</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">found</span><span class="p">;</span>

	<span class="n">ahd_fetch_devinfo</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">devinfo</span><span class="p">);</span>
	<span class="n">scbid</span> <span class="o">=</span> <span class="n">ahd_get_scbptr</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
	<span class="n">scb</span> <span class="o">=</span> <span class="n">ahd_lookup_scb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scbid</span><span class="p">);</span>
	<span class="n">seq_flags</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SEQ_FLAGS</span><span class="p">);</span>
	<span class="n">curphase</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCSISIGI</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PHASE_MASK</span><span class="p">;</span>
	<span class="n">lastphase</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">LASTPHASE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">seq_flags</span> <span class="o">&amp;</span> <span class="n">NOT_IDENTIFIED</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/*</span>
<span class="cm">		 * The reconnecting target either did not send an</span>
<span class="cm">		 * identify message, or did, but we didn&#39;t find an SCB</span>
<span class="cm">		 * to match.</span>
<span class="cm">		 */</span>
		<span class="n">ahd_print_devinfo</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">devinfo</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Target did not send an IDENTIFY message. &quot;</span>
		       <span class="s">&quot;LASTPHASE = 0x%x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">lastphase</span><span class="p">);</span>
		<span class="n">scb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">scb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We don&#39;t seem to have an SCB active for this</span>
<span class="cm">		 * transaction.  Print an error and reset the bus.</span>
<span class="cm">		 */</span>
		<span class="n">ahd_print_devinfo</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">devinfo</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;No SCB found during protocol violation</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">proto_violation_reset</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ahd_set_transaction_status</span><span class="p">(</span><span class="n">scb</span><span class="p">,</span> <span class="n">CAM_SEQUENCE_FAIL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">seq_flags</span> <span class="o">&amp;</span> <span class="n">NO_CDB_SENT</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ahd_print_path</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;No or incomplete CDB sent to device.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">ahd_inb_scbram</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_CONTROL</span><span class="p">)</span>
			  <span class="o">&amp;</span> <span class="n">STATUS_RCVD</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * The target never bothered to provide status to</span>
<span class="cm">			 * us prior to completing the command.  Since we don&#39;t</span>
<span class="cm">			 * know the disposition of this command, we must attempt</span>
<span class="cm">			 * to abort it.  Assert ATN and prepare to send an abort</span>
<span class="cm">			 * message.</span>
<span class="cm">			 */</span>
			<span class="n">ahd_print_path</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Completed command without status.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ahd_print_path</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Unknown protocol violation.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">ahd_dump_card_state</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">lastphase</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">P_DATAIN_DT</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
	 <span class="o">||</span> <span class="n">lastphase</span> <span class="o">==</span> <span class="n">P_COMMAND</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">proto_violation_reset:</span>
		<span class="cm">/*</span>
<span class="cm">		 * Target either went directly to data</span>
<span class="cm">		 * phase or didn&#39;t respond to our ATN.</span>
<span class="cm">		 * The only safe thing to do is to blow</span>
<span class="cm">		 * it away with a bus reset.</span>
<span class="cm">		 */</span>
		<span class="n">found</span> <span class="o">=</span> <span class="n">ahd_reset_channel</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="sc">&#39;A&#39;</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: Issued Channel %c Bus Reset. &quot;</span>
		       <span class="s">&quot;%d SCBs aborted</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">),</span> <span class="sc">&#39;A&#39;</span><span class="p">,</span> <span class="n">found</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Leave the selection hardware off in case</span>
<span class="cm">		 * this abort attempt will affect yet to</span>
<span class="cm">		 * be sent commands.</span>
<span class="cm">		 */</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCSISEQ0</span><span class="p">,</span>
			 <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCSISEQ0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">ENSELO</span><span class="p">);</span>
		<span class="n">ahd_assert_atn</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">MSG_OUT</span><span class="p">,</span> <span class="n">HOST_MSG</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">scb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ahd_print_devinfo</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">devinfo</span><span class="p">);</span>
			<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">MSG_ABORT_TASK</span><span class="p">;</span>
			<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_len</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msg_type</span> <span class="o">=</span> <span class="n">MSG_TYPE_INITIATOR_MSGOUT</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ahd_print_path</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
			<span class="n">scb</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">SCB_ABORT</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Protocol violation %s.  Attempting to abort.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">ahd_lookup_phase_entry</span><span class="p">(</span><span class="n">curphase</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">phasemsg</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Force renegotiation to occur the next time we initiate</span>
<span class="cm"> * a command to the current device.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_force_renegotiation</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ahd_devinfo</span> <span class="o">*</span><span class="n">devinfo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span>	<span class="n">ahd_initiator_tinfo</span> <span class="o">*</span><span class="n">targ_info</span><span class="p">;</span>
	<span class="k">struct</span>	<span class="n">ahd_tmode_tstate</span> <span class="o">*</span><span class="n">tstate</span><span class="p">;</span>

<span class="cp">#ifdef AHD_DEBUG</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ahd_debug</span> <span class="o">&amp;</span> <span class="n">AHD_SHOW_MESSAGES</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ahd_print_devinfo</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">devinfo</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Forcing renegotiation</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="n">targ_info</span> <span class="o">=</span> <span class="n">ahd_fetch_transinfo</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span>
					<span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span>
					<span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">our_scsiid</span><span class="p">,</span>
					<span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">tstate</span><span class="p">);</span>
	<span class="n">ahd_update_neg_request</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">devinfo</span><span class="p">,</span> <span class="n">tstate</span><span class="p">,</span>
			       <span class="n">targ_info</span><span class="p">,</span> <span class="n">AHD_NEG_IF_NON_ASYNC</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define AHD_MAX_STEPS 2000</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_clear_critical_section</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ahd_mode_state</span>	<span class="n">saved_modes</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">stepping</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">steps</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">first_instr</span><span class="p">;</span>
	<span class="n">u_int</span>		<span class="n">simode0</span><span class="p">;</span>
	<span class="n">u_int</span>		<span class="n">simode1</span><span class="p">;</span>
	<span class="n">u_int</span>		<span class="n">simode3</span><span class="p">;</span>
	<span class="n">u_int</span>		<span class="n">lqimode0</span><span class="p">;</span>
	<span class="n">u_int</span>		<span class="n">lqimode1</span><span class="p">;</span>
	<span class="n">u_int</span>		<span class="n">lqomode0</span><span class="p">;</span>
	<span class="n">u_int</span>		<span class="n">lqomode1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">num_critical_sections</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">stepping</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
	<span class="n">steps</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">first_instr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">simode0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">simode1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">simode3</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">lqimode0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">lqimode1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">lqomode0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">lqomode1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">saved_modes</span> <span class="o">=</span> <span class="n">ahd_save_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="k">struct</span>	<span class="n">cs</span> <span class="o">*</span><span class="n">cs</span><span class="p">;</span>
		<span class="n">u_int</span>	<span class="n">seqaddr</span><span class="p">;</span>
		<span class="n">u_int</span>	<span class="n">i</span><span class="p">;</span>

		<span class="n">ahd_set_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI</span><span class="p">);</span>
		<span class="n">seqaddr</span> <span class="o">=</span> <span class="n">ahd_inw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CURADDR</span><span class="p">);</span>

		<span class="n">cs</span> <span class="o">=</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">critical_sections</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">num_critical_sections</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">cs</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			
			<span class="k">if</span> <span class="p">(</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">begin</span> <span class="o">&lt;</span> <span class="n">seqaddr</span> <span class="o">&amp;&amp;</span> <span class="n">cs</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">&gt;=</span> <span class="n">seqaddr</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">num_critical_sections</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">steps</span> <span class="o">&gt;</span> <span class="n">AHD_MAX_STEPS</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: Infinite loop in critical section</span><span class="se">\n</span><span class="s">&quot;</span>
			       <span class="s">&quot;%s: First Instruction 0x%x now 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">),</span> <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">),</span> <span class="n">first_instr</span><span class="p">,</span>
			       <span class="n">seqaddr</span><span class="p">);</span>
			<span class="n">ahd_dump_card_state</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
			<span class="n">panic</span><span class="p">(</span><span class="s">&quot;critical section loop&quot;</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">steps</span><span class="o">++</span><span class="p">;</span>
<span class="cp">#ifdef AHD_DEBUG</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ahd_debug</span> <span class="o">&amp;</span> <span class="n">AHD_SHOW_MISC</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: Single stepping at 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">),</span>
			       <span class="n">seqaddr</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">stepping</span> <span class="o">==</span> <span class="n">FALSE</span><span class="p">)</span> <span class="p">{</span>

			<span class="n">first_instr</span> <span class="o">=</span> <span class="n">seqaddr</span><span class="p">;</span>
  			<span class="n">ahd_set_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHD_MODE_CFG</span><span class="p">,</span> <span class="n">AHD_MODE_CFG</span><span class="p">);</span>
  			<span class="n">simode0</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SIMODE0</span><span class="p">);</span>
			<span class="n">simode3</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SIMODE3</span><span class="p">);</span>
			<span class="n">lqimode0</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">LQIMODE0</span><span class="p">);</span>
			<span class="n">lqimode1</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">LQIMODE1</span><span class="p">);</span>
			<span class="n">lqomode0</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">LQOMODE0</span><span class="p">);</span>
			<span class="n">lqomode1</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">LQOMODE1</span><span class="p">);</span>
			<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SIMODE0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SIMODE3</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">LQIMODE0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">LQIMODE1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">LQOMODE0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">LQOMODE1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">ahd_set_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI</span><span class="p">);</span>
			<span class="n">simode1</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SIMODE1</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * We don&#39;t clear ENBUSFREE.  Unfortunately</span>
<span class="cm">			 * we cannot re-enable busfree detection within</span>
<span class="cm">			 * the current connection, so we must leave it</span>
<span class="cm">			 * on while single stepping.</span>
<span class="cm">			 */</span>
			<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SIMODE1</span><span class="p">,</span> <span class="n">simode1</span> <span class="o">&amp;</span> <span class="n">ENBUSFREE</span><span class="p">);</span>
			<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SEQCTL0</span><span class="p">,</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SEQCTL0</span><span class="p">)</span> <span class="o">|</span> <span class="n">STEP</span><span class="p">);</span>
			<span class="n">stepping</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CLRSINT1</span><span class="p">,</span> <span class="n">CLRBUSFREE</span><span class="p">);</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CLRINT</span><span class="p">,</span> <span class="n">CLRSCSIINT</span><span class="p">);</span>
		<span class="n">ahd_set_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">saved_src_mode</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">saved_dst_mode</span><span class="p">);</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">HCNTRL</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">unpause</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">ahd_is_paused</span><span class="p">(</span><span class="n">ahd</span><span class="p">))</span>
			<span class="n">ahd_delay</span><span class="p">(</span><span class="mi">200</span><span class="p">);</span>
		<span class="n">ahd_update_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">stepping</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ahd_set_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHD_MODE_CFG</span><span class="p">,</span> <span class="n">AHD_MODE_CFG</span><span class="p">);</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SIMODE0</span><span class="p">,</span> <span class="n">simode0</span><span class="p">);</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SIMODE3</span><span class="p">,</span> <span class="n">simode3</span><span class="p">);</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">LQIMODE0</span><span class="p">,</span> <span class="n">lqimode0</span><span class="p">);</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">LQIMODE1</span><span class="p">,</span> <span class="n">lqimode1</span><span class="p">);</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">LQOMODE0</span><span class="p">,</span> <span class="n">lqomode0</span><span class="p">);</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">LQOMODE1</span><span class="p">,</span> <span class="n">lqomode1</span><span class="p">);</span>
		<span class="n">ahd_set_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI</span><span class="p">);</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SEQCTL0</span><span class="p">,</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SEQCTL0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">STEP</span><span class="p">);</span>
  		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SIMODE1</span><span class="p">,</span> <span class="n">simode1</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * SCSIINT seems to glitch occasionally when</span>
<span class="cm">		 * the interrupt masks are restored.  Clear SCSIINT</span>
<span class="cm">		 * one more time so that only persistent errors</span>
<span class="cm">		 * are seen as a real interrupt.</span>
<span class="cm">		 */</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CLRINT</span><span class="p">,</span> <span class="n">CLRSCSIINT</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">ahd_restore_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">saved_modes</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Clear any pending interrupt status.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_clear_intstat</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">AHD_ASSERT_MODES</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="o">~</span><span class="p">(</span><span class="n">AHD_MODE_UNKNOWN_MSK</span><span class="o">|</span><span class="n">AHD_MODE_CFG_MSK</span><span class="p">),</span>
			 <span class="o">~</span><span class="p">(</span><span class="n">AHD_MODE_UNKNOWN_MSK</span><span class="o">|</span><span class="n">AHD_MODE_CFG_MSK</span><span class="p">));</span>
	<span class="cm">/* Clear any interrupt conditions this may have caused */</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CLRLQIINT0</span><span class="p">,</span> <span class="n">CLRLQIATNQAS</span><span class="o">|</span><span class="n">CLRLQICRCT1</span><span class="o">|</span><span class="n">CLRLQICRCT2</span>
				 <span class="o">|</span><span class="n">CLRLQIBADLQT</span><span class="o">|</span><span class="n">CLRLQIATNLQ</span><span class="o">|</span><span class="n">CLRLQIATNCMD</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CLRLQIINT1</span><span class="p">,</span> <span class="n">CLRLQIPHASE_LQ</span><span class="o">|</span><span class="n">CLRLQIPHASE_NLQ</span><span class="o">|</span><span class="n">CLRLIQABORT</span>
				 <span class="o">|</span><span class="n">CLRLQICRCI_LQ</span><span class="o">|</span><span class="n">CLRLQICRCI_NLQ</span><span class="o">|</span><span class="n">CLRLQIBADLQI</span>
				 <span class="o">|</span><span class="n">CLRLQIOVERI_LQ</span><span class="o">|</span><span class="n">CLRLQIOVERI_NLQ</span><span class="o">|</span><span class="n">CLRNONPACKREQ</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CLRLQOINT0</span><span class="p">,</span> <span class="n">CLRLQOTARGSCBPERR</span><span class="o">|</span><span class="n">CLRLQOSTOPT2</span><span class="o">|</span><span class="n">CLRLQOATNLQ</span>
				 <span class="o">|</span><span class="n">CLRLQOATNPKT</span><span class="o">|</span><span class="n">CLRLQOTCRC</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CLRLQOINT1</span><span class="p">,</span> <span class="n">CLRLQOINITSCBPERR</span><span class="o">|</span><span class="n">CLRLQOSTOPI2</span><span class="o">|</span><span class="n">CLRLQOBADQAS</span>
				 <span class="o">|</span><span class="n">CLRLQOBUSFREE</span><span class="o">|</span><span class="n">CLRLQOPHACHGINPKT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">bugs</span> <span class="o">&amp;</span> <span class="n">AHD_CLRLQO_AUTOCLR_BUG</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CLRLQOINT0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CLRLQOINT1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CLRSINT3</span><span class="p">,</span> <span class="n">CLRNTRAMPERR</span><span class="o">|</span><span class="n">CLROSRAMPERR</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CLRSINT1</span><span class="p">,</span> <span class="n">CLRSELTIMEO</span><span class="o">|</span><span class="n">CLRATNO</span><span class="o">|</span><span class="n">CLRSCSIRSTI</span>
				<span class="o">|</span><span class="n">CLRBUSFREE</span><span class="o">|</span><span class="n">CLRSCSIPERR</span><span class="o">|</span><span class="n">CLRREQINIT</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CLRSINT0</span><span class="p">,</span> <span class="n">CLRSELDO</span><span class="o">|</span><span class="n">CLRSELDI</span><span class="o">|</span><span class="n">CLRSELINGO</span>
			        <span class="o">|</span><span class="n">CLRIOERR</span><span class="o">|</span><span class="n">CLROVERRUN</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CLRINT</span><span class="p">,</span> <span class="n">CLRSCSIINT</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**************************** Debugging Routines ******************************/</span>
<span class="cp">#ifdef AHD_DEBUG</span>
<span class="kt">uint32_t</span> <span class="n">ahd_debug</span> <span class="o">=</span> <span class="n">AHD_DEBUG_OPTS</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">void</span>
<span class="c">ahd_print_scb(struct scb *scb)</span>
<span class="c">{</span>
<span class="c">	struct hardware_scb *hscb;</span>
<span class="c">	int i;</span>

<span class="c">	hscb = scb-&gt;hscb;</span>
<span class="c">	printk(&quot;scb:%p control:0x%x scsiid:0x%x lun:%d cdb_len:%d\n&quot;,</span>
<span class="c">	       (void *)scb,</span>
<span class="c">	       hscb-&gt;control,</span>
<span class="c">	       hscb-&gt;scsiid,</span>
<span class="c">	       hscb-&gt;lun,</span>
<span class="c">	       hscb-&gt;cdb_len);</span>
<span class="c">	printk(&quot;Shared Data: &quot;);</span>
<span class="c">	for (i = 0; i &lt; sizeof(hscb-&gt;shared_data.idata.cdb); i++)</span>
<span class="c">		printk(&quot;%#02x&quot;, hscb-&gt;shared_data.idata.cdb[i]);</span>
<span class="c">	printk(&quot;        dataptr:%#x%x datacnt:%#x sgptr:%#x tag:%#x\n&quot;,</span>
<span class="c">	       (uint32_t)((ahd_le64toh(hscb-&gt;dataptr) &gt;&gt; 32) &amp; 0xFFFFFFFF),</span>
<span class="c">	       (uint32_t)(ahd_le64toh(hscb-&gt;dataptr) &amp; 0xFFFFFFFF),</span>
<span class="c">	       ahd_le32toh(hscb-&gt;datacnt),</span>
<span class="c">	       ahd_le32toh(hscb-&gt;sgptr),</span>
<span class="c">	       SCB_GET_TAG(scb));</span>
<span class="c">	ahd_dump_sglist(scb);</span>
<span class="c">}</span>
<span class="cp">#endif  /*  0  */</span>

<span class="cm">/************************* Transfer Negotiation *******************************/</span>
<span class="cm">/*</span>
<span class="cm"> * Allocate per target mode instance (ID we respond to as a target)</span>
<span class="cm"> * transfer negotiation data structures.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">ahd_tmode_tstate</span> <span class="o">*</span>
<span class="nf">ahd_alloc_tstate</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">scsi_id</span><span class="p">,</span> <span class="kt">char</span> <span class="n">channel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ahd_tmode_tstate</span> <span class="o">*</span><span class="n">master_tstate</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ahd_tmode_tstate</span> <span class="o">*</span><span class="n">tstate</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">master_tstate</span> <span class="o">=</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">enabled_targets</span><span class="p">[</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">our_id</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">enabled_targets</span><span class="p">[</span><span class="n">scsi_id</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span>
	 <span class="o">&amp;&amp;</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">enabled_targets</span><span class="p">[</span><span class="n">scsi_id</span><span class="p">]</span> <span class="o">!=</span> <span class="n">master_tstate</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;%s: ahd_alloc_tstate - Target already allocated&quot;</span><span class="p">,</span>
		      <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">));</span>
	<span class="n">tstate</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">tstate</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tstate</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we have allocated a master tstate, copy user settings from</span>
<span class="cm">	 * the master tstate (taken from SRAM or the EEPROM) for this</span>
<span class="cm">	 * channel, but reset our current and goal settings to async/narrow</span>
<span class="cm">	 * until an initiator talks to us.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">master_tstate</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">tstate</span><span class="p">,</span> <span class="n">master_tstate</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">tstate</span><span class="p">));</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">tstate</span><span class="o">-&gt;</span><span class="n">enabled_luns</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tstate</span><span class="o">-&gt;</span><span class="n">enabled_luns</span><span class="p">));</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tstate</span><span class="o">-&gt;</span><span class="n">transinfo</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">curr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			      <span class="k">sizeof</span><span class="p">(</span><span class="n">tstate</span><span class="o">-&gt;</span><span class="n">transinfo</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">curr</span><span class="p">));</span>
			<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tstate</span><span class="o">-&gt;</span><span class="n">transinfo</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">goal</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			      <span class="k">sizeof</span><span class="p">(</span><span class="n">tstate</span><span class="o">-&gt;</span><span class="n">transinfo</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">goal</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">tstate</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">tstate</span><span class="p">));</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">enabled_targets</span><span class="p">[</span><span class="n">scsi_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">tstate</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">tstate</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef AHD_TARGET_MODE</span>
<span class="cm">/*</span>
<span class="cm"> * Free per target mode instance (ID we respond to as a target)</span>
<span class="cm"> * transfer negotiation data structures.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_free_tstate</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">scsi_id</span><span class="p">,</span> <span class="kt">char</span> <span class="n">channel</span><span class="p">,</span> <span class="kt">int</span> <span class="n">force</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ahd_tmode_tstate</span> <span class="o">*</span><span class="n">tstate</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Don&#39;t clean up our &quot;master&quot; tstate.</span>
<span class="cm">	 * It has our default user settings.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">scsi_id</span> <span class="o">==</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">our_id</span>
	 <span class="o">&amp;&amp;</span> <span class="n">force</span> <span class="o">==</span> <span class="n">FALSE</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">tstate</span> <span class="o">=</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">enabled_targets</span><span class="p">[</span><span class="n">scsi_id</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tstate</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">tstate</span><span class="p">);</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">enabled_targets</span><span class="p">[</span><span class="n">scsi_id</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Called when we have an active connection to a target on the bus,</span>
<span class="cm"> * this function finds the nearest period to the input period limited</span>
<span class="cm"> * by the capabilities of the bus connectivity of and sync settings for</span>
<span class="cm"> * the target.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_devlimited_syncrate</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">ahd_initiator_tinfo</span> <span class="o">*</span><span class="n">tinfo</span><span class="p">,</span>
			<span class="n">u_int</span> <span class="o">*</span><span class="n">period</span><span class="p">,</span> <span class="n">u_int</span> <span class="o">*</span><span class="n">ppr_options</span><span class="p">,</span> <span class="n">role_t</span> <span class="n">role</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span>	<span class="n">ahd_transinfo</span> <span class="o">*</span><span class="n">transinfo</span><span class="p">;</span>
	<span class="n">u_int</span>	<span class="n">maxsync</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SBLKCTL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">ENAB40</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>
	 <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SSTAT2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">EXP_ACTIVE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">maxsync</span> <span class="o">=</span> <span class="n">AHD_SYNCRATE_PACED</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">maxsync</span> <span class="o">=</span> <span class="n">AHD_SYNCRATE_ULTRA</span><span class="p">;</span>
		<span class="cm">/* Can&#39;t do DT related options on an SE bus */</span>
		<span class="o">*</span><span class="n">ppr_options</span> <span class="o">&amp;=</span> <span class="n">MSG_EXT_PPR_QAS_REQ</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Never allow a value higher than our current goal</span>
<span class="cm">	 * period otherwise we may allow a target initiated</span>
<span class="cm">	 * negotiation to go above the limit as set by the</span>
<span class="cm">	 * user.  In the case of an initiator initiated</span>
<span class="cm">	 * sync negotiation, we limit based on the user</span>
<span class="cm">	 * setting.  This allows the system to still accept</span>
<span class="cm">	 * incoming negotiations even if target initiated</span>
<span class="cm">	 * negotiation is not performed.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">role</span> <span class="o">==</span> <span class="n">ROLE_TARGET</span><span class="p">)</span>
		<span class="n">transinfo</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">user</span><span class="p">;</span>
	<span class="k">else</span> 
		<span class="n">transinfo</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">goal</span><span class="p">;</span>
	<span class="o">*</span><span class="n">ppr_options</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">transinfo</span><span class="o">-&gt;</span><span class="n">ppr_options</span><span class="o">|</span><span class="n">MSG_EXT_PPR_PCOMP_EN</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">transinfo</span><span class="o">-&gt;</span><span class="n">width</span> <span class="o">==</span> <span class="n">MSG_EXT_WDTR_BUS_8_BIT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">maxsync</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">maxsync</span><span class="p">,</span> <span class="p">(</span><span class="n">u_int</span><span class="p">)</span><span class="n">AHD_SYNCRATE_ULTRA2</span><span class="p">);</span>
		<span class="o">*</span><span class="n">ppr_options</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MSG_EXT_PPR_DT_REQ</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">transinfo</span><span class="o">-&gt;</span><span class="n">period</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">period</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="o">*</span><span class="n">ppr_options</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">period</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="o">*</span><span class="n">period</span><span class="p">,</span> <span class="p">(</span><span class="n">u_int</span><span class="p">)</span><span class="n">transinfo</span><span class="o">-&gt;</span><span class="n">period</span><span class="p">);</span>
		<span class="n">ahd_find_syncrate</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">period</span><span class="p">,</span> <span class="n">ppr_options</span><span class="p">,</span> <span class="n">maxsync</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Look up the valid period to SCSIRATE conversion in our table.</span>
<span class="cm"> * Return the period and offset that should be sent to the target</span>
<span class="cm"> * if this was the beginning of an SDTR.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">ahd_find_syncrate</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="n">u_int</span> <span class="o">*</span><span class="n">period</span><span class="p">,</span>
		  <span class="n">u_int</span> <span class="o">*</span><span class="n">ppr_options</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">maxsync</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">period</span> <span class="o">&lt;</span> <span class="n">maxsync</span><span class="p">)</span>
		<span class="o">*</span><span class="n">period</span> <span class="o">=</span> <span class="n">maxsync</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">ppr_options</span> <span class="o">&amp;</span> <span class="n">MSG_EXT_PPR_DT_REQ</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>
	 <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">period</span> <span class="o">&gt;</span> <span class="n">AHD_SYNCRATE_MIN_DT</span><span class="p">)</span>
		<span class="o">*</span><span class="n">ppr_options</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MSG_EXT_PPR_DT_REQ</span><span class="p">;</span>
		
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">period</span> <span class="o">&gt;</span> <span class="n">AHD_SYNCRATE_MIN</span><span class="p">)</span>
		<span class="o">*</span><span class="n">period</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Honor PPR option conformance rules. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">period</span> <span class="o">&gt;</span> <span class="n">AHD_SYNCRATE_PACED</span><span class="p">)</span>
		<span class="o">*</span><span class="n">ppr_options</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MSG_EXT_PPR_RTI</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">ppr_options</span> <span class="o">&amp;</span> <span class="n">MSG_EXT_PPR_IU_REQ</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="o">*</span><span class="n">ppr_options</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">MSG_EXT_PPR_DT_REQ</span><span class="o">|</span><span class="n">MSG_EXT_PPR_QAS_REQ</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">ppr_options</span> <span class="o">&amp;</span> <span class="n">MSG_EXT_PPR_DT_REQ</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="o">*</span><span class="n">ppr_options</span> <span class="o">&amp;=</span> <span class="n">MSG_EXT_PPR_QAS_REQ</span><span class="p">;</span>

	<span class="cm">/* Skip all PACED only entries if IU is not available */</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">ppr_options</span> <span class="o">&amp;</span> <span class="n">MSG_EXT_PPR_IU_REQ</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
	 <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">period</span> <span class="o">&lt;</span> <span class="n">AHD_SYNCRATE_DT</span><span class="p">)</span>
		<span class="o">*</span><span class="n">period</span> <span class="o">=</span> <span class="n">AHD_SYNCRATE_DT</span><span class="p">;</span>

	<span class="cm">/* Skip all DT only entries if DT is not available */</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">ppr_options</span> <span class="o">&amp;</span> <span class="n">MSG_EXT_PPR_DT_REQ</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
	 <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">period</span> <span class="o">&lt;</span> <span class="n">AHD_SYNCRATE_ULTRA2</span><span class="p">)</span>
		<span class="o">*</span><span class="n">period</span> <span class="o">=</span> <span class="n">AHD_SYNCRATE_ULTRA2</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Truncate the given synchronous offset to a value the</span>
<span class="cm"> * current adapter type and syncrate are capable of.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_validate_offset</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">ahd_initiator_tinfo</span> <span class="o">*</span><span class="n">tinfo</span><span class="p">,</span>
		    <span class="n">u_int</span> <span class="n">period</span><span class="p">,</span> <span class="n">u_int</span> <span class="o">*</span><span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wide</span><span class="p">,</span>
		    <span class="n">role_t</span> <span class="n">role</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u_int</span> <span class="n">maxoffset</span><span class="p">;</span>

	<span class="cm">/* Limit offset to what we can do */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">period</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">maxoffset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">period</span> <span class="o">&lt;=</span> <span class="n">AHD_SYNCRATE_PACED</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">bugs</span> <span class="o">&amp;</span> <span class="n">AHD_PACED_NEGTABLE_BUG</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">maxoffset</span> <span class="o">=</span> <span class="n">MAX_OFFSET_PACED_BUG</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">maxoffset</span> <span class="o">=</span> <span class="n">MAX_OFFSET_PACED</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">maxoffset</span> <span class="o">=</span> <span class="n">MAX_OFFSET_NON_PACED</span><span class="p">;</span>
	<span class="o">*</span><span class="n">offset</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="o">*</span><span class="n">offset</span><span class="p">,</span> <span class="n">maxoffset</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tinfo</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">role</span> <span class="o">==</span> <span class="n">ROLE_TARGET</span><span class="p">)</span>
			<span class="o">*</span><span class="n">offset</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="o">*</span><span class="n">offset</span><span class="p">,</span> <span class="p">(</span><span class="n">u_int</span><span class="p">)</span><span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">user</span><span class="p">.</span><span class="n">offset</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="o">*</span><span class="n">offset</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="o">*</span><span class="n">offset</span><span class="p">,</span> <span class="p">(</span><span class="n">u_int</span><span class="p">)</span><span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">goal</span><span class="p">.</span><span class="n">offset</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Truncate the given transfer width parameter to a value the</span>
<span class="cm"> * current adapter type is capable of.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_validate_width</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ahd_initiator_tinfo</span> <span class="o">*</span><span class="n">tinfo</span><span class="p">,</span>
		   <span class="n">u_int</span> <span class="o">*</span><span class="n">bus_width</span><span class="p">,</span> <span class="n">role_t</span> <span class="n">role</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="o">*</span><span class="n">bus_width</span><span class="p">)</span> <span class="p">{</span>
	<span class="nl">default:</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">AHD_WIDE</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Respond Wide */</span>
			<span class="o">*</span><span class="n">bus_width</span> <span class="o">=</span> <span class="n">MSG_EXT_WDTR_BUS_16_BIT</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* FALLTHROUGH */</span>
	<span class="k">case</span> <span class="n">MSG_EXT_WDTR_BUS_8_BIT</span>:
		<span class="o">*</span><span class="n">bus_width</span> <span class="o">=</span> <span class="n">MSG_EXT_WDTR_BUS_8_BIT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tinfo</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">role</span> <span class="o">==</span> <span class="n">ROLE_TARGET</span><span class="p">)</span>
			<span class="o">*</span><span class="n">bus_width</span> <span class="o">=</span> <span class="n">min</span><span class="p">((</span><span class="n">u_int</span><span class="p">)</span><span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">user</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="o">*</span><span class="n">bus_width</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="o">*</span><span class="n">bus_width</span> <span class="o">=</span> <span class="n">min</span><span class="p">((</span><span class="n">u_int</span><span class="p">)</span><span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">goal</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="o">*</span><span class="n">bus_width</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Update the bitmask of targets for which the controller should</span>
<span class="cm"> * negotiate with at the next convenient opportunity.  This currently</span>
<span class="cm"> * means the next time we send the initial identify messages for</span>
<span class="cm"> * a new transaction.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">ahd_update_neg_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ahd_devinfo</span> <span class="o">*</span><span class="n">devinfo</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">ahd_tmode_tstate</span> <span class="o">*</span><span class="n">tstate</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">ahd_initiator_tinfo</span> <span class="o">*</span><span class="n">tinfo</span><span class="p">,</span> <span class="n">ahd_neg_type</span> <span class="n">neg_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u_int</span> <span class="n">auto_negotiate_orig</span><span class="p">;</span>

	<span class="n">auto_negotiate_orig</span> <span class="o">=</span> <span class="n">tstate</span><span class="o">-&gt;</span><span class="n">auto_negotiate</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">neg_type</span> <span class="o">==</span> <span class="n">AHD_NEG_ALWAYS</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Force our &quot;current&quot; settings to be</span>
<span class="cm">		 * unknown so that unless a bus reset</span>
<span class="cm">		 * occurs the need to renegotiate is</span>
<span class="cm">		 * recorded persistently.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">AHD_WIDE</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">.</span><span class="n">width</span> <span class="o">=</span> <span class="n">AHD_WIDTH_UNKNOWN</span><span class="p">;</span>
		<span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">.</span><span class="n">period</span> <span class="o">=</span> <span class="n">AHD_PERIOD_UNKNOWN</span><span class="p">;</span>
		<span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">AHD_OFFSET_UNKNOWN</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">.</span><span class="n">period</span> <span class="o">!=</span> <span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">goal</span><span class="p">.</span><span class="n">period</span>
	 <span class="o">||</span> <span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">.</span><span class="n">width</span> <span class="o">!=</span> <span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">goal</span><span class="p">.</span><span class="n">width</span>
	 <span class="o">||</span> <span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">.</span><span class="n">offset</span> <span class="o">!=</span> <span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">goal</span><span class="p">.</span><span class="n">offset</span>
	 <span class="o">||</span> <span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">.</span><span class="n">ppr_options</span> <span class="o">!=</span> <span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">goal</span><span class="p">.</span><span class="n">ppr_options</span>
	 <span class="o">||</span> <span class="p">(</span><span class="n">neg_type</span> <span class="o">==</span> <span class="n">AHD_NEG_IF_NON_ASYNC</span>
	  <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">goal</span><span class="p">.</span><span class="n">offset</span> <span class="o">!=</span> <span class="mi">0</span>
	   <span class="o">||</span> <span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">goal</span><span class="p">.</span><span class="n">width</span> <span class="o">!=</span> <span class="n">MSG_EXT_WDTR_BUS_8_BIT</span>
	   <span class="o">||</span> <span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">goal</span><span class="p">.</span><span class="n">ppr_options</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)))</span>
		<span class="n">tstate</span><span class="o">-&gt;</span><span class="n">auto_negotiate</span> <span class="o">|=</span> <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">target_mask</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">tstate</span><span class="o">-&gt;</span><span class="n">auto_negotiate</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">target_mask</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">auto_negotiate_orig</span> <span class="o">!=</span> <span class="n">tstate</span><span class="o">-&gt;</span><span class="n">auto_negotiate</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Update the user/goal/curr tables of synchronous negotiation</span>
<span class="cm"> * parameters as well as, in the case of a current or active update,</span>
<span class="cm"> * any data structures on the host controller.  In the case of an</span>
<span class="cm"> * active update, the specified target is currently talking to us on</span>
<span class="cm"> * the bus, so the transfer parameter update must take effect</span>
<span class="cm"> * immediately.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">ahd_set_syncrate</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ahd_devinfo</span> <span class="o">*</span><span class="n">devinfo</span><span class="p">,</span>
		 <span class="n">u_int</span> <span class="n">period</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">ppr_options</span><span class="p">,</span>
		 <span class="n">u_int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">paused</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span>	<span class="n">ahd_initiator_tinfo</span> <span class="o">*</span><span class="n">tinfo</span><span class="p">;</span>
	<span class="k">struct</span>	<span class="n">ahd_tmode_tstate</span> <span class="o">*</span><span class="n">tstate</span><span class="p">;</span>
	<span class="n">u_int</span>	<span class="n">old_period</span><span class="p">;</span>
	<span class="n">u_int</span>	<span class="n">old_offset</span><span class="p">;</span>
	<span class="n">u_int</span>	<span class="n">old_ppr</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">active</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">update_needed</span><span class="p">;</span>

	<span class="n">active</span> <span class="o">=</span> <span class="p">(</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">AHD_TRANS_ACTIVE</span><span class="p">)</span> <span class="o">==</span> <span class="n">AHD_TRANS_ACTIVE</span><span class="p">;</span>
	<span class="n">update_needed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">period</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">offset</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">period</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tinfo</span> <span class="o">=</span> <span class="n">ahd_fetch_transinfo</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span> <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">our_scsiid</span><span class="p">,</span>
				    <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tstate</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">AHD_TRANS_USER</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">user</span><span class="p">.</span><span class="n">period</span> <span class="o">=</span> <span class="n">period</span><span class="p">;</span>
		<span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">user</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
		<span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">user</span><span class="p">.</span><span class="n">ppr_options</span> <span class="o">=</span> <span class="n">ppr_options</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">AHD_TRANS_GOAL</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">goal</span><span class="p">.</span><span class="n">period</span> <span class="o">=</span> <span class="n">period</span><span class="p">;</span>
		<span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">goal</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
		<span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">goal</span><span class="p">.</span><span class="n">ppr_options</span> <span class="o">=</span> <span class="n">ppr_options</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">old_period</span> <span class="o">=</span> <span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">.</span><span class="n">period</span><span class="p">;</span>
	<span class="n">old_offset</span> <span class="o">=</span> <span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">.</span><span class="n">offset</span><span class="p">;</span>
	<span class="n">old_ppr</span>	   <span class="o">=</span> <span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">.</span><span class="n">ppr_options</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">AHD_TRANS_CUR</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>
	 <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">old_period</span> <span class="o">!=</span> <span class="n">period</span>
	  <span class="o">||</span> <span class="n">old_offset</span> <span class="o">!=</span> <span class="n">offset</span>
	  <span class="o">||</span> <span class="n">old_ppr</span> <span class="o">!=</span> <span class="n">ppr_options</span><span class="p">))</span> <span class="p">{</span>

		<span class="n">update_needed</span><span class="o">++</span><span class="p">;</span>

		<span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">.</span><span class="n">period</span> <span class="o">=</span> <span class="n">period</span><span class="p">;</span>
		<span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
		<span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">.</span><span class="n">ppr_options</span> <span class="o">=</span> <span class="n">ppr_options</span><span class="p">;</span>

		<span class="n">ahd_send_async</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span> <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">,</span>
			       <span class="n">CAM_LUN_WILDCARD</span><span class="p">,</span> <span class="n">AC_TRANSFER_NEG</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bootverbose</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="kt">int</span> <span class="n">options</span><span class="p">;</span>

				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: target %d synchronous with &quot;</span>
				       <span class="s">&quot;period = 0x%x, offset = 0x%x&quot;</span><span class="p">,</span>
				       <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">),</span> <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">,</span>
				       <span class="n">period</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
				<span class="n">options</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">ppr_options</span> <span class="o">&amp;</span> <span class="n">MSG_EXT_PPR_RD_STRM</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">printk</span><span class="p">(</span><span class="s">&quot;(RDSTRM&quot;</span><span class="p">);</span>
					<span class="n">options</span><span class="o">++</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">ppr_options</span> <span class="o">&amp;</span> <span class="n">MSG_EXT_PPR_DT_REQ</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">options</span> <span class="o">?</span> <span class="s">&quot;|DT&quot;</span> <span class="o">:</span> <span class="s">&quot;(DT&quot;</span><span class="p">);</span>
					<span class="n">options</span><span class="o">++</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">ppr_options</span> <span class="o">&amp;</span> <span class="n">MSG_EXT_PPR_IU_REQ</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">options</span> <span class="o">?</span> <span class="s">&quot;|IU&quot;</span> <span class="o">:</span> <span class="s">&quot;(IU&quot;</span><span class="p">);</span>
					<span class="n">options</span><span class="o">++</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">ppr_options</span> <span class="o">&amp;</span> <span class="n">MSG_EXT_PPR_RTI</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">options</span> <span class="o">?</span> <span class="s">&quot;|RTI&quot;</span> <span class="o">:</span> <span class="s">&quot;(RTI&quot;</span><span class="p">);</span>
					<span class="n">options</span><span class="o">++</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">ppr_options</span> <span class="o">&amp;</span> <span class="n">MSG_EXT_PPR_QAS_REQ</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">options</span> <span class="o">?</span> <span class="s">&quot;|QAS&quot;</span> <span class="o">:</span> <span class="s">&quot;(QAS&quot;</span><span class="p">);</span>
					<span class="n">options</span><span class="o">++</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">options</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
					<span class="n">printk</span><span class="p">(</span><span class="s">&quot;)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">else</span>
					<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: target %d using &quot;</span>
				       <span class="s">&quot;asynchronous transfers%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">),</span> <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">,</span>
				       <span class="p">(</span><span class="n">ppr_options</span> <span class="o">&amp;</span> <span class="n">MSG_EXT_PPR_QAS_REQ</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>
				     <span class="o">?</span>  <span class="s">&quot;(QAS)&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Always refresh the neg-table to handle the case of the</span>
<span class="cm">	 * sequencer setting the ENATNO bit for a MK_MESSAGE request.</span>
<span class="cm">	 * We will always renegotiate in that case if this is a</span>
<span class="cm">	 * packetized request.  Also manage the busfree expected flag</span>
<span class="cm">	 * from this common routine so that we catch changes due to</span>
<span class="cm">	 * WDTR or SDTR messages.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">AHD_TRANS_CUR</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">paused</span><span class="p">)</span>
			<span class="n">ahd_pause</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
		<span class="n">ahd_update_neg_table</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">devinfo</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">paused</span><span class="p">)</span>
			<span class="n">ahd_unpause</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msg_type</span> <span class="o">!=</span> <span class="n">MSG_TYPE_NONE</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">old_ppr</span> <span class="o">&amp;</span> <span class="n">MSG_EXT_PPR_IU_REQ</span><span class="p">)</span>
			 <span class="o">!=</span> <span class="p">(</span><span class="n">ppr_options</span> <span class="o">&amp;</span> <span class="n">MSG_EXT_PPR_IU_REQ</span><span class="p">))</span> <span class="p">{</span>
<span class="cp">#ifdef AHD_DEBUG</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">ahd_debug</span> <span class="o">&amp;</span> <span class="n">AHD_SHOW_MESSAGES</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">ahd_print_devinfo</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">devinfo</span><span class="p">);</span>
					<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Expecting IU Change busfree</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="p">}</span>
<span class="cp">#endif</span>
				<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msg_flags</span> <span class="o">|=</span> <span class="n">MSG_FLAG_EXPECT_PPR_BUSFREE</span>
					       <span class="o">|</span>  <span class="n">MSG_FLAG_IU_REQ_CHANGED</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">old_ppr</span> <span class="o">&amp;</span> <span class="n">MSG_EXT_PPR_IU_REQ</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef AHD_DEBUG</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">ahd_debug</span> <span class="o">&amp;</span> <span class="n">AHD_SHOW_MESSAGES</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
					<span class="n">printk</span><span class="p">(</span><span class="s">&quot;PPR with IU_REQ outstanding</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
				<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msg_flags</span> <span class="o">|=</span> <span class="n">MSG_FLAG_EXPECT_PPR_BUSFREE</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">update_needed</span> <span class="o">+=</span> <span class="n">ahd_update_neg_request</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">devinfo</span><span class="p">,</span> <span class="n">tstate</span><span class="p">,</span>
						<span class="n">tinfo</span><span class="p">,</span> <span class="n">AHD_NEG_TO_GOAL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">update_needed</span> <span class="o">&amp;&amp;</span> <span class="n">active</span><span class="p">)</span>
		<span class="n">ahd_update_pending_scbs</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Update the user/goal/curr tables of wide negotiation</span>
<span class="cm"> * parameters as well as, in the case of a current or active update,</span>
<span class="cm"> * any data structures on the host controller.  In the case of an</span>
<span class="cm"> * active update, the specified target is currently talking to us on</span>
<span class="cm"> * the bus, so the transfer parameter update must take effect</span>
<span class="cm"> * immediately.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">ahd_set_width</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ahd_devinfo</span> <span class="o">*</span><span class="n">devinfo</span><span class="p">,</span>
	      <span class="n">u_int</span> <span class="n">width</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">paused</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span>	<span class="n">ahd_initiator_tinfo</span> <span class="o">*</span><span class="n">tinfo</span><span class="p">;</span>
	<span class="k">struct</span>	<span class="n">ahd_tmode_tstate</span> <span class="o">*</span><span class="n">tstate</span><span class="p">;</span>
	<span class="n">u_int</span>	<span class="n">oldwidth</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">active</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">update_needed</span><span class="p">;</span>

	<span class="n">active</span> <span class="o">=</span> <span class="p">(</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">AHD_TRANS_ACTIVE</span><span class="p">)</span> <span class="o">==</span> <span class="n">AHD_TRANS_ACTIVE</span><span class="p">;</span>
	<span class="n">update_needed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tinfo</span> <span class="o">=</span> <span class="n">ahd_fetch_transinfo</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span> <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">our_scsiid</span><span class="p">,</span>
				    <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tstate</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">AHD_TRANS_USER</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">user</span><span class="p">.</span><span class="n">width</span> <span class="o">=</span> <span class="n">width</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">AHD_TRANS_GOAL</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">goal</span><span class="p">.</span><span class="n">width</span> <span class="o">=</span> <span class="n">width</span><span class="p">;</span>

	<span class="n">oldwidth</span> <span class="o">=</span> <span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">.</span><span class="n">width</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">AHD_TRANS_CUR</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">oldwidth</span> <span class="o">!=</span> <span class="n">width</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">update_needed</span><span class="o">++</span><span class="p">;</span>

		<span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">.</span><span class="n">width</span> <span class="o">=</span> <span class="n">width</span><span class="p">;</span>
		<span class="n">ahd_send_async</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span> <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">,</span>
			       <span class="n">CAM_LUN_WILDCARD</span><span class="p">,</span> <span class="n">AC_TRANSFER_NEG</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bootverbose</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: target %d using %dbit transfers</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">),</span> <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">,</span>
			       <span class="mi">8</span> <span class="o">*</span> <span class="p">(</span><span class="mh">0x01</span> <span class="o">&lt;&lt;</span> <span class="n">width</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">AHD_TRANS_CUR</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">paused</span><span class="p">)</span>
			<span class="n">ahd_pause</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
		<span class="n">ahd_update_neg_table</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">devinfo</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">paused</span><span class="p">)</span>
			<span class="n">ahd_unpause</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">update_needed</span> <span class="o">+=</span> <span class="n">ahd_update_neg_request</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">devinfo</span><span class="p">,</span> <span class="n">tstate</span><span class="p">,</span>
						<span class="n">tinfo</span><span class="p">,</span> <span class="n">AHD_NEG_TO_GOAL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">update_needed</span> <span class="o">&amp;&amp;</span> <span class="n">active</span><span class="p">)</span>
		<span class="n">ahd_update_pending_scbs</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Update the current state of tagged queuing for a given target.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_set_tags</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span>
	     <span class="k">struct</span> <span class="n">ahd_devinfo</span> <span class="o">*</span><span class="n">devinfo</span><span class="p">,</span> <span class="n">ahd_queue_alg</span> <span class="n">alg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">;</span>

	<span class="n">ahd_platform_set_tags</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">sdev</span><span class="p">,</span> <span class="n">devinfo</span><span class="p">,</span> <span class="n">alg</span><span class="p">);</span>
	<span class="n">ahd_send_async</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span> <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">,</span>
		       <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">,</span> <span class="n">AC_TRANSFER_NEG</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_update_neg_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ahd_devinfo</span> <span class="o">*</span><span class="n">devinfo</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">ahd_transinfo</span> <span class="o">*</span><span class="n">tinfo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ahd_mode_state</span>	<span class="n">saved_modes</span><span class="p">;</span>
	<span class="n">u_int</span>		<span class="n">period</span><span class="p">;</span>
	<span class="n">u_int</span>		<span class="n">ppr_opts</span><span class="p">;</span>
	<span class="n">u_int</span>		<span class="n">con_opts</span><span class="p">;</span>
	<span class="n">u_int</span>		<span class="n">offset</span><span class="p">;</span>
	<span class="n">u_int</span>		<span class="n">saved_negoaddr</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">iocell_opts</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">iocell_opts</span><span class="p">)];</span>

	<span class="n">saved_modes</span> <span class="o">=</span> <span class="n">ahd_save_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
	<span class="n">ahd_set_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI</span><span class="p">);</span>

	<span class="n">saved_negoaddr</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">NEGOADDR</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">NEGOADDR</span><span class="p">,</span> <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">);</span>
	<span class="n">period</span> <span class="o">=</span> <span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">period</span><span class="p">;</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">iocell_opts</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">iocell_opts</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">iocell_opts</span><span class="p">));</span> 
	<span class="n">ppr_opts</span> <span class="o">=</span> <span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">ppr_options</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">MSG_EXT_PPR_QAS_REQ</span><span class="o">|</span><span class="n">MSG_EXT_PPR_DT_REQ</span>
					<span class="o">|</span><span class="n">MSG_EXT_PPR_IU_REQ</span><span class="o">|</span><span class="n">MSG_EXT_PPR_RTI</span><span class="p">);</span>
	<span class="n">con_opts</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">period</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">period</span> <span class="o">=</span> <span class="n">AHD_SYNCRATE_ASYNC</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">period</span> <span class="o">==</span> <span class="n">AHD_SYNCRATE_160</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">bugs</span> <span class="o">&amp;</span> <span class="n">AHD_PACED_NEGTABLE_BUG</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * When the SPI4 spec was finalized, PACE transfers</span>
<span class="cm">			 * was not made a configurable option in the PPR</span>
<span class="cm">			 * message.  Instead it is assumed to be enabled for</span>
<span class="cm">			 * any syncrate faster than 80MHz.  Nevertheless,</span>
<span class="cm">			 * Harpoon2A4 allows this to be configurable.</span>
<span class="cm">			 *</span>
<span class="cm">			 * Harpoon2A4 also assumes at most 2 data bytes per</span>
<span class="cm">			 * negotiated REQ/ACK offset.  Paced transfers take</span>
<span class="cm">			 * 4, so we must adjust our offset.</span>
<span class="cm">			 */</span>
			<span class="n">ppr_opts</span> <span class="o">|=</span> <span class="n">PPROPT_PACE</span><span class="p">;</span>
			<span class="n">offset</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * Harpoon2A assumed that there would be a</span>
<span class="cm">			 * fallback rate between 160MHz and 80MHz,</span>
<span class="cm">			 * so 7 is used as the period factor rather</span>
<span class="cm">			 * than 8 for 160MHz.</span>
<span class="cm">			 */</span>
			<span class="n">period</span> <span class="o">=</span> <span class="n">AHD_SYNCRATE_REVA_160</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">ppr_options</span> <span class="o">&amp;</span> <span class="n">MSG_EXT_PPR_PCOMP_EN</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">iocell_opts</span><span class="p">[</span><span class="n">AHD_PRECOMP_SLEW_INDEX</span><span class="p">]</span> <span class="o">&amp;=</span>
			    <span class="o">~</span><span class="n">AHD_PRECOMP_MASK</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Precomp should be disabled for non-paced transfers.</span>
<span class="cm">		 */</span>
		<span class="n">iocell_opts</span><span class="p">[</span><span class="n">AHD_PRECOMP_SLEW_INDEX</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">AHD_PRECOMP_MASK</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">AHD_NEW_IOCELL_OPTS</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>
		 <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ppr_opts</span> <span class="o">&amp;</span> <span class="n">MSG_EXT_PPR_DT_REQ</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>
		 <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ppr_opts</span> <span class="o">&amp;</span> <span class="n">MSG_EXT_PPR_IU_REQ</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Slow down our CRC interval to be</span>
<span class="cm">			 * compatible with non-packetized</span>
<span class="cm">			 * U160 devices that can&#39;t handle a</span>
<span class="cm">			 * CRC at full speed.</span>
<span class="cm">			 */</span>
			<span class="n">con_opts</span> <span class="o">|=</span> <span class="n">ENSLOWCRC</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">bugs</span> <span class="o">&amp;</span> <span class="n">AHD_PACED_NEGTABLE_BUG</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * On H2A4, revert to a slower slewrate</span>
<span class="cm">			 * on non-paced transfers.</span>
<span class="cm">			 */</span>
			<span class="n">iocell_opts</span><span class="p">[</span><span class="n">AHD_PRECOMP_SLEW_INDEX</span><span class="p">]</span> <span class="o">&amp;=</span>
			    <span class="o">~</span><span class="n">AHD_SLEWRATE_MASK</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">ANNEXCOL</span><span class="p">,</span> <span class="n">AHD_ANNEXCOL_PRECOMP_SLEW</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">ANNEXDAT</span><span class="p">,</span> <span class="n">iocell_opts</span><span class="p">[</span><span class="n">AHD_PRECOMP_SLEW_INDEX</span><span class="p">]);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">ANNEXCOL</span><span class="p">,</span> <span class="n">AHD_ANNEXCOL_AMPLITUDE</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">ANNEXDAT</span><span class="p">,</span> <span class="n">iocell_opts</span><span class="p">[</span><span class="n">AHD_AMPLITUDE_INDEX</span><span class="p">]);</span>

	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">NEGPERIOD</span><span class="p">,</span> <span class="n">period</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">NEGPPROPTS</span><span class="p">,</span> <span class="n">ppr_opts</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">NEGOFFSET</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">width</span> <span class="o">==</span> <span class="n">MSG_EXT_WDTR_BUS_16_BIT</span><span class="p">)</span>
		<span class="n">con_opts</span> <span class="o">|=</span> <span class="n">WIDEXFER</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Slow down our CRC interval to be</span>
<span class="cm">	 * compatible with packetized U320 devices</span>
<span class="cm">	 * that can&#39;t handle a CRC at full speed</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">AHD_AIC79XXB_SLOWCRC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">con_opts</span> <span class="o">|=</span> <span class="n">ENSLOWCRC</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * During packetized transfers, the target will</span>
<span class="cm">	 * give us the opportunity to send command packets</span>
<span class="cm">	 * without us asserting attention.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">ppr_options</span> <span class="o">&amp;</span> <span class="n">MSG_EXT_PPR_IU_REQ</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">con_opts</span> <span class="o">|=</span> <span class="n">ENAUTOATNO</span><span class="p">;</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">NEGCONOPTS</span><span class="p">,</span> <span class="n">con_opts</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">NEGOADDR</span><span class="p">,</span> <span class="n">saved_negoaddr</span><span class="p">);</span>
	<span class="n">ahd_restore_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">saved_modes</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * When the transfer settings for a connection change, setup for</span>
<span class="cm"> * negotiation in pending SCBs to effect the change as quickly as</span>
<span class="cm"> * possible.  We also cancel any negotiations that are scheduled</span>
<span class="cm"> * for inflight SCBs that have not been started yet.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_update_pending_scbs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span>		<span class="n">scb</span> <span class="o">*</span><span class="n">pending_scb</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">pending_scb_count</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">paused</span><span class="p">;</span>
	<span class="n">u_int</span>		<span class="n">saved_scbptr</span><span class="p">;</span>
	<span class="n">ahd_mode_state</span>	<span class="n">saved_modes</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Traverse the pending SCB list and ensure that all of the</span>
<span class="cm">	 * SCBs there have the proper settings.  We can only safely</span>
<span class="cm">	 * clear the negotiation required flag (setting requires the</span>
<span class="cm">	 * execution queue to be modified) and this is only possible</span>
<span class="cm">	 * if we are not already attempting to select out for this</span>
<span class="cm">	 * SCB.  For this reason, all callers only call this routine</span>
<span class="cm">	 * if we are changing the negotiation settings for the currently</span>
<span class="cm">	 * active transaction on the bus.</span>
<span class="cm">	 */</span>
	<span class="n">pending_scb_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">LIST_FOREACH</span><span class="p">(</span><span class="n">pending_scb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">pending_scbs</span><span class="p">,</span> <span class="n">pending_links</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ahd_devinfo</span> <span class="n">devinfo</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">ahd_initiator_tinfo</span> <span class="o">*</span><span class="n">tinfo</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">ahd_tmode_tstate</span> <span class="o">*</span><span class="n">tstate</span><span class="p">;</span>

		<span class="n">ahd_scb_devinfo</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">devinfo</span><span class="p">,</span> <span class="n">pending_scb</span><span class="p">);</span>
		<span class="n">tinfo</span> <span class="o">=</span> <span class="n">ahd_fetch_transinfo</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">devinfo</span><span class="p">.</span><span class="n">channel</span><span class="p">,</span>
					    <span class="n">devinfo</span><span class="p">.</span><span class="n">our_scsiid</span><span class="p">,</span>
					    <span class="n">devinfo</span><span class="p">.</span><span class="n">target</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tstate</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">tstate</span><span class="o">-&gt;</span><span class="n">auto_negotiate</span> <span class="o">&amp;</span> <span class="n">devinfo</span><span class="p">.</span><span class="n">target_mask</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
		 <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">pending_scb</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SCB_AUTO_NEGOTIATE</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pending_scb</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SCB_AUTO_NEGOTIATE</span><span class="p">;</span>
			<span class="n">pending_scb</span><span class="o">-&gt;</span><span class="n">hscb</span><span class="o">-&gt;</span><span class="n">control</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MK_MESSAGE</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ahd_sync_scb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">pending_scb</span><span class="p">,</span>
			     <span class="n">BUS_DMASYNC_PREREAD</span><span class="o">|</span><span class="n">BUS_DMASYNC_PREWRITE</span><span class="p">);</span>
		<span class="n">pending_scb_count</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pending_scb_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ahd_is_paused</span><span class="p">(</span><span class="n">ahd</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">paused</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">paused</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ahd_pause</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Force the sequencer to reinitialize the selection for</span>
<span class="cm">	 * the command at the head of the execution queue if it</span>
<span class="cm">	 * has already been setup.  The negotiation changes may</span>
<span class="cm">	 * effect whether we select-out with ATN.  It is only</span>
<span class="cm">	 * safe to clear ENSELO when the bus is not free and no</span>
<span class="cm">	 * selection is in progres or completed.</span>
<span class="cm">	 */</span>
	<span class="n">saved_modes</span> <span class="o">=</span> <span class="n">ahd_save_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
	<span class="n">ahd_set_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCSISIGI</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">BSYI</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>
	 <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SSTAT0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">SELDO</span><span class="o">|</span><span class="n">SELINGO</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCSISEQ0</span><span class="p">,</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCSISEQ0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">ENSELO</span><span class="p">);</span>
	<span class="n">saved_scbptr</span> <span class="o">=</span> <span class="n">ahd_get_scbptr</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
	<span class="cm">/* Ensure that the hscbs down on the card match the new information */</span>
	<span class="n">LIST_FOREACH</span><span class="p">(</span><span class="n">pending_scb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">pending_scbs</span><span class="p">,</span> <span class="n">pending_links</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u_int</span>	<span class="n">scb_tag</span><span class="p">;</span>
		<span class="n">u_int</span>	<span class="n">control</span><span class="p">;</span>

		<span class="n">scb_tag</span> <span class="o">=</span> <span class="n">SCB_GET_TAG</span><span class="p">(</span><span class="n">pending_scb</span><span class="p">);</span>
		<span class="n">ahd_set_scbptr</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb_tag</span><span class="p">);</span>
		<span class="n">control</span> <span class="o">=</span> <span class="n">ahd_inb_scbram</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_CONTROL</span><span class="p">);</span>
		<span class="n">control</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MK_MESSAGE</span><span class="p">;</span>
		<span class="n">control</span> <span class="o">|=</span> <span class="n">pending_scb</span><span class="o">-&gt;</span><span class="n">hscb</span><span class="o">-&gt;</span><span class="n">control</span> <span class="o">&amp;</span> <span class="n">MK_MESSAGE</span><span class="p">;</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_CONTROL</span><span class="p">,</span> <span class="n">control</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">ahd_set_scbptr</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">saved_scbptr</span><span class="p">);</span>
	<span class="n">ahd_restore_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">saved_modes</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">paused</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ahd_unpause</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**************************** Pathing Information *****************************/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_fetch_devinfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ahd_devinfo</span> <span class="o">*</span><span class="n">devinfo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ahd_mode_state</span>	<span class="n">saved_modes</span><span class="p">;</span>
	<span class="n">u_int</span>		<span class="n">saved_scsiid</span><span class="p">;</span>
	<span class="n">role_t</span>		<span class="n">role</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">our_id</span><span class="p">;</span>

	<span class="n">saved_modes</span> <span class="o">=</span> <span class="n">ahd_save_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
	<span class="n">ahd_set_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SSTAT0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">TARGET</span><span class="p">)</span>
		<span class="n">role</span> <span class="o">=</span> <span class="n">ROLE_TARGET</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">role</span> <span class="o">=</span> <span class="n">ROLE_INITIATOR</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">role</span> <span class="o">==</span> <span class="n">ROLE_TARGET</span>
	 <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SEQ_FLAGS</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">CMDPHASE_PENDING</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* We were selected, so pull our id from TARGIDIN */</span>
		<span class="n">our_id</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">TARGIDIN</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">OID</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">role</span> <span class="o">==</span> <span class="n">ROLE_TARGET</span><span class="p">)</span>
		<span class="n">our_id</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">TOWNID</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">our_id</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">IOWNID</span><span class="p">);</span>

	<span class="n">saved_scsiid</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SAVED_SCSIID</span><span class="p">);</span>
	<span class="n">ahd_compile_devinfo</span><span class="p">(</span><span class="n">devinfo</span><span class="p">,</span>
			    <span class="n">our_id</span><span class="p">,</span>
			    <span class="n">SCSIID_TARGET</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">saved_scsiid</span><span class="p">),</span>
			    <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SAVED_LUN</span><span class="p">),</span>
			    <span class="n">SCSIID_CHANNEL</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">saved_scsiid</span><span class="p">),</span>
			    <span class="n">role</span><span class="p">);</span>
	<span class="n">ahd_restore_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">saved_modes</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">ahd_print_devinfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ahd_devinfo</span> <span class="o">*</span><span class="n">devinfo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s:%c:%d:%d: &quot;</span><span class="p">,</span> <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">),</span> <span class="sc">&#39;A&#39;</span><span class="p">,</span>
	       <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">,</span> <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ahd_phase_table_entry</span><span class="o">*</span>
<span class="nf">ahd_lookup_phase_entry</span><span class="p">(</span><span class="kt">int</span> <span class="n">phase</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ahd_phase_table_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ahd_phase_table_entry</span> <span class="o">*</span><span class="n">last_entry</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * num_phases doesn&#39;t include the default entry which</span>
<span class="cm">	 * will be returned if the phase doesn&#39;t match.</span>
<span class="cm">	 */</span>
	<span class="n">last_entry</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ahd_phase_table</span><span class="p">[</span><span class="n">num_phases</span><span class="p">];</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">entry</span> <span class="o">=</span> <span class="n">ahd_phase_table</span><span class="p">;</span> <span class="n">entry</span> <span class="o">&lt;</span> <span class="n">last_entry</span><span class="p">;</span> <span class="n">entry</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phase</span> <span class="o">==</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">phase</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">entry</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">ahd_compile_devinfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_devinfo</span> <span class="o">*</span><span class="n">devinfo</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">our_id</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">target</span><span class="p">,</span>
		    <span class="n">u_int</span> <span class="n">lun</span><span class="p">,</span> <span class="kt">char</span> <span class="n">channel</span><span class="p">,</span> <span class="n">role_t</span> <span class="n">role</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">our_scsiid</span> <span class="o">=</span> <span class="n">our_id</span><span class="p">;</span>
	<span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">target</span> <span class="o">=</span> <span class="n">target</span><span class="p">;</span>
	<span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">lun</span> <span class="o">=</span> <span class="n">lun</span><span class="p">;</span>
	<span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">target_offset</span> <span class="o">=</span> <span class="n">target</span><span class="p">;</span>
	<span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">channel</span> <span class="o">=</span> <span class="n">channel</span><span class="p">;</span>
	<span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">role</span> <span class="o">=</span> <span class="n">role</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">channel</span> <span class="o">==</span> <span class="sc">&#39;B&#39;</span><span class="p">)</span>
		<span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">target_offset</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">target_mask</span> <span class="o">=</span> <span class="p">(</span><span class="mh">0x01</span> <span class="o">&lt;&lt;</span> <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">target_offset</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_scb_devinfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ahd_devinfo</span> <span class="o">*</span><span class="n">devinfo</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">scb</span> <span class="o">*</span><span class="n">scb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">role_t</span>	<span class="n">role</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">our_id</span><span class="p">;</span>

	<span class="n">our_id</span> <span class="o">=</span> <span class="n">SCSIID_OUR_ID</span><span class="p">(</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">hscb</span><span class="o">-&gt;</span><span class="n">scsiid</span><span class="p">);</span>
	<span class="n">role</span> <span class="o">=</span> <span class="n">ROLE_INITIATOR</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">hscb</span><span class="o">-&gt;</span><span class="n">control</span> <span class="o">&amp;</span> <span class="n">TARGET_SCB</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">role</span> <span class="o">=</span> <span class="n">ROLE_TARGET</span><span class="p">;</span>
	<span class="n">ahd_compile_devinfo</span><span class="p">(</span><span class="n">devinfo</span><span class="p">,</span> <span class="n">our_id</span><span class="p">,</span> <span class="n">SCB_GET_TARGET</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">),</span>
			    <span class="n">SCB_GET_LUN</span><span class="p">(</span><span class="n">scb</span><span class="p">),</span> <span class="n">SCB_GET_CHANNEL</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">),</span> <span class="n">role</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/************************ Message Phase Processing ****************************/</span>
<span class="cm">/*</span>
<span class="cm"> * When an initiator transaction with the MK_MESSAGE flag either reconnects</span>
<span class="cm"> * or enters the initial message out phase, we are interrupted.  Fill our</span>
<span class="cm"> * outgoing message buffer with the appropriate message and beging handing</span>
<span class="cm"> * the message phase(s) manually.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_setup_initiator_msgout</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ahd_devinfo</span> <span class="o">*</span><span class="n">devinfo</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">scb</span> <span class="o">*</span><span class="n">scb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * To facilitate adding multiple messages together,</span>
<span class="cm">	 * each routine should increment the index and len</span>
<span class="cm">	 * variables instead of setting them explicitly.</span>
<span class="cm">	 */</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ahd_currently_packetized</span><span class="p">(</span><span class="n">ahd</span><span class="p">))</span>
		<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msg_flags</span> <span class="o">|=</span> <span class="n">MSG_FLAG_PACKETIZED</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">send_msg_perror</span>
	 <span class="o">&amp;&amp;</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">MSG_OUT</span><span class="p">)</span> <span class="o">==</span> <span class="n">HOST_MSG</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_buf</span><span class="p">[</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_index</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">send_msg_perror</span><span class="p">;</span>
		<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_len</span><span class="o">++</span><span class="p">;</span>
		<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msg_type</span> <span class="o">=</span> <span class="n">MSG_TYPE_INITIATOR_MSGOUT</span><span class="p">;</span>
<span class="cp">#ifdef AHD_DEBUG</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ahd_debug</span> <span class="o">&amp;</span> <span class="n">AHD_SHOW_MESSAGES</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Setting up for Parity Error delivery</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">scb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: WARNING. No pending message for &quot;</span>
		       <span class="s">&quot;I_T msgin.  Issuing NO-OP</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">));</span>
		<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_buf</span><span class="p">[</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_index</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">MSG_NOOP</span><span class="p">;</span>
		<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_len</span><span class="o">++</span><span class="p">;</span>
		<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msg_type</span> <span class="o">=</span> <span class="n">MSG_TYPE_INITIATOR_MSGOUT</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SCB_DEVICE_RESET</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
	 <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SCB_PACKETIZED</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
	 <span class="o">&amp;&amp;</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">MSG_OUT</span><span class="p">)</span> <span class="o">==</span> <span class="n">MSG_IDENTIFYFLAG</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u_int</span> <span class="n">identify_msg</span><span class="p">;</span>

		<span class="n">identify_msg</span> <span class="o">=</span> <span class="n">MSG_IDENTIFYFLAG</span> <span class="o">|</span> <span class="n">SCB_GET_LUN</span><span class="p">(</span><span class="n">scb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">hscb</span><span class="o">-&gt;</span><span class="n">control</span> <span class="o">&amp;</span> <span class="n">DISCENB</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">identify_msg</span> <span class="o">|=</span> <span class="n">MSG_IDENTIFY_DISCFLAG</span><span class="p">;</span>
		<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_buf</span><span class="p">[</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_index</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">identify_msg</span><span class="p">;</span>
		<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_len</span><span class="o">++</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">hscb</span><span class="o">-&gt;</span><span class="n">control</span> <span class="o">&amp;</span> <span class="n">TAG_ENB</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_buf</span><span class="p">[</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_index</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span>
			    <span class="n">scb</span><span class="o">-&gt;</span><span class="n">hscb</span><span class="o">-&gt;</span><span class="n">control</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">TAG_ENB</span><span class="o">|</span><span class="n">SCB_TAG_TYPE</span><span class="p">);</span>
			<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_buf</span><span class="p">[</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_index</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">SCB_GET_TAG</span><span class="p">(</span><span class="n">scb</span><span class="p">);</span>
			<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_len</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SCB_DEVICE_RESET</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_buf</span><span class="p">[</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_index</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">MSG_BUS_DEV_RESET</span><span class="p">;</span>
		<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_len</span><span class="o">++</span><span class="p">;</span>
		<span class="n">ahd_print_path</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Bus Device Reset Message Sent</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Clear our selection hardware in advance of</span>
<span class="cm">		 * the busfree.  We may have an entry in the waiting</span>
<span class="cm">		 * Q for this target, and we don&#39;t want to go about</span>
<span class="cm">		 * selecting while we handle the busfree and blow it</span>
<span class="cm">		 * away.</span>
<span class="cm">		 */</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCSISEQ0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SCB_ABORT</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">hscb</span><span class="o">-&gt;</span><span class="n">control</span> <span class="o">&amp;</span> <span class="n">TAG_ENB</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_buf</span><span class="p">[</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_index</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">MSG_ABORT_TAG</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_buf</span><span class="p">[</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_index</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">MSG_ABORT</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_len</span><span class="o">++</span><span class="p">;</span>
		<span class="n">ahd_print_path</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Abort%s Message Sent</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="p">(</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">hscb</span><span class="o">-&gt;</span><span class="n">control</span> <span class="o">&amp;</span> <span class="n">TAG_ENB</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">?</span> <span class="s">&quot; Tag&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Clear our selection hardware in advance of</span>
<span class="cm">		 * the busfree.  We may have an entry in the waiting</span>
<span class="cm">		 * Q for this target, and we don&#39;t want to go about</span>
<span class="cm">		 * selecting while we handle the busfree and blow it</span>
<span class="cm">		 * away.</span>
<span class="cm">		 */</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCSISEQ0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">SCB_AUTO_NEGOTIATE</span><span class="o">|</span><span class="n">SCB_NEGOTIATE</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ahd_build_transfer_msg</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">devinfo</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Clear our selection hardware in advance of potential</span>
<span class="cm">		 * PPR IU status change busfree.  We may have an entry in</span>
<span class="cm">		 * the waiting Q for this target, and we don&#39;t want to go</span>
<span class="cm">		 * about selecting while we handle the busfree and blow</span>
<span class="cm">		 * it away.</span>
<span class="cm">		 */</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCSISEQ0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;ahd_intr: AWAITING_MSG for an SCB that &quot;</span>
		       <span class="s">&quot;does not have a waiting message</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;SCSIID = %x, target_mask = %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">hscb</span><span class="o">-&gt;</span><span class="n">scsiid</span><span class="p">,</span>
		       <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">target_mask</span><span class="p">);</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;SCB = %d, SCB Control = %x:%x, MSG_OUT = %x &quot;</span>
		      <span class="s">&quot;SCB flags = %x&quot;</span><span class="p">,</span> <span class="n">SCB_GET_TAG</span><span class="p">(</span><span class="n">scb</span><span class="p">),</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">hscb</span><span class="o">-&gt;</span><span class="n">control</span><span class="p">,</span>
		      <span class="n">ahd_inb_scbram</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_CONTROL</span><span class="p">),</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">MSG_OUT</span><span class="p">),</span>
		      <span class="n">scb</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Clear the MK_MESSAGE flag from the SCB so we aren&#39;t</span>
<span class="cm">	 * asked to send this message again.</span>
<span class="cm">	 */</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_CONTROL</span><span class="p">,</span>
		 <span class="n">ahd_inb_scbram</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_CONTROL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">MK_MESSAGE</span><span class="p">);</span>
	<span class="n">scb</span><span class="o">-&gt;</span><span class="n">hscb</span><span class="o">-&gt;</span><span class="n">control</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MK_MESSAGE</span><span class="p">;</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msg_type</span> <span class="o">=</span> <span class="n">MSG_TYPE_INITIATOR_MSGOUT</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Build an appropriate transfer negotiation message for the</span>
<span class="cm"> * currently active target.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_build_transfer_msg</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ahd_devinfo</span> <span class="o">*</span><span class="n">devinfo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * We need to initiate transfer negotiations.</span>
<span class="cm">	 * If our current and goal settings are identical,</span>
<span class="cm">	 * we want to renegotiate due to a check condition.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span>	<span class="n">ahd_initiator_tinfo</span> <span class="o">*</span><span class="n">tinfo</span><span class="p">;</span>
	<span class="k">struct</span>	<span class="n">ahd_tmode_tstate</span> <span class="o">*</span><span class="n">tstate</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">dowide</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">dosync</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">doppr</span><span class="p">;</span>
	<span class="n">u_int</span>	<span class="n">period</span><span class="p">;</span>
	<span class="n">u_int</span>	<span class="n">ppr_options</span><span class="p">;</span>
	<span class="n">u_int</span>	<span class="n">offset</span><span class="p">;</span>

	<span class="n">tinfo</span> <span class="o">=</span> <span class="n">ahd_fetch_transinfo</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span> <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">our_scsiid</span><span class="p">,</span>
				    <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tstate</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Filter our period based on the current connection.</span>
<span class="cm">	 * If we can&#39;t perform DT transfers on this segment (not in LVD</span>
<span class="cm">	 * mode for instance), then our decision to issue a PPR message</span>
<span class="cm">	 * may change.</span>
<span class="cm">	 */</span>
	<span class="n">period</span> <span class="o">=</span> <span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">goal</span><span class="p">.</span><span class="n">period</span><span class="p">;</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">goal</span><span class="p">.</span><span class="n">offset</span><span class="p">;</span>
	<span class="n">ppr_options</span> <span class="o">=</span> <span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">goal</span><span class="p">.</span><span class="n">ppr_options</span><span class="p">;</span>
	<span class="cm">/* Target initiated PPR is not allowed in the SCSI spec */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">role</span> <span class="o">==</span> <span class="n">ROLE_TARGET</span><span class="p">)</span>
		<span class="n">ppr_options</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ahd_devlimited_syncrate</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">tinfo</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">period</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">ppr_options</span><span class="p">,</span> <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">role</span><span class="p">);</span>
	<span class="n">dowide</span> <span class="o">=</span> <span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">.</span><span class="n">width</span> <span class="o">!=</span> <span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">goal</span><span class="p">.</span><span class="n">width</span><span class="p">;</span>
	<span class="n">dosync</span> <span class="o">=</span> <span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">.</span><span class="n">offset</span> <span class="o">!=</span> <span class="n">offset</span> <span class="o">||</span> <span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">.</span><span class="n">period</span> <span class="o">!=</span> <span class="n">period</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Only use PPR if we have options that need it, even if the device</span>
<span class="cm">	 * claims to support it.  There might be an expander in the way</span>
<span class="cm">	 * that doesn&#39;t.</span>
<span class="cm">	 */</span>
	<span class="n">doppr</span> <span class="o">=</span> <span class="n">ppr_options</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dowide</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">dosync</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">doppr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dowide</span> <span class="o">=</span> <span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">goal</span><span class="p">.</span><span class="n">width</span> <span class="o">!=</span> <span class="n">MSG_EXT_WDTR_BUS_8_BIT</span><span class="p">;</span>
		<span class="n">dosync</span> <span class="o">=</span> <span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">goal</span><span class="p">.</span><span class="n">offset</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dowide</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">dosync</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">doppr</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Force async with a WDTR message if we have a wide bus,</span>
<span class="cm">		 * or just issue an SDTR with a 0 offset.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">AHD_WIDE</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">dowide</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">dosync</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">bootverbose</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ahd_print_devinfo</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">devinfo</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Ensuring async</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* Target initiated PPR is not allowed in the SCSI spec */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">role</span> <span class="o">==</span> <span class="n">ROLE_TARGET</span><span class="p">)</span>
		<span class="n">doppr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Both the PPR message and SDTR message require the</span>
<span class="cm">	 * goal syncrate to be limited to what the target device</span>
<span class="cm">	 * is capable of handling (based on whether an LVD-&gt;SE</span>
<span class="cm">	 * expander is on the bus), so combine these two cases.</span>
<span class="cm">	 * Regardless, guarantee that if we are using WDTR and SDTR</span>
<span class="cm">	 * messages that WDTR comes first.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">doppr</span> <span class="o">||</span> <span class="p">(</span><span class="n">dosync</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">dowide</span><span class="p">))</span> <span class="p">{</span>

		<span class="n">offset</span> <span class="o">=</span> <span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">goal</span><span class="p">.</span><span class="n">offset</span><span class="p">;</span>
		<span class="n">ahd_validate_offset</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">tinfo</span><span class="p">,</span> <span class="n">period</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">,</span>
				    <span class="n">doppr</span> <span class="o">?</span> <span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">goal</span><span class="p">.</span><span class="n">width</span>
					  <span class="o">:</span> <span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">.</span><span class="n">width</span><span class="p">,</span>
				    <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">role</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">doppr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ahd_construct_ppr</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">devinfo</span><span class="p">,</span> <span class="n">period</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span>
					  <span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">goal</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">ppr_options</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ahd_construct_sdtr</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">devinfo</span><span class="p">,</span> <span class="n">period</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ahd_construct_wdtr</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">devinfo</span><span class="p">,</span> <span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">goal</span><span class="p">.</span><span class="n">width</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Build a synchronous negotiation message in our message</span>
<span class="cm"> * buffer based on the input parameters.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_construct_sdtr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ahd_devinfo</span> <span class="o">*</span><span class="n">devinfo</span><span class="p">,</span>
		   <span class="n">u_int</span> <span class="n">period</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">period</span> <span class="o">=</span> <span class="n">AHD_ASYNC_XFER_PERIOD</span><span class="p">;</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_index</span> <span class="o">+=</span> <span class="n">spi_populate_sync_msg</span><span class="p">(</span>
			<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_buf</span> <span class="o">+</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_index</span><span class="p">,</span> <span class="n">period</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_len</span> <span class="o">+=</span> <span class="mi">5</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bootverbose</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;(%s:%c:%d:%d): Sending SDTR period %x, offset %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">),</span> <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span> <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">,</span>
		       <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">,</span> <span class="n">period</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Build a wide negotiateion message in our message</span>
<span class="cm"> * buffer based on the input parameters.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_construct_wdtr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ahd_devinfo</span> <span class="o">*</span><span class="n">devinfo</span><span class="p">,</span>
		   <span class="n">u_int</span> <span class="n">bus_width</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_index</span> <span class="o">+=</span> <span class="n">spi_populate_width_msg</span><span class="p">(</span>
			<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_buf</span> <span class="o">+</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_index</span><span class="p">,</span> <span class="n">bus_width</span><span class="p">);</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_len</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bootverbose</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;(%s:%c:%d:%d): Sending WDTR %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">),</span> <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span> <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">,</span>
		       <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">,</span> <span class="n">bus_width</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Build a parallel protocol request message in our message</span>
<span class="cm"> * buffer based on the input parameters.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_construct_ppr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ahd_devinfo</span> <span class="o">*</span><span class="n">devinfo</span><span class="p">,</span>
		  <span class="n">u_int</span> <span class="n">period</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">bus_width</span><span class="p">,</span>
		  <span class="n">u_int</span> <span class="n">ppr_options</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Always request precompensation from</span>
<span class="cm">	 * the other target if we are running</span>
<span class="cm">	 * at paced syncrates.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">period</span> <span class="o">&lt;=</span> <span class="n">AHD_SYNCRATE_PACED</span><span class="p">)</span>
		<span class="n">ppr_options</span> <span class="o">|=</span> <span class="n">MSG_EXT_PPR_PCOMP_EN</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">period</span> <span class="o">=</span> <span class="n">AHD_ASYNC_XFER_PERIOD</span><span class="p">;</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_index</span> <span class="o">+=</span> <span class="n">spi_populate_ppr_msg</span><span class="p">(</span>
			<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_buf</span> <span class="o">+</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_index</span><span class="p">,</span> <span class="n">period</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span>
			<span class="n">bus_width</span><span class="p">,</span> <span class="n">ppr_options</span><span class="p">);</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_len</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bootverbose</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;(%s:%c:%d:%d): Sending PPR bus_width %x, period %x, &quot;</span>
		       <span class="s">&quot;offset %x, ppr_options %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">),</span>
		       <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span> <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">,</span> <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">,</span>
		       <span class="n">bus_width</span><span class="p">,</span> <span class="n">period</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">ppr_options</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Clear any active message state.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_clear_msg_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ahd_mode_state</span> <span class="n">saved_modes</span><span class="p">;</span>

	<span class="n">saved_modes</span> <span class="o">=</span> <span class="n">ahd_save_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
	<span class="n">ahd_set_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI</span><span class="p">);</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">send_msg_perror</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msg_flags</span> <span class="o">=</span> <span class="n">MSG_FLAG_NONE</span><span class="p">;</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgin_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msg_type</span> <span class="o">=</span> <span class="n">MSG_TYPE_NONE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCSISIGO</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">ATNO</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The target didn&#39;t care to respond to our</span>
<span class="cm">		 * message request, so clear ATN.</span>
<span class="cm">		 */</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CLRSINT1</span><span class="p">,</span> <span class="n">CLRATNO</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">MSG_OUT</span><span class="p">,</span> <span class="n">MSG_NOOP</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SEQ_FLAGS2</span><span class="p">,</span>
		 <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SEQ_FLAGS2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">TARGET_MSG_PENDING</span><span class="p">);</span>
	<span class="n">ahd_restore_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">saved_modes</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Manual message loop handler.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_handle_message_phase</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span>	<span class="n">ahd_devinfo</span> <span class="n">devinfo</span><span class="p">;</span>
	<span class="n">u_int</span>	<span class="n">bus_phase</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">end_session</span><span class="p">;</span>

	<span class="n">ahd_fetch_devinfo</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">devinfo</span><span class="p">);</span>
	<span class="n">end_session</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
	<span class="n">bus_phase</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">LASTPHASE</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">LQISTAT2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">LQIPHASE_OUTPKT</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;LQIRETRY for LQIPHASE_OUTPKT</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">LQCTL2</span><span class="p">,</span> <span class="n">LQIRETRY</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">reswitch:</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msg_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">MSG_TYPE_INITIATOR_MSGOUT</span>:
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">lastbyte</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">phasemis</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">msgdone</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_len</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">send_msg_perror</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">panic</span><span class="p">(</span><span class="s">&quot;HOST_MSG_LOOP interrupt with no active message&quot;</span><span class="p">);</span>

<span class="cp">#ifdef AHD_DEBUG</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ahd_debug</span> <span class="o">&amp;</span> <span class="n">AHD_SHOW_MESSAGES</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ahd_print_devinfo</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">devinfo</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;INITIATOR_MSG_OUT&quot;</span><span class="p">);</span>
		<span class="p">}</span>
<span class="cp">#endif</span>
		<span class="n">phasemis</span> <span class="o">=</span> <span class="n">bus_phase</span> <span class="o">!=</span> <span class="n">P_MESGOUT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phasemis</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef AHD_DEBUG</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">ahd_debug</span> <span class="o">&amp;</span> <span class="n">AHD_SHOW_MESSAGES</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot; PHASEMIS %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">ahd_lookup_phase_entry</span><span class="p">(</span><span class="n">bus_phase</span><span class="p">)</span>
							     <span class="o">-&gt;</span><span class="n">phasemsg</span><span class="p">);</span>
			<span class="p">}</span>
<span class="cp">#endif</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bus_phase</span> <span class="o">==</span> <span class="n">P_MESGIN</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Change gears and see if</span>
<span class="cm">				 * this messages is of interest to</span>
<span class="cm">				 * us or should be passed back to</span>
<span class="cm">				 * the sequencer.</span>
<span class="cm">				 */</span>
				<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CLRSINT1</span><span class="p">,</span> <span class="n">CLRATNO</span><span class="p">);</span>
				<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">send_msg_perror</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msg_type</span> <span class="o">=</span> <span class="n">MSG_TYPE_INITIATOR_MSGIN</span><span class="p">;</span>
				<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgin_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">reswitch</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">end_session</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">send_msg_perror</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CLRSINT1</span><span class="p">,</span> <span class="n">CLRATNO</span><span class="p">);</span>
			<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CLRSINT1</span><span class="p">,</span> <span class="n">CLRREQINIT</span><span class="p">);</span>
<span class="cp">#ifdef AHD_DEBUG</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">ahd_debug</span> <span class="o">&amp;</span> <span class="n">AHD_SHOW_MESSAGES</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot; byte 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">send_msg_perror</span><span class="p">);</span>
<span class="cp">#endif</span>
			<span class="cm">/*</span>
<span class="cm">			 * If we are notifying the target of a CRC error</span>
<span class="cm">			 * during packetized operations, the target is</span>
<span class="cm">			 * within its rights to acknowledge our message</span>
<span class="cm">			 * with a busfree.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msg_flags</span> <span class="o">&amp;</span> <span class="n">MSG_FLAG_PACKETIZED</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>
			 <span class="o">&amp;&amp;</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">send_msg_perror</span> <span class="o">==</span> <span class="n">MSG_INITIATOR_DET_ERR</span><span class="p">)</span>
				<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msg_flags</span> <span class="o">|=</span> <span class="n">MSG_FLAG_EXPECT_IDE_BUSFREE</span><span class="p">;</span>

			<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">RETURN_2</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">send_msg_perror</span><span class="p">);</span>
			<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">RETURN_1</span><span class="p">,</span> <span class="n">CONT_MSG_LOOP_WRITE</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">msgdone</span>	<span class="o">=</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_index</span> <span class="o">==</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_len</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">msgdone</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * The target has requested a retry.</span>
<span class="cm">			 * Re-assert ATN, reset our message index to</span>
<span class="cm">			 * 0, and try again.</span>
<span class="cm">			 */</span>
			<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">ahd_assert_atn</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">lastbyte</span> <span class="o">=</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_index</span> <span class="o">==</span> <span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lastbyte</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Last byte is signified by dropping ATN */</span>
			<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CLRSINT1</span><span class="p">,</span> <span class="n">CLRATNO</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Clear our interrupt status and present</span>
<span class="cm">		 * the next byte on the bus.</span>
<span class="cm">		 */</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CLRSINT1</span><span class="p">,</span> <span class="n">CLRREQINIT</span><span class="p">);</span>
<span class="cp">#ifdef AHD_DEBUG</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ahd_debug</span> <span class="o">&amp;</span> <span class="n">AHD_SHOW_MESSAGES</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot; byte 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_buf</span><span class="p">[</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_index</span><span class="p">]);</span>
<span class="cp">#endif</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">RETURN_2</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_buf</span><span class="p">[</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_index</span><span class="o">++</span><span class="p">]);</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">RETURN_1</span><span class="p">,</span> <span class="n">CONT_MSG_LOOP_WRITE</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">MSG_TYPE_INITIATOR_MSGIN</span>:
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">phasemis</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">message_done</span><span class="p">;</span>

<span class="cp">#ifdef AHD_DEBUG</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ahd_debug</span> <span class="o">&amp;</span> <span class="n">AHD_SHOW_MESSAGES</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ahd_print_devinfo</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">devinfo</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;INITIATOR_MSG_IN&quot;</span><span class="p">);</span>
		<span class="p">}</span>
<span class="cp">#endif</span>
		<span class="n">phasemis</span> <span class="o">=</span> <span class="n">bus_phase</span> <span class="o">!=</span> <span class="n">P_MESGIN</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phasemis</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef AHD_DEBUG</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">ahd_debug</span> <span class="o">&amp;</span> <span class="n">AHD_SHOW_MESSAGES</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot; PHASEMIS %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">ahd_lookup_phase_entry</span><span class="p">(</span><span class="n">bus_phase</span><span class="p">)</span>
							     <span class="o">-&gt;</span><span class="n">phasemsg</span><span class="p">);</span>
			<span class="p">}</span>
<span class="cp">#endif</span>
			<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgin_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bus_phase</span> <span class="o">==</span> <span class="n">P_MESGOUT</span>
			 <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">send_msg_perror</span> <span class="o">!=</span> <span class="mi">0</span>
			  <span class="o">||</span> <span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_len</span> <span class="o">!=</span> <span class="mi">0</span>
			   <span class="o">&amp;&amp;</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msg_type</span> <span class="o">=</span> <span class="n">MSG_TYPE_INITIATOR_MSGOUT</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">reswitch</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">end_session</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Pull the byte in without acking it */</span>
		<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgin_buf</span><span class="p">[</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgin_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCSIBUS</span><span class="p">);</span>
<span class="cp">#ifdef AHD_DEBUG</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ahd_debug</span> <span class="o">&amp;</span> <span class="n">AHD_SHOW_MESSAGES</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot; byte 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgin_buf</span><span class="p">[</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgin_index</span><span class="p">]);</span>
<span class="cp">#endif</span>

		<span class="n">message_done</span> <span class="o">=</span> <span class="n">ahd_parse_msg</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">devinfo</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">message_done</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Clear our incoming message buffer in case there</span>
<span class="cm">			 * is another message following this one.</span>
<span class="cm">			 */</span>
			<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgin_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * If this message illicited a response,</span>
<span class="cm">			 * assert ATN so the target takes us to the</span>
<span class="cm">			 * message out phase.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_len</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef AHD_DEBUG</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">ahd_debug</span> <span class="o">&amp;</span> <span class="n">AHD_SHOW_MESSAGES</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">ahd_print_devinfo</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">devinfo</span><span class="p">);</span>
					<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Asserting ATN for response</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="p">}</span>
<span class="cp">#endif</span>
				<span class="n">ahd_assert_atn</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> 
			<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgin_index</span><span class="o">++</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">message_done</span> <span class="o">==</span> <span class="n">MSGLOOP_TERMINATED</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">end_session</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Ack the byte */</span>
			<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CLRSINT1</span><span class="p">,</span> <span class="n">CLRREQINIT</span><span class="p">);</span>
			<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">RETURN_1</span><span class="p">,</span> <span class="n">CONT_MSG_LOOP_READ</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">MSG_TYPE_TARGET_MSGIN</span>:
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">msgdone</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">msgout_request</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * By default, the message loop will continue.</span>
<span class="cm">		 */</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">RETURN_1</span><span class="p">,</span> <span class="n">CONT_MSG_LOOP_TARG</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Target MSGIN with no active message&quot;</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * If we interrupted a mesgout session, the initiator</span>
<span class="cm">		 * will not know this until our first REQ.  So, we</span>
<span class="cm">		 * only honor mesgout requests after we&#39;ve sent our</span>
<span class="cm">		 * first byte.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCSISIGI</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">ATNI</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>
		 <span class="o">&amp;&amp;</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_index</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">msgout_request</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">msgout_request</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">msgout_request</span><span class="p">)</span> <span class="p">{</span>

			<span class="cm">/*</span>
<span class="cm">			 * Change gears and see if</span>
<span class="cm">			 * this messages is of interest to</span>
<span class="cm">			 * us or should be passed back to</span>
<span class="cm">			 * the sequencer.</span>
<span class="cm">			 */</span>
			<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msg_type</span> <span class="o">=</span> <span class="n">MSG_TYPE_TARGET_MSGOUT</span><span class="p">;</span>
			<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCSISIGO</span><span class="p">,</span> <span class="n">P_MESGOUT</span> <span class="o">|</span> <span class="n">BSYO</span><span class="p">);</span>
			<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgin_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="cm">/* Dummy read to REQ for first byte */</span>
			<span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCSIDAT</span><span class="p">);</span>
			<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SXFRCTL0</span><span class="p">,</span>
				 <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SXFRCTL0</span><span class="p">)</span> <span class="o">|</span> <span class="n">SPIOEN</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">msgdone</span> <span class="o">=</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_index</span> <span class="o">==</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_len</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">msgdone</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SXFRCTL0</span><span class="p">,</span>
				 <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SXFRCTL0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">SPIOEN</span><span class="p">);</span>
			<span class="n">end_session</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Present the next byte on the bus.</span>
<span class="cm">		 */</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SXFRCTL0</span><span class="p">,</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SXFRCTL0</span><span class="p">)</span> <span class="o">|</span> <span class="n">SPIOEN</span><span class="p">);</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCSIDAT</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_buf</span><span class="p">[</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_index</span><span class="o">++</span><span class="p">]);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">MSG_TYPE_TARGET_MSGOUT</span>:
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">lastbyte</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">msgdone</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * By default, the message loop will continue.</span>
<span class="cm">		 */</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">RETURN_1</span><span class="p">,</span> <span class="n">CONT_MSG_LOOP_TARG</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * The initiator signals that this is</span>
<span class="cm">		 * the last byte by dropping ATN.</span>
<span class="cm">		 */</span>
		<span class="n">lastbyte</span> <span class="o">=</span> <span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCSISIGI</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">ATNI</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Read the latched byte, but turn off SPIOEN first</span>
<span class="cm">		 * so that we don&#39;t inadvertently cause a REQ for the</span>
<span class="cm">		 * next byte.</span>
<span class="cm">		 */</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SXFRCTL0</span><span class="p">,</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SXFRCTL0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">SPIOEN</span><span class="p">);</span>
		<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgin_buf</span><span class="p">[</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgin_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCSIDAT</span><span class="p">);</span>
		<span class="n">msgdone</span> <span class="o">=</span> <span class="n">ahd_parse_msg</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">devinfo</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">msgdone</span> <span class="o">==</span> <span class="n">MSGLOOP_TERMINATED</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * The message is *really* done in that it caused</span>
<span class="cm">			 * us to go to bus free.  The sequencer has already</span>
<span class="cm">			 * been reset at this point, so pull the ejection</span>
<span class="cm">			 * handle.</span>
<span class="cm">			 */</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		
		<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgin_index</span><span class="o">++</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * XXX Read spec about initiator dropping ATN too soon</span>
<span class="cm">		 *     and use msgdone to detect it.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">msgdone</span> <span class="o">==</span> <span class="n">MSGLOOP_MSGCOMPLETE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgin_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * If this message illicited a response, transition</span>
<span class="cm">			 * to the Message in phase and send it.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_len</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCSISIGO</span><span class="p">,</span> <span class="n">P_MESGIN</span> <span class="o">|</span> <span class="n">BSYO</span><span class="p">);</span>
				<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SXFRCTL0</span><span class="p">,</span>
					 <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SXFRCTL0</span><span class="p">)</span> <span class="o">|</span> <span class="n">SPIOEN</span><span class="p">);</span>
				<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msg_type</span> <span class="o">=</span> <span class="n">MSG_TYPE_TARGET_MSGIN</span><span class="p">;</span>
				<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgin_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">lastbyte</span><span class="p">)</span>
			<span class="n">end_session</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Ask for the next byte. */</span>
			<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SXFRCTL0</span><span class="p">,</span>
				 <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SXFRCTL0</span><span class="p">)</span> <span class="o">|</span> <span class="n">SPIOEN</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="nl">default:</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Unknown REQINIT message type&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">end_session</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msg_flags</span> <span class="o">&amp;</span> <span class="n">MSG_FLAG_PACKETIZED</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: Returning to Idle Loop</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">));</span>
			<span class="n">ahd_clear_msg_state</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * Perform the equivalent of a clear_target_state.</span>
<span class="cm">			 */</span>
			<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">LASTPHASE</span><span class="p">,</span> <span class="n">P_BUSFREE</span><span class="p">);</span>
			<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SEQ_FLAGS</span><span class="p">,</span> <span class="n">NOT_IDENTIFIED</span><span class="o">|</span><span class="n">NO_CDB_SENT</span><span class="p">);</span>
			<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SEQCTL0</span><span class="p">,</span> <span class="n">FASTMODE</span><span class="o">|</span><span class="n">SEQRESET</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ahd_clear_msg_state</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
			<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">RETURN_1</span><span class="p">,</span> <span class="n">EXIT_MSG_LOOP</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * See if we sent a particular extended message to the target.</span>
<span class="cm"> * If &quot;full&quot; is true, return true only if the target saw the full</span>
<span class="cm"> * message.  If &quot;full&quot; is false, return true if the target saw at</span>
<span class="cm"> * least the first byte of the message.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ahd_sent_msg</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="n">ahd_msgtype</span> <span class="n">type</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">msgval</span><span class="p">,</span> <span class="kt">int</span> <span class="n">full</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">found</span><span class="p">;</span>
	<span class="n">u_int</span> <span class="n">index</span><span class="p">;</span>

	<span class="n">found</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
	<span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_len</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_buf</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">==</span> <span class="n">MSG_EXTENDED</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u_int</span> <span class="n">end_index</span><span class="p">;</span>

			<span class="n">end_index</span> <span class="o">=</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_buf</span><span class="p">[</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_buf</span><span class="p">[</span><span class="n">index</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">msgval</span>
			 <span class="o">&amp;&amp;</span> <span class="n">type</span> <span class="o">==</span> <span class="n">AHDMSG_EXT</span><span class="p">)</span> <span class="p">{</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">full</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_index</span> <span class="o">&gt;</span> <span class="n">end_index</span><span class="p">)</span>
						<span class="n">found</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_index</span> <span class="o">&gt;</span> <span class="n">index</span><span class="p">)</span>
					<span class="n">found</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">index</span> <span class="o">=</span> <span class="n">end_index</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_buf</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">MSG_SIMPLE_TASK</span>
			<span class="o">&amp;&amp;</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_buf</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">MSG_IGN_WIDE_RESIDUE</span><span class="p">)</span> <span class="p">{</span>

			<span class="cm">/* Skip tag type and tag id or residue param*/</span>
			<span class="n">index</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Single byte message */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">AHDMSG_1B</span>
			 <span class="o">&amp;&amp;</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_index</span> <span class="o">&gt;</span> <span class="n">index</span>
			 <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_buf</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">==</span> <span class="n">msgval</span>
			  <span class="o">||</span> <span class="p">((</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_buf</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">MSG_IDENTIFYFLAG</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>
			   <span class="o">&amp;&amp;</span> <span class="n">msgval</span> <span class="o">==</span> <span class="n">MSG_IDENTIFYFLAG</span><span class="p">)))</span>
				<span class="n">found</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
			<span class="n">index</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">found</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">found</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Wait for a complete incoming message, parse it, and respond accordingly.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ahd_parse_msg</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ahd_devinfo</span> <span class="o">*</span><span class="n">devinfo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span>	<span class="n">ahd_initiator_tinfo</span> <span class="o">*</span><span class="n">tinfo</span><span class="p">;</span>
	<span class="k">struct</span>	<span class="n">ahd_tmode_tstate</span> <span class="o">*</span><span class="n">tstate</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">reject</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">done</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">response</span><span class="p">;</span>

	<span class="n">done</span> <span class="o">=</span> <span class="n">MSGLOOP_IN_PROG</span><span class="p">;</span>
	<span class="n">response</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
	<span class="n">reject</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
	<span class="n">tinfo</span> <span class="o">=</span> <span class="n">ahd_fetch_transinfo</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span> <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">our_scsiid</span><span class="p">,</span>
				    <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tstate</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Parse as much of the message as is available,</span>
<span class="cm">	 * rejecting it if we don&#39;t support it.  When</span>
<span class="cm">	 * the entire message is available and has been</span>
<span class="cm">	 * handled, return MSGLOOP_MSGCOMPLETE, indicating</span>
<span class="cm">	 * that we have parsed an entire message.</span>
<span class="cm">	 *</span>
<span class="cm">	 * In the case of extended messages, we accept the length</span>
<span class="cm">	 * byte outright and perform more checking once we know the</span>
<span class="cm">	 * extended message type.</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgin_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">MSG_DISCONNECT</span>:
	<span class="k">case</span> <span class="n">MSG_SAVEDATAPOINTER</span>:
	<span class="k">case</span> <span class="n">MSG_CMDCOMPLETE</span>:
	<span class="k">case</span> <span class="n">MSG_RESTOREPOINTERS</span>:
	<span class="k">case</span> <span class="n">MSG_IGN_WIDE_RESIDUE</span>:
		<span class="cm">/*</span>
<span class="cm">		 * End our message loop as these are messages</span>
<span class="cm">		 * the sequencer handles on its own.</span>
<span class="cm">		 */</span>
		<span class="n">done</span> <span class="o">=</span> <span class="n">MSGLOOP_TERMINATED</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MSG_MESSAGE_REJECT</span>:
		<span class="n">response</span> <span class="o">=</span> <span class="n">ahd_handle_msg_reject</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">devinfo</span><span class="p">);</span>
		<span class="cm">/* FALLTHROUGH */</span>
	<span class="k">case</span> <span class="n">MSG_NOOP</span>:
		<span class="n">done</span> <span class="o">=</span> <span class="n">MSGLOOP_MSGCOMPLETE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MSG_EXTENDED</span>:
	<span class="p">{</span>
		<span class="cm">/* Wait for enough of the message to begin validation */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgin_index</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgin_buf</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">MSG_EXT_SDTR</span>:
		<span class="p">{</span>
			<span class="n">u_int</span>	 <span class="n">period</span><span class="p">;</span>
			<span class="n">u_int</span>	 <span class="n">ppr_options</span><span class="p">;</span>
			<span class="n">u_int</span>	 <span class="n">offset</span><span class="p">;</span>
			<span class="n">u_int</span>	 <span class="n">saved_offset</span><span class="p">;</span>
			
			<span class="k">if</span> <span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgin_buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">MSG_EXT_SDTR_LEN</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">reject</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * Wait until we have both args before validating</span>
<span class="cm">			 * and acting on this message.</span>
<span class="cm">			 *</span>
<span class="cm">			 * Add one to MSG_EXT_SDTR_LEN to account for</span>
<span class="cm">			 * the extended message preamble.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgin_index</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">MSG_EXT_SDTR_LEN</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="n">period</span> <span class="o">=</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgin_buf</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
			<span class="n">ppr_options</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">saved_offset</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgin_buf</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
			<span class="n">ahd_devlimited_syncrate</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">tinfo</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">period</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">ppr_options</span><span class="p">,</span> <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">role</span><span class="p">);</span>
			<span class="n">ahd_validate_offset</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">tinfo</span><span class="p">,</span> <span class="n">period</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">,</span>
					    <span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">role</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bootverbose</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;(%s:%c:%d:%d): Received &quot;</span>
				       <span class="s">&quot;SDTR period %x, offset %x</span><span class="se">\n\t</span><span class="s">&quot;</span>
				       <span class="s">&quot;Filtered to period %x, offset %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">),</span> <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span>
				       <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">,</span> <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">,</span>
				       <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgin_buf</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">saved_offset</span><span class="p">,</span>
				       <span class="n">period</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">ahd_set_syncrate</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">devinfo</span><span class="p">,</span> <span class="n">period</span><span class="p">,</span>
					 <span class="n">offset</span><span class="p">,</span> <span class="n">ppr_options</span><span class="p">,</span>
					 <span class="n">AHD_TRANS_ACTIVE</span><span class="o">|</span><span class="n">AHD_TRANS_GOAL</span><span class="p">,</span>
					 <span class="cm">/*paused*/</span><span class="n">TRUE</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * See if we initiated Sync Negotiation</span>
<span class="cm">			 * and didn&#39;t have to fall down to async</span>
<span class="cm">			 * transfers.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ahd_sent_msg</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHDMSG_EXT</span><span class="p">,</span> <span class="n">MSG_EXT_SDTR</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* We started it */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">saved_offset</span> <span class="o">!=</span> <span class="n">offset</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* Went too low - force async */</span>
					<span class="n">reject</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Send our own SDTR in reply</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">bootverbose</span>
				 <span class="o">&amp;&amp;</span> <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">role</span> <span class="o">==</span> <span class="n">ROLE_INITIATOR</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">printk</span><span class="p">(</span><span class="s">&quot;(%s:%c:%d:%d): Target &quot;</span>
					       <span class="s">&quot;Initiated SDTR</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					       <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">),</span> <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span>
					       <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">,</span> <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">ahd_construct_sdtr</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">devinfo</span><span class="p">,</span>
						   <span class="n">period</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
				<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">response</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">done</span> <span class="o">=</span> <span class="n">MSGLOOP_MSGCOMPLETE</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">case</span> <span class="n">MSG_EXT_WDTR</span>:
		<span class="p">{</span>
			<span class="n">u_int</span> <span class="n">bus_width</span><span class="p">;</span>
			<span class="n">u_int</span> <span class="n">saved_width</span><span class="p">;</span>
			<span class="n">u_int</span> <span class="n">sending_reply</span><span class="p">;</span>

			<span class="n">sending_reply</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgin_buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">MSG_EXT_WDTR_LEN</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">reject</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * Wait until we have our arg before validating</span>
<span class="cm">			 * and acting on this message.</span>
<span class="cm">			 *</span>
<span class="cm">			 * Add one to MSG_EXT_WDTR_LEN to account for</span>
<span class="cm">			 * the extended message preamble.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgin_index</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">MSG_EXT_WDTR_LEN</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="n">bus_width</span> <span class="o">=</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgin_buf</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
			<span class="n">saved_width</span> <span class="o">=</span> <span class="n">bus_width</span><span class="p">;</span>
			<span class="n">ahd_validate_width</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">tinfo</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bus_width</span><span class="p">,</span>
					   <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">role</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bootverbose</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;(%s:%c:%d:%d): Received WDTR &quot;</span>
				       <span class="s">&quot;%x filtered to %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">),</span> <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span>
				       <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">,</span> <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">,</span>
				       <span class="n">saved_width</span><span class="p">,</span> <span class="n">bus_width</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">ahd_sent_msg</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHDMSG_EXT</span><span class="p">,</span> <span class="n">MSG_EXT_WDTR</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Don&#39;t send a WDTR back to the</span>
<span class="cm">				 * target, since we asked first.</span>
<span class="cm">				 * If the width went higher than our</span>
<span class="cm">				 * request, reject it.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">saved_width</span> <span class="o">&gt;</span> <span class="n">bus_width</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">reject</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
					<span class="n">printk</span><span class="p">(</span><span class="s">&quot;(%s:%c:%d:%d): requested %dBit &quot;</span>
					       <span class="s">&quot;transfers.  Rejecting...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					       <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">),</span> <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span>
					       <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">,</span> <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">,</span>
					       <span class="mi">8</span> <span class="o">*</span> <span class="p">(</span><span class="mh">0x01</span> <span class="o">&lt;&lt;</span> <span class="n">bus_width</span><span class="p">));</span>
					<span class="n">bus_width</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Send our own WDTR in reply</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">bootverbose</span>
				 <span class="o">&amp;&amp;</span> <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">role</span> <span class="o">==</span> <span class="n">ROLE_INITIATOR</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">printk</span><span class="p">(</span><span class="s">&quot;(%s:%c:%d:%d): Target &quot;</span>
					       <span class="s">&quot;Initiated WDTR</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					       <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">),</span> <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span>
					       <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">,</span> <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">ahd_construct_wdtr</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">devinfo</span><span class="p">,</span> <span class="n">bus_width</span><span class="p">);</span>
				<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">response</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
				<span class="n">sending_reply</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/*</span>
<span class="cm">			 * After a wide message, we are async, but</span>
<span class="cm">			 * some devices don&#39;t seem to honor this portion</span>
<span class="cm">			 * of the spec.  Force a renegotiation of the</span>
<span class="cm">			 * sync component of our transfer agreement even</span>
<span class="cm">			 * if our goal is async.  By updating our width</span>
<span class="cm">			 * after forcing the negotiation, we avoid</span>
<span class="cm">			 * renegotiating for width.</span>
<span class="cm">			 */</span>
			<span class="n">ahd_update_neg_request</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">devinfo</span><span class="p">,</span> <span class="n">tstate</span><span class="p">,</span>
					       <span class="n">tinfo</span><span class="p">,</span> <span class="n">AHD_NEG_ALWAYS</span><span class="p">);</span>
			<span class="n">ahd_set_width</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">devinfo</span><span class="p">,</span> <span class="n">bus_width</span><span class="p">,</span>
				      <span class="n">AHD_TRANS_ACTIVE</span><span class="o">|</span><span class="n">AHD_TRANS_GOAL</span><span class="p">,</span>
				      <span class="cm">/*paused*/</span><span class="n">TRUE</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sending_reply</span> <span class="o">==</span> <span class="n">FALSE</span> <span class="o">&amp;&amp;</span> <span class="n">reject</span> <span class="o">==</span> <span class="n">FALSE</span><span class="p">)</span> <span class="p">{</span>

				<span class="cm">/*</span>
<span class="cm">				 * We will always have an SDTR to send.</span>
<span class="cm">				 */</span>
				<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">ahd_build_transfer_msg</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">devinfo</span><span class="p">);</span>
				<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">response</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">done</span> <span class="o">=</span> <span class="n">MSGLOOP_MSGCOMPLETE</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">case</span> <span class="n">MSG_EXT_PPR</span>:
		<span class="p">{</span>
			<span class="n">u_int</span>	<span class="n">period</span><span class="p">;</span>
			<span class="n">u_int</span>	<span class="n">offset</span><span class="p">;</span>
			<span class="n">u_int</span>	<span class="n">bus_width</span><span class="p">;</span>
			<span class="n">u_int</span>	<span class="n">ppr_options</span><span class="p">;</span>
			<span class="n">u_int</span>	<span class="n">saved_width</span><span class="p">;</span>
			<span class="n">u_int</span>	<span class="n">saved_offset</span><span class="p">;</span>
			<span class="n">u_int</span>	<span class="n">saved_ppr_options</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgin_buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">MSG_EXT_PPR_LEN</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">reject</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * Wait until we have all args before validating</span>
<span class="cm">			 * and acting on this message.</span>
<span class="cm">			 *</span>
<span class="cm">			 * Add one to MSG_EXT_PPR_LEN to account for</span>
<span class="cm">			 * the extended message preamble.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgin_index</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">MSG_EXT_PPR_LEN</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="n">period</span> <span class="o">=</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgin_buf</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
			<span class="n">offset</span> <span class="o">=</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgin_buf</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
			<span class="n">bus_width</span> <span class="o">=</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgin_buf</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
			<span class="n">saved_width</span> <span class="o">=</span> <span class="n">bus_width</span><span class="p">;</span>
			<span class="n">ppr_options</span> <span class="o">=</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgin_buf</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span>
			<span class="cm">/*</span>
<span class="cm">			 * According to the spec, a DT only</span>
<span class="cm">			 * period factor with no DT option</span>
<span class="cm">			 * set implies async.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">ppr_options</span> <span class="o">&amp;</span> <span class="n">MSG_EXT_PPR_DT_REQ</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
			 <span class="o">&amp;&amp;</span> <span class="n">period</span> <span class="o">&lt;=</span> <span class="mi">9</span><span class="p">)</span>
				<span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">saved_ppr_options</span> <span class="o">=</span> <span class="n">ppr_options</span><span class="p">;</span>
			<span class="n">saved_offset</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * Transfer options are only available if we</span>
<span class="cm">			 * are negotiating wide.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bus_width</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">ppr_options</span> <span class="o">&amp;=</span> <span class="n">MSG_EXT_PPR_QAS_REQ</span><span class="p">;</span>

			<span class="n">ahd_validate_width</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">tinfo</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bus_width</span><span class="p">,</span>
					   <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">role</span><span class="p">);</span>
			<span class="n">ahd_devlimited_syncrate</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">tinfo</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">period</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">ppr_options</span><span class="p">,</span> <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">role</span><span class="p">);</span>
			<span class="n">ahd_validate_offset</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">tinfo</span><span class="p">,</span> <span class="n">period</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">,</span>
					    <span class="n">bus_width</span><span class="p">,</span> <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">role</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">ahd_sent_msg</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHDMSG_EXT</span><span class="p">,</span> <span class="n">MSG_EXT_PPR</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * If we are unable to do any of the</span>
<span class="cm">				 * requested options (we went too low),</span>
<span class="cm">				 * then we&#39;ll have to reject the message.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">saved_width</span> <span class="o">&gt;</span> <span class="n">bus_width</span>
				 <span class="o">||</span> <span class="n">saved_offset</span> <span class="o">!=</span> <span class="n">offset</span>
				 <span class="o">||</span> <span class="n">saved_ppr_options</span> <span class="o">!=</span> <span class="n">ppr_options</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">reject</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
					<span class="n">period</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="n">bus_width</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="n">ppr_options</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">role</span> <span class="o">!=</span> <span class="n">ROLE_TARGET</span><span class="p">)</span>
					<span class="n">printk</span><span class="p">(</span><span class="s">&quot;(%s:%c:%d:%d): Target &quot;</span>
					       <span class="s">&quot;Initiated PPR</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					       <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">),</span> <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span>
					       <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">,</span> <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>
				<span class="k">else</span>
					<span class="n">printk</span><span class="p">(</span><span class="s">&quot;(%s:%c:%d:%d): Initiator &quot;</span>
					       <span class="s">&quot;Initiated PPR</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					       <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">),</span> <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span>
					       <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">,</span> <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>
				<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">ahd_construct_ppr</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">devinfo</span><span class="p">,</span> <span class="n">period</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span>
						  <span class="n">bus_width</span><span class="p">,</span> <span class="n">ppr_options</span><span class="p">);</span>
				<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">response</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bootverbose</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;(%s:%c:%d:%d): Received PPR width %x, &quot;</span>
				       <span class="s">&quot;period %x, offset %x,options %x</span><span class="se">\n</span><span class="s">&quot;</span>
				       <span class="s">&quot;</span><span class="se">\t</span><span class="s">Filtered to width %x, period %x, &quot;</span>
				       <span class="s">&quot;offset %x, options %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">),</span> <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span>
				       <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">,</span> <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">,</span>
				       <span class="n">saved_width</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgin_buf</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
				       <span class="n">saved_offset</span><span class="p">,</span> <span class="n">saved_ppr_options</span><span class="p">,</span>
				       <span class="n">bus_width</span><span class="p">,</span> <span class="n">period</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">ppr_options</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">ahd_set_width</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">devinfo</span><span class="p">,</span> <span class="n">bus_width</span><span class="p">,</span>
				      <span class="n">AHD_TRANS_ACTIVE</span><span class="o">|</span><span class="n">AHD_TRANS_GOAL</span><span class="p">,</span>
				      <span class="cm">/*paused*/</span><span class="n">TRUE</span><span class="p">);</span>
			<span class="n">ahd_set_syncrate</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">devinfo</span><span class="p">,</span> <span class="n">period</span><span class="p">,</span>
					 <span class="n">offset</span><span class="p">,</span> <span class="n">ppr_options</span><span class="p">,</span>
					 <span class="n">AHD_TRANS_ACTIVE</span><span class="o">|</span><span class="n">AHD_TRANS_GOAL</span><span class="p">,</span>
					 <span class="cm">/*paused*/</span><span class="n">TRUE</span><span class="p">);</span>

			<span class="n">done</span> <span class="o">=</span> <span class="n">MSGLOOP_MSGCOMPLETE</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="nl">default:</span>
			<span class="cm">/* Unknown extended message.  Reject it. */</span>
			<span class="n">reject</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#ifdef AHD_TARGET_MODE</span>
	<span class="k">case</span> <span class="n">MSG_BUS_DEV_RESET</span>:
		<span class="n">ahd_handle_devreset</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">devinfo</span><span class="p">,</span> <span class="n">CAM_LUN_WILDCARD</span><span class="p">,</span>
				    <span class="n">CAM_BDR_SENT</span><span class="p">,</span>
				    <span class="s">&quot;Bus Device Reset Received&quot;</span><span class="p">,</span>
				    <span class="cm">/*verbose_level*/</span><span class="mi">0</span><span class="p">);</span>
		<span class="n">ahd_restart</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
		<span class="n">done</span> <span class="o">=</span> <span class="n">MSGLOOP_TERMINATED</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MSG_ABORT_TAG</span>:
	<span class="k">case</span> <span class="n">MSG_ABORT</span>:
	<span class="k">case</span> <span class="n">MSG_CLEAR_QUEUE</span>:
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">tag</span><span class="p">;</span>

		<span class="cm">/* Target mode messages */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">role</span> <span class="o">!=</span> <span class="n">ROLE_TARGET</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">reject</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">tag</span> <span class="o">=</span> <span class="n">SCB_LIST_NULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgin_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">MSG_ABORT_TAG</span><span class="p">)</span>
			<span class="n">tag</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">INITIATOR_TAG</span><span class="p">);</span>
		<span class="n">ahd_abort_scbs</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">,</span> <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span>
			       <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="n">ROLE_TARGET</span><span class="p">,</span>
			       <span class="n">CAM_REQ_ABORTED</span><span class="p">);</span>

		<span class="n">tstate</span> <span class="o">=</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">enabled_targets</span><span class="p">[</span><span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">our_scsiid</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tstate</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">ahd_tmode_lstate</span><span class="o">*</span> <span class="n">lstate</span><span class="p">;</span>

			<span class="n">lstate</span> <span class="o">=</span> <span class="n">tstate</span><span class="o">-&gt;</span><span class="n">enabled_luns</span><span class="p">[</span><span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lstate</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ahd_queue_lstate_event</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">lstate</span><span class="p">,</span>
						       <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">our_scsiid</span><span class="p">,</span>
						       <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgin_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
						       <span class="cm">/*arg*/</span><span class="n">tag</span><span class="p">);</span>
				<span class="n">ahd_send_lstate_events</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">lstate</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">ahd_restart</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
		<span class="n">done</span> <span class="o">=</span> <span class="n">MSGLOOP_TERMINATED</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="k">case</span> <span class="n">MSG_QAS_REQUEST</span>:
<span class="cp">#ifdef AHD_DEBUG</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ahd_debug</span> <span class="o">&amp;</span> <span class="n">AHD_SHOW_MESSAGES</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: QAS request.  SCSISIGI == 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">),</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCSISIGI</span><span class="p">));</span>
<span class="cp">#endif</span>
		<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msg_flags</span> <span class="o">|=</span> <span class="n">MSG_FLAG_EXPECT_QASREJ_BUSFREE</span><span class="p">;</span>
		<span class="cm">/* FALLTHROUGH */</span>
	<span class="k">case</span> <span class="n">MSG_TERM_IO_PROC</span>:
	<span class="nl">default:</span>
		<span class="n">reject</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">reject</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Setup to reject the message.</span>
<span class="cm">		 */</span>
		<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_len</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">MSG_MESSAGE_REJECT</span><span class="p">;</span>
		<span class="n">done</span> <span class="o">=</span> <span class="n">MSGLOOP_MSGCOMPLETE</span><span class="p">;</span>
		<span class="n">response</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">done</span> <span class="o">!=</span> <span class="n">MSGLOOP_IN_PROG</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">response</span><span class="p">)</span>
		<span class="cm">/* Clear the outgoing message buffer */</span>
		<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">done</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Process a message reject message.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ahd_handle_msg_reject</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ahd_devinfo</span> <span class="o">*</span><span class="n">devinfo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * What we care about here is if we had an</span>
<span class="cm">	 * outstanding SDTR or WDTR message for this</span>
<span class="cm">	 * target.  If we did, this is a signal that</span>
<span class="cm">	 * the target is refusing negotiation.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">scb</span> <span class="o">*</span><span class="n">scb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ahd_initiator_tinfo</span> <span class="o">*</span><span class="n">tinfo</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ahd_tmode_tstate</span> <span class="o">*</span><span class="n">tstate</span><span class="p">;</span>
	<span class="n">u_int</span> <span class="n">scb_index</span><span class="p">;</span>
	<span class="n">u_int</span> <span class="n">last_msg</span><span class="p">;</span>
	<span class="kt">int</span>   <span class="n">response</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">scb_index</span> <span class="o">=</span> <span class="n">ahd_get_scbptr</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
	<span class="n">scb</span> <span class="o">=</span> <span class="n">ahd_lookup_scb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb_index</span><span class="p">);</span>
	<span class="n">tinfo</span> <span class="o">=</span> <span class="n">ahd_fetch_transinfo</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span>
				    <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">our_scsiid</span><span class="p">,</span>
				    <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tstate</span><span class="p">);</span>
	<span class="cm">/* Might be necessary */</span>
	<span class="n">last_msg</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">LAST_MSG</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ahd_sent_msg</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHDMSG_EXT</span><span class="p">,</span> <span class="n">MSG_EXT_PPR</span><span class="p">,</span> <span class="cm">/*full*/</span><span class="n">FALSE</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ahd_sent_msg</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHDMSG_EXT</span><span class="p">,</span> <span class="n">MSG_EXT_PPR</span><span class="p">,</span> <span class="cm">/*full*/</span><span class="n">TRUE</span><span class="p">)</span>
		 <span class="o">&amp;&amp;</span> <span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">goal</span><span class="p">.</span><span class="n">period</span> <span class="o">&lt;=</span> <span class="n">AHD_SYNCRATE_PACED</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Target may not like our SPI-4 PPR Options.</span>
<span class="cm">			 * Attempt to negotiate 80MHz which will turn</span>
<span class="cm">			 * off these options.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bootverbose</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;(%s:%c:%d:%d): PPR Rejected. &quot;</span>
				       <span class="s">&quot;Trying simple U160 PPR</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">),</span> <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span>
				       <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">,</span> <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">goal</span><span class="p">.</span><span class="n">period</span> <span class="o">=</span> <span class="n">AHD_SYNCRATE_DT</span><span class="p">;</span>
			<span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">goal</span><span class="p">.</span><span class="n">ppr_options</span> <span class="o">&amp;=</span> <span class="n">MSG_EXT_PPR_IU_REQ</span>
						<span class="o">|</span>  <span class="n">MSG_EXT_PPR_QAS_REQ</span>
						<span class="o">|</span>  <span class="n">MSG_EXT_PPR_DT_REQ</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Target does not support the PPR message.</span>
<span class="cm">			 * Attempt to negotiate SPI-2 style.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bootverbose</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;(%s:%c:%d:%d): PPR Rejected. &quot;</span>
				       <span class="s">&quot;Trying WDTR/SDTR</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">),</span> <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span>
				       <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">,</span> <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">goal</span><span class="p">.</span><span class="n">ppr_options</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">.</span><span class="n">transport_version</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
			<span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">goal</span><span class="p">.</span><span class="n">transport_version</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ahd_build_transfer_msg</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">devinfo</span><span class="p">);</span>
		<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">response</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ahd_sent_msg</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHDMSG_EXT</span><span class="p">,</span> <span class="n">MSG_EXT_WDTR</span><span class="p">,</span> <span class="cm">/*full*/</span><span class="n">FALSE</span><span class="p">))</span> <span class="p">{</span>

		<span class="cm">/* note 8bit xfers */</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;(%s:%c:%d:%d): refuses WIDE negotiation.  Using &quot;</span>
		       <span class="s">&quot;8bit transfers</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">),</span>
		       <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span> <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">,</span> <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>
		<span class="n">ahd_set_width</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">devinfo</span><span class="p">,</span> <span class="n">MSG_EXT_WDTR_BUS_8_BIT</span><span class="p">,</span>
			      <span class="n">AHD_TRANS_ACTIVE</span><span class="o">|</span><span class="n">AHD_TRANS_GOAL</span><span class="p">,</span>
			      <span class="cm">/*paused*/</span><span class="n">TRUE</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * No need to clear the sync rate.  If the target</span>
<span class="cm">		 * did not accept the command, our syncrate is</span>
<span class="cm">		 * unaffected.  If the target started the negotiation,</span>
<span class="cm">		 * but rejected our response, we already cleared the</span>
<span class="cm">		 * sync rate before sending our WDTR.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">goal</span><span class="p">.</span><span class="n">offset</span> <span class="o">!=</span> <span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">.</span><span class="n">offset</span><span class="p">)</span> <span class="p">{</span>

			<span class="cm">/* Start the sync negotiation */</span>
			<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">ahd_build_transfer_msg</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">devinfo</span><span class="p">);</span>
			<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">response</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ahd_sent_msg</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHDMSG_EXT</span><span class="p">,</span> <span class="n">MSG_EXT_SDTR</span><span class="p">,</span> <span class="cm">/*full*/</span><span class="n">FALSE</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* note asynch xfers and clear flag */</span>
		<span class="n">ahd_set_syncrate</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">devinfo</span><span class="p">,</span> <span class="cm">/*period*/</span><span class="mi">0</span><span class="p">,</span>
				 <span class="cm">/*offset*/</span><span class="mi">0</span><span class="p">,</span> <span class="cm">/*ppr_options*/</span><span class="mi">0</span><span class="p">,</span>
				 <span class="n">AHD_TRANS_ACTIVE</span><span class="o">|</span><span class="n">AHD_TRANS_GOAL</span><span class="p">,</span>
				 <span class="cm">/*paused*/</span><span class="n">TRUE</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;(%s:%c:%d:%d): refuses synchronous negotiation. &quot;</span>
		       <span class="s">&quot;Using asynchronous transfers</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">),</span> <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span>
		       <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">,</span> <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">hscb</span><span class="o">-&gt;</span><span class="n">control</span> <span class="o">&amp;</span> <span class="n">MSG_SIMPLE_TASK</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">tag_type</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">mask</span><span class="p">;</span>

		<span class="n">tag_type</span> <span class="o">=</span> <span class="p">(</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">hscb</span><span class="o">-&gt;</span><span class="n">control</span> <span class="o">&amp;</span> <span class="n">MSG_SIMPLE_TASK</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tag_type</span> <span class="o">==</span> <span class="n">MSG_SIMPLE_TASK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;(%s:%c:%d:%d): refuses tagged commands.  &quot;</span>
			       <span class="s">&quot;Performing non-tagged I/O</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">),</span>
			       <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span> <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">,</span> <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>
			<span class="n">ahd_set_tags</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">io_ctx</span><span class="p">,</span> <span class="n">devinfo</span><span class="p">,</span> <span class="n">AHD_QUEUE_NONE</span><span class="p">);</span>
			<span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="mh">0x23</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;(%s:%c:%d:%d): refuses %s tagged commands.  &quot;</span>
			       <span class="s">&quot;Performing simple queue tagged I/O only</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">),</span> <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span> <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">,</span>
			       <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">,</span> <span class="n">tag_type</span> <span class="o">==</span> <span class="n">MSG_ORDERED_TASK</span>
			       <span class="o">?</span> <span class="s">&quot;ordered&quot;</span> <span class="o">:</span> <span class="s">&quot;head of queue&quot;</span><span class="p">);</span>
			<span class="n">ahd_set_tags</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">io_ctx</span><span class="p">,</span> <span class="n">devinfo</span><span class="p">,</span> <span class="n">AHD_QUEUE_BASIC</span><span class="p">);</span>
			<span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="mh">0x03</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Resend the identify for this CCB as the target</span>
<span class="cm">		 * may believe that the selection is invalid otherwise.</span>
<span class="cm">		 */</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_CONTROL</span><span class="p">,</span>
			 <span class="n">ahd_inb_scbram</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_CONTROL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">);</span>
	 	<span class="n">scb</span><span class="o">-&gt;</span><span class="n">hscb</span><span class="o">-&gt;</span><span class="n">control</span> <span class="o">&amp;=</span> <span class="n">mask</span><span class="p">;</span>
		<span class="n">ahd_set_transaction_tag</span><span class="p">(</span><span class="n">scb</span><span class="p">,</span> <span class="cm">/*enabled*/</span><span class="n">FALSE</span><span class="p">,</span>
					<span class="cm">/*type*/</span><span class="n">MSG_SIMPLE_TASK</span><span class="p">);</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">MSG_OUT</span><span class="p">,</span> <span class="n">MSG_IDENTIFYFLAG</span><span class="p">);</span>
		<span class="n">ahd_assert_atn</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
		<span class="n">ahd_busy_tcl</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">BUILD_TCL</span><span class="p">(</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">hscb</span><span class="o">-&gt;</span><span class="n">scsiid</span><span class="p">,</span> <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">),</span>
			     <span class="n">SCB_GET_TAG</span><span class="p">(</span><span class="n">scb</span><span class="p">));</span>

		<span class="cm">/*</span>
<span class="cm">		 * Requeue all tagged commands for this target</span>
<span class="cm">		 * currently in our possession so they can be</span>
<span class="cm">		 * converted to untagged commands.</span>
<span class="cm">		 */</span>
		<span class="n">ahd_search_qinfifo</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_GET_TARGET</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">),</span>
				   <span class="n">SCB_GET_CHANNEL</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">),</span>
				   <span class="n">SCB_GET_LUN</span><span class="p">(</span><span class="n">scb</span><span class="p">),</span> <span class="cm">/*tag*/</span><span class="n">SCB_LIST_NULL</span><span class="p">,</span>
				   <span class="n">ROLE_INITIATOR</span><span class="p">,</span> <span class="n">CAM_REQUEUE_REQ</span><span class="p">,</span>
				   <span class="n">SEARCH_COMPLETE</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ahd_sent_msg</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHDMSG_1B</span><span class="p">,</span> <span class="n">MSG_IDENTIFYFLAG</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Most likely the device believes that we had</span>
<span class="cm">		 * previously negotiated packetized.</span>
<span class="cm">		 */</span>
		<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msg_flags</span> <span class="o">|=</span> <span class="n">MSG_FLAG_EXPECT_PPR_BUSFREE</span>
			       <span class="o">|</span>  <span class="n">MSG_FLAG_IU_REQ_CHANGED</span><span class="p">;</span>

		<span class="n">ahd_force_renegotiation</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">devinfo</span><span class="p">);</span>
		<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ahd_build_transfer_msg</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">devinfo</span><span class="p">);</span>
		<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">response</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Otherwise, we ignore it.</span>
<span class="cm">		 */</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s:%c:%d: Message reject for %x -- ignored</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">),</span> <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span> <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">,</span>
		       <span class="n">last_msg</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">response</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Process an ingnore wide residue message.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_handle_ign_wide_residue</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ahd_devinfo</span> <span class="o">*</span><span class="n">devinfo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u_int</span> <span class="n">scb_index</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scb</span> <span class="o">*</span><span class="n">scb</span><span class="p">;</span>

	<span class="n">scb_index</span> <span class="o">=</span> <span class="n">ahd_get_scbptr</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
	<span class="n">scb</span> <span class="o">=</span> <span class="n">ahd_lookup_scb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb_index</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * XXX Actually check data direction in the sequencer?</span>
<span class="cm">	 * Perhaps add datadir to some spare bits in the hscb?</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SEQ_FLAGS</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">DPHASE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
	 <span class="o">||</span> <span class="n">ahd_get_transfer_dir</span><span class="p">(</span><span class="n">scb</span><span class="p">)</span> <span class="o">!=</span> <span class="n">CAM_DIR_IN</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Ignore the message if we haven&#39;t</span>
<span class="cm">		 * seen an appropriate data phase yet.</span>
<span class="cm">		 */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If the residual occurred on the last</span>
<span class="cm">		 * transfer and the transfer request was</span>
<span class="cm">		 * expected to end on an odd count, do</span>
<span class="cm">		 * nothing.  Otherwise, subtract a byte</span>
<span class="cm">		 * and update the residual count accordingly.</span>
<span class="cm">		 */</span>
		<span class="kt">uint32_t</span> <span class="n">sgptr</span><span class="p">;</span>

		<span class="n">sgptr</span> <span class="o">=</span> <span class="n">ahd_inb_scbram</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_RESIDUAL_SGPTR</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">sgptr</span> <span class="o">&amp;</span> <span class="n">SG_LIST_NULL</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>
		 <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ahd_inb_scbram</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_TASK_ATTRIBUTE</span><span class="p">)</span>
		     <span class="o">&amp;</span> <span class="n">SCB_XFERLEN_ODD</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * If the residual occurred on the last</span>
<span class="cm">			 * transfer and the transfer request was</span>
<span class="cm">			 * expected to end on an odd count, do</span>
<span class="cm">			 * nothing.</span>
<span class="cm">			 */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="kt">uint32_t</span> <span class="n">data_cnt</span><span class="p">;</span>
			<span class="kt">uint64_t</span> <span class="n">data_addr</span><span class="p">;</span>
			<span class="kt">uint32_t</span> <span class="n">sglen</span><span class="p">;</span>

			<span class="cm">/* Pull in the rest of the sgptr */</span>
			<span class="n">sgptr</span> <span class="o">=</span> <span class="n">ahd_inl_scbram</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_RESIDUAL_SGPTR</span><span class="p">);</span>
			<span class="n">data_cnt</span> <span class="o">=</span> <span class="n">ahd_inl_scbram</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_RESIDUAL_DATACNT</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">sgptr</span> <span class="o">&amp;</span> <span class="n">SG_LIST_NULL</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * The residual data count is not updated</span>
<span class="cm">				 * for the command run to completion case.</span>
<span class="cm">				 * Explicitly zero the count.</span>
<span class="cm">				 */</span>
				<span class="n">data_cnt</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">AHD_SG_LEN_MASK</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">data_addr</span> <span class="o">=</span> <span class="n">ahd_inq</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SHADDR</span><span class="p">);</span>
			<span class="n">data_cnt</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">data_addr</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">sgptr</span> <span class="o">&amp;=</span> <span class="n">SG_PTR_MASK</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AHD_64BIT_ADDRESSING</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">struct</span> <span class="n">ahd_dma64_seg</span> <span class="o">*</span><span class="n">sg</span><span class="p">;</span>

				<span class="n">sg</span> <span class="o">=</span> <span class="n">ahd_sg_bus_to_virt</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">,</span> <span class="n">sgptr</span><span class="p">);</span>

				<span class="cm">/*</span>
<span class="cm">				 * The residual sg ptr points to the next S/G</span>
<span class="cm">				 * to load so we must go back one.</span>
<span class="cm">				 */</span>
				<span class="n">sg</span><span class="o">--</span><span class="p">;</span>
				<span class="n">sglen</span> <span class="o">=</span> <span class="n">ahd_le32toh</span><span class="p">(</span><span class="n">sg</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">AHD_SG_LEN_MASK</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">sg</span> <span class="o">!=</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">sg_list</span>
				 <span class="o">&amp;&amp;</span> <span class="n">sglen</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">data_cnt</span> <span class="o">&amp;</span> <span class="n">AHD_SG_LEN_MASK</span><span class="p">))</span> <span class="p">{</span>

					<span class="n">sg</span><span class="o">--</span><span class="p">;</span>
					<span class="n">sglen</span> <span class="o">=</span> <span class="n">ahd_le32toh</span><span class="p">(</span><span class="n">sg</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
					<span class="cm">/*</span>
<span class="cm">					 * Preserve High Address and SG_LIST</span>
<span class="cm">					 * bits while setting the count to 1.</span>
<span class="cm">					 */</span>
					<span class="n">data_cnt</span> <span class="o">=</span> <span class="mi">1</span><span class="o">|</span><span class="p">(</span><span class="n">sglen</span><span class="o">&amp;</span><span class="p">(</span><span class="o">~</span><span class="n">AHD_SG_LEN_MASK</span><span class="p">));</span>
					<span class="n">data_addr</span> <span class="o">=</span> <span class="n">ahd_le64toh</span><span class="p">(</span><span class="n">sg</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">)</span>
						  <span class="o">+</span> <span class="p">(</span><span class="n">sglen</span> <span class="o">&amp;</span> <span class="n">AHD_SG_LEN_MASK</span><span class="p">)</span>
						  <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

					<span class="cm">/*</span>
<span class="cm">					 * Increment sg so it points to the</span>
<span class="cm">					 * &quot;next&quot; sg.</span>
<span class="cm">					 */</span>
					<span class="n">sg</span><span class="o">++</span><span class="p">;</span>
					<span class="n">sgptr</span> <span class="o">=</span> <span class="n">ahd_sg_virt_to_bus</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">,</span>
								   <span class="n">sg</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">struct</span> <span class="n">ahd_dma_seg</span> <span class="o">*</span><span class="n">sg</span><span class="p">;</span>

				<span class="n">sg</span> <span class="o">=</span> <span class="n">ahd_sg_bus_to_virt</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">,</span> <span class="n">sgptr</span><span class="p">);</span>

				<span class="cm">/*</span>
<span class="cm">				 * The residual sg ptr points to the next S/G</span>
<span class="cm">				 * to load so we must go back one.</span>
<span class="cm">				 */</span>
				<span class="n">sg</span><span class="o">--</span><span class="p">;</span>
				<span class="n">sglen</span> <span class="o">=</span> <span class="n">ahd_le32toh</span><span class="p">(</span><span class="n">sg</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">AHD_SG_LEN_MASK</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">sg</span> <span class="o">!=</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">sg_list</span>
				 <span class="o">&amp;&amp;</span> <span class="n">sglen</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">data_cnt</span> <span class="o">&amp;</span> <span class="n">AHD_SG_LEN_MASK</span><span class="p">))</span> <span class="p">{</span>

					<span class="n">sg</span><span class="o">--</span><span class="p">;</span>
					<span class="n">sglen</span> <span class="o">=</span> <span class="n">ahd_le32toh</span><span class="p">(</span><span class="n">sg</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
					<span class="cm">/*</span>
<span class="cm">					 * Preserve High Address and SG_LIST</span>
<span class="cm">					 * bits while setting the count to 1.</span>
<span class="cm">					 */</span>
					<span class="n">data_cnt</span> <span class="o">=</span> <span class="mi">1</span><span class="o">|</span><span class="p">(</span><span class="n">sglen</span><span class="o">&amp;</span><span class="p">(</span><span class="o">~</span><span class="n">AHD_SG_LEN_MASK</span><span class="p">));</span>
					<span class="n">data_addr</span> <span class="o">=</span> <span class="n">ahd_le32toh</span><span class="p">(</span><span class="n">sg</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">)</span>
						  <span class="o">+</span> <span class="p">(</span><span class="n">sglen</span> <span class="o">&amp;</span> <span class="n">AHD_SG_LEN_MASK</span><span class="p">)</span>
						  <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

					<span class="cm">/*</span>
<span class="cm">					 * Increment sg so it points to the</span>
<span class="cm">					 * &quot;next&quot; sg.</span>
<span class="cm">					 */</span>
					<span class="n">sg</span><span class="o">++</span><span class="p">;</span>
					<span class="n">sgptr</span> <span class="o">=</span> <span class="n">ahd_sg_virt_to_bus</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">,</span>
								  <span class="n">sg</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="cm">/*</span>
<span class="cm">			 * Toggle the &quot;oddness&quot; of the transfer length</span>
<span class="cm">			 * to handle this mid-transfer ignore wide</span>
<span class="cm">			 * residue.  This ensures that the oddness is</span>
<span class="cm">			 * correct for subsequent data transfers.</span>
<span class="cm">			 */</span>
			<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_TASK_ATTRIBUTE</span><span class="p">,</span>
			    <span class="n">ahd_inb_scbram</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_TASK_ATTRIBUTE</span><span class="p">)</span>
			    <span class="o">^</span> <span class="n">SCB_XFERLEN_ODD</span><span class="p">);</span>

			<span class="n">ahd_outl</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_RESIDUAL_SGPTR</span><span class="p">,</span> <span class="n">sgptr</span><span class="p">);</span>
			<span class="n">ahd_outl</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_RESIDUAL_DATACNT</span><span class="p">,</span> <span class="n">data_cnt</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * The FIFO&#39;s pointers will be updated if/when the</span>
<span class="cm">			 * sequencer re-enters a data phase.</span>
<span class="cm">			 */</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Reinitialize the data pointers for the active transfer</span>
<span class="cm"> * based on its current residual.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_reinitialize_dataptrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span>		 <span class="n">scb</span> <span class="o">*</span><span class="n">scb</span><span class="p">;</span>
	<span class="n">ahd_mode_state</span>	 <span class="n">saved_modes</span><span class="p">;</span>
	<span class="n">u_int</span>		 <span class="n">scb_index</span><span class="p">;</span>
	<span class="n">u_int</span>		 <span class="n">wait</span><span class="p">;</span>
	<span class="kt">uint32_t</span>	 <span class="n">sgptr</span><span class="p">;</span>
	<span class="kt">uint32_t</span>	 <span class="n">resid</span><span class="p">;</span>
	<span class="kt">uint64_t</span>	 <span class="n">dataptr</span><span class="p">;</span>

	<span class="n">AHD_ASSERT_MODES</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHD_MODE_DFF0_MSK</span><span class="o">|</span><span class="n">AHD_MODE_DFF1_MSK</span><span class="p">,</span>
			 <span class="n">AHD_MODE_DFF0_MSK</span><span class="o">|</span><span class="n">AHD_MODE_DFF1_MSK</span><span class="p">);</span>
			 
	<span class="n">scb_index</span> <span class="o">=</span> <span class="n">ahd_get_scbptr</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
	<span class="n">scb</span> <span class="o">=</span> <span class="n">ahd_lookup_scb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb_index</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Release and reacquire the FIFO so we</span>
<span class="cm">	 * have a clean slate.</span>
<span class="cm">	 */</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">DFFSXFRCTL</span><span class="p">,</span> <span class="n">CLRCHN</span><span class="p">);</span>
	<span class="n">wait</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">wait</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">MDFFSTAT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">FIFOFREE</span><span class="p">))</span>
		<span class="n">ahd_delay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wait</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ahd_print_path</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;ahd_reinitialize_dataptrs: Forcing FIFO free.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">DFFSXFRCTL</span><span class="p">,</span> <span class="n">RSTCHN</span><span class="o">|</span><span class="n">CLRSHCNT</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">saved_modes</span> <span class="o">=</span> <span class="n">ahd_save_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
	<span class="n">ahd_set_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">DFFSTAT</span><span class="p">,</span>
		 <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">DFFSTAT</span><span class="p">)</span>
		<span class="o">|</span> <span class="p">(</span><span class="n">saved_modes</span> <span class="o">==</span> <span class="mh">0x11</span> <span class="o">?</span> <span class="n">CURRFIFO_1</span> <span class="o">:</span> <span class="n">CURRFIFO_0</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Determine initial values for data_addr and data_cnt</span>
<span class="cm">	 * for resuming the data phase.</span>
<span class="cm">	 */</span>
	<span class="n">sgptr</span> <span class="o">=</span> <span class="n">ahd_inl_scbram</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_RESIDUAL_SGPTR</span><span class="p">);</span>
	<span class="n">sgptr</span> <span class="o">&amp;=</span> <span class="n">SG_PTR_MASK</span><span class="p">;</span>

	<span class="n">resid</span> <span class="o">=</span> <span class="p">(</span><span class="n">ahd_inb_scbram</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_RESIDUAL_DATACNT</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span>
	      <span class="o">|</span> <span class="p">(</span><span class="n">ahd_inb_scbram</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_RESIDUAL_DATACNT</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span>
	      <span class="o">|</span> <span class="n">ahd_inb_scbram</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_RESIDUAL_DATACNT</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AHD_64BIT_ADDRESSING</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ahd_dma64_seg</span> <span class="o">*</span><span class="n">sg</span><span class="p">;</span>

		<span class="n">sg</span> <span class="o">=</span> <span class="n">ahd_sg_bus_to_virt</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">,</span> <span class="n">sgptr</span><span class="p">);</span>

		<span class="cm">/* The residual sg_ptr always points to the next sg */</span>
		<span class="n">sg</span><span class="o">--</span><span class="p">;</span>

		<span class="n">dataptr</span> <span class="o">=</span> <span class="n">ahd_le64toh</span><span class="p">(</span><span class="n">sg</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">)</span>
			<span class="o">+</span> <span class="p">(</span><span class="n">ahd_le32toh</span><span class="p">(</span><span class="n">sg</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">AHD_SG_LEN_MASK</span><span class="p">)</span>
			<span class="o">-</span> <span class="n">resid</span><span class="p">;</span>
		<span class="n">ahd_outl</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">HADDR</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="n">dataptr</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span>	 <span class="n">ahd_dma_seg</span> <span class="o">*</span><span class="n">sg</span><span class="p">;</span>

		<span class="n">sg</span> <span class="o">=</span> <span class="n">ahd_sg_bus_to_virt</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">,</span> <span class="n">sgptr</span><span class="p">);</span>

		<span class="cm">/* The residual sg_ptr always points to the next sg */</span>
		<span class="n">sg</span><span class="o">--</span><span class="p">;</span>

		<span class="n">dataptr</span> <span class="o">=</span> <span class="n">ahd_le32toh</span><span class="p">(</span><span class="n">sg</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">)</span>
			<span class="o">+</span> <span class="p">(</span><span class="n">ahd_le32toh</span><span class="p">(</span><span class="n">sg</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">AHD_SG_LEN_MASK</span><span class="p">)</span>
			<span class="o">-</span> <span class="n">resid</span><span class="p">;</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">HADDR</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span>
			 <span class="p">(</span><span class="n">ahd_le32toh</span><span class="p">(</span><span class="n">sg</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">AHD_SG_LEN_MASK</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">ahd_outl</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">HADDR</span><span class="p">,</span> <span class="n">dataptr</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">HCNT</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">resid</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">HCNT</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">resid</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">HCNT</span><span class="p">,</span> <span class="n">resid</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Handle the effects of issuing a bus device reset message.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_handle_devreset</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ahd_devinfo</span> <span class="o">*</span><span class="n">devinfo</span><span class="p">,</span>
		    <span class="n">u_int</span> <span class="n">lun</span><span class="p">,</span> <span class="n">cam_status</span> <span class="n">status</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">message</span><span class="p">,</span>
		    <span class="kt">int</span> <span class="n">verbose_level</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef AHD_TARGET_MODE</span>
	<span class="k">struct</span> <span class="n">ahd_tmode_tstate</span><span class="o">*</span> <span class="n">tstate</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="kt">int</span> <span class="n">found</span><span class="p">;</span>

	<span class="n">found</span> <span class="o">=</span> <span class="n">ahd_abort_scbs</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">,</span> <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span>
			       <span class="n">lun</span><span class="p">,</span> <span class="n">SCB_LIST_NULL</span><span class="p">,</span> <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">role</span><span class="p">,</span>
			       <span class="n">status</span><span class="p">);</span>

<span class="cp">#ifdef AHD_TARGET_MODE</span>
	<span class="cm">/*</span>
<span class="cm">	 * Send an immediate notify ccb to all target mord peripheral</span>
<span class="cm">	 * drivers affected by this action.</span>
<span class="cm">	 */</span>
	<span class="n">tstate</span> <span class="o">=</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">enabled_targets</span><span class="p">[</span><span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">our_scsiid</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tstate</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u_int</span> <span class="n">cur_lun</span><span class="p">;</span>
		<span class="n">u_int</span> <span class="n">max_lun</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">lun</span> <span class="o">!=</span> <span class="n">CAM_LUN_WILDCARD</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cur_lun</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">max_lun</span> <span class="o">=</span> <span class="n">AHD_NUM_LUNS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">cur_lun</span> <span class="o">=</span> <span class="n">lun</span><span class="p">;</span>
			<span class="n">max_lun</span> <span class="o">=</span> <span class="n">lun</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">for</span> <span class="p">(;</span><span class="n">cur_lun</span> <span class="o">&lt;=</span> <span class="n">max_lun</span><span class="p">;</span> <span class="n">cur_lun</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">ahd_tmode_lstate</span><span class="o">*</span> <span class="n">lstate</span><span class="p">;</span>

			<span class="n">lstate</span> <span class="o">=</span> <span class="n">tstate</span><span class="o">-&gt;</span><span class="n">enabled_luns</span><span class="p">[</span><span class="n">cur_lun</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lstate</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="n">ahd_queue_lstate_event</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">lstate</span><span class="p">,</span> <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">our_scsiid</span><span class="p">,</span>
					       <span class="n">MSG_BUS_DEV_RESET</span><span class="p">,</span> <span class="cm">/*arg*/</span><span class="mi">0</span><span class="p">);</span>
			<span class="n">ahd_send_lstate_events</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">lstate</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 * Go back to async/narrow transfers and renegotiate.</span>
<span class="cm">	 */</span>
	<span class="n">ahd_set_width</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">devinfo</span><span class="p">,</span> <span class="n">MSG_EXT_WDTR_BUS_8_BIT</span><span class="p">,</span>
		      <span class="n">AHD_TRANS_CUR</span><span class="p">,</span> <span class="cm">/*paused*/</span><span class="n">TRUE</span><span class="p">);</span>
	<span class="n">ahd_set_syncrate</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">devinfo</span><span class="p">,</span> <span class="cm">/*period*/</span><span class="mi">0</span><span class="p">,</span> <span class="cm">/*offset*/</span><span class="mi">0</span><span class="p">,</span>
			 <span class="cm">/*ppr_options*/</span><span class="mi">0</span><span class="p">,</span> <span class="n">AHD_TRANS_CUR</span><span class="p">,</span>
			 <span class="cm">/*paused*/</span><span class="n">TRUE</span><span class="p">);</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">CAM_SEL_TIMEOUT</span><span class="p">)</span>
		<span class="n">ahd_send_async</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span> <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">,</span>
			       <span class="n">CAM_LUN_WILDCARD</span><span class="p">,</span> <span class="n">AC_SENT_BDR</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">message</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">bootverbose</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: %s on %c:%d. %d SCBs aborted</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">),</span>
		       <span class="n">message</span><span class="p">,</span> <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span> <span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">,</span> <span class="n">found</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef AHD_TARGET_MODE</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_setup_target_msgin</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ahd_devinfo</span> <span class="o">*</span><span class="n">devinfo</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">scb</span> <span class="o">*</span><span class="n">scb</span><span class="p">)</span>
<span class="p">{</span>

	<span class="cm">/*              </span>
<span class="cm">	 * To facilitate adding multiple messages together,</span>
<span class="cm">	 * each routine should increment the index and len</span>
<span class="cm">	 * variables instead of setting them explicitly.</span>
<span class="cm">	 */</span>             
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">scb</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SCB_AUTO_NEGOTIATE</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ahd_build_transfer_msg</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">devinfo</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;ahd_intr: AWAITING target message with no message&quot;</span><span class="p">);</span>

	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msgout_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">msg_type</span> <span class="o">=</span> <span class="n">MSG_TYPE_TARGET_MSGIN</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>
<span class="cm">/**************************** Initialization **********************************/</span>
<span class="k">static</span> <span class="n">u_int</span>
<span class="nf">ahd_sglist_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bus_size_t</span> <span class="n">list_size</span><span class="p">;</span>

	<span class="n">list_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_dma_seg</span><span class="p">)</span> <span class="o">*</span> <span class="n">AHD_NSEG</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AHD_64BIT_ADDRESSING</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">list_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_dma64_seg</span><span class="p">)</span> <span class="o">*</span> <span class="n">AHD_NSEG</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">list_size</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Calculate the optimum S/G List allocation size.  S/G elements used</span>
<span class="cm"> * for a given transaction must be physically contiguous.  Assume the</span>
<span class="cm"> * OS will allocate full pages to us, so it doesn&#39;t make sense to request</span>
<span class="cm"> * less than a page.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u_int</span>
<span class="nf">ahd_sglist_allocsize</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bus_size_t</span> <span class="n">sg_list_increment</span><span class="p">;</span>
	<span class="n">bus_size_t</span> <span class="n">sg_list_size</span><span class="p">;</span>
	<span class="n">bus_size_t</span> <span class="n">max_list_size</span><span class="p">;</span>
	<span class="n">bus_size_t</span> <span class="n">best_list_size</span><span class="p">;</span>

	<span class="cm">/* Start out with the minimum required for AHD_NSEG. */</span>
	<span class="n">sg_list_increment</span> <span class="o">=</span> <span class="n">ahd_sglist_size</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
	<span class="n">sg_list_size</span> <span class="o">=</span> <span class="n">sg_list_increment</span><span class="p">;</span>

	<span class="cm">/* Get us as close as possible to a page in size. */</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">sg_list_size</span> <span class="o">+</span> <span class="n">sg_list_increment</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
		<span class="n">sg_list_size</span> <span class="o">+=</span> <span class="n">sg_list_increment</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Try to reduce the amount of wastage by allocating</span>
<span class="cm">	 * multiple pages.</span>
<span class="cm">	 */</span>
	<span class="n">best_list_size</span> <span class="o">=</span> <span class="n">sg_list_size</span><span class="p">;</span>
	<span class="n">max_list_size</span> <span class="o">=</span> <span class="n">roundup</span><span class="p">(</span><span class="n">sg_list_increment</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">max_list_size</span> <span class="o">&lt;</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
		<span class="n">max_list_size</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">max_list_size</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">AHD_SCB_MAX_ALLOC</span> <span class="o">*</span> <span class="n">sg_list_increment</span><span class="p">))</span>
		<span class="n">max_list_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">AHD_SCB_MAX_ALLOC</span> <span class="o">*</span> <span class="n">sg_list_increment</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">sg_list_size</span> <span class="o">+</span> <span class="n">sg_list_increment</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">max_list_size</span>
	   <span class="o">&amp;&amp;</span>  <span class="p">(</span><span class="n">sg_list_size</span> <span class="o">%</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bus_size_t</span> <span class="n">new_mod</span><span class="p">;</span>
		<span class="n">bus_size_t</span> <span class="n">best_mod</span><span class="p">;</span>

		<span class="n">sg_list_size</span> <span class="o">+=</span> <span class="n">sg_list_increment</span><span class="p">;</span>
		<span class="n">new_mod</span> <span class="o">=</span> <span class="n">sg_list_size</span> <span class="o">%</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
		<span class="n">best_mod</span> <span class="o">=</span> <span class="n">best_list_size</span> <span class="o">%</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new_mod</span> <span class="o">&gt;</span> <span class="n">best_mod</span> <span class="o">||</span> <span class="n">new_mod</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">best_list_size</span> <span class="o">=</span> <span class="n">sg_list_size</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">best_list_size</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate a controller structure for a new device</span>
<span class="cm"> * and perform initial initializion.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span>
<span class="nf">ahd_alloc</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">platform_arg</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span>  <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">;</span>

<span class="cp">#ifndef	__FreeBSD__</span>
	<span class="n">ahd</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ahd</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ahd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;aic7xxx: cannot malloc softc!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#else</span>
	<span class="n">ahd</span> <span class="o">=</span> <span class="n">device_get_softc</span><span class="p">((</span><span class="n">device_t</span><span class="p">)</span><span class="n">platform_arg</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ahd</span><span class="p">));</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">seep_config</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">seep_config</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">seep_config</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifndef	__FreeBSD__</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">LIST_INIT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">pending_scbs</span><span class="p">);</span>
	<span class="cm">/* We don&#39;t know our unit number until the OSM sets it */</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">unit</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">description</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">bus_description</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">channel</span> <span class="o">=</span> <span class="sc">&#39;A&#39;</span><span class="p">;</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">chip</span> <span class="o">=</span> <span class="n">AHD_NONE</span><span class="p">;</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">=</span> <span class="n">AHD_FENONE</span><span class="p">;</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">bugs</span> <span class="o">=</span> <span class="n">AHD_BUGNONE</span><span class="p">;</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">AHD_SPCHK_ENB_A</span><span class="o">|</span><span class="n">AHD_RESET_BUS_A</span><span class="o">|</span><span class="n">AHD_TERM_ENB_A</span>
		   <span class="o">|</span> <span class="n">AHD_EXTENDED_TRANS_A</span><span class="o">|</span><span class="n">AHD_STPWLEVEL_A</span><span class="p">;</span>
	<span class="n">ahd_timer_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">reset_timer</span><span class="p">);</span>
	<span class="n">ahd_timer_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">stat_timer</span><span class="p">);</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">int_coalescing_timer</span> <span class="o">=</span> <span class="n">AHD_INT_COALESCING_TIMER_DEFAULT</span><span class="p">;</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">int_coalescing_maxcmds</span> <span class="o">=</span> <span class="n">AHD_INT_COALESCING_MAXCMDS_DEFAULT</span><span class="p">;</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">int_coalescing_mincmds</span> <span class="o">=</span> <span class="n">AHD_INT_COALESCING_MINCMDS_DEFAULT</span><span class="p">;</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">int_coalescing_threshold</span> <span class="o">=</span> <span class="n">AHD_INT_COALESCING_THRESHOLD_DEFAULT</span><span class="p">;</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">int_coalescing_stop_threshold</span> <span class="o">=</span>
	    <span class="n">AHD_INT_COALESCING_STOP_THRESHOLD_DEFAULT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ahd_platform_alloc</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">platform_arg</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ahd_free</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
		<span class="n">ahd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#ifdef AHD_DEBUG</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ahd_debug</span> <span class="o">&amp;</span> <span class="n">AHD_SHOW_MEMORY</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: scb size = 0x%x, hscb size = 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">),</span> <span class="p">(</span><span class="n">u_int</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">scb</span><span class="p">),</span>
		       <span class="p">(</span><span class="n">u_int</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hardware_scb</span><span class="p">));</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">ahd_softc_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">)</span>
<span class="p">{</span>

	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">unpause</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">pause</span> <span class="o">=</span> <span class="n">PAUSE</span><span class="p">;</span> 
	<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">ahd_set_unit</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">unit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">unit</span> <span class="o">=</span> <span class="n">unit</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">ahd_set_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">ahd_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">init_level</span><span class="p">)</span> <span class="p">{</span>
	<span class="nl">default:</span>
	<span class="k">case</span> <span class="mi">5</span>:
		<span class="n">ahd_shutdown</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
		<span class="cm">/* FALLTHROUGH */</span>
	<span class="k">case</span> <span class="mi">4</span>:
		<span class="n">ahd_dmamap_unload</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">shared_data_dmat</span><span class="p">,</span>
				  <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">shared_data_map</span><span class="p">.</span><span class="n">dmamap</span><span class="p">);</span>
		<span class="cm">/* FALLTHROUGH */</span>
	<span class="k">case</span> <span class="mi">3</span>:
		<span class="n">ahd_dmamem_free</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">shared_data_dmat</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">qoutfifo</span><span class="p">,</span>
				<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">shared_data_map</span><span class="p">.</span><span class="n">dmamap</span><span class="p">);</span>
		<span class="n">ahd_dmamap_destroy</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">shared_data_dmat</span><span class="p">,</span>
				   <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">shared_data_map</span><span class="p">.</span><span class="n">dmamap</span><span class="p">);</span>
		<span class="cm">/* FALLTHROUGH */</span>
	<span class="k">case</span> <span class="mi">2</span>:
		<span class="n">ahd_dma_tag_destroy</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">shared_data_dmat</span><span class="p">);</span>
	<span class="k">case</span> <span class="mi">1</span>:
<span class="cp">#ifndef __linux__</span>
		<span class="n">ahd_dma_tag_destroy</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">buffer_dmat</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#ifndef __linux__</span>
	<span class="n">ahd_dma_tag_destroy</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">parent_dmat</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">ahd_platform_free</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
	<span class="n">ahd_fini_scbdata</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">AHD_NUM_TARGETS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ahd_tmode_tstate</span> <span class="o">*</span><span class="n">tstate</span><span class="p">;</span>

		<span class="n">tstate</span> <span class="o">=</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">enabled_targets</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tstate</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef AHD_TARGET_MODE</span>
			<span class="kt">int</span> <span class="n">j</span><span class="p">;</span>

			<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">AHD_NUM_LUNS</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">struct</span> <span class="n">ahd_tmode_lstate</span> <span class="o">*</span><span class="n">lstate</span><span class="p">;</span>

				<span class="n">lstate</span> <span class="o">=</span> <span class="n">tstate</span><span class="o">-&gt;</span><span class="n">enabled_luns</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">lstate</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">xpt_free_path</span><span class="p">(</span><span class="n">lstate</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">);</span>
					<span class="n">kfree</span><span class="p">(</span><span class="n">lstate</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
<span class="cp">#endif</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">tstate</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#ifdef AHD_TARGET_MODE</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">black_hole</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xpt_free_path</span><span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">black_hole</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">black_hole</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">seep_config</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">seep_config</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">saved_stack</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">saved_stack</span><span class="p">);</span>
<span class="cp">#ifndef __FreeBSD__</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_shutdown</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span>	<span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">;</span>

	<span class="n">ahd</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Stop periodic timer callbacks.</span>
<span class="cm">	 */</span>
	<span class="n">ahd_timer_stop</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">reset_timer</span><span class="p">);</span>
	<span class="n">ahd_timer_stop</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">stat_timer</span><span class="p">);</span>

	<span class="cm">/* This will reset most registers to 0, but not all */</span>
	<span class="n">ahd_reset</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="cm">/*reinit*/</span><span class="n">FALSE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Reset the controller and record some information about it</span>
<span class="cm"> * that is only available just after a reset.  If &quot;reinit&quot; is</span>
<span class="cm"> * non-zero, this reset occurred after initial configuration</span>
<span class="cm"> * and the caller requests that the chip be fully reinitialized</span>
<span class="cm"> * to a runable state.  Chip interrupts are *not* enabled after</span>
<span class="cm"> * a reinitialization.  The caller must enable interrupts via</span>
<span class="cm"> * ahd_intr_enable().</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">ahd_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reinit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u_int</span>	 <span class="n">sxfrctl1</span><span class="p">;</span>
	<span class="kt">int</span>	 <span class="n">wait</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">cmd</span><span class="p">;</span>
	
	<span class="cm">/*</span>
<span class="cm">	 * Preserve the value of the SXFRCTL1 register for all channels.</span>
<span class="cm">	 * It contains settings that affect termination and we don&#39;t want</span>
<span class="cm">	 * to disturb the integrity of the bus.</span>
<span class="cm">	 */</span>
	<span class="n">ahd_pause</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
	<span class="n">ahd_update_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
	<span class="n">ahd_set_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI</span><span class="p">);</span>
	<span class="n">sxfrctl1</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SXFRCTL1</span><span class="p">);</span>

	<span class="n">cmd</span> <span class="o">=</span> <span class="n">ahd_pci_read_config</span><span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">dev_softc</span><span class="p">,</span> <span class="n">PCIR_COMMAND</span><span class="p">,</span> <span class="cm">/*bytes*/</span><span class="mi">2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">bugs</span> <span class="o">&amp;</span> <span class="n">AHD_PCIX_CHIPRST_BUG</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">uint32_t</span> <span class="n">mod_cmd</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * A4 Razor #632</span>
<span class="cm">		 * During the assertion of CHIPRST, the chip</span>
<span class="cm">		 * does not disable its parity logic prior to</span>
<span class="cm">		 * the start of the reset.  This may cause a</span>
<span class="cm">		 * parity error to be detected and thus a</span>
<span class="cm">		 * spurious SERR or PERR assertion.  Disble</span>
<span class="cm">		 * PERR and SERR responses during the CHIPRST.</span>
<span class="cm">		 */</span>
		<span class="n">mod_cmd</span> <span class="o">=</span> <span class="n">cmd</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">PCIM_CMD_PERRESPEN</span><span class="o">|</span><span class="n">PCIM_CMD_SERRESPEN</span><span class="p">);</span>
		<span class="n">ahd_pci_write_config</span><span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">dev_softc</span><span class="p">,</span> <span class="n">PCIR_COMMAND</span><span class="p">,</span>
				     <span class="n">mod_cmd</span><span class="p">,</span> <span class="cm">/*bytes*/</span><span class="mi">2</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">HCNTRL</span><span class="p">,</span> <span class="n">CHIPRST</span> <span class="o">|</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">pause</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Ensure that the reset has finished.  We delay 1000us</span>
<span class="cm">	 * prior to reading the register to make sure the chip</span>
<span class="cm">	 * has sufficiently completed its reset to handle register</span>
<span class="cm">	 * accesses.</span>
<span class="cm">	 */</span>
	<span class="n">wait</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">ahd_delay</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">wait</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">HCNTRL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">CHIPRSTACK</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wait</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: WARNING - Failed chip reset!  &quot;</span>
		       <span class="s">&quot;Trying to initialize anyway.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">HCNTRL</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">pause</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">bugs</span> <span class="o">&amp;</span> <span class="n">AHD_PCIX_CHIPRST_BUG</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Clear any latched PCI error status and restore</span>
<span class="cm">		 * previous SERR and PERR response enables.</span>
<span class="cm">		 */</span>
		<span class="n">ahd_pci_write_config</span><span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">dev_softc</span><span class="p">,</span> <span class="n">PCIR_STATUS</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
				     <span class="mh">0xFF</span><span class="p">,</span> <span class="cm">/*bytes*/</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">ahd_pci_write_config</span><span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">dev_softc</span><span class="p">,</span> <span class="n">PCIR_COMMAND</span><span class="p">,</span>
				     <span class="n">cmd</span><span class="p">,</span> <span class="cm">/*bytes*/</span><span class="mi">2</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Mode should be SCSI after a chip reset, but lets</span>
<span class="cm">	 * set it just to be safe.  We touch the MODE_PTR</span>
<span class="cm">	 * register directly so as to bypass the lazy update</span>
<span class="cm">	 * code in ahd_set_modes().</span>
<span class="cm">	 */</span>
	<span class="n">ahd_known_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">MODE_PTR</span><span class="p">,</span>
		 <span class="n">ahd_build_mode_state</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Restore SXFRCTL1.</span>
<span class="cm">	 *</span>
<span class="cm">	 * We must always initialize STPWEN to 1 before we</span>
<span class="cm">	 * restore the saved values.  STPWEN is initialized</span>
<span class="cm">	 * to a tri-state condition which can only be cleared</span>
<span class="cm">	 * by turning it on.</span>
<span class="cm">	 */</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SXFRCTL1</span><span class="p">,</span> <span class="n">sxfrctl1</span><span class="o">|</span><span class="n">STPWEN</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SXFRCTL1</span><span class="p">,</span> <span class="n">sxfrctl1</span><span class="p">);</span>

	<span class="cm">/* Determine chip configuration */</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">AHD_WIDE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SBLKCTL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SELWIDE</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">|=</span> <span class="n">AHD_WIDE</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If a recovery action has forced a chip reset,</span>
<span class="cm">	 * re-initialize the chip to our liking.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reinit</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ahd_chip_init</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Determine the number of SCBs available on the controller</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ahd_probe_scbs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">AHD_ASSERT_MODES</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="o">~</span><span class="p">(</span><span class="n">AHD_MODE_UNKNOWN_MSK</span><span class="o">|</span><span class="n">AHD_MODE_CFG_MSK</span><span class="p">),</span>
			 <span class="o">~</span><span class="p">(</span><span class="n">AHD_MODE_UNKNOWN_MSK</span><span class="o">|</span><span class="n">AHD_MODE_CFG_MSK</span><span class="p">));</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">AHD_SCB_MAX</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">j</span><span class="p">;</span>

		<span class="n">ahd_set_scbptr</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">ahd_outw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_BASE</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">64</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
			<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_BASE</span><span class="o">+</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="cm">/* Start out life as unallocated (needing an abort) */</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_CONTROL</span><span class="p">,</span> <span class="n">MK_MESSAGE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ahd_inw_scbram</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_BASE</span><span class="p">)</span> <span class="o">!=</span> <span class="n">i</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">ahd_set_scbptr</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ahd_inw_scbram</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_BASE</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_dmamap_cb</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="n">bus_dma_segment_t</span> <span class="o">*</span><span class="n">segs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nseg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">error</span><span class="p">)</span> 
<span class="p">{</span>
	<span class="n">dma_addr_t</span> <span class="o">*</span><span class="n">baddr</span><span class="p">;</span>

	<span class="n">baddr</span> <span class="o">=</span> <span class="p">(</span><span class="n">dma_addr_t</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
	<span class="o">*</span><span class="n">baddr</span> <span class="o">=</span> <span class="n">segs</span><span class="o">-&gt;</span><span class="n">ds_addr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_initialize_hscbs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">scb_data</span><span class="p">.</span><span class="n">maxhscbs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ahd_set_scbptr</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

		<span class="cm">/* Clear the control byte. */</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_CONTROL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="cm">/* Set the next pointer */</span>
		<span class="n">ahd_outw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_NEXT</span><span class="p">,</span> <span class="n">SCB_LIST_NULL</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ahd_init_scbdata</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span>	<span class="n">scb_data</span> <span class="o">*</span><span class="n">scb_data</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">i</span><span class="p">;</span>

	<span class="n">scb_data</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">scb_data</span><span class="p">;</span>
	<span class="n">TAILQ_INIT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scb_data</span><span class="o">-&gt;</span><span class="n">free_scbs</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">AHD_NUM_TARGETS</span> <span class="o">*</span> <span class="n">AHD_NUM_LUNS_NONPKT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">LIST_INIT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scb_data</span><span class="o">-&gt;</span><span class="n">free_scb_lists</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="n">LIST_INIT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scb_data</span><span class="o">-&gt;</span><span class="n">any_dev_free_scb_list</span><span class="p">);</span>
	<span class="n">SLIST_INIT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scb_data</span><span class="o">-&gt;</span><span class="n">hscb_maps</span><span class="p">);</span>
	<span class="n">SLIST_INIT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scb_data</span><span class="o">-&gt;</span><span class="n">sg_maps</span><span class="p">);</span>
	<span class="n">SLIST_INIT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scb_data</span><span class="o">-&gt;</span><span class="n">sense_maps</span><span class="p">);</span>

	<span class="cm">/* Determine the number of hardware SCBs and initialize them */</span>
	<span class="n">scb_data</span><span class="o">-&gt;</span><span class="n">maxhscbs</span> <span class="o">=</span> <span class="n">ahd_probe_scbs</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">scb_data</span><span class="o">-&gt;</span><span class="n">maxhscbs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: No SCB space found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">));</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">ENXIO</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ahd_initialize_hscbs</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Create our DMA tags.  These tags define the kinds of device</span>
<span class="cm">	 * accessible memory allocations and memory mappings we will</span>
<span class="cm">	 * need to perform during normal operation.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Unless we need to further restrict the allocation, we rely</span>
<span class="cm">	 * on the restrictions of the parent dmat, hence the common</span>
<span class="cm">	 * use of MAXADDR and MAXSIZE.</span>
<span class="cm">	 */</span>

	<span class="cm">/* DMA tag for our hardware scb structures */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ahd_dma_tag_create</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">parent_dmat</span><span class="p">,</span> <span class="cm">/*alignment*/</span><span class="mi">1</span><span class="p">,</span>
			       <span class="cm">/*boundary*/</span><span class="n">BUS_SPACE_MAXADDR_32BIT</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
			       <span class="cm">/*lowaddr*/</span><span class="n">BUS_SPACE_MAXADDR_32BIT</span><span class="p">,</span>
			       <span class="cm">/*highaddr*/</span><span class="n">BUS_SPACE_MAXADDR</span><span class="p">,</span>
			       <span class="cm">/*filter*/</span><span class="nb">NULL</span><span class="p">,</span> <span class="cm">/*filterarg*/</span><span class="nb">NULL</span><span class="p">,</span>
			       <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="cm">/*nsegments*/</span><span class="mi">1</span><span class="p">,</span>
			       <span class="cm">/*maxsegsz*/</span><span class="n">BUS_SPACE_MAXSIZE_32BIT</span><span class="p">,</span>
			       <span class="cm">/*flags*/</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">scb_data</span><span class="o">-&gt;</span><span class="n">hscb_dmat</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">goto</span> <span class="n">error_exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">scb_data</span><span class="o">-&gt;</span><span class="n">init_level</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* DMA tag for our S/G structures. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ahd_dma_tag_create</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">parent_dmat</span><span class="p">,</span> <span class="cm">/*alignment*/</span><span class="mi">8</span><span class="p">,</span>
			       <span class="cm">/*boundary*/</span><span class="n">BUS_SPACE_MAXADDR_32BIT</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
			       <span class="cm">/*lowaddr*/</span><span class="n">BUS_SPACE_MAXADDR_32BIT</span><span class="p">,</span>
			       <span class="cm">/*highaddr*/</span><span class="n">BUS_SPACE_MAXADDR</span><span class="p">,</span>
			       <span class="cm">/*filter*/</span><span class="nb">NULL</span><span class="p">,</span> <span class="cm">/*filterarg*/</span><span class="nb">NULL</span><span class="p">,</span>
			       <span class="n">ahd_sglist_allocsize</span><span class="p">(</span><span class="n">ahd</span><span class="p">),</span> <span class="cm">/*nsegments*/</span><span class="mi">1</span><span class="p">,</span>
			       <span class="cm">/*maxsegsz*/</span><span class="n">BUS_SPACE_MAXSIZE_32BIT</span><span class="p">,</span>
			       <span class="cm">/*flags*/</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">scb_data</span><span class="o">-&gt;</span><span class="n">sg_dmat</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">goto</span> <span class="n">error_exit</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#ifdef AHD_DEBUG</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ahd_debug</span> <span class="o">&amp;</span> <span class="n">AHD_SHOW_MEMORY</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: ahd_sglist_allocsize = 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">),</span>
		       <span class="n">ahd_sglist_allocsize</span><span class="p">(</span><span class="n">ahd</span><span class="p">));</span>
<span class="cp">#endif</span>

	<span class="n">scb_data</span><span class="o">-&gt;</span><span class="n">init_level</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* DMA tag for our sense buffers.  We allocate in page sized chunks */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ahd_dma_tag_create</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">parent_dmat</span><span class="p">,</span> <span class="cm">/*alignment*/</span><span class="mi">1</span><span class="p">,</span>
			       <span class="cm">/*boundary*/</span><span class="n">BUS_SPACE_MAXADDR_32BIT</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
			       <span class="cm">/*lowaddr*/</span><span class="n">BUS_SPACE_MAXADDR_32BIT</span><span class="p">,</span>
			       <span class="cm">/*highaddr*/</span><span class="n">BUS_SPACE_MAXADDR</span><span class="p">,</span>
			       <span class="cm">/*filter*/</span><span class="nb">NULL</span><span class="p">,</span> <span class="cm">/*filterarg*/</span><span class="nb">NULL</span><span class="p">,</span>
			       <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="cm">/*nsegments*/</span><span class="mi">1</span><span class="p">,</span>
			       <span class="cm">/*maxsegsz*/</span><span class="n">BUS_SPACE_MAXSIZE_32BIT</span><span class="p">,</span>
			       <span class="cm">/*flags*/</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">scb_data</span><span class="o">-&gt;</span><span class="n">sense_dmat</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">goto</span> <span class="n">error_exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">scb_data</span><span class="o">-&gt;</span><span class="n">init_level</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* Perform initial CCB allocation */</span>
	<span class="n">ahd_alloc_scbs</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">scb_data</span><span class="o">-&gt;</span><span class="n">numscbs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: ahd_init_scbdata - &quot;</span>
		       <span class="s">&quot;Unable to allocate initial scbs</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">));</span>
		<span class="k">goto</span> <span class="n">error_exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Note that we were successful</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span> 

<span class="nl">error_exit:</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">ENOMEM</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">scb</span> <span class="o">*</span>
<span class="nf">ahd_find_scb_by_tag</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">tag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scb</span> <span class="o">*</span><span class="n">scb</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Look on the pending list.</span>
<span class="cm">	 */</span>
	<span class="n">LIST_FOREACH</span><span class="p">(</span><span class="n">scb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">pending_scbs</span><span class="p">,</span> <span class="n">pending_links</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">SCB_GET_TAG</span><span class="p">(</span><span class="n">scb</span><span class="p">)</span> <span class="o">==</span> <span class="n">tag</span><span class="p">)</span>
			<span class="k">return</span> <span class="p">(</span><span class="n">scb</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Then on all of the collision free lists.</span>
<span class="cm">	 */</span>
	<span class="n">TAILQ_FOREACH</span><span class="p">(</span><span class="n">scb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">scb_data</span><span class="p">.</span><span class="n">free_scbs</span><span class="p">,</span> <span class="n">links</span><span class="p">.</span><span class="n">tqe</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">scb</span> <span class="o">*</span><span class="n">list_scb</span><span class="p">;</span>

		<span class="n">list_scb</span> <span class="o">=</span> <span class="n">scb</span><span class="p">;</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">SCB_GET_TAG</span><span class="p">(</span><span class="n">list_scb</span><span class="p">)</span> <span class="o">==</span> <span class="n">tag</span><span class="p">)</span>
				<span class="k">return</span> <span class="p">(</span><span class="n">list_scb</span><span class="p">);</span>
			<span class="n">list_scb</span> <span class="o">=</span> <span class="n">LIST_NEXT</span><span class="p">(</span><span class="n">list_scb</span><span class="p">,</span> <span class="n">collision_links</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">list_scb</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * And finally on the generic free list.</span>
<span class="cm">	 */</span>
	<span class="n">LIST_FOREACH</span><span class="p">(</span><span class="n">scb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">scb_data</span><span class="p">.</span><span class="n">any_dev_free_scb_list</span><span class="p">,</span> <span class="n">links</span><span class="p">.</span><span class="n">le</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">SCB_GET_TAG</span><span class="p">(</span><span class="n">scb</span><span class="p">)</span> <span class="o">==</span> <span class="n">tag</span><span class="p">)</span>
			<span class="k">return</span> <span class="p">(</span><span class="n">scb</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_fini_scbdata</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scb_data</span> <span class="o">*</span><span class="n">scb_data</span><span class="p">;</span>

	<span class="n">scb_data</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">scb_data</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">scb_data</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">scb_data</span><span class="o">-&gt;</span><span class="n">init_level</span><span class="p">)</span> <span class="p">{</span>
	<span class="nl">default:</span>
	<span class="k">case</span> <span class="mi">7</span>:
	<span class="p">{</span>
		<span class="k">struct</span> <span class="n">map_node</span> <span class="o">*</span><span class="n">sns_map</span><span class="p">;</span>

		<span class="k">while</span> <span class="p">((</span><span class="n">sns_map</span> <span class="o">=</span> <span class="n">SLIST_FIRST</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scb_data</span><span class="o">-&gt;</span><span class="n">sense_maps</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">SLIST_REMOVE_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scb_data</span><span class="o">-&gt;</span><span class="n">sense_maps</span><span class="p">,</span> <span class="n">links</span><span class="p">);</span>
			<span class="n">ahd_dmamap_unload</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb_data</span><span class="o">-&gt;</span><span class="n">sense_dmat</span><span class="p">,</span>
					  <span class="n">sns_map</span><span class="o">-&gt;</span><span class="n">dmamap</span><span class="p">);</span>
			<span class="n">ahd_dmamem_free</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb_data</span><span class="o">-&gt;</span><span class="n">sense_dmat</span><span class="p">,</span>
					<span class="n">sns_map</span><span class="o">-&gt;</span><span class="n">vaddr</span><span class="p">,</span> <span class="n">sns_map</span><span class="o">-&gt;</span><span class="n">dmamap</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">sns_map</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">ahd_dma_tag_destroy</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb_data</span><span class="o">-&gt;</span><span class="n">sense_dmat</span><span class="p">);</span>
		<span class="cm">/* FALLTHROUGH */</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="mi">6</span>:
	<span class="p">{</span>
		<span class="k">struct</span> <span class="n">map_node</span> <span class="o">*</span><span class="n">sg_map</span><span class="p">;</span>

		<span class="k">while</span> <span class="p">((</span><span class="n">sg_map</span> <span class="o">=</span> <span class="n">SLIST_FIRST</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scb_data</span><span class="o">-&gt;</span><span class="n">sg_maps</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">SLIST_REMOVE_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scb_data</span><span class="o">-&gt;</span><span class="n">sg_maps</span><span class="p">,</span> <span class="n">links</span><span class="p">);</span>
			<span class="n">ahd_dmamap_unload</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb_data</span><span class="o">-&gt;</span><span class="n">sg_dmat</span><span class="p">,</span>
					  <span class="n">sg_map</span><span class="o">-&gt;</span><span class="n">dmamap</span><span class="p">);</span>
			<span class="n">ahd_dmamem_free</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb_data</span><span class="o">-&gt;</span><span class="n">sg_dmat</span><span class="p">,</span>
					<span class="n">sg_map</span><span class="o">-&gt;</span><span class="n">vaddr</span><span class="p">,</span> <span class="n">sg_map</span><span class="o">-&gt;</span><span class="n">dmamap</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">sg_map</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">ahd_dma_tag_destroy</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb_data</span><span class="o">-&gt;</span><span class="n">sg_dmat</span><span class="p">);</span>
		<span class="cm">/* FALLTHROUGH */</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="mi">5</span>:
	<span class="p">{</span>
		<span class="k">struct</span> <span class="n">map_node</span> <span class="o">*</span><span class="n">hscb_map</span><span class="p">;</span>

		<span class="k">while</span> <span class="p">((</span><span class="n">hscb_map</span> <span class="o">=</span> <span class="n">SLIST_FIRST</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scb_data</span><span class="o">-&gt;</span><span class="n">hscb_maps</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">SLIST_REMOVE_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scb_data</span><span class="o">-&gt;</span><span class="n">hscb_maps</span><span class="p">,</span> <span class="n">links</span><span class="p">);</span>
			<span class="n">ahd_dmamap_unload</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb_data</span><span class="o">-&gt;</span><span class="n">hscb_dmat</span><span class="p">,</span>
					  <span class="n">hscb_map</span><span class="o">-&gt;</span><span class="n">dmamap</span><span class="p">);</span>
			<span class="n">ahd_dmamem_free</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb_data</span><span class="o">-&gt;</span><span class="n">hscb_dmat</span><span class="p">,</span>
					<span class="n">hscb_map</span><span class="o">-&gt;</span><span class="n">vaddr</span><span class="p">,</span> <span class="n">hscb_map</span><span class="o">-&gt;</span><span class="n">dmamap</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">hscb_map</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">ahd_dma_tag_destroy</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb_data</span><span class="o">-&gt;</span><span class="n">hscb_dmat</span><span class="p">);</span>
		<span class="cm">/* FALLTHROUGH */</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="mi">4</span>:
	<span class="k">case</span> <span class="mi">3</span>:
	<span class="k">case</span> <span class="mi">2</span>:
	<span class="k">case</span> <span class="mi">1</span>:
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * DSP filter Bypass must be enabled until the first selection</span>
<span class="cm"> * after a change in bus mode (Razor #491 and #493).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_setup_iocell_workaround</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ahd_mode_state</span> <span class="n">saved_modes</span><span class="p">;</span>

	<span class="n">saved_modes</span> <span class="o">=</span> <span class="n">ahd_save_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
	<span class="n">ahd_set_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHD_MODE_CFG</span><span class="p">,</span> <span class="n">AHD_MODE_CFG</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">DSPDATACTL</span><span class="p">,</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">DSPDATACTL</span><span class="p">)</span>
	       <span class="o">|</span> <span class="n">BYPASSENAB</span> <span class="o">|</span> <span class="n">RCVROFFSTDIS</span> <span class="o">|</span> <span class="n">XMITOFFSTDIS</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SIMODE0</span><span class="p">,</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SIMODE0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">ENSELDO</span><span class="o">|</span><span class="n">ENSELDI</span><span class="p">));</span>
<span class="cp">#ifdef AHD_DEBUG</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ahd_debug</span> <span class="o">&amp;</span> <span class="n">AHD_SHOW_MISC</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: Setting up iocell workaround</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">));</span>
<span class="cp">#endif</span>
	<span class="n">ahd_restore_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">saved_modes</span><span class="p">);</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">AHD_HAD_FIRST_SEL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_iocell_first_selection</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ahd_mode_state</span>	<span class="n">saved_modes</span><span class="p">;</span>
	<span class="n">u_int</span>		<span class="n">sblkctl</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AHD_HAD_FIRST_SEL</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">saved_modes</span> <span class="o">=</span> <span class="n">ahd_save_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
	<span class="n">ahd_set_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI</span><span class="p">);</span>
	<span class="n">sblkctl</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SBLKCTL</span><span class="p">);</span>
	<span class="n">ahd_set_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHD_MODE_CFG</span><span class="p">,</span> <span class="n">AHD_MODE_CFG</span><span class="p">);</span>
<span class="cp">#ifdef AHD_DEBUG</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ahd_debug</span> <span class="o">&amp;</span> <span class="n">AHD_SHOW_MISC</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: iocell first selection</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">));</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">sblkctl</span> <span class="o">&amp;</span> <span class="n">ENAB40</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">DSPDATACTL</span><span class="p">,</span>
			 <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">DSPDATACTL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">BYPASSENAB</span><span class="p">);</span>
<span class="cp">#ifdef AHD_DEBUG</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ahd_debug</span> <span class="o">&amp;</span> <span class="n">AHD_SHOW_MISC</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: BYPASS now disabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">));</span>
<span class="cp">#endif</span>
	<span class="p">}</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SIMODE0</span><span class="p">,</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SIMODE0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">ENSELDO</span><span class="o">|</span><span class="n">ENSELDI</span><span class="p">));</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CLRINT</span><span class="p">,</span> <span class="n">CLRSCSIINT</span><span class="p">);</span>
	<span class="n">ahd_restore_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">saved_modes</span><span class="p">);</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">AHD_HAD_FIRST_SEL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*************************** SCB Management ***********************************/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_add_col_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scb</span> <span class="o">*</span><span class="n">scb</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">col_idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span>	<span class="n">scb_list</span> <span class="o">*</span><span class="n">free_list</span><span class="p">;</span>
	<span class="k">struct</span>	<span class="n">scb_tailq</span> <span class="o">*</span><span class="n">free_tailq</span><span class="p">;</span>
	<span class="k">struct</span>	<span class="n">scb</span> <span class="o">*</span><span class="n">first_scb</span><span class="p">;</span>

	<span class="n">scb</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">SCB_ON_COL_LIST</span><span class="p">;</span>
	<span class="n">AHD_SET_SCB_COL_IDX</span><span class="p">(</span><span class="n">scb</span><span class="p">,</span> <span class="n">col_idx</span><span class="p">);</span>
	<span class="n">free_list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">scb_data</span><span class="p">.</span><span class="n">free_scb_lists</span><span class="p">[</span><span class="n">col_idx</span><span class="p">];</span>
	<span class="n">free_tailq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">scb_data</span><span class="p">.</span><span class="n">free_scbs</span><span class="p">;</span>
	<span class="n">first_scb</span> <span class="o">=</span> <span class="n">LIST_FIRST</span><span class="p">(</span><span class="n">free_list</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">first_scb</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">LIST_INSERT_AFTER</span><span class="p">(</span><span class="n">first_scb</span><span class="p">,</span> <span class="n">scb</span><span class="p">,</span> <span class="n">collision_links</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">LIST_INSERT_HEAD</span><span class="p">(</span><span class="n">free_list</span><span class="p">,</span> <span class="n">scb</span><span class="p">,</span> <span class="n">collision_links</span><span class="p">);</span>
		<span class="n">TAILQ_INSERT_TAIL</span><span class="p">(</span><span class="n">free_tailq</span><span class="p">,</span> <span class="n">scb</span><span class="p">,</span> <span class="n">links</span><span class="p">.</span><span class="n">tqe</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_rem_col_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scb</span> <span class="o">*</span><span class="n">scb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span>	<span class="n">scb_list</span> <span class="o">*</span><span class="n">free_list</span><span class="p">;</span>
	<span class="k">struct</span>	<span class="n">scb_tailq</span> <span class="o">*</span><span class="n">free_tailq</span><span class="p">;</span>
	<span class="k">struct</span>	<span class="n">scb</span> <span class="o">*</span><span class="n">first_scb</span><span class="p">;</span>
	<span class="n">u_int</span>	<span class="n">col_idx</span><span class="p">;</span>

	<span class="n">scb</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SCB_ON_COL_LIST</span><span class="p">;</span>
	<span class="n">col_idx</span> <span class="o">=</span> <span class="n">AHD_GET_SCB_COL_IDX</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
	<span class="n">free_list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">scb_data</span><span class="p">.</span><span class="n">free_scb_lists</span><span class="p">[</span><span class="n">col_idx</span><span class="p">];</span>
	<span class="n">free_tailq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">scb_data</span><span class="p">.</span><span class="n">free_scbs</span><span class="p">;</span>
	<span class="n">first_scb</span> <span class="o">=</span> <span class="n">LIST_FIRST</span><span class="p">(</span><span class="n">free_list</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">first_scb</span> <span class="o">==</span> <span class="n">scb</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">scb</span> <span class="o">*</span><span class="n">next_scb</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Maintain order in the collision free</span>
<span class="cm">		 * lists for fairness if this device has</span>
<span class="cm">		 * other colliding tags active.</span>
<span class="cm">		 */</span>
		<span class="n">next_scb</span> <span class="o">=</span> <span class="n">LIST_NEXT</span><span class="p">(</span><span class="n">scb</span><span class="p">,</span> <span class="n">collision_links</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">next_scb</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">TAILQ_INSERT_AFTER</span><span class="p">(</span><span class="n">free_tailq</span><span class="p">,</span> <span class="n">scb</span><span class="p">,</span>
					   <span class="n">next_scb</span><span class="p">,</span> <span class="n">links</span><span class="p">.</span><span class="n">tqe</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">TAILQ_REMOVE</span><span class="p">(</span><span class="n">free_tailq</span><span class="p">,</span> <span class="n">scb</span><span class="p">,</span> <span class="n">links</span><span class="p">.</span><span class="n">tqe</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">LIST_REMOVE</span><span class="p">(</span><span class="n">scb</span><span class="p">,</span> <span class="n">collision_links</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Get a free scb. If there are none, see if we can allocate a new SCB.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">scb</span> <span class="o">*</span>
<span class="nf">ahd_get_scb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">col_idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scb</span> <span class="o">*</span><span class="n">scb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tries</span><span class="p">;</span>

	<span class="n">tries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">look_again:</span>
	<span class="n">TAILQ_FOREACH</span><span class="p">(</span><span class="n">scb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">scb_data</span><span class="p">.</span><span class="n">free_scbs</span><span class="p">,</span> <span class="n">links</span><span class="p">.</span><span class="n">tqe</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">AHD_GET_SCB_COL_IDX</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">)</span> <span class="o">!=</span> <span class="n">col_idx</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ahd_rem_col_list</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">scb</span> <span class="o">=</span> <span class="n">LIST_FIRST</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">scb_data</span><span class="p">.</span><span class="n">any_dev_free_scb_list</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tries</span><span class="o">++</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
		<span class="n">ahd_alloc_scbs</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">look_again</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">LIST_REMOVE</span><span class="p">(</span><span class="n">scb</span><span class="p">,</span> <span class="n">links</span><span class="p">.</span><span class="n">le</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">col_idx</span> <span class="o">!=</span> <span class="n">AHD_NEVER_COL_IDX</span>
	 <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">col_scb</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
	 <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">col_scb</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SCB_ACTIVE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">LIST_REMOVE</span><span class="p">(</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">col_scb</span><span class="p">,</span> <span class="n">links</span><span class="p">.</span><span class="n">le</span><span class="p">);</span>
		<span class="n">ahd_add_col_list</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">col_scb</span><span class="p">,</span> <span class="n">col_idx</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">found:</span>
	<span class="n">scb</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">SCB_ACTIVE</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">scb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return an SCB resource to the free list.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">ahd_free_scb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scb</span> <span class="o">*</span><span class="n">scb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Clean up for the next user */</span>
	<span class="n">scb</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">SCB_FLAG_NONE</span><span class="p">;</span>
	<span class="n">scb</span><span class="o">-&gt;</span><span class="n">hscb</span><span class="o">-&gt;</span><span class="n">control</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">scb_data</span><span class="p">.</span><span class="n">scbindex</span><span class="p">[</span><span class="n">SCB_GET_TAG</span><span class="p">(</span><span class="n">scb</span><span class="p">)]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">col_scb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/*</span>
<span class="cm">		 * No collision possible.  Just free normally.</span>
<span class="cm">		 */</span>
		<span class="n">LIST_INSERT_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">scb_data</span><span class="p">.</span><span class="n">any_dev_free_scb_list</span><span class="p">,</span>
				 <span class="n">scb</span><span class="p">,</span> <span class="n">links</span><span class="p">.</span><span class="n">le</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">col_scb</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SCB_ON_COL_LIST</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/*</span>
<span class="cm">		 * The SCB we might have collided with is on</span>
<span class="cm">		 * a free collision list.  Put both SCBs on</span>
<span class="cm">		 * the generic list.</span>
<span class="cm">		 */</span>
		<span class="n">ahd_rem_col_list</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">col_scb</span><span class="p">);</span>
		<span class="n">LIST_INSERT_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">scb_data</span><span class="p">.</span><span class="n">any_dev_free_scb_list</span><span class="p">,</span>
				 <span class="n">scb</span><span class="p">,</span> <span class="n">links</span><span class="p">.</span><span class="n">le</span><span class="p">);</span>
		<span class="n">LIST_INSERT_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">scb_data</span><span class="p">.</span><span class="n">any_dev_free_scb_list</span><span class="p">,</span>
				 <span class="n">scb</span><span class="o">-&gt;</span><span class="n">col_scb</span><span class="p">,</span> <span class="n">links</span><span class="p">.</span><span class="n">le</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">col_scb</span><span class="o">-&gt;</span><span class="n">flags</span>
		  <span class="o">&amp;</span> <span class="p">(</span><span class="n">SCB_PACKETIZED</span><span class="o">|</span><span class="n">SCB_ACTIVE</span><span class="p">))</span> <span class="o">==</span> <span class="n">SCB_ACTIVE</span>
		<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">col_scb</span><span class="o">-&gt;</span><span class="n">hscb</span><span class="o">-&gt;</span><span class="n">control</span> <span class="o">&amp;</span> <span class="n">TAG_ENB</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/*</span>
<span class="cm">		 * The SCB we might collide with on the next allocation</span>
<span class="cm">		 * is still active in a non-packetized, tagged, context.</span>
<span class="cm">		 * Put us on the SCB collision list.</span>
<span class="cm">		 */</span>
		<span class="n">ahd_add_col_list</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">,</span>
				 <span class="n">AHD_GET_SCB_COL_IDX</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">col_scb</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The SCB we might collide with on the next allocation</span>
<span class="cm">		 * is either active in a packetized context, or free.</span>
<span class="cm">		 * Since we can&#39;t collide, put this SCB on the generic</span>
<span class="cm">		 * free list.</span>
<span class="cm">		 */</span>
		<span class="n">LIST_INSERT_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">scb_data</span><span class="p">.</span><span class="n">any_dev_free_scb_list</span><span class="p">,</span>
				 <span class="n">scb</span><span class="p">,</span> <span class="n">links</span><span class="p">.</span><span class="n">le</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ahd_platform_scb_free</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_alloc_scbs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scb_data</span> <span class="o">*</span><span class="n">scb_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scb</span>	<span class="o">*</span><span class="n">next_scb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hardware_scb</span> <span class="o">*</span><span class="n">hscb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">map_node</span> <span class="o">*</span><span class="n">hscb_map</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">map_node</span> <span class="o">*</span><span class="n">sg_map</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">map_node</span> <span class="o">*</span><span class="n">sense_map</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="o">*</span><span class="n">segs</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="o">*</span><span class="n">sense_data</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>	 <span class="n">hscb_busaddr</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>	 <span class="n">sg_busaddr</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>	 <span class="n">sense_busaddr</span><span class="p">;</span>
	<span class="kt">int</span>		 <span class="n">newcount</span><span class="p">;</span>
	<span class="kt">int</span>		 <span class="n">i</span><span class="p">;</span>

	<span class="n">scb_data</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">scb_data</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">scb_data</span><span class="o">-&gt;</span><span class="n">numscbs</span> <span class="o">&gt;=</span> <span class="n">AHD_SCB_MAX_ALLOC</span><span class="p">)</span>
		<span class="cm">/* Can&#39;t allocate any more */</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">scb_data</span><span class="o">-&gt;</span><span class="n">scbs_left</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">offset</span><span class="p">;</span>

		<span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">hscb</span><span class="p">))</span> <span class="o">-</span> <span class="n">scb_data</span><span class="o">-&gt;</span><span class="n">scbs_left</span><span class="p">;</span>
		<span class="n">hscb_map</span> <span class="o">=</span> <span class="n">SLIST_FIRST</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scb_data</span><span class="o">-&gt;</span><span class="n">hscb_maps</span><span class="p">);</span>
		<span class="n">hscb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">((</span><span class="k">struct</span> <span class="n">hardware_scb</span> <span class="o">*</span><span class="p">)</span><span class="n">hscb_map</span><span class="o">-&gt;</span><span class="n">vaddr</span><span class="p">)[</span><span class="n">offset</span><span class="p">];</span>
		<span class="n">hscb_busaddr</span> <span class="o">=</span> <span class="n">hscb_map</span><span class="o">-&gt;</span><span class="n">physaddr</span> <span class="o">+</span> <span class="p">(</span><span class="n">offset</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">hscb</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">hscb_map</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">hscb_map</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">hscb_map</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="cm">/* Allocate the next batch of hardware SCBs */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ahd_dmamem_alloc</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb_data</span><span class="o">-&gt;</span><span class="n">hscb_dmat</span><span class="p">,</span>
				     <span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">hscb_map</span><span class="o">-&gt;</span><span class="n">vaddr</span><span class="p">,</span>
				     <span class="n">BUS_DMA_NOWAIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hscb_map</span><span class="o">-&gt;</span><span class="n">dmamap</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">hscb_map</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">SLIST_INSERT_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scb_data</span><span class="o">-&gt;</span><span class="n">hscb_maps</span><span class="p">,</span> <span class="n">hscb_map</span><span class="p">,</span> <span class="n">links</span><span class="p">);</span>

		<span class="n">ahd_dmamap_load</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb_data</span><span class="o">-&gt;</span><span class="n">hscb_dmat</span><span class="p">,</span> <span class="n">hscb_map</span><span class="o">-&gt;</span><span class="n">dmamap</span><span class="p">,</span>
				<span class="n">hscb_map</span><span class="o">-&gt;</span><span class="n">vaddr</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">ahd_dmamap_cb</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">hscb_map</span><span class="o">-&gt;</span><span class="n">physaddr</span><span class="p">,</span> <span class="cm">/*flags*/</span><span class="mi">0</span><span class="p">);</span>

		<span class="n">hscb</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">hardware_scb</span> <span class="o">*</span><span class="p">)</span><span class="n">hscb_map</span><span class="o">-&gt;</span><span class="n">vaddr</span><span class="p">;</span>
		<span class="n">hscb_busaddr</span> <span class="o">=</span> <span class="n">hscb_map</span><span class="o">-&gt;</span><span class="n">physaddr</span><span class="p">;</span>
		<span class="n">scb_data</span><span class="o">-&gt;</span><span class="n">scbs_left</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">hscb</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">scb_data</span><span class="o">-&gt;</span><span class="n">sgs_left</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">offset</span><span class="p">;</span>

		<span class="n">offset</span> <span class="o">=</span> <span class="p">((</span><span class="n">ahd_sglist_allocsize</span><span class="p">(</span><span class="n">ahd</span><span class="p">)</span> <span class="o">/</span> <span class="n">ahd_sglist_size</span><span class="p">(</span><span class="n">ahd</span><span class="p">))</span>
		       <span class="o">-</span> <span class="n">scb_data</span><span class="o">-&gt;</span><span class="n">sgs_left</span><span class="p">)</span> <span class="o">*</span> <span class="n">ahd_sglist_size</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
		<span class="n">sg_map</span> <span class="o">=</span> <span class="n">SLIST_FIRST</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scb_data</span><span class="o">-&gt;</span><span class="n">sg_maps</span><span class="p">);</span>
		<span class="n">segs</span> <span class="o">=</span> <span class="n">sg_map</span><span class="o">-&gt;</span><span class="n">vaddr</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
		<span class="n">sg_busaddr</span> <span class="o">=</span> <span class="n">sg_map</span><span class="o">-&gt;</span><span class="n">physaddr</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">sg_map</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">sg_map</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sg_map</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="cm">/* Allocate the next batch of S/G lists */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ahd_dmamem_alloc</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb_data</span><span class="o">-&gt;</span><span class="n">sg_dmat</span><span class="p">,</span>
				     <span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sg_map</span><span class="o">-&gt;</span><span class="n">vaddr</span><span class="p">,</span>
				     <span class="n">BUS_DMA_NOWAIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sg_map</span><span class="o">-&gt;</span><span class="n">dmamap</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">sg_map</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">SLIST_INSERT_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scb_data</span><span class="o">-&gt;</span><span class="n">sg_maps</span><span class="p">,</span> <span class="n">sg_map</span><span class="p">,</span> <span class="n">links</span><span class="p">);</span>

		<span class="n">ahd_dmamap_load</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb_data</span><span class="o">-&gt;</span><span class="n">sg_dmat</span><span class="p">,</span> <span class="n">sg_map</span><span class="o">-&gt;</span><span class="n">dmamap</span><span class="p">,</span>
				<span class="n">sg_map</span><span class="o">-&gt;</span><span class="n">vaddr</span><span class="p">,</span> <span class="n">ahd_sglist_allocsize</span><span class="p">(</span><span class="n">ahd</span><span class="p">),</span>
				<span class="n">ahd_dmamap_cb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sg_map</span><span class="o">-&gt;</span><span class="n">physaddr</span><span class="p">,</span> <span class="cm">/*flags*/</span><span class="mi">0</span><span class="p">);</span>

		<span class="n">segs</span> <span class="o">=</span> <span class="n">sg_map</span><span class="o">-&gt;</span><span class="n">vaddr</span><span class="p">;</span>
		<span class="n">sg_busaddr</span> <span class="o">=</span> <span class="n">sg_map</span><span class="o">-&gt;</span><span class="n">physaddr</span><span class="p">;</span>
		<span class="n">scb_data</span><span class="o">-&gt;</span><span class="n">sgs_left</span> <span class="o">=</span>
		    <span class="n">ahd_sglist_allocsize</span><span class="p">(</span><span class="n">ahd</span><span class="p">)</span> <span class="o">/</span> <span class="n">ahd_sglist_size</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
<span class="cp">#ifdef AHD_DEBUG</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ahd_debug</span> <span class="o">&amp;</span> <span class="n">AHD_SHOW_MEMORY</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Mapped SG data</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">scb_data</span><span class="o">-&gt;</span><span class="n">sense_left</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">offset</span><span class="p">;</span>

		<span class="n">offset</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="p">(</span><span class="n">AHD_SENSE_BUFSIZE</span> <span class="o">*</span> <span class="n">scb_data</span><span class="o">-&gt;</span><span class="n">sense_left</span><span class="p">);</span>
		<span class="n">sense_map</span> <span class="o">=</span> <span class="n">SLIST_FIRST</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scb_data</span><span class="o">-&gt;</span><span class="n">sense_maps</span><span class="p">);</span>
		<span class="n">sense_data</span> <span class="o">=</span> <span class="n">sense_map</span><span class="o">-&gt;</span><span class="n">vaddr</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
		<span class="n">sense_busaddr</span> <span class="o">=</span> <span class="n">sense_map</span><span class="o">-&gt;</span><span class="n">physaddr</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">sense_map</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">sense_map</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sense_map</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="cm">/* Allocate the next batch of sense buffers */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ahd_dmamem_alloc</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb_data</span><span class="o">-&gt;</span><span class="n">sense_dmat</span><span class="p">,</span>
				     <span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sense_map</span><span class="o">-&gt;</span><span class="n">vaddr</span><span class="p">,</span>
				     <span class="n">BUS_DMA_NOWAIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sense_map</span><span class="o">-&gt;</span><span class="n">dmamap</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">sense_map</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">SLIST_INSERT_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scb_data</span><span class="o">-&gt;</span><span class="n">sense_maps</span><span class="p">,</span> <span class="n">sense_map</span><span class="p">,</span> <span class="n">links</span><span class="p">);</span>

		<span class="n">ahd_dmamap_load</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb_data</span><span class="o">-&gt;</span><span class="n">sense_dmat</span><span class="p">,</span> <span class="n">sense_map</span><span class="o">-&gt;</span><span class="n">dmamap</span><span class="p">,</span>
				<span class="n">sense_map</span><span class="o">-&gt;</span><span class="n">vaddr</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">ahd_dmamap_cb</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">sense_map</span><span class="o">-&gt;</span><span class="n">physaddr</span><span class="p">,</span> <span class="cm">/*flags*/</span><span class="mi">0</span><span class="p">);</span>

		<span class="n">sense_data</span> <span class="o">=</span> <span class="n">sense_map</span><span class="o">-&gt;</span><span class="n">vaddr</span><span class="p">;</span>
		<span class="n">sense_busaddr</span> <span class="o">=</span> <span class="n">sense_map</span><span class="o">-&gt;</span><span class="n">physaddr</span><span class="p">;</span>
		<span class="n">scb_data</span><span class="o">-&gt;</span><span class="n">sense_left</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span> <span class="o">/</span> <span class="n">AHD_SENSE_BUFSIZE</span><span class="p">;</span>
<span class="cp">#ifdef AHD_DEBUG</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ahd_debug</span> <span class="o">&amp;</span> <span class="n">AHD_SHOW_MEMORY</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Mapped sense data</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="p">}</span>

	<span class="n">newcount</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">scb_data</span><span class="o">-&gt;</span><span class="n">sense_left</span><span class="p">,</span> <span class="n">scb_data</span><span class="o">-&gt;</span><span class="n">scbs_left</span><span class="p">);</span>
	<span class="n">newcount</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">newcount</span><span class="p">,</span> <span class="n">scb_data</span><span class="o">-&gt;</span><span class="n">sgs_left</span><span class="p">);</span>
	<span class="n">newcount</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">newcount</span><span class="p">,</span> <span class="p">(</span><span class="n">AHD_SCB_MAX_ALLOC</span> <span class="o">-</span> <span class="n">scb_data</span><span class="o">-&gt;</span><span class="n">numscbs</span><span class="p">));</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">newcount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">scb_platform_data</span> <span class="o">*</span><span class="n">pdata</span><span class="p">;</span>
		<span class="n">u_int</span> <span class="n">col_tag</span><span class="p">;</span>
<span class="cp">#ifndef __linux__</span>
		<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
<span class="cp">#endif</span>

		<span class="n">next_scb</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">next_scb</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">next_scb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">pdata</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">pdata</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pdata</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">next_scb</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">next_scb</span><span class="o">-&gt;</span><span class="n">platform_data</span> <span class="o">=</span> <span class="n">pdata</span><span class="p">;</span>
		<span class="n">next_scb</span><span class="o">-&gt;</span><span class="n">hscb_map</span> <span class="o">=</span> <span class="n">hscb_map</span><span class="p">;</span>
		<span class="n">next_scb</span><span class="o">-&gt;</span><span class="n">sg_map</span> <span class="o">=</span> <span class="n">sg_map</span><span class="p">;</span>
		<span class="n">next_scb</span><span class="o">-&gt;</span><span class="n">sense_map</span> <span class="o">=</span> <span class="n">sense_map</span><span class="p">;</span>
		<span class="n">next_scb</span><span class="o">-&gt;</span><span class="n">sg_list</span> <span class="o">=</span> <span class="n">segs</span><span class="p">;</span>
		<span class="n">next_scb</span><span class="o">-&gt;</span><span class="n">sense_data</span> <span class="o">=</span> <span class="n">sense_data</span><span class="p">;</span>
		<span class="n">next_scb</span><span class="o">-&gt;</span><span class="n">sense_busaddr</span> <span class="o">=</span> <span class="n">sense_busaddr</span><span class="p">;</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">hscb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">hscb</span><span class="p">));</span>
		<span class="n">next_scb</span><span class="o">-&gt;</span><span class="n">hscb</span> <span class="o">=</span> <span class="n">hscb</span><span class="p">;</span>
		<span class="n">hscb</span><span class="o">-&gt;</span><span class="n">hscb_busaddr</span> <span class="o">=</span> <span class="n">ahd_htole32</span><span class="p">(</span><span class="n">hscb_busaddr</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * The sequencer always starts with the second entry.</span>
<span class="cm">		 * The first entry is embedded in the scb.</span>
<span class="cm">		 */</span>
		<span class="n">next_scb</span><span class="o">-&gt;</span><span class="n">sg_list_busaddr</span> <span class="o">=</span> <span class="n">sg_busaddr</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AHD_64BIT_ADDRESSING</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">next_scb</span><span class="o">-&gt;</span><span class="n">sg_list_busaddr</span>
			    <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_dma64_seg</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">next_scb</span><span class="o">-&gt;</span><span class="n">sg_list_busaddr</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_dma_seg</span><span class="p">);</span>
		<span class="n">next_scb</span><span class="o">-&gt;</span><span class="n">ahd_softc</span> <span class="o">=</span> <span class="n">ahd</span><span class="p">;</span>
		<span class="n">next_scb</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">SCB_FLAG_NONE</span><span class="p">;</span>
<span class="cp">#ifndef __linux__</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">ahd_dmamap_create</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">buffer_dmat</span><span class="p">,</span> <span class="cm">/*flags*/</span><span class="mi">0</span><span class="p">,</span>
					  <span class="o">&amp;</span><span class="n">next_scb</span><span class="o">-&gt;</span><span class="n">dmamap</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">next_scb</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">pdata</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
<span class="cp">#endif</span>
		<span class="n">next_scb</span><span class="o">-&gt;</span><span class="n">hscb</span><span class="o">-&gt;</span><span class="n">tag</span> <span class="o">=</span> <span class="n">ahd_htole16</span><span class="p">(</span><span class="n">scb_data</span><span class="o">-&gt;</span><span class="n">numscbs</span><span class="p">);</span>
		<span class="n">col_tag</span> <span class="o">=</span> <span class="n">scb_data</span><span class="o">-&gt;</span><span class="n">numscbs</span> <span class="o">^</span> <span class="mh">0x100</span><span class="p">;</span>
		<span class="n">next_scb</span><span class="o">-&gt;</span><span class="n">col_scb</span> <span class="o">=</span> <span class="n">ahd_find_scb_by_tag</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">col_tag</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">next_scb</span><span class="o">-&gt;</span><span class="n">col_scb</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">next_scb</span><span class="o">-&gt;</span><span class="n">col_scb</span><span class="o">-&gt;</span><span class="n">col_scb</span> <span class="o">=</span> <span class="n">next_scb</span><span class="p">;</span>
		<span class="n">ahd_free_scb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">next_scb</span><span class="p">);</span>
		<span class="n">hscb</span><span class="o">++</span><span class="p">;</span>
		<span class="n">hscb_busaddr</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">hscb</span><span class="p">);</span>
		<span class="n">segs</span> <span class="o">+=</span> <span class="n">ahd_sglist_size</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
		<span class="n">sg_busaddr</span> <span class="o">+=</span> <span class="n">ahd_sglist_size</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
		<span class="n">sense_data</span> <span class="o">+=</span> <span class="n">AHD_SENSE_BUFSIZE</span><span class="p">;</span>
		<span class="n">sense_busaddr</span> <span class="o">+=</span> <span class="n">AHD_SENSE_BUFSIZE</span><span class="p">;</span>
		<span class="n">scb_data</span><span class="o">-&gt;</span><span class="n">numscbs</span><span class="o">++</span><span class="p">;</span>
		<span class="n">scb_data</span><span class="o">-&gt;</span><span class="n">sense_left</span><span class="o">--</span><span class="p">;</span>
		<span class="n">scb_data</span><span class="o">-&gt;</span><span class="n">scbs_left</span><span class="o">--</span><span class="p">;</span>
		<span class="n">scb_data</span><span class="o">-&gt;</span><span class="n">sgs_left</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">ahd_controller_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">speed</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">type</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%s: &quot;</span><span class="p">,</span> <span class="n">ahd_chip_names</span><span class="p">[</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">chip</span> <span class="o">&amp;</span> <span class="n">AHD_CHIPID_MASK</span><span class="p">]);</span>
	<span class="n">buf</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>

	<span class="n">speed</span> <span class="o">=</span> <span class="s">&quot;Ultra320 &quot;</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">AHD_WIDE</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">type</span> <span class="o">=</span> <span class="s">&quot;Wide &quot;</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">type</span> <span class="o">=</span> <span class="s">&quot;Single &quot;</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%s%sChannel %c, SCSI Id=%d, &quot;</span><span class="p">,</span>
		      <span class="n">speed</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">our_id</span><span class="p">);</span>
	<span class="n">buf</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>

	<span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%s, %d SCBs&quot;</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">bus_description</span><span class="p">,</span>
		<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">scb_data</span><span class="p">.</span><span class="n">maxhscbs</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">channel_strings</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="s">&quot;Primary Low&quot;</span><span class="p">,</span>
	<span class="s">&quot;Primary High&quot;</span><span class="p">,</span>
	<span class="s">&quot;Secondary Low&quot;</span><span class="p">,</span> 
	<span class="s">&quot;Secondary High&quot;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">termstat_strings</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="s">&quot;Terminated Correctly&quot;</span><span class="p">,</span>
	<span class="s">&quot;Over Terminated&quot;</span><span class="p">,</span>
	<span class="s">&quot;Under Terminated&quot;</span><span class="p">,</span>
	<span class="s">&quot;Not Configured&quot;</span>
<span class="p">};</span>

<span class="cm">/***************************** Timer Facilities *******************************/</span>
<span class="cp">#define ahd_timer_init init_timer</span>
<span class="cp">#define ahd_timer_stop del_timer_sync</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="n">ahd_linux_callback_t</span> <span class="p">(</span><span class="n">u_long</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_timer_reset</span><span class="p">(</span><span class="n">ahd_timer_t</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">usec</span><span class="p">,</span> <span class="n">ahd_callback_t</span> <span class="o">*</span><span class="n">func</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">;</span>

	<span class="n">ahd</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
	<span class="n">del_timer</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
	<span class="n">timer</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="n">u_long</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
	<span class="n">timer</span><span class="o">-&gt;</span><span class="n">expires</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="p">(</span><span class="n">usec</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">)</span><span class="o">/</span><span class="mi">1000000</span><span class="p">;</span>
	<span class="n">timer</span><span class="o">-&gt;</span><span class="n">function</span> <span class="o">=</span> <span class="p">(</span><span class="n">ahd_linux_callback_t</span><span class="o">*</span><span class="p">)</span><span class="n">func</span><span class="p">;</span>
	<span class="n">add_timer</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Start the board, ready for normal operation</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">ahd_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint8_t</span>		<span class="o">*</span><span class="n">next_vaddr</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>	 <span class="n">next_baddr</span><span class="p">;</span>
	<span class="kt">size_t</span>		 <span class="n">driver_data_size</span><span class="p">;</span>
	<span class="kt">int</span>		 <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span>		 <span class="n">error</span><span class="p">;</span>
	<span class="n">u_int</span>		 <span class="n">warn_user</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		 <span class="n">current_sensing</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		 <span class="n">fstat</span><span class="p">;</span>

	<span class="n">AHD_ASSERT_MODES</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI_MSK</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI_MSK</span><span class="p">);</span>

	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">stack_size</span> <span class="o">=</span> <span class="n">ahd_probe_stack_size</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">saved_stack</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">stack_size</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint16_t</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">saved_stack</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">ENOMEM</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Verify that the compiler hasn&#39;t over-aggressively</span>
<span class="cm">	 * padded important structures.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hardware_scb</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">64</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Hardware SCB size is incorrect&quot;</span><span class="p">);</span>

<span class="cp">#ifdef AHD_DEBUG</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ahd_debug</span> <span class="o">&amp;</span> <span class="n">AHD_DEBUG_SEQUENCER</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">AHD_SEQUENCER_DEBUG</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 * Default to allowing initiator operations.</span>
<span class="cm">	 */</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">AHD_INITIATORROLE</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Only allow target mode features if this unit has them enabled.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">AHD_TMODE_ENABLE</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mh">0x1</span> <span class="o">&lt;&lt;</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">unit</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">AHD_TARGETMODE</span><span class="p">;</span>

<span class="cp">#ifndef __linux__</span>
	<span class="cm">/* DMA tag for mapping buffers into device visible space. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ahd_dma_tag_create</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">parent_dmat</span><span class="p">,</span> <span class="cm">/*alignment*/</span><span class="mi">1</span><span class="p">,</span>
			       <span class="cm">/*boundary*/</span><span class="n">BUS_SPACE_MAXADDR_32BIT</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
			       <span class="cm">/*lowaddr*/</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AHD_39BIT_ADDRESSING</span>
					<span class="o">?</span> <span class="p">(</span><span class="n">dma_addr_t</span><span class="p">)</span><span class="mh">0x7FFFFFFFFFULL</span>
					<span class="o">:</span> <span class="n">BUS_SPACE_MAXADDR_32BIT</span><span class="p">,</span>
			       <span class="cm">/*highaddr*/</span><span class="n">BUS_SPACE_MAXADDR</span><span class="p">,</span>
			       <span class="cm">/*filter*/</span><span class="nb">NULL</span><span class="p">,</span> <span class="cm">/*filterarg*/</span><span class="nb">NULL</span><span class="p">,</span>
			       <span class="cm">/*maxsize*/</span><span class="p">(</span><span class="n">AHD_NSEG</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">,</span>
			       <span class="cm">/*nsegments*/</span><span class="n">AHD_NSEG</span><span class="p">,</span>
			       <span class="cm">/*maxsegsz*/</span><span class="n">AHD_MAXTRANSFER_SIZE</span><span class="p">,</span>
			       <span class="cm">/*flags*/</span><span class="n">BUS_DMA_ALLOCNOW</span><span class="p">,</span>
			       <span class="o">&amp;</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">buffer_dmat</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">ENOMEM</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">init_level</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * DMA tag for our command fifos and other data in system memory</span>
<span class="cm">	 * the card&#39;s sequencer must be able to access.  For initiator</span>
<span class="cm">	 * roles, we need to allocate space for the qoutfifo.  When providing</span>
<span class="cm">	 * for the target mode role, we must additionally provide space for</span>
<span class="cm">	 * the incoming target command fifo.</span>
<span class="cm">	 */</span>
	<span class="n">driver_data_size</span> <span class="o">=</span> <span class="n">AHD_SCB_MAX</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">qoutfifo</span><span class="p">)</span>
			 <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hardware_scb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">AHD_TARGETMODE</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">driver_data_size</span> <span class="o">+=</span> <span class="n">AHD_TMODE_CMDS</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">target_cmd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">bugs</span> <span class="o">&amp;</span> <span class="n">AHD_PKT_BITBUCKET_BUG</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">driver_data_size</span> <span class="o">+=</span> <span class="n">PKT_OVERRUN_BUFSIZE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ahd_dma_tag_create</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">parent_dmat</span><span class="p">,</span> <span class="cm">/*alignment*/</span><span class="mi">1</span><span class="p">,</span>
			       <span class="cm">/*boundary*/</span><span class="n">BUS_SPACE_MAXADDR_32BIT</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
			       <span class="cm">/*lowaddr*/</span><span class="n">BUS_SPACE_MAXADDR_32BIT</span><span class="p">,</span>
			       <span class="cm">/*highaddr*/</span><span class="n">BUS_SPACE_MAXADDR</span><span class="p">,</span>
			       <span class="cm">/*filter*/</span><span class="nb">NULL</span><span class="p">,</span> <span class="cm">/*filterarg*/</span><span class="nb">NULL</span><span class="p">,</span>
			       <span class="n">driver_data_size</span><span class="p">,</span>
			       <span class="cm">/*nsegments*/</span><span class="mi">1</span><span class="p">,</span>
			       <span class="cm">/*maxsegsz*/</span><span class="n">BUS_SPACE_MAXSIZE_32BIT</span><span class="p">,</span>
			       <span class="cm">/*flags*/</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">shared_data_dmat</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">ENOMEM</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">init_level</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* Allocation of driver data */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ahd_dmamem_alloc</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">shared_data_dmat</span><span class="p">,</span>
			     <span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">shared_data_map</span><span class="p">.</span><span class="n">vaddr</span><span class="p">,</span>
			     <span class="n">BUS_DMA_NOWAIT</span><span class="p">,</span>
			     <span class="o">&amp;</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">shared_data_map</span><span class="p">.</span><span class="n">dmamap</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">ENOMEM</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">init_level</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* And permanently map it in */</span>
	<span class="n">ahd_dmamap_load</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">shared_data_dmat</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">shared_data_map</span><span class="p">.</span><span class="n">dmamap</span><span class="p">,</span>
			<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">shared_data_map</span><span class="p">.</span><span class="n">vaddr</span><span class="p">,</span> <span class="n">driver_data_size</span><span class="p">,</span>
			<span class="n">ahd_dmamap_cb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">shared_data_map</span><span class="p">.</span><span class="n">physaddr</span><span class="p">,</span>
			<span class="cm">/*flags*/</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">qoutfifo</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ahd_completion</span> <span class="o">*</span><span class="p">)</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">shared_data_map</span><span class="p">.</span><span class="n">vaddr</span><span class="p">;</span>
	<span class="n">next_vaddr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">qoutfifo</span><span class="p">[</span><span class="n">AHD_QOUT_SIZE</span><span class="p">];</span>
	<span class="n">next_baddr</span> <span class="o">=</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">shared_data_map</span><span class="p">.</span><span class="n">physaddr</span>
		   <span class="o">+</span> <span class="n">AHD_QOUT_SIZE</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_completion</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">AHD_TARGETMODE</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">targetcmds</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">target_cmd</span> <span class="o">*</span><span class="p">)</span><span class="n">next_vaddr</span><span class="p">;</span>
		<span class="n">next_vaddr</span> <span class="o">+=</span> <span class="n">AHD_TMODE_CMDS</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">target_cmd</span><span class="p">);</span>
		<span class="n">next_baddr</span> <span class="o">+=</span> <span class="n">AHD_TMODE_CMDS</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">target_cmd</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">bugs</span> <span class="o">&amp;</span> <span class="n">AHD_PKT_BITBUCKET_BUG</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">overrun_buf</span> <span class="o">=</span> <span class="n">next_vaddr</span><span class="p">;</span>
		<span class="n">next_vaddr</span> <span class="o">+=</span> <span class="n">PKT_OVERRUN_BUFSIZE</span><span class="p">;</span>
		<span class="n">next_baddr</span> <span class="o">+=</span> <span class="n">PKT_OVERRUN_BUFSIZE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We need one SCB to serve as the &quot;next SCB&quot;.  Since the</span>
<span class="cm">	 * tag identifier in this SCB will never be used, there is</span>
<span class="cm">	 * no point in using a valid HSCB tag from an SCB pulled from</span>
<span class="cm">	 * the standard free pool.  So, we allocate this &quot;sentinel&quot;</span>
<span class="cm">	 * specially from the DMA safe memory chunk used for the QOUTFIFO.</span>
<span class="cm">	 */</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">next_queued_hscb</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">hardware_scb</span> <span class="o">*</span><span class="p">)</span><span class="n">next_vaddr</span><span class="p">;</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">next_queued_hscb_map</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">shared_data_map</span><span class="p">;</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">next_queued_hscb</span><span class="o">-&gt;</span><span class="n">hscb_busaddr</span> <span class="o">=</span> <span class="n">ahd_htole32</span><span class="p">(</span><span class="n">next_baddr</span><span class="p">);</span>

	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">init_level</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* Allocate SCB data now that buffer_dmat is initialized */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ahd_init_scbdata</span><span class="p">(</span><span class="n">ahd</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">ENOMEM</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AHD_INITIATORROLE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">AHD_RESET_BUS_A</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Before committing these settings to the chip, give</span>
<span class="cm">	 * the OSM one last chance to modify our configuration.</span>
<span class="cm">	 */</span>
	<span class="n">ahd_platform_init</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>

	<span class="cm">/* Bring up the chip. */</span>
	<span class="n">ahd_chip_init</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>

	<span class="n">AHD_ASSERT_MODES</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI_MSK</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI_MSK</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AHD_CURRENT_SENSING</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">init_done</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Verify termination based on current draw and</span>
<span class="cm">	 * warn user if the bus is over/under terminated.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">ahd_write_flexport</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">FLXADDR_ROMSTAT_CURSENSECTL</span><span class="p">,</span>
				   <span class="n">CURSENSE_ENB</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: current sensing timeout 1</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">));</span>
		<span class="k">goto</span> <span class="n">init_done</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span> <span class="n">fstat</span> <span class="o">=</span> <span class="n">FLX_FSTAT_BUSY</span><span class="p">;</span>
	     <span class="p">(</span><span class="n">fstat</span> <span class="o">&amp;</span> <span class="n">FLX_FSTAT_BUSY</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">i</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">ahd_read_flexport</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">FLXADDR_FLEXSTAT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fstat</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: current sensing timeout 2</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">));</span>
			<span class="k">goto</span> <span class="n">init_done</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: Timedout during current-sensing test</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">));</span>
		<span class="k">goto</span> <span class="n">init_done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Latch Current Sensing status. */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">ahd_read_flexport</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">FLXADDR_CURRENT_STAT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">current_sensing</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: current sensing timeout 3</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">));</span>
		<span class="k">goto</span> <span class="n">init_done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Diable current sensing. */</span>
	<span class="n">ahd_write_flexport</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">FLXADDR_ROMSTAT_CURSENSECTL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="cp">#ifdef AHD_DEBUG</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ahd_debug</span> <span class="o">&amp;</span> <span class="n">AHD_SHOW_TERMCTL</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: current_sensing == 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">),</span> <span class="n">current_sensing</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="n">warn_user</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">current_sensing</span> <span class="o">&gt;&gt;=</span> <span class="n">FLX_CSTAT_SHIFT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u_int</span> <span class="n">term_stat</span><span class="p">;</span>

		<span class="n">term_stat</span> <span class="o">=</span> <span class="p">(</span><span class="n">current_sensing</span> <span class="o">&amp;</span> <span class="n">FLX_CSTAT_MASK</span><span class="p">);</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">term_stat</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">FLX_CSTAT_OVER</span>:
		<span class="k">case</span> <span class="n">FLX_CSTAT_UNDER</span>:
			<span class="n">warn_user</span><span class="o">++</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">FLX_CSTAT_INVALID</span>:
		<span class="k">case</span> <span class="n">FLX_CSTAT_OKAY</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">warn_user</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">bootverbose</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: %s Channel %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">),</span>
			       <span class="n">channel_strings</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">termstat_strings</span><span class="p">[</span><span class="n">term_stat</span><span class="p">]);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">warn_user</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: WARNING. Termination is not configured correctly.</span><span class="se">\n</span><span class="s">&quot;</span>
		       <span class="s">&quot;%s: WARNING. SCSI bus operations may FAIL.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">),</span> <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">));</span>
	<span class="p">}</span>
<span class="nl">init_done:</span>
	<span class="n">ahd_restart</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
	<span class="n">ahd_timer_reset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">stat_timer</span><span class="p">,</span> <span class="n">AHD_STAT_UPDATE_US</span><span class="p">,</span>
			<span class="n">ahd_stat_timer</span><span class="p">,</span> <span class="n">ahd</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * (Re)initialize chip state after a chip reset.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_chip_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">busaddr</span><span class="p">;</span>
	<span class="n">u_int</span>	 <span class="n">sxfrctl1</span><span class="p">;</span>
	<span class="n">u_int</span>	 <span class="n">scsiseq_template</span><span class="p">;</span>
	<span class="n">u_int</span>	 <span class="n">wait</span><span class="p">;</span>
	<span class="n">u_int</span>	 <span class="n">i</span><span class="p">;</span>
	<span class="n">u_int</span>	 <span class="n">target</span><span class="p">;</span>

	<span class="n">ahd_set_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Take the LED out of diagnostic mode</span>
<span class="cm">	 */</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SBLKCTL</span><span class="p">,</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SBLKCTL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">DIAGLEDEN</span><span class="o">|</span><span class="n">DIAGLEDON</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Return HS_MAILBOX to its default value.</span>
<span class="cm">	 */</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">hs_mailbox</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">HS_MAILBOX</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Set the SCSI Id, SXFRCTL0, SXFRCTL1, and SIMODE1. */</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">IOWNID</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">our_id</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">TOWNID</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">our_id</span><span class="p">);</span>
	<span class="n">sxfrctl1</span> <span class="o">=</span> <span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AHD_TERM_ENB_A</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">STPWEN</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sxfrctl1</span> <span class="o">|=</span> <span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AHD_SPCHK_ENB_A</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">ENSPCHK</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">bugs</span> <span class="o">&amp;</span> <span class="n">AHD_LONG_SETIMO_BUG</span><span class="p">)</span>
	 <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">seltime</span> <span class="o">!=</span> <span class="n">STIMESEL_MIN</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The selection timer duration is twice as long</span>
<span class="cm">		 * as it should be.  Halve it by adding &quot;1&quot; to</span>
<span class="cm">		 * the user specified setting.</span>
<span class="cm">		 */</span>
		<span class="n">sxfrctl1</span> <span class="o">|=</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">seltime</span> <span class="o">+</span> <span class="n">STIMESEL_BUG_ADJ</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">sxfrctl1</span> <span class="o">|=</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">seltime</span><span class="p">;</span>
	<span class="p">}</span>
		
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SXFRCTL0</span><span class="p">,</span> <span class="n">DFON</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SXFRCTL1</span><span class="p">,</span> <span class="n">sxfrctl1</span><span class="o">|</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">seltime</span><span class="o">|</span><span class="n">ENSTIMER</span><span class="o">|</span><span class="n">ACTNEGEN</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SIMODE1</span><span class="p">,</span> <span class="n">ENSELTIMO</span><span class="o">|</span><span class="n">ENSCSIRST</span><span class="o">|</span><span class="n">ENSCSIPERR</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now that termination is set, wait for up</span>
<span class="cm">	 * to 500ms for our transceivers to settle.  If</span>
<span class="cm">	 * the adapter does not have a cable attached,</span>
<span class="cm">	 * the transceivers may never settle, so don&#39;t</span>
<span class="cm">	 * complain if we fail here.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">wait</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">;</span>
	     <span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SBLKCTL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ENAB40</span><span class="o">|</span><span class="n">ENAB20</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">wait</span><span class="p">;</span>
	     <span class="n">wait</span><span class="o">--</span><span class="p">)</span>
		<span class="n">ahd_delay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>

	<span class="cm">/* Clear any false bus resets due to the transceivers settling */</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CLRSINT1</span><span class="p">,</span> <span class="n">CLRSCSIRSTI</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CLRINT</span><span class="p">,</span> <span class="n">CLRSCSIINT</span><span class="p">);</span>

	<span class="cm">/* Initialize mode specific S/G state. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ahd_set_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHD_MODE_DFF0</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">AHD_MODE_DFF0</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">LONGJMP_ADDR</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">INVALID_ADDR</span><span class="p">);</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SG_STATE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CLRSEQINTSRC</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">);</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SEQIMODE</span><span class="p">,</span>
			 <span class="n">ENSAVEPTRS</span><span class="o">|</span><span class="n">ENCFG4DATA</span><span class="o">|</span><span class="n">ENCFG4ISTAT</span>
			<span class="o">|</span><span class="n">ENCFG4TSTAT</span><span class="o">|</span><span class="n">ENCFG4ICMD</span><span class="o">|</span><span class="n">ENCFG4TCMD</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ahd_set_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHD_MODE_CFG</span><span class="p">,</span> <span class="n">AHD_MODE_CFG</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">DSCOMMAND0</span><span class="p">,</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">DSCOMMAND0</span><span class="p">)</span><span class="o">|</span><span class="n">MPARCKEN</span><span class="o">|</span><span class="n">CACHETHEN</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">DFF_THRSH</span><span class="p">,</span> <span class="n">RD_DFTHRSH_75</span><span class="o">|</span><span class="n">WR_DFTHRSH_75</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SIMODE0</span><span class="p">,</span> <span class="n">ENIOERR</span><span class="o">|</span><span class="n">ENOVERRUN</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SIMODE3</span><span class="p">,</span> <span class="n">ENNTRAMPERR</span><span class="o">|</span><span class="n">ENOSRAMPERR</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">bugs</span> <span class="o">&amp;</span> <span class="n">AHD_BUSFREEREV_BUG</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">OPTIONMODE</span><span class="p">,</span> <span class="n">AUTOACKEN</span><span class="o">|</span><span class="n">AUTO_MSGOUT_DE</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">OPTIONMODE</span><span class="p">,</span> <span class="n">AUTOACKEN</span><span class="o">|</span><span class="n">BUSFREEREV</span><span class="o">|</span><span class="n">AUTO_MSGOUT_DE</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCSCHKN</span><span class="p">,</span> <span class="n">CURRFIFODEF</span><span class="o">|</span><span class="n">WIDERESEN</span><span class="o">|</span><span class="n">SHVALIDSTDIS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">chip</span> <span class="o">&amp;</span> <span class="n">AHD_BUS_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">AHD_PCIX</span><span class="p">)</span>
		<span class="cm">/*</span>
<span class="cm">		 * Do not issue a target abort when a split completion</span>
<span class="cm">		 * error occurs.  Let our PCIX interrupt handler deal</span>
<span class="cm">		 * with it instead. H2A4 Razor #625</span>
<span class="cm">		 */</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">PCIXCTL</span><span class="p">,</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">PCIXCTL</span><span class="p">)</span> <span class="o">|</span> <span class="n">SPLTSTADIS</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">bugs</span> <span class="o">&amp;</span> <span class="n">AHD_LQOOVERRUN_BUG</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">LQOSCSCTL</span><span class="p">,</span> <span class="n">LQONOCHKOVER</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Tweak IOCELL settings.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AHD_HP_BOARD</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUMDSPS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">DSPSELECT</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">WRTBIASCTL</span><span class="p">,</span> <span class="n">WRTBIASCTL_HP_DEFAULT</span><span class="p">);</span>
		<span class="p">}</span>
<span class="cp">#ifdef AHD_DEBUG</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ahd_debug</span> <span class="o">&amp;</span> <span class="n">AHD_SHOW_MISC</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: WRTBIASCTL now 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">),</span>
			       <span class="n">WRTBIASCTL_HP_DEFAULT</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="p">}</span>
	<span class="n">ahd_setup_iocell_workaround</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Enable LQI Manager interrupts.</span>
<span class="cm">	 */</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">LQIMODE1</span><span class="p">,</span> <span class="n">ENLQIPHASE_LQ</span><span class="o">|</span><span class="n">ENLQIPHASE_NLQ</span><span class="o">|</span><span class="n">ENLIQABORT</span>
			      <span class="o">|</span> <span class="n">ENLQICRCI_LQ</span><span class="o">|</span><span class="n">ENLQICRCI_NLQ</span><span class="o">|</span><span class="n">ENLQIBADLQI</span>
			      <span class="o">|</span> <span class="n">ENLQIOVERI_LQ</span><span class="o">|</span><span class="n">ENLQIOVERI_NLQ</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">LQOMODE0</span><span class="p">,</span> <span class="n">ENLQOATNLQ</span><span class="o">|</span><span class="n">ENLQOATNPKT</span><span class="o">|</span><span class="n">ENLQOTCRC</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * We choose to have the sequencer catch LQOPHCHGINPKT errors</span>
<span class="cm">	 * manually for the command phase at the start of a packetized</span>
<span class="cm">	 * selection case.  ENLQOBUSFREE should be made redundant by</span>
<span class="cm">	 * the BUSFREE interrupt, but it seems that some LQOBUSFREE</span>
<span class="cm">	 * events fail to assert the BUSFREE interrupt so we must</span>
<span class="cm">	 * also enable LQOBUSFREE interrupts.</span>
<span class="cm">	 */</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">LQOMODE1</span><span class="p">,</span> <span class="n">ENLQOBUSFREE</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Setup sequencer interrupt handlers.</span>
<span class="cm">	 */</span>
	<span class="n">ahd_outw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">INTVEC1_ADDR</span><span class="p">,</span> <span class="n">ahd_resolve_seqaddr</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">LABEL_seq_isr</span><span class="p">));</span>
	<span class="n">ahd_outw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">INTVEC2_ADDR</span><span class="p">,</span> <span class="n">ahd_resolve_seqaddr</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">LABEL_timer_isr</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Setup SCB Offset registers.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">bugs</span> <span class="o">&amp;</span> <span class="n">AHD_PKT_LUN_BUG</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">LUNPTR</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hardware_scb</span><span class="p">,</span>
			 <span class="n">pkt_long_lun</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">LUNPTR</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hardware_scb</span><span class="p">,</span> <span class="n">lun</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CMDLENPTR</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hardware_scb</span><span class="p">,</span> <span class="n">cdb_len</span><span class="p">));</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">ATTRPTR</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hardware_scb</span><span class="p">,</span> <span class="n">task_attribute</span><span class="p">));</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">FLAGPTR</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hardware_scb</span><span class="p">,</span> <span class="n">task_management</span><span class="p">));</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CMDPTR</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hardware_scb</span><span class="p">,</span>
				       <span class="n">shared_data</span><span class="p">.</span><span class="n">idata</span><span class="p">.</span><span class="n">cdb</span><span class="p">));</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">QNEXTPTR</span><span class="p">,</span>
		 <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hardware_scb</span><span class="p">,</span> <span class="n">next_hscb_busaddr</span><span class="p">));</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">ABRTBITPTR</span><span class="p">,</span> <span class="n">MK_MESSAGE_BIT_OFFSET</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">ABRTBYTEPTR</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hardware_scb</span><span class="p">,</span> <span class="n">control</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">bugs</span> <span class="o">&amp;</span> <span class="n">AHD_PKT_LUN_BUG</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">LUNLEN</span><span class="p">,</span>
			 <span class="k">sizeof</span><span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">next_queued_hscb</span><span class="o">-&gt;</span><span class="n">pkt_long_lun</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">LUNLEN</span><span class="p">,</span> <span class="n">LUNLEN_SINGLE_LEVEL_LUN</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CDBLIMIT</span><span class="p">,</span> <span class="n">SCB_CDB_LEN_PTR</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">MAXCMD</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCBAUTOPTR</span><span class="p">,</span>
		 <span class="n">AUSCBPTR_EN</span> <span class="o">|</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hardware_scb</span><span class="p">,</span> <span class="n">tag</span><span class="p">));</span>

	<span class="cm">/* We haven&#39;t been enabled for target mode yet. */</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">MULTARGID</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">MULTARGID</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">ahd_set_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI</span><span class="p">);</span>
	<span class="cm">/* Initialize the negotiation table. */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">AHD_NEW_IOCELL_OPTS</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Clear the spare bytes in the neg table to avoid</span>
<span class="cm">		 * spurious parity errors.</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">target</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">target</span> <span class="o">&lt;</span> <span class="n">AHD_NUM_TARGETS</span><span class="p">;</span> <span class="n">target</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">NEGOADDR</span><span class="p">,</span> <span class="n">target</span><span class="p">);</span>
			<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">ANNEXCOL</span><span class="p">,</span> <span class="n">AHD_ANNEXCOL_PER_DEV0</span><span class="p">);</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">AHD_NUM_PER_DEV_ANNEXCOLS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
				<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">ANNEXDAT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">target</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">target</span> <span class="o">&lt;</span> <span class="n">AHD_NUM_TARGETS</span><span class="p">;</span> <span class="n">target</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span>	 <span class="n">ahd_devinfo</span> <span class="n">devinfo</span><span class="p">;</span>
		<span class="k">struct</span>	 <span class="n">ahd_initiator_tinfo</span> <span class="o">*</span><span class="n">tinfo</span><span class="p">;</span>
		<span class="k">struct</span>	 <span class="n">ahd_tmode_tstate</span> <span class="o">*</span><span class="n">tstate</span><span class="p">;</span>

		<span class="n">tinfo</span> <span class="o">=</span> <span class="n">ahd_fetch_transinfo</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="sc">&#39;A&#39;</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">our_id</span><span class="p">,</span>
					    <span class="n">target</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tstate</span><span class="p">);</span>
		<span class="n">ahd_compile_devinfo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devinfo</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">our_id</span><span class="p">,</span>
				    <span class="n">target</span><span class="p">,</span> <span class="n">CAM_LUN_WILDCARD</span><span class="p">,</span>
				    <span class="sc">&#39;A&#39;</span><span class="p">,</span> <span class="n">ROLE_INITIATOR</span><span class="p">);</span>
		<span class="n">ahd_update_neg_table</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">devinfo</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CLRSINT3</span><span class="p">,</span> <span class="n">NTRAMPERR</span><span class="o">|</span><span class="n">OSRAMPERR</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CLRINT</span><span class="p">,</span> <span class="n">CLRSCSIINT</span><span class="p">);</span>

<span class="cp">#ifdef NEEDS_MORE_TESTING</span>
	<span class="cm">/*</span>
<span class="cm">	 * Always enable abort on incoming L_Qs if this feature is</span>
<span class="cm">	 * supported.  We use this to catch invalid SCB references.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">bugs</span> <span class="o">&amp;</span> <span class="n">AHD_ABORT_LQI_BUG</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">LQCTL1</span><span class="p">,</span> <span class="n">ABORTPENDING</span><span class="p">);</span>
	<span class="k">else</span>
<span class="cp">#endif</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">LQCTL1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* All of our queues are empty */</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">qoutfifonext</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">qoutfifonext_valid_tag</span> <span class="o">=</span> <span class="n">QOUTFIFO_ENTRY_VALID</span><span class="p">;</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">QOUTFIFO_ENTRY_VALID_TAG</span><span class="p">,</span> <span class="n">QOUTFIFO_ENTRY_VALID</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">AHD_QOUT_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">qoutfifo</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">valid_tag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ahd_sync_qoutfifo</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">BUS_DMASYNC_PREREAD</span><span class="p">);</span>

	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">qinfifonext</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">AHD_QIN_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">qinfifo</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">SCB_LIST_NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">AHD_TARGETMODE</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* All target command blocks start out invalid. */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">AHD_TMODE_CMDS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">targetcmds</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cmd_valid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ahd_sync_tqinfifo</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">BUS_DMASYNC_PREREAD</span><span class="p">);</span>
		<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">tqinfifonext</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">KERNEL_TQINPOS</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">tqinfifonext</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">TQINPOS</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">tqinfifonext</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Initialize Scratch Ram. */</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SEQ_FLAGS</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SEQ_FLAGS2</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* We don&#39;t have any waiting selections */</span>
	<span class="n">ahd_outw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">WAITING_TID_HEAD</span><span class="p">,</span> <span class="n">SCB_LIST_NULL</span><span class="p">);</span>
	<span class="n">ahd_outw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">WAITING_TID_TAIL</span><span class="p">,</span> <span class="n">SCB_LIST_NULL</span><span class="p">);</span>
	<span class="n">ahd_outw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">MK_MESSAGE_SCB</span><span class="p">,</span> <span class="n">SCB_LIST_NULL</span><span class="p">);</span>
	<span class="n">ahd_outw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">MK_MESSAGE_SCSIID</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">AHD_NUM_TARGETS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">ahd_outw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">WAITING_SCB_TAILS</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">),</span> <span class="n">SCB_LIST_NULL</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Nobody is waiting to be DMAed into the QOUTFIFO.</span>
<span class="cm">	 */</span>
	<span class="n">ahd_outw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">COMPLETE_SCB_HEAD</span><span class="p">,</span> <span class="n">SCB_LIST_NULL</span><span class="p">);</span>
	<span class="n">ahd_outw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">COMPLETE_SCB_DMAINPROG_HEAD</span><span class="p">,</span> <span class="n">SCB_LIST_NULL</span><span class="p">);</span>
	<span class="n">ahd_outw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">COMPLETE_DMA_SCB_HEAD</span><span class="p">,</span> <span class="n">SCB_LIST_NULL</span><span class="p">);</span>
	<span class="n">ahd_outw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">COMPLETE_DMA_SCB_TAIL</span><span class="p">,</span> <span class="n">SCB_LIST_NULL</span><span class="p">);</span>
	<span class="n">ahd_outw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">COMPLETE_ON_QFREEZE_HEAD</span><span class="p">,</span> <span class="n">SCB_LIST_NULL</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The Freeze Count is 0.</span>
<span class="cm">	 */</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">qfreeze_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ahd_outw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">QFREEZE_COUNT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ahd_outw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">KERNEL_QFREEZE_COUNT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Tell the sequencer where it can find our arrays in memory.</span>
<span class="cm">	 */</span>
	<span class="n">busaddr</span> <span class="o">=</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">shared_data_map</span><span class="p">.</span><span class="n">physaddr</span><span class="p">;</span>
	<span class="n">ahd_outl</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SHARED_DATA_ADDR</span><span class="p">,</span> <span class="n">busaddr</span><span class="p">);</span>
	<span class="n">ahd_outl</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">QOUTFIFO_NEXT_ADDR</span><span class="p">,</span> <span class="n">busaddr</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Setup the allowed SCSI Sequences based on operational mode.</span>
<span class="cm">	 * If we are a target, we&#39;ll enable select in operations once</span>
<span class="cm">	 * we&#39;ve had a lun enabled.</span>
<span class="cm">	 */</span>
	<span class="n">scsiseq_template</span> <span class="o">=</span> <span class="n">ENAUTOATNP</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AHD_INITIATORROLE</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">scsiseq_template</span> <span class="o">|=</span> <span class="n">ENRSELI</span><span class="p">;</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCSISEQ_TEMPLATE</span><span class="p">,</span> <span class="n">scsiseq_template</span><span class="p">);</span>

	<span class="cm">/* There are no busy SCBs yet. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">target</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">target</span> <span class="o">&lt;</span> <span class="n">AHD_NUM_TARGETS</span><span class="p">;</span> <span class="n">target</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">lun</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">lun</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">lun</span> <span class="o">&lt;</span> <span class="n">AHD_NUM_LUNS_NONPKT</span><span class="p">;</span> <span class="n">lun</span><span class="o">++</span><span class="p">)</span>
			<span class="n">ahd_unbusy_tcl</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">BUILD_TCL_RAW</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="sc">&#39;A&#39;</span><span class="p">,</span> <span class="n">lun</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialize the group code to command length table.</span>
<span class="cm">	 * Vendor Unique codes are set to 0 so we only capture</span>
<span class="cm">	 * the first byte of the cdb.  These can be overridden</span>
<span class="cm">	 * when target mode is enabled.</span>
<span class="cm">	 */</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CMDSIZE_TABLE</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CMDSIZE_TABLE</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CMDSIZE_TABLE</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">9</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CMDSIZE_TABLE</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CMDSIZE_TABLE</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">15</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CMDSIZE_TABLE</span> <span class="o">+</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">11</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CMDSIZE_TABLE</span> <span class="o">+</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CMDSIZE_TABLE</span> <span class="o">+</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		
	<span class="cm">/* Tell the sequencer of our initial queue positions */</span>
	<span class="n">ahd_set_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHD_MODE_CCHAN</span><span class="p">,</span> <span class="n">AHD_MODE_CCHAN</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">QOFF_CTLSTA</span><span class="p">,</span> <span class="n">SCB_QSIZE_512</span><span class="p">);</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">qinfifonext</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ahd_set_hnscb_qoff</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">qinfifonext</span><span class="p">);</span>
	<span class="n">ahd_set_hescb_qoff</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ahd_set_snscb_qoff</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ahd_set_sescb_qoff</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ahd_set_sdscb_qoff</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Tell the sequencer which SCB will be the next one it receives.</span>
<span class="cm">	 */</span>
	<span class="n">busaddr</span> <span class="o">=</span> <span class="n">ahd_le32toh</span><span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">next_queued_hscb</span><span class="o">-&gt;</span><span class="n">hscb_busaddr</span><span class="p">);</span>
	<span class="n">ahd_outl</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">NEXT_QUEUED_SCB_ADDR</span><span class="p">,</span> <span class="n">busaddr</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Default to coalescing disabled.</span>
<span class="cm">	 */</span>
	<span class="n">ahd_outw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">INT_COALESCING_CMDCOUNT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ahd_outw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CMDS_PENDING</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ahd_update_coalescing_values</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">int_coalescing_timer</span><span class="p">,</span>
				     <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">int_coalescing_maxcmds</span><span class="p">,</span>
				     <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">int_coalescing_mincmds</span><span class="p">);</span>
	<span class="n">ahd_enable_coalescing</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">);</span>

	<span class="n">ahd_loadseq</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
	<span class="n">ahd_set_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">AHD_AIC79XXB_SLOWCRC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u_int</span> <span class="n">negodat3</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">NEGCONOPTS</span><span class="p">);</span>

		<span class="n">negodat3</span> <span class="o">|=</span> <span class="n">ENSLOWCRC</span><span class="p">;</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">NEGCONOPTS</span><span class="p">,</span> <span class="n">negodat3</span><span class="p">);</span>
		<span class="n">negodat3</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">NEGCONOPTS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">negodat3</span> <span class="o">&amp;</span> <span class="n">ENSLOWCRC</span><span class="p">))</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;aic79xx: failed to set the SLOWCRC bit</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;aic79xx: SLOWCRC bit set</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Setup default device and controller settings.</span>
<span class="cm"> * This should only be called if our probe has</span>
<span class="cm"> * determined that no configuration data is available.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">ahd_default_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>	<span class="n">targ</span><span class="p">;</span>

	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">our_id</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate a tstate to house information for our</span>
<span class="cm">	 * initiator presence on the bus as well as the user</span>
<span class="cm">	 * data for any target mode initiator.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ahd_alloc_tstate</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">our_id</span><span class="p">,</span> <span class="sc">&#39;A&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: unable to allocate ahd_tmode_tstate.  &quot;</span>
		       <span class="s">&quot;Failing attach</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">));</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">ENOMEM</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">targ</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">targ</span> <span class="o">&lt;</span> <span class="n">AHD_NUM_TARGETS</span><span class="p">;</span> <span class="n">targ</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span>	 <span class="n">ahd_devinfo</span> <span class="n">devinfo</span><span class="p">;</span>
		<span class="k">struct</span>	 <span class="n">ahd_initiator_tinfo</span> <span class="o">*</span><span class="n">tinfo</span><span class="p">;</span>
		<span class="k">struct</span>	 <span class="n">ahd_tmode_tstate</span> <span class="o">*</span><span class="n">tstate</span><span class="p">;</span>
		<span class="kt">uint16_t</span> <span class="n">target_mask</span><span class="p">;</span>

		<span class="n">tinfo</span> <span class="o">=</span> <span class="n">ahd_fetch_transinfo</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="sc">&#39;A&#39;</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">our_id</span><span class="p">,</span>
					    <span class="n">targ</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tstate</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * We support SPC2 and SPI4.</span>
<span class="cm">		 */</span>
		<span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">user</span><span class="p">.</span><span class="n">protocol_version</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
		<span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">user</span><span class="p">.</span><span class="n">transport_version</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>

		<span class="n">target_mask</span> <span class="o">=</span> <span class="mh">0x01</span> <span class="o">&lt;&lt;</span> <span class="n">targ</span><span class="p">;</span>
		<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">user_discenable</span> <span class="o">|=</span> <span class="n">target_mask</span><span class="p">;</span>
		<span class="n">tstate</span><span class="o">-&gt;</span><span class="n">discenable</span> <span class="o">|=</span> <span class="n">target_mask</span><span class="p">;</span>
		<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">user_tagenable</span> <span class="o">|=</span> <span class="n">target_mask</span><span class="p">;</span>
<span class="cp">#ifdef AHD_FORCE_160</span>
		<span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">user</span><span class="p">.</span><span class="n">period</span> <span class="o">=</span> <span class="n">AHD_SYNCRATE_DT</span><span class="p">;</span>
<span class="cp">#else</span>
		<span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">user</span><span class="p">.</span><span class="n">period</span> <span class="o">=</span> <span class="n">AHD_SYNCRATE_160</span><span class="p">;</span>
<span class="cp">#endif</span>
		<span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">user</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">MAX_OFFSET</span><span class="p">;</span>
		<span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">user</span><span class="p">.</span><span class="n">ppr_options</span> <span class="o">=</span> <span class="n">MSG_EXT_PPR_RD_STRM</span>
					<span class="o">|</span> <span class="n">MSG_EXT_PPR_WR_FLOW</span>
					<span class="o">|</span> <span class="n">MSG_EXT_PPR_HOLD_MCS</span>
					<span class="o">|</span> <span class="n">MSG_EXT_PPR_IU_REQ</span>
					<span class="o">|</span> <span class="n">MSG_EXT_PPR_QAS_REQ</span>
					<span class="o">|</span> <span class="n">MSG_EXT_PPR_DT_REQ</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">AHD_RTI</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">user</span><span class="p">.</span><span class="n">ppr_options</span> <span class="o">|=</span> <span class="n">MSG_EXT_PPR_RTI</span><span class="p">;</span>

		<span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">user</span><span class="p">.</span><span class="n">width</span> <span class="o">=</span> <span class="n">MSG_EXT_WDTR_BUS_16_BIT</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Start out Async/Narrow/Untagged and with</span>
<span class="cm">		 * conservative protocol support.</span>
<span class="cm">		 */</span>
		<span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">goal</span><span class="p">.</span><span class="n">protocol_version</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">goal</span><span class="p">.</span><span class="n">transport_version</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">.</span><span class="n">protocol_version</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">.</span><span class="n">transport_version</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">ahd_compile_devinfo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devinfo</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">our_id</span><span class="p">,</span>
				    <span class="n">targ</span><span class="p">,</span> <span class="n">CAM_LUN_WILDCARD</span><span class="p">,</span>
				    <span class="sc">&#39;A&#39;</span><span class="p">,</span> <span class="n">ROLE_INITIATOR</span><span class="p">);</span>
		<span class="n">tstate</span><span class="o">-&gt;</span><span class="n">tagenable</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">target_mask</span><span class="p">;</span>
		<span class="n">ahd_set_width</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">devinfo</span><span class="p">,</span> <span class="n">MSG_EXT_WDTR_BUS_8_BIT</span><span class="p">,</span>
			      <span class="n">AHD_TRANS_CUR</span><span class="o">|</span><span class="n">AHD_TRANS_GOAL</span><span class="p">,</span> <span class="cm">/*paused*/</span><span class="n">TRUE</span><span class="p">);</span>
		<span class="n">ahd_set_syncrate</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">devinfo</span><span class="p">,</span> <span class="cm">/*period*/</span><span class="mi">0</span><span class="p">,</span> <span class="cm">/*offset*/</span><span class="mi">0</span><span class="p">,</span>
				 <span class="cm">/*ppr_options*/</span><span class="mi">0</span><span class="p">,</span> <span class="n">AHD_TRANS_CUR</span><span class="o">|</span><span class="n">AHD_TRANS_GOAL</span><span class="p">,</span>
				 <span class="cm">/*paused*/</span><span class="n">TRUE</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Parse device configuration information.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">ahd_parse_cfgdata</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">seeprom_config</span> <span class="o">*</span><span class="n">sc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">targ</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">max_targ</span><span class="p">;</span>

	<span class="n">max_targ</span> <span class="o">=</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">max_targets</span> <span class="o">&amp;</span> <span class="n">CFMAXTARG</span><span class="p">;</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">our_id</span> <span class="o">=</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">brtime_id</span> <span class="o">&amp;</span> <span class="n">CFSCSIID</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate a tstate to house information for our</span>
<span class="cm">	 * initiator presence on the bus as well as the user</span>
<span class="cm">	 * data for any target mode initiator.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ahd_alloc_tstate</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">our_id</span><span class="p">,</span> <span class="sc">&#39;A&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: unable to allocate ahd_tmode_tstate.  &quot;</span>
		       <span class="s">&quot;Failing attach</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">));</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">ENOMEM</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">targ</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">targ</span> <span class="o">&lt;</span> <span class="n">max_targ</span><span class="p">;</span> <span class="n">targ</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span>	 <span class="n">ahd_devinfo</span> <span class="n">devinfo</span><span class="p">;</span>
		<span class="k">struct</span>	 <span class="n">ahd_initiator_tinfo</span> <span class="o">*</span><span class="n">tinfo</span><span class="p">;</span>
		<span class="k">struct</span>	 <span class="n">ahd_transinfo</span> <span class="o">*</span><span class="n">user_tinfo</span><span class="p">;</span>
		<span class="k">struct</span>	 <span class="n">ahd_tmode_tstate</span> <span class="o">*</span><span class="n">tstate</span><span class="p">;</span>
		<span class="kt">uint16_t</span> <span class="n">target_mask</span><span class="p">;</span>

		<span class="n">tinfo</span> <span class="o">=</span> <span class="n">ahd_fetch_transinfo</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="sc">&#39;A&#39;</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">our_id</span><span class="p">,</span>
					    <span class="n">targ</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tstate</span><span class="p">);</span>
		<span class="n">user_tinfo</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">user</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * We support SPC2 and SPI4.</span>
<span class="cm">		 */</span>
		<span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">user</span><span class="p">.</span><span class="n">protocol_version</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
		<span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">user</span><span class="p">.</span><span class="n">transport_version</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>

		<span class="n">target_mask</span> <span class="o">=</span> <span class="mh">0x01</span> <span class="o">&lt;&lt;</span> <span class="n">targ</span><span class="p">;</span>
		<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">user_discenable</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">target_mask</span><span class="p">;</span>
		<span class="n">tstate</span><span class="o">-&gt;</span><span class="n">discenable</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">target_mask</span><span class="p">;</span>
		<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">user_tagenable</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">target_mask</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">device_flags</span><span class="p">[</span><span class="n">targ</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">CFDISC</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tstate</span><span class="o">-&gt;</span><span class="n">discenable</span> <span class="o">|=</span> <span class="n">target_mask</span><span class="p">;</span>
			<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">user_discenable</span> <span class="o">|=</span> <span class="n">target_mask</span><span class="p">;</span>
			<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">user_tagenable</span> <span class="o">|=</span> <span class="n">target_mask</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Cannot be packetized without disconnection.</span>
<span class="cm">			 */</span>
			<span class="n">sc</span><span class="o">-&gt;</span><span class="n">device_flags</span><span class="p">[</span><span class="n">targ</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CFPACKETIZED</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">user_tinfo</span><span class="o">-&gt;</span><span class="n">ppr_options</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">user_tinfo</span><span class="o">-&gt;</span><span class="n">period</span> <span class="o">=</span> <span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">device_flags</span><span class="p">[</span><span class="n">targ</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">CFXFER</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">user_tinfo</span><span class="o">-&gt;</span><span class="n">period</span> <span class="o">&lt;</span> <span class="n">CFXFER_ASYNC</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">user_tinfo</span><span class="o">-&gt;</span><span class="n">period</span> <span class="o">&lt;=</span> <span class="n">AHD_PERIOD_10MHz</span><span class="p">)</span>
				<span class="n">user_tinfo</span><span class="o">-&gt;</span><span class="n">ppr_options</span> <span class="o">|=</span> <span class="n">MSG_EXT_PPR_DT_REQ</span><span class="p">;</span>
			<span class="n">user_tinfo</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="n">MAX_OFFSET</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>  <span class="p">{</span>
			<span class="n">user_tinfo</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">user_tinfo</span><span class="o">-&gt;</span><span class="n">period</span> <span class="o">=</span> <span class="n">AHD_ASYNC_XFER_PERIOD</span><span class="p">;</span>
		<span class="p">}</span>
<span class="cp">#ifdef AHD_FORCE_160</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">user_tinfo</span><span class="o">-&gt;</span><span class="n">period</span> <span class="o">&lt;=</span> <span class="n">AHD_SYNCRATE_160</span><span class="p">)</span>
			<span class="n">user_tinfo</span><span class="o">-&gt;</span><span class="n">period</span> <span class="o">=</span> <span class="n">AHD_SYNCRATE_DT</span><span class="p">;</span>
<span class="cp">#endif</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">device_flags</span><span class="p">[</span><span class="n">targ</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">CFPACKETIZED</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">user_tinfo</span><span class="o">-&gt;</span><span class="n">ppr_options</span> <span class="o">|=</span> <span class="n">MSG_EXT_PPR_RD_STRM</span>
						<span class="o">|</span>  <span class="n">MSG_EXT_PPR_WR_FLOW</span>
						<span class="o">|</span>  <span class="n">MSG_EXT_PPR_HOLD_MCS</span>
						<span class="o">|</span>  <span class="n">MSG_EXT_PPR_IU_REQ</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">AHD_RTI</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">user_tinfo</span><span class="o">-&gt;</span><span class="n">ppr_options</span> <span class="o">|=</span> <span class="n">MSG_EXT_PPR_RTI</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">device_flags</span><span class="p">[</span><span class="n">targ</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">CFQAS</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">user_tinfo</span><span class="o">-&gt;</span><span class="n">ppr_options</span> <span class="o">|=</span> <span class="n">MSG_EXT_PPR_QAS_REQ</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">device_flags</span><span class="p">[</span><span class="n">targ</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">CFWIDEB</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">user_tinfo</span><span class="o">-&gt;</span><span class="n">width</span> <span class="o">=</span> <span class="n">MSG_EXT_WDTR_BUS_16_BIT</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">user_tinfo</span><span class="o">-&gt;</span><span class="n">width</span> <span class="o">=</span> <span class="n">MSG_EXT_WDTR_BUS_8_BIT</span><span class="p">;</span>
<span class="cp">#ifdef AHD_DEBUG</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ahd_debug</span> <span class="o">&amp;</span> <span class="n">AHD_SHOW_MISC</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;(%d): %x:%x:%x:%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">targ</span><span class="p">,</span> <span class="n">user_tinfo</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">,</span>
			       <span class="n">user_tinfo</span><span class="o">-&gt;</span><span class="n">period</span><span class="p">,</span> <span class="n">user_tinfo</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">,</span>
			       <span class="n">user_tinfo</span><span class="o">-&gt;</span><span class="n">ppr_options</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="cm">/*</span>
<span class="cm">		 * Start out Async/Narrow/Untagged and with</span>
<span class="cm">		 * conservative protocol support.</span>
<span class="cm">		 */</span>
		<span class="n">tstate</span><span class="o">-&gt;</span><span class="n">tagenable</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">target_mask</span><span class="p">;</span>
		<span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">goal</span><span class="p">.</span><span class="n">protocol_version</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">goal</span><span class="p">.</span><span class="n">transport_version</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">.</span><span class="n">protocol_version</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">.</span><span class="n">transport_version</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">ahd_compile_devinfo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devinfo</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">our_id</span><span class="p">,</span>
				    <span class="n">targ</span><span class="p">,</span> <span class="n">CAM_LUN_WILDCARD</span><span class="p">,</span>
				    <span class="sc">&#39;A&#39;</span><span class="p">,</span> <span class="n">ROLE_INITIATOR</span><span class="p">);</span>
		<span class="n">ahd_set_width</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">devinfo</span><span class="p">,</span> <span class="n">MSG_EXT_WDTR_BUS_8_BIT</span><span class="p">,</span>
			      <span class="n">AHD_TRANS_CUR</span><span class="o">|</span><span class="n">AHD_TRANS_GOAL</span><span class="p">,</span> <span class="cm">/*paused*/</span><span class="n">TRUE</span><span class="p">);</span>
		<span class="n">ahd_set_syncrate</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">devinfo</span><span class="p">,</span> <span class="cm">/*period*/</span><span class="mi">0</span><span class="p">,</span> <span class="cm">/*offset*/</span><span class="mi">0</span><span class="p">,</span>
				 <span class="cm">/*ppr_options*/</span><span class="mi">0</span><span class="p">,</span> <span class="n">AHD_TRANS_CUR</span><span class="o">|</span><span class="n">AHD_TRANS_GOAL</span><span class="p">,</span>
				 <span class="cm">/*paused*/</span><span class="n">TRUE</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">AHD_SPCHK_ENB_A</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">bios_control</span> <span class="o">&amp;</span> <span class="n">CFSPARITY</span><span class="p">)</span>
		<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">AHD_SPCHK_ENB_A</span><span class="p">;</span>

	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">AHD_RESET_BUS_A</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">bios_control</span> <span class="o">&amp;</span> <span class="n">CFRESETB</span><span class="p">)</span>
		<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">AHD_RESET_BUS_A</span><span class="p">;</span>

	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">AHD_EXTENDED_TRANS_A</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">bios_control</span> <span class="o">&amp;</span> <span class="n">CFEXTEND</span><span class="p">)</span>
		<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">AHD_EXTENDED_TRANS_A</span><span class="p">;</span>

	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">AHD_BIOS_ENABLED</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">bios_control</span> <span class="o">&amp;</span> <span class="n">CFBIOSSTATE</span><span class="p">)</span> <span class="o">==</span> <span class="n">CFBS_ENABLED</span><span class="p">)</span>
		<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">AHD_BIOS_ENABLED</span><span class="p">;</span>

	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">AHD_STPWLEVEL_A</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">adapter_control</span> <span class="o">&amp;</span> <span class="n">CFSTPWLEVEL</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">AHD_STPWLEVEL_A</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Parse device configuration information.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">ahd_parse_vpddata</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vpd_config</span> <span class="o">*</span><span class="n">vpd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">ahd_verify_vpd_cksum</span><span class="p">(</span><span class="n">vpd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">EINVAL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">vpd</span><span class="o">-&gt;</span><span class="n">bios_flags</span> <span class="o">&amp;</span> <span class="n">VPDBOOTHOST</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">AHD_BOOT_CHANNEL</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">ahd_intr_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">enable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u_int</span> <span class="n">hcntrl</span><span class="p">;</span>

	<span class="n">hcntrl</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">HCNTRL</span><span class="p">);</span>
	<span class="n">hcntrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">INTEN</span><span class="p">;</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">pause</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">INTEN</span><span class="p">;</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">unpause</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">INTEN</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">enable</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hcntrl</span> <span class="o">|=</span> <span class="n">INTEN</span><span class="p">;</span>
		<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">pause</span> <span class="o">|=</span> <span class="n">INTEN</span><span class="p">;</span>
		<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">unpause</span> <span class="o">|=</span> <span class="n">INTEN</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">HCNTRL</span><span class="p">,</span> <span class="n">hcntrl</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_update_coalescing_values</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">timer</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">maxcmds</span><span class="p">,</span>
			     <span class="n">u_int</span> <span class="n">mincmds</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">timer</span> <span class="o">&gt;</span> <span class="n">AHD_TIMER_MAX_US</span><span class="p">)</span>
		<span class="n">timer</span> <span class="o">=</span> <span class="n">AHD_TIMER_MAX_US</span><span class="p">;</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">int_coalescing_timer</span> <span class="o">=</span> <span class="n">timer</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">maxcmds</span> <span class="o">&gt;</span> <span class="n">AHD_INT_COALESCING_MAXCMDS_MAX</span><span class="p">)</span>
		<span class="n">maxcmds</span> <span class="o">=</span> <span class="n">AHD_INT_COALESCING_MAXCMDS_MAX</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mincmds</span> <span class="o">&gt;</span> <span class="n">AHD_INT_COALESCING_MINCMDS_MAX</span><span class="p">)</span>
		<span class="n">mincmds</span> <span class="o">=</span> <span class="n">AHD_INT_COALESCING_MINCMDS_MAX</span><span class="p">;</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">int_coalescing_maxcmds</span> <span class="o">=</span> <span class="n">maxcmds</span><span class="p">;</span>
	<span class="n">ahd_outw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">INT_COALESCING_TIMER</span><span class="p">,</span> <span class="n">timer</span> <span class="o">/</span> <span class="n">AHD_TIMER_US_PER_TICK</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">INT_COALESCING_MAXCMDS</span><span class="p">,</span> <span class="o">-</span><span class="n">maxcmds</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">INT_COALESCING_MINCMDS</span><span class="p">,</span> <span class="o">-</span><span class="n">mincmds</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_enable_coalescing</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">enable</span><span class="p">)</span>
<span class="p">{</span>

	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">hs_mailbox</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ENINT_COALESCE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">enable</span><span class="p">)</span>
		<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">hs_mailbox</span> <span class="o">|=</span> <span class="n">ENINT_COALESCE</span><span class="p">;</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">HS_MAILBOX</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">hs_mailbox</span><span class="p">);</span>
	<span class="n">ahd_flush_device_writes</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
	<span class="n">ahd_run_qoutfifo</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Ensure that the card is paused in a location</span>
<span class="cm"> * outside of all critical sections and that all</span>
<span class="cm"> * pending work is completed prior to returning.</span>
<span class="cm"> * This routine should only be called from outside</span>
<span class="cm"> * an interrupt context.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">ahd_pause_and_flushwork</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u_int</span> <span class="n">intstat</span><span class="p">;</span>
	<span class="n">u_int</span> <span class="n">maxloops</span><span class="p">;</span>

	<span class="n">maxloops</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">AHD_ALL_INTERRUPTS</span><span class="p">;</span>
	<span class="n">ahd_pause</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Freeze the outgoing selections.  We do this only</span>
<span class="cm">	 * until we are safely paused without further selections</span>
<span class="cm">	 * pending.</span>
<span class="cm">	 */</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">qfreeze_cnt</span><span class="o">--</span><span class="p">;</span>
	<span class="n">ahd_outw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">KERNEL_QFREEZE_COUNT</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">qfreeze_cnt</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SEQ_FLAGS2</span><span class="p">,</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SEQ_FLAGS2</span><span class="p">)</span> <span class="o">|</span> <span class="n">SELECTOUT_QFROZEN</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>

		<span class="n">ahd_unpause</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Give the sequencer some time to service</span>
<span class="cm">		 * any active selections.</span>
<span class="cm">		 */</span>
		<span class="n">ahd_delay</span><span class="p">(</span><span class="mi">500</span><span class="p">);</span>

		<span class="n">ahd_intr</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
		<span class="n">ahd_pause</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
		<span class="n">intstat</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">INTSTAT</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">intstat</span> <span class="o">&amp;</span> <span class="n">INT_PEND</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ahd_clear_critical_section</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
			<span class="n">intstat</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">INTSTAT</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">maxloops</span>
	      <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">intstat</span> <span class="o">!=</span> <span class="mh">0xFF</span> <span class="o">||</span> <span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">AHD_REMOVABLE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
	      <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">intstat</span> <span class="o">&amp;</span> <span class="n">INT_PEND</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>
	       <span class="o">||</span> <span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCSISEQ0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">ENSELO</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>
	       <span class="o">||</span> <span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SSTAT0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">SELDO</span><span class="o">|</span><span class="n">SELINGO</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">maxloops</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Infinite interrupt loop, INTSTAT = %x&quot;</span><span class="p">,</span>
		      <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">INTSTAT</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">qfreeze_cnt</span><span class="o">++</span><span class="p">;</span>
	<span class="n">ahd_outw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">KERNEL_QFREEZE_COUNT</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">qfreeze_cnt</span><span class="p">);</span>

	<span class="n">ahd_flush_qoutfifo</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>

	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">AHD_ALL_INTERRUPTS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PM</span>
<span class="kt">int</span>
<span class="nf">ahd_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">)</span>
<span class="p">{</span>

	<span class="n">ahd_pause_and_flushwork</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">LIST_FIRST</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">pending_scbs</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ahd_unpause</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">EBUSY</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">ahd_shutdown</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">ahd_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">)</span>
<span class="p">{</span>

	<span class="n">ahd_reset</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="cm">/*reinit*/</span><span class="n">TRUE</span><span class="p">);</span>
	<span class="n">ahd_intr_enable</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">);</span> 
	<span class="n">ahd_restart</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/************************** Busy Target Table *********************************/</span>
<span class="cm">/*</span>
<span class="cm"> * Set SCBPTR to the SCB that contains the busy</span>
<span class="cm"> * table entry for TCL.  Return the offset into</span>
<span class="cm"> * the SCB that contains the entry for TCL.</span>
<span class="cm"> * saved_scbid is dereferenced and set to the</span>
<span class="cm"> * scbid that should be restored once manipualtion</span>
<span class="cm"> * of the TCL entry is complete.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u_int</span>
<span class="nf">ahd_index_busy_tcl</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="n">u_int</span> <span class="o">*</span><span class="n">saved_scbid</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">tcl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Index to the SCB that contains the busy entry.</span>
<span class="cm">	 */</span>
	<span class="n">AHD_ASSERT_MODES</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI_MSK</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI_MSK</span><span class="p">);</span>
	<span class="o">*</span><span class="n">saved_scbid</span> <span class="o">=</span> <span class="n">ahd_get_scbptr</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
	<span class="n">ahd_set_scbptr</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">TCL_LUN</span><span class="p">(</span><span class="n">tcl</span><span class="p">)</span>
		     <span class="o">|</span> <span class="p">((</span><span class="n">TCL_TARGET_OFFSET</span><span class="p">(</span><span class="n">tcl</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xC</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * And now calculate the SCB offset to the entry.</span>
<span class="cm">	 * Each entry is 2 bytes wide, hence the</span>
<span class="cm">	 * multiplication by 2.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="p">(((</span><span class="n">TCL_TARGET_OFFSET</span><span class="p">(</span><span class="n">tcl</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">SCB_DISCONNECTED_LISTS</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return the untagged transaction id for a given target/channel lun.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u_int</span>
<span class="nf">ahd_find_busy_tcl</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">tcl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u_int</span> <span class="n">scbid</span><span class="p">;</span>
	<span class="n">u_int</span> <span class="n">scb_offset</span><span class="p">;</span>
	<span class="n">u_int</span> <span class="n">saved_scbptr</span><span class="p">;</span>
		
	<span class="n">scb_offset</span> <span class="o">=</span> <span class="n">ahd_index_busy_tcl</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">saved_scbptr</span><span class="p">,</span> <span class="n">tcl</span><span class="p">);</span>
	<span class="n">scbid</span> <span class="o">=</span> <span class="n">ahd_inw_scbram</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb_offset</span><span class="p">);</span>
	<span class="n">ahd_set_scbptr</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">saved_scbptr</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">scbid</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_busy_tcl</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">tcl</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">scbid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u_int</span> <span class="n">scb_offset</span><span class="p">;</span>
	<span class="n">u_int</span> <span class="n">saved_scbptr</span><span class="p">;</span>
		
	<span class="n">scb_offset</span> <span class="o">=</span> <span class="n">ahd_index_busy_tcl</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">saved_scbptr</span><span class="p">,</span> <span class="n">tcl</span><span class="p">);</span>
	<span class="n">ahd_outw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb_offset</span><span class="p">,</span> <span class="n">scbid</span><span class="p">);</span>
	<span class="n">ahd_set_scbptr</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">saved_scbptr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/************************** SCB and SCB queue management **********************/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ahd_match_scb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scb</span> <span class="o">*</span><span class="n">scb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">,</span>
	      <span class="kt">char</span> <span class="n">channel</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lun</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">tag</span><span class="p">,</span> <span class="n">role_t</span> <span class="n">role</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">targ</span> <span class="o">=</span> <span class="n">SCB_GET_TARGET</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
	<span class="kt">char</span> <span class="n">chan</span> <span class="o">=</span> <span class="n">SCB_GET_CHANNEL</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">slun</span> <span class="o">=</span> <span class="n">SCB_GET_LUN</span><span class="p">(</span><span class="n">scb</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">match</span><span class="p">;</span>

	<span class="n">match</span> <span class="o">=</span> <span class="p">((</span><span class="n">chan</span> <span class="o">==</span> <span class="n">channel</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">channel</span> <span class="o">==</span> <span class="n">ALL_CHANNELS</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">match</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">match</span> <span class="o">=</span> <span class="p">((</span><span class="n">targ</span> <span class="o">==</span> <span class="n">target</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">target</span> <span class="o">==</span> <span class="n">CAM_TARGET_WILDCARD</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">match</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">match</span> <span class="o">=</span> <span class="p">((</span><span class="n">lun</span> <span class="o">==</span> <span class="n">slun</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">lun</span> <span class="o">==</span> <span class="n">CAM_LUN_WILDCARD</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">match</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef AHD_TARGET_MODE</span>
		<span class="kt">int</span> <span class="n">group</span><span class="p">;</span>

		<span class="n">group</span> <span class="o">=</span> <span class="n">XPT_FC_GROUP</span><span class="p">(</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">io_ctx</span><span class="o">-&gt;</span><span class="n">ccb_h</span><span class="p">.</span><span class="n">func_code</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">role</span> <span class="o">==</span> <span class="n">ROLE_INITIATOR</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">match</span> <span class="o">=</span> <span class="p">(</span><span class="n">group</span> <span class="o">!=</span> <span class="n">XPT_FC_GROUP_TMODE</span><span class="p">)</span>
			      <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">tag</span> <span class="o">==</span> <span class="n">SCB_GET_TAG</span><span class="p">(</span><span class="n">scb</span><span class="p">))</span>
			       <span class="o">||</span> <span class="p">(</span><span class="n">tag</span> <span class="o">==</span> <span class="n">SCB_LIST_NULL</span><span class="p">));</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">role</span> <span class="o">==</span> <span class="n">ROLE_TARGET</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">match</span> <span class="o">=</span> <span class="p">(</span><span class="n">group</span> <span class="o">==</span> <span class="n">XPT_FC_GROUP_TMODE</span><span class="p">)</span>
			      <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">tag</span> <span class="o">==</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">io_ctx</span><span class="o">-&gt;</span><span class="n">csio</span><span class="p">.</span><span class="n">tag_id</span><span class="p">)</span>
			       <span class="o">||</span> <span class="p">(</span><span class="n">tag</span> <span class="o">==</span> <span class="n">SCB_LIST_NULL</span><span class="p">));</span>
		<span class="p">}</span>
<span class="cp">#else </span><span class="cm">/* !AHD_TARGET_MODE */</span><span class="cp"></span>
		<span class="n">match</span> <span class="o">=</span> <span class="p">((</span><span class="n">tag</span> <span class="o">==</span> <span class="n">SCB_GET_TAG</span><span class="p">(</span><span class="n">scb</span><span class="p">))</span> <span class="o">||</span> <span class="p">(</span><span class="n">tag</span> <span class="o">==</span> <span class="n">SCB_LIST_NULL</span><span class="p">));</span>
<span class="cp">#endif </span><span class="cm">/* AHD_TARGET_MODE */</span><span class="cp"></span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">match</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_freeze_devq</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scb</span> <span class="o">*</span><span class="n">scb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>	<span class="n">target</span><span class="p">;</span>
	<span class="kt">char</span>	<span class="n">channel</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">lun</span><span class="p">;</span>

	<span class="n">target</span> <span class="o">=</span> <span class="n">SCB_GET_TARGET</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
	<span class="n">lun</span> <span class="o">=</span> <span class="n">SCB_GET_LUN</span><span class="p">(</span><span class="n">scb</span><span class="p">);</span>
	<span class="n">channel</span> <span class="o">=</span> <span class="n">SCB_GET_CHANNEL</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
	
	<span class="n">ahd_search_qinfifo</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">lun</span><span class="p">,</span>
			   <span class="cm">/*tag*/</span><span class="n">SCB_LIST_NULL</span><span class="p">,</span> <span class="n">ROLE_UNKNOWN</span><span class="p">,</span>
			   <span class="n">CAM_REQUEUE_REQ</span><span class="p">,</span> <span class="n">SEARCH_COMPLETE</span><span class="p">);</span>

	<span class="n">ahd_platform_freeze_devq</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">ahd_qinfifo_requeue_tail</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scb</span> <span class="o">*</span><span class="n">scb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scb</span>	<span class="o">*</span><span class="n">prev_scb</span><span class="p">;</span>
	<span class="n">ahd_mode_state</span>	 <span class="n">saved_modes</span><span class="p">;</span>

	<span class="n">saved_modes</span> <span class="o">=</span> <span class="n">ahd_save_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
	<span class="n">ahd_set_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHD_MODE_CCHAN</span><span class="p">,</span> <span class="n">AHD_MODE_CCHAN</span><span class="p">);</span>
	<span class="n">prev_scb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ahd_qinfifo_count</span><span class="p">(</span><span class="n">ahd</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u_int</span> <span class="n">prev_tag</span><span class="p">;</span>
		<span class="n">u_int</span> <span class="n">prev_pos</span><span class="p">;</span>

		<span class="n">prev_pos</span> <span class="o">=</span> <span class="n">AHD_QIN_WRAP</span><span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">qinfifonext</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">prev_tag</span> <span class="o">=</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">qinfifo</span><span class="p">[</span><span class="n">prev_pos</span><span class="p">];</span>
		<span class="n">prev_scb</span> <span class="o">=</span> <span class="n">ahd_lookup_scb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">prev_tag</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">ahd_qinfifo_requeue</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">prev_scb</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
	<span class="n">ahd_set_hnscb_qoff</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">qinfifonext</span><span class="p">);</span>
	<span class="n">ahd_restore_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">saved_modes</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_qinfifo_requeue</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scb</span> <span class="o">*</span><span class="n">prev_scb</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">scb</span> <span class="o">*</span><span class="n">scb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">prev_scb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">uint32_t</span> <span class="n">busaddr</span><span class="p">;</span>

		<span class="n">busaddr</span> <span class="o">=</span> <span class="n">ahd_le32toh</span><span class="p">(</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">hscb</span><span class="o">-&gt;</span><span class="n">hscb_busaddr</span><span class="p">);</span>
		<span class="n">ahd_outl</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">NEXT_QUEUED_SCB_ADDR</span><span class="p">,</span> <span class="n">busaddr</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">prev_scb</span><span class="o">-&gt;</span><span class="n">hscb</span><span class="o">-&gt;</span><span class="n">next_hscb_busaddr</span> <span class="o">=</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">hscb</span><span class="o">-&gt;</span><span class="n">hscb_busaddr</span><span class="p">;</span>
		<span class="n">ahd_sync_scb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">prev_scb</span><span class="p">,</span> 
			     <span class="n">BUS_DMASYNC_PREREAD</span><span class="o">|</span><span class="n">BUS_DMASYNC_PREWRITE</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">qinfifo</span><span class="p">[</span><span class="n">AHD_QIN_WRAP</span><span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">qinfifonext</span><span class="p">)]</span> <span class="o">=</span> <span class="n">SCB_GET_TAG</span><span class="p">(</span><span class="n">scb</span><span class="p">);</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">qinfifonext</span><span class="o">++</span><span class="p">;</span>
	<span class="n">scb</span><span class="o">-&gt;</span><span class="n">hscb</span><span class="o">-&gt;</span><span class="n">next_hscb_busaddr</span> <span class="o">=</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">next_queued_hscb</span><span class="o">-&gt;</span><span class="n">hscb_busaddr</span><span class="p">;</span>
	<span class="n">ahd_sync_scb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">,</span> <span class="n">BUS_DMASYNC_PREREAD</span><span class="o">|</span><span class="n">BUS_DMASYNC_PREWRITE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ahd_qinfifo_count</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u_int</span> <span class="n">qinpos</span><span class="p">;</span>
	<span class="n">u_int</span> <span class="n">wrap_qinpos</span><span class="p">;</span>
	<span class="n">u_int</span> <span class="n">wrap_qinfifonext</span><span class="p">;</span>

	<span class="n">AHD_ASSERT_MODES</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHD_MODE_CCHAN_MSK</span><span class="p">,</span> <span class="n">AHD_MODE_CCHAN_MSK</span><span class="p">);</span>
	<span class="n">qinpos</span> <span class="o">=</span> <span class="n">ahd_get_snscb_qoff</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
	<span class="n">wrap_qinpos</span> <span class="o">=</span> <span class="n">AHD_QIN_WRAP</span><span class="p">(</span><span class="n">qinpos</span><span class="p">);</span>
	<span class="n">wrap_qinfifonext</span> <span class="o">=</span> <span class="n">AHD_QIN_WRAP</span><span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">qinfifonext</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wrap_qinfifonext</span> <span class="o">&gt;=</span> <span class="n">wrap_qinpos</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">wrap_qinfifonext</span> <span class="o">-</span> <span class="n">wrap_qinpos</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">wrap_qinfifonext</span>
		      <span class="o">+</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">qinfifo</span><span class="p">)</span> <span class="o">-</span> <span class="n">wrap_qinpos</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_reset_cmds_pending</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span>		<span class="n">scb</span> <span class="o">*</span><span class="n">scb</span><span class="p">;</span>
	<span class="n">ahd_mode_state</span>	<span class="n">saved_modes</span><span class="p">;</span>
	<span class="n">u_int</span>		<span class="n">pending_cmds</span><span class="p">;</span>

	<span class="n">saved_modes</span> <span class="o">=</span> <span class="n">ahd_save_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
	<span class="n">ahd_set_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHD_MODE_CCHAN</span><span class="p">,</span> <span class="n">AHD_MODE_CCHAN</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Don&#39;t count any commands as outstanding that the</span>
<span class="cm">	 * sequencer has already marked for completion.</span>
<span class="cm">	 */</span>
	<span class="n">ahd_flush_qoutfifo</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>

	<span class="n">pending_cmds</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">LIST_FOREACH</span><span class="p">(</span><span class="n">scb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">pending_scbs</span><span class="p">,</span> <span class="n">pending_links</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pending_cmds</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ahd_outw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CMDS_PENDING</span><span class="p">,</span> <span class="n">pending_cmds</span> <span class="o">-</span> <span class="n">ahd_qinfifo_count</span><span class="p">(</span><span class="n">ahd</span><span class="p">));</span>
	<span class="n">ahd_restore_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">saved_modes</span><span class="p">);</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">AHD_UPDATE_PEND_CMDS</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_done_with_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scb</span> <span class="o">*</span><span class="n">scb</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cam_status</span> <span class="n">ostat</span><span class="p">;</span>
	<span class="n">cam_status</span> <span class="n">cstat</span><span class="p">;</span>

	<span class="n">ostat</span> <span class="o">=</span> <span class="n">ahd_get_transaction_status</span><span class="p">(</span><span class="n">scb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ostat</span> <span class="o">==</span> <span class="n">CAM_REQ_INPROG</span><span class="p">)</span>
		<span class="n">ahd_set_transaction_status</span><span class="p">(</span><span class="n">scb</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="n">cstat</span> <span class="o">=</span> <span class="n">ahd_get_transaction_status</span><span class="p">(</span><span class="n">scb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cstat</span> <span class="o">!=</span> <span class="n">CAM_REQ_CMP</span><span class="p">)</span>
		<span class="n">ahd_freeze_scb</span><span class="p">(</span><span class="n">scb</span><span class="p">);</span>
	<span class="n">ahd_done</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">ahd_search_qinfifo</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">,</span> <span class="kt">char</span> <span class="n">channel</span><span class="p">,</span>
		   <span class="kt">int</span> <span class="n">lun</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">tag</span><span class="p">,</span> <span class="n">role_t</span> <span class="n">role</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">status</span><span class="p">,</span>
		   <span class="n">ahd_search_action</span> <span class="n">action</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scb</span>	<span class="o">*</span><span class="n">scb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scb</span>	<span class="o">*</span><span class="n">mk_msg_scb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scb</span>	<span class="o">*</span><span class="n">prev_scb</span><span class="p">;</span>
	<span class="n">ahd_mode_state</span>	 <span class="n">saved_modes</span><span class="p">;</span>
	<span class="n">u_int</span>		 <span class="n">qinstart</span><span class="p">;</span>
	<span class="n">u_int</span>		 <span class="n">qinpos</span><span class="p">;</span>
	<span class="n">u_int</span>		 <span class="n">qintail</span><span class="p">;</span>
	<span class="n">u_int</span>		 <span class="n">tid_next</span><span class="p">;</span>
	<span class="n">u_int</span>		 <span class="n">tid_prev</span><span class="p">;</span>
	<span class="n">u_int</span>		 <span class="n">scbid</span><span class="p">;</span>
	<span class="n">u_int</span>		 <span class="n">seq_flags2</span><span class="p">;</span>
	<span class="n">u_int</span>		 <span class="n">savedscbptr</span><span class="p">;</span>
	<span class="kt">uint32_t</span>	 <span class="n">busaddr</span><span class="p">;</span>
	<span class="kt">int</span>		 <span class="n">found</span><span class="p">;</span>
	<span class="kt">int</span>		 <span class="n">targets</span><span class="p">;</span>

	<span class="cm">/* Must be in CCHAN mode */</span>
	<span class="n">saved_modes</span> <span class="o">=</span> <span class="n">ahd_save_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
	<span class="n">ahd_set_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHD_MODE_CCHAN</span><span class="p">,</span> <span class="n">AHD_MODE_CCHAN</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Halt any pending SCB DMA.  The sequencer will reinitiate</span>
<span class="cm">	 * this dma if the qinfifo is not empty once we unpause.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CCSCBCTL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">CCARREN</span><span class="o">|</span><span class="n">CCSCBEN</span><span class="o">|</span><span class="n">CCSCBDIR</span><span class="p">))</span>
	 <span class="o">==</span> <span class="p">(</span><span class="n">CCARREN</span><span class="o">|</span><span class="n">CCSCBEN</span><span class="o">|</span><span class="n">CCSCBDIR</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CCSCBCTL</span><span class="p">,</span>
			 <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CCSCBCTL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">CCARREN</span><span class="o">|</span><span class="n">CCSCBEN</span><span class="p">));</span>
		<span class="k">while</span> <span class="p">((</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CCSCBCTL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">CCARREN</span><span class="o">|</span><span class="n">CCSCBEN</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Determine sequencer&#39;s position in the qinfifo. */</span>
	<span class="n">qintail</span> <span class="o">=</span> <span class="n">AHD_QIN_WRAP</span><span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">qinfifonext</span><span class="p">);</span>
	<span class="n">qinstart</span> <span class="o">=</span> <span class="n">ahd_get_snscb_qoff</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
	<span class="n">qinpos</span> <span class="o">=</span> <span class="n">AHD_QIN_WRAP</span><span class="p">(</span><span class="n">qinstart</span><span class="p">);</span>
	<span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">prev_scb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">action</span> <span class="o">==</span> <span class="n">SEARCH_PRINT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;qinstart = %d qinfifonext = %d</span><span class="se">\n</span><span class="s">QINFIFO:&quot;</span><span class="p">,</span>
		       <span class="n">qinstart</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">qinfifonext</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Start with an empty queue.  Entries that are not chosen</span>
<span class="cm">	 * for removal will be re-added to the queue as we go.</span>
<span class="cm">	 */</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">qinfifonext</span> <span class="o">=</span> <span class="n">qinstart</span><span class="p">;</span>
	<span class="n">busaddr</span> <span class="o">=</span> <span class="n">ahd_le32toh</span><span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">next_queued_hscb</span><span class="o">-&gt;</span><span class="n">hscb_busaddr</span><span class="p">);</span>
	<span class="n">ahd_outl</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">NEXT_QUEUED_SCB_ADDR</span><span class="p">,</span> <span class="n">busaddr</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">qinpos</span> <span class="o">!=</span> <span class="n">qintail</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">scb</span> <span class="o">=</span> <span class="n">ahd_lookup_scb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">qinfifo</span><span class="p">[</span><span class="n">qinpos</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">scb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;qinpos = %d, SCB index = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">qinpos</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">qinfifo</span><span class="p">[</span><span class="n">qinpos</span><span class="p">]);</span>
			<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Loop 1</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ahd_match_scb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">lun</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="n">role</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * We found an scb that needs to be acted on.</span>
<span class="cm">			 */</span>
			<span class="n">found</span><span class="o">++</span><span class="p">;</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">action</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">SEARCH_COMPLETE</span>:
				<span class="k">if</span> <span class="p">((</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SCB_ACTIVE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
					<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Inactive SCB in qinfifo</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">ahd_done_with_status</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
				<span class="cm">/* FALLTHROUGH */</span>
			<span class="k">case</span> <span class="n">SEARCH_REMOVE</span>:
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">SEARCH_PRINT</span>:
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot; 0x%x&quot;</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">qinfifo</span><span class="p">[</span><span class="n">qinpos</span><span class="p">]);</span>
				<span class="cm">/* FALLTHROUGH */</span>
			<span class="k">case</span> <span class="n">SEARCH_COUNT</span>:
				<span class="n">ahd_qinfifo_requeue</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">prev_scb</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
				<span class="n">prev_scb</span> <span class="o">=</span> <span class="n">scb</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ahd_qinfifo_requeue</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">prev_scb</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
			<span class="n">prev_scb</span> <span class="o">=</span> <span class="n">scb</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">qinpos</span> <span class="o">=</span> <span class="n">AHD_QIN_WRAP</span><span class="p">(</span><span class="n">qinpos</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ahd_set_hnscb_qoff</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">qinfifonext</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">action</span> <span class="o">==</span> <span class="n">SEARCH_PRINT</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">WAITING_TID_QUEUES:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Search waiting for selection lists.  We traverse the</span>
<span class="cm">	 * list of &quot;their ids&quot; waiting for selection and, if</span>
<span class="cm">	 * appropriate, traverse the SCBs of each &quot;their id&quot;</span>
<span class="cm">	 * looking for matches.</span>
<span class="cm">	 */</span>
	<span class="n">ahd_set_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI</span><span class="p">);</span>
	<span class="n">seq_flags2</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SEQ_FLAGS2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">seq_flags2</span> <span class="o">&amp;</span> <span class="n">PENDING_MK_MESSAGE</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">scbid</span> <span class="o">=</span> <span class="n">ahd_inw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">MK_MESSAGE_SCB</span><span class="p">);</span>
		<span class="n">mk_msg_scb</span> <span class="o">=</span> <span class="n">ahd_lookup_scb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scbid</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">mk_msg_scb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">savedscbptr</span> <span class="o">=</span> <span class="n">ahd_get_scbptr</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
	<span class="n">tid_next</span> <span class="o">=</span> <span class="n">ahd_inw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">WAITING_TID_HEAD</span><span class="p">);</span>
	<span class="n">tid_prev</span> <span class="o">=</span> <span class="n">SCB_LIST_NULL</span><span class="p">;</span>
	<span class="n">targets</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">scbid</span> <span class="o">=</span> <span class="n">tid_next</span><span class="p">;</span> <span class="o">!</span><span class="n">SCBID_IS_NULL</span><span class="p">(</span><span class="n">scbid</span><span class="p">);</span> <span class="n">scbid</span> <span class="o">=</span> <span class="n">tid_next</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u_int</span> <span class="n">tid_head</span><span class="p">;</span>
		<span class="n">u_int</span> <span class="n">tid_tail</span><span class="p">;</span>

		<span class="n">targets</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">targets</span> <span class="o">&gt;</span> <span class="n">AHD_NUM_TARGETS</span><span class="p">)</span>
			<span class="n">panic</span><span class="p">(</span><span class="s">&quot;TID LIST LOOP&quot;</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">scbid</span> <span class="o">&gt;=</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">scb_data</span><span class="p">.</span><span class="n">numscbs</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: Waiting TID List inconsistency. &quot;</span>
			       <span class="s">&quot;SCB index == 0x%x, yet numscbs == 0x%x.&quot;</span><span class="p">,</span>
			       <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">),</span> <span class="n">scbid</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">scb_data</span><span class="p">.</span><span class="n">numscbs</span><span class="p">);</span>
			<span class="n">ahd_dump_card_state</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
			<span class="n">panic</span><span class="p">(</span><span class="s">&quot;for safety&quot;</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">scb</span> <span class="o">=</span> <span class="n">ahd_lookup_scb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scbid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">scb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: SCB = 0x%x Not Active!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">),</span> <span class="n">scbid</span><span class="p">);</span>
			<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Waiting TID List traversal</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">ahd_set_scbptr</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scbid</span><span class="p">);</span>
		<span class="n">tid_next</span> <span class="o">=</span> <span class="n">ahd_inw_scbram</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_NEXT2</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ahd_match_scb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">CAM_LUN_WILDCARD</span><span class="p">,</span>
				  <span class="n">SCB_LIST_NULL</span><span class="p">,</span> <span class="n">ROLE_UNKNOWN</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tid_prev</span> <span class="o">=</span> <span class="n">scbid</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * We found a list of scbs that needs to be searched.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">action</span> <span class="o">==</span> <span class="n">SEARCH_PRINT</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;       %d ( &quot;</span><span class="p">,</span> <span class="n">SCB_GET_TARGET</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">));</span>
		<span class="n">tid_head</span> <span class="o">=</span> <span class="n">scbid</span><span class="p">;</span>
		<span class="n">found</span> <span class="o">+=</span> <span class="n">ahd_search_scb_list</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span>
					     <span class="n">lun</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="n">role</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span>
					     <span class="n">action</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tid_head</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tid_tail</span><span class="p">,</span>
					     <span class="n">SCB_GET_TARGET</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">));</span>
		<span class="cm">/*</span>
<span class="cm">		 * Check any MK_MESSAGE SCB that is still waiting to</span>
<span class="cm">		 * enter this target&#39;s waiting for selection queue.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mk_msg_scb</span> <span class="o">!=</span> <span class="nb">NULL</span>
		 <span class="o">&amp;&amp;</span> <span class="n">ahd_match_scb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">mk_msg_scb</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span>
				  <span class="n">lun</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="n">role</span><span class="p">))</span> <span class="p">{</span>

			<span class="cm">/*</span>
<span class="cm">			 * We found an scb that needs to be acted on.</span>
<span class="cm">			 */</span>
			<span class="n">found</span><span class="o">++</span><span class="p">;</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">action</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">SEARCH_COMPLETE</span>:
				<span class="k">if</span> <span class="p">((</span><span class="n">mk_msg_scb</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SCB_ACTIVE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
					<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Inactive SCB pending MK_MSG</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">ahd_done_with_status</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">mk_msg_scb</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
				<span class="cm">/* FALLTHROUGH */</span>
			<span class="k">case</span> <span class="n">SEARCH_REMOVE</span>:
			<span class="p">{</span>
				<span class="n">u_int</span> <span class="n">tail_offset</span><span class="p">;</span>

				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Removing MK_MSG scb</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

				<span class="cm">/*</span>
<span class="cm">				 * Reset our tail to the tail of the</span>
<span class="cm">				 * main per-target list.</span>
<span class="cm">				 */</span>
				<span class="n">tail_offset</span> <span class="o">=</span> <span class="n">WAITING_SCB_TAILS</span>
				    <span class="o">+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">SCB_GET_TARGET</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">mk_msg_scb</span><span class="p">));</span>
				<span class="n">ahd_outw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">tail_offset</span><span class="p">,</span> <span class="n">tid_tail</span><span class="p">);</span>

				<span class="n">seq_flags2</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PENDING_MK_MESSAGE</span><span class="p">;</span>
				<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SEQ_FLAGS2</span><span class="p">,</span> <span class="n">seq_flags2</span><span class="p">);</span>
				<span class="n">ahd_outw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CMDS_PENDING</span><span class="p">,</span>
					 <span class="n">ahd_inw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CMDS_PENDING</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
				<span class="n">mk_msg_scb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">case</span> <span class="n">SEARCH_PRINT</span>:
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot; 0x%x&quot;</span><span class="p">,</span> <span class="n">SCB_GET_TAG</span><span class="p">(</span><span class="n">scb</span><span class="p">));</span>
				<span class="cm">/* FALLTHROUGH */</span>
			<span class="k">case</span> <span class="n">SEARCH_COUNT</span>:
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">mk_msg_scb</span> <span class="o">!=</span> <span class="nb">NULL</span>
		 <span class="o">&amp;&amp;</span> <span class="n">SCBID_IS_NULL</span><span class="p">(</span><span class="n">tid_head</span><span class="p">)</span>
		 <span class="o">&amp;&amp;</span> <span class="n">ahd_match_scb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">CAM_LUN_WILDCARD</span><span class="p">,</span>
				  <span class="n">SCB_LIST_NULL</span><span class="p">,</span> <span class="n">ROLE_UNKNOWN</span><span class="p">))</span> <span class="p">{</span>

			<span class="cm">/*</span>
<span class="cm">			 * When removing the last SCB for a target</span>
<span class="cm">			 * queue with a pending MK_MESSAGE scb, we</span>
<span class="cm">			 * must queue the MK_MESSAGE scb.</span>
<span class="cm">			 */</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Queueing mk_msg_scb</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">tid_head</span> <span class="o">=</span> <span class="n">ahd_inw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">MK_MESSAGE_SCB</span><span class="p">);</span>
			<span class="n">seq_flags2</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PENDING_MK_MESSAGE</span><span class="p">;</span>
			<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SEQ_FLAGS2</span><span class="p">,</span> <span class="n">seq_flags2</span><span class="p">);</span>
			<span class="n">mk_msg_scb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tid_head</span> <span class="o">!=</span> <span class="n">scbid</span><span class="p">)</span>
			<span class="n">ahd_stitch_tid_list</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">tid_prev</span><span class="p">,</span> <span class="n">tid_head</span><span class="p">,</span> <span class="n">tid_next</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">SCBID_IS_NULL</span><span class="p">(</span><span class="n">tid_head</span><span class="p">))</span>
			<span class="n">tid_prev</span> <span class="o">=</span> <span class="n">tid_head</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">action</span> <span class="o">==</span> <span class="n">SEARCH_PRINT</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Restore saved state. */</span>
	<span class="n">ahd_set_scbptr</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">savedscbptr</span><span class="p">);</span>
	<span class="n">ahd_restore_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">saved_modes</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">found</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ahd_search_scb_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">,</span> <span class="kt">char</span> <span class="n">channel</span><span class="p">,</span>
		    <span class="kt">int</span> <span class="n">lun</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">tag</span><span class="p">,</span> <span class="n">role_t</span> <span class="n">role</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">status</span><span class="p">,</span>
		    <span class="n">ahd_search_action</span> <span class="n">action</span><span class="p">,</span> <span class="n">u_int</span> <span class="o">*</span><span class="n">list_head</span><span class="p">,</span> 
		    <span class="n">u_int</span> <span class="o">*</span><span class="n">list_tail</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">tid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span>	<span class="n">scb</span> <span class="o">*</span><span class="n">scb</span><span class="p">;</span>
	<span class="n">u_int</span>	<span class="n">scbid</span><span class="p">;</span>
	<span class="n">u_int</span>	<span class="n">next</span><span class="p">;</span>
	<span class="n">u_int</span>	<span class="n">prev</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">found</span><span class="p">;</span>

	<span class="n">AHD_ASSERT_MODES</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI_MSK</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI_MSK</span><span class="p">);</span>
	<span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">prev</span> <span class="o">=</span> <span class="n">SCB_LIST_NULL</span><span class="p">;</span>
	<span class="n">next</span> <span class="o">=</span> <span class="o">*</span><span class="n">list_head</span><span class="p">;</span>
	<span class="o">*</span><span class="n">list_tail</span> <span class="o">=</span> <span class="n">SCB_LIST_NULL</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">scbid</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span> <span class="o">!</span><span class="n">SCBID_IS_NULL</span><span class="p">(</span><span class="n">scbid</span><span class="p">);</span> <span class="n">scbid</span> <span class="o">=</span> <span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">scbid</span> <span class="o">&gt;=</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">scb_data</span><span class="p">.</span><span class="n">numscbs</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s:SCB List inconsistency. &quot;</span>
			       <span class="s">&quot;SCB == 0x%x, yet numscbs == 0x%x.&quot;</span><span class="p">,</span>
			       <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">),</span> <span class="n">scbid</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">scb_data</span><span class="p">.</span><span class="n">numscbs</span><span class="p">);</span>
			<span class="n">ahd_dump_card_state</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
			<span class="n">panic</span><span class="p">(</span><span class="s">&quot;for safety&quot;</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">scb</span> <span class="o">=</span> <span class="n">ahd_lookup_scb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scbid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">scb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: SCB = %d Not Active!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">),</span> <span class="n">scbid</span><span class="p">);</span>
			<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Waiting List traversal</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">ahd_set_scbptr</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scbid</span><span class="p">);</span>
		<span class="o">*</span><span class="n">list_tail</span> <span class="o">=</span> <span class="n">scbid</span><span class="p">;</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">ahd_inw_scbram</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_NEXT</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ahd_match_scb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span>
				  <span class="n">lun</span><span class="p">,</span> <span class="n">SCB_LIST_NULL</span><span class="p">,</span> <span class="n">role</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">prev</span> <span class="o">=</span> <span class="n">scbid</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">found</span><span class="o">++</span><span class="p">;</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">action</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">SEARCH_COMPLETE</span>:
			<span class="k">if</span> <span class="p">((</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SCB_ACTIVE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Inactive SCB in Waiting List</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">ahd_done_with_status</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
			<span class="cm">/* FALLTHROUGH */</span>
		<span class="k">case</span> <span class="n">SEARCH_REMOVE</span>:
			<span class="n">ahd_rem_wscb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scbid</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">tid</span><span class="p">);</span>
			<span class="o">*</span><span class="n">list_tail</span> <span class="o">=</span> <span class="n">prev</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">SCBID_IS_NULL</span><span class="p">(</span><span class="n">prev</span><span class="p">))</span>
				<span class="o">*</span><span class="n">list_head</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">SEARCH_PRINT</span>:
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;0x%x &quot;</span><span class="p">,</span> <span class="n">scbid</span><span class="p">);</span>
		<span class="k">case</span> <span class="n">SEARCH_COUNT</span>:
			<span class="n">prev</span> <span class="o">=</span> <span class="n">scbid</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">found</span> <span class="o">&gt;</span> <span class="n">AHD_SCB_MAX</span><span class="p">)</span>
			<span class="n">panic</span><span class="p">(</span><span class="s">&quot;SCB LIST LOOP&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">action</span> <span class="o">==</span> <span class="n">SEARCH_COMPLETE</span>
	 <span class="o">||</span> <span class="n">action</span> <span class="o">==</span> <span class="n">SEARCH_REMOVE</span><span class="p">)</span>
		<span class="n">ahd_outw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CMDS_PENDING</span><span class="p">,</span> <span class="n">ahd_inw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CMDS_PENDING</span><span class="p">)</span> <span class="o">-</span> <span class="n">found</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">found</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_stitch_tid_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">tid_prev</span><span class="p">,</span>
		    <span class="n">u_int</span> <span class="n">tid_cur</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">tid_next</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">AHD_ASSERT_MODES</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI_MSK</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI_MSK</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">SCBID_IS_NULL</span><span class="p">(</span><span class="n">tid_cur</span><span class="p">))</span> <span class="p">{</span>

		<span class="cm">/* Bypass current TID list */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">SCBID_IS_NULL</span><span class="p">(</span><span class="n">tid_prev</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ahd_outw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">WAITING_TID_HEAD</span><span class="p">,</span> <span class="n">tid_next</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ahd_set_scbptr</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">tid_prev</span><span class="p">);</span>
			<span class="n">ahd_outw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_NEXT2</span><span class="p">,</span> <span class="n">tid_next</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">SCBID_IS_NULL</span><span class="p">(</span><span class="n">tid_next</span><span class="p">))</span>
			<span class="n">ahd_outw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">WAITING_TID_TAIL</span><span class="p">,</span> <span class="n">tid_prev</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>

		<span class="cm">/* Stitch through tid_cur */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">SCBID_IS_NULL</span><span class="p">(</span><span class="n">tid_prev</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ahd_outw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">WAITING_TID_HEAD</span><span class="p">,</span> <span class="n">tid_cur</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ahd_set_scbptr</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">tid_prev</span><span class="p">);</span>
			<span class="n">ahd_outw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_NEXT2</span><span class="p">,</span> <span class="n">tid_cur</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">ahd_set_scbptr</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">tid_cur</span><span class="p">);</span>
		<span class="n">ahd_outw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_NEXT2</span><span class="p">,</span> <span class="n">tid_next</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">SCBID_IS_NULL</span><span class="p">(</span><span class="n">tid_next</span><span class="p">))</span>
			<span class="n">ahd_outw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">WAITING_TID_TAIL</span><span class="p">,</span> <span class="n">tid_cur</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Manipulate the waiting for selection list and return the</span>
<span class="cm"> * scb that follows the one that we remove.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u_int</span>
<span class="nf">ahd_rem_wscb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">scbid</span><span class="p">,</span>
	     <span class="n">u_int</span> <span class="n">prev</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">next</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">tid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u_int</span> <span class="n">tail_offset</span><span class="p">;</span>

	<span class="n">AHD_ASSERT_MODES</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI_MSK</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI_MSK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">SCBID_IS_NULL</span><span class="p">(</span><span class="n">prev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ahd_set_scbptr</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">prev</span><span class="p">);</span>
		<span class="n">ahd_outw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_NEXT</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * SCBs that have MK_MESSAGE set in them may</span>
<span class="cm">	 * cause the tail pointer to be updated without</span>
<span class="cm">	 * setting the next pointer of the previous tail.</span>
<span class="cm">	 * Only clear the tail if the removed SCB was</span>
<span class="cm">	 * the tail.</span>
<span class="cm">	 */</span>
	<span class="n">tail_offset</span> <span class="o">=</span> <span class="n">WAITING_SCB_TAILS</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">tid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">SCBID_IS_NULL</span><span class="p">(</span><span class="n">next</span><span class="p">)</span>
	 <span class="o">&amp;&amp;</span> <span class="n">ahd_inw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">tail_offset</span><span class="p">)</span> <span class="o">==</span> <span class="n">scbid</span><span class="p">)</span>
		<span class="n">ahd_outw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">tail_offset</span><span class="p">,</span> <span class="n">prev</span><span class="p">);</span>

	<span class="n">ahd_add_scb_to_free_list</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scbid</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">next</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Add the SCB as selected by SCBPTR onto the on chip list of</span>
<span class="cm"> * free hardware SCBs.  This list is empty/unused if we are not</span>
<span class="cm"> * performing SCB paging.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_add_scb_to_free_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">scbid</span><span class="p">)</span>
<span class="p">{</span>
<span class="cm">/* XXX Need some other mechanism to designate &quot;free&quot;. */</span>
	<span class="cm">/*</span>
<span class="cm">	 * Invalidate the tag so that our abort</span>
<span class="cm">	 * routines don&#39;t think it&#39;s active.</span>
<span class="cm">	ahd_outb(ahd, SCB_TAG, SCB_LIST_NULL);</span>
<span class="cm">	 */</span>
<span class="p">}</span>

<span class="cm">/******************************** Error Handling ******************************/</span>
<span class="cm">/*</span>
<span class="cm"> * Abort all SCBs that match the given description (target/channel/lun/tag),</span>
<span class="cm"> * setting their status to the passed in status if the status has not already</span>
<span class="cm"> * been modified from CAM_REQ_INPROG.  This routine assumes that the sequencer</span>
<span class="cm"> * is paused before it is called.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ahd_abort_scbs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">,</span> <span class="kt">char</span> <span class="n">channel</span><span class="p">,</span>
	       <span class="kt">int</span> <span class="n">lun</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">tag</span><span class="p">,</span> <span class="n">role_t</span> <span class="n">role</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span>		<span class="n">scb</span> <span class="o">*</span><span class="n">scbp</span><span class="p">;</span>
	<span class="k">struct</span>		<span class="n">scb</span> <span class="o">*</span><span class="n">scbp_next</span><span class="p">;</span>
	<span class="n">u_int</span>		<span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
	<span class="n">u_int</span>		<span class="n">maxtarget</span><span class="p">;</span>
	<span class="n">u_int</span>		<span class="n">minlun</span><span class="p">;</span>
	<span class="n">u_int</span>		<span class="n">maxlun</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">found</span><span class="p">;</span>
	<span class="n">ahd_mode_state</span>	<span class="n">saved_modes</span><span class="p">;</span>

	<span class="cm">/* restore this when we&#39;re done */</span>
	<span class="n">saved_modes</span> <span class="o">=</span> <span class="n">ahd_save_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
	<span class="n">ahd_set_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI</span><span class="p">);</span>

	<span class="n">found</span> <span class="o">=</span> <span class="n">ahd_search_qinfifo</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">lun</span><span class="p">,</span> <span class="n">SCB_LIST_NULL</span><span class="p">,</span>
				   <span class="n">role</span><span class="p">,</span> <span class="n">CAM_REQUEUE_REQ</span><span class="p">,</span> <span class="n">SEARCH_COMPLETE</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Clean out the busy target table for any untagged commands.</span>
<span class="cm">	 */</span>
	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">maxtarget</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">target</span> <span class="o">!=</span> <span class="n">CAM_TARGET_WILDCARD</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">target</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">channel</span> <span class="o">==</span> <span class="sc">&#39;B&#39;</span><span class="p">)</span>
			<span class="n">i</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">maxtarget</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lun</span> <span class="o">==</span> <span class="n">CAM_LUN_WILDCARD</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">minlun</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">maxlun</span> <span class="o">=</span> <span class="n">AHD_NUM_LUNS_NONPKT</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">lun</span> <span class="o">&gt;=</span> <span class="n">AHD_NUM_LUNS_NONPKT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">minlun</span> <span class="o">=</span> <span class="n">maxlun</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">minlun</span> <span class="o">=</span> <span class="n">lun</span><span class="p">;</span>
		<span class="n">maxlun</span> <span class="o">=</span> <span class="n">lun</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">role</span> <span class="o">!=</span> <span class="n">ROLE_TARGET</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(;</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">maxtarget</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">minlun</span><span class="p">;</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">maxlun</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">u_int</span> <span class="n">scbid</span><span class="p">;</span>
				<span class="n">u_int</span> <span class="n">tcl</span><span class="p">;</span>

				<span class="n">tcl</span> <span class="o">=</span> <span class="n">BUILD_TCL_RAW</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="sc">&#39;A&#39;</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
				<span class="n">scbid</span> <span class="o">=</span> <span class="n">ahd_find_busy_tcl</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">tcl</span><span class="p">);</span>
				<span class="n">scbp</span> <span class="o">=</span> <span class="n">ahd_lookup_scb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scbid</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">scbp</span> <span class="o">==</span> <span class="nb">NULL</span>
				 <span class="o">||</span> <span class="n">ahd_match_scb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scbp</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span>
						  <span class="n">lun</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="n">role</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">continue</span><span class="p">;</span>
				<span class="n">ahd_unbusy_tcl</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">BUILD_TCL_RAW</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="sc">&#39;A&#39;</span><span class="p">,</span> <span class="n">j</span><span class="p">));</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Don&#39;t abort commands that have already completed,</span>
<span class="cm">	 * but haven&#39;t quite made it up to the host yet.</span>
<span class="cm">	 */</span>
	<span class="n">ahd_flush_qoutfifo</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Go through the pending CCB list and look for</span>
<span class="cm">	 * commands for this target that are still active.</span>
<span class="cm">	 * These are other tagged commands that were</span>
<span class="cm">	 * disconnected when the reset occurred.</span>
<span class="cm">	 */</span>
	<span class="n">scbp_next</span> <span class="o">=</span> <span class="n">LIST_FIRST</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">pending_scbs</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">scbp_next</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">scbp</span> <span class="o">=</span> <span class="n">scbp_next</span><span class="p">;</span>
		<span class="n">scbp_next</span> <span class="o">=</span> <span class="n">LIST_NEXT</span><span class="p">(</span><span class="n">scbp</span><span class="p">,</span> <span class="n">pending_links</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ahd_match_scb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scbp</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">lun</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="n">role</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">cam_status</span> <span class="n">ostat</span><span class="p">;</span>

			<span class="n">ostat</span> <span class="o">=</span> <span class="n">ahd_get_transaction_status</span><span class="p">(</span><span class="n">scbp</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ostat</span> <span class="o">==</span> <span class="n">CAM_REQ_INPROG</span><span class="p">)</span>
				<span class="n">ahd_set_transaction_status</span><span class="p">(</span><span class="n">scbp</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ahd_get_transaction_status</span><span class="p">(</span><span class="n">scbp</span><span class="p">)</span> <span class="o">!=</span> <span class="n">CAM_REQ_CMP</span><span class="p">)</span>
				<span class="n">ahd_freeze_scb</span><span class="p">(</span><span class="n">scbp</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">scbp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SCB_ACTIVE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Inactive SCB on pending list</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">ahd_done</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scbp</span><span class="p">);</span>
			<span class="n">found</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">ahd_restore_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">saved_modes</span><span class="p">);</span>
	<span class="n">ahd_platform_abort_scbs</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">lun</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="n">role</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">AHD_UPDATE_PEND_CMDS</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">found</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_reset_current_bus</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint8_t</span> <span class="n">scsiseq</span><span class="p">;</span>

	<span class="n">AHD_ASSERT_MODES</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI_MSK</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI_MSK</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SIMODE1</span><span class="p">,</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SIMODE1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">ENSCSIRST</span><span class="p">);</span>
	<span class="n">scsiseq</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCSISEQ0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">ENSELO</span><span class="o">|</span><span class="n">ENARBO</span><span class="o">|</span><span class="n">SCSIRSTO</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCSISEQ0</span><span class="p">,</span> <span class="n">scsiseq</span> <span class="o">|</span> <span class="n">SCSIRSTO</span><span class="p">);</span>
	<span class="n">ahd_flush_device_writes</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
	<span class="n">ahd_delay</span><span class="p">(</span><span class="n">AHD_BUSRESET_DELAY</span><span class="p">);</span>
	<span class="cm">/* Turn off the bus reset */</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCSISEQ0</span><span class="p">,</span> <span class="n">scsiseq</span><span class="p">);</span>
	<span class="n">ahd_flush_device_writes</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
	<span class="n">ahd_delay</span><span class="p">(</span><span class="n">AHD_BUSRESET_DELAY</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">bugs</span> <span class="o">&amp;</span> <span class="n">AHD_SCSIRST_BUG</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * 2A Razor #474</span>
<span class="cm">		 * Certain chip state is not cleared for</span>
<span class="cm">		 * SCSI bus resets that we initiate, so</span>
<span class="cm">		 * we must reset the chip.</span>
<span class="cm">		 */</span>
		<span class="n">ahd_reset</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="cm">/*reinit*/</span><span class="n">TRUE</span><span class="p">);</span>
		<span class="n">ahd_intr_enable</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="cm">/*enable*/</span><span class="n">TRUE</span><span class="p">);</span>
		<span class="n">AHD_ASSERT_MODES</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI_MSK</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI_MSK</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ahd_clear_intstat</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">ahd_reset_channel</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="kt">char</span> <span class="n">channel</span><span class="p">,</span> <span class="kt">int</span> <span class="n">initiate_reset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span>	<span class="n">ahd_devinfo</span> <span class="n">caminfo</span><span class="p">;</span>
	<span class="n">u_int</span>	<span class="n">initiator</span><span class="p">;</span>
	<span class="n">u_int</span>	<span class="n">target</span><span class="p">;</span>
	<span class="n">u_int</span>	<span class="n">max_scsiid</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">found</span><span class="p">;</span>
	<span class="n">u_int</span>	<span class="n">fifo</span><span class="p">;</span>
	<span class="n">u_int</span>	<span class="n">next_fifo</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">scsiseq</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check if the last bus reset is cleared</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AHD_BUS_RESET_ACTIVE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: bus reset still active</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">));</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">AHD_BUS_RESET_ACTIVE</span><span class="p">;</span>

	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">pending_device</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">ahd_compile_devinfo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">caminfo</span><span class="p">,</span>
			    <span class="n">CAM_TARGET_WILDCARD</span><span class="p">,</span>
			    <span class="n">CAM_TARGET_WILDCARD</span><span class="p">,</span>
			    <span class="n">CAM_LUN_WILDCARD</span><span class="p">,</span>
			    <span class="n">channel</span><span class="p">,</span> <span class="n">ROLE_UNKNOWN</span><span class="p">);</span>
	<span class="n">ahd_pause</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>

	<span class="cm">/* Make sure the sequencer is in a safe location. */</span>
	<span class="n">ahd_clear_critical_section</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Run our command complete fifos to ensure that we perform</span>
<span class="cm">	 * completion processing on any commands that &#39;completed&#39;</span>
<span class="cm">	 * before the reset occurred.</span>
<span class="cm">	 */</span>
	<span class="n">ahd_run_qoutfifo</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
<span class="cp">#ifdef AHD_TARGET_MODE</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AHD_TARGETROLE</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ahd_run_tqinfifo</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="cm">/*paused*/</span><span class="n">TRUE</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="n">ahd_set_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Disable selections so no automatic hardware</span>
<span class="cm">	 * functions will modify chip state.</span>
<span class="cm">	 */</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCSISEQ0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCSISEQ1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Safely shut down our DMA engines.  Always start with</span>
<span class="cm">	 * the FIFO that is not currently active (if any are</span>
<span class="cm">	 * actively connected).</span>
<span class="cm">	 */</span>
	<span class="n">next_fifo</span> <span class="o">=</span> <span class="n">fifo</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">DFFSTAT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">CURRFIFO</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">next_fifo</span> <span class="o">&gt;</span> <span class="n">CURRFIFO_1</span><span class="p">)</span>
		<span class="cm">/* If disconneced, arbitrarily start with FIFO1. */</span>
		<span class="n">next_fifo</span> <span class="o">=</span> <span class="n">fifo</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">next_fifo</span> <span class="o">^=</span> <span class="n">CURRFIFO_1</span><span class="p">;</span>
		<span class="n">ahd_set_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">next_fifo</span><span class="p">,</span> <span class="n">next_fifo</span><span class="p">);</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">DFCNTRL</span><span class="p">,</span>
			 <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">DFCNTRL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">SCSIEN</span><span class="o">|</span><span class="n">HDMAEN</span><span class="p">));</span>
		<span class="k">while</span> <span class="p">((</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">DFCNTRL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">HDMAENACK</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ahd_delay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Set CURRFIFO to the now inactive channel.</span>
<span class="cm">		 */</span>
		<span class="n">ahd_set_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI</span><span class="p">);</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">DFFSTAT</span><span class="p">,</span> <span class="n">next_fifo</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">next_fifo</span> <span class="o">!=</span> <span class="n">fifo</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Reset the bus if we are initiating this reset</span>
<span class="cm">	 */</span>
	<span class="n">ahd_clear_msg_state</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SIMODE1</span><span class="p">,</span>
		 <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SIMODE1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">ENBUSFREE</span><span class="o">|</span><span class="n">ENSCSIRST</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">initiate_reset</span><span class="p">)</span>
		<span class="n">ahd_reset_current_bus</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>

	<span class="n">ahd_clear_intstat</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Clean up all the state information for the</span>
<span class="cm">	 * pending transactions on this bus.</span>
<span class="cm">	 */</span>
	<span class="n">found</span> <span class="o">=</span> <span class="n">ahd_abort_scbs</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CAM_TARGET_WILDCARD</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span>
			       <span class="n">CAM_LUN_WILDCARD</span><span class="p">,</span> <span class="n">SCB_LIST_NULL</span><span class="p">,</span>
			       <span class="n">ROLE_UNKNOWN</span><span class="p">,</span> <span class="n">CAM_SCSI_BUS_RESET</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Cleanup anything left in the FIFOs.</span>
<span class="cm">	 */</span>
	<span class="n">ahd_clear_fifo</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ahd_clear_fifo</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Clear SCSI interrupt status</span>
<span class="cm">	 */</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CLRSINT1</span><span class="p">,</span> <span class="n">CLRSCSIRSTI</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Reenable selections</span>
<span class="cm">	 */</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SIMODE1</span><span class="p">,</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SIMODE1</span><span class="p">)</span> <span class="o">|</span> <span class="n">ENSCSIRST</span><span class="p">);</span>
	<span class="n">scsiseq</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCSISEQ_TEMPLATE</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCSISEQ1</span><span class="p">,</span> <span class="n">scsiseq</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ENSELI</span><span class="o">|</span><span class="n">ENRSELI</span><span class="o">|</span><span class="n">ENAUTOATNP</span><span class="p">));</span>

	<span class="n">max_scsiid</span> <span class="o">=</span> <span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">AHD_WIDE</span><span class="p">)</span> <span class="o">?</span> <span class="mi">15</span> <span class="o">:</span> <span class="mi">7</span><span class="p">;</span>
<span class="cp">#ifdef AHD_TARGET_MODE</span>
	<span class="cm">/*</span>
<span class="cm">	 * Send an immediate notify ccb to all target more peripheral</span>
<span class="cm">	 * drivers affected by this action.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">target</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">target</span> <span class="o">&lt;=</span> <span class="n">max_scsiid</span><span class="p">;</span> <span class="n">target</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ahd_tmode_tstate</span><span class="o">*</span> <span class="n">tstate</span><span class="p">;</span>
		<span class="n">u_int</span> <span class="n">lun</span><span class="p">;</span>

		<span class="n">tstate</span> <span class="o">=</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">enabled_targets</span><span class="p">[</span><span class="n">target</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tstate</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">lun</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">lun</span> <span class="o">&lt;</span> <span class="n">AHD_NUM_LUNS</span><span class="p">;</span> <span class="n">lun</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">ahd_tmode_lstate</span><span class="o">*</span> <span class="n">lstate</span><span class="p">;</span>

			<span class="n">lstate</span> <span class="o">=</span> <span class="n">tstate</span><span class="o">-&gt;</span><span class="n">enabled_luns</span><span class="p">[</span><span class="n">lun</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lstate</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="n">ahd_queue_lstate_event</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">lstate</span><span class="p">,</span> <span class="n">CAM_TARGET_WILDCARD</span><span class="p">,</span>
					       <span class="n">EVENT_TYPE_BUS_RESET</span><span class="p">,</span> <span class="cm">/*arg*/</span><span class="mi">0</span><span class="p">);</span>
			<span class="n">ahd_send_lstate_events</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">lstate</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="cm">/*</span>
<span class="cm">	 * Revert to async/narrow transfers until we renegotiate.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">target</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">target</span> <span class="o">&lt;=</span> <span class="n">max_scsiid</span><span class="p">;</span> <span class="n">target</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">enabled_targets</span><span class="p">[</span><span class="n">target</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">initiator</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">initiator</span> <span class="o">&lt;=</span> <span class="n">max_scsiid</span><span class="p">;</span> <span class="n">initiator</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">ahd_devinfo</span> <span class="n">devinfo</span><span class="p">;</span>

			<span class="n">ahd_compile_devinfo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devinfo</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">initiator</span><span class="p">,</span>
					    <span class="n">CAM_LUN_WILDCARD</span><span class="p">,</span>
					    <span class="sc">&#39;A&#39;</span><span class="p">,</span> <span class="n">ROLE_UNKNOWN</span><span class="p">);</span>
			<span class="n">ahd_set_width</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">devinfo</span><span class="p">,</span> <span class="n">MSG_EXT_WDTR_BUS_8_BIT</span><span class="p">,</span>
				      <span class="n">AHD_TRANS_CUR</span><span class="p">,</span> <span class="cm">/*paused*/</span><span class="n">TRUE</span><span class="p">);</span>
			<span class="n">ahd_set_syncrate</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">devinfo</span><span class="p">,</span> <span class="cm">/*period*/</span><span class="mi">0</span><span class="p">,</span>
					 <span class="cm">/*offset*/</span><span class="mi">0</span><span class="p">,</span> <span class="cm">/*ppr_options*/</span><span class="mi">0</span><span class="p">,</span>
					 <span class="n">AHD_TRANS_CUR</span><span class="p">,</span> <span class="cm">/*paused*/</span><span class="n">TRUE</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Notify the XPT that a bus reset occurred */</span>
	<span class="n">ahd_send_async</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">caminfo</span><span class="p">.</span><span class="n">channel</span><span class="p">,</span> <span class="n">CAM_TARGET_WILDCARD</span><span class="p">,</span>
		       <span class="n">CAM_LUN_WILDCARD</span><span class="p">,</span> <span class="n">AC_BUS_RESET</span><span class="p">);</span>

	<span class="n">ahd_restart</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">found</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**************************** Statistics Processing ***************************/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_stat_timer</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span>	<span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
	<span class="n">u_long</span>	<span class="n">s</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">enint_coal</span><span class="p">;</span>
	
	<span class="n">ahd_lock</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>

	<span class="n">enint_coal</span> <span class="o">=</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">hs_mailbox</span> <span class="o">&amp;</span> <span class="n">ENINT_COALESCE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">cmdcmplt_total</span> <span class="o">&gt;</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">int_coalescing_threshold</span><span class="p">)</span>
		<span class="n">enint_coal</span> <span class="o">|=</span> <span class="n">ENINT_COALESCE</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">cmdcmplt_total</span> <span class="o">&lt;</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">int_coalescing_stop_threshold</span><span class="p">)</span>
		<span class="n">enint_coal</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ENINT_COALESCE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">enint_coal</span> <span class="o">!=</span> <span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">hs_mailbox</span> <span class="o">&amp;</span> <span class="n">ENINT_COALESCE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ahd_enable_coalescing</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">enint_coal</span><span class="p">);</span>
<span class="cp">#ifdef AHD_DEBUG</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ahd_debug</span> <span class="o">&amp;</span> <span class="n">AHD_SHOW_INT_COALESCING</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: Interrupt coalescing &quot;</span>
			       <span class="s">&quot;now %sabled. Cmds %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">),</span>
			       <span class="p">(</span><span class="n">enint_coal</span> <span class="o">&amp;</span> <span class="n">ENINT_COALESCE</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;en&quot;</span> <span class="o">:</span> <span class="s">&quot;dis&quot;</span><span class="p">,</span>
			       <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">cmdcmplt_total</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="p">}</span>

	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">cmdcmplt_bucket</span> <span class="o">=</span> <span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">cmdcmplt_bucket</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">AHD_STAT_BUCKETS</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">cmdcmplt_total</span> <span class="o">-=</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">cmdcmplt_counts</span><span class="p">[</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">cmdcmplt_bucket</span><span class="p">];</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">cmdcmplt_counts</span><span class="p">[</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">cmdcmplt_bucket</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ahd_timer_reset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">stat_timer</span><span class="p">,</span> <span class="n">AHD_STAT_UPDATE_US</span><span class="p">,</span>
			<span class="n">ahd_stat_timer</span><span class="p">,</span> <span class="n">ahd</span><span class="p">);</span>
	<span class="n">ahd_unlock</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/****************************** Status Processing *****************************/</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_handle_scsi_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scb</span> <span class="o">*</span><span class="n">scb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span>	<span class="n">hardware_scb</span> <span class="o">*</span><span class="n">hscb</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">paused</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The sequencer freezes its select-out queue</span>
<span class="cm">	 * anytime a SCSI status error occurs.  We must</span>
<span class="cm">	 * handle the error and increment our qfreeze count</span>
<span class="cm">	 * to allow the sequencer to continue.  We don&#39;t</span>
<span class="cm">	 * bother clearing critical sections here since all</span>
<span class="cm">	 * operations are on data structures that the sequencer</span>
<span class="cm">	 * is not touching once the queue is frozen.</span>
<span class="cm">	 */</span>
	<span class="n">hscb</span> <span class="o">=</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">hscb</span><span class="p">;</span> 

	<span class="k">if</span> <span class="p">(</span><span class="n">ahd_is_paused</span><span class="p">(</span><span class="n">ahd</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">paused</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">paused</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ahd_pause</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Freeze the queue until the client sees the error. */</span>
	<span class="n">ahd_freeze_devq</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
	<span class="n">ahd_freeze_scb</span><span class="p">(</span><span class="n">scb</span><span class="p">);</span>
	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">qfreeze_cnt</span><span class="o">++</span><span class="p">;</span>
	<span class="n">ahd_outw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">KERNEL_QFREEZE_COUNT</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">qfreeze_cnt</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">paused</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ahd_unpause</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>

	<span class="cm">/* Don&#39;t want to clobber the original sense code */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SCB_SENSE</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Clear the SCB_SENSE Flag and perform</span>
<span class="cm">		 * a normal command completion.</span>
<span class="cm">		 */</span>
		<span class="n">scb</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SCB_SENSE</span><span class="p">;</span>
		<span class="n">ahd_set_transaction_status</span><span class="p">(</span><span class="n">scb</span><span class="p">,</span> <span class="n">CAM_AUTOSENSE_FAIL</span><span class="p">);</span>
		<span class="n">ahd_done</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ahd_set_transaction_status</span><span class="p">(</span><span class="n">scb</span><span class="p">,</span> <span class="n">CAM_SCSI_STATUS_ERROR</span><span class="p">);</span>
	<span class="n">ahd_set_scsi_status</span><span class="p">(</span><span class="n">scb</span><span class="p">,</span> <span class="n">hscb</span><span class="o">-&gt;</span><span class="n">shared_data</span><span class="p">.</span><span class="n">istatus</span><span class="p">.</span><span class="n">scsi_status</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">hscb</span><span class="o">-&gt;</span><span class="n">shared_data</span><span class="p">.</span><span class="n">istatus</span><span class="p">.</span><span class="n">scsi_status</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">STATUS_PKT_SENSE</span>:
	<span class="p">{</span>
		<span class="k">struct</span> <span class="n">scsi_status_iu_header</span> <span class="o">*</span><span class="n">siu</span><span class="p">;</span>

		<span class="n">ahd_sync_sense</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">,</span> <span class="n">BUS_DMASYNC_POSTREAD</span><span class="p">);</span>
		<span class="n">siu</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">scsi_status_iu_header</span> <span class="o">*</span><span class="p">)</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">sense_data</span><span class="p">;</span>
		<span class="n">ahd_set_scsi_status</span><span class="p">(</span><span class="n">scb</span><span class="p">,</span> <span class="n">siu</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
<span class="cp">#ifdef AHD_DEBUG</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ahd_debug</span> <span class="o">&amp;</span> <span class="n">AHD_SHOW_SENSE</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ahd_print_path</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;SCB 0x%x Received PKT Status of 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">SCB_GET_TAG</span><span class="p">(</span><span class="n">scb</span><span class="p">),</span> <span class="n">siu</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">flags = 0x%x, sense len = 0x%x, &quot;</span>
			       <span class="s">&quot;pktfail = 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">siu</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span> <span class="n">scsi_4btoul</span><span class="p">(</span><span class="n">siu</span><span class="o">-&gt;</span><span class="n">sense_length</span><span class="p">),</span>
			       <span class="n">scsi_4btoul</span><span class="p">(</span><span class="n">siu</span><span class="o">-&gt;</span><span class="n">pkt_failures_length</span><span class="p">));</span>
		<span class="p">}</span>
<span class="cp">#endif</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">siu</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SIU_RSPVALID</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ahd_print_path</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">scsi_4btoul</span><span class="p">(</span><span class="n">siu</span><span class="o">-&gt;</span><span class="n">pkt_failures_length</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Unable to parse pkt_failures</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>

				<span class="k">switch</span> <span class="p">(</span><span class="n">SIU_PKTFAIL_CODE</span><span class="p">(</span><span class="n">siu</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">case</span> <span class="n">SIU_PFC_NONE</span>:
					<span class="n">printk</span><span class="p">(</span><span class="s">&quot;No packet failure found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="k">case</span> <span class="n">SIU_PFC_CIU_FIELDS_INVALID</span>:
					<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Invalid Command IU Field</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="k">case</span> <span class="n">SIU_PFC_TMF_NOT_SUPPORTED</span>:
					<span class="n">printk</span><span class="p">(</span><span class="s">&quot;TMF not supported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="k">case</span> <span class="n">SIU_PFC_TMF_FAILED</span>:
					<span class="n">printk</span><span class="p">(</span><span class="s">&quot;TMF failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="k">case</span> <span class="n">SIU_PFC_INVALID_TYPE_CODE</span>:
					<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Invalid L_Q Type code</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="k">case</span> <span class="n">SIU_PFC_ILLEGAL_REQUEST</span>:
					<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Illegal request</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="nl">default:</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">siu</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="n">SCSI_STATUS_OK</span><span class="p">)</span>
				<span class="n">ahd_set_transaction_status</span><span class="p">(</span><span class="n">scb</span><span class="p">,</span>
							   <span class="n">CAM_REQ_CMP_ERR</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">siu</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SIU_SNSVALID</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">scb</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">SCB_PKT_SENSE</span><span class="p">;</span>
<span class="cp">#ifdef AHD_DEBUG</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">ahd_debug</span> <span class="o">&amp;</span> <span class="n">AHD_SHOW_SENSE</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Sense data available</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="p">}</span>
		<span class="n">ahd_done</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">SCSI_STATUS_CMD_TERMINATED</span>:
	<span class="k">case</span> <span class="n">SCSI_STATUS_CHECK_COND</span>:
	<span class="p">{</span>
		<span class="k">struct</span> <span class="n">ahd_devinfo</span> <span class="n">devinfo</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">ahd_dma_seg</span> <span class="o">*</span><span class="n">sg</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">scsi_sense</span> <span class="o">*</span><span class="n">sc</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">ahd_initiator_tinfo</span> <span class="o">*</span><span class="n">targ_info</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">ahd_tmode_tstate</span> <span class="o">*</span><span class="n">tstate</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">ahd_transinfo</span> <span class="o">*</span><span class="n">tinfo</span><span class="p">;</span>
<span class="cp">#ifdef AHD_DEBUG</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ahd_debug</span> <span class="o">&amp;</span> <span class="n">AHD_SHOW_SENSE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ahd_print_path</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;SCB %d: requests Check Status</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">SCB_GET_TAG</span><span class="p">(</span><span class="n">scb</span><span class="p">));</span>
		<span class="p">}</span>
<span class="cp">#endif</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ahd_perform_autosense</span><span class="p">(</span><span class="n">scb</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">ahd_compile_devinfo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devinfo</span><span class="p">,</span> <span class="n">SCB_GET_OUR_ID</span><span class="p">(</span><span class="n">scb</span><span class="p">),</span>
				    <span class="n">SCB_GET_TARGET</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">),</span>
				    <span class="n">SCB_GET_LUN</span><span class="p">(</span><span class="n">scb</span><span class="p">),</span>
				    <span class="n">SCB_GET_CHANNEL</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">),</span>
				    <span class="n">ROLE_INITIATOR</span><span class="p">);</span>
		<span class="n">targ_info</span> <span class="o">=</span> <span class="n">ahd_fetch_transinfo</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span>
						<span class="n">devinfo</span><span class="p">.</span><span class="n">channel</span><span class="p">,</span>
						<span class="n">devinfo</span><span class="p">.</span><span class="n">our_scsiid</span><span class="p">,</span>
						<span class="n">devinfo</span><span class="p">.</span><span class="n">target</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">tstate</span><span class="p">);</span>
		<span class="n">tinfo</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">targ_info</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">;</span>
		<span class="n">sg</span> <span class="o">=</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">sg_list</span><span class="p">;</span>
		<span class="n">sc</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">scsi_sense</span> <span class="o">*</span><span class="p">)</span><span class="n">hscb</span><span class="o">-&gt;</span><span class="n">shared_data</span><span class="p">.</span><span class="n">idata</span><span class="p">.</span><span class="n">cdb</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Save off the residual if there is one.</span>
<span class="cm">		 */</span>
		<span class="n">ahd_update_residual</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
<span class="cp">#ifdef AHD_DEBUG</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ahd_debug</span> <span class="o">&amp;</span> <span class="n">AHD_SHOW_SENSE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ahd_print_path</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Sending Sense</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
<span class="cp">#endif</span>
		<span class="n">scb</span><span class="o">-&gt;</span><span class="n">sg_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">sg</span> <span class="o">=</span> <span class="n">ahd_sg_setup</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">ahd_get_sense_bufaddr</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">),</span>
				  <span class="n">ahd_get_sense_bufsize</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">),</span>
				  <span class="cm">/*last*/</span><span class="n">TRUE</span><span class="p">);</span>
		<span class="n">sc</span><span class="o">-&gt;</span><span class="n">opcode</span> <span class="o">=</span> <span class="n">REQUEST_SENSE</span><span class="p">;</span>
		<span class="n">sc</span><span class="o">-&gt;</span><span class="n">byte2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tinfo</span><span class="o">-&gt;</span><span class="n">protocol_version</span> <span class="o">&lt;=</span> <span class="n">SCSI_REV_2</span>
		 <span class="o">&amp;&amp;</span> <span class="n">SCB_GET_LUN</span><span class="p">(</span><span class="n">scb</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">)</span>
			<span class="n">sc</span><span class="o">-&gt;</span><span class="n">byte2</span> <span class="o">=</span> <span class="n">SCB_GET_LUN</span><span class="p">(</span><span class="n">scb</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">;</span>
		<span class="n">sc</span><span class="o">-&gt;</span><span class="n">unused</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">sc</span><span class="o">-&gt;</span><span class="n">unused</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">sc</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">ahd_get_sense_bufsize</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
		<span class="n">sc</span><span class="o">-&gt;</span><span class="n">control</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * We can&#39;t allow the target to disconnect.</span>
<span class="cm">		 * This will be an untagged transaction and</span>
<span class="cm">		 * having the target disconnect will make this</span>
<span class="cm">		 * transaction indestinguishable from outstanding</span>
<span class="cm">		 * tagged transactions.</span>
<span class="cm">		 */</span>
		<span class="n">hscb</span><span class="o">-&gt;</span><span class="n">control</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * This request sense could be because the</span>
<span class="cm">		 * the device lost power or in some other</span>
<span class="cm">		 * way has lost our transfer negotiations.</span>
<span class="cm">		 * Renegotiate if appropriate.  Unit attention</span>
<span class="cm">		 * errors will be reported before any data</span>
<span class="cm">		 * phases occur.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ahd_get_residual</span><span class="p">(</span><span class="n">scb</span><span class="p">)</span> <span class="o">==</span> <span class="n">ahd_get_transfer_length</span><span class="p">(</span><span class="n">scb</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ahd_update_neg_request</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">devinfo</span><span class="p">,</span>
					       <span class="n">tstate</span><span class="p">,</span> <span class="n">targ_info</span><span class="p">,</span>
					       <span class="n">AHD_NEG_IF_NON_ASYNC</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tstate</span><span class="o">-&gt;</span><span class="n">auto_negotiate</span> <span class="o">&amp;</span> <span class="n">devinfo</span><span class="p">.</span><span class="n">target_mask</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">hscb</span><span class="o">-&gt;</span><span class="n">control</span> <span class="o">|=</span> <span class="n">MK_MESSAGE</span><span class="p">;</span>
			<span class="n">scb</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span>
			    <span class="o">~</span><span class="p">(</span><span class="n">SCB_NEGOTIATE</span><span class="o">|</span><span class="n">SCB_ABORT</span><span class="o">|</span><span class="n">SCB_DEVICE_RESET</span><span class="p">);</span>
			<span class="n">scb</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">SCB_AUTO_NEGOTIATE</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">hscb</span><span class="o">-&gt;</span><span class="n">cdb_len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">sc</span><span class="p">);</span>
		<span class="n">ahd_setup_data_scb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
		<span class="n">scb</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">SCB_SENSE</span><span class="p">;</span>
		<span class="n">ahd_queue_scb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">SCSI_STATUS_OK</span>:
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: Interrupted for status of 0???</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">));</span>
		<span class="cm">/* FALLTHROUGH */</span>
	<span class="nl">default:</span>
		<span class="n">ahd_done</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_handle_scb_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scb</span> <span class="o">*</span><span class="n">scb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">hscb</span><span class="o">-&gt;</span><span class="n">shared_data</span><span class="p">.</span><span class="n">istatus</span><span class="p">.</span><span class="n">scsi_status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ahd_handle_scsi_status</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ahd_calc_residual</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
		<span class="n">ahd_done</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Calculate the residual for a just completed SCB.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_calc_residual</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scb</span> <span class="o">*</span><span class="n">scb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hardware_scb</span> <span class="o">*</span><span class="n">hscb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">initiator_status</span> <span class="o">*</span><span class="n">spkt</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">sgptr</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">resid_sgptr</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">resid</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * 5 cases.</span>
<span class="cm">	 * 1) No residual.</span>
<span class="cm">	 *    SG_STATUS_VALID clear in sgptr.</span>
<span class="cm">	 * 2) Transferless command</span>
<span class="cm">	 * 3) Never performed any transfers.</span>
<span class="cm">	 *    sgptr has SG_FULL_RESID set.</span>
<span class="cm">	 * 4) No residual but target did not</span>
<span class="cm">	 *    save data pointers after the</span>
<span class="cm">	 *    last transfer, so sgptr was</span>
<span class="cm">	 *    never updated.</span>
<span class="cm">	 * 5) We have a partial residual.</span>
<span class="cm">	 *    Use residual_sgptr to determine</span>
<span class="cm">	 *    where we are.</span>
<span class="cm">	 */</span>

	<span class="n">hscb</span> <span class="o">=</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">hscb</span><span class="p">;</span>
	<span class="n">sgptr</span> <span class="o">=</span> <span class="n">ahd_le32toh</span><span class="p">(</span><span class="n">hscb</span><span class="o">-&gt;</span><span class="n">sgptr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">sgptr</span> <span class="o">&amp;</span> <span class="n">SG_STATUS_VALID</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="cm">/* Case 1 */</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">sgptr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SG_STATUS_VALID</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">sgptr</span> <span class="o">&amp;</span> <span class="n">SG_LIST_NULL</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="cm">/* Case 2 */</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Residual fields are the same in both</span>
<span class="cm">	 * target and initiator status packets,</span>
<span class="cm">	 * so we can always use the initiator fields</span>
<span class="cm">	 * regardless of the role for this SCB.</span>
<span class="cm">	 */</span>
	<span class="n">spkt</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hscb</span><span class="o">-&gt;</span><span class="n">shared_data</span><span class="p">.</span><span class="n">istatus</span><span class="p">;</span>
	<span class="n">resid_sgptr</span> <span class="o">=</span> <span class="n">ahd_le32toh</span><span class="p">(</span><span class="n">spkt</span><span class="o">-&gt;</span><span class="n">residual_sgptr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">sgptr</span> <span class="o">&amp;</span> <span class="n">SG_FULL_RESID</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Case 3 */</span>
		<span class="n">resid</span> <span class="o">=</span> <span class="n">ahd_get_transfer_length</span><span class="p">(</span><span class="n">scb</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">resid_sgptr</span> <span class="o">&amp;</span> <span class="n">SG_LIST_NULL</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Case 4 */</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">resid_sgptr</span> <span class="o">&amp;</span> <span class="n">SG_OVERRUN_RESID</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ahd_print_path</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;data overrun detected Tag == 0x%x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">SCB_GET_TAG</span><span class="p">(</span><span class="n">scb</span><span class="p">));</span>
		<span class="n">ahd_freeze_devq</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
		<span class="n">ahd_set_transaction_status</span><span class="p">(</span><span class="n">scb</span><span class="p">,</span> <span class="n">CAM_DATA_RUN_ERR</span><span class="p">);</span>
		<span class="n">ahd_freeze_scb</span><span class="p">(</span><span class="n">scb</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">resid_sgptr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">SG_PTR_MASK</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Bogus resid sgptr value 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">resid_sgptr</span><span class="p">);</span>
		<span class="cm">/* NOTREACHED */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ahd_dma_seg</span> <span class="o">*</span><span class="n">sg</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Remainder of the SG where the transfer</span>
<span class="cm">		 * stopped.  </span>
<span class="cm">		 */</span>
		<span class="n">resid</span> <span class="o">=</span> <span class="n">ahd_le32toh</span><span class="p">(</span><span class="n">spkt</span><span class="o">-&gt;</span><span class="n">residual_datacnt</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">AHD_SG_LEN_MASK</span><span class="p">;</span>
		<span class="n">sg</span> <span class="o">=</span> <span class="n">ahd_sg_bus_to_virt</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">,</span> <span class="n">resid_sgptr</span> <span class="o">&amp;</span> <span class="n">SG_PTR_MASK</span><span class="p">);</span>

		<span class="cm">/* The residual sg_ptr always points to the next sg */</span>
		<span class="n">sg</span><span class="o">--</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Add up the contents of all residual</span>
<span class="cm">		 * SG segments that are after the SG where</span>
<span class="cm">		 * the transfer stopped.</span>
<span class="cm">		 */</span>
		<span class="k">while</span> <span class="p">((</span><span class="n">ahd_le32toh</span><span class="p">(</span><span class="n">sg</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">AHD_DMA_LAST_SEG</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sg</span><span class="o">++</span><span class="p">;</span>
			<span class="n">resid</span> <span class="o">+=</span> <span class="n">ahd_le32toh</span><span class="p">(</span><span class="n">sg</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">AHD_SG_LEN_MASK</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SCB_SENSE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ahd_set_residual</span><span class="p">(</span><span class="n">scb</span><span class="p">,</span> <span class="n">resid</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ahd_set_sense_residual</span><span class="p">(</span><span class="n">scb</span><span class="p">,</span> <span class="n">resid</span><span class="p">);</span>

<span class="cp">#ifdef AHD_DEBUG</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ahd_debug</span> <span class="o">&amp;</span> <span class="n">AHD_SHOW_MISC</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ahd_print_path</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Handled %sResidual of %d bytes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="p">(</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SCB_SENSE</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;Sense &quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">resid</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/******************************* Target Mode **********************************/</span>
<span class="cp">#ifdef AHD_TARGET_MODE</span>
<span class="cm">/*</span>
<span class="cm"> * Add a target mode event to this lun&#39;s queue</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_queue_lstate_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ahd_tmode_lstate</span> <span class="o">*</span><span class="n">lstate</span><span class="p">,</span>
		       <span class="n">u_int</span> <span class="n">initiator_id</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">event_type</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">event_arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ahd_tmode_event</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pending</span><span class="p">;</span>

	<span class="n">xpt_freeze_devq</span><span class="p">(</span><span class="n">lstate</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">,</span> <span class="cm">/*count*/</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lstate</span><span class="o">-&gt;</span><span class="n">event_w_idx</span> <span class="o">&gt;=</span> <span class="n">lstate</span><span class="o">-&gt;</span><span class="n">event_r_idx</span><span class="p">)</span>
		<span class="n">pending</span> <span class="o">=</span> <span class="n">lstate</span><span class="o">-&gt;</span><span class="n">event_w_idx</span> <span class="o">-</span> <span class="n">lstate</span><span class="o">-&gt;</span><span class="n">event_r_idx</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">pending</span> <span class="o">=</span> <span class="n">AHD_TMODE_EVENT_BUFFER_SIZE</span> <span class="o">+</span> <span class="mi">1</span>
			<span class="o">-</span> <span class="p">(</span><span class="n">lstate</span><span class="o">-&gt;</span><span class="n">event_r_idx</span> <span class="o">-</span> <span class="n">lstate</span><span class="o">-&gt;</span><span class="n">event_w_idx</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event_type</span> <span class="o">==</span> <span class="n">EVENT_TYPE_BUS_RESET</span>
	 <span class="o">||</span> <span class="n">event_type</span> <span class="o">==</span> <span class="n">MSG_BUS_DEV_RESET</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Any earlier events are irrelevant, so reset our buffer.</span>
<span class="cm">		 * This has the effect of allowing us to deal with reset</span>
<span class="cm">		 * floods (an external device holding down the reset line)</span>
<span class="cm">		 * without losing the event that is really interesting.</span>
<span class="cm">		 */</span>
		<span class="n">lstate</span><span class="o">-&gt;</span><span class="n">event_r_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">lstate</span><span class="o">-&gt;</span><span class="n">event_w_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">xpt_release_devq</span><span class="p">(</span><span class="n">lstate</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">,</span> <span class="n">pending</span><span class="p">,</span> <span class="cm">/*runqueue*/</span><span class="n">FALSE</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pending</span> <span class="o">==</span> <span class="n">AHD_TMODE_EVENT_BUFFER_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xpt_print_path</span><span class="p">(</span><span class="n">lstate</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;immediate event %x:%x lost</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">lstate</span><span class="o">-&gt;</span><span class="n">event_buffer</span><span class="p">[</span><span class="n">lstate</span><span class="o">-&gt;</span><span class="n">event_r_idx</span><span class="p">].</span><span class="n">event_type</span><span class="p">,</span>
		       <span class="n">lstate</span><span class="o">-&gt;</span><span class="n">event_buffer</span><span class="p">[</span><span class="n">lstate</span><span class="o">-&gt;</span><span class="n">event_r_idx</span><span class="p">].</span><span class="n">event_arg</span><span class="p">);</span>
		<span class="n">lstate</span><span class="o">-&gt;</span><span class="n">event_r_idx</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lstate</span><span class="o">-&gt;</span><span class="n">event_r_idx</span> <span class="o">==</span> <span class="n">AHD_TMODE_EVENT_BUFFER_SIZE</span><span class="p">)</span>
			<span class="n">lstate</span><span class="o">-&gt;</span><span class="n">event_r_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">xpt_release_devq</span><span class="p">(</span><span class="n">lstate</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">,</span> <span class="cm">/*count*/</span><span class="mi">1</span><span class="p">,</span> <span class="cm">/*runqueue*/</span><span class="n">FALSE</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">event</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lstate</span><span class="o">-&gt;</span><span class="n">event_buffer</span><span class="p">[</span><span class="n">lstate</span><span class="o">-&gt;</span><span class="n">event_w_idx</span><span class="p">];</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">initiator_id</span> <span class="o">=</span> <span class="n">initiator_id</span><span class="p">;</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">event_type</span> <span class="o">=</span> <span class="n">event_type</span><span class="p">;</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">event_arg</span> <span class="o">=</span> <span class="n">event_arg</span><span class="p">;</span>
	<span class="n">lstate</span><span class="o">-&gt;</span><span class="n">event_w_idx</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lstate</span><span class="o">-&gt;</span><span class="n">event_w_idx</span> <span class="o">==</span> <span class="n">AHD_TMODE_EVENT_BUFFER_SIZE</span><span class="p">)</span>
		<span class="n">lstate</span><span class="o">-&gt;</span><span class="n">event_w_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Send any target mode events queued up waiting</span>
<span class="cm"> * for immediate notify resources.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">ahd_send_lstate_events</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ahd_tmode_lstate</span> <span class="o">*</span><span class="n">lstate</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ccb_hdr</span> <span class="o">*</span><span class="n">ccbh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ccb_immed_notify</span> <span class="o">*</span><span class="n">inot</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">lstate</span><span class="o">-&gt;</span><span class="n">event_r_idx</span> <span class="o">!=</span> <span class="n">lstate</span><span class="o">-&gt;</span><span class="n">event_w_idx</span>
	    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ccbh</span> <span class="o">=</span> <span class="n">SLIST_FIRST</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lstate</span><span class="o">-&gt;</span><span class="n">immed_notifies</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ahd_tmode_event</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>

		<span class="n">event</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lstate</span><span class="o">-&gt;</span><span class="n">event_buffer</span><span class="p">[</span><span class="n">lstate</span><span class="o">-&gt;</span><span class="n">event_r_idx</span><span class="p">];</span>
		<span class="n">SLIST_REMOVE_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lstate</span><span class="o">-&gt;</span><span class="n">immed_notifies</span><span class="p">,</span> <span class="n">sim_links</span><span class="p">.</span><span class="n">sle</span><span class="p">);</span>
		<span class="n">inot</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ccb_immed_notify</span> <span class="o">*</span><span class="p">)</span><span class="n">ccbh</span><span class="p">;</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">event_type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">EVENT_TYPE_BUS_RESET</span>:
			<span class="n">ccbh</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">CAM_SCSI_BUS_RESET</span><span class="o">|</span><span class="n">CAM_DEV_QFRZN</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">ccbh</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">CAM_MESSAGE_RECV</span><span class="o">|</span><span class="n">CAM_DEV_QFRZN</span><span class="p">;</span>
			<span class="n">inot</span><span class="o">-&gt;</span><span class="n">message_args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">event_type</span><span class="p">;</span>
			<span class="n">inot</span><span class="o">-&gt;</span><span class="n">message_args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">event_arg</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">inot</span><span class="o">-&gt;</span><span class="n">initiator_id</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">initiator_id</span><span class="p">;</span>
		<span class="n">inot</span><span class="o">-&gt;</span><span class="n">sense_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">xpt_done</span><span class="p">((</span><span class="k">union</span> <span class="n">ccb</span> <span class="o">*</span><span class="p">)</span><span class="n">inot</span><span class="p">);</span>
		<span class="n">lstate</span><span class="o">-&gt;</span><span class="n">event_r_idx</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lstate</span><span class="o">-&gt;</span><span class="n">event_r_idx</span> <span class="o">==</span> <span class="n">AHD_TMODE_EVENT_BUFFER_SIZE</span><span class="p">)</span>
			<span class="n">lstate</span><span class="o">-&gt;</span><span class="n">event_r_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/******************** Sequencer Program Patching/Download *********************/</span>

<span class="cp">#ifdef AHD_DUMP_SEQ</span>
<span class="kt">void</span>
<span class="nf">ahd_dumpseq</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span><span class="o">*</span> <span class="n">ahd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">max_prog</span><span class="p">;</span>

	<span class="n">max_prog</span> <span class="o">=</span> <span class="mi">2048</span><span class="p">;</span>

	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SEQCTL0</span><span class="p">,</span> <span class="n">PERRORDIS</span><span class="o">|</span><span class="n">FAILDIS</span><span class="o">|</span><span class="n">FASTMODE</span><span class="o">|</span><span class="n">LOADRAM</span><span class="p">);</span>
	<span class="n">ahd_outw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">PRGMCNT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">max_prog</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">uint8_t</span> <span class="n">ins_bytes</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>

		<span class="n">ahd_insb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SEQRAM</span><span class="p">,</span> <span class="n">ins_bytes</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ins_bytes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span>
				 <span class="o">|</span> <span class="n">ins_bytes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span>
				 <span class="o">|</span> <span class="n">ins_bytes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span>
				 <span class="o">|</span> <span class="n">ins_bytes</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_loadseq</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span>	<span class="n">cs</span> <span class="n">cs_table</span><span class="p">[</span><span class="n">num_critical_sections</span><span class="p">];</span>
	<span class="n">u_int</span>	<span class="n">begin_set</span><span class="p">[</span><span class="n">num_critical_sections</span><span class="p">];</span>
	<span class="n">u_int</span>	<span class="n">end_set</span><span class="p">[</span><span class="n">num_critical_sections</span><span class="p">];</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">patch</span> <span class="o">*</span><span class="n">cur_patch</span><span class="p">;</span>
	<span class="n">u_int</span>	<span class="n">cs_count</span><span class="p">;</span>
	<span class="n">u_int</span>	<span class="n">cur_cs</span><span class="p">;</span>
	<span class="n">u_int</span>	<span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">downloaded</span><span class="p">;</span>
	<span class="n">u_int</span>	<span class="n">skip_addr</span><span class="p">;</span>
	<span class="n">u_int</span>	<span class="n">sg_prefetch_cnt</span><span class="p">;</span>
	<span class="n">u_int</span>	<span class="n">sg_prefetch_cnt_limit</span><span class="p">;</span>
	<span class="n">u_int</span>	<span class="n">sg_prefetch_align</span><span class="p">;</span>
	<span class="n">u_int</span>	<span class="n">sg_size</span><span class="p">;</span>
	<span class="n">u_int</span>	<span class="n">cacheline_mask</span><span class="p">;</span>
	<span class="kt">uint8_t</span>	<span class="n">download_consts</span><span class="p">[</span><span class="n">DOWNLOAD_CONST_COUNT</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bootverbose</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: Downloading Sequencer Program...&quot;</span><span class="p">,</span>
		       <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">));</span>

<span class="cp">#if DOWNLOAD_CONST_COUNT != 8</span>
<span class="cp">#error &quot;Download Const Mismatch&quot;</span>
<span class="cp">#endif</span>
	<span class="cm">/*</span>
<span class="cm">	 * Start out with 0 critical sections</span>
<span class="cm">	 * that apply to this firmware load.</span>
<span class="cm">	 */</span>
	<span class="n">cs_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cur_cs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">begin_set</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">begin_set</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">end_set</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">end_set</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Setup downloadable constant table.</span>
<span class="cm">	 * </span>
<span class="cm">	 * The computation for the S/G prefetch variables is</span>
<span class="cm">	 * a bit complicated.  We would like to always fetch</span>
<span class="cm">	 * in terms of cachelined sized increments.  However,</span>
<span class="cm">	 * if the cacheline is not an even multiple of the</span>
<span class="cm">	 * SG element size or is larger than our SG RAM, using</span>
<span class="cm">	 * just the cache size might leave us with only a portion</span>
<span class="cm">	 * of an SG element at the tail of a prefetch.  If the</span>
<span class="cm">	 * cacheline is larger than our S/G prefetch buffer less</span>
<span class="cm">	 * the size of an SG element, we may round down to a cacheline</span>
<span class="cm">	 * that doesn&#39;t contain any or all of the S/G of interest</span>
<span class="cm">	 * within the bounds of our S/G ram.  Provide variables to</span>
<span class="cm">	 * the sequencer that will allow it to handle these edge</span>
<span class="cm">	 * cases.</span>
<span class="cm">	 */</span>
	<span class="cm">/* Start by aligning to the nearest cacheline. */</span>
	<span class="n">sg_prefetch_align</span> <span class="o">=</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">pci_cachesize</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sg_prefetch_align</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">sg_prefetch_align</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="cm">/* Round down to the nearest power of 2. */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">powerof2</span><span class="p">(</span><span class="n">sg_prefetch_align</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">sg_prefetch_align</span><span class="o">--</span><span class="p">;</span>

	<span class="n">cacheline_mask</span> <span class="o">=</span> <span class="n">sg_prefetch_align</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the cacheline boundary is greater than half our prefetch RAM</span>
<span class="cm">	 * we risk not being able to fetch even a single complete S/G</span>
<span class="cm">	 * segment if we align to that boundary.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sg_prefetch_align</span> <span class="o">&gt;</span> <span class="n">CCSGADDR_MAX</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
		<span class="n">sg_prefetch_align</span> <span class="o">=</span> <span class="n">CCSGADDR_MAX</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
	<span class="cm">/* Start by fetching a single cacheline. */</span>
	<span class="n">sg_prefetch_cnt</span> <span class="o">=</span> <span class="n">sg_prefetch_align</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Increment the prefetch count by cachelines until</span>
<span class="cm">	 * at least one S/G element will fit.</span>
<span class="cm">	 */</span>
	<span class="n">sg_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_dma_seg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AHD_64BIT_ADDRESSING</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">sg_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_dma64_seg</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">sg_prefetch_cnt</span> <span class="o">&lt;</span> <span class="n">sg_size</span><span class="p">)</span>
		<span class="n">sg_prefetch_cnt</span> <span class="o">+=</span> <span class="n">sg_prefetch_align</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * If the cacheline is not an even multiple of</span>
<span class="cm">	 * the S/G size, we may only get a partial S/G when</span>
<span class="cm">	 * we align. Add a cacheline if this is the case.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">sg_prefetch_align</span> <span class="o">%</span> <span class="n">sg_size</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>
	 <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">sg_prefetch_cnt</span> <span class="o">&lt;</span> <span class="n">CCSGADDR_MAX</span><span class="p">))</span>
		<span class="n">sg_prefetch_cnt</span> <span class="o">+=</span> <span class="n">sg_prefetch_align</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Lastly, compute a value that the sequencer can use</span>
<span class="cm">	 * to determine if the remainder of the CCSGRAM buffer</span>
<span class="cm">	 * has a full S/G element in it.</span>
<span class="cm">	 */</span>
	<span class="n">sg_prefetch_cnt_limit</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">sg_prefetch_cnt</span> <span class="o">-</span> <span class="n">sg_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">download_consts</span><span class="p">[</span><span class="n">SG_PREFETCH_CNT</span><span class="p">]</span> <span class="o">=</span> <span class="n">sg_prefetch_cnt</span><span class="p">;</span>
	<span class="n">download_consts</span><span class="p">[</span><span class="n">SG_PREFETCH_CNT_LIMIT</span><span class="p">]</span> <span class="o">=</span> <span class="n">sg_prefetch_cnt_limit</span><span class="p">;</span>
	<span class="n">download_consts</span><span class="p">[</span><span class="n">SG_PREFETCH_ALIGN_MASK</span><span class="p">]</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="n">sg_prefetch_align</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">download_consts</span><span class="p">[</span><span class="n">SG_PREFETCH_ADDR_MASK</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">sg_prefetch_align</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">download_consts</span><span class="p">[</span><span class="n">SG_SIZEOF</span><span class="p">]</span> <span class="o">=</span> <span class="n">sg_size</span><span class="p">;</span>
	<span class="n">download_consts</span><span class="p">[</span><span class="n">PKT_OVERRUN_BUFOFFSET</span><span class="p">]</span> <span class="o">=</span>
		<span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">overrun_buf</span> <span class="o">-</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">qoutfifo</span><span class="p">)</span> <span class="o">/</span> <span class="mi">256</span><span class="p">;</span>
	<span class="n">download_consts</span><span class="p">[</span><span class="n">SCB_TRANSFER_SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="n">SCB_TRANSFER_SIZE_1BYTE_LUN</span><span class="p">;</span>
	<span class="n">download_consts</span><span class="p">[</span><span class="n">CACHELINE_MASK</span><span class="p">]</span> <span class="o">=</span> <span class="n">cacheline_mask</span><span class="p">;</span>
	<span class="n">cur_patch</span> <span class="o">=</span> <span class="n">patches</span><span class="p">;</span>
	<span class="n">downloaded</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">skip_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SEQCTL0</span><span class="p">,</span> <span class="n">PERRORDIS</span><span class="o">|</span><span class="n">FAILDIS</span><span class="o">|</span><span class="n">FASTMODE</span><span class="o">|</span><span class="n">LOADRAM</span><span class="p">);</span>
	<span class="n">ahd_outw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">PRGMCNT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">seqprog</span><span class="p">)</span><span class="o">/</span><span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ahd_check_patch</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cur_patch</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">skip_addr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Don&#39;t download this instruction as it</span>
<span class="cm">			 * is in a patch that was removed.</span>
<span class="cm">			 */</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * Move through the CS table until we find a CS</span>
<span class="cm">		 * that might apply to this instruction.</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(;</span> <span class="n">cur_cs</span> <span class="o">&lt;</span> <span class="n">num_critical_sections</span><span class="p">;</span> <span class="n">cur_cs</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">critical_sections</span><span class="p">[</span><span class="n">cur_cs</span><span class="p">].</span><span class="n">end</span> <span class="o">&lt;=</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">begin_set</span><span class="p">[</span><span class="n">cs_count</span><span class="p">]</span> <span class="o">==</span> <span class="n">TRUE</span>
				 <span class="o">&amp;&amp;</span> <span class="n">end_set</span><span class="p">[</span><span class="n">cs_count</span><span class="p">]</span> <span class="o">==</span> <span class="n">FALSE</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">cs_table</span><span class="p">[</span><span class="n">cs_count</span><span class="p">].</span><span class="n">end</span> <span class="o">=</span> <span class="n">downloaded</span><span class="p">;</span>
				 	<span class="n">end_set</span><span class="p">[</span><span class="n">cs_count</span><span class="p">]</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
					<span class="n">cs_count</span><span class="o">++</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">critical_sections</span><span class="p">[</span><span class="n">cur_cs</span><span class="p">].</span><span class="n">begin</span> <span class="o">&lt;=</span> <span class="n">i</span>
			 <span class="o">&amp;&amp;</span> <span class="n">begin_set</span><span class="p">[</span><span class="n">cs_count</span><span class="p">]</span> <span class="o">==</span> <span class="n">FALSE</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">cs_table</span><span class="p">[</span><span class="n">cs_count</span><span class="p">].</span><span class="n">begin</span> <span class="o">=</span> <span class="n">downloaded</span><span class="p">;</span>
				<span class="n">begin_set</span><span class="p">[</span><span class="n">cs_count</span><span class="p">]</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ahd_download_instr</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">download_consts</span><span class="p">);</span>
		<span class="n">downloaded</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">num_critical_sections</span> <span class="o">=</span> <span class="n">cs_count</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cs_count</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">cs_count</span> <span class="o">*=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cs</span><span class="p">);</span>
		<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">critical_sections</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">cs_count</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">critical_sections</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">panic</span><span class="p">(</span><span class="s">&quot;ahd_loadseq: Could not malloc&quot;</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">critical_sections</span><span class="p">,</span> <span class="n">cs_table</span><span class="p">,</span> <span class="n">cs_count</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SEQCTL0</span><span class="p">,</span> <span class="n">PERRORDIS</span><span class="o">|</span><span class="n">FAILDIS</span><span class="o">|</span><span class="n">FASTMODE</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bootverbose</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot; %d instructions downloaded</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">downloaded</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: Features 0x%x, Bugs 0x%x, Flags 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">),</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">features</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">bugs</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ahd_check_patch</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">patch</span> <span class="o">**</span><span class="n">start_patch</span><span class="p">,</span>
		<span class="n">u_int</span> <span class="n">start_instr</span><span class="p">,</span> <span class="n">u_int</span> <span class="o">*</span><span class="n">skip_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">patch</span> <span class="o">*</span><span class="n">cur_patch</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">patch</span> <span class="o">*</span><span class="n">last_patch</span><span class="p">;</span>
	<span class="n">u_int</span>	<span class="n">num_patches</span><span class="p">;</span>

	<span class="n">num_patches</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">patches</span><span class="p">);</span>
	<span class="n">last_patch</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">patches</span><span class="p">[</span><span class="n">num_patches</span><span class="p">];</span>
	<span class="n">cur_patch</span> <span class="o">=</span> <span class="o">*</span><span class="n">start_patch</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">cur_patch</span> <span class="o">&lt;</span> <span class="n">last_patch</span> <span class="o">&amp;&amp;</span> <span class="n">start_instr</span> <span class="o">==</span> <span class="n">cur_patch</span><span class="o">-&gt;</span><span class="n">begin</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cur_patch</span><span class="o">-&gt;</span><span class="n">patch_func</span><span class="p">(</span><span class="n">ahd</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

			<span class="cm">/* Start rejecting code */</span>
			<span class="o">*</span><span class="n">skip_addr</span> <span class="o">=</span> <span class="n">start_instr</span> <span class="o">+</span> <span class="n">cur_patch</span><span class="o">-&gt;</span><span class="n">skip_instr</span><span class="p">;</span>
			<span class="n">cur_patch</span> <span class="o">+=</span> <span class="n">cur_patch</span><span class="o">-&gt;</span><span class="n">skip_patch</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Accepted this patch.  Advance to the next</span>
<span class="cm">			 * one and wait for our intruction pointer to</span>
<span class="cm">			 * hit this point.</span>
<span class="cm">			 */</span>
			<span class="n">cur_patch</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">start_patch</span> <span class="o">=</span> <span class="n">cur_patch</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">start_instr</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">skip_addr</span><span class="p">)</span>
		<span class="cm">/* Still skipping */</span>
		<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u_int</span>
<span class="nf">ahd_resolve_seqaddr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">patch</span> <span class="o">*</span><span class="n">cur_patch</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">address_offset</span><span class="p">;</span>
	<span class="n">u_int</span> <span class="n">skip_addr</span><span class="p">;</span>
	<span class="n">u_int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">address_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cur_patch</span> <span class="o">=</span> <span class="n">patches</span><span class="p">;</span>
	<span class="n">skip_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">address</span><span class="p">;)</span> <span class="p">{</span>

		<span class="n">ahd_check_patch</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cur_patch</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">skip_addr</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">skip_addr</span> <span class="o">&gt;</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">end_addr</span><span class="p">;</span>

			<span class="n">end_addr</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">skip_addr</span><span class="p">);</span>
			<span class="n">address_offset</span> <span class="o">+=</span> <span class="n">end_addr</span> <span class="o">-</span> <span class="n">i</span><span class="p">;</span>
			<span class="n">i</span> <span class="o">=</span> <span class="n">skip_addr</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">i</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">address</span> <span class="o">-</span> <span class="n">address_offset</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_download_instr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">instrptr</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">dconsts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span>	<span class="n">ins_formats</span> <span class="n">instr</span><span class="p">;</span>
	<span class="k">struct</span>	<span class="n">ins_format1</span> <span class="o">*</span><span class="n">fmt1_ins</span><span class="p">;</span>
	<span class="k">struct</span>	<span class="n">ins_format3</span> <span class="o">*</span><span class="n">fmt3_ins</span><span class="p">;</span>
	<span class="n">u_int</span>	<span class="n">opcode</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The firmware is always compiled into a little endian format.</span>
<span class="cm">	 */</span>
	<span class="n">instr</span><span class="p">.</span><span class="n">integer</span> <span class="o">=</span> <span class="n">ahd_le32toh</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="kt">uint32_t</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">seqprog</span><span class="p">[</span><span class="n">instrptr</span> <span class="o">*</span> <span class="mi">4</span><span class="p">]);</span>

	<span class="n">fmt1_ins</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">instr</span><span class="p">.</span><span class="n">format1</span><span class="p">;</span>
	<span class="n">fmt3_ins</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Pull the opcode */</span>
	<span class="n">opcode</span> <span class="o">=</span> <span class="n">instr</span><span class="p">.</span><span class="n">format1</span><span class="p">.</span><span class="n">opcode</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">opcode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">AIC_OP_JMP</span>:
	<span class="k">case</span> <span class="n">AIC_OP_JC</span>:
	<span class="k">case</span> <span class="n">AIC_OP_JNC</span>:
	<span class="k">case</span> <span class="n">AIC_OP_CALL</span>:
	<span class="k">case</span> <span class="n">AIC_OP_JNE</span>:
	<span class="k">case</span> <span class="n">AIC_OP_JNZ</span>:
	<span class="k">case</span> <span class="n">AIC_OP_JE</span>:
	<span class="k">case</span> <span class="n">AIC_OP_JZ</span>:
	<span class="p">{</span>
		<span class="n">fmt3_ins</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">instr</span><span class="p">.</span><span class="n">format3</span><span class="p">;</span>
		<span class="n">fmt3_ins</span><span class="o">-&gt;</span><span class="n">address</span> <span class="o">=</span> <span class="n">ahd_resolve_seqaddr</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">fmt3_ins</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">);</span>
		<span class="cm">/* FALLTHROUGH */</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">AIC_OP_OR</span>:
	<span class="k">case</span> <span class="n">AIC_OP_AND</span>:
	<span class="k">case</span> <span class="n">AIC_OP_XOR</span>:
	<span class="k">case</span> <span class="n">AIC_OP_ADD</span>:
	<span class="k">case</span> <span class="n">AIC_OP_ADC</span>:
	<span class="k">case</span> <span class="n">AIC_OP_BMOV</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">fmt1_ins</span><span class="o">-&gt;</span><span class="n">parity</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">fmt1_ins</span><span class="o">-&gt;</span><span class="n">immediate</span> <span class="o">=</span> <span class="n">dconsts</span><span class="p">[</span><span class="n">fmt1_ins</span><span class="o">-&gt;</span><span class="n">immediate</span><span class="p">];</span>
		<span class="p">}</span>
		<span class="n">fmt1_ins</span><span class="o">-&gt;</span><span class="n">parity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="cm">/* FALLTHROUGH */</span>
	<span class="k">case</span> <span class="n">AIC_OP_ROL</span>:
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">count</span><span class="p">;</span>

		<span class="cm">/* Calculate odd parity for the instruction */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">31</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">uint32_t</span> <span class="n">mask</span><span class="p">;</span>

			<span class="n">mask</span> <span class="o">=</span> <span class="mh">0x01</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">instr</span><span class="p">.</span><span class="n">integer</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">count</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">count</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">instr</span><span class="p">.</span><span class="n">format1</span><span class="p">.</span><span class="n">parity</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* The sequencer is a little endian cpu */</span>
		<span class="n">instr</span><span class="p">.</span><span class="n">integer</span> <span class="o">=</span> <span class="n">ahd_htole32</span><span class="p">(</span><span class="n">instr</span><span class="p">.</span><span class="n">integer</span><span class="p">);</span>
		<span class="n">ahd_outsb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SEQRAM</span><span class="p">,</span> <span class="n">instr</span><span class="p">.</span><span class="n">bytes</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="nl">default:</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Unknown opcode encountered in seq program&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ahd_probe_stack_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">last_probe</span><span class="p">;</span>

	<span class="n">last_probe</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * We avoid using 0 as a pattern to avoid</span>
<span class="cm">		 * confusion if the stack implementation</span>
<span class="cm">		 * &quot;back-fills&quot; with zeros when &quot;poping&#39;</span>
<span class="cm">		 * entries.</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">last_probe</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		       <span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">STACK</span><span class="p">,</span> <span class="n">i</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">);</span>
		       <span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">STACK</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* Verify */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">last_probe</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u_int</span> <span class="n">stack_entry</span><span class="p">;</span>

			<span class="n">stack_entry</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">STACK</span><span class="p">)</span>
				    <span class="o">|</span><span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">STACK</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">stack_entry</span> <span class="o">!=</span> <span class="n">i</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">sized</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">last_probe</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">sized:</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">last_probe</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">ahd_print_register</span><span class="p">(</span><span class="k">const</span> <span class="n">ahd_reg_parse_entry_t</span> <span class="o">*</span><span class="n">table</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">num_entries</span><span class="p">,</span>
		   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">address</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">value</span><span class="p">,</span>
		   <span class="n">u_int</span> <span class="o">*</span><span class="n">cur_column</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">wrap_point</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>	<span class="n">printed</span><span class="p">;</span>
	<span class="n">u_int</span>	<span class="n">printed_mask</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cur_column</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">cur_column</span> <span class="o">&gt;=</span> <span class="n">wrap_point</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="o">*</span><span class="n">cur_column</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">printed</span> <span class="o">=</span> <span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s[0x%x]&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">table</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printed</span> <span class="o">+=</span> <span class="n">printk</span><span class="p">(</span><span class="s">&quot; &quot;</span><span class="p">);</span>
		<span class="o">*</span><span class="n">cur_column</span> <span class="o">+=</span> <span class="n">printed</span><span class="p">;</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">printed</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">printed_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">printed_mask</span> <span class="o">!=</span> <span class="mh">0xFF</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">entry</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">entry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">entry</span> <span class="o">&lt;</span> <span class="n">num_entries</span><span class="p">;</span> <span class="n">entry</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(((</span><span class="n">value</span> <span class="o">&amp;</span> <span class="n">table</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">mask</span><span class="p">)</span>
			  <span class="o">!=</span> <span class="n">table</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">value</span><span class="p">)</span>
			 <span class="o">||</span> <span class="p">((</span><span class="n">printed_mask</span> <span class="o">&amp;</span> <span class="n">table</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">mask</span><span class="p">)</span>
			  <span class="o">==</span> <span class="n">table</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">mask</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="n">printed</span> <span class="o">+=</span> <span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s%s&quot;</span><span class="p">,</span>
					  <span class="n">printed_mask</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="s">&quot;:(&quot;</span> <span class="o">:</span> <span class="s">&quot;|&quot;</span><span class="p">,</span>
					  <span class="n">table</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">name</span><span class="p">);</span>
			<span class="n">printed_mask</span> <span class="o">|=</span> <span class="n">table</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">mask</span><span class="p">;</span>
			
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">entry</span> <span class="o">&gt;=</span> <span class="n">num_entries</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">printed_mask</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">printed</span> <span class="o">+=</span> <span class="n">printk</span><span class="p">(</span><span class="s">&quot;) &quot;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">printed</span> <span class="o">+=</span> <span class="n">printk</span><span class="p">(</span><span class="s">&quot; &quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cur_column</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="o">*</span><span class="n">cur_column</span> <span class="o">+=</span> <span class="n">printed</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">printed</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">ahd_dump_card_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scb</span>	<span class="o">*</span><span class="n">scb</span><span class="p">;</span>
	<span class="n">ahd_mode_state</span>	 <span class="n">saved_modes</span><span class="p">;</span>
	<span class="n">u_int</span>		 <span class="n">dffstat</span><span class="p">;</span>
	<span class="kt">int</span>		 <span class="n">paused</span><span class="p">;</span>
	<span class="n">u_int</span>		 <span class="n">scb_index</span><span class="p">;</span>
	<span class="n">u_int</span>		 <span class="n">saved_scb_index</span><span class="p">;</span>
	<span class="n">u_int</span>		 <span class="n">cur_col</span><span class="p">;</span>
	<span class="kt">int</span>		 <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ahd_is_paused</span><span class="p">(</span><span class="n">ahd</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">paused</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">paused</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ahd_pause</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">saved_modes</span> <span class="o">=</span> <span class="n">ahd_save_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
	<span class="n">ahd_set_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Dump Card State Begins &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span><span class="se">\n</span><span class="s">&quot;</span>
	       <span class="s">&quot;%s: Dumping Card State at program address 0x%x Mode 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">),</span> 
	       <span class="n">ahd_inw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CURADDR</span><span class="p">),</span>
	       <span class="n">ahd_build_mode_state</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">saved_src_mode</span><span class="p">,</span>
				    <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">saved_dst_mode</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">paused</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Card was paused</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ahd_check_cmdcmpltqueues</span><span class="p">(</span><span class="n">ahd</span><span class="p">))</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Completions are pending</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Mode independent registers.</span>
<span class="cm">	 */</span>
	<span class="n">cur_col</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ahd_intstat_print</span><span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">INTSTAT</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">cur_col</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
	<span class="n">ahd_seloid_print</span><span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SELOID</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">cur_col</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
	<span class="n">ahd_selid_print</span><span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SELID</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">cur_col</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
	<span class="n">ahd_hs_mailbox_print</span><span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">LOCAL_HS_MAILBOX</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">cur_col</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
	<span class="n">ahd_intctl_print</span><span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">INTCTL</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">cur_col</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
	<span class="n">ahd_seqintstat_print</span><span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SEQINTSTAT</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">cur_col</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
	<span class="n">ahd_saved_mode_print</span><span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SAVED_MODE</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">cur_col</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
	<span class="n">ahd_dffstat_print</span><span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">DFFSTAT</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">cur_col</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
	<span class="n">ahd_scsisigi_print</span><span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCSISIGI</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">cur_col</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
	<span class="n">ahd_scsiphase_print</span><span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCSIPHASE</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">cur_col</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
	<span class="n">ahd_scsibus_print</span><span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCSIBUS</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">cur_col</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
	<span class="n">ahd_lastphase_print</span><span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">LASTPHASE</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">cur_col</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
	<span class="n">ahd_scsiseq0_print</span><span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCSISEQ0</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">cur_col</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
	<span class="n">ahd_scsiseq1_print</span><span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCSISEQ1</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">cur_col</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
	<span class="n">ahd_seqctl0_print</span><span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SEQCTL0</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">cur_col</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
	<span class="n">ahd_seqintctl_print</span><span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SEQINTCTL</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">cur_col</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
	<span class="n">ahd_seq_flags_print</span><span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SEQ_FLAGS</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">cur_col</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
	<span class="n">ahd_seq_flags2_print</span><span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SEQ_FLAGS2</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">cur_col</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
	<span class="n">ahd_qfreeze_count_print</span><span class="p">(</span><span class="n">ahd_inw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">QFREEZE_COUNT</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">cur_col</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
	<span class="n">ahd_kernel_qfreeze_count_print</span><span class="p">(</span><span class="n">ahd_inw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">KERNEL_QFREEZE_COUNT</span><span class="p">),</span>
				       <span class="o">&amp;</span><span class="n">cur_col</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
	<span class="n">ahd_mk_message_scb_print</span><span class="p">(</span><span class="n">ahd_inw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">MK_MESSAGE_SCB</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">cur_col</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
	<span class="n">ahd_mk_message_scsiid_print</span><span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">MK_MESSAGE_SCSIID</span><span class="p">),</span>
				    <span class="o">&amp;</span><span class="n">cur_col</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
	<span class="n">ahd_sstat0_print</span><span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SSTAT0</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">cur_col</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
	<span class="n">ahd_sstat1_print</span><span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SSTAT1</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">cur_col</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
	<span class="n">ahd_sstat2_print</span><span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SSTAT2</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">cur_col</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
	<span class="n">ahd_sstat3_print</span><span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SSTAT3</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">cur_col</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
	<span class="n">ahd_perrdiag_print</span><span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">PERRDIAG</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">cur_col</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
	<span class="n">ahd_simode1_print</span><span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SIMODE1</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">cur_col</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
	<span class="n">ahd_lqistat0_print</span><span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">LQISTAT0</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">cur_col</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
	<span class="n">ahd_lqistat1_print</span><span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">LQISTAT1</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">cur_col</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
	<span class="n">ahd_lqistat2_print</span><span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">LQISTAT2</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">cur_col</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
	<span class="n">ahd_lqostat0_print</span><span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">LQOSTAT0</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">cur_col</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
	<span class="n">ahd_lqostat1_print</span><span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">LQOSTAT1</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">cur_col</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
	<span class="n">ahd_lqostat2_print</span><span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">LQOSTAT2</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">cur_col</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">SCB Count = %d CMDS_PENDING = %d LASTSCB 0x%x &quot;</span>
	       <span class="s">&quot;CURRSCB 0x%x NEXTSCB 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">scb_data</span><span class="p">.</span><span class="n">numscbs</span><span class="p">,</span> <span class="n">ahd_inw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CMDS_PENDING</span><span class="p">),</span>
	       <span class="n">ahd_inw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">LASTSCB</span><span class="p">),</span> <span class="n">ahd_inw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CURRSCB</span><span class="p">),</span>
	       <span class="n">ahd_inw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">NEXTSCB</span><span class="p">));</span>
	<span class="n">cur_col</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* QINFIFO */</span>
	<span class="n">ahd_search_qinfifo</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CAM_TARGET_WILDCARD</span><span class="p">,</span> <span class="n">ALL_CHANNELS</span><span class="p">,</span>
			   <span class="n">CAM_LUN_WILDCARD</span><span class="p">,</span> <span class="n">SCB_LIST_NULL</span><span class="p">,</span>
			   <span class="n">ROLE_UNKNOWN</span><span class="p">,</span> <span class="cm">/*status*/</span><span class="mi">0</span><span class="p">,</span> <span class="n">SEARCH_PRINT</span><span class="p">);</span>
	<span class="n">saved_scb_index</span> <span class="o">=</span> <span class="n">ahd_get_scbptr</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Pending list:&quot;</span><span class="p">);</span>
	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">LIST_FOREACH</span><span class="p">(</span><span class="n">scb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">pending_scbs</span><span class="p">,</span> <span class="n">pending_links</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">++</span> <span class="o">&gt;</span> <span class="n">AHD_SCB_MAX</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">cur_col</span> <span class="o">=</span> <span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">%3d FIFO_USE[0x%x] &quot;</span><span class="p">,</span> <span class="n">SCB_GET_TAG</span><span class="p">(</span><span class="n">scb</span><span class="p">),</span>
				 <span class="n">ahd_inb_scbram</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_FIFO_USE_COUNT</span><span class="p">));</span>
		<span class="n">ahd_set_scbptr</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_GET_TAG</span><span class="p">(</span><span class="n">scb</span><span class="p">));</span>
		<span class="n">ahd_scb_control_print</span><span class="p">(</span><span class="n">ahd_inb_scbram</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_CONTROL</span><span class="p">),</span>
				      <span class="o">&amp;</span><span class="n">cur_col</span><span class="p">,</span> <span class="mi">60</span><span class="p">);</span>
		<span class="n">ahd_scb_scsiid_print</span><span class="p">(</span><span class="n">ahd_inb_scbram</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_SCSIID</span><span class="p">),</span>
				     <span class="o">&amp;</span><span class="n">cur_col</span><span class="p">,</span> <span class="mi">60</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">Total %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Kernel Free SCB list: &quot;</span><span class="p">);</span>
	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">TAILQ_FOREACH</span><span class="p">(</span><span class="n">scb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">scb_data</span><span class="p">.</span><span class="n">free_scbs</span><span class="p">,</span> <span class="n">links</span><span class="p">.</span><span class="n">tqe</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">scb</span> <span class="o">*</span><span class="n">list_scb</span><span class="p">;</span>

		<span class="n">list_scb</span> <span class="o">=</span> <span class="n">scb</span><span class="p">;</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%d &quot;</span><span class="p">,</span> <span class="n">SCB_GET_TAG</span><span class="p">(</span><span class="n">list_scb</span><span class="p">));</span>
			<span class="n">list_scb</span> <span class="o">=</span> <span class="n">LIST_NEXT</span><span class="p">(</span><span class="n">list_scb</span><span class="p">,</span> <span class="n">collision_links</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">list_scb</span> <span class="o">&amp;&amp;</span> <span class="n">i</span><span class="o">++</span> <span class="o">&lt;</span> <span class="n">AHD_SCB_MAX</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">LIST_FOREACH</span><span class="p">(</span><span class="n">scb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">scb_data</span><span class="p">.</span><span class="n">any_dev_free_scb_list</span><span class="p">,</span> <span class="n">links</span><span class="p">.</span><span class="n">le</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">++</span> <span class="o">&gt;</span> <span class="n">AHD_SCB_MAX</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%d &quot;</span><span class="p">,</span> <span class="n">SCB_GET_TAG</span><span class="p">(</span><span class="n">scb</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Sequencer Complete DMA-inprog list: &quot;</span><span class="p">);</span>
	<span class="n">scb_index</span> <span class="o">=</span> <span class="n">ahd_inw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">COMPLETE_SCB_DMAINPROG_HEAD</span><span class="p">);</span>
	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">SCBID_IS_NULL</span><span class="p">(</span><span class="n">scb_index</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">i</span><span class="o">++</span> <span class="o">&lt;</span> <span class="n">AHD_SCB_MAX</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ahd_set_scbptr</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb_index</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%d &quot;</span><span class="p">,</span> <span class="n">scb_index</span><span class="p">);</span>
		<span class="n">scb_index</span> <span class="o">=</span> <span class="n">ahd_inw_scbram</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_NEXT_COMPLETE</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Sequencer Complete list: &quot;</span><span class="p">);</span>
	<span class="n">scb_index</span> <span class="o">=</span> <span class="n">ahd_inw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">COMPLETE_SCB_HEAD</span><span class="p">);</span>
	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">SCBID_IS_NULL</span><span class="p">(</span><span class="n">scb_index</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">i</span><span class="o">++</span> <span class="o">&lt;</span> <span class="n">AHD_SCB_MAX</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ahd_set_scbptr</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb_index</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%d &quot;</span><span class="p">,</span> <span class="n">scb_index</span><span class="p">);</span>
		<span class="n">scb_index</span> <span class="o">=</span> <span class="n">ahd_inw_scbram</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_NEXT_COMPLETE</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Sequencer DMA-Up and Complete list: &quot;</span><span class="p">);</span>
	<span class="n">scb_index</span> <span class="o">=</span> <span class="n">ahd_inw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">COMPLETE_DMA_SCB_HEAD</span><span class="p">);</span>
	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">SCBID_IS_NULL</span><span class="p">(</span><span class="n">scb_index</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">i</span><span class="o">++</span> <span class="o">&lt;</span> <span class="n">AHD_SCB_MAX</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ahd_set_scbptr</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb_index</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%d &quot;</span><span class="p">,</span> <span class="n">scb_index</span><span class="p">);</span>
		<span class="n">scb_index</span> <span class="o">=</span> <span class="n">ahd_inw_scbram</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_NEXT_COMPLETE</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Sequencer On QFreeze and Complete list: &quot;</span><span class="p">);</span>
	<span class="n">scb_index</span> <span class="o">=</span> <span class="n">ahd_inw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">COMPLETE_ON_QFREEZE_HEAD</span><span class="p">);</span>
	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">SCBID_IS_NULL</span><span class="p">(</span><span class="n">scb_index</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">i</span><span class="o">++</span> <span class="o">&lt;</span> <span class="n">AHD_SCB_MAX</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ahd_set_scbptr</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">scb_index</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%d &quot;</span><span class="p">,</span> <span class="n">scb_index</span><span class="p">);</span>
		<span class="n">scb_index</span> <span class="o">=</span> <span class="n">ahd_inw_scbram</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_NEXT_COMPLETE</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ahd_set_scbptr</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">saved_scb_index</span><span class="p">);</span>
	<span class="n">dffstat</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">DFFSTAT</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef AHD_DEBUG</span>
		<span class="k">struct</span> <span class="n">scb</span> <span class="o">*</span><span class="n">fifo_scb</span><span class="p">;</span>
<span class="cp">#endif</span>
		<span class="n">u_int</span>	    <span class="n">fifo_scbptr</span><span class="p">;</span>

		<span class="n">ahd_set_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHD_MODE_DFF0</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">AHD_MODE_DFF0</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">fifo_scbptr</span> <span class="o">=</span> <span class="n">ahd_get_scbptr</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n\n</span><span class="s">%s: FIFO%d %s, LONGJMP == 0x%x, SCB 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">),</span> <span class="n">i</span><span class="p">,</span>
		       <span class="p">(</span><span class="n">dffstat</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">FIFO0FREE</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">))</span> <span class="o">?</span> <span class="s">&quot;Free&quot;</span> <span class="o">:</span> <span class="s">&quot;Active&quot;</span><span class="p">,</span>
		       <span class="n">ahd_inw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">LONGJMP_ADDR</span><span class="p">),</span> <span class="n">fifo_scbptr</span><span class="p">);</span>
		<span class="n">cur_col</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ahd_seqimode_print</span><span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SEQIMODE</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">cur_col</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
		<span class="n">ahd_seqintsrc_print</span><span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SEQINTSRC</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">cur_col</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
		<span class="n">ahd_dfcntrl_print</span><span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">DFCNTRL</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">cur_col</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
		<span class="n">ahd_dfstatus_print</span><span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">DFSTATUS</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">cur_col</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
		<span class="n">ahd_sg_cache_shadow_print</span><span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SG_CACHE_SHADOW</span><span class="p">),</span>
					  <span class="o">&amp;</span><span class="n">cur_col</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
		<span class="n">ahd_sg_state_print</span><span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SG_STATE</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">cur_col</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
		<span class="n">ahd_dffsxfrctl_print</span><span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">DFFSXFRCTL</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">cur_col</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
		<span class="n">ahd_soffcnt_print</span><span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SOFFCNT</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">cur_col</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
		<span class="n">ahd_mdffstat_print</span><span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">MDFFSTAT</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">cur_col</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cur_col</span> <span class="o">&gt;</span> <span class="mi">50</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">cur_col</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">cur_col</span> <span class="o">+=</span> <span class="n">printk</span><span class="p">(</span><span class="s">&quot;SHADDR = 0x%x%x, SHCNT = 0x%x &quot;</span><span class="p">,</span>
				  <span class="n">ahd_inl</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SHADDR</span><span class="o">+</span><span class="mi">4</span><span class="p">),</span>
				  <span class="n">ahd_inl</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SHADDR</span><span class="p">),</span>
				  <span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SHCNT</span><span class="p">)</span>
				<span class="o">|</span> <span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SHCNT</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span>
				<span class="o">|</span> <span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SHCNT</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cur_col</span> <span class="o">&gt;</span> <span class="mi">50</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">cur_col</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">cur_col</span> <span class="o">+=</span> <span class="n">printk</span><span class="p">(</span><span class="s">&quot;HADDR = 0x%x%x, HCNT = 0x%x &quot;</span><span class="p">,</span>
				  <span class="n">ahd_inl</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">HADDR</span><span class="o">+</span><span class="mi">4</span><span class="p">),</span>
				  <span class="n">ahd_inl</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">HADDR</span><span class="p">),</span>
				  <span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">HCNT</span><span class="p">)</span>
				<span class="o">|</span> <span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">HCNT</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span>
				<span class="o">|</span> <span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">HCNT</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)));</span>
		<span class="n">ahd_ccsgctl_print</span><span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CCSGCTL</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">cur_col</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
<span class="cp">#ifdef AHD_DEBUG</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ahd_debug</span> <span class="o">&amp;</span> <span class="n">AHD_SHOW_SG</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">fifo_scb</span> <span class="o">=</span> <span class="n">ahd_lookup_scb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">fifo_scbptr</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">fifo_scb</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="n">ahd_dump_sglist</span><span class="p">(</span><span class="n">fifo_scb</span><span class="p">);</span>
		<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="p">}</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">LQIN: &quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;0x%x &quot;</span><span class="p">,</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">LQIN</span> <span class="o">+</span> <span class="n">i</span><span class="p">));</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ahd_set_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHD_MODE_CFG</span><span class="p">,</span> <span class="n">AHD_MODE_CFG</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: LQISTATE = 0x%x, LQOSTATE = 0x%x, OPTIONMODE = 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">),</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">LQISTATE</span><span class="p">),</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">LQOSTATE</span><span class="p">),</span>
	       <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">OPTIONMODE</span><span class="p">));</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: OS_SPACE_CNT = 0x%x MAXCMDCNT = 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">),</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">OS_SPACE_CNT</span><span class="p">),</span>
	       <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">MAXCMDCNT</span><span class="p">));</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: SAVED_SCSIID = 0x%x SAVED_LUN = 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">),</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SAVED_SCSIID</span><span class="p">),</span>
	       <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SAVED_LUN</span><span class="p">));</span>
	<span class="n">ahd_simode0_print</span><span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SIMODE0</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">cur_col</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ahd_set_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHD_MODE_CCHAN</span><span class="p">,</span> <span class="n">AHD_MODE_CCHAN</span><span class="p">);</span>
	<span class="n">cur_col</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ahd_ccscbctl_print</span><span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">CCSCBCTL</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">cur_col</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ahd_set_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">saved_src_mode</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">saved_dst_mode</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: REG0 == 0x%x, SINDEX = 0x%x, DINDEX = 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">),</span> <span class="n">ahd_inw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">REG0</span><span class="p">),</span> <span class="n">ahd_inw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SINDEX</span><span class="p">),</span>
	       <span class="n">ahd_inw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">DINDEX</span><span class="p">));</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: SCBPTR == 0x%x, SCB_NEXT == 0x%x, SCB_NEXT2 == 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">ahd_name</span><span class="p">(</span><span class="n">ahd</span><span class="p">),</span> <span class="n">ahd_get_scbptr</span><span class="p">(</span><span class="n">ahd</span><span class="p">),</span>
	       <span class="n">ahd_inw_scbram</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_NEXT</span><span class="p">),</span>
	       <span class="n">ahd_inw_scbram</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_NEXT2</span><span class="p">));</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;CDB %x %x %x %x %x %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">ahd_inb_scbram</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_CDB_STORE</span><span class="p">),</span>
	       <span class="n">ahd_inb_scbram</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_CDB_STORE</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span>
	       <span class="n">ahd_inb_scbram</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_CDB_STORE</span><span class="o">+</span><span class="mi">2</span><span class="p">),</span>
	       <span class="n">ahd_inb_scbram</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_CDB_STORE</span><span class="o">+</span><span class="mi">3</span><span class="p">),</span>
	       <span class="n">ahd_inb_scbram</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_CDB_STORE</span><span class="o">+</span><span class="mi">4</span><span class="p">),</span>
	       <span class="n">ahd_inb_scbram</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCB_CDB_STORE</span><span class="o">+</span><span class="mi">5</span><span class="p">));</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;STACK:&quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">stack_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">saved_stack</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>
		    <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">STACK</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">STACK</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot; 0x%x&quot;</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">saved_stack</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">stack_size</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">STACK</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">saved_stack</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">);</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">STACK</span><span class="p">,</span> <span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">saved_stack</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; Dump Card State Ends &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ahd_restore_modes</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">saved_modes</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">paused</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ahd_unpause</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">void</span>
<span class="c">ahd_dump_scbs(struct ahd_softc *ahd)</span>
<span class="c">{</span>
<span class="c">	ahd_mode_state saved_modes;</span>
<span class="c">	u_int	       saved_scb_index;</span>
<span class="c">	int	       i;</span>

<span class="c">	saved_modes = ahd_save_modes(ahd);</span>
<span class="c">	ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);</span>
<span class="c">	saved_scb_index = ahd_get_scbptr(ahd);</span>
<span class="c">	for (i = 0; i &lt; AHD_SCB_MAX; i++) {</span>
<span class="c">		ahd_set_scbptr(ahd, i);</span>
<span class="c">		printk(&quot;%3d&quot;, i);</span>
<span class="c">		printk(&quot;(CTRL 0x%x ID 0x%x N 0x%x N2 0x%x SG 0x%x, RSG 0x%x)\n&quot;,</span>
<span class="c">		       ahd_inb_scbram(ahd, SCB_CONTROL),</span>
<span class="c">		       ahd_inb_scbram(ahd, SCB_SCSIID),</span>
<span class="c">		       ahd_inw_scbram(ahd, SCB_NEXT),</span>
<span class="c">		       ahd_inw_scbram(ahd, SCB_NEXT2),</span>
<span class="c">		       ahd_inl_scbram(ahd, SCB_SGPTR),</span>
<span class="c">		       ahd_inl_scbram(ahd, SCB_RESIDUAL_SGPTR));</span>
<span class="c">	}</span>
<span class="c">	printk(&quot;\n&quot;);</span>
<span class="c">	ahd_set_scbptr(ahd, saved_scb_index);</span>
<span class="c">	ahd_restore_modes(ahd, saved_modes);</span>
<span class="c">}</span>
<span class="cp">#endif  /*  0  */</span>

<span class="cm">/**************************** Flexport Logic **********************************/</span>
<span class="cm">/*</span>
<span class="cm"> * Read count 16bit words from 16bit word address start_addr from the</span>
<span class="cm"> * SEEPROM attached to the controller, into buf, using the controller&#39;s</span>
<span class="cm"> * SEEPROM reading state machine.  Optionally treat the data as a byte</span>
<span class="cm"> * stream in terms of byte order.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">ahd_read_seeprom</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
		 <span class="n">u_int</span> <span class="n">start_addr</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">count</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bytestream</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u_int</span> <span class="n">cur_addr</span><span class="p">;</span>
	<span class="n">u_int</span> <span class="n">end_addr</span><span class="p">;</span>
	<span class="kt">int</span>   <span class="n">error</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we never make it through the loop even once,</span>
<span class="cm">	 * we were passed invalid arguments.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">AHD_ASSERT_MODES</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI_MSK</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI_MSK</span><span class="p">);</span>
	<span class="n">end_addr</span> <span class="o">=</span> <span class="n">start_addr</span> <span class="o">+</span> <span class="n">count</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">cur_addr</span> <span class="o">=</span> <span class="n">start_addr</span><span class="p">;</span> <span class="n">cur_addr</span> <span class="o">&lt;</span> <span class="n">end_addr</span><span class="p">;</span> <span class="n">cur_addr</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SEEADR</span><span class="p">,</span> <span class="n">cur_addr</span><span class="p">);</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SEECTL</span><span class="p">,</span> <span class="n">SEEOP_READ</span> <span class="o">|</span> <span class="n">SEESTART</span><span class="p">);</span>
		
		<span class="n">error</span> <span class="o">=</span> <span class="n">ahd_wait_seeprom</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bytestream</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">bytestream_ptr</span><span class="p">;</span>

			<span class="n">bytestream_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">;</span>
			<span class="o">*</span><span class="n">bytestream_ptr</span><span class="o">++</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SEEDAT</span><span class="p">);</span>
			<span class="o">*</span><span class="n">bytestream_ptr</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SEEDAT</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * ahd_inw() already handles machine byte order.</span>
<span class="cm">			 */</span>
			<span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">ahd_inw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SEEDAT</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">buf</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">error</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Write count 16bit words from buf, into SEEPROM attache to the</span>
<span class="cm"> * controller starting at 16bit word address start_addr, using the</span>
<span class="cm"> * controller&#39;s SEEPROM writing state machine.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">ahd_write_seeprom</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
		  <span class="n">u_int</span> <span class="n">start_addr</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u_int</span> <span class="n">cur_addr</span><span class="p">;</span>
	<span class="n">u_int</span> <span class="n">end_addr</span><span class="p">;</span>
	<span class="kt">int</span>   <span class="n">error</span><span class="p">;</span>
	<span class="kt">int</span>   <span class="n">retval</span><span class="p">;</span>

	<span class="n">AHD_ASSERT_MODES</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI_MSK</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI_MSK</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">ENOENT</span><span class="p">;</span>

	<span class="cm">/* Place the chip into write-enable mode */</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SEEADR</span><span class="p">,</span> <span class="n">SEEOP_EWEN_ADDR</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SEECTL</span><span class="p">,</span> <span class="n">SEEOP_EWEN</span> <span class="o">|</span> <span class="n">SEESTART</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">ahd_wait_seeprom</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">error</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Write the data.  If we don&#39;t get through the loop at</span>
<span class="cm">	 * least once, the arguments were invalid.</span>
<span class="cm">	 */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">end_addr</span> <span class="o">=</span> <span class="n">start_addr</span> <span class="o">+</span> <span class="n">count</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">cur_addr</span> <span class="o">=</span> <span class="n">start_addr</span><span class="p">;</span> <span class="n">cur_addr</span> <span class="o">&lt;</span> <span class="n">end_addr</span><span class="p">;</span> <span class="n">cur_addr</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ahd_outw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SEEDAT</span><span class="p">,</span> <span class="o">*</span><span class="n">buf</span><span class="o">++</span><span class="p">);</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SEEADR</span><span class="p">,</span> <span class="n">cur_addr</span><span class="p">);</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SEECTL</span><span class="p">,</span> <span class="n">SEEOP_WRITE</span> <span class="o">|</span> <span class="n">SEESTART</span><span class="p">);</span>
		
		<span class="n">retval</span> <span class="o">=</span> <span class="n">ahd_wait_seeprom</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Disable writes.</span>
<span class="cm">	 */</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SEEADR</span><span class="p">,</span> <span class="n">SEEOP_EWDS_ADDR</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SEECTL</span><span class="p">,</span> <span class="n">SEEOP_EWDS</span> <span class="o">|</span> <span class="n">SEESTART</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">ahd_wait_seeprom</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">error</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">retval</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Wait ~100us for the serial eeprom to satisfy our request.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ahd_wait_seeprom</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cnt</span><span class="p">;</span>

	<span class="n">cnt</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SEESTAT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">SEEARBACK</span><span class="o">|</span><span class="n">SEEBUSY</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">--</span><span class="n">cnt</span><span class="p">)</span>
		<span class="n">ahd_delay</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">ETIMEDOUT</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Validate the two checksums in the per_channel</span>
<span class="cm"> * vital product data struct.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ahd_verify_vpd_cksum</span><span class="p">(</span><span class="k">struct</span> <span class="n">vpd_config</span> <span class="o">*</span><span class="n">vpd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">maxaddr</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">checksum</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">vpdarray</span><span class="p">;</span>

	<span class="n">vpdarray</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span><span class="n">vpd</span><span class="p">;</span>
	<span class="n">maxaddr</span> <span class="o">=</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vpd_config</span><span class="p">,</span> <span class="n">vpd_checksum</span><span class="p">);</span>
	<span class="n">checksum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vpd_config</span><span class="p">,</span> <span class="n">resource_type</span><span class="p">);</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">maxaddr</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">checksum</span> <span class="o">=</span> <span class="n">checksum</span> <span class="o">+</span> <span class="n">vpdarray</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">checksum</span> <span class="o">==</span> <span class="mi">0</span>
	 <span class="o">||</span> <span class="p">(</span><span class="o">-</span><span class="n">checksum</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">)</span> <span class="o">!=</span> <span class="n">vpd</span><span class="o">-&gt;</span><span class="n">vpd_checksum</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>

	<span class="n">checksum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">maxaddr</span> <span class="o">=</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vpd_config</span><span class="p">,</span> <span class="n">checksum</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vpd_config</span><span class="p">,</span> <span class="n">default_target_flags</span><span class="p">);</span>
	     <span class="n">i</span> <span class="o">&lt;</span> <span class="n">maxaddr</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">checksum</span> <span class="o">=</span> <span class="n">checksum</span> <span class="o">+</span> <span class="n">vpdarray</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">checksum</span> <span class="o">==</span> <span class="mi">0</span>
	 <span class="o">||</span> <span class="p">(</span><span class="o">-</span><span class="n">checksum</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">)</span> <span class="o">!=</span> <span class="n">vpd</span><span class="o">-&gt;</span><span class="n">checksum</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">ahd_verify_cksum</span><span class="p">(</span><span class="k">struct</span> <span class="n">seeprom_config</span> <span class="o">*</span><span class="n">sc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">maxaddr</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">checksum</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="o">*</span><span class="n">scarray</span><span class="p">;</span>

	<span class="n">maxaddr</span> <span class="o">=</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">sc</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">checksum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">scarray</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint16_t</span> <span class="o">*</span><span class="p">)</span><span class="n">sc</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">maxaddr</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">checksum</span> <span class="o">=</span> <span class="n">checksum</span> <span class="o">+</span> <span class="n">scarray</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">checksum</span> <span class="o">==</span> <span class="mi">0</span>
	 <span class="o">||</span> <span class="p">(</span><span class="n">checksum</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="p">)</span> <span class="o">!=</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">checksum</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">ahd_acquire_seeprom</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * We should be able to determine the SEEPROM type</span>
<span class="cm">	 * from the flexport logic, but unfortunately not</span>
<span class="cm">	 * all implementations have this logic and there is</span>
<span class="cm">	 * no programatic method for determining if the logic</span>
<span class="cm">	 * is present.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	uint8_t	seetype;</span>
<span class="c">	int	error;</span>

<span class="c">	error = ahd_read_flexport(ahd, FLXADDR_ROMSTAT_CURSENSECTL, &amp;seetype);</span>
<span class="c">	if (error != 0</span>
<span class="c">         || ((seetype &amp; FLX_ROMSTAT_SEECFG) == FLX_ROMSTAT_SEE_NONE))</span>
<span class="c">		return (0);</span>
<span class="c">	return (1);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">ahd_release_seeprom</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Currently a no-op */</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Wait at most 2 seconds for flexport arbitration to succeed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ahd_wait_flexport</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cnt</span><span class="p">;</span>

	<span class="n">AHD_ASSERT_MODES</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI_MSK</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI_MSK</span><span class="p">);</span>
	<span class="n">cnt</span> <span class="o">=</span> <span class="mi">1000000</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">/</span> <span class="mi">5</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">BRDCTL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">FLXARBACK</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">--</span><span class="n">cnt</span><span class="p">)</span>
		<span class="n">ahd_delay</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">ETIMEDOUT</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">ahd_write_flexport</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">addr</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">AHD_ASSERT_MODES</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI_MSK</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI_MSK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&gt;</span> <span class="mi">7</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;ahd_write_flexport: address out of range&quot;</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">BRDCTL</span><span class="p">,</span> <span class="n">BRDEN</span><span class="o">|</span><span class="p">(</span><span class="n">addr</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">));</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">ahd_wait_flexport</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">error</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">BRDDAT</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
	<span class="n">ahd_flush_device_writes</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">BRDCTL</span><span class="p">,</span> <span class="n">BRDSTB</span><span class="o">|</span><span class="n">BRDEN</span><span class="o">|</span><span class="p">(</span><span class="n">addr</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">));</span>
	<span class="n">ahd_flush_device_writes</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">BRDCTL</span><span class="p">,</span> <span class="n">BRDEN</span><span class="o">|</span><span class="p">(</span><span class="n">addr</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">));</span>
	<span class="n">ahd_flush_device_writes</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">BRDCTL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ahd_flush_device_writes</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">ahd_read_flexport</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>	<span class="n">error</span><span class="p">;</span>

	<span class="n">AHD_ASSERT_MODES</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI_MSK</span><span class="p">,</span> <span class="n">AHD_MODE_SCSI_MSK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&gt;</span> <span class="mi">7</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;ahd_read_flexport: address out of range&quot;</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">BRDCTL</span><span class="p">,</span> <span class="n">BRDRW</span><span class="o">|</span><span class="n">BRDEN</span><span class="o">|</span><span class="p">(</span><span class="n">addr</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">));</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">ahd_wait_flexport</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">error</span><span class="p">);</span>
	<span class="o">*</span><span class="n">value</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">BRDDAT</span><span class="p">);</span>
	<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">BRDCTL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ahd_flush_device_writes</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/************************* Target Mode ****************************************/</span>
<span class="cp">#ifdef AHD_TARGET_MODE</span>
<span class="n">cam_status</span>
<span class="nf">ahd_find_tmode_devs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cam_sim</span> <span class="o">*</span><span class="n">sim</span><span class="p">,</span> <span class="k">union</span> <span class="n">ccb</span> <span class="o">*</span><span class="n">ccb</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">ahd_tmode_tstate</span> <span class="o">**</span><span class="n">tstate</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">ahd_tmode_lstate</span> <span class="o">**</span><span class="n">lstate</span><span class="p">,</span>
		    <span class="kt">int</span> <span class="n">notfound_failure</span><span class="p">)</span>
<span class="p">{</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">AHD_TARGETMODE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">CAM_REQ_INVALID</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Handle the &#39;black hole&#39; device that sucks up</span>
<span class="cm">	 * requests to unattached luns on enabled targets.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ccb</span><span class="o">-&gt;</span><span class="n">ccb_h</span><span class="p">.</span><span class="n">target_id</span> <span class="o">==</span> <span class="n">CAM_TARGET_WILDCARD</span>
	 <span class="o">&amp;&amp;</span> <span class="n">ccb</span><span class="o">-&gt;</span><span class="n">ccb_h</span><span class="p">.</span><span class="n">target_lun</span> <span class="o">==</span> <span class="n">CAM_LUN_WILDCARD</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">tstate</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="o">*</span><span class="n">lstate</span> <span class="o">=</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">black_hole</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">u_int</span> <span class="n">max_id</span><span class="p">;</span>

		<span class="n">max_id</span> <span class="o">=</span> <span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">AHD_WIDE</span><span class="p">)</span> <span class="o">?</span> <span class="mi">16</span> <span class="o">:</span> <span class="mi">8</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ccb</span><span class="o">-&gt;</span><span class="n">ccb_h</span><span class="p">.</span><span class="n">target_id</span> <span class="o">&gt;=</span> <span class="n">max_id</span><span class="p">)</span>
			<span class="k">return</span> <span class="p">(</span><span class="n">CAM_TID_INVALID</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ccb</span><span class="o">-&gt;</span><span class="n">ccb_h</span><span class="p">.</span><span class="n">target_lun</span> <span class="o">&gt;=</span> <span class="n">AHD_NUM_LUNS</span><span class="p">)</span>
			<span class="k">return</span> <span class="p">(</span><span class="n">CAM_LUN_INVALID</span><span class="p">);</span>

		<span class="o">*</span><span class="n">tstate</span> <span class="o">=</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">enabled_targets</span><span class="p">[</span><span class="n">ccb</span><span class="o">-&gt;</span><span class="n">ccb_h</span><span class="p">.</span><span class="n">target_id</span><span class="p">];</span>
		<span class="o">*</span><span class="n">lstate</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">tstate</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="o">*</span><span class="n">lstate</span> <span class="o">=</span>
			    <span class="p">(</span><span class="o">*</span><span class="n">tstate</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">enabled_luns</span><span class="p">[</span><span class="n">ccb</span><span class="o">-&gt;</span><span class="n">ccb_h</span><span class="p">.</span><span class="n">target_lun</span><span class="p">];</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">notfound_failure</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">lstate</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">CAM_PATH_INVALID</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">CAM_REQ_CMP</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">ahd_handle_en_lun</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cam_sim</span> <span class="o">*</span><span class="n">sim</span><span class="p">,</span> <span class="k">union</span> <span class="n">ccb</span> <span class="o">*</span><span class="n">ccb</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if NOT_YET</span>
	<span class="k">struct</span>	   <span class="n">ahd_tmode_tstate</span> <span class="o">*</span><span class="n">tstate</span><span class="p">;</span>
	<span class="k">struct</span>	   <span class="n">ahd_tmode_lstate</span> <span class="o">*</span><span class="n">lstate</span><span class="p">;</span>
	<span class="k">struct</span>	   <span class="n">ccb_en_lun</span> <span class="o">*</span><span class="n">cel</span><span class="p">;</span>
	<span class="n">cam_status</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">u_int</span>	   <span class="n">target</span><span class="p">;</span>
	<span class="n">u_int</span>	   <span class="n">lun</span><span class="p">;</span>
	<span class="n">u_int</span>	   <span class="n">target_mask</span><span class="p">;</span>
	<span class="n">u_long</span>	   <span class="n">s</span><span class="p">;</span>
	<span class="kt">char</span>	   <span class="n">channel</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">ahd_find_tmode_devs</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">sim</span><span class="p">,</span> <span class="n">ccb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tstate</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lstate</span><span class="p">,</span>
				     <span class="cm">/*notfound_failure*/</span><span class="n">FALSE</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">CAM_REQ_CMP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ccb</span><span class="o">-&gt;</span><span class="n">ccb_h</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="n">status</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">AHD_MULTIROLE</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u_int</span>	   <span class="n">our_id</span><span class="p">;</span>

		<span class="n">our_id</span> <span class="o">=</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">our_id</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ccb</span><span class="o">-&gt;</span><span class="n">ccb_h</span><span class="p">.</span><span class="n">target_id</span> <span class="o">!=</span> <span class="n">our_id</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">AHD_MULTI_TID</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>
		   	 <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AHD_INITIATORROLE</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Only allow additional targets if</span>
<span class="cm">				 * the initiator role is disabled.</span>
<span class="cm">				 * The hardware cannot handle a re-select-in</span>
<span class="cm">				 * on the initiator id during a re-select-out</span>
<span class="cm">				 * on a different target id.</span>
<span class="cm">				 */</span>
				<span class="n">status</span> <span class="o">=</span> <span class="n">CAM_TID_INVALID</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AHD_INITIATORROLE</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>
				<span class="o">||</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">enabled_luns</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Only allow our target id to change</span>
<span class="cm">				 * if the initiator role is not configured</span>
<span class="cm">				 * and there are no enabled luns which</span>
<span class="cm">				 * are attached to the currently registered</span>
<span class="cm">				 * scsi id.</span>
<span class="cm">				 */</span>
				<span class="n">status</span> <span class="o">=</span> <span class="n">CAM_TID_INVALID</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">CAM_REQ_CMP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ccb</span><span class="o">-&gt;</span><span class="n">ccb_h</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="n">status</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We now have an id that is valid.</span>
<span class="cm">	 * If we aren&#39;t in target mode, switch modes.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AHD_TARGETROLE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
	 <span class="o">&amp;&amp;</span> <span class="n">ccb</span><span class="o">-&gt;</span><span class="n">ccb_h</span><span class="p">.</span><span class="n">target_id</span> <span class="o">!=</span> <span class="n">CAM_TARGET_WILDCARD</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u_long</span>	<span class="n">s</span><span class="p">;</span>

		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Configuring Target Mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ahd_lock</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">LIST_FIRST</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">pending_scbs</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ccb</span><span class="o">-&gt;</span><span class="n">ccb_h</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="n">CAM_BUSY</span><span class="p">;</span>
			<span class="n">ahd_unlock</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">AHD_TARGETROLE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">AHD_MULTIROLE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">AHD_INITIATORROLE</span><span class="p">;</span>
		<span class="n">ahd_pause</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
		<span class="n">ahd_loadseq</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
		<span class="n">ahd_restart</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
		<span class="n">ahd_unlock</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">cel</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ccb</span><span class="o">-&gt;</span><span class="n">cel</span><span class="p">;</span>
	<span class="n">target</span> <span class="o">=</span> <span class="n">ccb</span><span class="o">-&gt;</span><span class="n">ccb_h</span><span class="p">.</span><span class="n">target_id</span><span class="p">;</span>
	<span class="n">lun</span> <span class="o">=</span> <span class="n">ccb</span><span class="o">-&gt;</span><span class="n">ccb_h</span><span class="p">.</span><span class="n">target_lun</span><span class="p">;</span>
	<span class="n">channel</span> <span class="o">=</span> <span class="n">SIM_CHANNEL</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">sim</span><span class="p">);</span>
	<span class="n">target_mask</span> <span class="o">=</span> <span class="mh">0x01</span> <span class="o">&lt;&lt;</span> <span class="n">target</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">channel</span> <span class="o">==</span> <span class="sc">&#39;B&#39;</span><span class="p">)</span>
		<span class="n">target_mask</span> <span class="o">&lt;&lt;=</span> <span class="mi">8</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cel</span><span class="o">-&gt;</span><span class="n">enable</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u_int</span> <span class="n">scsiseq1</span><span class="p">;</span>

		<span class="cm">/* Are we already enabled?? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lstate</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xpt_print_path</span><span class="p">(</span><span class="n">ccb</span><span class="o">-&gt;</span><span class="n">ccb_h</span><span class="p">.</span><span class="n">path</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Lun already enabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">ccb</span><span class="o">-&gt;</span><span class="n">ccb_h</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="n">CAM_LUN_ALRDY_ENA</span><span class="p">;</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cel</span><span class="o">-&gt;</span><span class="n">grp6_len</span> <span class="o">!=</span> <span class="mi">0</span>
		 <span class="o">||</span> <span class="n">cel</span><span class="o">-&gt;</span><span class="n">grp7_len</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Don&#39;t (yet?) support vendor</span>
<span class="cm">			 * specific commands.</span>
<span class="cm">			 */</span>
			<span class="n">ccb</span><span class="o">-&gt;</span><span class="n">ccb_h</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="n">CAM_REQ_INVALID</span><span class="p">;</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Non-zero Group Codes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Seems to be okay.</span>
<span class="cm">		 * Setup our data structures.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">target</span> <span class="o">!=</span> <span class="n">CAM_TARGET_WILDCARD</span> <span class="o">&amp;&amp;</span> <span class="n">tstate</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tstate</span> <span class="o">=</span> <span class="n">ahd_alloc_tstate</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">channel</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tstate</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">xpt_print_path</span><span class="p">(</span><span class="n">ccb</span><span class="o">-&gt;</span><span class="n">ccb_h</span><span class="p">.</span><span class="n">path</span><span class="p">);</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Couldn&#39;t allocate tstate</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">ccb</span><span class="o">-&gt;</span><span class="n">ccb_h</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="n">CAM_RESRC_UNAVAIL</span><span class="p">;</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">lstate</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">lstate</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lstate</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xpt_print_path</span><span class="p">(</span><span class="n">ccb</span><span class="o">-&gt;</span><span class="n">ccb_h</span><span class="p">.</span><span class="n">path</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Couldn&#39;t allocate lstate</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">ccb</span><span class="o">-&gt;</span><span class="n">ccb_h</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="n">CAM_RESRC_UNAVAIL</span><span class="p">;</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">lstate</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">lstate</span><span class="p">));</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">xpt_create_path</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lstate</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">,</span> <span class="cm">/*periph*/</span><span class="nb">NULL</span><span class="p">,</span>
					 <span class="n">xpt_path_path_id</span><span class="p">(</span><span class="n">ccb</span><span class="o">-&gt;</span><span class="n">ccb_h</span><span class="p">.</span><span class="n">path</span><span class="p">),</span>
					 <span class="n">xpt_path_target_id</span><span class="p">(</span><span class="n">ccb</span><span class="o">-&gt;</span><span class="n">ccb_h</span><span class="p">.</span><span class="n">path</span><span class="p">),</span>
					 <span class="n">xpt_path_lun_id</span><span class="p">(</span><span class="n">ccb</span><span class="o">-&gt;</span><span class="n">ccb_h</span><span class="p">.</span><span class="n">path</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">CAM_REQ_CMP</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">lstate</span><span class="p">);</span>
			<span class="n">xpt_print_path</span><span class="p">(</span><span class="n">ccb</span><span class="o">-&gt;</span><span class="n">ccb_h</span><span class="p">.</span><span class="n">path</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Couldn&#39;t allocate path</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">ccb</span><span class="o">-&gt;</span><span class="n">ccb_h</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="n">CAM_RESRC_UNAVAIL</span><span class="p">;</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">SLIST_INIT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lstate</span><span class="o">-&gt;</span><span class="n">accept_tios</span><span class="p">);</span>
		<span class="n">SLIST_INIT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lstate</span><span class="o">-&gt;</span><span class="n">immed_notifies</span><span class="p">);</span>
		<span class="n">ahd_lock</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
		<span class="n">ahd_pause</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">target</span> <span class="o">!=</span> <span class="n">CAM_TARGET_WILDCARD</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tstate</span><span class="o">-&gt;</span><span class="n">enabled_luns</span><span class="p">[</span><span class="n">lun</span><span class="p">]</span> <span class="o">=</span> <span class="n">lstate</span><span class="p">;</span>
			<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">enabled_luns</span><span class="o">++</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">((</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">AHD_MULTI_TID</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">u_int</span> <span class="n">targid_mask</span><span class="p">;</span>

				<span class="n">targid_mask</span> <span class="o">=</span> <span class="n">ahd_inw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">TARGID</span><span class="p">);</span>
				<span class="n">targid_mask</span> <span class="o">|=</span> <span class="n">target_mask</span><span class="p">;</span>
				<span class="n">ahd_outw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">TARGID</span><span class="p">,</span> <span class="n">targid_mask</span><span class="p">);</span>
				<span class="n">ahd_update_scsiid</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">targid_mask</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">u_int</span> <span class="n">our_id</span><span class="p">;</span>
				<span class="kt">char</span>  <span class="n">channel</span><span class="p">;</span>

				<span class="n">channel</span> <span class="o">=</span> <span class="n">SIM_CHANNEL</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">sim</span><span class="p">);</span>
				<span class="n">our_id</span> <span class="o">=</span> <span class="n">SIM_SCSI_ID</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">sim</span><span class="p">);</span>

				<span class="cm">/*</span>
<span class="cm">				 * This can only happen if selections</span>
<span class="cm">				 * are not enabled</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">target</span> <span class="o">!=</span> <span class="n">our_id</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">u_int</span> <span class="n">sblkctl</span><span class="p">;</span>
					<span class="kt">char</span>  <span class="n">cur_channel</span><span class="p">;</span>
					<span class="kt">int</span>   <span class="n">swap</span><span class="p">;</span>

					<span class="n">sblkctl</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SBLKCTL</span><span class="p">);</span>
					<span class="n">cur_channel</span> <span class="o">=</span> <span class="p">(</span><span class="n">sblkctl</span> <span class="o">&amp;</span> <span class="n">SELBUSB</span><span class="p">)</span>
						    <span class="o">?</span> <span class="sc">&#39;B&#39;</span> <span class="o">:</span> <span class="sc">&#39;A&#39;</span><span class="p">;</span>
					<span class="k">if</span> <span class="p">((</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">AHD_TWIN</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
						<span class="n">cur_channel</span> <span class="o">=</span> <span class="sc">&#39;A&#39;</span><span class="p">;</span>
					<span class="n">swap</span> <span class="o">=</span> <span class="n">cur_channel</span> <span class="o">!=</span> <span class="n">channel</span><span class="p">;</span>
					<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">our_id</span> <span class="o">=</span> <span class="n">target</span><span class="p">;</span>

					<span class="k">if</span> <span class="p">(</span><span class="n">swap</span><span class="p">)</span>
						<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SBLKCTL</span><span class="p">,</span>
							 <span class="n">sblkctl</span> <span class="o">^</span> <span class="n">SELBUSB</span><span class="p">);</span>

					<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCSIID</span><span class="p">,</span> <span class="n">target</span><span class="p">);</span>

					<span class="k">if</span> <span class="p">(</span><span class="n">swap</span><span class="p">)</span>
						<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SBLKCTL</span><span class="p">,</span> <span class="n">sblkctl</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">black_hole</span> <span class="o">=</span> <span class="n">lstate</span><span class="p">;</span>
		<span class="cm">/* Allow select-in operations */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">black_hole</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">enabled_luns</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">scsiseq1</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCSISEQ_TEMPLATE</span><span class="p">);</span>
			<span class="n">scsiseq1</span> <span class="o">|=</span> <span class="n">ENSELI</span><span class="p">;</span>
			<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCSISEQ_TEMPLATE</span><span class="p">,</span> <span class="n">scsiseq1</span><span class="p">);</span>
			<span class="n">scsiseq1</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCSISEQ1</span><span class="p">);</span>
			<span class="n">scsiseq1</span> <span class="o">|=</span> <span class="n">ENSELI</span><span class="p">;</span>
			<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCSISEQ1</span><span class="p">,</span> <span class="n">scsiseq1</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">ahd_unpause</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
		<span class="n">ahd_unlock</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
		<span class="n">ccb</span><span class="o">-&gt;</span><span class="n">ccb_h</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="n">CAM_REQ_CMP</span><span class="p">;</span>
		<span class="n">xpt_print_path</span><span class="p">(</span><span class="n">ccb</span><span class="o">-&gt;</span><span class="n">ccb_h</span><span class="p">.</span><span class="n">path</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Lun now enabled for target mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">scb</span> <span class="o">*</span><span class="n">scb</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">empty</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">lstate</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ccb</span><span class="o">-&gt;</span><span class="n">ccb_h</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="n">CAM_LUN_INVALID</span><span class="p">;</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ahd_lock</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
		
		<span class="n">ccb</span><span class="o">-&gt;</span><span class="n">ccb_h</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="n">CAM_REQ_CMP</span><span class="p">;</span>
		<span class="n">LIST_FOREACH</span><span class="p">(</span><span class="n">scb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">pending_scbs</span><span class="p">,</span> <span class="n">pending_links</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">ccb_hdr</span> <span class="o">*</span><span class="n">ccbh</span><span class="p">;</span>

			<span class="n">ccbh</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">io_ctx</span><span class="o">-&gt;</span><span class="n">ccb_h</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ccbh</span><span class="o">-&gt;</span><span class="n">func_code</span> <span class="o">==</span> <span class="n">XPT_CONT_TARGET_IO</span>
			 <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">xpt_path_comp</span><span class="p">(</span><span class="n">ccbh</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">,</span> <span class="n">ccb</span><span class="o">-&gt;</span><span class="n">ccb_h</span><span class="p">.</span><span class="n">path</span><span class="p">)){</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;CTIO pending</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">ccb</span><span class="o">-&gt;</span><span class="n">ccb_h</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="n">CAM_REQ_INVALID</span><span class="p">;</span>
				<span class="n">ahd_unlock</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">SLIST_FIRST</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lstate</span><span class="o">-&gt;</span><span class="n">accept_tios</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;ATIOs pending</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">ccb</span><span class="o">-&gt;</span><span class="n">ccb_h</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="n">CAM_REQ_INVALID</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">SLIST_FIRST</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lstate</span><span class="o">-&gt;</span><span class="n">immed_notifies</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;INOTs pending</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">ccb</span><span class="o">-&gt;</span><span class="n">ccb_h</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="n">CAM_REQ_INVALID</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ccb</span><span class="o">-&gt;</span><span class="n">ccb_h</span><span class="p">.</span><span class="n">status</span> <span class="o">!=</span> <span class="n">CAM_REQ_CMP</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ahd_unlock</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">xpt_print_path</span><span class="p">(</span><span class="n">ccb</span><span class="o">-&gt;</span><span class="n">ccb_h</span><span class="p">.</span><span class="n">path</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Target mode disabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">xpt_free_path</span><span class="p">(</span><span class="n">lstate</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">lstate</span><span class="p">);</span>

		<span class="n">ahd_pause</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
		<span class="cm">/* Can we clean up the target too? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">target</span> <span class="o">!=</span> <span class="n">CAM_TARGET_WILDCARD</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tstate</span><span class="o">-&gt;</span><span class="n">enabled_luns</span><span class="p">[</span><span class="n">lun</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">enabled_luns</span><span class="o">--</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">empty</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">tstate</span><span class="o">-&gt;</span><span class="n">enabled_luns</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">empty</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">empty</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ahd_free_tstate</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span>
						<span class="cm">/*force*/</span><span class="n">FALSE</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">AHD_MULTI_TID</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">u_int</span> <span class="n">targid_mask</span><span class="p">;</span>

					<span class="n">targid_mask</span> <span class="o">=</span> <span class="n">ahd_inw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">TARGID</span><span class="p">);</span>
					<span class="n">targid_mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">target_mask</span><span class="p">;</span>
					<span class="n">ahd_outw</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">TARGID</span><span class="p">,</span> <span class="n">targid_mask</span><span class="p">);</span>
					<span class="n">ahd_update_scsiid</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">targid_mask</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>

			<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">black_hole</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * We can&#39;t allow selections without</span>
<span class="cm">			 * our black hole device.</span>
<span class="cm">			 */</span>
			<span class="n">empty</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">enabled_luns</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Disallow select-in */</span>
			<span class="n">u_int</span> <span class="n">scsiseq1</span><span class="p">;</span>

			<span class="n">scsiseq1</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCSISEQ_TEMPLATE</span><span class="p">);</span>
			<span class="n">scsiseq1</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ENSELI</span><span class="p">;</span>
			<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCSISEQ_TEMPLATE</span><span class="p">,</span> <span class="n">scsiseq1</span><span class="p">);</span>
			<span class="n">scsiseq1</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCSISEQ1</span><span class="p">);</span>
			<span class="n">scsiseq1</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ENSELI</span><span class="p">;</span>
			<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCSISEQ1</span><span class="p">,</span> <span class="n">scsiseq1</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">((</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">AHD_MULTIROLE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Configuring Initiator Mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">AHD_TARGETROLE</span><span class="p">;</span>
				<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">AHD_INITIATORROLE</span><span class="p">;</span>
				<span class="n">ahd_pause</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
				<span class="n">ahd_loadseq</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
				<span class="n">ahd_restart</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
				<span class="cm">/*</span>
<span class="cm">				 * Unpaused.  The extra unpause</span>
<span class="cm">				 * that follows is harmless.</span>
<span class="cm">				 */</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">ahd_unpause</span><span class="p">(</span><span class="n">ahd</span><span class="p">);</span>
		<span class="n">ahd_unlock</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_update_scsiid</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">targid_mask</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if NOT_YET</span>
	<span class="n">u_int</span> <span class="n">scsiid_mask</span><span class="p">;</span>
	<span class="n">u_int</span> <span class="n">scsiid</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">AHD_MULTI_TID</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;ahd_update_scsiid called on non-multitid unit</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Since we will rely on the TARGID mask</span>
<span class="cm">	 * for selection enables, ensure that OID</span>
<span class="cm">	 * in SCSIID is not set to some other ID</span>
<span class="cm">	 * that we don&#39;t want to allow selections on.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">AHD_ULTRA2</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">scsiid</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCSIID_ULTRA2</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">scsiid</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCSIID</span><span class="p">);</span>
	<span class="n">scsiid_mask</span> <span class="o">=</span> <span class="mh">0x1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">scsiid</span> <span class="o">&amp;</span> <span class="n">OID</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">targid_mask</span> <span class="o">&amp;</span> <span class="n">scsiid_mask</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u_int</span> <span class="n">our_id</span><span class="p">;</span>

		<span class="cm">/* ffs counts from 1 */</span>
		<span class="n">our_id</span> <span class="o">=</span> <span class="n">ffs</span><span class="p">(</span><span class="n">targid_mask</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">our_id</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">our_id</span> <span class="o">=</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">our_id</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">our_id</span><span class="o">--</span><span class="p">;</span>
		<span class="n">scsiid</span> <span class="o">&amp;=</span> <span class="n">TID</span><span class="p">;</span>
		<span class="n">scsiid</span> <span class="o">|=</span> <span class="n">our_id</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">AHD_ULTRA2</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCSIID_ULTRA2</span><span class="p">,</span> <span class="n">scsiid</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">SCSIID</span><span class="p">,</span> <span class="n">scsiid</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahd_run_tqinfifo</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">paused</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">target_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>

	<span class="n">ahd_sync_tqinfifo</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">BUS_DMASYNC_POSTREAD</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">cmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">targetcmds</span><span class="p">[</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">tqinfifonext</span><span class="p">])</span><span class="o">-&gt;</span><span class="n">cmd_valid</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/*</span>
<span class="cm">		 * Only advance through the queue if we</span>
<span class="cm">		 * have the resources to process the command.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ahd_handle_target_cmd</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">cmd</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmd_valid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ahd_dmamap_sync</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">shared_data_dmat</span><span class="p">,</span>
				<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">shared_data_map</span><span class="p">.</span><span class="n">dmamap</span><span class="p">,</span>
				<span class="n">ahd_targetcmd_offset</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">tqinfifonext</span><span class="p">),</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">target_cmd</span><span class="p">),</span>
				<span class="n">BUS_DMASYNC_PREREAD</span><span class="p">);</span>
		<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">tqinfifonext</span><span class="o">++</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Lazily update our position in the target mode incoming</span>
<span class="cm">		 * command queue as seen by the sequencer.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ahd</span><span class="o">-&gt;</span><span class="n">tqinfifonext</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">HOST_TQINPOS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u_int</span> <span class="n">hs_mailbox</span><span class="p">;</span>

			<span class="n">hs_mailbox</span> <span class="o">=</span> <span class="n">ahd_inb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">HS_MAILBOX</span><span class="p">);</span>
			<span class="n">hs_mailbox</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">HOST_TQINPOS</span><span class="p">;</span>
			<span class="n">hs_mailbox</span> <span class="o">|=</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">tqinfifonext</span> <span class="o">&amp;</span> <span class="n">HOST_TQINPOS</span><span class="p">;</span>
			<span class="n">ahd_outb</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">HS_MAILBOX</span><span class="p">,</span> <span class="n">hs_mailbox</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ahd_handle_target_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">target_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span>	  <span class="n">ahd_tmode_tstate</span> <span class="o">*</span><span class="n">tstate</span><span class="p">;</span>
	<span class="k">struct</span>	  <span class="n">ahd_tmode_lstate</span> <span class="o">*</span><span class="n">lstate</span><span class="p">;</span>
	<span class="k">struct</span>	  <span class="n">ccb_accept_tio</span> <span class="o">*</span><span class="n">atio</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">byte</span><span class="p">;</span>
	<span class="kt">int</span>	  <span class="n">initiator</span><span class="p">;</span>
	<span class="kt">int</span>	  <span class="n">target</span><span class="p">;</span>
	<span class="kt">int</span>	  <span class="n">lun</span><span class="p">;</span>

	<span class="n">initiator</span> <span class="o">=</span> <span class="n">SCSIID_TARGET</span><span class="p">(</span><span class="n">ahd</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsiid</span><span class="p">);</span>
	<span class="n">target</span> <span class="o">=</span> <span class="n">SCSIID_OUR_ID</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsiid</span><span class="p">);</span>
	<span class="n">lun</span>    <span class="o">=</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">identify</span> <span class="o">&amp;</span> <span class="n">MSG_IDENTIFY_LUNMASK</span><span class="p">);</span>

	<span class="n">byte</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">bytes</span><span class="p">;</span>
	<span class="n">tstate</span> <span class="o">=</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">enabled_targets</span><span class="p">[</span><span class="n">target</span><span class="p">];</span>
	<span class="n">lstate</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tstate</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">lstate</span> <span class="o">=</span> <span class="n">tstate</span><span class="o">-&gt;</span><span class="n">enabled_luns</span><span class="p">[</span><span class="n">lun</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 * Commands for disabled luns go to the black hole driver.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lstate</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">lstate</span> <span class="o">=</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">black_hole</span><span class="p">;</span>

	<span class="n">atio</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ccb_accept_tio</span><span class="o">*</span><span class="p">)</span><span class="n">SLIST_FIRST</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lstate</span><span class="o">-&gt;</span><span class="n">accept_tios</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atio</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">AHD_TQINFIFO_BLOCKED</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Wait for more ATIOs from the peripheral driver for this lun.</span>
<span class="cm">		 */</span>
		<span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">AHD_TQINFIFO_BLOCKED</span><span class="p">;</span>
<span class="cp">#ifdef AHD_DEBUG</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ahd_debug</span> <span class="o">&amp;</span> <span class="n">AHD_SHOW_TQIN</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Incoming command from %d for %d:%d%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">initiator</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">lun</span><span class="p">,</span>
		       <span class="n">lstate</span> <span class="o">==</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">black_hole</span> <span class="o">?</span> <span class="s">&quot;(Black Holed)&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">SLIST_REMOVE_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lstate</span><span class="o">-&gt;</span><span class="n">accept_tios</span><span class="p">,</span> <span class="n">sim_links</span><span class="p">.</span><span class="n">sle</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lstate</span> <span class="o">==</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">black_hole</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Fill in the wildcards */</span>
		<span class="n">atio</span><span class="o">-&gt;</span><span class="n">ccb_h</span><span class="p">.</span><span class="n">target_id</span> <span class="o">=</span> <span class="n">target</span><span class="p">;</span>
		<span class="n">atio</span><span class="o">-&gt;</span><span class="n">ccb_h</span><span class="p">.</span><span class="n">target_lun</span> <span class="o">=</span> <span class="n">lun</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Package it up and send it off to</span>
<span class="cm">	 * whomever has this lun enabled.</span>
<span class="cm">	 */</span>
	<span class="n">atio</span><span class="o">-&gt;</span><span class="n">sense_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">atio</span><span class="o">-&gt;</span><span class="n">init_id</span> <span class="o">=</span> <span class="n">initiator</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">byte</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mh">0xFF</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Tag was included */</span>
		<span class="n">atio</span><span class="o">-&gt;</span><span class="n">tag_action</span> <span class="o">=</span> <span class="o">*</span><span class="n">byte</span><span class="o">++</span><span class="p">;</span>
		<span class="n">atio</span><span class="o">-&gt;</span><span class="n">tag_id</span> <span class="o">=</span> <span class="o">*</span><span class="n">byte</span><span class="o">++</span><span class="p">;</span>
		<span class="n">atio</span><span class="o">-&gt;</span><span class="n">ccb_h</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">CAM_TAG_ACTION_VALID</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">atio</span><span class="o">-&gt;</span><span class="n">ccb_h</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">byte</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* Okay.  Now determine the cdb size based on the command code */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="o">*</span><span class="n">byte</span> <span class="o">&gt;&gt;</span> <span class="n">CMD_GROUP_CODE_SHIFT</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="n">atio</span><span class="o">-&gt;</span><span class="n">cdb_len</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1</span>:
	<span class="k">case</span> <span class="mi">2</span>:
		<span class="n">atio</span><span class="o">-&gt;</span><span class="n">cdb_len</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">4</span>:
		<span class="n">atio</span><span class="o">-&gt;</span><span class="n">cdb_len</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">5</span>:
		<span class="n">atio</span><span class="o">-&gt;</span><span class="n">cdb_len</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">3</span>:
	<span class="nl">default:</span>
		<span class="cm">/* Only copy the opcode. */</span>
		<span class="n">atio</span><span class="o">-&gt;</span><span class="n">cdb_len</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Reserved or VU command code type encountered</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	
	<span class="n">memcpy</span><span class="p">(</span><span class="n">atio</span><span class="o">-&gt;</span><span class="n">cdb_io</span><span class="p">.</span><span class="n">cdb_bytes</span><span class="p">,</span> <span class="n">byte</span><span class="p">,</span> <span class="n">atio</span><span class="o">-&gt;</span><span class="n">cdb_len</span><span class="p">);</span>

	<span class="n">atio</span><span class="o">-&gt;</span><span class="n">ccb_h</span><span class="p">.</span><span class="n">status</span> <span class="o">|=</span> <span class="n">CAM_CDB_RECVD</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">identify</span> <span class="o">&amp;</span> <span class="n">MSG_IDENTIFY_DISCFLAG</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We weren&#39;t allowed to disconnect.</span>
<span class="cm">		 * We&#39;re hanging on the bus until a</span>
<span class="cm">		 * continue target I/O comes in response</span>
<span class="cm">		 * to this accept tio.</span>
<span class="cm">		 */</span>
<span class="cp">#ifdef AHD_DEBUG</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ahd_debug</span> <span class="o">&amp;</span> <span class="n">AHD_SHOW_TQIN</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Received Immediate Command %d:%d:%d - %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">initiator</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">lun</span><span class="p">,</span> <span class="n">ahd</span><span class="o">-&gt;</span><span class="n">pending_device</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="n">ahd</span><span class="o">-&gt;</span><span class="n">pending_device</span> <span class="o">=</span> <span class="n">lstate</span><span class="p">;</span>
		<span class="n">ahd_freeze_ccb</span><span class="p">((</span><span class="k">union</span> <span class="n">ccb</span> <span class="o">*</span><span class="p">)</span><span class="n">atio</span><span class="p">);</span>
		<span class="n">atio</span><span class="o">-&gt;</span><span class="n">ccb_h</span><span class="p">.</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">CAM_DIS_DISCONNECT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">xpt_done</span><span class="p">((</span><span class="k">union</span> <span class="n">ccb</span><span class="o">*</span><span class="p">)</span><span class="n">atio</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
