<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › scsi › aic7xxx › aic7xxx.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>aic7xxx.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Core definitions and data structures shareable across OS platforms.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 1994-2001 Justin T. Gibbs.</span>
<span class="cm"> * Copyright (c) 2000-2001 Adaptec Inc.</span>
<span class="cm"> * All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * Redistribution and use in source and binary forms, with or without</span>
<span class="cm"> * modification, are permitted provided that the following conditions</span>
<span class="cm"> * are met:</span>
<span class="cm"> * 1. Redistributions of source code must retain the above copyright</span>
<span class="cm"> *    notice, this list of conditions, and the following disclaimer,</span>
<span class="cm"> *    without modification.</span>
<span class="cm"> * 2. Redistributions in binary form must reproduce at minimum a disclaimer</span>
<span class="cm"> *    substantially similar to the &quot;NO WARRANTY&quot; disclaimer below</span>
<span class="cm"> *    (&quot;Disclaimer&quot;) and any redistribution must be conditioned upon</span>
<span class="cm"> *    including a substantially similar Disclaimer requirement for further</span>
<span class="cm"> *    binary redistribution.</span>
<span class="cm"> * 3. Neither the names of the above-listed copyright holders nor the names</span>
<span class="cm"> *    of any contributors may be used to endorse or promote products derived</span>
<span class="cm"> *    from this software without specific prior written permission.</span>
<span class="cm"> *</span>
<span class="cm"> * Alternatively, this software may be distributed under the terms of the</span>
<span class="cm"> * GNU General Public License (&quot;GPL&quot;) version 2 as published by the Free</span>
<span class="cm"> * Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * NO WARRANTY</span>
<span class="cm"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span>
<span class="cm"> * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span>
<span class="cm"> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR</span>
<span class="cm"> * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</span>
<span class="cm"> * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</span>
<span class="cm"> * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</span>
<span class="cm"> * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</span>
<span class="cm"> * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,</span>
<span class="cm"> * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING</span>
<span class="cm"> * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</span>
<span class="cm"> * POSSIBILITY OF SUCH DAMAGES.</span>
<span class="cm"> *</span>
<span class="cm"> * $Id: //depot/aic7xxx/aic7xxx/aic7xxx.h#85 $</span>
<span class="cm"> *</span>
<span class="cm"> * $FreeBSD$</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _AIC7XXX_H_</span>
<span class="cp">#define _AIC7XXX_H_</span>

<span class="cm">/* Register Definitions */</span>
<span class="cp">#include &quot;aic7xxx_reg.h&quot;</span>

<span class="cm">/************************* Forward Declarations *******************************/</span>
<span class="k">struct</span> <span class="n">ahc_platform_data</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">scb_platform_data</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">seeprom_descriptor</span><span class="p">;</span>

<span class="cm">/****************************** Useful Macros *********************************/</span>
<span class="cp">#ifndef TRUE</span>
<span class="cp">#define TRUE 1</span>
<span class="cp">#endif</span>
<span class="cp">#ifndef FALSE</span>
<span class="cp">#define FALSE 0</span>
<span class="cp">#endif</span>

<span class="cp">#define ALL_CHANNELS &#39;\0&#39;</span>
<span class="cp">#define ALL_TARGETS_MASK 0xFFFF</span>
<span class="cp">#define INITIATOR_WILDCARD	(~0)</span>

<span class="cp">#define SCSIID_TARGET(ahc, scsiid) \</span>
<span class="cp">	(((scsiid) &amp; ((((ahc)-&gt;features &amp; AHC_TWIN) != 0) ? TWIN_TID : TID)) \</span>
<span class="cp">	&gt;&gt; TID_SHIFT)</span>
<span class="cp">#define SCSIID_OUR_ID(scsiid) \</span>
<span class="cp">	((scsiid) &amp; OID)</span>
<span class="cp">#define SCSIID_CHANNEL(ahc, scsiid) \</span>
<span class="cp">	((((ahc)-&gt;features &amp; AHC_TWIN) != 0) \</span>
<span class="cp">        ? ((((scsiid) &amp; TWIN_CHNLB) != 0) ? &#39;B&#39; : &#39;A&#39;) \</span>
<span class="cp">       : &#39;A&#39;)</span>
<span class="cp">#define	SCB_IS_SCSIBUS_B(ahc, scb) \</span>
<span class="cp">	(SCSIID_CHANNEL(ahc, (scb)-&gt;hscb-&gt;scsiid) == &#39;B&#39;)</span>
<span class="cp">#define	SCB_GET_OUR_ID(scb) \</span>
<span class="cp">	SCSIID_OUR_ID((scb)-&gt;hscb-&gt;scsiid)</span>
<span class="cp">#define	SCB_GET_TARGET(ahc, scb) \</span>
<span class="cp">	SCSIID_TARGET((ahc), (scb)-&gt;hscb-&gt;scsiid)</span>
<span class="cp">#define	SCB_GET_CHANNEL(ahc, scb) \</span>
<span class="cp">	SCSIID_CHANNEL(ahc, (scb)-&gt;hscb-&gt;scsiid)</span>
<span class="cp">#define	SCB_GET_LUN(scb) \</span>
<span class="cp">	((scb)-&gt;hscb-&gt;lun &amp; LID)</span>
<span class="cp">#define SCB_GET_TARGET_OFFSET(ahc, scb)	\</span>
<span class="cp">	(SCB_GET_TARGET(ahc, scb) + (SCB_IS_SCSIBUS_B(ahc, scb) ? 8 : 0))</span>
<span class="cp">#define SCB_GET_TARGET_MASK(ahc, scb) \</span>
<span class="cp">	(0x01 &lt;&lt; (SCB_GET_TARGET_OFFSET(ahc, scb)))</span>
<span class="cp">#ifdef AHC_DEBUG</span>
<span class="cp">#define SCB_IS_SILENT(scb)					\</span>
<span class="cp">	((ahc_debug &amp; AHC_SHOW_MASKED_ERRORS) == 0		\</span>
<span class="cp">      &amp;&amp; (((scb)-&gt;flags &amp; SCB_SILENT) != 0))</span>
<span class="cp">#else</span>
<span class="cp">#define SCB_IS_SILENT(scb)					\</span>
<span class="cp">	(((scb)-&gt;flags &amp; SCB_SILENT) != 0)</span>
<span class="cp">#endif</span>
<span class="cp">#define TCL_TARGET_OFFSET(tcl) \</span>
<span class="cp">	((((tcl) &gt;&gt; 4) &amp; TID) &gt;&gt; 4)</span>
<span class="cp">#define TCL_LUN(tcl) \</span>
<span class="cp">	(tcl &amp; (AHC_NUM_LUNS - 1))</span>
<span class="cp">#define BUILD_TCL(scsiid, lun) \</span>
<span class="cp">	((lun) | (((scsiid) &amp; TID) &lt;&lt; 4))</span>

<span class="cp">#ifndef	AHC_TARGET_MODE</span>
<span class="cp">#undef	AHC_TMODE_ENABLE</span>
<span class="cp">#define	AHC_TMODE_ENABLE 0</span>
<span class="cp">#endif</span>

<span class="cm">/**************************** Driver Constants ********************************/</span>
<span class="cm">/*</span>
<span class="cm"> * The maximum number of supported targets.</span>
<span class="cm"> */</span>
<span class="cp">#define AHC_NUM_TARGETS 16</span>

<span class="cm">/*</span>
<span class="cm"> * The maximum number of supported luns.</span>
<span class="cm"> * The identify message only supports 64 luns in SPI3.</span>
<span class="cm"> * You can have 2^64 luns when information unit transfers are enabled,</span>
<span class="cm"> * but it is doubtful this driver will ever support IUTs.</span>
<span class="cm"> */</span>
<span class="cp">#define AHC_NUM_LUNS 64</span>

<span class="cm">/*</span>
<span class="cm"> * The maximum transfer per S/G segment.</span>
<span class="cm"> */</span>
<span class="cp">#define AHC_MAXTRANSFER_SIZE	 0x00ffffff	</span><span class="cm">/* limited by 24bit counter */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * The maximum amount of SCB storage in hardware on a controller.</span>
<span class="cm"> * This value represents an upper bound.  Controllers vary in the number</span>
<span class="cm"> * they actually support.</span>
<span class="cm"> */</span>
<span class="cp">#define AHC_SCB_MAX	255</span>

<span class="cm">/*</span>
<span class="cm"> * The maximum number of concurrent transactions supported per driver instance.</span>
<span class="cm"> * Sequencer Control Blocks (SCBs) store per-transaction information.  Although</span>
<span class="cm"> * the space for SCBs on the host adapter varies by model, the driver will</span>
<span class="cm"> * page the SCBs between host and controller memory as needed.  We are limited</span>
<span class="cm"> * to 253 because:</span>
<span class="cm"> * 	1) The 8bit nature of the RISC engine holds us to an 8bit value.</span>
<span class="cm"> * 	2) We reserve one value, 255, to represent the invalid element.</span>
<span class="cm"> *	3) Our input queue scheme requires one SCB to always be reserved</span>
<span class="cm"> *	   in advance of queuing any SCBs.  This takes us down to 254.</span>
<span class="cm"> *	4) To handle our output queue correctly on machines that only</span>
<span class="cm"> * 	   support 32bit stores, we must clear the array 4 bytes at a</span>
<span class="cm"> *	   time.  To avoid colliding with a DMA write from the sequencer,</span>
<span class="cm"> *	   we must be sure that 4 slots are empty when we write to clear</span>
<span class="cm"> *	   the queue.  This reduces us to 253 SCBs: 1 that just completed</span>
<span class="cm"> *	   and the known three additional empty slots in the queue that</span>
<span class="cm"> *	   precede it.</span>
<span class="cm"> */</span>
<span class="cp">#define AHC_MAX_QUEUE	253</span>

<span class="cm">/*</span>
<span class="cm"> * The maximum amount of SCB storage we allocate in host memory.  This</span>
<span class="cm"> * number should reflect the 1 additional SCB we require to handle our</span>
<span class="cm"> * qinfifo mechanism.</span>
<span class="cm"> */</span>
<span class="cp">#define AHC_SCB_MAX_ALLOC (AHC_MAX_QUEUE+1)</span>

<span class="cm">/*</span>
<span class="cm"> * Ring Buffer of incoming target commands.</span>
<span class="cm"> * We allocate 256 to simplify the logic in the sequencer</span>
<span class="cm"> * by using the natural wrap point of an 8bit counter.</span>
<span class="cm"> */</span>
<span class="cp">#define AHC_TMODE_CMDS	256</span>

<span class="cm">/* Reset line assertion time in us */</span>
<span class="cp">#define AHC_BUSRESET_DELAY	25</span>

<span class="cm">/******************* Chip Characteristics/Operating Settings  *****************/</span>
<span class="cm">/*</span>
<span class="cm"> * Chip Type</span>
<span class="cm"> * The chip order is from least sophisticated to most sophisticated.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
	<span class="n">AHC_NONE</span>	<span class="o">=</span> <span class="mh">0x0000</span><span class="p">,</span>
	<span class="n">AHC_CHIPID_MASK</span>	<span class="o">=</span> <span class="mh">0x00FF</span><span class="p">,</span>
	<span class="n">AHC_AIC7770</span>	<span class="o">=</span> <span class="mh">0x0001</span><span class="p">,</span>
	<span class="n">AHC_AIC7850</span>	<span class="o">=</span> <span class="mh">0x0002</span><span class="p">,</span>
	<span class="n">AHC_AIC7855</span>	<span class="o">=</span> <span class="mh">0x0003</span><span class="p">,</span>
	<span class="n">AHC_AIC7859</span>	<span class="o">=</span> <span class="mh">0x0004</span><span class="p">,</span>
	<span class="n">AHC_AIC7860</span>	<span class="o">=</span> <span class="mh">0x0005</span><span class="p">,</span>
	<span class="n">AHC_AIC7870</span>	<span class="o">=</span> <span class="mh">0x0006</span><span class="p">,</span>
	<span class="n">AHC_AIC7880</span>	<span class="o">=</span> <span class="mh">0x0007</span><span class="p">,</span>
	<span class="n">AHC_AIC7895</span>	<span class="o">=</span> <span class="mh">0x0008</span><span class="p">,</span>
	<span class="n">AHC_AIC7895C</span>	<span class="o">=</span> <span class="mh">0x0009</span><span class="p">,</span>
	<span class="n">AHC_AIC7890</span>	<span class="o">=</span> <span class="mh">0x000a</span><span class="p">,</span>
	<span class="n">AHC_AIC7896</span>	<span class="o">=</span> <span class="mh">0x000b</span><span class="p">,</span>
	<span class="n">AHC_AIC7892</span>	<span class="o">=</span> <span class="mh">0x000c</span><span class="p">,</span>
	<span class="n">AHC_AIC7899</span>	<span class="o">=</span> <span class="mh">0x000d</span><span class="p">,</span>
	<span class="n">AHC_VL</span>		<span class="o">=</span> <span class="mh">0x0100</span><span class="p">,</span>	<span class="cm">/* Bus type VL */</span>
	<span class="n">AHC_EISA</span>	<span class="o">=</span> <span class="mh">0x0200</span><span class="p">,</span>	<span class="cm">/* Bus type EISA */</span>
	<span class="n">AHC_PCI</span>		<span class="o">=</span> <span class="mh">0x0400</span><span class="p">,</span>	<span class="cm">/* Bus type PCI */</span>
	<span class="n">AHC_BUS_MASK</span>	<span class="o">=</span> <span class="mh">0x0F00</span>
<span class="p">}</span> <span class="n">ahc_chip</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Features available in each chip type.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
	<span class="n">AHC_FENONE</span>	<span class="o">=</span> <span class="mh">0x00000</span><span class="p">,</span>
	<span class="n">AHC_ULTRA</span>	<span class="o">=</span> <span class="mh">0x00001</span><span class="p">,</span>	<span class="cm">/* Supports 20MHz Transfers */</span>
	<span class="n">AHC_ULTRA2</span>	<span class="o">=</span> <span class="mh">0x00002</span><span class="p">,</span>	<span class="cm">/* Supports 40MHz Transfers */</span>
	<span class="n">AHC_WIDE</span>  	<span class="o">=</span> <span class="mh">0x00004</span><span class="p">,</span>	<span class="cm">/* Wide Channel */</span>
	<span class="n">AHC_TWIN</span>	<span class="o">=</span> <span class="mh">0x00008</span><span class="p">,</span>	<span class="cm">/* Twin Channel */</span>
	<span class="n">AHC_MORE_SRAM</span>	<span class="o">=</span> <span class="mh">0x00010</span><span class="p">,</span>	<span class="cm">/* 80 bytes instead of 64 */</span>
	<span class="n">AHC_CMD_CHAN</span>	<span class="o">=</span> <span class="mh">0x00020</span><span class="p">,</span>	<span class="cm">/* Has a Command DMA Channel */</span>
	<span class="n">AHC_QUEUE_REGS</span>	<span class="o">=</span> <span class="mh">0x00040</span><span class="p">,</span>	<span class="cm">/* Has Queue management registers */</span>
	<span class="n">AHC_SG_PRELOAD</span>	<span class="o">=</span> <span class="mh">0x00080</span><span class="p">,</span>	<span class="cm">/* Can perform auto-SG preload */</span>
	<span class="n">AHC_SPIOCAP</span>	<span class="o">=</span> <span class="mh">0x00100</span><span class="p">,</span>	<span class="cm">/* Has a Serial Port I/O Cap Register */</span>
	<span class="n">AHC_MULTI_TID</span>	<span class="o">=</span> <span class="mh">0x00200</span><span class="p">,</span>	<span class="cm">/* Has bitmask of TIDs for select-in */</span>
	<span class="n">AHC_HS_MAILBOX</span>	<span class="o">=</span> <span class="mh">0x00400</span><span class="p">,</span>	<span class="cm">/* Has HS_MAILBOX register */</span>
	<span class="n">AHC_DT</span>		<span class="o">=</span> <span class="mh">0x00800</span><span class="p">,</span>	<span class="cm">/* Double Transition transfers */</span>
	<span class="n">AHC_NEW_TERMCTL</span>	<span class="o">=</span> <span class="mh">0x01000</span><span class="p">,</span>	<span class="cm">/* Newer termination scheme */</span>
	<span class="n">AHC_MULTI_FUNC</span>	<span class="o">=</span> <span class="mh">0x02000</span><span class="p">,</span>	<span class="cm">/* Multi-Function Twin Channel Device */</span>
	<span class="n">AHC_LARGE_SCBS</span>	<span class="o">=</span> <span class="mh">0x04000</span><span class="p">,</span>	<span class="cm">/* 64byte SCBs */</span>
	<span class="n">AHC_AUTORATE</span>	<span class="o">=</span> <span class="mh">0x08000</span><span class="p">,</span>	<span class="cm">/* Automatic update of SCSIRATE/OFFSET*/</span>
	<span class="n">AHC_AUTOPAUSE</span>	<span class="o">=</span> <span class="mh">0x10000</span><span class="p">,</span>	<span class="cm">/* Automatic pause on register access */</span>
	<span class="n">AHC_TARGETMODE</span>	<span class="o">=</span> <span class="mh">0x20000</span><span class="p">,</span>	<span class="cm">/* Has tested target mode support */</span>
	<span class="n">AHC_MULTIROLE</span>	<span class="o">=</span> <span class="mh">0x40000</span><span class="p">,</span>	<span class="cm">/* Space for two roles at a time */</span>
	<span class="n">AHC_REMOVABLE</span>	<span class="o">=</span> <span class="mh">0x80000</span><span class="p">,</span>	<span class="cm">/* Hot-Swap supported */</span>
	<span class="n">AHC_HVD</span>		<span class="o">=</span> <span class="mh">0x100000</span><span class="p">,</span>	<span class="cm">/* HVD rather than SE */</span>
	<span class="n">AHC_AIC7770_FE</span>	<span class="o">=</span> <span class="n">AHC_FENONE</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 * The real 7850 does not support Ultra modes, but there are</span>
<span class="cm">	 * several cards that use the generic 7850 PCI ID even though</span>
<span class="cm">	 * they are using an Ultra capable chip (7859/7860).  We start</span>
<span class="cm">	 * out with the AHC_ULTRA feature set and then check the DEVSTATUS</span>
<span class="cm">	 * register to determine if the capability is really present.</span>
<span class="cm">	 */</span>
	<span class="n">AHC_AIC7850_FE</span>	<span class="o">=</span> <span class="n">AHC_SPIOCAP</span><span class="o">|</span><span class="n">AHC_AUTOPAUSE</span><span class="o">|</span><span class="n">AHC_TARGETMODE</span><span class="o">|</span><span class="n">AHC_ULTRA</span><span class="p">,</span>
	<span class="n">AHC_AIC7860_FE</span>	<span class="o">=</span> <span class="n">AHC_AIC7850_FE</span><span class="p">,</span>
	<span class="n">AHC_AIC7870_FE</span>	<span class="o">=</span> <span class="n">AHC_TARGETMODE</span><span class="o">|</span><span class="n">AHC_AUTOPAUSE</span><span class="p">,</span>
	<span class="n">AHC_AIC7880_FE</span>	<span class="o">=</span> <span class="n">AHC_AIC7870_FE</span><span class="o">|</span><span class="n">AHC_ULTRA</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 * Although we have space for both the initiator and</span>
<span class="cm">	 * target roles on ULTRA2 chips, we currently disable</span>
<span class="cm">	 * the initiator role to allow multi-scsi-id target mode</span>
<span class="cm">	 * configurations.  We can only respond on the same SCSI</span>
<span class="cm">	 * ID as our initiator role if we allow initiator operation.</span>
<span class="cm">	 * At some point, we should add a configuration knob to</span>
<span class="cm">	 * allow both roles to be loaded.</span>
<span class="cm">	 */</span>
	<span class="n">AHC_AIC7890_FE</span>	<span class="o">=</span> <span class="n">AHC_MORE_SRAM</span><span class="o">|</span><span class="n">AHC_CMD_CHAN</span><span class="o">|</span><span class="n">AHC_ULTRA2</span>
			  <span class="o">|</span><span class="n">AHC_QUEUE_REGS</span><span class="o">|</span><span class="n">AHC_SG_PRELOAD</span><span class="o">|</span><span class="n">AHC_MULTI_TID</span>
			  <span class="o">|</span><span class="n">AHC_HS_MAILBOX</span><span class="o">|</span><span class="n">AHC_NEW_TERMCTL</span><span class="o">|</span><span class="n">AHC_LARGE_SCBS</span>
			  <span class="o">|</span><span class="n">AHC_TARGETMODE</span><span class="p">,</span>
	<span class="n">AHC_AIC7892_FE</span>	<span class="o">=</span> <span class="n">AHC_AIC7890_FE</span><span class="o">|</span><span class="n">AHC_DT</span><span class="o">|</span><span class="n">AHC_AUTORATE</span><span class="o">|</span><span class="n">AHC_AUTOPAUSE</span><span class="p">,</span>
	<span class="n">AHC_AIC7895_FE</span>	<span class="o">=</span> <span class="n">AHC_AIC7880_FE</span><span class="o">|</span><span class="n">AHC_MORE_SRAM</span><span class="o">|</span><span class="n">AHC_AUTOPAUSE</span>
			  <span class="o">|</span><span class="n">AHC_CMD_CHAN</span><span class="o">|</span><span class="n">AHC_MULTI_FUNC</span><span class="o">|</span><span class="n">AHC_LARGE_SCBS</span><span class="p">,</span>
	<span class="n">AHC_AIC7895C_FE</span>	<span class="o">=</span> <span class="n">AHC_AIC7895_FE</span><span class="o">|</span><span class="n">AHC_MULTI_TID</span><span class="p">,</span>
	<span class="n">AHC_AIC7896_FE</span>	<span class="o">=</span> <span class="n">AHC_AIC7890_FE</span><span class="o">|</span><span class="n">AHC_MULTI_FUNC</span><span class="p">,</span>
	<span class="n">AHC_AIC7899_FE</span>	<span class="o">=</span> <span class="n">AHC_AIC7892_FE</span><span class="o">|</span><span class="n">AHC_MULTI_FUNC</span>
<span class="p">}</span> <span class="n">ahc_feature</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Bugs in the silicon that we work around in software.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
	<span class="n">AHC_BUGNONE</span>		<span class="o">=</span> <span class="mh">0x00</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 * On all chips prior to the U2 product line,</span>
<span class="cm">	 * the WIDEODD S/G segment feature does not</span>
<span class="cm">	 * work during scsi-&gt;HostBus transfers.</span>
<span class="cm">	 */</span>
	<span class="n">AHC_TMODE_WIDEODD_BUG</span>	<span class="o">=</span> <span class="mh">0x01</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 * On the aic7890/91 Rev 0 chips, the autoflush</span>
<span class="cm">	 * feature does not work.  A manual flush of</span>
<span class="cm">	 * the DMA FIFO is required.</span>
<span class="cm">	 */</span>
	<span class="n">AHC_AUTOFLUSH_BUG</span>	<span class="o">=</span> <span class="mh">0x02</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 * On many chips, cacheline streaming does not work.</span>
<span class="cm">	 */</span>
	<span class="n">AHC_CACHETHEN_BUG</span>	<span class="o">=</span> <span class="mh">0x04</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 * On the aic7896/97 chips, cacheline</span>
<span class="cm">	 * streaming must be enabled.</span>
<span class="cm">	 */</span>
	<span class="n">AHC_CACHETHEN_DIS_BUG</span>	<span class="o">=</span> <span class="mh">0x08</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 * PCI 2.1 Retry failure on non-empty data fifo.</span>
<span class="cm">	 */</span>
	<span class="n">AHC_PCI_2_1_RETRY_BUG</span>	<span class="o">=</span> <span class="mh">0x10</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 * Controller does not handle cacheline residuals</span>
<span class="cm">	 * properly on S/G segments if PCI MWI instructions</span>
<span class="cm">	 * are allowed.</span>
<span class="cm">	 */</span>
	<span class="n">AHC_PCI_MWI_BUG</span>		<span class="o">=</span> <span class="mh">0x20</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 * An SCB upload using the SCB channel&#39;s</span>
<span class="cm">	 * auto array entry copy feature may </span>
<span class="cm">	 * corrupt data.  This appears to only</span>
<span class="cm">	 * occur on 66MHz systems.</span>
<span class="cm">	 */</span>
	<span class="n">AHC_SCBCHAN_UPLOAD_BUG</span>	<span class="o">=</span> <span class="mh">0x40</span>
<span class="p">}</span> <span class="n">ahc_bug</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Configuration specific settings.</span>
<span class="cm"> * The driver determines these settings by probing the</span>
<span class="cm"> * chip/controller&#39;s configuration.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
	<span class="n">AHC_FNONE</span>	      <span class="o">=</span> <span class="mh">0x000</span><span class="p">,</span>
	<span class="n">AHC_PRIMARY_CHANNEL</span>   <span class="o">=</span> <span class="mh">0x003</span><span class="p">,</span>  <span class="cm">/*</span>
<span class="cm">					 * The channel that should</span>
<span class="cm">					 * be probed first.</span>
<span class="cm">					 */</span>
	<span class="n">AHC_USEDEFAULTS</span>	      <span class="o">=</span> <span class="mh">0x004</span><span class="p">,</span>  <span class="cm">/*</span>
<span class="cm">					 * For cards without an seeprom</span>
<span class="cm">					 * or a BIOS to initialize the chip&#39;s</span>
<span class="cm">					 * SRAM, we use the default target</span>
<span class="cm">					 * settings.</span>
<span class="cm">					 */</span>
	<span class="n">AHC_SEQUENCER_DEBUG</span>   <span class="o">=</span> <span class="mh">0x008</span><span class="p">,</span>
	<span class="n">AHC_SHARED_SRAM</span>	      <span class="o">=</span> <span class="mh">0x010</span><span class="p">,</span>
	<span class="n">AHC_LARGE_SEEPROM</span>     <span class="o">=</span> <span class="mh">0x020</span><span class="p">,</span>  <span class="cm">/* Uses C56_66 not C46 */</span>
	<span class="n">AHC_RESET_BUS_A</span>	      <span class="o">=</span> <span class="mh">0x040</span><span class="p">,</span>
	<span class="n">AHC_RESET_BUS_B</span>	      <span class="o">=</span> <span class="mh">0x080</span><span class="p">,</span>
	<span class="n">AHC_EXTENDED_TRANS_A</span>  <span class="o">=</span> <span class="mh">0x100</span><span class="p">,</span>
	<span class="n">AHC_EXTENDED_TRANS_B</span>  <span class="o">=</span> <span class="mh">0x200</span><span class="p">,</span>
	<span class="n">AHC_TERM_ENB_A</span>	      <span class="o">=</span> <span class="mh">0x400</span><span class="p">,</span>
	<span class="n">AHC_TERM_ENB_B</span>	      <span class="o">=</span> <span class="mh">0x800</span><span class="p">,</span>
	<span class="n">AHC_INITIATORROLE</span>     <span class="o">=</span> <span class="mh">0x1000</span><span class="p">,</span>  <span class="cm">/*</span>
<span class="cm">					  * Allow initiator operations on</span>
<span class="cm">					  * this controller.</span>
<span class="cm">					  */</span>
	<span class="n">AHC_TARGETROLE</span>	      <span class="o">=</span> <span class="mh">0x2000</span><span class="p">,</span>  <span class="cm">/*</span>
<span class="cm">					  * Allow target operations on this</span>
<span class="cm">					  * controller.</span>
<span class="cm">					  */</span>
	<span class="n">AHC_NEWEEPROM_FMT</span>     <span class="o">=</span> <span class="mh">0x4000</span><span class="p">,</span>
	<span class="n">AHC_TQINFIFO_BLOCKED</span>  <span class="o">=</span> <span class="mh">0x10000</span><span class="p">,</span>  <span class="cm">/* Blocked waiting for ATIOs */</span>
	<span class="n">AHC_INT50_SPEEDFLEX</span>   <span class="o">=</span> <span class="mh">0x20000</span><span class="p">,</span>  <span class="cm">/*</span>
<span class="cm">					   * Internal 50pin connector</span>
<span class="cm">					   * sits behind an aic3860</span>
<span class="cm">					   */</span>
	<span class="n">AHC_SCB_BTT</span>	      <span class="o">=</span> <span class="mh">0x40000</span><span class="p">,</span>  <span class="cm">/*</span>
<span class="cm">					   * The busy targets table is</span>
<span class="cm">					   * stored in SCB space rather</span>
<span class="cm">					   * than SRAM.</span>
<span class="cm">					   */</span>
	<span class="n">AHC_BIOS_ENABLED</span>      <span class="o">=</span> <span class="mh">0x80000</span><span class="p">,</span>
	<span class="n">AHC_ALL_INTERRUPTS</span>    <span class="o">=</span> <span class="mh">0x100000</span><span class="p">,</span>
	<span class="n">AHC_PAGESCBS</span>	      <span class="o">=</span> <span class="mh">0x400000</span><span class="p">,</span>  <span class="cm">/* Enable SCB paging */</span>
	<span class="n">AHC_EDGE_INTERRUPT</span>    <span class="o">=</span> <span class="mh">0x800000</span><span class="p">,</span>  <span class="cm">/* Device uses edge triggered ints */</span>
	<span class="n">AHC_39BIT_ADDRESSING</span>  <span class="o">=</span> <span class="mh">0x1000000</span><span class="p">,</span> <span class="cm">/* Use 39 bit addressing scheme. */</span>
	<span class="n">AHC_LSCBS_ENABLED</span>     <span class="o">=</span> <span class="mh">0x2000000</span><span class="p">,</span> <span class="cm">/* 64Byte SCBs enabled */</span>
	<span class="n">AHC_SCB_CONFIG_USED</span>   <span class="o">=</span> <span class="mh">0x4000000</span><span class="p">,</span> <span class="cm">/* No SEEPROM but SCB2 had info. */</span>
	<span class="n">AHC_NO_BIOS_INIT</span>      <span class="o">=</span> <span class="mh">0x8000000</span><span class="p">,</span> <span class="cm">/* No BIOS left over settings. */</span>
	<span class="n">AHC_DISABLE_PCI_PERR</span>  <span class="o">=</span> <span class="mh">0x10000000</span><span class="p">,</span>
	<span class="n">AHC_HAS_TERM_LOGIC</span>    <span class="o">=</span> <span class="mh">0x20000000</span>
<span class="p">}</span> <span class="n">ahc_flag</span><span class="p">;</span>

<span class="cm">/************************* Hardware  SCB Definition ***************************/</span>

<span class="cm">/*</span>
<span class="cm"> * The driver keeps up to MAX_SCB scb structures per card in memory.  The SCB</span>
<span class="cm"> * consists of a &quot;hardware SCB&quot; mirroring the fields available on the card</span>
<span class="cm"> * and additional information the kernel stores for each transaction.</span>
<span class="cm"> *</span>
<span class="cm"> * To minimize space utilization, a portion of the hardware scb stores</span>
<span class="cm"> * different data during different portions of a SCSI transaction.</span>
<span class="cm"> * As initialized by the host driver for the initiator role, this area</span>
<span class="cm"> * contains the SCSI cdb (or a pointer to the  cdb) to be executed.  After</span>
<span class="cm"> * the cdb has been presented to the target, this area serves to store</span>
<span class="cm"> * residual transfer information and the SCSI status byte.</span>
<span class="cm"> * For the target role, the contents of this area do not change, but</span>
<span class="cm"> * still serve a different purpose than for the initiator role.  See</span>
<span class="cm"> * struct target_data for details.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Status information embedded in the shared poriton of</span>
<span class="cm"> * an SCB after passing the cdb to the target.  The kernel</span>
<span class="cm"> * driver will only read this data for transactions that</span>
<span class="cm"> * complete abnormally (non-zero status byte).</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">status_pkt</span> <span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">residual_datacnt</span><span class="p">;</span>	<span class="cm">/* Residual in the current S/G seg */</span>
	<span class="kt">uint32_t</span> <span class="n">residual_sg_ptr</span><span class="p">;</span>	<span class="cm">/* The next S/G for this transfer */</span>
	<span class="kt">uint8_t</span>	 <span class="n">scsi_status</span><span class="p">;</span>		<span class="cm">/* Standard SCSI status byte */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Target mode version of the shared data SCB segment.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">target_data</span> <span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">residual_datacnt</span><span class="p">;</span>	<span class="cm">/* Residual in the current S/G seg */</span>
	<span class="kt">uint32_t</span> <span class="n">residual_sg_ptr</span><span class="p">;</span>	<span class="cm">/* The next S/G for this transfer */</span>
	<span class="kt">uint8_t</span>  <span class="n">scsi_status</span><span class="p">;</span>		<span class="cm">/* SCSI status to give to initiator */</span>
	<span class="kt">uint8_t</span>  <span class="n">target_phases</span><span class="p">;</span>		<span class="cm">/* Bitmap of phases to execute */</span>
	<span class="kt">uint8_t</span>  <span class="n">data_phase</span><span class="p">;</span>		<span class="cm">/* Data-In or Data-Out */</span>
	<span class="kt">uint8_t</span>  <span class="n">initiator_tag</span><span class="p">;</span>		<span class="cm">/* Initiator&#39;s transaction tag */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">hardware_scb</span> <span class="p">{</span>
<span class="cm">/*0*/</span>	<span class="k">union</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If the cdb is 12 bytes or less, we embed it directly</span>
<span class="cm">		 * in the SCB.  For longer cdbs, we embed the address</span>
<span class="cm">		 * of the cdb payload as seen by the chip and a DMA</span>
<span class="cm">		 * is used to pull it in.</span>
<span class="cm">		 */</span>
		<span class="kt">uint8_t</span>	 <span class="n">cdb</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>
		<span class="kt">uint32_t</span> <span class="n">cdb_ptr</span><span class="p">;</span>
		<span class="k">struct</span>	 <span class="n">status_pkt</span> <span class="n">status</span><span class="p">;</span>
		<span class="k">struct</span>	 <span class="n">target_data</span> <span class="n">tdata</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">shared_data</span><span class="p">;</span>
<span class="cm">/*</span>
<span class="cm"> * A word about residuals.</span>
<span class="cm"> * The scb is presented to the sequencer with the dataptr and datacnt</span>
<span class="cm"> * fields initialized to the contents of the first S/G element to</span>
<span class="cm"> * transfer.  The sgptr field is initialized to the bus address for</span>
<span class="cm"> * the S/G element that follows the first in the in core S/G array</span>
<span class="cm"> * or&#39;ed with the SG_FULL_RESID flag.  Sgptr may point to an invalid</span>
<span class="cm"> * S/G entry for this transfer (single S/G element transfer with the</span>
<span class="cm"> * first elements address and length preloaded in the dataptr/datacnt</span>
<span class="cm"> * fields).  If no transfer is to occur, sgptr is set to SG_LIST_NULL.</span>
<span class="cm"> * The SG_FULL_RESID flag ensures that the residual will be correctly</span>
<span class="cm"> * noted even if no data transfers occur.  Once the data phase is entered,</span>
<span class="cm"> * the residual sgptr and datacnt are loaded from the sgptr and the</span>
<span class="cm"> * datacnt fields.  After each S/G element&#39;s dataptr and length are</span>
<span class="cm"> * loaded into the hardware, the residual sgptr is advanced.  After</span>
<span class="cm"> * each S/G element is expired, its datacnt field is checked to see</span>
<span class="cm"> * if the LAST_SEG flag is set.  If so, SG_LIST_NULL is set in the</span>
<span class="cm"> * residual sg ptr and the transfer is considered complete.  If the</span>
<span class="cm"> * sequencer determines that there is a residual in the tranfer, it</span>
<span class="cm"> * will set the SG_RESID_VALID flag in sgptr and dma the scb back into</span>
<span class="cm"> * host memory.  To sumarize:</span>
<span class="cm"> *</span>
<span class="cm"> * Sequencer:</span>
<span class="cm"> *	o A residual has occurred if SG_FULL_RESID is set in sgptr,</span>
<span class="cm"> *	  or residual_sgptr does not have SG_LIST_NULL set.</span>
<span class="cm"> *</span>
<span class="cm"> *	o We are transferring the last segment if residual_datacnt has</span>
<span class="cm"> *	  the SG_LAST_SEG flag set.</span>
<span class="cm"> *</span>
<span class="cm"> * Host:</span>
<span class="cm"> *	o A residual has occurred if a completed scb has the</span>
<span class="cm"> *	  SG_RESID_VALID flag set.</span>
<span class="cm"> *</span>
<span class="cm"> *	o residual_sgptr and sgptr refer to the &quot;next&quot; sg entry</span>
<span class="cm"> *	  and so may point beyond the last valid sg entry for the</span>
<span class="cm"> *	  transfer.</span>
<span class="cm"> */</span> 
<span class="cm">/*12*/</span>	<span class="kt">uint32_t</span> <span class="n">dataptr</span><span class="p">;</span>
<span class="cm">/*16*/</span>	<span class="kt">uint32_t</span> <span class="n">datacnt</span><span class="p">;</span>		<span class="cm">/*</span>
<span class="cm">					 * Byte 3 (numbered from 0) of</span>
<span class="cm">					 * the datacnt is really the</span>
<span class="cm">					 * 4th byte in that data address.</span>
<span class="cm">					 */</span>
<span class="cm">/*20*/</span>	<span class="kt">uint32_t</span> <span class="n">sgptr</span><span class="p">;</span>
<span class="cp">#define SG_PTR_MASK	0xFFFFFFF8</span>
<span class="cm">/*24*/</span>	<span class="kt">uint8_t</span>  <span class="n">control</span><span class="p">;</span>	<span class="cm">/* See SCB_CONTROL in aic7xxx.reg for details */</span>
<span class="cm">/*25*/</span>	<span class="kt">uint8_t</span>  <span class="n">scsiid</span><span class="p">;</span>	<span class="cm">/* what to load in the SCSIID register */</span>
<span class="cm">/*26*/</span>	<span class="kt">uint8_t</span>  <span class="n">lun</span><span class="p">;</span>
<span class="cm">/*27*/</span>	<span class="kt">uint8_t</span>  <span class="n">tag</span><span class="p">;</span>			<span class="cm">/*</span>
<span class="cm">					 * Index into our kernel SCB array.</span>
<span class="cm">					 * Also used as the tag for tagged I/O</span>
<span class="cm">					 */</span>
<span class="cm">/*28*/</span>	<span class="kt">uint8_t</span>  <span class="n">cdb_len</span><span class="p">;</span>
<span class="cm">/*29*/</span>	<span class="kt">uint8_t</span>  <span class="n">scsirate</span><span class="p">;</span>		<span class="cm">/* Value for SCSIRATE register */</span>
<span class="cm">/*30*/</span>	<span class="kt">uint8_t</span>  <span class="n">scsioffset</span><span class="p">;</span>		<span class="cm">/* Value for SCSIOFFSET register */</span>
<span class="cm">/*31*/</span>	<span class="kt">uint8_t</span>  <span class="n">next</span><span class="p">;</span>			<span class="cm">/*</span>
<span class="cm">					 * Used for threading SCBs in the</span>
<span class="cm">					 * &quot;Waiting for Selection&quot; and</span>
<span class="cm">					 * &quot;Disconnected SCB&quot; lists down</span>
<span class="cm">					 * in the sequencer.</span>
<span class="cm">					 */</span>
<span class="cm">/*32*/</span>	<span class="kt">uint8_t</span>  <span class="n">cdb32</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>		<span class="cm">/*</span>
<span class="cm">					 * CDB storage for cdbs of size</span>
<span class="cm">					 * 13-&gt;32.  We store them here</span>
<span class="cm">					 * because hardware scbs are</span>
<span class="cm">					 * allocated from DMA safe</span>
<span class="cm">					 * memory so we are guaranteed</span>
<span class="cm">					 * the controller can access</span>
<span class="cm">					 * this data.</span>
<span class="cm">					 */</span>
<span class="p">};</span>

<span class="cm">/************************ Kernel SCB Definitions ******************************/</span>
<span class="cm">/*</span>
<span class="cm"> * Some fields of the SCB are OS dependent.  Here we collect the</span>
<span class="cm"> * definitions for elements that all OS platforms need to include</span>
<span class="cm"> * in there SCB definition.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Definition of a scatter/gather element as transferred to the controller.</span>
<span class="cm"> * The aic7xxx chips only support a 24bit length.  We use the top byte of</span>
<span class="cm"> * the length to store additional address bits and a flag to indicate</span>
<span class="cm"> * that a given segment terminates the transfer.  This gives us an</span>
<span class="cm"> * addressable range of 512GB on machines with 64bit PCI or with chips</span>
<span class="cm"> * that can support dual address cycles on 32bit PCI busses.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ahc_dma_seg</span> <span class="p">{</span>
	<span class="kt">uint32_t</span>	<span class="n">addr</span><span class="p">;</span>
	<span class="kt">uint32_t</span>	<span class="n">len</span><span class="p">;</span>
<span class="cp">#define	AHC_DMA_LAST_SEG	0x80000000</span>
<span class="cp">#define	AHC_SG_HIGH_ADDR_MASK	0x7F000000</span>
<span class="cp">#define	AHC_SG_LEN_MASK		0x00FFFFFF</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">sg_map_node</span> <span class="p">{</span>
	<span class="n">bus_dmamap_t</span>		 <span class="n">sg_dmamap</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>		 <span class="n">sg_physaddr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ahc_dma_seg</span><span class="o">*</span>	 <span class="n">sg_vaddr</span><span class="p">;</span>
	<span class="n">SLIST_ENTRY</span><span class="p">(</span><span class="n">sg_map_node</span><span class="p">)</span> <span class="n">links</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * The current state of this SCB.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
	<span class="n">SCB_FREE</span>		<span class="o">=</span> <span class="mh">0x0000</span><span class="p">,</span>
	<span class="n">SCB_OTHERTCL_TIMEOUT</span>	<span class="o">=</span> <span class="mh">0x0002</span><span class="p">,</span><span class="cm">/*</span>
<span class="cm">					  * Another device was active</span>
<span class="cm">					  * during the first timeout for</span>
<span class="cm">					  * this SCB so we gave ourselves</span>
<span class="cm">					  * an additional timeout period</span>
<span class="cm">					  * in case it was hogging the</span>
<span class="cm">					  * bus.</span>
<span class="cm">				          */</span>
	<span class="n">SCB_DEVICE_RESET</span>	<span class="o">=</span> <span class="mh">0x0004</span><span class="p">,</span>
	<span class="n">SCB_SENSE</span>		<span class="o">=</span> <span class="mh">0x0008</span><span class="p">,</span>
	<span class="n">SCB_CDB32_PTR</span>		<span class="o">=</span> <span class="mh">0x0010</span><span class="p">,</span>
	<span class="n">SCB_RECOVERY_SCB</span>	<span class="o">=</span> <span class="mh">0x0020</span><span class="p">,</span>
	<span class="n">SCB_AUTO_NEGOTIATE</span>	<span class="o">=</span> <span class="mh">0x0040</span><span class="p">,</span><span class="cm">/* Negotiate to achieve goal. */</span>
	<span class="n">SCB_NEGOTIATE</span>		<span class="o">=</span> <span class="mh">0x0080</span><span class="p">,</span><span class="cm">/* Negotiation forced for command. */</span>
	<span class="n">SCB_ABORT</span>		<span class="o">=</span> <span class="mh">0x0100</span><span class="p">,</span>
	<span class="n">SCB_UNTAGGEDQ</span>		<span class="o">=</span> <span class="mh">0x0200</span><span class="p">,</span>
	<span class="n">SCB_ACTIVE</span>		<span class="o">=</span> <span class="mh">0x0400</span><span class="p">,</span>
	<span class="n">SCB_TARGET_IMMEDIATE</span>	<span class="o">=</span> <span class="mh">0x0800</span><span class="p">,</span>
	<span class="n">SCB_TRANSMISSION_ERROR</span>	<span class="o">=</span> <span class="mh">0x1000</span><span class="p">,</span><span class="cm">/*</span>
<span class="cm">					  * We detected a parity or CRC</span>
<span class="cm">					  * error that has effected the</span>
<span class="cm">					  * payload of the command.  This</span>
<span class="cm">					  * flag is checked when normal</span>
<span class="cm">					  * status is returned to catch</span>
<span class="cm">					  * the case of a target not</span>
<span class="cm">					  * responding to our attempt</span>
<span class="cm">					  * to report the error.</span>
<span class="cm">					  */</span>
	<span class="n">SCB_TARGET_SCB</span>		<span class="o">=</span> <span class="mh">0x2000</span><span class="p">,</span>
	<span class="n">SCB_SILENT</span>		<span class="o">=</span> <span class="mh">0x4000</span> <span class="cm">/*</span>
<span class="cm">					  * Be quiet about transmission type</span>
<span class="cm">					  * errors.  They are expected and we</span>
<span class="cm">					  * don&#39;t want to upset the user.  This</span>
<span class="cm">					  * flag is typically used during DV.</span>
<span class="cm">					  */</span>
<span class="p">}</span> <span class="n">scb_flag</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">scb</span> <span class="p">{</span>
	<span class="k">struct</span>	<span class="n">hardware_scb</span>	 <span class="o">*</span><span class="n">hscb</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="n">SLIST_ENTRY</span><span class="p">(</span><span class="n">scb</span><span class="p">)</span>  <span class="n">sle</span><span class="p">;</span>
		<span class="n">TAILQ_ENTRY</span><span class="p">(</span><span class="n">scb</span><span class="p">)</span>  <span class="n">tqe</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">links</span><span class="p">;</span>
	<span class="n">LIST_ENTRY</span><span class="p">(</span><span class="n">scb</span><span class="p">)</span>		  <span class="n">pending_links</span><span class="p">;</span>
	<span class="n">ahc_io_ctx_t</span>		  <span class="n">io_ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ahc_softc</span>	 <span class="o">*</span><span class="n">ahc_softc</span><span class="p">;</span>
	<span class="n">scb_flag</span>		  <span class="n">flags</span><span class="p">;</span>
<span class="cp">#ifndef __linux__</span>
	<span class="n">bus_dmamap_t</span>		  <span class="n">dmamap</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">struct</span> <span class="n">scb_platform_data</span> <span class="o">*</span><span class="n">platform_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sg_map_node</span>	 <span class="o">*</span><span class="n">sg_map</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ahc_dma_seg</span> 	 <span class="o">*</span><span class="n">sg_list</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>		  <span class="n">sg_list_phys</span><span class="p">;</span>
	<span class="n">u_int</span>			  <span class="n">sg_count</span><span class="p">;</span><span class="cm">/* How full ahc_dma_seg is */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">scb_data</span> <span class="p">{</span>
	<span class="n">SLIST_HEAD</span><span class="p">(,</span> <span class="n">scb</span><span class="p">)</span> <span class="n">free_scbs</span><span class="p">;</span>	<span class="cm">/*</span>
<span class="cm">					 * Pool of SCBs ready to be assigned</span>
<span class="cm">					 * commands to execute.</span>
<span class="cm">					 */</span>
	<span class="k">struct</span>	<span class="n">scb</span> <span class="o">*</span><span class="n">scbindex</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>	<span class="cm">/*</span>
<span class="cm">					 * Mapping from tag to SCB.</span>
<span class="cm">					 * As tag identifiers are an</span>
<span class="cm">					 * 8bit value, we provide space</span>
<span class="cm">					 * for all possible tag values.</span>
<span class="cm">					 * Any lookups to entries at or</span>
<span class="cm">					 * above AHC_SCB_MAX_ALLOC will</span>
<span class="cm">					 * always fail.</span>
<span class="cm">					 */</span>
	<span class="k">struct</span>	<span class="n">hardware_scb</span>	<span class="o">*</span><span class="n">hscbs</span><span class="p">;</span>	<span class="cm">/* Array of hardware SCBs */</span>
	<span class="k">struct</span>	<span class="n">scb</span> <span class="o">*</span><span class="n">scbarray</span><span class="p">;</span>		<span class="cm">/* Array of kernel SCBs */</span>
	<span class="k">struct</span>	<span class="n">scsi_sense_data</span> <span class="o">*</span><span class="n">sense</span><span class="p">;</span> <span class="cm">/* Per SCB sense data */</span>

	<span class="cm">/*</span>
<span class="cm">	 * &quot;Bus&quot; addresses of our data structures.</span>
<span class="cm">	 */</span>
	<span class="n">bus_dma_tag_t</span>	 <span class="n">hscb_dmat</span><span class="p">;</span>	<span class="cm">/* dmat for our hardware SCB array */</span>
	<span class="n">bus_dmamap_t</span>	 <span class="n">hscb_dmamap</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>	 <span class="n">hscb_busaddr</span><span class="p">;</span>
	<span class="n">bus_dma_tag_t</span>	 <span class="n">sense_dmat</span><span class="p">;</span>
	<span class="n">bus_dmamap_t</span>	 <span class="n">sense_dmamap</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>	 <span class="n">sense_busaddr</span><span class="p">;</span>
	<span class="n">bus_dma_tag_t</span>	 <span class="n">sg_dmat</span><span class="p">;</span>	<span class="cm">/* dmat for our sg segments */</span>
	<span class="n">SLIST_HEAD</span><span class="p">(,</span> <span class="n">sg_map_node</span><span class="p">)</span> <span class="n">sg_maps</span><span class="p">;</span>
	<span class="kt">uint8_t</span>	<span class="n">numscbs</span><span class="p">;</span>
	<span class="kt">uint8_t</span>	<span class="n">maxhscbs</span><span class="p">;</span>		<span class="cm">/* Number of SCBs on the card */</span>
	<span class="kt">uint8_t</span>	<span class="n">init_level</span><span class="p">;</span>		<span class="cm">/*</span>
<span class="cm">					 * How far we&#39;ve initialized</span>
<span class="cm">					 * this structure.</span>
<span class="cm">					 */</span>
<span class="p">};</span>

<span class="cm">/************************ Target Mode Definitions *****************************/</span>

<span class="cm">/*</span>
<span class="cm"> * Connection descriptor for select-in requests in target mode.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">target_cmd</span> <span class="p">{</span>
	<span class="kt">uint8_t</span> <span class="n">scsiid</span><span class="p">;</span>		<span class="cm">/* Our ID and the initiator&#39;s ID */</span>
	<span class="kt">uint8_t</span> <span class="n">identify</span><span class="p">;</span>	<span class="cm">/* Identify message */</span>
	<span class="kt">uint8_t</span> <span class="n">bytes</span><span class="p">[</span><span class="mi">22</span><span class="p">];</span>	<span class="cm">/* </span>
<span class="cm">				 * Bytes contains any additional message</span>
<span class="cm">				 * bytes terminated by 0xFF.  The remainder</span>
<span class="cm">				 * is the cdb to execute.</span>
<span class="cm">				 */</span>
	<span class="kt">uint8_t</span> <span class="n">cmd_valid</span><span class="p">;</span>	<span class="cm">/*</span>
<span class="cm">				 * When a command is complete, the firmware</span>
<span class="cm">				 * will set cmd_valid to all bits set.</span>
<span class="cm">				 * After the host has seen the command,</span>
<span class="cm">				 * the bits are cleared.  This allows us</span>
<span class="cm">				 * to just peek at host memory to determine</span>
<span class="cm">				 * if more work is complete. cmd_valid is on</span>
<span class="cm">				 * an 8 byte boundary to simplify setting</span>
<span class="cm">				 * it on aic7880 hardware which only has</span>
<span class="cm">				 * limited direct access to the DMA FIFO.</span>
<span class="cm">				 */</span>
	<span class="kt">uint8_t</span> <span class="n">pad</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Number of events we can buffer up if we run out</span>
<span class="cm"> * of immediate notify ccbs.</span>
<span class="cm"> */</span>
<span class="cp">#define AHC_TMODE_EVENT_BUFFER_SIZE 8</span>
<span class="k">struct</span> <span class="n">ahc_tmode_event</span> <span class="p">{</span>
	<span class="kt">uint8_t</span> <span class="n">initiator_id</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">event_type</span><span class="p">;</span>	<span class="cm">/* MSG type or EVENT_TYPE_BUS_RESET */</span>
<span class="cp">#define	EVENT_TYPE_BUS_RESET 0xFF</span>
	<span class="kt">uint8_t</span> <span class="n">event_arg</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Per enabled lun target mode state.</span>
<span class="cm"> * As this state is directly influenced by the host OS&#39;es target mode</span>
<span class="cm"> * environment, we let the OS module define it.  Forward declare the</span>
<span class="cm"> * structure here so we can store arrays of them, etc. in OS neutral</span>
<span class="cm"> * data structures.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef AHC_TARGET_MODE </span>
<span class="k">struct</span> <span class="n">ahc_tmode_lstate</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">cam_path</span> <span class="o">*</span><span class="n">path</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ccb_hdr_slist</span> <span class="n">accept_tios</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ccb_hdr_slist</span> <span class="n">immed_notifies</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ahc_tmode_event</span> <span class="n">event_buffer</span><span class="p">[</span><span class="n">AHC_TMODE_EVENT_BUFFER_SIZE</span><span class="p">];</span>
	<span class="kt">uint8_t</span> <span class="n">event_r_idx</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">event_w_idx</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp">#else</span>
<span class="k">struct</span> <span class="n">ahc_tmode_lstate</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cm">/******************** Transfer Negotiation Datastructures *********************/</span>
<span class="cp">#define AHC_TRANS_CUR		0x01	</span><span class="cm">/* Modify current neogtiation status */</span><span class="cp"></span>
<span class="cp">#define AHC_TRANS_ACTIVE	0x03	</span><span class="cm">/* Assume this target is on the bus */</span><span class="cp"></span>
<span class="cp">#define AHC_TRANS_GOAL		0x04	</span><span class="cm">/* Modify negotiation goal */</span><span class="cp"></span>
<span class="cp">#define AHC_TRANS_USER		0x08	</span><span class="cm">/* Modify user negotiation settings */</span><span class="cp"></span>

<span class="cp">#define AHC_WIDTH_UNKNOWN	0xFF</span>
<span class="cp">#define AHC_PERIOD_UNKNOWN	0xFF</span>
<span class="cp">#define AHC_OFFSET_UNKNOWN	0xFF</span>
<span class="cp">#define AHC_PPR_OPTS_UNKNOWN	0xFF</span>

<span class="cm">/*</span>
<span class="cm"> * Transfer Negotiation Information.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ahc_transinfo</span> <span class="p">{</span>
	<span class="kt">uint8_t</span> <span class="n">protocol_version</span><span class="p">;</span>	<span class="cm">/* SCSI Revision level */</span>
	<span class="kt">uint8_t</span> <span class="n">transport_version</span><span class="p">;</span>	<span class="cm">/* SPI Revision level */</span>
	<span class="kt">uint8_t</span> <span class="n">width</span><span class="p">;</span>			<span class="cm">/* Bus width */</span>
	<span class="kt">uint8_t</span> <span class="n">period</span><span class="p">;</span>			<span class="cm">/* Sync rate factor */</span>
	<span class="kt">uint8_t</span> <span class="n">offset</span><span class="p">;</span>			<span class="cm">/* Sync offset */</span>
	<span class="kt">uint8_t</span> <span class="n">ppr_options</span><span class="p">;</span>		<span class="cm">/* Parallel Protocol Request options */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Per-initiator current, goal and user transfer negotiation information. */</span>
<span class="k">struct</span> <span class="n">ahc_initiator_tinfo</span> <span class="p">{</span>
	<span class="kt">uint8_t</span> <span class="n">scsirate</span><span class="p">;</span>		<span class="cm">/* Computed value for SCSIRATE reg */</span>
	<span class="k">struct</span> <span class="n">ahc_transinfo</span> <span class="n">curr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ahc_transinfo</span> <span class="n">goal</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ahc_transinfo</span> <span class="n">user</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Per enabled target ID state.</span>
<span class="cm"> * Pointers to lun target state as well as sync/wide negotiation information</span>
<span class="cm"> * for each initiator&lt;-&gt;target mapping.  For the initiator role we pretend</span>
<span class="cm"> * that we are the target and the targets are the initiators since the</span>
<span class="cm"> * negotiation is the same regardless of role.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ahc_tmode_tstate</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ahc_tmode_lstate</span><span class="o">*</span>	<span class="n">enabled_luns</span><span class="p">[</span><span class="n">AHC_NUM_LUNS</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">ahc_initiator_tinfo</span>	<span class="n">transinfo</span><span class="p">[</span><span class="n">AHC_NUM_TARGETS</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 * Per initiator state bitmasks.</span>
<span class="cm">	 */</span>
	<span class="kt">uint16_t</span>	 <span class="n">auto_negotiate</span><span class="p">;</span><span class="cm">/* Auto Negotiation Required */</span>
	<span class="kt">uint16_t</span>	 <span class="n">ultraenb</span><span class="p">;</span>	<span class="cm">/* Using ultra sync rate  */</span>
	<span class="kt">uint16_t</span>	 <span class="n">discenable</span><span class="p">;</span>	<span class="cm">/* Disconnection allowed  */</span>
	<span class="kt">uint16_t</span>	 <span class="n">tagenable</span><span class="p">;</span>	<span class="cm">/* Tagged Queuing allowed */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Data structure for our table of allowed synchronous transfer rates.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ahc_syncrate</span> <span class="p">{</span>
	<span class="n">u_int</span> <span class="n">sxfr_u2</span><span class="p">;</span>	<span class="cm">/* Value of the SXFR parameter for Ultra2+ Chips */</span>
	<span class="n">u_int</span> <span class="n">sxfr</span><span class="p">;</span>	<span class="cm">/* Value of the SXFR parameter for &lt;= Ultra Chips */</span>
<span class="cp">#define		ULTRA_SXFR 0x100	</span><span class="cm">/* Rate Requires Ultra Mode set */</span><span class="cp"></span>
<span class="cp">#define		ST_SXFR	   0x010	</span><span class="cm">/* Rate Single Transition Only */</span><span class="cp"></span>
<span class="cp">#define		DT_SXFR	   0x040	</span><span class="cm">/* Rate Double Transition Only */</span><span class="cp"></span>
	<span class="kt">uint8_t</span> <span class="n">period</span><span class="p">;</span> <span class="cm">/* Period to send to SCSI target */</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">rate</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Safe and valid period for async negotiations. */</span>
<span class="cp">#define	AHC_ASYNC_XFER_PERIOD 0x45</span>
<span class="cp">#define	AHC_ULTRA2_XFER_PERIOD 0x0a</span>

<span class="cm">/*</span>
<span class="cm"> * Indexes into our table of syncronous transfer rates.</span>
<span class="cm"> */</span>
<span class="cp">#define AHC_SYNCRATE_DT		0</span>
<span class="cp">#define AHC_SYNCRATE_ULTRA2	1</span>
<span class="cp">#define AHC_SYNCRATE_ULTRA	3</span>
<span class="cp">#define AHC_SYNCRATE_FAST	6</span>
<span class="cp">#define AHC_SYNCRATE_MAX	AHC_SYNCRATE_DT</span>
<span class="cp">#define	AHC_SYNCRATE_MIN	13</span>

<span class="cm">/***************************** Lookup Tables **********************************/</span>
<span class="cm">/*</span>
<span class="cm"> * Phase -&gt; name and message out response</span>
<span class="cm"> * to parity errors in each phase table. </span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ahc_phase_table_entry</span> <span class="p">{</span>
        <span class="kt">uint8_t</span> <span class="n">phase</span><span class="p">;</span>
        <span class="kt">uint8_t</span> <span class="n">mesg_out</span><span class="p">;</span> <span class="cm">/* Message response to parity errors */</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">phasemsg</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/************************** Serial EEPROM Format ******************************/</span>

<span class="k">struct</span> <span class="n">seeprom_config</span> <span class="p">{</span>
<span class="cm">/*</span>
<span class="cm"> * Per SCSI ID Configuration Flags</span>
<span class="cm"> */</span>
	<span class="kt">uint16_t</span> <span class="n">device_flags</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>	<span class="cm">/* words 0-15 */</span>
<span class="cp">#define		CFXFER		0x0007	</span><span class="cm">/* synchronous transfer rate */</span><span class="cp"></span>
<span class="cp">#define		CFSYNCH		0x0008	</span><span class="cm">/* enable synchronous transfer */</span><span class="cp"></span>
<span class="cp">#define		CFDISC		0x0010	</span><span class="cm">/* enable disconnection */</span><span class="cp"></span>
<span class="cp">#define		CFWIDEB		0x0020	</span><span class="cm">/* wide bus device */</span><span class="cp"></span>
<span class="cp">#define		CFSYNCHISULTRA	0x0040	</span><span class="cm">/* CFSYNCH is an ultra offset (2940AU)*/</span><span class="cp"></span>
<span class="cp">#define		CFSYNCSINGLE	0x0080	</span><span class="cm">/* Single-Transition signalling */</span><span class="cp"></span>
<span class="cp">#define		CFSTART		0x0100	</span><span class="cm">/* send start unit SCSI command */</span><span class="cp"></span>
<span class="cp">#define		CFINCBIOS	0x0200	</span><span class="cm">/* include in BIOS scan */</span><span class="cp"></span>
<span class="cp">#define		CFRNFOUND	0x0400	</span><span class="cm">/* report even if not found */</span><span class="cp"></span>
<span class="cp">#define		CFMULTILUNDEV	0x0800	</span><span class="cm">/* Probe multiple luns in BIOS scan */</span><span class="cp"></span>
<span class="cp">#define		CFWBCACHEENB	0x4000	</span><span class="cm">/* Enable W-Behind Cache on disks */</span><span class="cp"></span>
<span class="cp">#define		CFWBCACHENOP	0xc000	</span><span class="cm">/* Don&#39;t touch W-Behind Cache */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * BIOS Control Bits</span>
<span class="cm"> */</span>
	<span class="kt">uint16_t</span> <span class="n">bios_control</span><span class="p">;</span>		<span class="cm">/* word 16 */</span>
<span class="cp">#define		CFSUPREM	0x0001	</span><span class="cm">/* support all removeable drives */</span><span class="cp"></span>
<span class="cp">#define		CFSUPREMB	0x0002	</span><span class="cm">/* support removeable boot drives */</span><span class="cp"></span>
<span class="cp">#define		CFBIOSEN	0x0004	</span><span class="cm">/* BIOS enabled */</span><span class="cp"></span>
<span class="cp">#define		CFBIOS_BUSSCAN	0x0008	</span><span class="cm">/* Have the BIOS Scan the Bus */</span><span class="cp"></span>
<span class="cp">#define		CFSM2DRV	0x0010	</span><span class="cm">/* support more than two drives */</span><span class="cp"></span>
<span class="cp">#define		CFSTPWLEVEL	0x0010	</span><span class="cm">/* Termination level control */</span><span class="cp"></span>
<span class="cp">#define		CF284XEXTEND	0x0020	</span><span class="cm">/* extended translation (284x cards) */</span><span class="cp">	</span>
<span class="cp">#define		CFCTRL_A	0x0020	</span><span class="cm">/* BIOS displays Ctrl-A message */</span><span class="cp">	</span>
<span class="cp">#define		CFTERM_MENU	0x0040	</span><span class="cm">/* BIOS displays termination menu */</span><span class="cp">	</span>
<span class="cp">#define		CFEXTEND	0x0080	</span><span class="cm">/* extended translation enabled */</span><span class="cp"></span>
<span class="cp">#define		CFSCAMEN	0x0100	</span><span class="cm">/* SCAM enable */</span><span class="cp"></span>
<span class="cp">#define		CFMSG_LEVEL	0x0600	</span><span class="cm">/* BIOS Message Level */</span><span class="cp"></span>
<span class="cp">#define			CFMSG_VERBOSE	0x0000</span>
<span class="cp">#define			CFMSG_SILENT	0x0200</span>
<span class="cp">#define			CFMSG_DIAG	0x0400</span>
<span class="cp">#define		CFBOOTCD	0x0800  </span><span class="cm">/* Support Bootable CD-ROM */</span><span class="cp"></span>
<span class="cm">/*		UNUSED		0xff00	*/</span>

<span class="cm">/*</span>
<span class="cm"> * Host Adapter Control Bits</span>
<span class="cm"> */</span>
	<span class="kt">uint16_t</span> <span class="n">adapter_control</span><span class="p">;</span>	<span class="cm">/* word 17 */</span>	
<span class="cp">#define		CFAUTOTERM	0x0001	</span><span class="cm">/* Perform Auto termination */</span><span class="cp"></span>
<span class="cp">#define		CFULTRAEN	0x0002	</span><span class="cm">/* Ultra SCSI speed enable */</span><span class="cp"></span>
<span class="cp">#define		CF284XSELTO     0x0003	</span><span class="cm">/* Selection timeout (284x cards) */</span><span class="cp"></span>
<span class="cp">#define		CF284XFIFO      0x000C	</span><span class="cm">/* FIFO Threshold (284x cards) */</span><span class="cp"></span>
<span class="cp">#define		CFSTERM		0x0004	</span><span class="cm">/* SCSI low byte termination */</span><span class="cp"></span>
<span class="cp">#define		CFWSTERM	0x0008	</span><span class="cm">/* SCSI high byte termination */</span><span class="cp"></span>
<span class="cp">#define		CFSPARITY	0x0010	</span><span class="cm">/* SCSI parity */</span><span class="cp"></span>
<span class="cp">#define		CF284XSTERM     0x0020	</span><span class="cm">/* SCSI low byte term (284x cards) */</span><span class="cp">	</span>
<span class="cp">#define		CFMULTILUN	0x0020</span>
<span class="cp">#define		CFRESETB	0x0040	</span><span class="cm">/* reset SCSI bus at boot */</span><span class="cp"></span>
<span class="cp">#define		CFCLUSTERENB	0x0080	</span><span class="cm">/* Cluster Enable */</span><span class="cp"></span>
<span class="cp">#define		CFBOOTCHAN	0x0300	</span><span class="cm">/* probe this channel first */</span><span class="cp"></span>
<span class="cp">#define		CFBOOTCHANSHIFT 8</span>
<span class="cp">#define		CFSEAUTOTERM	0x0400	</span><span class="cm">/* Ultra2 Perform secondary Auto Term*/</span><span class="cp"></span>
<span class="cp">#define		CFSELOWTERM	0x0800	</span><span class="cm">/* Ultra2 secondary low term */</span><span class="cp"></span>
<span class="cp">#define		CFSEHIGHTERM	0x1000	</span><span class="cm">/* Ultra2 secondary high term */</span><span class="cp"></span>
<span class="cp">#define		CFENABLEDV	0x4000	</span><span class="cm">/* Perform Domain Validation*/</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Bus Release Time, Host Adapter ID</span>
<span class="cm"> */</span>
	<span class="kt">uint16_t</span> <span class="n">brtime_id</span><span class="p">;</span>		<span class="cm">/* word 18 */</span>
<span class="cp">#define		CFSCSIID	0x000f	</span><span class="cm">/* host adapter SCSI ID */</span><span class="cp"></span>
<span class="cm">/*		UNUSED		0x00f0	*/</span>
<span class="cp">#define		CFBRTIME	0xff00	</span><span class="cm">/* bus release time */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Maximum targets</span>
<span class="cm"> */</span>
	<span class="kt">uint16_t</span> <span class="n">max_targets</span><span class="p">;</span>		<span class="cm">/* word 19 */</span>	
<span class="cp">#define		CFMAXTARG	0x00ff	</span><span class="cm">/* maximum targets */</span><span class="cp"></span>
<span class="cp">#define		CFBOOTLUN	0x0f00	</span><span class="cm">/* Lun to boot from */</span><span class="cp"></span>
<span class="cp">#define		CFBOOTID	0xf000	</span><span class="cm">/* Target to boot from */</span><span class="cp"></span>
	<span class="kt">uint16_t</span> <span class="n">res_1</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>		<span class="cm">/* words 20-29 */</span>
	<span class="kt">uint16_t</span> <span class="n">signature</span><span class="p">;</span>		<span class="cm">/* Signature == 0x250 */</span>
<span class="cp">#define		CFSIGNATURE	0x250</span>
<span class="cp">#define		CFSIGNATURE2	0x300</span>
	<span class="kt">uint16_t</span> <span class="n">checksum</span><span class="p">;</span>		<span class="cm">/* word 31 */</span>
<span class="p">};</span>

<span class="cm">/****************************  Message Buffer *********************************/</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
	<span class="n">MSG_TYPE_NONE</span>			<span class="o">=</span> <span class="mh">0x00</span><span class="p">,</span>
	<span class="n">MSG_TYPE_INITIATOR_MSGOUT</span>	<span class="o">=</span> <span class="mh">0x01</span><span class="p">,</span>
	<span class="n">MSG_TYPE_INITIATOR_MSGIN</span>	<span class="o">=</span> <span class="mh">0x02</span><span class="p">,</span>
	<span class="n">MSG_TYPE_TARGET_MSGOUT</span>		<span class="o">=</span> <span class="mh">0x03</span><span class="p">,</span>
	<span class="n">MSG_TYPE_TARGET_MSGIN</span>		<span class="o">=</span> <span class="mh">0x04</span>
<span class="p">}</span> <span class="n">ahc_msg_type</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
	<span class="n">MSGLOOP_IN_PROG</span><span class="p">,</span>
	<span class="n">MSGLOOP_MSGCOMPLETE</span><span class="p">,</span>
	<span class="n">MSGLOOP_TERMINATED</span>
<span class="p">}</span> <span class="n">msg_loop_stat</span><span class="p">;</span>

<span class="cm">/*********************** Software Configuration Structure *********************/</span>
<span class="n">TAILQ_HEAD</span><span class="p">(</span><span class="n">scb_tailq</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">ahc_aic7770_softc</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Saved register state used for chip_init().</span>
<span class="cm">	 */</span>
	<span class="kt">uint8_t</span> <span class="n">busspd</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">bustime</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ahc_pci_softc</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Saved register state used for chip_init().</span>
<span class="cm">	 */</span>
	<span class="kt">uint32_t</span>  <span class="n">devconfig</span><span class="p">;</span>
	<span class="kt">uint16_t</span>  <span class="n">targcrccnt</span><span class="p">;</span>
	<span class="kt">uint8_t</span>   <span class="n">command</span><span class="p">;</span>
	<span class="kt">uint8_t</span>   <span class="n">csize_lattime</span><span class="p">;</span>
	<span class="kt">uint8_t</span>   <span class="n">optionmode</span><span class="p">;</span>
	<span class="kt">uint8_t</span>   <span class="n">crccontrol1</span><span class="p">;</span>
	<span class="kt">uint8_t</span>   <span class="n">dscommand0</span><span class="p">;</span>
	<span class="kt">uint8_t</span>   <span class="n">dspcistatus</span><span class="p">;</span>
	<span class="kt">uint8_t</span>   <span class="n">scbbaddr</span><span class="p">;</span>
	<span class="kt">uint8_t</span>   <span class="n">dff_thrsh</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">union</span> <span class="n">ahc_bus_softc</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ahc_aic7770_softc</span> <span class="n">aic7770_softc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ahc_pci_softc</span> <span class="n">pci_softc</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">ahc_bus_intr_t</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ahc_softc</span> <span class="o">*</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">ahc_bus_chip_init_t</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ahc_softc</span> <span class="o">*</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">ahc_bus_suspend_t</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ahc_softc</span> <span class="o">*</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">ahc_bus_resume_t</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ahc_softc</span> <span class="o">*</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="n">ahc_callback_t</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">ahc_softc</span> <span class="p">{</span>
	<span class="n">bus_space_tag_t</span>           <span class="n">tag</span><span class="p">;</span>
	<span class="n">bus_space_handle_t</span>        <span class="n">bsh</span><span class="p">;</span>
<span class="cp">#ifndef __linux__</span>
	<span class="n">bus_dma_tag_t</span>		  <span class="n">buffer_dmat</span><span class="p">;</span>   <span class="cm">/* dmat for buffer I/O */</span>
<span class="cp">#endif</span>
	<span class="k">struct</span> <span class="n">scb_data</span>		 <span class="o">*</span><span class="n">scb_data</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">scb</span>		 <span class="o">*</span><span class="n">next_queued_scb</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * SCBs that have been sent to the controller</span>
<span class="cm">	 */</span>
	<span class="n">LIST_HEAD</span><span class="p">(,</span> <span class="n">scb</span><span class="p">)</span>	  <span class="n">pending_scbs</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Counting lock for deferring the release of additional</span>
<span class="cm">	 * untagged transactions from the untagged_queues.  When</span>
<span class="cm">	 * the lock is decremented to 0, all queues in the</span>
<span class="cm">	 * untagged_queues array are run.</span>
<span class="cm">	 */</span>
	<span class="n">u_int</span>			  <span class="n">untagged_queue_lock</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Per-target queue of untagged-transactions.  The</span>
<span class="cm">	 * transaction at the head of the queue is the</span>
<span class="cm">	 * currently pending untagged transaction for the</span>
<span class="cm">	 * target.  The driver only allows a single untagged</span>
<span class="cm">	 * transaction per target.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">scb_tailq</span>	  <span class="n">untagged_queues</span><span class="p">[</span><span class="n">AHC_NUM_TARGETS</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 * Bus attachment specific data.</span>
<span class="cm">	 */</span>
	<span class="k">union</span> <span class="n">ahc_bus_softc</span>	  <span class="n">bus_softc</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Platform specific data.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">ahc_platform_data</span> <span class="o">*</span><span class="n">platform_data</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Platform specific device information.</span>
<span class="cm">	 */</span>
	<span class="n">ahc_dev_softc_t</span>		  <span class="n">dev_softc</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Bus specific device information.</span>
<span class="cm">	 */</span>
	<span class="n">ahc_bus_intr_t</span>		  <span class="n">bus_intr</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Bus specific initialization required</span>
<span class="cm">	 * after a chip reset.</span>
<span class="cm">	 */</span>
	<span class="n">ahc_bus_chip_init_t</span>	  <span class="n">bus_chip_init</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Target mode related state kept on a per enabled lun basis.</span>
<span class="cm">	 * Targets that are not enabled will have null entries.</span>
<span class="cm">	 * As an initiator, we keep one target entry for our initiator</span>
<span class="cm">	 * ID to store our sync/wide transfer settings.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">ahc_tmode_tstate</span>  <span class="o">*</span><span class="n">enabled_targets</span><span class="p">[</span><span class="n">AHC_NUM_TARGETS</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 * The black hole device responsible for handling requests for</span>
<span class="cm">	 * disabled luns on enabled targets.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">ahc_tmode_lstate</span>  <span class="o">*</span><span class="n">black_hole</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Device instance currently on the bus awaiting a continue TIO</span>
<span class="cm">	 * for a command that was not given the disconnect priveledge.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">ahc_tmode_lstate</span>  <span class="o">*</span><span class="n">pending_device</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Card characteristics</span>
<span class="cm">	 */</span>
	<span class="n">ahc_chip</span>		  <span class="n">chip</span><span class="p">;</span>
	<span class="n">ahc_feature</span>		  <span class="n">features</span><span class="p">;</span>
	<span class="n">ahc_bug</span>			  <span class="n">bugs</span><span class="p">;</span>
	<span class="n">ahc_flag</span>		  <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">seeprom_config</span>	 <span class="o">*</span><span class="n">seep_config</span><span class="p">;</span>

	<span class="cm">/* Values to store in the SEQCTL register for pause and unpause */</span>
	<span class="kt">uint8_t</span>			  <span class="n">unpause</span><span class="p">;</span>
	<span class="kt">uint8_t</span>			  <span class="n">pause</span><span class="p">;</span>

	<span class="cm">/* Command Queues */</span>
	<span class="kt">uint8_t</span>			  <span class="n">qoutfifonext</span><span class="p">;</span>
	<span class="kt">uint8_t</span>			  <span class="n">qinfifonext</span><span class="p">;</span>
	<span class="kt">uint8_t</span>			 <span class="o">*</span><span class="n">qoutfifo</span><span class="p">;</span>
	<span class="kt">uint8_t</span>			 <span class="o">*</span><span class="n">qinfifo</span><span class="p">;</span>

	<span class="cm">/* Critical Section Data */</span>
	<span class="k">struct</span> <span class="n">cs</span>		 <span class="o">*</span><span class="n">critical_sections</span><span class="p">;</span>
	<span class="n">u_int</span>			  <span class="n">num_critical_sections</span><span class="p">;</span>

	<span class="cm">/* Channel Names (&#39;A&#39;, &#39;B&#39;, etc.) */</span>
	<span class="kt">char</span>			  <span class="n">channel</span><span class="p">;</span>
	<span class="kt">char</span>			  <span class="n">channel_b</span><span class="p">;</span>

	<span class="cm">/* Initiator Bus ID */</span>
	<span class="kt">uint8_t</span>			  <span class="n">our_id</span><span class="p">;</span>
	<span class="kt">uint8_t</span>			  <span class="n">our_id_b</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * PCI error detection.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span>			  <span class="n">unsolicited_ints</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Target incoming command FIFO.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">target_cmd</span>	 <span class="o">*</span><span class="n">targetcmds</span><span class="p">;</span>
	<span class="kt">uint8_t</span>			  <span class="n">tqinfifonext</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Cached copy of the sequencer control register.</span>
<span class="cm">	 */</span>
	<span class="kt">uint8_t</span>			  <span class="n">seqctl</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Incoming and outgoing message handling.</span>
<span class="cm">	 */</span>
	<span class="kt">uint8_t</span>			  <span class="n">send_msg_perror</span><span class="p">;</span>
	<span class="n">ahc_msg_type</span>		  <span class="n">msg_type</span><span class="p">;</span>
	<span class="kt">uint8_t</span>			  <span class="n">msgout_buf</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span><span class="cm">/* Message we are sending */</span>
	<span class="kt">uint8_t</span>			  <span class="n">msgin_buf</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span><span class="cm">/* Message we are receiving */</span>
	<span class="n">u_int</span>			  <span class="n">msgout_len</span><span class="p">;</span>	<span class="cm">/* Length of message to send */</span>
	<span class="n">u_int</span>			  <span class="n">msgout_index</span><span class="p">;</span>	<span class="cm">/* Current index in msgout */</span>
	<span class="n">u_int</span>			  <span class="n">msgin_index</span><span class="p">;</span>	<span class="cm">/* Current index in msgin */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Mapping information for data structures shared</span>
<span class="cm">	 * between the sequencer and kernel.</span>
<span class="cm">	 */</span>
	<span class="n">bus_dma_tag_t</span>		  <span class="n">parent_dmat</span><span class="p">;</span>
	<span class="n">bus_dma_tag_t</span>		  <span class="n">shared_data_dmat</span><span class="p">;</span>
	<span class="n">bus_dmamap_t</span>		  <span class="n">shared_data_dmamap</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>		  <span class="n">shared_data_busaddr</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Bus address of the one byte buffer used to</span>
<span class="cm">	 * work-around a DMA bug for chips &lt;= aic7880</span>
<span class="cm">	 * in target mode.</span>
<span class="cm">	 */</span>
	<span class="n">dma_addr_t</span>		  <span class="n">dma_bug_buf</span><span class="p">;</span>

	<span class="cm">/* Number of enabled target mode device on this card */</span>
	<span class="n">u_int</span>			  <span class="n">enabled_luns</span><span class="p">;</span>

	<span class="cm">/* Initialization level of this data structure */</span>
	<span class="n">u_int</span>			  <span class="n">init_level</span><span class="p">;</span>

	<span class="cm">/* PCI cacheline size. */</span>
	<span class="n">u_int</span>			  <span class="n">pci_cachesize</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Count of parity errors we have seen as a target.</span>
<span class="cm">	 * We auto-disable parity error checking after seeing</span>
<span class="cm">	 * AHC_PCI_TARGET_PERR_THRESH number of errors.</span>
<span class="cm">	 */</span>
	<span class="n">u_int</span>			  <span class="n">pci_target_perr_count</span><span class="p">;</span>
<span class="cp">#define		AHC_PCI_TARGET_PERR_THRESH	10</span>

	<span class="cm">/* Maximum number of sequencer instructions supported. */</span>
	<span class="n">u_int</span>			  <span class="n">instruction_ram_size</span><span class="p">;</span>

	<span class="cm">/* Per-Unit descriptive information */</span>
	<span class="k">const</span> <span class="kt">char</span>		 <span class="o">*</span><span class="n">description</span><span class="p">;</span>
	<span class="kt">char</span>			 <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">int</span>			  <span class="n">unit</span><span class="p">;</span>

	<span class="cm">/* Selection Timer settings */</span>
	<span class="kt">int</span>			  <span class="n">seltime</span><span class="p">;</span>
	<span class="kt">int</span>			  <span class="n">seltime_b</span><span class="p">;</span>

	<span class="kt">uint16_t</span>	 	  <span class="n">user_discenable</span><span class="p">;</span><span class="cm">/* Disconnection allowed  */</span>
	<span class="kt">uint16_t</span>		  <span class="n">user_tagenable</span><span class="p">;</span><span class="cm">/* Tagged Queuing allowed */</span>
<span class="p">};</span>

<span class="cm">/************************ Active Device Information ***************************/</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
	<span class="n">ROLE_UNKNOWN</span><span class="p">,</span>
	<span class="n">ROLE_INITIATOR</span><span class="p">,</span>
	<span class="n">ROLE_TARGET</span>
<span class="p">}</span> <span class="n">role_t</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">ahc_devinfo</span> <span class="p">{</span>
	<span class="kt">int</span>	 <span class="n">our_scsiid</span><span class="p">;</span>
	<span class="kt">int</span>	 <span class="n">target_offset</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">target_mask</span><span class="p">;</span>
	<span class="n">u_int</span>	 <span class="n">target</span><span class="p">;</span>
	<span class="n">u_int</span>	 <span class="n">lun</span><span class="p">;</span>
	<span class="kt">char</span>	 <span class="n">channel</span><span class="p">;</span>
	<span class="n">role_t</span>	 <span class="n">role</span><span class="p">;</span>		<span class="cm">/*</span>
<span class="cm">				 * Only guaranteed to be correct if not</span>
<span class="cm">				 * in the busfree state.</span>
<span class="cm">				 */</span>
<span class="p">};</span>

<span class="cm">/****************************** PCI Structures ********************************/</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="p">(</span><span class="n">ahc_device_setup_t</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ahc_softc</span> <span class="o">*</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">ahc_pci_identity</span> <span class="p">{</span>
	<span class="kt">uint64_t</span>		 <span class="n">full_id</span><span class="p">;</span>
	<span class="kt">uint64_t</span>		 <span class="n">id_mask</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span>		<span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="n">ahc_device_setup_t</span>	<span class="o">*</span><span class="n">setup</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/***************************** VL/EISA Declarations ***************************/</span>
<span class="k">struct</span> <span class="n">aic7770_identity</span> <span class="p">{</span>
	<span class="kt">uint32_t</span>		 <span class="n">full_id</span><span class="p">;</span>
	<span class="kt">uint32_t</span>		 <span class="n">id_mask</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span>		<span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="n">ahc_device_setup_t</span>	<span class="o">*</span><span class="n">setup</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">aic7770_identity</span> <span class="n">aic7770_ident_table</span><span class="p">[];</span>
<span class="k">extern</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">ahc_num_aic7770_devs</span><span class="p">;</span>

<span class="cp">#define AHC_EISA_SLOT_OFFSET	0xc00</span>
<span class="cp">#define AHC_EISA_IOSIZE		0x100</span>

<span class="cm">/*************************** Function Declarations ****************************/</span>
<span class="cm">/******************************************************************************/</span>

<span class="cm">/***************************** PCI Front End *********************************/</span>
<span class="k">const</span> <span class="k">struct</span> <span class="n">ahc_pci_identity</span>	<span class="o">*</span><span class="n">ahc_find_pci_device</span><span class="p">(</span><span class="n">ahc_dev_softc_t</span><span class="p">);</span>
<span class="kt">int</span>			 <span class="n">ahc_pci_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahc_softc</span> <span class="o">*</span><span class="p">,</span>
					<span class="k">const</span> <span class="k">struct</span> <span class="n">ahc_pci_identity</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span>			 <span class="n">ahc_pci_test_register_access</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahc_softc</span> <span class="o">*</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_PM</span>
<span class="kt">void</span>			 <span class="n">ahc_pci_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahc_softc</span> <span class="o">*</span><span class="n">ahc</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/*************************** EISA/VL Front End ********************************/</span>
<span class="k">struct</span> <span class="n">aic7770_identity</span> <span class="o">*</span><span class="n">aic7770_find_device</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span>
<span class="kt">int</span>			 <span class="n">aic7770_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahc_softc</span> <span class="o">*</span><span class="n">ahc</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">aic7770_identity</span> <span class="o">*</span><span class="p">,</span>
					<span class="n">u_int</span> <span class="n">port</span><span class="p">);</span>

<span class="cm">/************************** SCB and SCB queue management **********************/</span>
<span class="kt">int</span>		<span class="n">ahc_probe_scbs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahc_softc</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span>		<span class="n">ahc_qinfifo_requeue_tail</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahc_softc</span> <span class="o">*</span><span class="n">ahc</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">scb</span> <span class="o">*</span><span class="n">scb</span><span class="p">);</span>
<span class="kt">int</span>		<span class="n">ahc_match_scb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahc_softc</span> <span class="o">*</span><span class="n">ahc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scb</span> <span class="o">*</span><span class="n">scb</span><span class="p">,</span>
			      <span class="kt">int</span> <span class="n">target</span><span class="p">,</span> <span class="kt">char</span> <span class="n">channel</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lun</span><span class="p">,</span>
			      <span class="n">u_int</span> <span class="n">tag</span><span class="p">,</span> <span class="n">role_t</span> <span class="n">role</span><span class="p">);</span>

<span class="cm">/****************************** Initialization ********************************/</span>
<span class="k">struct</span> <span class="n">ahc_softc</span>	<span class="o">*</span><span class="n">ahc_alloc</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">platform_arg</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>
<span class="kt">int</span>			 <span class="n">ahc_softc_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahc_softc</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span>			 <span class="n">ahc_controller_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahc_softc</span> <span class="o">*</span><span class="n">ahc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>
<span class="kt">int</span>			 <span class="n">ahc_chip_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahc_softc</span> <span class="o">*</span><span class="n">ahc</span><span class="p">);</span>
<span class="kt">int</span>			 <span class="n">ahc_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahc_softc</span> <span class="o">*</span><span class="n">ahc</span><span class="p">);</span>
<span class="kt">void</span>			 <span class="n">ahc_intr_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahc_softc</span> <span class="o">*</span><span class="n">ahc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">enable</span><span class="p">);</span>
<span class="kt">void</span>			 <span class="n">ahc_pause_and_flushwork</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahc_softc</span> <span class="o">*</span><span class="n">ahc</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_PM</span>
<span class="kt">int</span>			 <span class="n">ahc_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahc_softc</span> <span class="o">*</span><span class="n">ahc</span><span class="p">);</span> 
<span class="kt">int</span>			 <span class="n">ahc_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahc_softc</span> <span class="o">*</span><span class="n">ahc</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="kt">void</span>			 <span class="n">ahc_set_unit</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahc_softc</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="kt">void</span>			 <span class="n">ahc_set_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahc_softc</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span>			 <span class="n">ahc_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahc_softc</span> <span class="o">*</span><span class="n">ahc</span><span class="p">);</span>
<span class="kt">int</span>			 <span class="n">ahc_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahc_softc</span> <span class="o">*</span><span class="n">ahc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reinit</span><span class="p">);</span>

<span class="cm">/***************************** Error Recovery *********************************/</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
	<span class="n">SEARCH_COMPLETE</span><span class="p">,</span>
	<span class="n">SEARCH_COUNT</span><span class="p">,</span>
	<span class="n">SEARCH_REMOVE</span>
<span class="p">}</span> <span class="n">ahc_search_action</span><span class="p">;</span>
<span class="kt">int</span>			<span class="n">ahc_search_qinfifo</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahc_softc</span> <span class="o">*</span><span class="n">ahc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">,</span>
					   <span class="kt">char</span> <span class="n">channel</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lun</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">tag</span><span class="p">,</span>
					   <span class="n">role_t</span> <span class="n">role</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">status</span><span class="p">,</span>
					   <span class="n">ahc_search_action</span> <span class="n">action</span><span class="p">);</span>
<span class="kt">int</span>			<span class="n">ahc_search_untagged_queues</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahc_softc</span> <span class="o">*</span><span class="n">ahc</span><span class="p">,</span>
						   <span class="n">ahc_io_ctx_t</span> <span class="n">ctx</span><span class="p">,</span>
						   <span class="kt">int</span> <span class="n">target</span><span class="p">,</span> <span class="kt">char</span> <span class="n">channel</span><span class="p">,</span>
						   <span class="kt">int</span> <span class="n">lun</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">status</span><span class="p">,</span>
						   <span class="n">ahc_search_action</span> <span class="n">action</span><span class="p">);</span>
<span class="kt">int</span>			<span class="n">ahc_search_disc_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahc_softc</span> <span class="o">*</span><span class="n">ahc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">,</span>
					     <span class="kt">char</span> <span class="n">channel</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lun</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">tag</span><span class="p">,</span>
					     <span class="kt">int</span> <span class="n">stop_on_first</span><span class="p">,</span> <span class="kt">int</span> <span class="n">remove</span><span class="p">,</span>
					     <span class="kt">int</span> <span class="n">save_state</span><span class="p">);</span>
<span class="kt">int</span>			<span class="n">ahc_reset_channel</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahc_softc</span> <span class="o">*</span><span class="n">ahc</span><span class="p">,</span> <span class="kt">char</span> <span class="n">channel</span><span class="p">,</span>
					  <span class="kt">int</span> <span class="n">initiate_reset</span><span class="p">);</span>

<span class="cm">/*************************** Utility Functions ********************************/</span>
<span class="kt">void</span>			<span class="n">ahc_compile_devinfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahc_devinfo</span> <span class="o">*</span><span class="n">devinfo</span><span class="p">,</span>
					    <span class="n">u_int</span> <span class="n">our_id</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">target</span><span class="p">,</span>
					    <span class="n">u_int</span> <span class="n">lun</span><span class="p">,</span> <span class="kt">char</span> <span class="n">channel</span><span class="p">,</span>
					    <span class="n">role_t</span> <span class="n">role</span><span class="p">);</span>
<span class="cm">/************************** Transfer Negotiation ******************************/</span>
<span class="k">const</span> <span class="k">struct</span> <span class="n">ahc_syncrate</span><span class="o">*</span>	<span class="n">ahc_find_syncrate</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahc_softc</span> <span class="o">*</span><span class="n">ahc</span><span class="p">,</span> <span class="n">u_int</span> <span class="o">*</span><span class="n">period</span><span class="p">,</span>
					  <span class="n">u_int</span> <span class="o">*</span><span class="n">ppr_options</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">maxsync</span><span class="p">);</span>
<span class="n">u_int</span>			<span class="n">ahc_find_period</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahc_softc</span> <span class="o">*</span><span class="n">ahc</span><span class="p">,</span>
					<span class="n">u_int</span> <span class="n">scsirate</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">maxsync</span><span class="p">);</span>
<span class="cm">/*</span>
<span class="cm"> * Negotiation types.  These are used to qualify if we should renegotiate</span>
<span class="cm"> * even if our goal and current transport parameters are identical.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
	<span class="n">AHC_NEG_TO_GOAL</span><span class="p">,</span>	<span class="cm">/* Renegotiate only if goal and curr differ. */</span>
	<span class="n">AHC_NEG_IF_NON_ASYNC</span><span class="p">,</span>	<span class="cm">/* Renegotiate so long as goal is non-async. */</span>
	<span class="n">AHC_NEG_ALWAYS</span>		<span class="cm">/* Renegotiat even if goal is async. */</span>
<span class="p">}</span> <span class="n">ahc_neg_type</span><span class="p">;</span>
<span class="kt">int</span>			<span class="n">ahc_update_neg_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahc_softc</span><span class="o">*</span><span class="p">,</span>
					       <span class="k">struct</span> <span class="n">ahc_devinfo</span><span class="o">*</span><span class="p">,</span>
					       <span class="k">struct</span> <span class="n">ahc_tmode_tstate</span><span class="o">*</span><span class="p">,</span>
					       <span class="k">struct</span> <span class="n">ahc_initiator_tinfo</span><span class="o">*</span><span class="p">,</span>
					       <span class="n">ahc_neg_type</span><span class="p">);</span>
<span class="kt">void</span>			<span class="n">ahc_set_width</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahc_softc</span> <span class="o">*</span><span class="n">ahc</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">ahc_devinfo</span> <span class="o">*</span><span class="n">devinfo</span><span class="p">,</span>
				      <span class="n">u_int</span> <span class="n">width</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">paused</span><span class="p">);</span>
<span class="kt">void</span>			<span class="n">ahc_set_syncrate</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahc_softc</span> <span class="o">*</span><span class="n">ahc</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">ahc_devinfo</span> <span class="o">*</span><span class="n">devinfo</span><span class="p">,</span>
					 <span class="k">const</span> <span class="k">struct</span> <span class="n">ahc_syncrate</span> <span class="o">*</span><span class="n">syncrate</span><span class="p">,</span>
					 <span class="n">u_int</span> <span class="n">period</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">offset</span><span class="p">,</span>
					 <span class="n">u_int</span> <span class="n">ppr_options</span><span class="p">,</span>
					 <span class="n">u_int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">paused</span><span class="p">);</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
	<span class="n">AHC_QUEUE_NONE</span><span class="p">,</span>
	<span class="n">AHC_QUEUE_BASIC</span><span class="p">,</span>
	<span class="n">AHC_QUEUE_TAGGED</span>
<span class="p">}</span> <span class="n">ahc_queue_alg</span><span class="p">;</span>

<span class="cm">/**************************** Target Mode *************************************/</span>
<span class="cp">#ifdef AHC_TARGET_MODE</span>
<span class="kt">void</span>		<span class="n">ahc_send_lstate_events</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahc_softc</span> <span class="o">*</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">ahc_tmode_lstate</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span>		<span class="n">ahc_handle_en_lun</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahc_softc</span> <span class="o">*</span><span class="n">ahc</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">cam_sim</span> <span class="o">*</span><span class="n">sim</span><span class="p">,</span> <span class="k">union</span> <span class="n">ccb</span> <span class="o">*</span><span class="n">ccb</span><span class="p">);</span>
<span class="n">cam_status</span>	<span class="n">ahc_find_tmode_devs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahc_softc</span> <span class="o">*</span><span class="n">ahc</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">cam_sim</span> <span class="o">*</span><span class="n">sim</span><span class="p">,</span> <span class="k">union</span> <span class="n">ccb</span> <span class="o">*</span><span class="n">ccb</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">ahc_tmode_tstate</span> <span class="o">**</span><span class="n">tstate</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">ahc_tmode_lstate</span> <span class="o">**</span><span class="n">lstate</span><span class="p">,</span>
				    <span class="kt">int</span> <span class="n">notfound_failure</span><span class="p">);</span>
<span class="cp">#ifndef AHC_TMODE_ENABLE</span>
<span class="cp">#define AHC_TMODE_ENABLE 0</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>
<span class="cm">/******************************* Debug ***************************************/</span>
<span class="cp">#ifdef AHC_DEBUG</span>
<span class="k">extern</span> <span class="kt">uint32_t</span> <span class="n">ahc_debug</span><span class="p">;</span>
<span class="cp">#define	AHC_SHOW_MISC		0x0001</span>
<span class="cp">#define	AHC_SHOW_SENSE		0x0002</span>
<span class="cp">#define AHC_DUMP_SEEPROM	0x0004</span>
<span class="cp">#define AHC_SHOW_TERMCTL	0x0008</span>
<span class="cp">#define AHC_SHOW_MEMORY		0x0010</span>
<span class="cp">#define AHC_SHOW_MESSAGES	0x0020</span>
<span class="cp">#define	AHC_SHOW_DV		0x0040</span>
<span class="cp">#define AHC_SHOW_SELTO		0x0080</span>
<span class="cp">#define AHC_SHOW_QFULL		0x0200</span>
<span class="cp">#define AHC_SHOW_QUEUE		0x0400</span>
<span class="cp">#define AHC_SHOW_TQIN		0x0800</span>
<span class="cp">#define AHC_SHOW_MASKED_ERRORS	0x1000</span>
<span class="cp">#define AHC_DEBUG_SEQUENCER	0x2000</span>
<span class="cp">#endif</span>
<span class="kt">void</span>			<span class="n">ahc_print_devinfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahc_softc</span> <span class="o">*</span><span class="n">ahc</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">ahc_devinfo</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">void</span>			<span class="n">ahc_dump_card_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahc_softc</span> <span class="o">*</span><span class="n">ahc</span><span class="p">);</span>
<span class="kt">int</span>			<span class="n">ahc_print_register</span><span class="p">(</span><span class="k">const</span> <span class="n">ahc_reg_parse_entry_t</span> <span class="o">*</span><span class="n">table</span><span class="p">,</span>
					   <span class="n">u_int</span> <span class="n">num_entries</span><span class="p">,</span>
					   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
					   <span class="n">u_int</span> <span class="n">address</span><span class="p">,</span>
					   <span class="n">u_int</span> <span class="n">value</span><span class="p">,</span>
					   <span class="n">u_int</span> <span class="o">*</span><span class="n">cur_column</span><span class="p">,</span>
					   <span class="n">u_int</span> <span class="n">wrap_point</span><span class="p">);</span>
<span class="cm">/******************************* SEEPROM *************************************/</span>
<span class="kt">int</span>		<span class="n">ahc_acquire_seeprom</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahc_softc</span> <span class="o">*</span><span class="n">ahc</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">seeprom_descriptor</span> <span class="o">*</span><span class="n">sd</span><span class="p">);</span>
<span class="kt">void</span>		<span class="n">ahc_release_seeprom</span><span class="p">(</span><span class="k">struct</span> <span class="n">seeprom_descriptor</span> <span class="o">*</span><span class="n">sd</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* _AIC7XXX_H_ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
