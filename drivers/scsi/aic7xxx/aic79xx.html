<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › scsi › aic7xxx › aic79xx.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>aic79xx.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Core definitions and data structures shareable across OS platforms.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 1994-2002 Justin T. Gibbs.</span>
<span class="cm"> * Copyright (c) 2000-2002 Adaptec Inc.</span>
<span class="cm"> * All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * Redistribution and use in source and binary forms, with or without</span>
<span class="cm"> * modification, are permitted provided that the following conditions</span>
<span class="cm"> * are met:</span>
<span class="cm"> * 1. Redistributions of source code must retain the above copyright</span>
<span class="cm"> *    notice, this list of conditions, and the following disclaimer,</span>
<span class="cm"> *    without modification.</span>
<span class="cm"> * 2. Redistributions in binary form must reproduce at minimum a disclaimer</span>
<span class="cm"> *    substantially similar to the &quot;NO WARRANTY&quot; disclaimer below</span>
<span class="cm"> *    (&quot;Disclaimer&quot;) and any redistribution must be conditioned upon</span>
<span class="cm"> *    including a substantially similar Disclaimer requirement for further</span>
<span class="cm"> *    binary redistribution.</span>
<span class="cm"> * 3. Neither the names of the above-listed copyright holders nor the names</span>
<span class="cm"> *    of any contributors may be used to endorse or promote products derived</span>
<span class="cm"> *    from this software without specific prior written permission.</span>
<span class="cm"> *</span>
<span class="cm"> * Alternatively, this software may be distributed under the terms of the</span>
<span class="cm"> * GNU General Public License (&quot;GPL&quot;) version 2 as published by the Free</span>
<span class="cm"> * Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * NO WARRANTY</span>
<span class="cm"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span>
<span class="cm"> * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span>
<span class="cm"> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR</span>
<span class="cm"> * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</span>
<span class="cm"> * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</span>
<span class="cm"> * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</span>
<span class="cm"> * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</span>
<span class="cm"> * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,</span>
<span class="cm"> * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING</span>
<span class="cm"> * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</span>
<span class="cm"> * POSSIBILITY OF SUCH DAMAGES.</span>
<span class="cm"> *</span>
<span class="cm"> * $Id: //depot/aic7xxx/aic7xxx/aic79xx.h#109 $</span>
<span class="cm"> *</span>
<span class="cm"> * $FreeBSD$</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _AIC79XX_H_</span>
<span class="cp">#define _AIC79XX_H_</span>

<span class="cm">/* Register Definitions */</span>
<span class="cp">#include &quot;aic79xx_reg.h&quot;</span>

<span class="cm">/************************* Forward Declarations *******************************/</span>
<span class="k">struct</span> <span class="n">ahd_platform_data</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">scb_platform_data</span><span class="p">;</span>

<span class="cm">/****************************** Useful Macros *********************************/</span>
<span class="cp">#ifndef TRUE</span>
<span class="cp">#define TRUE 1</span>
<span class="cp">#endif</span>
<span class="cp">#ifndef FALSE</span>
<span class="cp">#define FALSE 0</span>
<span class="cp">#endif</span>

<span class="cp">#define ALL_CHANNELS &#39;\0&#39;</span>
<span class="cp">#define ALL_TARGETS_MASK 0xFFFF</span>
<span class="cp">#define INITIATOR_WILDCARD	(~0)</span>
<span class="cp">#define	SCB_LIST_NULL		0xFF00</span>
<span class="cp">#define	SCB_LIST_NULL_LE	(ahd_htole16(SCB_LIST_NULL))</span>
<span class="cp">#define QOUTFIFO_ENTRY_VALID 0x80</span>
<span class="cp">#define SCBID_IS_NULL(scbid) (((scbid) &amp; 0xFF00 ) == SCB_LIST_NULL)</span>

<span class="cp">#define SCSIID_TARGET(ahd, scsiid)	\</span>
<span class="cp">	(((scsiid) &amp; TID) &gt;&gt; TID_SHIFT)</span>
<span class="cp">#define SCSIID_OUR_ID(scsiid)		\</span>
<span class="cp">	((scsiid) &amp; OID)</span>
<span class="cp">#define SCSIID_CHANNEL(ahd, scsiid) (&#39;A&#39;)</span>
<span class="cp">#define	SCB_IS_SCSIBUS_B(ahd, scb) (0)</span>
<span class="cp">#define	SCB_GET_OUR_ID(scb) \</span>
<span class="cp">	SCSIID_OUR_ID((scb)-&gt;hscb-&gt;scsiid)</span>
<span class="cp">#define	SCB_GET_TARGET(ahd, scb) \</span>
<span class="cp">	SCSIID_TARGET((ahd), (scb)-&gt;hscb-&gt;scsiid)</span>
<span class="cp">#define	SCB_GET_CHANNEL(ahd, scb) \</span>
<span class="cp">	SCSIID_CHANNEL(ahd, (scb)-&gt;hscb-&gt;scsiid)</span>
<span class="cp">#define	SCB_GET_LUN(scb) \</span>
<span class="cp">	((scb)-&gt;hscb-&gt;lun)</span>
<span class="cp">#define SCB_GET_TARGET_OFFSET(ahd, scb)	\</span>
<span class="cp">	SCB_GET_TARGET(ahd, scb)</span>
<span class="cp">#define SCB_GET_TARGET_MASK(ahd, scb) \</span>
<span class="cp">	(0x01 &lt;&lt; (SCB_GET_TARGET_OFFSET(ahd, scb)))</span>
<span class="cp">#ifdef AHD_DEBUG</span>
<span class="cp">#define SCB_IS_SILENT(scb)					\</span>
<span class="cp">	((ahd_debug &amp; AHD_SHOW_MASKED_ERRORS) == 0		\</span>
<span class="cp">      &amp;&amp; (((scb)-&gt;flags &amp; SCB_SILENT) != 0))</span>
<span class="cp">#else</span>
<span class="cp">#define SCB_IS_SILENT(scb)					\</span>
<span class="cp">	(((scb)-&gt;flags &amp; SCB_SILENT) != 0)</span>
<span class="cp">#endif</span>
<span class="cm">/*</span>
<span class="cm"> * TCLs have the following format: TTTTLLLLLLLL</span>
<span class="cm"> */</span>
<span class="cp">#define TCL_TARGET_OFFSET(tcl) \</span>
<span class="cp">	((((tcl) &gt;&gt; 4) &amp; TID) &gt;&gt; 4)</span>
<span class="cp">#define TCL_LUN(tcl) \</span>
<span class="cp">	(tcl &amp; (AHD_NUM_LUNS - 1))</span>
<span class="cp">#define BUILD_TCL(scsiid, lun) \</span>
<span class="cp">	((lun) | (((scsiid) &amp; TID) &lt;&lt; 4))</span>
<span class="cp">#define BUILD_TCL_RAW(target, channel, lun) \</span>
<span class="cp">	((lun) | ((target) &lt;&lt; 8))</span>

<span class="cp">#define SCB_GET_TAG(scb) \</span>
<span class="cp">	ahd_le16toh(scb-&gt;hscb-&gt;tag)</span>

<span class="cp">#ifndef	AHD_TARGET_MODE</span>
<span class="cp">#undef	AHD_TMODE_ENABLE</span>
<span class="cp">#define	AHD_TMODE_ENABLE 0</span>
<span class="cp">#endif</span>

<span class="cp">#define AHD_BUILD_COL_IDX(target, lun)				\</span>
<span class="cp">	(((lun) &lt;&lt; 4) | target)</span>

<span class="cp">#define AHD_GET_SCB_COL_IDX(ahd, scb)				\</span>
<span class="cp">	((SCB_GET_LUN(scb) &lt;&lt; 4) | SCB_GET_TARGET(ahd, scb))</span>

<span class="cp">#define AHD_SET_SCB_COL_IDX(scb, col_idx)				\</span>
<span class="cp">do {									\</span>
<span class="cp">	(scb)-&gt;hscb-&gt;scsiid = ((col_idx) &lt;&lt; TID_SHIFT) &amp; TID;		\</span>
<span class="cp">	(scb)-&gt;hscb-&gt;lun = ((col_idx) &gt;&gt; 4) &amp; (AHD_NUM_LUNS_NONPKT-1);	\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define AHD_COPY_SCB_COL_IDX(dst, src)				\</span>
<span class="cp">do {								\</span>
<span class="cp">	dst-&gt;hscb-&gt;scsiid = src-&gt;hscb-&gt;scsiid;			\</span>
<span class="cp">	dst-&gt;hscb-&gt;lun = src-&gt;hscb-&gt;lun;			\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define	AHD_NEVER_COL_IDX 0xFFFF</span>

<span class="cm">/**************************** Driver Constants ********************************/</span>
<span class="cm">/*</span>
<span class="cm"> * The maximum number of supported targets.</span>
<span class="cm"> */</span>
<span class="cp">#define AHD_NUM_TARGETS 16</span>

<span class="cm">/*</span>
<span class="cm"> * The maximum number of supported luns.</span>
<span class="cm"> * The identify message only supports 64 luns in non-packetized transfers.</span>
<span class="cm"> * You can have 2^64 luns when information unit transfers are enabled,</span>
<span class="cm"> * but until we see a need to support that many, we support 256.</span>
<span class="cm"> */</span>
<span class="cp">#define AHD_NUM_LUNS_NONPKT 64</span>
<span class="cp">#define AHD_NUM_LUNS 256</span>

<span class="cm">/*</span>
<span class="cm"> * The maximum transfer per S/G segment.</span>
<span class="cm"> */</span>
<span class="cp">#define AHD_MAXTRANSFER_SIZE	 0x00ffffff	</span><span class="cm">/* limited by 24bit counter */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * The maximum amount of SCB storage in hardware on a controller.</span>
<span class="cm"> * This value represents an upper bound.  Due to software design,</span>
<span class="cm"> * we may not be able to use this number.</span>
<span class="cm"> */</span>
<span class="cp">#define AHD_SCB_MAX	512</span>

<span class="cm">/*</span>
<span class="cm"> * The maximum number of concurrent transactions supported per driver instance.</span>
<span class="cm"> * Sequencer Control Blocks (SCBs) store per-transaction information.</span>
<span class="cm"> */</span>
<span class="cp">#define AHD_MAX_QUEUE	AHD_SCB_MAX</span>

<span class="cm">/*</span>
<span class="cm"> * Define the size of our QIN and QOUT FIFOs.  They must be a power of 2</span>
<span class="cm"> * in size and accommodate as many transactions as can be queued concurrently.</span>
<span class="cm"> */</span>
<span class="cp">#define	AHD_QIN_SIZE	AHD_MAX_QUEUE</span>
<span class="cp">#define	AHD_QOUT_SIZE	AHD_MAX_QUEUE</span>

<span class="cp">#define AHD_QIN_WRAP(x) ((x) &amp; (AHD_QIN_SIZE-1))</span>
<span class="cm">/*</span>
<span class="cm"> * The maximum amount of SCB storage we allocate in host memory.</span>
<span class="cm"> */</span>
<span class="cp">#define AHD_SCB_MAX_ALLOC AHD_MAX_QUEUE</span>

<span class="cm">/*</span>
<span class="cm"> * Ring Buffer of incoming target commands.</span>
<span class="cm"> * We allocate 256 to simplify the logic in the sequencer</span>
<span class="cm"> * by using the natural wrap point of an 8bit counter.</span>
<span class="cm"> */</span>
<span class="cp">#define AHD_TMODE_CMDS	256</span>

<span class="cm">/* Reset line assertion time in us */</span>
<span class="cp">#define AHD_BUSRESET_DELAY	25</span>

<span class="cm">/******************* Chip Characteristics/Operating Settings  *****************/</span>
<span class="cm">/*</span>
<span class="cm"> * Chip Type</span>
<span class="cm"> * The chip order is from least sophisticated to most sophisticated.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
	<span class="n">AHD_NONE</span>	<span class="o">=</span> <span class="mh">0x0000</span><span class="p">,</span>
	<span class="n">AHD_CHIPID_MASK</span>	<span class="o">=</span> <span class="mh">0x00FF</span><span class="p">,</span>
	<span class="n">AHD_AIC7901</span>	<span class="o">=</span> <span class="mh">0x0001</span><span class="p">,</span>
	<span class="n">AHD_AIC7902</span>	<span class="o">=</span> <span class="mh">0x0002</span><span class="p">,</span>
	<span class="n">AHD_AIC7901A</span>	<span class="o">=</span> <span class="mh">0x0003</span><span class="p">,</span>
	<span class="n">AHD_PCI</span>		<span class="o">=</span> <span class="mh">0x0100</span><span class="p">,</span>	<span class="cm">/* Bus type PCI */</span>
	<span class="n">AHD_PCIX</span>	<span class="o">=</span> <span class="mh">0x0200</span><span class="p">,</span>	<span class="cm">/* Bus type PCIX */</span>
	<span class="n">AHD_BUS_MASK</span>	<span class="o">=</span> <span class="mh">0x0F00</span>
<span class="p">}</span> <span class="n">ahd_chip</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Features available in each chip type.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
	<span class="n">AHD_FENONE</span>		<span class="o">=</span> <span class="mh">0x00000</span><span class="p">,</span>
	<span class="n">AHD_WIDE</span>  		<span class="o">=</span> <span class="mh">0x00001</span><span class="p">,</span><span class="cm">/* Wide Channel */</span>
	<span class="n">AHD_AIC79XXB_SLOWCRC</span>    <span class="o">=</span> <span class="mh">0x00002</span><span class="p">,</span><span class="cm">/* SLOWCRC bit should be set */</span>
	<span class="n">AHD_MULTI_FUNC</span>		<span class="o">=</span> <span class="mh">0x00100</span><span class="p">,</span><span class="cm">/* Multi-Function/Channel Device */</span>
	<span class="n">AHD_TARGETMODE</span>		<span class="o">=</span> <span class="mh">0x01000</span><span class="p">,</span><span class="cm">/* Has tested target mode support */</span>
	<span class="n">AHD_MULTIROLE</span>		<span class="o">=</span> <span class="mh">0x02000</span><span class="p">,</span><span class="cm">/* Space for two roles at a time */</span>
	<span class="n">AHD_RTI</span>			<span class="o">=</span> <span class="mh">0x04000</span><span class="p">,</span><span class="cm">/* Retained Training Support */</span>
	<span class="n">AHD_NEW_IOCELL_OPTS</span>	<span class="o">=</span> <span class="mh">0x08000</span><span class="p">,</span><span class="cm">/* More Signal knobs in the IOCELL */</span>
	<span class="n">AHD_NEW_DFCNTRL_OPTS</span>	<span class="o">=</span> <span class="mh">0x10000</span><span class="p">,</span><span class="cm">/* SCSIENWRDIS bit */</span>
	<span class="n">AHD_FAST_CDB_DELIVERY</span>	<span class="o">=</span> <span class="mh">0x20000</span><span class="p">,</span><span class="cm">/* CDB acks released to Output Sync */</span>
	<span class="n">AHD_REMOVABLE</span>		<span class="o">=</span> <span class="mh">0x00000</span><span class="p">,</span><span class="cm">/* Hot-Swap supported - None so far*/</span>
	<span class="n">AHD_AIC7901_FE</span>		<span class="o">=</span> <span class="n">AHD_FENONE</span><span class="p">,</span>
	<span class="n">AHD_AIC7901A_FE</span>		<span class="o">=</span> <span class="n">AHD_FENONE</span><span class="p">,</span>
	<span class="n">AHD_AIC7902_FE</span>		<span class="o">=</span> <span class="n">AHD_MULTI_FUNC</span>
<span class="p">}</span> <span class="n">ahd_feature</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Bugs in the silicon that we work around in software.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
	<span class="n">AHD_BUGNONE</span>		<span class="o">=</span> <span class="mh">0x0000</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 * Rev A hardware fails to update LAST/CURR/NEXTSCB</span>
<span class="cm">	 * correctly in certain packetized selection cases.</span>
<span class="cm">	 */</span>
	<span class="n">AHD_SENT_SCB_UPDATE_BUG</span>	<span class="o">=</span> <span class="mh">0x0001</span><span class="p">,</span>
	<span class="cm">/* The wrong SCB is accessed to check the abort pending bit. */</span>
	<span class="n">AHD_ABORT_LQI_BUG</span>	<span class="o">=</span> <span class="mh">0x0002</span><span class="p">,</span>
	<span class="cm">/* Packetized bitbucket crosses packet boundaries. */</span>
	<span class="n">AHD_PKT_BITBUCKET_BUG</span>	<span class="o">=</span> <span class="mh">0x0004</span><span class="p">,</span>
	<span class="cm">/* The selection timer runs twice as long as its setting. */</span>
	<span class="n">AHD_LONG_SETIMO_BUG</span>	<span class="o">=</span> <span class="mh">0x0008</span><span class="p">,</span>
	<span class="cm">/* The Non-LQ CRC error status is delayed until phase change. */</span>
	<span class="n">AHD_NLQICRC_DELAYED_BUG</span>	<span class="o">=</span> <span class="mh">0x0010</span><span class="p">,</span>
	<span class="cm">/* The chip must be reset for all outgoing bus resets.  */</span>
	<span class="n">AHD_SCSIRST_BUG</span>		<span class="o">=</span> <span class="mh">0x0020</span><span class="p">,</span>
	<span class="cm">/* Some PCIX fields must be saved and restored across chip reset. */</span>
	<span class="n">AHD_PCIX_CHIPRST_BUG</span>	<span class="o">=</span> <span class="mh">0x0040</span><span class="p">,</span>
	<span class="cm">/* MMAPIO is not functional in PCI-X mode.  */</span>
	<span class="n">AHD_PCIX_MMAPIO_BUG</span>	<span class="o">=</span> <span class="mh">0x0080</span><span class="p">,</span>
	<span class="cm">/* Reads to SCBRAM fail to reset the discard timer. */</span>
	<span class="n">AHD_PCIX_SCBRAM_RD_BUG</span>  <span class="o">=</span> <span class="mh">0x0100</span><span class="p">,</span>
	<span class="cm">/* Bug workarounds that can be disabled on non-PCIX busses. */</span>
	<span class="n">AHD_PCIX_BUG_MASK</span>	<span class="o">=</span> <span class="n">AHD_PCIX_CHIPRST_BUG</span>
				<span class="o">|</span> <span class="n">AHD_PCIX_MMAPIO_BUG</span>
				<span class="o">|</span> <span class="n">AHD_PCIX_SCBRAM_RD_BUG</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 * LQOSTOP0 status set even for forced selections with ATN</span>
<span class="cm">	 * to perform non-packetized message delivery.</span>
<span class="cm">	 */</span>
	<span class="n">AHD_LQO_ATNO_BUG</span>	<span class="o">=</span> <span class="mh">0x0200</span><span class="p">,</span>
	<span class="cm">/* FIFO auto-flush does not always trigger.  */</span>
	<span class="n">AHD_AUTOFLUSH_BUG</span>	<span class="o">=</span> <span class="mh">0x0400</span><span class="p">,</span>
	<span class="cm">/* The CLRLQO registers are not self-clearing. */</span>
	<span class="n">AHD_CLRLQO_AUTOCLR_BUG</span>	<span class="o">=</span> <span class="mh">0x0800</span><span class="p">,</span>
	<span class="cm">/* The PACKETIZED status bit refers to the previous connection. */</span>
	<span class="n">AHD_PKTIZED_STATUS_BUG</span>  <span class="o">=</span> <span class="mh">0x1000</span><span class="p">,</span>
	<span class="cm">/* &quot;Short Luns&quot; are not placed into outgoing LQ packets correctly. */</span>
	<span class="n">AHD_PKT_LUN_BUG</span>		<span class="o">=</span> <span class="mh">0x2000</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 * Only the FIFO allocated to the non-packetized connection may</span>
<span class="cm">	 * be in use during a non-packetzied connection.</span>
<span class="cm">	 */</span>
	<span class="n">AHD_NONPACKFIFO_BUG</span>	<span class="o">=</span> <span class="mh">0x4000</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 * Writing to a DFF SCBPTR register may fail if concurent with</span>
<span class="cm">	 * a hardware write to the other DFF SCBPTR register.  This is</span>
<span class="cm">	 * not currently a concern in our sequencer since all chips with</span>
<span class="cm">	 * this bug have the AHD_NONPACKFIFO_BUG and all writes of concern</span>
<span class="cm">	 * occur in non-packetized connections.</span>
<span class="cm">	 */</span>
	<span class="n">AHD_MDFF_WSCBPTR_BUG</span>	<span class="o">=</span> <span class="mh">0x8000</span><span class="p">,</span>
	<span class="cm">/* SGHADDR updates are slow. */</span>
	<span class="n">AHD_REG_SLOW_SETTLE_BUG</span>	<span class="o">=</span> <span class="mh">0x10000</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 * Changing the MODE_PTR coincident with an interrupt that</span>
<span class="cm">	 * switches to a different mode will cause the interrupt to</span>
<span class="cm">	 * be in the mode written outside of interrupt context.</span>
<span class="cm">	 */</span>
	<span class="n">AHD_SET_MODE_BUG</span>	<span class="o">=</span> <span class="mh">0x20000</span><span class="p">,</span>
	<span class="cm">/* Non-packetized busfree revision does not work. */</span>
	<span class="n">AHD_BUSFREEREV_BUG</span>	<span class="o">=</span> <span class="mh">0x40000</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 * Paced transfers are indicated with a non-standard PPR</span>
<span class="cm">	 * option bit in the neg table, 160MHz is indicated by</span>
<span class="cm">	 * sync factor 0x7, and the offset if off by a factor of 2.</span>
<span class="cm">	 */</span>
	<span class="n">AHD_PACED_NEGTABLE_BUG</span>	<span class="o">=</span> <span class="mh">0x80000</span><span class="p">,</span>
	<span class="cm">/* LQOOVERRUN false positives. */</span>
	<span class="n">AHD_LQOOVERRUN_BUG</span>	<span class="o">=</span> <span class="mh">0x100000</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 * Controller write to INTSTAT will lose to a host</span>
<span class="cm">	 * write to CLRINT.</span>
<span class="cm">	 */</span>
	<span class="n">AHD_INTCOLLISION_BUG</span>	<span class="o">=</span> <span class="mh">0x200000</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 * The GEM318 violates the SCSI spec by not waiting</span>
<span class="cm">	 * the mandated bus settle delay between phase changes</span>
<span class="cm">	 * in some situations.  Some aic79xx chip revs. are more</span>
<span class="cm">	 * strict in this regard and will treat REQ assertions</span>
<span class="cm">	 * that fall within the bus settle delay window as</span>
<span class="cm">	 * glitches.  This flag tells the firmware to tolerate</span>
<span class="cm">	 * early REQ assertions.</span>
<span class="cm">	 */</span>
	<span class="n">AHD_EARLY_REQ_BUG</span>	<span class="o">=</span> <span class="mh">0x400000</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 * The LED does not stay on long enough in packetized modes.</span>
<span class="cm">	 */</span>
	<span class="n">AHD_FAINT_LED_BUG</span>	<span class="o">=</span> <span class="mh">0x800000</span>
<span class="p">}</span> <span class="n">ahd_bug</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Configuration specific settings.</span>
<span class="cm"> * The driver determines these settings by probing the</span>
<span class="cm"> * chip/controller&#39;s configuration.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
	<span class="n">AHD_FNONE</span>	      <span class="o">=</span> <span class="mh">0x00000</span><span class="p">,</span>
	<span class="n">AHD_BOOT_CHANNEL</span>      <span class="o">=</span> <span class="mh">0x00001</span><span class="p">,</span><span class="cm">/* We were set as the boot channel. */</span>
	<span class="n">AHD_USEDEFAULTS</span>	      <span class="o">=</span> <span class="mh">0x00004</span><span class="p">,</span><span class="cm">/*</span>
<span class="cm">					 * For cards without an seeprom</span>
<span class="cm">					 * or a BIOS to initialize the chip&#39;s</span>
<span class="cm">					 * SRAM, we use the default target</span>
<span class="cm">					 * settings.</span>
<span class="cm">					 */</span>
	<span class="n">AHD_SEQUENCER_DEBUG</span>   <span class="o">=</span> <span class="mh">0x00008</span><span class="p">,</span>
	<span class="n">AHD_RESET_BUS_A</span>	      <span class="o">=</span> <span class="mh">0x00010</span><span class="p">,</span>
	<span class="n">AHD_EXTENDED_TRANS_A</span>  <span class="o">=</span> <span class="mh">0x00020</span><span class="p">,</span>
	<span class="n">AHD_TERM_ENB_A</span>	      <span class="o">=</span> <span class="mh">0x00040</span><span class="p">,</span>
	<span class="n">AHD_SPCHK_ENB_A</span>	      <span class="o">=</span> <span class="mh">0x00080</span><span class="p">,</span>
	<span class="n">AHD_STPWLEVEL_A</span>	      <span class="o">=</span> <span class="mh">0x00100</span><span class="p">,</span>
	<span class="n">AHD_INITIATORROLE</span>     <span class="o">=</span> <span class="mh">0x00200</span><span class="p">,</span><span class="cm">/*</span>
<span class="cm">					 * Allow initiator operations on</span>
<span class="cm">					 * this controller.</span>
<span class="cm">					 */</span>
	<span class="n">AHD_TARGETROLE</span>	      <span class="o">=</span> <span class="mh">0x00400</span><span class="p">,</span><span class="cm">/*</span>
<span class="cm">					 * Allow target operations on this</span>
<span class="cm">					 * controller.</span>
<span class="cm">					 */</span>
	<span class="n">AHD_RESOURCE_SHORTAGE</span> <span class="o">=</span> <span class="mh">0x00800</span><span class="p">,</span>
	<span class="n">AHD_TQINFIFO_BLOCKED</span>  <span class="o">=</span> <span class="mh">0x01000</span><span class="p">,</span><span class="cm">/* Blocked waiting for ATIOs */</span>
	<span class="n">AHD_INT50_SPEEDFLEX</span>   <span class="o">=</span> <span class="mh">0x02000</span><span class="p">,</span><span class="cm">/*</span>
<span class="cm">					 * Internal 50pin connector</span>
<span class="cm">					 * sits behind an aic3860</span>
<span class="cm">					 */</span>
	<span class="n">AHD_BIOS_ENABLED</span>      <span class="o">=</span> <span class="mh">0x04000</span><span class="p">,</span>
	<span class="n">AHD_ALL_INTERRUPTS</span>    <span class="o">=</span> <span class="mh">0x08000</span><span class="p">,</span>
	<span class="n">AHD_39BIT_ADDRESSING</span>  <span class="o">=</span> <span class="mh">0x10000</span><span class="p">,</span><span class="cm">/* Use 39 bit addressing scheme. */</span>
	<span class="n">AHD_64BIT_ADDRESSING</span>  <span class="o">=</span> <span class="mh">0x20000</span><span class="p">,</span><span class="cm">/* Use 64 bit addressing scheme. */</span>
	<span class="n">AHD_CURRENT_SENSING</span>   <span class="o">=</span> <span class="mh">0x40000</span><span class="p">,</span>
	<span class="n">AHD_SCB_CONFIG_USED</span>   <span class="o">=</span> <span class="mh">0x80000</span><span class="p">,</span><span class="cm">/* No SEEPROM but SCB had info. */</span>
	<span class="n">AHD_HP_BOARD</span>	      <span class="o">=</span> <span class="mh">0x100000</span><span class="p">,</span>
	<span class="n">AHD_BUS_RESET_ACTIVE</span>  <span class="o">=</span> <span class="mh">0x200000</span><span class="p">,</span>
	<span class="n">AHD_UPDATE_PEND_CMDS</span>  <span class="o">=</span> <span class="mh">0x400000</span><span class="p">,</span>
	<span class="n">AHD_RUNNING_QOUTFIFO</span>  <span class="o">=</span> <span class="mh">0x800000</span><span class="p">,</span>
	<span class="n">AHD_HAD_FIRST_SEL</span>     <span class="o">=</span> <span class="mh">0x1000000</span>
<span class="p">}</span> <span class="n">ahd_flag</span><span class="p">;</span>

<span class="cm">/************************* Hardware  SCB Definition ***************************/</span>

<span class="cm">/*</span>
<span class="cm"> * The driver keeps up to MAX_SCB scb structures per card in memory.  The SCB</span>
<span class="cm"> * consists of a &quot;hardware SCB&quot; mirroring the fields available on the card</span>
<span class="cm"> * and additional information the kernel stores for each transaction.</span>
<span class="cm"> *</span>
<span class="cm"> * To minimize space utilization, a portion of the hardware scb stores</span>
<span class="cm"> * different data during different portions of a SCSI transaction.</span>
<span class="cm"> * As initialized by the host driver for the initiator role, this area</span>
<span class="cm"> * contains the SCSI cdb (or a pointer to the  cdb) to be executed.  After</span>
<span class="cm"> * the cdb has been presented to the target, this area serves to store</span>
<span class="cm"> * residual transfer information and the SCSI status byte.</span>
<span class="cm"> * For the target role, the contents of this area do not change, but</span>
<span class="cm"> * still serve a different purpose than for the initiator role.  See</span>
<span class="cm"> * struct target_data for details.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Status information embedded in the shared poriton of</span>
<span class="cm"> * an SCB after passing the cdb to the target.  The kernel</span>
<span class="cm"> * driver will only read this data for transactions that</span>
<span class="cm"> * complete abnormally.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">initiator_status</span> <span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">residual_datacnt</span><span class="p">;</span>	<span class="cm">/* Residual in the current S/G seg */</span>
	<span class="kt">uint32_t</span> <span class="n">residual_sgptr</span><span class="p">;</span>	<span class="cm">/* The next S/G for this transfer */</span>
	<span class="kt">uint8_t</span>	 <span class="n">scsi_status</span><span class="p">;</span>		<span class="cm">/* Standard SCSI status byte */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">target_status</span> <span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">residual_datacnt</span><span class="p">;</span>	<span class="cm">/* Residual in the current S/G seg */</span>
	<span class="kt">uint32_t</span> <span class="n">residual_sgptr</span><span class="p">;</span>	<span class="cm">/* The next S/G for this transfer */</span>
	<span class="kt">uint8_t</span>  <span class="n">scsi_status</span><span class="p">;</span>		<span class="cm">/* SCSI status to give to initiator */</span>
	<span class="kt">uint8_t</span>  <span class="n">target_phases</span><span class="p">;</span>		<span class="cm">/* Bitmap of phases to execute */</span>
	<span class="kt">uint8_t</span>  <span class="n">data_phase</span><span class="p">;</span>		<span class="cm">/* Data-In or Data-Out */</span>
	<span class="kt">uint8_t</span>  <span class="n">initiator_tag</span><span class="p">;</span>		<span class="cm">/* Initiator&#39;s transaction tag */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Initiator mode SCB shared data area.</span>
<span class="cm"> * If the embedded CDB is 12 bytes or less, we embed</span>
<span class="cm"> * the sense buffer address in the SCB.  This allows</span>
<span class="cm"> * us to retrieve sense information without interrupting</span>
<span class="cm"> * the host in packetized mode.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">uint32_t</span> <span class="n">sense_addr_t</span><span class="p">;</span>
<span class="cp">#define MAX_CDB_LEN 16</span>
<span class="cp">#define MAX_CDB_LEN_WITH_SENSE_ADDR (MAX_CDB_LEN - sizeof(sense_addr_t))</span>
<span class="k">union</span> <span class="n">initiator_data</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="kt">uint64_t</span> <span class="n">cdbptr</span><span class="p">;</span>
		<span class="kt">uint8_t</span>  <span class="n">cdblen</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">cdb_from_host</span><span class="p">;</span>
	<span class="kt">uint8_t</span>	 <span class="n">cdb</span><span class="p">[</span><span class="n">MAX_CDB_LEN</span><span class="p">];</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="kt">uint8_t</span>	 <span class="n">cdb</span><span class="p">[</span><span class="n">MAX_CDB_LEN_WITH_SENSE_ADDR</span><span class="p">];</span>
		<span class="n">sense_addr_t</span> <span class="n">sense_addr</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">cdb_plus_saddr</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Target mode version of the shared data SCB segment.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">target_data</span> <span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">spare</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>	
	<span class="kt">uint8_t</span>  <span class="n">scsi_status</span><span class="p">;</span>		<span class="cm">/* SCSI status to give to initiator */</span>
	<span class="kt">uint8_t</span>  <span class="n">target_phases</span><span class="p">;</span>		<span class="cm">/* Bitmap of phases to execute */</span>
	<span class="kt">uint8_t</span>  <span class="n">data_phase</span><span class="p">;</span>		<span class="cm">/* Data-In or Data-Out */</span>
	<span class="kt">uint8_t</span>  <span class="n">initiator_tag</span><span class="p">;</span>		<span class="cm">/* Initiator&#39;s transaction tag */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">hardware_scb</span> <span class="p">{</span>
<span class="cm">/*0*/</span>	<span class="k">union</span> <span class="p">{</span>
		<span class="k">union</span>	<span class="n">initiator_data</span> <span class="n">idata</span><span class="p">;</span>
		<span class="k">struct</span>	<span class="n">target_data</span> <span class="n">tdata</span><span class="p">;</span>
		<span class="k">struct</span>	<span class="n">initiator_status</span> <span class="n">istatus</span><span class="p">;</span>
		<span class="k">struct</span>	<span class="n">target_status</span> <span class="n">tstatus</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">shared_data</span><span class="p">;</span>
<span class="cm">/*</span>
<span class="cm"> * A word about residuals.</span>
<span class="cm"> * The scb is presented to the sequencer with the dataptr and datacnt</span>
<span class="cm"> * fields initialized to the contents of the first S/G element to</span>
<span class="cm"> * transfer.  The sgptr field is initialized to the bus address for</span>
<span class="cm"> * the S/G element that follows the first in the in core S/G array</span>
<span class="cm"> * or&#39;ed with the SG_FULL_RESID flag.  Sgptr may point to an invalid</span>
<span class="cm"> * S/G entry for this transfer (single S/G element transfer with the</span>
<span class="cm"> * first elements address and length preloaded in the dataptr/datacnt</span>
<span class="cm"> * fields).  If no transfer is to occur, sgptr is set to SG_LIST_NULL.</span>
<span class="cm"> * The SG_FULL_RESID flag ensures that the residual will be correctly</span>
<span class="cm"> * noted even if no data transfers occur.  Once the data phase is entered,</span>
<span class="cm"> * the residual sgptr and datacnt are loaded from the sgptr and the</span>
<span class="cm"> * datacnt fields.  After each S/G element&#39;s dataptr and length are</span>
<span class="cm"> * loaded into the hardware, the residual sgptr is advanced.  After</span>
<span class="cm"> * each S/G element is expired, its datacnt field is checked to see</span>
<span class="cm"> * if the LAST_SEG flag is set.  If so, SG_LIST_NULL is set in the</span>
<span class="cm"> * residual sg ptr and the transfer is considered complete.  If the</span>
<span class="cm"> * sequencer determines that there is a residual in the tranfer, or</span>
<span class="cm"> * there is non-zero status, it will set the SG_STATUS_VALID flag in</span>
<span class="cm"> * sgptr and dma the scb back into host memory.  To sumarize:</span>
<span class="cm"> *</span>
<span class="cm"> * Sequencer:</span>
<span class="cm"> *	o A residual has occurred if SG_FULL_RESID is set in sgptr,</span>
<span class="cm"> *	  or residual_sgptr does not have SG_LIST_NULL set.</span>
<span class="cm"> *</span>
<span class="cm"> *	o We are transferring the last segment if residual_datacnt has</span>
<span class="cm"> *	  the SG_LAST_SEG flag set.</span>
<span class="cm"> *</span>
<span class="cm"> * Host:</span>
<span class="cm"> *	o A residual can only have occurred if a completed scb has the</span>
<span class="cm"> *	  SG_STATUS_VALID flag set.  Inspection of the SCSI status field,</span>
<span class="cm"> *	  the residual_datacnt, and the residual_sgptr field will tell</span>
<span class="cm"> *	  for sure.</span>
<span class="cm"> *</span>
<span class="cm"> *	o residual_sgptr and sgptr refer to the &quot;next&quot; sg entry</span>
<span class="cm"> *	  and so may point beyond the last valid sg entry for the</span>
<span class="cm"> *	  transfer.</span>
<span class="cm"> */</span> 
<span class="cp">#define SG_PTR_MASK	0xFFFFFFF8</span>
<span class="cm">/*16*/</span>	<span class="kt">uint16_t</span> <span class="n">tag</span><span class="p">;</span>		<span class="cm">/* Reused by Sequencer. */</span>
<span class="cm">/*18*/</span>	<span class="kt">uint8_t</span>  <span class="n">control</span><span class="p">;</span>	<span class="cm">/* See SCB_CONTROL in aic79xx.reg for details */</span>
<span class="cm">/*19*/</span>	<span class="kt">uint8_t</span>	 <span class="n">scsiid</span><span class="p">;</span>	<span class="cm">/*</span>
<span class="cm">				 * Selection out Id</span>
<span class="cm">				 * Our Id (bits 0-3) Their ID (bits 4-7)</span>
<span class="cm">				 */</span>
<span class="cm">/*20*/</span>	<span class="kt">uint8_t</span>  <span class="n">lun</span><span class="p">;</span>
<span class="cm">/*21*/</span>	<span class="kt">uint8_t</span>  <span class="n">task_attribute</span><span class="p">;</span>
<span class="cm">/*22*/</span>	<span class="kt">uint8_t</span>  <span class="n">cdb_len</span><span class="p">;</span>
<span class="cm">/*23*/</span>	<span class="kt">uint8_t</span>  <span class="n">task_management</span><span class="p">;</span>
<span class="cm">/*24*/</span>	<span class="kt">uint64_t</span> <span class="n">dataptr</span><span class="p">;</span>
<span class="cm">/*32*/</span>	<span class="kt">uint32_t</span> <span class="n">datacnt</span><span class="p">;</span>	<span class="cm">/* Byte 3 is spare. */</span>
<span class="cm">/*36*/</span>	<span class="kt">uint32_t</span> <span class="n">sgptr</span><span class="p">;</span>
<span class="cm">/*40*/</span>	<span class="kt">uint32_t</span> <span class="n">hscb_busaddr</span><span class="p">;</span>
<span class="cm">/*44*/</span>	<span class="kt">uint32_t</span> <span class="n">next_hscb_busaddr</span><span class="p">;</span>
<span class="cm">/********** Long lun field only downloaded for full 8 byte lun support ********/</span>
<span class="cm">/*48*/</span>  <span class="kt">uint8_t</span>	 <span class="n">pkt_long_lun</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
<span class="cm">/******* Fields below are not Downloaded (Sequencer may use for scratch) ******/</span>
<span class="cm">/*56*/</span>  <span class="kt">uint8_t</span>	 <span class="n">spare</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/************************ Kernel SCB Definitions ******************************/</span>
<span class="cm">/*</span>
<span class="cm"> * Some fields of the SCB are OS dependent.  Here we collect the</span>
<span class="cm"> * definitions for elements that all OS platforms need to include</span>
<span class="cm"> * in there SCB definition.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Definition of a scatter/gather element as transferred to the controller.</span>
<span class="cm"> * The aic7xxx chips only support a 24bit length.  We use the top byte of</span>
<span class="cm"> * the length to store additional address bits and a flag to indicate</span>
<span class="cm"> * that a given segment terminates the transfer.  This gives us an</span>
<span class="cm"> * addressable range of 512GB on machines with 64bit PCI or with chips</span>
<span class="cm"> * that can support dual address cycles on 32bit PCI busses.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ahd_dma_seg</span> <span class="p">{</span>
	<span class="kt">uint32_t</span>	<span class="n">addr</span><span class="p">;</span>
	<span class="kt">uint32_t</span>	<span class="n">len</span><span class="p">;</span>
<span class="cp">#define	AHD_DMA_LAST_SEG	0x80000000</span>
<span class="cp">#define	AHD_SG_HIGH_ADDR_MASK	0x7F000000</span>
<span class="cp">#define	AHD_SG_LEN_MASK		0x00FFFFFF</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ahd_dma64_seg</span> <span class="p">{</span>
	<span class="kt">uint64_t</span>	<span class="n">addr</span><span class="p">;</span>
	<span class="kt">uint32_t</span>	<span class="n">len</span><span class="p">;</span>
	<span class="kt">uint32_t</span>	<span class="n">pad</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">map_node</span> <span class="p">{</span>
	<span class="n">bus_dmamap_t</span>		 <span class="n">dmamap</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>		 <span class="n">physaddr</span><span class="p">;</span>
	<span class="kt">uint8_t</span>			<span class="o">*</span><span class="n">vaddr</span><span class="p">;</span>
	<span class="n">SLIST_ENTRY</span><span class="p">(</span><span class="n">map_node</span><span class="p">)</span>	 <span class="n">links</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * The current state of this SCB.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
	<span class="n">SCB_FLAG_NONE</span>		<span class="o">=</span> <span class="mh">0x00000</span><span class="p">,</span>
	<span class="n">SCB_TRANSMISSION_ERROR</span>	<span class="o">=</span> <span class="mh">0x00001</span><span class="p">,</span><span class="cm">/*</span>
<span class="cm">					   * We detected a parity or CRC</span>
<span class="cm">					   * error that has effected the</span>
<span class="cm">					   * payload of the command.  This</span>
<span class="cm">					   * flag is checked when normal</span>
<span class="cm">					   * status is returned to catch</span>
<span class="cm">					   * the case of a target not</span>
<span class="cm">					   * responding to our attempt</span>
<span class="cm">					   * to report the error.</span>
<span class="cm">					   */</span>
	<span class="n">SCB_OTHERTCL_TIMEOUT</span>	<span class="o">=</span> <span class="mh">0x00002</span><span class="p">,</span><span class="cm">/*</span>
<span class="cm">					   * Another device was active</span>
<span class="cm">					   * during the first timeout for</span>
<span class="cm">					   * this SCB so we gave ourselves</span>
<span class="cm">					   * an additional timeout period</span>
<span class="cm">					   * in case it was hogging the</span>
<span class="cm">					   * bus.</span>
<span class="cm">				           */</span>
	<span class="n">SCB_DEVICE_RESET</span>	<span class="o">=</span> <span class="mh">0x00004</span><span class="p">,</span>
	<span class="n">SCB_SENSE</span>		<span class="o">=</span> <span class="mh">0x00008</span><span class="p">,</span>
	<span class="n">SCB_CDB32_PTR</span>		<span class="o">=</span> <span class="mh">0x00010</span><span class="p">,</span>
	<span class="n">SCB_RECOVERY_SCB</span>	<span class="o">=</span> <span class="mh">0x00020</span><span class="p">,</span>
	<span class="n">SCB_AUTO_NEGOTIATE</span>	<span class="o">=</span> <span class="mh">0x00040</span><span class="p">,</span><span class="cm">/* Negotiate to achieve goal. */</span>
	<span class="n">SCB_NEGOTIATE</span>		<span class="o">=</span> <span class="mh">0x00080</span><span class="p">,</span><span class="cm">/* Negotiation forced for command. */</span>
	<span class="n">SCB_ABORT</span>		<span class="o">=</span> <span class="mh">0x00100</span><span class="p">,</span>
	<span class="n">SCB_ACTIVE</span>		<span class="o">=</span> <span class="mh">0x00200</span><span class="p">,</span>
	<span class="n">SCB_TARGET_IMMEDIATE</span>	<span class="o">=</span> <span class="mh">0x00400</span><span class="p">,</span>
	<span class="n">SCB_PACKETIZED</span>		<span class="o">=</span> <span class="mh">0x00800</span><span class="p">,</span>
	<span class="n">SCB_EXPECT_PPR_BUSFREE</span>	<span class="o">=</span> <span class="mh">0x01000</span><span class="p">,</span>
	<span class="n">SCB_PKT_SENSE</span>		<span class="o">=</span> <span class="mh">0x02000</span><span class="p">,</span>
	<span class="n">SCB_EXTERNAL_RESET</span>	<span class="o">=</span> <span class="mh">0x04000</span><span class="p">,</span><span class="cm">/* Device was reset externally */</span>
	<span class="n">SCB_ON_COL_LIST</span>		<span class="o">=</span> <span class="mh">0x08000</span><span class="p">,</span>
	<span class="n">SCB_SILENT</span>		<span class="o">=</span> <span class="mh">0x10000</span> <span class="cm">/*</span>
<span class="cm">					   * Be quiet about transmission type</span>
<span class="cm">					   * errors.  They are expected and we</span>
<span class="cm">					   * don&#39;t want to upset the user.  This</span>
<span class="cm">					   * flag is typically used during DV.</span>
<span class="cm">					   */</span>
<span class="p">}</span> <span class="n">scb_flag</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">scb</span> <span class="p">{</span>
	<span class="k">struct</span>	<span class="n">hardware_scb</span>	 <span class="o">*</span><span class="n">hscb</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="n">SLIST_ENTRY</span><span class="p">(</span><span class="n">scb</span><span class="p">)</span>  <span class="n">sle</span><span class="p">;</span>
		<span class="n">LIST_ENTRY</span><span class="p">(</span><span class="n">scb</span><span class="p">)</span>	  <span class="n">le</span><span class="p">;</span>
		<span class="n">TAILQ_ENTRY</span><span class="p">(</span><span class="n">scb</span><span class="p">)</span>  <span class="n">tqe</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">links</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="n">SLIST_ENTRY</span><span class="p">(</span><span class="n">scb</span><span class="p">)</span>  <span class="n">sle</span><span class="p">;</span>
		<span class="n">LIST_ENTRY</span><span class="p">(</span><span class="n">scb</span><span class="p">)</span>	  <span class="n">le</span><span class="p">;</span>
		<span class="n">TAILQ_ENTRY</span><span class="p">(</span><span class="n">scb</span><span class="p">)</span>  <span class="n">tqe</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">links2</span><span class="p">;</span>
<span class="cp">#define pending_links links2.le</span>
<span class="cp">#define collision_links links2.le</span>
	<span class="k">struct</span> <span class="n">scb</span>		 <span class="o">*</span><span class="n">col_scb</span><span class="p">;</span>
	<span class="n">ahd_io_ctx_t</span>		  <span class="n">io_ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ahd_softc</span>	 <span class="o">*</span><span class="n">ahd_softc</span><span class="p">;</span>
	<span class="n">scb_flag</span>		  <span class="n">flags</span><span class="p">;</span>
<span class="cp">#ifndef __linux__</span>
	<span class="n">bus_dmamap_t</span>		  <span class="n">dmamap</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">struct</span> <span class="n">scb_platform_data</span> <span class="o">*</span><span class="n">platform_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">map_node</span>	 	 <span class="o">*</span><span class="n">hscb_map</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">map_node</span>	 	 <span class="o">*</span><span class="n">sg_map</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">map_node</span>	 	 <span class="o">*</span><span class="n">sense_map</span><span class="p">;</span>
	<span class="kt">void</span>			 <span class="o">*</span><span class="n">sg_list</span><span class="p">;</span>
	<span class="kt">uint8_t</span>			 <span class="o">*</span><span class="n">sense_data</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>		  <span class="n">sg_list_busaddr</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>		  <span class="n">sense_busaddr</span><span class="p">;</span>
	<span class="n">u_int</span>			  <span class="n">sg_count</span><span class="p">;</span><span class="cm">/* How full ahd_dma_seg is */</span>
<span class="cp">#define	AHD_MAX_LQ_CRC_ERRORS 5</span>
	<span class="n">u_int</span>			  <span class="n">crc_retry_count</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">TAILQ_HEAD</span><span class="p">(</span><span class="n">scb_tailq</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">scb_list</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">scb_data</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * TAILQ of lists of free SCBs grouped by device</span>
<span class="cm">	 * collision domains.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">scb_tailq</span> <span class="n">free_scbs</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Per-device lists of SCBs whose tag ID would collide</span>
<span class="cm">	 * with an already active tag on the device.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">scb_list</span> <span class="n">free_scb_lists</span><span class="p">[</span><span class="n">AHD_NUM_TARGETS</span> <span class="o">*</span> <span class="n">AHD_NUM_LUNS_NONPKT</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 * SCBs that will not collide with any active device.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">scb_list</span> <span class="n">any_dev_free_scb_list</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Mapping from tag to SCB.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span>	<span class="n">scb</span> <span class="o">*</span><span class="n">scbindex</span><span class="p">[</span><span class="n">AHD_SCB_MAX</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 * &quot;Bus&quot; addresses of our data structures.</span>
<span class="cm">	 */</span>
	<span class="n">bus_dma_tag_t</span>	 <span class="n">hscb_dmat</span><span class="p">;</span>	<span class="cm">/* dmat for our hardware SCB array */</span>
	<span class="n">bus_dma_tag_t</span>	 <span class="n">sg_dmat</span><span class="p">;</span>	<span class="cm">/* dmat for our sg segments */</span>
	<span class="n">bus_dma_tag_t</span>	 <span class="n">sense_dmat</span><span class="p">;</span>	<span class="cm">/* dmat for our sense buffers */</span>
	<span class="n">SLIST_HEAD</span><span class="p">(,</span> <span class="n">map_node</span><span class="p">)</span> <span class="n">hscb_maps</span><span class="p">;</span>
	<span class="n">SLIST_HEAD</span><span class="p">(,</span> <span class="n">map_node</span><span class="p">)</span> <span class="n">sg_maps</span><span class="p">;</span>
	<span class="n">SLIST_HEAD</span><span class="p">(,</span> <span class="n">map_node</span><span class="p">)</span> <span class="n">sense_maps</span><span class="p">;</span>
	<span class="kt">int</span>		 <span class="n">scbs_left</span><span class="p">;</span>	<span class="cm">/* unallocated scbs in head map_node */</span>
	<span class="kt">int</span>		 <span class="n">sgs_left</span><span class="p">;</span>	<span class="cm">/* unallocated sgs in head map_node */</span>
	<span class="kt">int</span>		 <span class="n">sense_left</span><span class="p">;</span>	<span class="cm">/* unallocated sense in head map_node */</span>
	<span class="kt">uint16_t</span>	 <span class="n">numscbs</span><span class="p">;</span>
	<span class="kt">uint16_t</span>	 <span class="n">maxhscbs</span><span class="p">;</span>	<span class="cm">/* Number of SCBs on the card */</span>
	<span class="kt">uint8_t</span>		 <span class="n">init_level</span><span class="p">;</span>	<span class="cm">/*</span>
<span class="cm">					 * How far we&#39;ve initialized</span>
<span class="cm">					 * this structure.</span>
<span class="cm">					 */</span>
<span class="p">};</span>

<span class="cm">/************************ Target Mode Definitions *****************************/</span>

<span class="cm">/*</span>
<span class="cm"> * Connection descriptor for select-in requests in target mode.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">target_cmd</span> <span class="p">{</span>
	<span class="kt">uint8_t</span> <span class="n">scsiid</span><span class="p">;</span>		<span class="cm">/* Our ID and the initiator&#39;s ID */</span>
	<span class="kt">uint8_t</span> <span class="n">identify</span><span class="p">;</span>	<span class="cm">/* Identify message */</span>
	<span class="kt">uint8_t</span> <span class="n">bytes</span><span class="p">[</span><span class="mi">22</span><span class="p">];</span>	<span class="cm">/* </span>
<span class="cm">				 * Bytes contains any additional message</span>
<span class="cm">				 * bytes terminated by 0xFF.  The remainder</span>
<span class="cm">				 * is the cdb to execute.</span>
<span class="cm">				 */</span>
	<span class="kt">uint8_t</span> <span class="n">cmd_valid</span><span class="p">;</span>	<span class="cm">/*</span>
<span class="cm">				 * When a command is complete, the firmware</span>
<span class="cm">				 * will set cmd_valid to all bits set.</span>
<span class="cm">				 * After the host has seen the command,</span>
<span class="cm">				 * the bits are cleared.  This allows us</span>
<span class="cm">				 * to just peek at host memory to determine</span>
<span class="cm">				 * if more work is complete. cmd_valid is on</span>
<span class="cm">				 * an 8 byte boundary to simplify setting</span>
<span class="cm">				 * it on aic7880 hardware which only has</span>
<span class="cm">				 * limited direct access to the DMA FIFO.</span>
<span class="cm">				 */</span>
	<span class="kt">uint8_t</span> <span class="n">pad</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Number of events we can buffer up if we run out</span>
<span class="cm"> * of immediate notify ccbs.</span>
<span class="cm"> */</span>
<span class="cp">#define AHD_TMODE_EVENT_BUFFER_SIZE 8</span>
<span class="k">struct</span> <span class="n">ahd_tmode_event</span> <span class="p">{</span>
	<span class="kt">uint8_t</span> <span class="n">initiator_id</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">event_type</span><span class="p">;</span>	<span class="cm">/* MSG type or EVENT_TYPE_BUS_RESET */</span>
<span class="cp">#define	EVENT_TYPE_BUS_RESET 0xFF</span>
	<span class="kt">uint8_t</span> <span class="n">event_arg</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Per enabled lun target mode state.</span>
<span class="cm"> * As this state is directly influenced by the host OS&#39;es target mode</span>
<span class="cm"> * environment, we let the OS module define it.  Forward declare the</span>
<span class="cm"> * structure here so we can store arrays of them, etc. in OS neutral</span>
<span class="cm"> * data structures.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef AHD_TARGET_MODE </span>
<span class="k">struct</span> <span class="n">ahd_tmode_lstate</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">cam_path</span> <span class="o">*</span><span class="n">path</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ccb_hdr_slist</span> <span class="n">accept_tios</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ccb_hdr_slist</span> <span class="n">immed_notifies</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ahd_tmode_event</span> <span class="n">event_buffer</span><span class="p">[</span><span class="n">AHD_TMODE_EVENT_BUFFER_SIZE</span><span class="p">];</span>
	<span class="kt">uint8_t</span> <span class="n">event_r_idx</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">event_w_idx</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp">#else</span>
<span class="k">struct</span> <span class="n">ahd_tmode_lstate</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cm">/******************** Transfer Negotiation Datastructures *********************/</span>
<span class="cp">#define AHD_TRANS_CUR		0x01	</span><span class="cm">/* Modify current neogtiation status */</span><span class="cp"></span>
<span class="cp">#define AHD_TRANS_ACTIVE	0x03	</span><span class="cm">/* Assume this target is on the bus */</span><span class="cp"></span>
<span class="cp">#define AHD_TRANS_GOAL		0x04	</span><span class="cm">/* Modify negotiation goal */</span><span class="cp"></span>
<span class="cp">#define AHD_TRANS_USER		0x08	</span><span class="cm">/* Modify user negotiation settings */</span><span class="cp"></span>
<span class="cp">#define AHD_PERIOD_10MHz	0x19</span>

<span class="cp">#define AHD_WIDTH_UNKNOWN	0xFF</span>
<span class="cp">#define AHD_PERIOD_UNKNOWN	0xFF</span>
<span class="cp">#define AHD_OFFSET_UNKNOWN	0xFF</span>
<span class="cp">#define AHD_PPR_OPTS_UNKNOWN	0xFF</span>

<span class="cm">/*</span>
<span class="cm"> * Transfer Negotiation Information.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ahd_transinfo</span> <span class="p">{</span>
	<span class="kt">uint8_t</span> <span class="n">protocol_version</span><span class="p">;</span>	<span class="cm">/* SCSI Revision level */</span>
	<span class="kt">uint8_t</span> <span class="n">transport_version</span><span class="p">;</span>	<span class="cm">/* SPI Revision level */</span>
	<span class="kt">uint8_t</span> <span class="n">width</span><span class="p">;</span>			<span class="cm">/* Bus width */</span>
	<span class="kt">uint8_t</span> <span class="n">period</span><span class="p">;</span>			<span class="cm">/* Sync rate factor */</span>
	<span class="kt">uint8_t</span> <span class="n">offset</span><span class="p">;</span>			<span class="cm">/* Sync offset */</span>
	<span class="kt">uint8_t</span> <span class="n">ppr_options</span><span class="p">;</span>		<span class="cm">/* Parallel Protocol Request options */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Per-initiator current, goal and user transfer negotiation information. */</span>
<span class="k">struct</span> <span class="n">ahd_initiator_tinfo</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ahd_transinfo</span> <span class="n">curr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ahd_transinfo</span> <span class="n">goal</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ahd_transinfo</span> <span class="n">user</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Per enabled target ID state.</span>
<span class="cm"> * Pointers to lun target state as well as sync/wide negotiation information</span>
<span class="cm"> * for each initiator&lt;-&gt;target mapping.  For the initiator role we pretend</span>
<span class="cm"> * that we are the target and the targets are the initiators since the</span>
<span class="cm"> * negotiation is the same regardless of role.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ahd_tmode_tstate</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ahd_tmode_lstate</span><span class="o">*</span>	<span class="n">enabled_luns</span><span class="p">[</span><span class="n">AHD_NUM_LUNS</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">ahd_initiator_tinfo</span>	<span class="n">transinfo</span><span class="p">[</span><span class="n">AHD_NUM_TARGETS</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 * Per initiator state bitmasks.</span>
<span class="cm">	 */</span>
	<span class="kt">uint16_t</span>	 <span class="n">auto_negotiate</span><span class="p">;</span><span class="cm">/* Auto Negotiation Required */</span>
	<span class="kt">uint16_t</span>	 <span class="n">discenable</span><span class="p">;</span>	<span class="cm">/* Disconnection allowed  */</span>
	<span class="kt">uint16_t</span>	 <span class="n">tagenable</span><span class="p">;</span>	<span class="cm">/* Tagged Queuing allowed */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Points of interest along the negotiated transfer scale.</span>
<span class="cm"> */</span>
<span class="cp">#define AHD_SYNCRATE_160	0x8</span>
<span class="cp">#define AHD_SYNCRATE_PACED	0x8</span>
<span class="cp">#define AHD_SYNCRATE_DT		0x9</span>
<span class="cp">#define AHD_SYNCRATE_ULTRA2	0xa</span>
<span class="cp">#define AHD_SYNCRATE_ULTRA	0xc</span>
<span class="cp">#define AHD_SYNCRATE_FAST	0x19</span>
<span class="cp">#define AHD_SYNCRATE_MIN_DT	AHD_SYNCRATE_FAST</span>
<span class="cp">#define AHD_SYNCRATE_SYNC	0x32</span>
<span class="cp">#define AHD_SYNCRATE_MIN	0x60</span>
<span class="cp">#define	AHD_SYNCRATE_ASYNC	0xFF</span>
<span class="cp">#define AHD_SYNCRATE_MAX	AHD_SYNCRATE_160</span>

<span class="cm">/* Safe and valid period for async negotiations. */</span>
<span class="cp">#define	AHD_ASYNC_XFER_PERIOD	0x44</span>

<span class="cm">/*</span>
<span class="cm"> * In RevA, the synctable uses a 120MHz rate for the period</span>
<span class="cm"> * factor 8 and 160MHz for the period factor 7.  The 120MHz</span>
<span class="cm"> * rate never made it into the official SCSI spec, so we must</span>
<span class="cm"> * compensate when setting the negotiation table for Rev A</span>
<span class="cm"> * parts.</span>
<span class="cm"> */</span>
<span class="cp">#define AHD_SYNCRATE_REVA_120	0x8</span>
<span class="cp">#define AHD_SYNCRATE_REVA_160	0x7</span>

<span class="cm">/***************************** Lookup Tables **********************************/</span>
<span class="cm">/*</span>
<span class="cm"> * Phase -&gt; name and message out response</span>
<span class="cm"> * to parity errors in each phase table. </span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ahd_phase_table_entry</span> <span class="p">{</span>
        <span class="kt">uint8_t</span> <span class="n">phase</span><span class="p">;</span>
        <span class="kt">uint8_t</span> <span class="n">mesg_out</span><span class="p">;</span> <span class="cm">/* Message response to parity errors */</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">phasemsg</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/************************** Serial EEPROM Format ******************************/</span>

<span class="k">struct</span> <span class="n">seeprom_config</span> <span class="p">{</span>
<span class="cm">/*</span>
<span class="cm"> * Per SCSI ID Configuration Flags</span>
<span class="cm"> */</span>
	<span class="kt">uint16_t</span> <span class="n">device_flags</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>	<span class="cm">/* words 0-15 */</span>
<span class="cp">#define		CFXFER		0x003F	</span><span class="cm">/* synchronous transfer rate */</span><span class="cp"></span>
<span class="cp">#define			CFXFER_ASYNC	0x3F</span>
<span class="cp">#define		CFQAS		0x0040	</span><span class="cm">/* Negotiate QAS */</span><span class="cp"></span>
<span class="cp">#define		CFPACKETIZED	0x0080	</span><span class="cm">/* Negotiate Packetized Transfers */</span><span class="cp"></span>
<span class="cp">#define		CFSTART		0x0100	</span><span class="cm">/* send start unit SCSI command */</span><span class="cp"></span>
<span class="cp">#define		CFINCBIOS	0x0200	</span><span class="cm">/* include in BIOS scan */</span><span class="cp"></span>
<span class="cp">#define		CFDISC		0x0400	</span><span class="cm">/* enable disconnection */</span><span class="cp"></span>
<span class="cp">#define		CFMULTILUNDEV	0x0800	</span><span class="cm">/* Probe multiple luns in BIOS scan */</span><span class="cp"></span>
<span class="cp">#define		CFWIDEB		0x1000	</span><span class="cm">/* wide bus device */</span><span class="cp"></span>
<span class="cp">#define		CFHOSTMANAGED	0x8000	</span><span class="cm">/* Managed by a RAID controller */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * BIOS Control Bits</span>
<span class="cm"> */</span>
	<span class="kt">uint16_t</span> <span class="n">bios_control</span><span class="p">;</span>		<span class="cm">/* word 16 */</span>
<span class="cp">#define		CFSUPREM	0x0001	</span><span class="cm">/* support all removeable drives */</span><span class="cp"></span>
<span class="cp">#define		CFSUPREMB	0x0002	</span><span class="cm">/* support removeable boot drives */</span><span class="cp"></span>
<span class="cp">#define		CFBIOSSTATE	0x000C	</span><span class="cm">/* BIOS Action State */</span><span class="cp"></span>
<span class="cp">#define		    CFBS_DISABLED	0x00</span>
<span class="cp">#define		    CFBS_ENABLED	0x04</span>
<span class="cp">#define		    CFBS_DISABLED_SCAN	0x08</span>
<span class="cp">#define		CFENABLEDV	0x0010	</span><span class="cm">/* Perform Domain Validation */</span><span class="cp"></span>
<span class="cp">#define		CFCTRL_A	0x0020	</span><span class="cm">/* BIOS displays Ctrl-A message */</span><span class="cp">	</span>
<span class="cp">#define		CFSPARITY	0x0040	</span><span class="cm">/* SCSI parity */</span><span class="cp"></span>
<span class="cp">#define		CFEXTEND	0x0080	</span><span class="cm">/* extended translation enabled */</span><span class="cp"></span>
<span class="cp">#define		CFBOOTCD	0x0100  </span><span class="cm">/* Support Bootable CD-ROM */</span><span class="cp"></span>
<span class="cp">#define		CFMSG_LEVEL	0x0600	</span><span class="cm">/* BIOS Message Level */</span><span class="cp"></span>
<span class="cp">#define			CFMSG_VERBOSE	0x0000</span>
<span class="cp">#define			CFMSG_SILENT	0x0200</span>
<span class="cp">#define			CFMSG_DIAG	0x0400</span>
<span class="cp">#define		CFRESETB	0x0800	</span><span class="cm">/* reset SCSI bus at boot */</span><span class="cp"></span>
<span class="cm">/*		UNUSED		0xf000	*/</span>

<span class="cm">/*</span>
<span class="cm"> * Host Adapter Control Bits</span>
<span class="cm"> */</span>
	<span class="kt">uint16_t</span> <span class="n">adapter_control</span><span class="p">;</span>	<span class="cm">/* word 17 */</span>	
<span class="cp">#define		CFAUTOTERM	0x0001	</span><span class="cm">/* Perform Auto termination */</span><span class="cp"></span>
<span class="cp">#define		CFSTERM		0x0002	</span><span class="cm">/* SCSI low byte termination */</span><span class="cp"></span>
<span class="cp">#define		CFWSTERM	0x0004	</span><span class="cm">/* SCSI high byte termination */</span><span class="cp"></span>
<span class="cp">#define		CFSEAUTOTERM	0x0008	</span><span class="cm">/* Ultra2 Perform secondary Auto Term*/</span><span class="cp"></span>
<span class="cp">#define		CFSELOWTERM	0x0010	</span><span class="cm">/* Ultra2 secondary low term */</span><span class="cp"></span>
<span class="cp">#define		CFSEHIGHTERM	0x0020	</span><span class="cm">/* Ultra2 secondary high term */</span><span class="cp"></span>
<span class="cp">#define		CFSTPWLEVEL	0x0040	</span><span class="cm">/* Termination level control */</span><span class="cp"></span>
<span class="cp">#define		CFBIOSAUTOTERM	0x0080	</span><span class="cm">/* Perform Auto termination */</span><span class="cp"></span>
<span class="cp">#define		CFTERM_MENU	0x0100	</span><span class="cm">/* BIOS displays termination menu */</span><span class="cp">	</span>
<span class="cp">#define		CFCLUSTERENB	0x8000	</span><span class="cm">/* Cluster Enable */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Bus Release Time, Host Adapter ID</span>
<span class="cm"> */</span>
	<span class="kt">uint16_t</span> <span class="n">brtime_id</span><span class="p">;</span>		<span class="cm">/* word 18 */</span>
<span class="cp">#define		CFSCSIID	0x000f	</span><span class="cm">/* host adapter SCSI ID */</span><span class="cp"></span>
<span class="cm">/*		UNUSED		0x00f0	*/</span>
<span class="cp">#define		CFBRTIME	0xff00	</span><span class="cm">/* bus release time/PCI Latency Time */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Maximum targets</span>
<span class="cm"> */</span>
	<span class="kt">uint16_t</span> <span class="n">max_targets</span><span class="p">;</span>		<span class="cm">/* word 19 */</span>	
<span class="cp">#define		CFMAXTARG	0x00ff	</span><span class="cm">/* maximum targets */</span><span class="cp"></span>
<span class="cp">#define		CFBOOTLUN	0x0f00	</span><span class="cm">/* Lun to boot from */</span><span class="cp"></span>
<span class="cp">#define		CFBOOTID	0xf000	</span><span class="cm">/* Target to boot from */</span><span class="cp"></span>
	<span class="kt">uint16_t</span> <span class="n">res_1</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>		<span class="cm">/* words 20-29 */</span>
	<span class="kt">uint16_t</span> <span class="n">signature</span><span class="p">;</span>		<span class="cm">/* BIOS Signature */</span>
<span class="cp">#define		CFSIGNATURE	0x400</span>
	<span class="kt">uint16_t</span> <span class="n">checksum</span><span class="p">;</span>		<span class="cm">/* word 31 */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Vital Product Data used during POST and by the BIOS.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">vpd_config</span> <span class="p">{</span>
	<span class="kt">uint8_t</span>  <span class="n">bios_flags</span><span class="p">;</span>
<span class="cp">#define		VPDMASTERBIOS	0x0001</span>
<span class="cp">#define		VPDBOOTHOST	0x0002</span>
	<span class="kt">uint8_t</span>  <span class="n">reserved_1</span><span class="p">[</span><span class="mi">21</span><span class="p">];</span>
	<span class="kt">uint8_t</span>  <span class="n">resource_type</span><span class="p">;</span>
	<span class="kt">uint8_t</span>  <span class="n">resource_len</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="kt">uint8_t</span>  <span class="n">resource_data</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="kt">uint8_t</span>  <span class="n">vpd_tag</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">vpd_len</span><span class="p">;</span>
	<span class="kt">uint8_t</span>  <span class="n">vpd_keyword</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="kt">uint8_t</span>  <span class="n">length</span><span class="p">;</span>
	<span class="kt">uint8_t</span>  <span class="n">revision</span><span class="p">;</span>
	<span class="kt">uint8_t</span>  <span class="n">device_flags</span><span class="p">;</span>
	<span class="kt">uint8_t</span>  <span class="n">termnation_menus</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="kt">uint8_t</span>  <span class="n">fifo_threshold</span><span class="p">;</span>
	<span class="kt">uint8_t</span>  <span class="n">end_tag</span><span class="p">;</span>
	<span class="kt">uint8_t</span>  <span class="n">vpd_checksum</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">default_target_flags</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">default_bios_flags</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">default_ctrl_flags</span><span class="p">;</span>
	<span class="kt">uint8_t</span>  <span class="n">default_irq</span><span class="p">;</span>
	<span class="kt">uint8_t</span>  <span class="n">pci_lattime</span><span class="p">;</span>
	<span class="kt">uint8_t</span>  <span class="n">max_target</span><span class="p">;</span>
	<span class="kt">uint8_t</span>  <span class="n">boot_lun</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">signature</span><span class="p">;</span>
	<span class="kt">uint8_t</span>  <span class="n">reserved_2</span><span class="p">;</span>
	<span class="kt">uint8_t</span>  <span class="n">checksum</span><span class="p">;</span>
	<span class="kt">uint8_t</span>	 <span class="n">reserved_3</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/****************************** Flexport Logic ********************************/</span>
<span class="cp">#define FLXADDR_TERMCTL			0x0</span>
<span class="cp">#define		FLX_TERMCTL_ENSECHIGH	0x8</span>
<span class="cp">#define		FLX_TERMCTL_ENSECLOW	0x4</span>
<span class="cp">#define		FLX_TERMCTL_ENPRIHIGH	0x2</span>
<span class="cp">#define		FLX_TERMCTL_ENPRILOW	0x1</span>
<span class="cp">#define FLXADDR_ROMSTAT_CURSENSECTL	0x1</span>
<span class="cp">#define		FLX_ROMSTAT_SEECFG	0xF0</span>
<span class="cp">#define		FLX_ROMSTAT_EECFG	0x0F</span>
<span class="cp">#define		FLX_ROMSTAT_SEE_93C66	0x00</span>
<span class="cp">#define		FLX_ROMSTAT_SEE_NONE	0xF0</span>
<span class="cp">#define		FLX_ROMSTAT_EE_512x8	0x0</span>
<span class="cp">#define		FLX_ROMSTAT_EE_1MBx8	0x1</span>
<span class="cp">#define		FLX_ROMSTAT_EE_2MBx8	0x2</span>
<span class="cp">#define		FLX_ROMSTAT_EE_4MBx8	0x3</span>
<span class="cp">#define		FLX_ROMSTAT_EE_16MBx8	0x4</span>
<span class="cp">#define 		CURSENSE_ENB	0x1</span>
<span class="cp">#define	FLXADDR_FLEXSTAT		0x2</span>
<span class="cp">#define		FLX_FSTAT_BUSY		0x1</span>
<span class="cp">#define FLXADDR_CURRENT_STAT		0x4</span>
<span class="cp">#define		FLX_CSTAT_SEC_HIGH	0xC0</span>
<span class="cp">#define		FLX_CSTAT_SEC_LOW	0x30</span>
<span class="cp">#define		FLX_CSTAT_PRI_HIGH	0x0C</span>
<span class="cp">#define		FLX_CSTAT_PRI_LOW	0x03</span>
<span class="cp">#define		FLX_CSTAT_MASK		0x03</span>
<span class="cp">#define		FLX_CSTAT_SHIFT		2</span>
<span class="cp">#define		FLX_CSTAT_OKAY		0x0</span>
<span class="cp">#define		FLX_CSTAT_OVER		0x1</span>
<span class="cp">#define		FLX_CSTAT_UNDER		0x2</span>
<span class="cp">#define		FLX_CSTAT_INVALID	0x3</span>

<span class="kt">int</span>		<span class="n">ahd_read_seeprom</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				 <span class="n">u_int</span> <span class="n">start_addr</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">count</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bstream</span><span class="p">);</span>

<span class="kt">int</span>		<span class="n">ahd_write_seeprom</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				  <span class="n">u_int</span> <span class="n">start_addr</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">count</span><span class="p">);</span>
<span class="kt">int</span>		<span class="n">ahd_verify_cksum</span><span class="p">(</span><span class="k">struct</span> <span class="n">seeprom_config</span> <span class="o">*</span><span class="n">sc</span><span class="p">);</span>
<span class="kt">int</span>		<span class="n">ahd_acquire_seeprom</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">);</span>
<span class="kt">void</span>		<span class="n">ahd_release_seeprom</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">);</span>

<span class="cm">/****************************  Message Buffer *********************************/</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
	<span class="n">MSG_FLAG_NONE</span>			<span class="o">=</span> <span class="mh">0x00</span><span class="p">,</span>
	<span class="n">MSG_FLAG_EXPECT_PPR_BUSFREE</span>	<span class="o">=</span> <span class="mh">0x01</span><span class="p">,</span>
	<span class="n">MSG_FLAG_IU_REQ_CHANGED</span>		<span class="o">=</span> <span class="mh">0x02</span><span class="p">,</span>
	<span class="n">MSG_FLAG_EXPECT_IDE_BUSFREE</span>	<span class="o">=</span> <span class="mh">0x04</span><span class="p">,</span>
	<span class="n">MSG_FLAG_EXPECT_QASREJ_BUSFREE</span>	<span class="o">=</span> <span class="mh">0x08</span><span class="p">,</span>
	<span class="n">MSG_FLAG_PACKETIZED</span>		<span class="o">=</span> <span class="mh">0x10</span>
<span class="p">}</span> <span class="n">ahd_msg_flags</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
	<span class="n">MSG_TYPE_NONE</span>			<span class="o">=</span> <span class="mh">0x00</span><span class="p">,</span>
	<span class="n">MSG_TYPE_INITIATOR_MSGOUT</span>	<span class="o">=</span> <span class="mh">0x01</span><span class="p">,</span>
	<span class="n">MSG_TYPE_INITIATOR_MSGIN</span>	<span class="o">=</span> <span class="mh">0x02</span><span class="p">,</span>
	<span class="n">MSG_TYPE_TARGET_MSGOUT</span>		<span class="o">=</span> <span class="mh">0x03</span><span class="p">,</span>
	<span class="n">MSG_TYPE_TARGET_MSGIN</span>		<span class="o">=</span> <span class="mh">0x04</span>
<span class="p">}</span> <span class="n">ahd_msg_type</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
	<span class="n">MSGLOOP_IN_PROG</span><span class="p">,</span>
	<span class="n">MSGLOOP_MSGCOMPLETE</span><span class="p">,</span>
	<span class="n">MSGLOOP_TERMINATED</span>
<span class="p">}</span> <span class="n">msg_loop_stat</span><span class="p">;</span>

<span class="cm">/*********************** Software Configuration Structure *********************/</span>
<span class="k">struct</span> <span class="n">ahd_suspend_channel_state</span> <span class="p">{</span>
	<span class="kt">uint8_t</span>	<span class="n">scsiseq</span><span class="p">;</span>
	<span class="kt">uint8_t</span>	<span class="n">sxfrctl0</span><span class="p">;</span>
	<span class="kt">uint8_t</span>	<span class="n">sxfrctl1</span><span class="p">;</span>
	<span class="kt">uint8_t</span>	<span class="n">simode0</span><span class="p">;</span>
	<span class="kt">uint8_t</span>	<span class="n">simode1</span><span class="p">;</span>
	<span class="kt">uint8_t</span>	<span class="n">seltimer</span><span class="p">;</span>
	<span class="kt">uint8_t</span>	<span class="n">seqctl</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ahd_suspend_pci_state</span> <span class="p">{</span>
	<span class="kt">uint32_t</span>  <span class="n">devconfig</span><span class="p">;</span>
	<span class="kt">uint8_t</span>   <span class="n">command</span><span class="p">;</span>
	<span class="kt">uint8_t</span>   <span class="n">csize_lattime</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ahd_suspend_state</span> <span class="p">{</span>
	<span class="k">struct</span>	<span class="n">ahd_suspend_channel_state</span> <span class="n">channel</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="k">struct</span>  <span class="n">ahd_suspend_pci_state</span> <span class="n">pci_state</span><span class="p">;</span>
	<span class="kt">uint8_t</span>	<span class="n">optionmode</span><span class="p">;</span>
	<span class="kt">uint8_t</span>	<span class="n">dscommand0</span><span class="p">;</span>
	<span class="kt">uint8_t</span>	<span class="n">dspcistatus</span><span class="p">;</span>
	<span class="cm">/* hsmailbox */</span>
	<span class="kt">uint8_t</span>	<span class="n">crccontrol1</span><span class="p">;</span>
	<span class="kt">uint8_t</span>	<span class="n">scbbaddr</span><span class="p">;</span>
	<span class="cm">/* Host and sequencer SCB counts */</span>
	<span class="kt">uint8_t</span>	<span class="n">dff_thrsh</span><span class="p">;</span>
	<span class="kt">uint8_t</span>	<span class="o">*</span><span class="n">scratch_ram</span><span class="p">;</span>
	<span class="kt">uint8_t</span>	<span class="o">*</span><span class="n">btt</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">ahd_bus_intr_t</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="p">);</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
	<span class="n">AHD_MODE_DFF0</span><span class="p">,</span>
	<span class="n">AHD_MODE_DFF1</span><span class="p">,</span>
	<span class="n">AHD_MODE_CCHAN</span><span class="p">,</span>
	<span class="n">AHD_MODE_SCSI</span><span class="p">,</span>
	<span class="n">AHD_MODE_CFG</span><span class="p">,</span>
	<span class="n">AHD_MODE_UNKNOWN</span>
<span class="p">}</span> <span class="n">ahd_mode</span><span class="p">;</span>

<span class="cp">#define AHD_MK_MSK(x) (0x01 &lt;&lt; (x))</span>
<span class="cp">#define AHD_MODE_DFF0_MSK	AHD_MK_MSK(AHD_MODE_DFF0)</span>
<span class="cp">#define AHD_MODE_DFF1_MSK	AHD_MK_MSK(AHD_MODE_DFF1)</span>
<span class="cp">#define AHD_MODE_CCHAN_MSK	AHD_MK_MSK(AHD_MODE_CCHAN)</span>
<span class="cp">#define AHD_MODE_SCSI_MSK	AHD_MK_MSK(AHD_MODE_SCSI)</span>
<span class="cp">#define AHD_MODE_CFG_MSK	AHD_MK_MSK(AHD_MODE_CFG)</span>
<span class="cp">#define AHD_MODE_UNKNOWN_MSK	AHD_MK_MSK(AHD_MODE_UNKNOWN)</span>
<span class="cp">#define AHD_MODE_ANY_MSK (~0)</span>

<span class="k">typedef</span> <span class="kt">uint8_t</span> <span class="n">ahd_mode_state</span><span class="p">;</span>

<span class="k">typedef</span> <span class="kt">void</span> <span class="n">ahd_callback_t</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">ahd_completion</span>
<span class="p">{</span>
	<span class="kt">uint16_t</span>	<span class="n">tag</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">sg_status</span><span class="p">;</span>
	<span class="kt">uint8_t</span>		<span class="n">valid_tag</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ahd_softc</span> <span class="p">{</span>
	<span class="n">bus_space_tag_t</span>           <span class="n">tags</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="n">bus_space_handle_t</span>        <span class="n">bshs</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="cp">#ifndef __linux__</span>
	<span class="n">bus_dma_tag_t</span>		  <span class="n">buffer_dmat</span><span class="p">;</span>   <span class="cm">/* dmat for buffer I/O */</span>
<span class="cp">#endif</span>
	<span class="k">struct</span> <span class="n">scb_data</span>		  <span class="n">scb_data</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">hardware_scb</span>	 <span class="o">*</span><span class="n">next_queued_hscb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">map_node</span>		 <span class="o">*</span><span class="n">next_queued_hscb_map</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * SCBs that have been sent to the controller</span>
<span class="cm">	 */</span>
	<span class="n">LIST_HEAD</span><span class="p">(,</span> <span class="n">scb</span><span class="p">)</span>	  <span class="n">pending_scbs</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Current register window mode information.</span>
<span class="cm">	 */</span>
	<span class="n">ahd_mode</span>		  <span class="n">dst_mode</span><span class="p">;</span>
	<span class="n">ahd_mode</span>		  <span class="n">src_mode</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Saved register window mode information</span>
<span class="cm">	 * used for restore on next unpause.</span>
<span class="cm">	 */</span>
	<span class="n">ahd_mode</span>		  <span class="n">saved_dst_mode</span><span class="p">;</span>
	<span class="n">ahd_mode</span>		  <span class="n">saved_src_mode</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Platform specific data.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">ahd_platform_data</span> <span class="o">*</span><span class="n">platform_data</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Platform specific device information.</span>
<span class="cm">	 */</span>
	<span class="n">ahd_dev_softc_t</span>		  <span class="n">dev_softc</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Bus specific device information.</span>
<span class="cm">	 */</span>
	<span class="n">ahd_bus_intr_t</span>		  <span class="n">bus_intr</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Target mode related state kept on a per enabled lun basis.</span>
<span class="cm">	 * Targets that are not enabled will have null entries.</span>
<span class="cm">	 * As an initiator, we keep one target entry for our initiator</span>
<span class="cm">	 * ID to store our sync/wide transfer settings.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">ahd_tmode_tstate</span>  <span class="o">*</span><span class="n">enabled_targets</span><span class="p">[</span><span class="n">AHD_NUM_TARGETS</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 * The black hole device responsible for handling requests for</span>
<span class="cm">	 * disabled luns on enabled targets.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">ahd_tmode_lstate</span>  <span class="o">*</span><span class="n">black_hole</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Device instance currently on the bus awaiting a continue TIO</span>
<span class="cm">	 * for a command that was not given the disconnect priveledge.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">ahd_tmode_lstate</span>  <span class="o">*</span><span class="n">pending_device</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Timer handles for timer driven callbacks.</span>
<span class="cm">	 */</span>
	<span class="n">ahd_timer_t</span>		  <span class="n">reset_timer</span><span class="p">;</span>
	<span class="n">ahd_timer_t</span>		  <span class="n">stat_timer</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Statistics.</span>
<span class="cm">	 */</span>
<span class="cp">#define	AHD_STAT_UPDATE_US	250000 </span><span class="cm">/* 250ms */</span><span class="cp"></span>
<span class="cp">#define	AHD_STAT_BUCKETS	4</span>
	<span class="n">u_int</span>			  <span class="n">cmdcmplt_bucket</span><span class="p">;</span>
	<span class="kt">uint32_t</span>		  <span class="n">cmdcmplt_counts</span><span class="p">[</span><span class="n">AHD_STAT_BUCKETS</span><span class="p">];</span>
	<span class="kt">uint32_t</span>		  <span class="n">cmdcmplt_total</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Card characteristics</span>
<span class="cm">	 */</span>
	<span class="n">ahd_chip</span>		  <span class="n">chip</span><span class="p">;</span>
	<span class="n">ahd_feature</span>		  <span class="n">features</span><span class="p">;</span>
	<span class="n">ahd_bug</span>			  <span class="n">bugs</span><span class="p">;</span>
	<span class="n">ahd_flag</span>		  <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">seeprom_config</span>	 <span class="o">*</span><span class="n">seep_config</span><span class="p">;</span>

	<span class="cm">/* Command Queues */</span>
	<span class="k">struct</span> <span class="n">ahd_completion</span>	  <span class="o">*</span><span class="n">qoutfifo</span><span class="p">;</span>
	<span class="kt">uint16_t</span>		  <span class="n">qoutfifonext</span><span class="p">;</span>
	<span class="kt">uint16_t</span>		  <span class="n">qoutfifonext_valid_tag</span><span class="p">;</span>
	<span class="kt">uint16_t</span>		  <span class="n">qinfifonext</span><span class="p">;</span>
	<span class="kt">uint16_t</span>		  <span class="n">qinfifo</span><span class="p">[</span><span class="n">AHD_SCB_MAX</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 * Our qfreeze count.  The sequencer compares</span>
<span class="cm">	 * this value with its own counter to determine</span>
<span class="cm">	 * whether to allow selections to occur.</span>
<span class="cm">	 */</span>
	<span class="kt">uint16_t</span>		  <span class="n">qfreeze_cnt</span><span class="p">;</span>

	<span class="cm">/* Values to store in the SEQCTL register for pause and unpause */</span>
	<span class="kt">uint8_t</span>			  <span class="n">unpause</span><span class="p">;</span>
	<span class="kt">uint8_t</span>			  <span class="n">pause</span><span class="p">;</span>

	<span class="cm">/* Critical Section Data */</span>
	<span class="k">struct</span> <span class="n">cs</span>		 <span class="o">*</span><span class="n">critical_sections</span><span class="p">;</span>
	<span class="n">u_int</span>			  <span class="n">num_critical_sections</span><span class="p">;</span>

	<span class="cm">/* Buffer for handling packetized bitbucket. */</span>
	<span class="kt">uint8_t</span>			 <span class="o">*</span><span class="n">overrun_buf</span><span class="p">;</span>

	<span class="cm">/* Links for chaining softcs */</span>
	<span class="n">TAILQ_ENTRY</span><span class="p">(</span><span class="n">ahd_softc</span><span class="p">)</span>	  <span class="n">links</span><span class="p">;</span>

	<span class="cm">/* Channel Names (&#39;A&#39;, &#39;B&#39;, etc.) */</span>
	<span class="kt">char</span>			  <span class="n">channel</span><span class="p">;</span>

	<span class="cm">/* Initiator Bus ID */</span>
	<span class="kt">uint8_t</span>			  <span class="n">our_id</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Target incoming command FIFO.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">target_cmd</span>	 <span class="o">*</span><span class="n">targetcmds</span><span class="p">;</span>
	<span class="kt">uint8_t</span>			  <span class="n">tqinfifonext</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Cached verson of the hs_mailbox so we can avoid</span>
<span class="cm">	 * pausing the sequencer during mailbox updates.</span>
<span class="cm">	 */</span>
	<span class="kt">uint8_t</span>			  <span class="n">hs_mailbox</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Incoming and outgoing message handling.</span>
<span class="cm">	 */</span>
	<span class="kt">uint8_t</span>			  <span class="n">send_msg_perror</span><span class="p">;</span>
	<span class="n">ahd_msg_flags</span>		  <span class="n">msg_flags</span><span class="p">;</span>
	<span class="n">ahd_msg_type</span>		  <span class="n">msg_type</span><span class="p">;</span>
	<span class="kt">uint8_t</span>			  <span class="n">msgout_buf</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span><span class="cm">/* Message we are sending */</span>
	<span class="kt">uint8_t</span>			  <span class="n">msgin_buf</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span><span class="cm">/* Message we are receiving */</span>
	<span class="n">u_int</span>			  <span class="n">msgout_len</span><span class="p">;</span>	<span class="cm">/* Length of message to send */</span>
	<span class="n">u_int</span>			  <span class="n">msgout_index</span><span class="p">;</span>	<span class="cm">/* Current index in msgout */</span>
	<span class="n">u_int</span>			  <span class="n">msgin_index</span><span class="p">;</span>	<span class="cm">/* Current index in msgin */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Mapping information for data structures shared</span>
<span class="cm">	 * between the sequencer and kernel.</span>
<span class="cm">	 */</span>
	<span class="n">bus_dma_tag_t</span>		  <span class="n">parent_dmat</span><span class="p">;</span>
	<span class="n">bus_dma_tag_t</span>		  <span class="n">shared_data_dmat</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">map_node</span>		  <span class="n">shared_data_map</span><span class="p">;</span>

	<span class="cm">/* Information saved through suspend/resume cycles */</span>
	<span class="k">struct</span> <span class="n">ahd_suspend_state</span>  <span class="n">suspend_state</span><span class="p">;</span>

	<span class="cm">/* Number of enabled target mode device on this card */</span>
	<span class="n">u_int</span>			  <span class="n">enabled_luns</span><span class="p">;</span>

	<span class="cm">/* Initialization level of this data structure */</span>
	<span class="n">u_int</span>			  <span class="n">init_level</span><span class="p">;</span>

	<span class="cm">/* PCI cacheline size. */</span>
	<span class="n">u_int</span>			  <span class="n">pci_cachesize</span><span class="p">;</span>

	<span class="cm">/* IO Cell Parameters */</span>
	<span class="kt">uint8_t</span>			  <span class="n">iocell_opts</span><span class="p">[</span><span class="n">AHD_NUM_PER_DEV_ANNEXCOLS</span><span class="p">];</span>

	<span class="n">u_int</span>			  <span class="n">stack_size</span><span class="p">;</span>
	<span class="kt">uint16_t</span>		 <span class="o">*</span><span class="n">saved_stack</span><span class="p">;</span>

	<span class="cm">/* Per-Unit descriptive information */</span>
	<span class="k">const</span> <span class="kt">char</span>		 <span class="o">*</span><span class="n">description</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span>		 <span class="o">*</span><span class="n">bus_description</span><span class="p">;</span>
	<span class="kt">char</span>			 <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">int</span>			  <span class="n">unit</span><span class="p">;</span>

	<span class="cm">/* Selection Timer settings */</span>
	<span class="kt">int</span>			  <span class="n">seltime</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Interrupt coalescing settings.</span>
<span class="cm">	 */</span>
<span class="cp">#define	AHD_INT_COALESCING_TIMER_DEFAULT		250 </span><span class="cm">/*us*/</span><span class="cp"></span>
<span class="cp">#define	AHD_INT_COALESCING_MAXCMDS_DEFAULT		10</span>
<span class="cp">#define	AHD_INT_COALESCING_MAXCMDS_MAX			127</span>
<span class="cp">#define	AHD_INT_COALESCING_MINCMDS_DEFAULT		5</span>
<span class="cp">#define	AHD_INT_COALESCING_MINCMDS_MAX			127</span>
<span class="cp">#define	AHD_INT_COALESCING_THRESHOLD_DEFAULT		2000</span>
<span class="cp">#define	AHD_INT_COALESCING_STOP_THRESHOLD_DEFAULT	1000</span>
	<span class="n">u_int</span>			  <span class="n">int_coalescing_timer</span><span class="p">;</span>
	<span class="n">u_int</span>			  <span class="n">int_coalescing_maxcmds</span><span class="p">;</span>
	<span class="n">u_int</span>			  <span class="n">int_coalescing_mincmds</span><span class="p">;</span>
	<span class="n">u_int</span>			  <span class="n">int_coalescing_threshold</span><span class="p">;</span>
	<span class="n">u_int</span>			  <span class="n">int_coalescing_stop_threshold</span><span class="p">;</span>

	<span class="kt">uint16_t</span>	 	  <span class="n">user_discenable</span><span class="p">;</span><span class="cm">/* Disconnection allowed  */</span>
	<span class="kt">uint16_t</span>		  <span class="n">user_tagenable</span><span class="p">;</span><span class="cm">/* Tagged Queuing allowed */</span>
<span class="p">};</span>

<span class="cm">/*************************** IO Cell Configuration ****************************/</span>
<span class="cp">#define	AHD_PRECOMP_SLEW_INDEX						\</span>
<span class="cp">    (AHD_ANNEXCOL_PRECOMP_SLEW - AHD_ANNEXCOL_PER_DEV0)</span>

<span class="cp">#define	AHD_AMPLITUDE_INDEX						\</span>
<span class="cp">    (AHD_ANNEXCOL_AMPLITUDE - AHD_ANNEXCOL_PER_DEV0)</span>

<span class="cp">#define AHD_SET_SLEWRATE(ahd, new_slew)					\</span>
<span class="cp">do {									\</span>
<span class="cp">    (ahd)-&gt;iocell_opts[AHD_PRECOMP_SLEW_INDEX] &amp;= ~AHD_SLEWRATE_MASK;	\</span>
<span class="cp">    (ahd)-&gt;iocell_opts[AHD_PRECOMP_SLEW_INDEX] |=			\</span>
<span class="cp">	(((new_slew) &lt;&lt; AHD_SLEWRATE_SHIFT) &amp; AHD_SLEWRATE_MASK);	\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define AHD_SET_PRECOMP(ahd, new_pcomp)					\</span>
<span class="cp">do {									\</span>
<span class="cp">    (ahd)-&gt;iocell_opts[AHD_PRECOMP_SLEW_INDEX] &amp;= ~AHD_PRECOMP_MASK;	\</span>
<span class="cp">    (ahd)-&gt;iocell_opts[AHD_PRECOMP_SLEW_INDEX] |=			\</span>
<span class="cp">	(((new_pcomp) &lt;&lt; AHD_PRECOMP_SHIFT) &amp; AHD_PRECOMP_MASK);	\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define AHD_SET_AMPLITUDE(ahd, new_amp)					\</span>
<span class="cp">do {									\</span>
<span class="cp">    (ahd)-&gt;iocell_opts[AHD_AMPLITUDE_INDEX] &amp;= ~AHD_AMPLITUDE_MASK;	\</span>
<span class="cp">    (ahd)-&gt;iocell_opts[AHD_AMPLITUDE_INDEX] |=				\</span>
<span class="cp">	(((new_amp) &lt;&lt; AHD_AMPLITUDE_SHIFT) &amp; AHD_AMPLITUDE_MASK);	\</span>
<span class="cp">} while (0)</span>

<span class="cm">/************************ Active Device Information ***************************/</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
	<span class="n">ROLE_UNKNOWN</span><span class="p">,</span>
	<span class="n">ROLE_INITIATOR</span><span class="p">,</span>
	<span class="n">ROLE_TARGET</span>
<span class="p">}</span> <span class="n">role_t</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">ahd_devinfo</span> <span class="p">{</span>
	<span class="kt">int</span>	 <span class="n">our_scsiid</span><span class="p">;</span>
	<span class="kt">int</span>	 <span class="n">target_offset</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">target_mask</span><span class="p">;</span>
	<span class="n">u_int</span>	 <span class="n">target</span><span class="p">;</span>
	<span class="n">u_int</span>	 <span class="n">lun</span><span class="p">;</span>
	<span class="kt">char</span>	 <span class="n">channel</span><span class="p">;</span>
	<span class="n">role_t</span>	 <span class="n">role</span><span class="p">;</span>		<span class="cm">/*</span>
<span class="cm">				 * Only guaranteed to be correct if not</span>
<span class="cm">				 * in the busfree state.</span>
<span class="cm">				 */</span>
<span class="p">};</span>

<span class="cm">/****************************** PCI Structures ********************************/</span>
<span class="cp">#define AHD_PCI_IOADDR0	PCIR_BAR(0)	</span><span class="cm">/* I/O BAR*/</span><span class="cp"></span>
<span class="cp">#define AHD_PCI_MEMADDR	PCIR_BAR(1)	</span><span class="cm">/* Memory BAR */</span><span class="cp"></span>
<span class="cp">#define AHD_PCI_IOADDR1	PCIR_BAR(3)	</span><span class="cm">/* Second I/O BAR */</span><span class="cp"></span>

<span class="k">typedef</span> <span class="kt">int</span> <span class="p">(</span><span class="n">ahd_device_setup_t</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">ahd_pci_identity</span> <span class="p">{</span>
	<span class="kt">uint64_t</span>		 <span class="n">full_id</span><span class="p">;</span>
	<span class="kt">uint64_t</span>		 <span class="n">id_mask</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span>		<span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="n">ahd_device_setup_t</span>	<span class="o">*</span><span class="n">setup</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/***************************** VL/EISA Declarations ***************************/</span>
<span class="k">struct</span> <span class="n">aic7770_identity</span> <span class="p">{</span>
	<span class="kt">uint32_t</span>		 <span class="n">full_id</span><span class="p">;</span>
	<span class="kt">uint32_t</span>		 <span class="n">id_mask</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span>		<span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="n">ahd_device_setup_t</span>	<span class="o">*</span><span class="n">setup</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">aic7770_identity</span> <span class="n">aic7770_ident_table</span> <span class="p">[];</span>
<span class="k">extern</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">ahd_num_aic7770_devs</span><span class="p">;</span>

<span class="cp">#define AHD_EISA_SLOT_OFFSET	0xc00</span>
<span class="cp">#define AHD_EISA_IOSIZE		0x100</span>

<span class="cm">/*************************** Function Declarations ****************************/</span>
<span class="cm">/******************************************************************************/</span>

<span class="cm">/***************************** PCI Front End *********************************/</span>
<span class="k">const</span> <span class="k">struct</span>	<span class="n">ahd_pci_identity</span> <span class="o">*</span><span class="n">ahd_find_pci_device</span><span class="p">(</span><span class="n">ahd_dev_softc_t</span><span class="p">);</span>
<span class="kt">int</span>			  <span class="n">ahd_pci_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="p">,</span>
					 <span class="k">const</span> <span class="k">struct</span> <span class="n">ahd_pci_identity</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span>	<span class="n">ahd_pci_test_register_access</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_PM</span>
<span class="kt">void</span>	<span class="n">ahd_pci_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span>	<span class="n">ahd_pci_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/************************** SCB and SCB queue management **********************/</span>
<span class="kt">void</span>		<span class="n">ahd_qinfifo_requeue_tail</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">scb</span> <span class="o">*</span><span class="n">scb</span><span class="p">);</span>

<span class="cm">/****************************** Initialization ********************************/</span>
<span class="k">struct</span> <span class="n">ahd_softc</span>	<span class="o">*</span><span class="n">ahd_alloc</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">platform_arg</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>
<span class="kt">int</span>			 <span class="n">ahd_softc_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span>			 <span class="n">ahd_controller_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>
<span class="kt">int</span>			 <span class="n">ahd_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_PM</span>
<span class="kt">int</span>			 <span class="n">ahd_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">);</span>
<span class="kt">void</span>			 <span class="n">ahd_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="kt">int</span>			 <span class="n">ahd_default_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">);</span>
<span class="kt">int</span>			 <span class="n">ahd_parse_vpddata</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">vpd_config</span> <span class="o">*</span><span class="n">vpd</span><span class="p">);</span>
<span class="kt">int</span>			 <span class="n">ahd_parse_cfgdata</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">seeprom_config</span> <span class="o">*</span><span class="n">sc</span><span class="p">);</span>
<span class="kt">void</span>			 <span class="n">ahd_intr_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">enable</span><span class="p">);</span>
<span class="kt">void</span>			 <span class="n">ahd_pause_and_flushwork</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">);</span>
<span class="kt">void</span>			 <span class="n">ahd_set_unit</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="kt">void</span>			 <span class="n">ahd_set_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">scb</span>		<span class="o">*</span><span class="n">ahd_get_scb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">col_idx</span><span class="p">);</span>
<span class="kt">void</span>			 <span class="n">ahd_free_scb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scb</span> <span class="o">*</span><span class="n">scb</span><span class="p">);</span>
<span class="kt">void</span>			 <span class="n">ahd_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">);</span>
<span class="kt">int</span>			 <span class="n">ahd_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reinit</span><span class="p">);</span>
<span class="kt">int</span>			 <span class="n">ahd_write_flexport</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span>
					    <span class="n">u_int</span> <span class="n">addr</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">value</span><span class="p">);</span>
<span class="kt">int</span>			 <span class="n">ahd_read_flexport</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">addr</span><span class="p">,</span>
					   <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">value</span><span class="p">);</span>

<span class="cm">/***************************** Error Recovery *********************************/</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
	<span class="n">SEARCH_COMPLETE</span><span class="p">,</span>
	<span class="n">SEARCH_COUNT</span><span class="p">,</span>
	<span class="n">SEARCH_REMOVE</span><span class="p">,</span>
	<span class="n">SEARCH_PRINT</span>
<span class="p">}</span> <span class="n">ahd_search_action</span><span class="p">;</span>
<span class="kt">int</span>			<span class="n">ahd_search_qinfifo</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">,</span>
					   <span class="kt">char</span> <span class="n">channel</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lun</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">tag</span><span class="p">,</span>
					   <span class="n">role_t</span> <span class="n">role</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">status</span><span class="p">,</span>
					   <span class="n">ahd_search_action</span> <span class="n">action</span><span class="p">);</span>
<span class="kt">int</span>			<span class="n">ahd_search_disc_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">,</span>
					     <span class="kt">char</span> <span class="n">channel</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lun</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">tag</span><span class="p">,</span>
					     <span class="kt">int</span> <span class="n">stop_on_first</span><span class="p">,</span> <span class="kt">int</span> <span class="n">remove</span><span class="p">,</span>
					     <span class="kt">int</span> <span class="n">save_state</span><span class="p">);</span>
<span class="kt">int</span>			<span class="n">ahd_reset_channel</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="kt">char</span> <span class="n">channel</span><span class="p">,</span>
					  <span class="kt">int</span> <span class="n">initiate_reset</span><span class="p">);</span>
<span class="cm">/*************************** Utility Functions ********************************/</span>
<span class="kt">void</span>			<span class="n">ahd_compile_devinfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_devinfo</span> <span class="o">*</span><span class="n">devinfo</span><span class="p">,</span>
					    <span class="n">u_int</span> <span class="n">our_id</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">target</span><span class="p">,</span>
					    <span class="n">u_int</span> <span class="n">lun</span><span class="p">,</span> <span class="kt">char</span> <span class="n">channel</span><span class="p">,</span>
					    <span class="n">role_t</span> <span class="n">role</span><span class="p">);</span>
<span class="cm">/************************** Transfer Negotiation ******************************/</span>
<span class="kt">void</span>			<span class="n">ahd_find_syncrate</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span> <span class="n">u_int</span> <span class="o">*</span><span class="n">period</span><span class="p">,</span>
					  <span class="n">u_int</span> <span class="o">*</span><span class="n">ppr_options</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">maxsync</span><span class="p">);</span>
<span class="cm">/*</span>
<span class="cm"> * Negotiation types.  These are used to qualify if we should renegotiate</span>
<span class="cm"> * even if our goal and current transport parameters are identical.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
	<span class="n">AHD_NEG_TO_GOAL</span><span class="p">,</span>	<span class="cm">/* Renegotiate only if goal and curr differ. */</span>
	<span class="n">AHD_NEG_IF_NON_ASYNC</span><span class="p">,</span>	<span class="cm">/* Renegotiate so long as goal is non-async. */</span>
	<span class="n">AHD_NEG_ALWAYS</span>		<span class="cm">/* Renegotiat even if goal is async. */</span>
<span class="p">}</span> <span class="n">ahd_neg_type</span><span class="p">;</span>
<span class="kt">int</span>			<span class="n">ahd_update_neg_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span><span class="o">*</span><span class="p">,</span>
					       <span class="k">struct</span> <span class="n">ahd_devinfo</span><span class="o">*</span><span class="p">,</span>
					       <span class="k">struct</span> <span class="n">ahd_tmode_tstate</span><span class="o">*</span><span class="p">,</span>
					       <span class="k">struct</span> <span class="n">ahd_initiator_tinfo</span><span class="o">*</span><span class="p">,</span>
					       <span class="n">ahd_neg_type</span><span class="p">);</span>
<span class="kt">void</span>			<span class="n">ahd_set_width</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">ahd_devinfo</span> <span class="o">*</span><span class="n">devinfo</span><span class="p">,</span>
				      <span class="n">u_int</span> <span class="n">width</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">paused</span><span class="p">);</span>
<span class="kt">void</span>			<span class="n">ahd_set_syncrate</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">ahd_devinfo</span> <span class="o">*</span><span class="n">devinfo</span><span class="p">,</span>
					 <span class="n">u_int</span> <span class="n">period</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">offset</span><span class="p">,</span>
					 <span class="n">u_int</span> <span class="n">ppr_options</span><span class="p">,</span>
					 <span class="n">u_int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">paused</span><span class="p">);</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
	<span class="n">AHD_QUEUE_NONE</span><span class="p">,</span>
	<span class="n">AHD_QUEUE_BASIC</span><span class="p">,</span>
	<span class="n">AHD_QUEUE_TAGGED</span>
<span class="p">}</span> <span class="n">ahd_queue_alg</span><span class="p">;</span>

<span class="cm">/**************************** Target Mode *************************************/</span>
<span class="cp">#ifdef AHD_TARGET_MODE</span>
<span class="kt">void</span>		<span class="n">ahd_send_lstate_events</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">ahd_tmode_lstate</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span>		<span class="n">ahd_handle_en_lun</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">cam_sim</span> <span class="o">*</span><span class="n">sim</span><span class="p">,</span> <span class="k">union</span> <span class="n">ccb</span> <span class="o">*</span><span class="n">ccb</span><span class="p">);</span>
<span class="n">cam_status</span>	<span class="n">ahd_find_tmode_devs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">cam_sim</span> <span class="o">*</span><span class="n">sim</span><span class="p">,</span> <span class="k">union</span> <span class="n">ccb</span> <span class="o">*</span><span class="n">ccb</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">ahd_tmode_tstate</span> <span class="o">**</span><span class="n">tstate</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">ahd_tmode_lstate</span> <span class="o">**</span><span class="n">lstate</span><span class="p">,</span>
				    <span class="kt">int</span> <span class="n">notfound_failure</span><span class="p">);</span>
<span class="cp">#ifndef AHD_TMODE_ENABLE</span>
<span class="cp">#define AHD_TMODE_ENABLE 0</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>
<span class="cm">/******************************* Debug ***************************************/</span>
<span class="cp">#ifdef AHD_DEBUG</span>
<span class="k">extern</span> <span class="kt">uint32_t</span> <span class="n">ahd_debug</span><span class="p">;</span>
<span class="cp">#define AHD_SHOW_MISC		0x00001</span>
<span class="cp">#define AHD_SHOW_SENSE		0x00002</span>
<span class="cp">#define AHD_SHOW_RECOVERY	0x00004</span>
<span class="cp">#define AHD_DUMP_SEEPROM	0x00008</span>
<span class="cp">#define AHD_SHOW_TERMCTL	0x00010</span>
<span class="cp">#define AHD_SHOW_MEMORY		0x00020</span>
<span class="cp">#define AHD_SHOW_MESSAGES	0x00040</span>
<span class="cp">#define AHD_SHOW_MODEPTR	0x00080</span>
<span class="cp">#define AHD_SHOW_SELTO		0x00100</span>
<span class="cp">#define AHD_SHOW_FIFOS		0x00200</span>
<span class="cp">#define AHD_SHOW_QFULL		0x00400</span>
<span class="cp">#define	AHD_SHOW_DV		0x00800</span>
<span class="cp">#define AHD_SHOW_MASKED_ERRORS	0x01000</span>
<span class="cp">#define AHD_SHOW_QUEUE		0x02000</span>
<span class="cp">#define AHD_SHOW_TQIN		0x04000</span>
<span class="cp">#define AHD_SHOW_SG		0x08000</span>
<span class="cp">#define AHD_SHOW_INT_COALESCING	0x10000</span>
<span class="cp">#define AHD_DEBUG_SEQUENCER	0x20000</span>
<span class="cp">#endif</span>
<span class="kt">void</span>			<span class="n">ahd_print_devinfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">ahd_devinfo</span> <span class="o">*</span><span class="n">devinfo</span><span class="p">);</span>
<span class="kt">void</span>			<span class="n">ahd_dump_card_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahd_softc</span> <span class="o">*</span><span class="n">ahd</span><span class="p">);</span>
<span class="kt">int</span>			<span class="n">ahd_print_register</span><span class="p">(</span><span class="k">const</span> <span class="n">ahd_reg_parse_entry_t</span> <span class="o">*</span><span class="n">table</span><span class="p">,</span>
					   <span class="n">u_int</span> <span class="n">num_entries</span><span class="p">,</span>
					   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
					   <span class="n">u_int</span> <span class="n">address</span><span class="p">,</span>
					   <span class="n">u_int</span> <span class="n">value</span><span class="p">,</span>
					   <span class="n">u_int</span> <span class="o">*</span><span class="n">cur_column</span><span class="p">,</span>
					   <span class="n">u_int</span> <span class="n">wrap_point</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* _AIC79XX_H_ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
