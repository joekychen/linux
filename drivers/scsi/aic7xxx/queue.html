<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › scsi › aic7xxx › queue.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>queue.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (c) 1991, 1993</span>
<span class="cm"> *	The Regents of the University of California.  All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * Redistribution and use in source and binary forms, with or without</span>
<span class="cm"> * modification, are permitted provided that the following conditions</span>
<span class="cm"> * are met:</span>
<span class="cm"> * 1. Redistributions of source code must retain the above copyright</span>
<span class="cm"> *    notice, this list of conditions and the following disclaimer.</span>
<span class="cm"> * 2. Redistributions in binary form must reproduce the above copyright</span>
<span class="cm"> *    notice, this list of conditions and the following disclaimer in the</span>
<span class="cm"> *    documentation and/or other materials provided with the distribution.</span>
<span class="cm"> *</span>
<span class="cm"> * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS&#39;&#39; AND</span>
<span class="cm"> * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</span>
<span class="cm"> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</span>
<span class="cm"> * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE</span>
<span class="cm"> * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</span>
<span class="cm"> * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</span>
<span class="cm"> * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</span>
<span class="cm"> * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</span>
<span class="cm"> * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</span>
<span class="cm"> * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</span>
<span class="cm"> * SUCH DAMAGE.</span>
<span class="cm"> *</span>
<span class="cm"> *	@(#)queue.h	8.5 (Berkeley) 8/20/94</span>
<span class="cm"> * $FreeBSD: src/sys/sys/queue.h,v 1.38 2000/05/26 02:06:56 jake Exp $</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _SYS_QUEUE_H_</span>
<span class="cp">#define	_SYS_QUEUE_H_</span>

<span class="cm">/*</span>
<span class="cm"> * This file defines five types of data structures: singly-linked lists,</span>
<span class="cm"> * singly-linked tail queues, lists, tail queues, and circular queues.</span>
<span class="cm"> *</span>
<span class="cm"> * A singly-linked list is headed by a single forward pointer. The elements</span>
<span class="cm"> * are singly linked for minimum space and pointer manipulation overhead at</span>
<span class="cm"> * the expense of O(n) removal for arbitrary elements. New elements can be</span>
<span class="cm"> * added to the list after an existing element or at the head of the list.</span>
<span class="cm"> * Elements being removed from the head of the list should use the explicit</span>
<span class="cm"> * macro for this purpose for optimum efficiency. A singly-linked list may</span>
<span class="cm"> * only be traversed in the forward direction.  Singly-linked lists are ideal</span>
<span class="cm"> * for applications with large datasets and few or no removals or for</span>
<span class="cm"> * implementing a LIFO queue.</span>
<span class="cm"> *</span>
<span class="cm"> * A singly-linked tail queue is headed by a pair of pointers, one to the</span>
<span class="cm"> * head of the list and the other to the tail of the list. The elements are</span>
<span class="cm"> * singly linked for minimum space and pointer manipulation overhead at the</span>
<span class="cm"> * expense of O(n) removal for arbitrary elements. New elements can be added</span>
<span class="cm"> * to the list after an existing element, at the head of the list, or at the</span>
<span class="cm"> * end of the list. Elements being removed from the head of the tail queue</span>
<span class="cm"> * should use the explicit macro for this purpose for optimum efficiency.</span>
<span class="cm"> * A singly-linked tail queue may only be traversed in the forward direction.</span>
<span class="cm"> * Singly-linked tail queues are ideal for applications with large datasets</span>
<span class="cm"> * and few or no removals or for implementing a FIFO queue.</span>
<span class="cm"> *</span>
<span class="cm"> * A list is headed by a single forward pointer (or an array of forward</span>
<span class="cm"> * pointers for a hash table header). The elements are doubly linked</span>
<span class="cm"> * so that an arbitrary element can be removed without a need to</span>
<span class="cm"> * traverse the list. New elements can be added to the list before</span>
<span class="cm"> * or after an existing element or at the head of the list. A list</span>
<span class="cm"> * may only be traversed in the forward direction.</span>
<span class="cm"> *</span>
<span class="cm"> * A tail queue is headed by a pair of pointers, one to the head of the</span>
<span class="cm"> * list and the other to the tail of the list. The elements are doubly</span>
<span class="cm"> * linked so that an arbitrary element can be removed without a need to</span>
<span class="cm"> * traverse the list. New elements can be added to the list before or</span>
<span class="cm"> * after an existing element, at the head of the list, or at the end of</span>
<span class="cm"> * the list. A tail queue may be traversed in either direction.</span>
<span class="cm"> *</span>
<span class="cm"> * A circle queue is headed by a pair of pointers, one to the head of the</span>
<span class="cm"> * list and the other to the tail of the list. The elements are doubly</span>
<span class="cm"> * linked so that an arbitrary element can be removed without a need to</span>
<span class="cm"> * traverse the list. New elements can be added to the list before or after</span>
<span class="cm"> * an existing element, at the head of the list, or at the end of the list.</span>
<span class="cm"> * A circle queue may be traversed in either direction, but has a more</span>
<span class="cm"> * complex end of list detection.</span>
<span class="cm"> *</span>
<span class="cm"> * For details on the use of these macros, see the queue(3) manual page.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *			SLIST	LIST	STAILQ	TAILQ	CIRCLEQ</span>
<span class="cm"> * _HEAD		+	+	+	+	+</span>
<span class="cm"> * _HEAD_INITIALIZER	+	+	+	+	+</span>
<span class="cm"> * _ENTRY		+	+	+	+	+</span>
<span class="cm"> * _INIT		+	+	+	+	+</span>
<span class="cm"> * _EMPTY		+	+	+	+	+</span>
<span class="cm"> * _FIRST		+	+	+	+	+</span>
<span class="cm"> * _NEXT		+	+	+	+	+</span>
<span class="cm"> * _PREV		-	-	-	+	+</span>
<span class="cm"> * _LAST		-	-	+	+	+</span>
<span class="cm"> * _FOREACH		+	+	+	+	+</span>
<span class="cm"> * _FOREACH_REVERSE	-	-	-	+	+</span>
<span class="cm"> * _INSERT_HEAD		+	+	+	+	+</span>
<span class="cm"> * _INSERT_BEFORE	-	+	-	+	+</span>
<span class="cm"> * _INSERT_AFTER	+	+	+	+	+</span>
<span class="cm"> * _INSERT_TAIL		-	-	+	+	+</span>
<span class="cm"> * _REMOVE_HEAD		+	-	+	-	-</span>
<span class="cm"> * _REMOVE		+	+	+	+	+</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Singly-linked List declarations.</span>
<span class="cm"> */</span>
<span class="cp">#define	SLIST_HEAD(name, type)						\</span>
<span class="cp">struct name {								\</span>
<span class="cp">	struct type *slh_first;	</span><span class="cm">/* first element */</span><span class="cp">			\</span>
<span class="cp">}</span>

<span class="cp">#define	SLIST_HEAD_INITIALIZER(head)					\</span>
<span class="cp">	{ NULL }</span>
 
<span class="cp">#define	SLIST_ENTRY(type)						\</span>
<span class="cp">struct {								\</span>
<span class="cp">	struct type *sle_next;	</span><span class="cm">/* next element */</span><span class="cp">			\</span>
<span class="cp">}</span>
 
<span class="cm">/*</span>
<span class="cm"> * Singly-linked List functions.</span>
<span class="cm"> */</span>
<span class="cp">#define	SLIST_EMPTY(head)	((head)-&gt;slh_first == NULL)</span>

<span class="cp">#define	SLIST_FIRST(head)	((head)-&gt;slh_first)</span>

<span class="cp">#define	SLIST_FOREACH(var, head, field)					\</span>
<span class="cp">	for ((var) = SLIST_FIRST((head));				\</span>
<span class="cp">	    (var);							\</span>
<span class="cp">	    (var) = SLIST_NEXT((var), field))</span>

<span class="cp">#define	SLIST_INIT(head) do {						\</span>
<span class="cp">	SLIST_FIRST((head)) = NULL;					\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define	SLIST_INSERT_AFTER(slistelm, elm, field) do {			\</span>
<span class="cp">	SLIST_NEXT((elm), field) = SLIST_NEXT((slistelm), field);	\</span>
<span class="cp">	SLIST_NEXT((slistelm), field) = (elm);				\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define	SLIST_INSERT_HEAD(head, elm, field) do {			\</span>
<span class="cp">	SLIST_NEXT((elm), field) = SLIST_FIRST((head));			\</span>
<span class="cp">	SLIST_FIRST((head)) = (elm);					\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define	SLIST_NEXT(elm, field)	((elm)-&gt;field.sle_next)</span>

<span class="cp">#define	SLIST_REMOVE(head, elm, type, field) do {			\</span>
<span class="cp">	if (SLIST_FIRST((head)) == (elm)) {				\</span>
<span class="cp">		SLIST_REMOVE_HEAD((head), field);			\</span>
<span class="cp">	}								\</span>
<span class="cp">	else {								\</span>
<span class="cp">		struct type *curelm = SLIST_FIRST((head));		\</span>
<span class="cp">		while (SLIST_NEXT(curelm, field) != (elm))		\</span>
<span class="cp">			curelm = SLIST_NEXT(curelm, field);		\</span>
<span class="cp">		SLIST_NEXT(curelm, field) =				\</span>
<span class="cp">		    SLIST_NEXT(SLIST_NEXT(curelm, field), field);	\</span>
<span class="cp">	}								\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define	SLIST_REMOVE_HEAD(head, field) do {				\</span>
<span class="cp">	SLIST_FIRST((head)) = SLIST_NEXT(SLIST_FIRST((head)), field);	\</span>
<span class="cp">} while (0)</span>

<span class="cm">/*</span>
<span class="cm"> * Singly-linked Tail queue declarations.</span>
<span class="cm"> */</span>
<span class="cp">#define	STAILQ_HEAD(name, type)						\</span>
<span class="cp">struct name {								\</span>
<span class="cp">	struct type *stqh_first;</span><span class="cm">/* first element */</span><span class="cp">			\</span>
<span class="cp">	struct type **stqh_last;</span><span class="cm">/* addr of last next element */</span><span class="cp">		\</span>
<span class="cp">}</span>

<span class="cp">#define	STAILQ_HEAD_INITIALIZER(head)					\</span>
<span class="cp">	{ NULL, &amp;(head).stqh_first }</span>

<span class="cp">#define	STAILQ_ENTRY(type)						\</span>
<span class="cp">struct {								\</span>
<span class="cp">	struct type *stqe_next;	</span><span class="cm">/* next element */</span><span class="cp">			\</span>
<span class="cp">}</span>

<span class="cm">/*</span>
<span class="cm"> * Singly-linked Tail queue functions.</span>
<span class="cm"> */</span>
<span class="cp">#define	STAILQ_EMPTY(head)	((head)-&gt;stqh_first == NULL)</span>

<span class="cp">#define	STAILQ_FIRST(head)	((head)-&gt;stqh_first)</span>

<span class="cp">#define	STAILQ_FOREACH(var, head, field)				\</span>
<span class="cp">	for((var) = STAILQ_FIRST((head));				\</span>
<span class="cp">	   (var);							\</span>
<span class="cp">	   (var) = STAILQ_NEXT((var), field))</span>

<span class="cp">#define	STAILQ_INIT(head) do {						\</span>
<span class="cp">	STAILQ_FIRST((head)) = NULL;					\</span>
<span class="cp">	(head)-&gt;stqh_last = &amp;STAILQ_FIRST((head));			\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define	STAILQ_INSERT_AFTER(head, tqelm, elm, field) do {		\</span>
<span class="cp">	if ((STAILQ_NEXT((elm), field) = STAILQ_NEXT((tqelm), field)) == NULL)\</span>
<span class="cp">		(head)-&gt;stqh_last = &amp;STAILQ_NEXT((elm), field);		\</span>
<span class="cp">	STAILQ_NEXT((tqelm), field) = (elm);				\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define	STAILQ_INSERT_HEAD(head, elm, field) do {			\</span>
<span class="cp">	if ((STAILQ_NEXT((elm), field) = STAILQ_FIRST((head))) == NULL)	\</span>
<span class="cp">		(head)-&gt;stqh_last = &amp;STAILQ_NEXT((elm), field);		\</span>
<span class="cp">	STAILQ_FIRST((head)) = (elm);					\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define	STAILQ_INSERT_TAIL(head, elm, field) do {			\</span>
<span class="cp">	STAILQ_NEXT((elm), field) = NULL;				\</span>
<span class="cp">	STAILQ_LAST((head)) = (elm);					\</span>
<span class="cp">	(head)-&gt;stqh_last = &amp;STAILQ_NEXT((elm), field);			\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define	STAILQ_LAST(head)	(*(head)-&gt;stqh_last)</span>

<span class="cp">#define	STAILQ_NEXT(elm, field)	((elm)-&gt;field.stqe_next)</span>

<span class="cp">#define	STAILQ_REMOVE(head, elm, type, field) do {			\</span>
<span class="cp">	if (STAILQ_FIRST((head)) == (elm)) {				\</span>
<span class="cp">		STAILQ_REMOVE_HEAD(head, field);			\</span>
<span class="cp">	}								\</span>
<span class="cp">	else {								\</span>
<span class="cp">		struct type *curelm = STAILQ_FIRST((head));		\</span>
<span class="cp">		while (STAILQ_NEXT(curelm, field) != (elm))		\</span>
<span class="cp">			curelm = STAILQ_NEXT(curelm, field);		\</span>
<span class="cp">		if ((STAILQ_NEXT(curelm, field) =			\</span>
<span class="cp">		     STAILQ_NEXT(STAILQ_NEXT(curelm, field), field)) == NULL)\</span>
<span class="cp">			(head)-&gt;stqh_last = &amp;STAILQ_NEXT((curelm), field);\</span>
<span class="cp">	}								\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define	STAILQ_REMOVE_HEAD(head, field) do {				\</span>
<span class="cp">	if ((STAILQ_FIRST((head)) =					\</span>
<span class="cp">	     STAILQ_NEXT(STAILQ_FIRST((head)), field)) == NULL)		\</span>
<span class="cp">		(head)-&gt;stqh_last = &amp;STAILQ_FIRST((head));		\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define	STAILQ_REMOVE_HEAD_UNTIL(head, elm, field) do {			\</span>
<span class="cp">	if ((STAILQ_FIRST((head)) = STAILQ_NEXT((elm), field)) == NULL)	\</span>
<span class="cp">		(head)-&gt;stqh_last = &amp;STAILQ_FIRST((head));		\</span>
<span class="cp">} while (0)</span>

<span class="cm">/*</span>
<span class="cm"> * List declarations.</span>
<span class="cm"> */</span>
<span class="cp">#define	LIST_HEAD(name, type)						\</span>
<span class="cp">struct name {								\</span>
<span class="cp">	struct type *lh_first;	</span><span class="cm">/* first element */</span><span class="cp">			\</span>
<span class="cp">}</span>

<span class="cp">#define	LIST_HEAD_INITIALIZER(head)					\</span>
<span class="cp">	{ NULL }</span>

<span class="cp">#define	LIST_ENTRY(type)						\</span>
<span class="cp">struct {								\</span>
<span class="cp">	struct type *le_next;	</span><span class="cm">/* next element */</span><span class="cp">			\</span>
<span class="cp">	struct type **le_prev;	</span><span class="cm">/* address of previous next element */</span><span class="cp">	\</span>
<span class="cp">}</span>

<span class="cm">/*</span>
<span class="cm"> * List functions.</span>
<span class="cm"> */</span>

<span class="cp">#define	LIST_EMPTY(head)	((head)-&gt;lh_first == NULL)</span>

<span class="cp">#define	LIST_FIRST(head)	((head)-&gt;lh_first)</span>

<span class="cp">#define	LIST_FOREACH(var, head, field)					\</span>
<span class="cp">	for ((var) = LIST_FIRST((head));				\</span>
<span class="cp">	    (var);							\</span>
<span class="cp">	    (var) = LIST_NEXT((var), field))</span>

<span class="cp">#define	LIST_INIT(head) do {						\</span>
<span class="cp">	LIST_FIRST((head)) = NULL;					\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define	LIST_INSERT_AFTER(listelm, elm, field) do {			\</span>
<span class="cp">	if ((LIST_NEXT((elm), field) = LIST_NEXT((listelm), field)) != NULL)\</span>
<span class="cp">		LIST_NEXT((listelm), field)-&gt;field.le_prev =		\</span>
<span class="cp">		    &amp;LIST_NEXT((elm), field);				\</span>
<span class="cp">	LIST_NEXT((listelm), field) = (elm);				\</span>
<span class="cp">	(elm)-&gt;field.le_prev = &amp;LIST_NEXT((listelm), field);		\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define	LIST_INSERT_BEFORE(listelm, elm, field) do {			\</span>
<span class="cp">	(elm)-&gt;field.le_prev = (listelm)-&gt;field.le_prev;		\</span>
<span class="cp">	LIST_NEXT((elm), field) = (listelm);				\</span>
<span class="cp">	*(listelm)-&gt;field.le_prev = (elm);				\</span>
<span class="cp">	(listelm)-&gt;field.le_prev = &amp;LIST_NEXT((elm), field);		\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define	LIST_INSERT_HEAD(head, elm, field) do {				\</span>
<span class="cp">	if ((LIST_NEXT((elm), field) = LIST_FIRST((head))) != NULL)	\</span>
<span class="cp">		LIST_FIRST((head))-&gt;field.le_prev = &amp;LIST_NEXT((elm), field);\</span>
<span class="cp">	LIST_FIRST((head)) = (elm);					\</span>
<span class="cp">	(elm)-&gt;field.le_prev = &amp;LIST_FIRST((head));			\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define	LIST_NEXT(elm, field)	((elm)-&gt;field.le_next)</span>

<span class="cp">#define	LIST_REMOVE(elm, field) do {					\</span>
<span class="cp">	if (LIST_NEXT((elm), field) != NULL)				\</span>
<span class="cp">		LIST_NEXT((elm), field)-&gt;field.le_prev = 		\</span>
<span class="cp">		    (elm)-&gt;field.le_prev;				\</span>
<span class="cp">	*(elm)-&gt;field.le_prev = LIST_NEXT((elm), field);		\</span>
<span class="cp">} while (0)</span>

<span class="cm">/*</span>
<span class="cm"> * Tail queue declarations.</span>
<span class="cm"> */</span>
<span class="cp">#define	TAILQ_HEAD(name, type)						\</span>
<span class="cp">struct name {								\</span>
<span class="cp">	struct type *tqh_first;	</span><span class="cm">/* first element */</span><span class="cp">			\</span>
<span class="cp">	struct type **tqh_last;	</span><span class="cm">/* addr of last next element */</span><span class="cp">		\</span>
<span class="cp">}</span>

<span class="cp">#define	TAILQ_HEAD_INITIALIZER(head)					\</span>
<span class="cp">	{ NULL, &amp;(head).tqh_first }</span>

<span class="cp">#define	TAILQ_ENTRY(type)						\</span>
<span class="cp">struct {								\</span>
<span class="cp">	struct type *tqe_next;	</span><span class="cm">/* next element */</span><span class="cp">			\</span>
<span class="cp">	struct type **tqe_prev;	</span><span class="cm">/* address of previous next element */</span><span class="cp">	\</span>
<span class="cp">}</span>

<span class="cm">/*</span>
<span class="cm"> * Tail queue functions.</span>
<span class="cm"> */</span>
<span class="cp">#define	TAILQ_EMPTY(head)	((head)-&gt;tqh_first == NULL)</span>

<span class="cp">#define	TAILQ_FIRST(head)	((head)-&gt;tqh_first)</span>

<span class="cp">#define	TAILQ_FOREACH(var, head, field)					\</span>
<span class="cp">	for ((var) = TAILQ_FIRST((head));				\</span>
<span class="cp">	    (var);							\</span>
<span class="cp">	    (var) = TAILQ_NEXT((var), field))</span>

<span class="cp">#define	TAILQ_FOREACH_REVERSE(var, head, headname, field)		\</span>
<span class="cp">	for ((var) = TAILQ_LAST((head), headname);			\</span>
<span class="cp">	    (var);							\</span>
<span class="cp">	    (var) = TAILQ_PREV((var), headname, field))</span>

<span class="cp">#define	TAILQ_INIT(head) do {						\</span>
<span class="cp">	TAILQ_FIRST((head)) = NULL;					\</span>
<span class="cp">	(head)-&gt;tqh_last = &amp;TAILQ_FIRST((head));			\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define	TAILQ_INSERT_AFTER(head, listelm, elm, field) do {		\</span>
<span class="cp">	if ((TAILQ_NEXT((elm), field) = TAILQ_NEXT((listelm), field)) != NULL)\</span>
<span class="cp">		TAILQ_NEXT((elm), field)-&gt;field.tqe_prev = 		\</span>
<span class="cp">		    &amp;TAILQ_NEXT((elm), field);				\</span>
<span class="cp">	else								\</span>
<span class="cp">		(head)-&gt;tqh_last = &amp;TAILQ_NEXT((elm), field);		\</span>
<span class="cp">	TAILQ_NEXT((listelm), field) = (elm);				\</span>
<span class="cp">	(elm)-&gt;field.tqe_prev = &amp;TAILQ_NEXT((listelm), field);		\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define	TAILQ_INSERT_BEFORE(listelm, elm, field) do {			\</span>
<span class="cp">	(elm)-&gt;field.tqe_prev = (listelm)-&gt;field.tqe_prev;		\</span>
<span class="cp">	TAILQ_NEXT((elm), field) = (listelm);				\</span>
<span class="cp">	*(listelm)-&gt;field.tqe_prev = (elm);				\</span>
<span class="cp">	(listelm)-&gt;field.tqe_prev = &amp;TAILQ_NEXT((elm), field);		\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define	TAILQ_INSERT_HEAD(head, elm, field) do {			\</span>
<span class="cp">	if ((TAILQ_NEXT((elm), field) = TAILQ_FIRST((head))) != NULL)	\</span>
<span class="cp">		TAILQ_FIRST((head))-&gt;field.tqe_prev =			\</span>
<span class="cp">		    &amp;TAILQ_NEXT((elm), field);				\</span>
<span class="cp">	else								\</span>
<span class="cp">		(head)-&gt;tqh_last = &amp;TAILQ_NEXT((elm), field);		\</span>
<span class="cp">	TAILQ_FIRST((head)) = (elm);					\</span>
<span class="cp">	(elm)-&gt;field.tqe_prev = &amp;TAILQ_FIRST((head));			\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define	TAILQ_INSERT_TAIL(head, elm, field) do {			\</span>
<span class="cp">	TAILQ_NEXT((elm), field) = NULL;				\</span>
<span class="cp">	(elm)-&gt;field.tqe_prev = (head)-&gt;tqh_last;			\</span>
<span class="cp">	*(head)-&gt;tqh_last = (elm);					\</span>
<span class="cp">	(head)-&gt;tqh_last = &amp;TAILQ_NEXT((elm), field);			\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define	TAILQ_LAST(head, headname)					\</span>
<span class="cp">	(*(((struct headname *)((head)-&gt;tqh_last))-&gt;tqh_last))</span>

<span class="cp">#define	TAILQ_NEXT(elm, field) ((elm)-&gt;field.tqe_next)</span>

<span class="cp">#define	TAILQ_PREV(elm, headname, field)				\</span>
<span class="cp">	(*(((struct headname *)((elm)-&gt;field.tqe_prev))-&gt;tqh_last))</span>

<span class="cp">#define	TAILQ_REMOVE(head, elm, field) do {				\</span>
<span class="cp">	if ((TAILQ_NEXT((elm), field)) != NULL)				\</span>
<span class="cp">		TAILQ_NEXT((elm), field)-&gt;field.tqe_prev = 		\</span>
<span class="cp">		    (elm)-&gt;field.tqe_prev;				\</span>
<span class="cp">	else								\</span>
<span class="cp">		(head)-&gt;tqh_last = (elm)-&gt;field.tqe_prev;		\</span>
<span class="cp">	*(elm)-&gt;field.tqe_prev = TAILQ_NEXT((elm), field);		\</span>
<span class="cp">} while (0)</span>

<span class="cm">/*</span>
<span class="cm"> * Circular queue declarations.</span>
<span class="cm"> */</span>
<span class="cp">#define	CIRCLEQ_HEAD(name, type)					\</span>
<span class="cp">struct name {								\</span>
<span class="cp">	struct type *cqh_first;		</span><span class="cm">/* first element */</span><span class="cp">		\</span>
<span class="cp">	struct type *cqh_last;		</span><span class="cm">/* last element */</span><span class="cp">		\</span>
<span class="cp">}</span>

<span class="cp">#define	CIRCLEQ_HEAD_INITIALIZER(head)					\</span>
<span class="cp">	{ (void *)&amp;(head), (void *)&amp;(head) }</span>

<span class="cp">#define	CIRCLEQ_ENTRY(type)						\</span>
<span class="cp">struct {								\</span>
<span class="cp">	struct type *cqe_next;		</span><span class="cm">/* next element */</span><span class="cp">		\</span>
<span class="cp">	struct type *cqe_prev;		</span><span class="cm">/* previous element */</span><span class="cp">		\</span>
<span class="cp">}</span>

<span class="cm">/*</span>
<span class="cm"> * Circular queue functions.</span>
<span class="cm"> */</span>
<span class="cp">#define	CIRCLEQ_EMPTY(head)	((head)-&gt;cqh_first == (void *)(head))</span>

<span class="cp">#define	CIRCLEQ_FIRST(head)	((head)-&gt;cqh_first)</span>

<span class="cp">#define	CIRCLEQ_FOREACH(var, head, field)				\</span>
<span class="cp">	for ((var) = CIRCLEQ_FIRST((head));				\</span>
<span class="cp">	    (var) != (void *)(head);					\</span>
<span class="cp">	    (var) = CIRCLEQ_NEXT((var), field))</span>

<span class="cp">#define	CIRCLEQ_FOREACH_REVERSE(var, head, field)			\</span>
<span class="cp">	for ((var) = CIRCLEQ_LAST((head));				\</span>
<span class="cp">	    (var) != (void *)(head);					\</span>
<span class="cp">	    (var) = CIRCLEQ_PREV((var), field))</span>

<span class="cp">#define	CIRCLEQ_INIT(head) do {						\</span>
<span class="cp">	CIRCLEQ_FIRST((head)) = (void *)(head);				\</span>
<span class="cp">	CIRCLEQ_LAST((head)) = (void *)(head);				\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define	CIRCLEQ_INSERT_AFTER(head, listelm, elm, field) do {		\</span>
<span class="cp">	CIRCLEQ_NEXT((elm), field) = CIRCLEQ_NEXT((listelm), field);	\</span>
<span class="cp">	CIRCLEQ_PREV((elm), field) = (listelm);				\</span>
<span class="cp">	if (CIRCLEQ_NEXT((listelm), field) == (void *)(head))		\</span>
<span class="cp">		CIRCLEQ_LAST((head)) = (elm);				\</span>
<span class="cp">	else								\</span>
<span class="cp">		CIRCLEQ_PREV(CIRCLEQ_NEXT((listelm), field), field) = (elm);\</span>
<span class="cp">	CIRCLEQ_NEXT((listelm), field) = (elm);				\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define	CIRCLEQ_INSERT_BEFORE(head, listelm, elm, field) do {		\</span>
<span class="cp">	CIRCLEQ_NEXT((elm), field) = (listelm);				\</span>
<span class="cp">	CIRCLEQ_PREV((elm), field) = CIRCLEQ_PREV((listelm), field);	\</span>
<span class="cp">	if (CIRCLEQ_PREV((listelm), field) == (void *)(head))		\</span>
<span class="cp">		CIRCLEQ_FIRST((head)) = (elm);				\</span>
<span class="cp">	else								\</span>
<span class="cp">		CIRCLEQ_NEXT(CIRCLEQ_PREV((listelm), field), field) = (elm);\</span>
<span class="cp">	CIRCLEQ_PREV((listelm), field) = (elm);				\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define	CIRCLEQ_INSERT_HEAD(head, elm, field) do {			\</span>
<span class="cp">	CIRCLEQ_NEXT((elm), field) = CIRCLEQ_FIRST((head));		\</span>
<span class="cp">	CIRCLEQ_PREV((elm), field) = (void *)(head);			\</span>
<span class="cp">	if (CIRCLEQ_LAST((head)) == (void *)(head))			\</span>
<span class="cp">		CIRCLEQ_LAST((head)) = (elm);				\</span>
<span class="cp">	else								\</span>
<span class="cp">		CIRCLEQ_PREV(CIRCLEQ_FIRST((head)), field) = (elm);	\</span>
<span class="cp">	CIRCLEQ_FIRST((head)) = (elm);					\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define	CIRCLEQ_INSERT_TAIL(head, elm, field) do {			\</span>
<span class="cp">	CIRCLEQ_NEXT((elm), field) = (void *)(head);			\</span>
<span class="cp">	CIRCLEQ_PREV((elm), field) = CIRCLEQ_LAST((head));		\</span>
<span class="cp">	if (CIRCLEQ_FIRST((head)) == (void *)(head))			\</span>
<span class="cp">		CIRCLEQ_FIRST((head)) = (elm);				\</span>
<span class="cp">	else								\</span>
<span class="cp">		CIRCLEQ_NEXT(CIRCLEQ_LAST((head)), field) = (elm);	\</span>
<span class="cp">	CIRCLEQ_LAST((head)) = (elm);					\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define	CIRCLEQ_LAST(head)	((head)-&gt;cqh_last)</span>

<span class="cp">#define	CIRCLEQ_NEXT(elm,field)	((elm)-&gt;field.cqe_next)</span>

<span class="cp">#define	CIRCLEQ_PREV(elm,field)	((elm)-&gt;field.cqe_prev)</span>

<span class="cp">#define	CIRCLEQ_REMOVE(head, elm, field) do {				\</span>
<span class="cp">	if (CIRCLEQ_NEXT((elm), field) == (void *)(head))		\</span>
<span class="cp">		CIRCLEQ_LAST((head)) = CIRCLEQ_PREV((elm), field);	\</span>
<span class="cp">	else								\</span>
<span class="cp">		CIRCLEQ_PREV(CIRCLEQ_NEXT((elm), field), field) =	\</span>
<span class="cp">		    CIRCLEQ_PREV((elm), field);				\</span>
<span class="cp">	if (CIRCLEQ_PREV((elm), field) == (void *)(head))		\</span>
<span class="cp">		CIRCLEQ_FIRST((head)) = CIRCLEQ_NEXT((elm), field);	\</span>
<span class="cp">	else								\</span>
<span class="cp">		CIRCLEQ_NEXT(CIRCLEQ_PREV((elm), field), field) =	\</span>
<span class="cp">		    CIRCLEQ_NEXT((elm), field);				\</span>
<span class="cp">} while (0)</span>

<span class="cp">#endif </span><span class="cm">/* !_SYS_QUEUE_H_ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
